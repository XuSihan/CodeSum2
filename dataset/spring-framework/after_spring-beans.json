[{"methodBody": ["METHOD_START", "{", "return   convertIfNecessary ( propertyName ,    oldValue ,    newValue ,    td . getType (  )  ,    td )  ;", "}", "METHOD_END"], "methodName": ["convertForProperty"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . typeConverterDelegate )     !  =    null )  ,     \" No   TypeConverterDelegate \"  )  ;", "try    {", "return   this . typeConverterDelegate . convertIfNecessary ( propertyName ,    oldValue ,    newValue ,    requiredType ,    td )  ;", "}    catch    ( ConverterNotFoundException    |    IllegalStateException   ex )     {", "ChangeEvent   pce    =    new   ChangeEvent ( getRootInstance (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,    oldValue ,    newValue )  ;", "throw   new   ConversionNotSupportedException ( pce ,    requiredType ,    ex )  ;", "}    catch    ( ConversionException    |    IllegalArgumentException   ex )     {", "ChangeEvent   pce    =    new   ChangeEvent ( getRootInstance (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,    oldValue ,    newValue )  ;", "throw   new   TypeMismatchException ( pce ,    requiredType ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["convertIfNecessary"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   desc    =    getPropertyTypeDescriptor ( tokens . canonicalName )  ;", "if    ( desc    =  =    null )     {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     \" Could   not   determine   property   type   for   auto - growing   a   default   value \"  )  ;", "}", "Object   defaultValue    =    newValue ( desc . getType (  )  ,    desc ,    tokens . canonicalName )  ;", "return   new   PropertyValue ( tokens . canonicalName ,    defaultValue )  ;", "}", "METHOD_END"], "methodName": ["createDefaultPropertyValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . autoGrowCollectionLimit ;", "}", "METHOD_END"], "methodName": ["getAutoGrowCollectionLimit"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    ( pa    =  =     ( this )  )     {", "return   nestedPath ;", "}", "return   nestedPath . substring (  (  ( Utils . getLastNestedPropertySeparatorIndex ( nestedPath )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getFinalPath"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   this . nestedPath ;", "}", "METHOD_END"], "methodName": ["getNestedPath"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . nestedPropertyAccessors )     =  =    null )     {", "this . nestedPropertyAccessors    =    new   HashMap <  >  (  )  ;", "}", ". PropertyTokenHolder   tokens    =    getPropertyNameTokens ( nestedProperty )  ;", "String   canonicalName    =    tokens . canonicalName ;", "Object   value    =    getPropertyValue ( tokens )  ;", "if    (  ( value    =  =    null )     |  |     (  ( value   instanceof   Optional )     &  &     (  !  (  (  ( Optional )     ( value )  )  . isPresent (  )  )  )  )  )     {", "if    ( isAutoGrowNestedPaths (  )  )     {", "value    =    setDefaultValue ( tokens )  ;", "} else    {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    canonicalName )  )  ;", "}", "}", "nestedPa    =    this . nestedPropertyAccessors . get ( canonicalName )  ;", "if    (  ( nestedPa    =  =    null )     |  |     (  ( nestedPa . getWrappedInstance (  )  )     !  =     ( ObjectUtils . unwrapOptional ( value )  )  )  )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  \" Creating   new   nested    \"     +     ( getClass (  )  . getSimpleName (  )  )  )     +     \"    for   property    '  \"  )     +    canonicalName )     +     \"  '  \"  )  )  ;", "}", "nestedPa    =    newNestedPropertyAccessor ( value ,     (  (  ( this . nestedPath )     +    canonicalName )     +     ( PropertyAccessor . NESTED _ PROPERTY _ SEPARATOR )  )  )  ;", "copyDefaultEditorsTo ( nestedPa )  ;", "copyCustomEditorsTo ( nestedPa ,    canonicalName )  ;", "this . nestedPropertyAccessors . put ( canonicalName ,    nestedPa )  ;", "} else    {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Using   cached   nested   property   accessor   for   property    '  \"     +    canonicalName )     +     \"  '  \"  )  )  ;", "}", "}", "return   nestedPa ;", "}", "METHOD_END"], "methodName": ["getNestedPropertyAccessor"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath )  ;", "if    ( pos    >     (  -  1  )  )     {", "String   nestedProperty    =    propertyPath . substring (  0  ,    pos )  ;", "String   nestedPath    =    propertyPath . substring (  ( pos    +     1  )  )  ;", "nestedPa    =    getNestedPropertyAccessor ( nestedProperty )  ;", "return   nestedPa . getPropertyAccessorForPropertyPath ( nestedPath )  ;", "} else    {", "return   this ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyAccessorForPropertyPath"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( propertyName ,     \" Property   name   must   not   be   null \"  )  ;", "nestedPa    =    getPropertyAccessorForPropertyPath ( propertyName )  ;", "return   nestedPa . getLocalPropertyHandler ( getFinalPath ( nestedPa ,    propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyHandler"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( tokens . keys )     !  =    null )  ,     \" No   token   keys \"  )  ;", ". PropertyTokenHolder   getterTokens    =    new    . PropertyTokenHolder ( tokens . actualName )  ;", "getterTokens . canonicalName    =    tokens . canonicalName ;", "getterTokens . keys    =    new   String [  ( tokens . keys . length )     -     1  ]  ;", "System . arraycopy ( tokens . keys ,     0  ,    getterTokens . keys ,     0  ,     (  ( tokens . keys . length )     -     1  )  )  ;", "Object   propValue ;", "try    {", "propValue    =    getPropertyValue ( getterTokens )  ;", "}    catch    ( NotReadablePropertyException   ex )     {", "throw   new   NotWritablePropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  (  \" Cannot   access   indexed   value   in   property   referenced    \"     +     \" in   indexed   property   path    '  \"  )     +     ( tokens . canonicalName )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "if    ( propValue    =  =    null )     {", "if    ( isAutoGrowNestedPaths (  )  )     {", "int   lastKeyIndex    =    tokens . canonicalName . lastIndexOf (  '  [  '  )  ;", "getterTokens . canonicalName    =    tokens . canonicalName . substring (  0  ,    lastKeyIndex )  ;", "propValue    =    setDefaultValue ( getterTokens )  ;", "} else    {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  (  \" Cannot   access   indexed   value   in   property   referenced    \"     +     \" in   indexed   property   path    '  \"  )     +     ( tokens . canonicalName )  )     +     \"  '  :    returned   null \"  )  )  ;", "}", "}", "return   propValue ;", "}", "METHOD_END"], "methodName": ["getPropertyHoldingValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "String   actualName    =    null ;", "List < String >    keys    =    new   ArrayList <  >  (  2  )  ;", "int   searchIndex    =     0  ;", "while    ( searchIndex    !  =     (  -  1  )  )     {", "int   keyStart    =    propertyName . indexOf ( PropertyAccessor . PROPERTY _ KEY _ PREFIX ,    searchIndex )  ;", "searchIndex    =     -  1  ;", "if    ( keyStart    !  =     (  -  1  )  )     {", "int   keyEnd    =    propertyName . indexOf ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX ,     ( keyStart    +     ( PropertyAccessor . PROPERTY _ KEY _ PREFIX . length (  )  )  )  )  ;", "if    ( keyEnd    !  =     (  -  1  )  )     {", "if    ( actualName    =  =    null )     {", "actualName    =    propertyName . substring (  0  ,    keyStart )  ;", "}", "String   key    =    propertyName . substring (  ( keyStart    +     ( PropertyAccessor . PROPERTY _ KEY _ PREFIX . length (  )  )  )  ,    keyEnd )  ;", "if    (  (  (  ( key . length (  )  )     >     1  )     &  &     (  ( key . startsWith (  \"  '  \"  )  )     &  &     ( key . endsWith (  \"  '  \"  )  )  )  )     |  |     (  ( key . startsWith (  \"  \\  \"  \"  )  )     &  &     ( key . endsWith (  \"  \\  \"  \"  )  )  )  )     {", "key    =    key . substring (  1  ,     (  ( key . length (  )  )     -     1  )  )  ;", "}", "keys . add ( key )  ;", "searchIndex    =    keyEnd    +     ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX . length (  )  )  ;", "}", "}", "}", ". PropertyTokenHolder   tokens    =    new    . PropertyTokenHolder (  ( actualName    !  =    null    ?    actualName    :    propertyName )  )  ;", "if    (  !  ( keys . isEmpty (  )  )  )     {", "tokens . canonicalName    +  =     (  ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )     +     ( StringUtils . collectionToDelimitedString ( keys ,     (  ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )     +     ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )  )  )  )  )     +     ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )  ;", "tokens . keys    =    StringUtils . toStringArray ( keys )  ;", "}", "return   tokens ;", "}", "METHOD_END"], "methodName": ["getPropertyNameTokens"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "String   propertyName    =    tokens . canonicalName ;", "String   actualName    =    tokens . actualName ;", ". PropertyHandler   ph    =    getLocalPropertyHandler ( actualName )  ;", "if    (  ( ph    =  =    null )     |  |     (  !  ( ph . isReadable (  )  )  )  )     {", "throw   new   NotReadablePropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  )  ;", "}", "try    {", "Object   value    =    ph . getValue (  )  ;", "if    (  ( tokens . keys )     !  =    null )     {", "if    ( value    =  =    null )     {", "if    ( isAutoGrowNestedPaths (  )  )     {", "value    =    setDefaultValue ( new    . PropertyTokenHolder ( tokens . actualName )  )  ;", "} else    {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  (  \" Cannot   access   indexed   value   of   property   referenced   in   indexed    \"     +     \" property   path    '  \"  )     +    propertyName )     +     \"  '  :    returned   null \"  )  )  ;", "}", "}", "StringBuilder   indexedPropertyName    =    new   StringBuilder ( tokens . actualName )  ;", "for    ( int   i    =     0  ;    i    <     ( tokens . keys . length )  ;    i +  +  )     {", "String   key    =    tokens . keys [ i ]  ;", "if    ( value    =  =    null )     {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  (  \" Cannot   access   indexed   value   of   property   referenced   in   indexed    \"     +     \" property   path    '  \"  )     +    propertyName )     +     \"  '  :    returned   null \"  )  )  ;", "} else", "if    ( value . getClass (  )  . isArray (  )  )     {", "int   index    =    Integer . parseInt ( key )  ;", "value    =    growArrayIfNecessary ( value ,    index ,    indexedPropertyName . toString (  )  )  ;", "value    =    get ( value ,    index )  ;", "} else", "if    ( value   instanceof   List )     {", "int   index    =    Integer . parseInt ( key )  ;", "List < Object >    list    =     (  ( List < Object >  )     ( value )  )  ;", "growCollectionIfNecessary ( list ,    index ,    indexedPropertyName . toString (  )  ,    ph ,     ( i    +     1  )  )  ;", "value    =    list . get ( index )  ;", "} else", "if    ( value   instanceof   Set )     {", "Set < Object >    set    =     (  ( Set < Object >  )     ( value )  )  ;", "int   index    =    Integer . parseInt ( key )  ;", "if    (  ( index    <     0  )     |  |     ( index    >  =     ( set . size (  )  )  )  )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  (  (  (  (  \" Cannot   get   element   with   index    \"     +    index )     +     \"    from   Set   of   size    \"  )     +     ( set . size (  )  )  )     +     \"  ,    accessed   using   property   path    '  \"  )     +    propertyName )     +     \"  '  \"  )  )  ;", "}", "Iterator < Object >    it    =    set . iterator (  )  ;", "for    ( int   j    =     0  ;    it . hasNext (  )  ;    j +  +  )     {", "Object   elem    =    it . next (  )  ;", "if    ( j    =  =    index )     {", "value    =    elem ;", "break ;", "}", "}", "} else", "if    ( value   instanceof   Map )     {", "Map < Object ,    Object >    map    =     (  ( Map < Object ,    Object >  )     ( value )  )  ;", "Class <  ?  >    mapKeyType    =    ph . getResolvableType (  )  . getNested (  ( i    +     1  )  )  . asMap (  )  . resolveGeneric (  0  )  ;", "TypeDescriptor   typeDescriptor    =    valueOf ( mapKeyType )  ;", "Object   convertedMapKey    =    convertIfNecessary ( null ,    null ,    key ,    mapKeyType ,    typeDescriptor )  ;", "value    =    map . get ( convertedMapKey )  ;", "} else    {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  (  (  \" Property   referenced   in   indexed   property   path    '  \"     +    propertyName )     +     \"  '    is   neither   an   array   nor   a   List   nor   a   Set   nor   a   Map ;    returned   value   was    [  \"  )     +    value )     +     \"  ]  \"  )  )  ;", "}", "indexedPropertyName . append ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )  . append ( key )  . append ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )  ;", "}", "}", "return   value ;", "}    catch    ( IndexOutOfBoundsException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  \" Index   of   out   of   bounds   in   property   path    '  \"     +    propertyName )     +     \"  '  \"  )  ,    ex )  ;", "}    catch    ( NumberFormatException    |    TypeMismatchException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  \" Invalid   index   in   property   path    '  \"     +    propertyName )     +     \"  '  \"  )  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  \" Getter   for   property    '  \"     +    actualName )     +     \"  '    threw   exception \"  )  ,    ex )  ;", "}    catch    ( Exception   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    propertyName )  ,     (  (  \" Illegal   attempt   to   get   property    '  \"     +    actualName )     +     \"  '    threw   exception \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getRootInstance (  )  . getClass (  )  ;", "}", "METHOD_END"], "methodName": ["getRootClass"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . rootObject )     !  =    null )  ,     \" No   root   object \"  )  ;", "return   this . rootObject ;", "}", "METHOD_END"], "methodName": ["getRootInstance"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "return   getWrappedInstance (  )  . getClass (  )  ;", "}", "METHOD_END"], "methodName": ["getWrappedClass"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . wrappedObject )     !  =    null )  ,     \" No   wrapped   object \"  )  ;", "return   this . wrappedObject ;", "}", "METHOD_END"], "methodName": ["getWrappedInstance"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isAutoGrowNestedPaths (  )  )  )     {", "return   array ;", "}", "int   length    =    Array . getLength ( array )  ;", "if    (  ( index    >  =    length )     &  &     ( index    <     ( this . autoGrowCollectionLimit )  )  )     {", "Class <  ?  >    componentType    =    array . getClass (  )  . getComponentType (  )  ;", "Object   newArray    =    Array . newInstance ( componentType ,     ( index    +     1  )  )  ;", "System . arraycopy ( array ,     0  ,    newArray ,     0  ,    length )  ;", "for    ( int   i    =    length ;    i    <     ( Array . getLength ( newArray )  )  ;    i +  +  )     {", "Array . set ( newArray ,    i ,    newValue ( componentType ,    null ,    name )  )  ;", "}", "setValue ( name ,    newArray )  ;", "Object   defaultValue    =    getValue ( name )  ;", "Assert . state (  ( defaultValue    !  =    null )  ,     \" Default   value   must   not   be   null \"  )  ;", "return   defaultValue ;", "} else    {", "return   array ;", "}", "}", "METHOD_END"], "methodName": ["growArrayIfNecessary"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isAutoGrowNestedPaths (  )  )  )     {", "return ;", "}", "int   size    =    collection . size (  )  ;", "if    (  ( index    >  =    size )     &  &     ( index    <     ( this . autoGrowCollectionLimit )  )  )     {", "Class <  ?  >    elementType    =    ph . getResolvableType (  )  . geed ( nestingLevel )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( elementType    !  =    null )     {", "for    ( int   i    =    collection . size (  )  ;    i    <     ( index    +     1  )  ;    i +  +  )     {", "collection . add ( newValue ( elementType ,    null ,    name )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["growCollectionIfNecessary"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( type . isArray (  )  )     {", "Class <  ?  >    componentType    =    type . getComponentType (  )  ;", "if    ( componentType . isArray (  )  )     {", "Object   array    =    Array . newInstance ( componentType ,     1  )  ;", "Array . set ( array ,     0  ,    Array . newInstance ( componentType . getComponentType (  )  ,     0  )  )  ;", "return   array ;", "} else    {", "return   Array . newInstance ( componentType ,     0  )  ;", "}", "} else", "if    ( isAssignableFrom ( type )  )     {", "core . convert . TypeDescriptor   elementDesc    =     ( desc    !  =    null )     ?    desc . getElementTypeDescriptor (  )     :    null ;", "return   core . CollectionFactory . createCollection ( type ,     ( elementDesc    !  =    null    ?    elementDesc . getType (  )     :    null )  ,     1  6  )  ;", "} else", "if    ( isAssignableFrom ( type )  )     {", "core . convert . TypeDescriptor   keyDesc    =     ( desc    !  =    null )     ?    desc . getMapKeyTypeDescriptor (  )     :    null ;", "return   core . CollectionFactory . createMap ( type ,     ( keyDesc    !  =    null    ?    keyDesc . getType (  )     :    null )  ,     1  6  )  ;", "} else    {", "Constructor <  ?  >    ctor    =    type . getDeclaredConstructor (  )  ;", "if    ( isPrivate ( ctor . getModifiers (  )  )  )     {", "throw   new   IllegalAccessException (  (  \" Auto - growing   not   allowed   with   private   constructor :     \"     +    ctor )  )  ;", "}", "return   BeanUtils . instantiateClass ( ctor )  ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   NullValueInNestedPathException ( getRootClass (  )  ,     (  ( this . nestedPath )     +    name )  ,     (  (  \" Could   not   instantiate   property   type    [  \"     +     ( type . getName (  )  )  )     +     \"  ]    to   auto - grow   nested   property   path \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["newValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "Object   propValue    =    getPropertyHoldingValue ( tokens )  ;", ". PropertyHandler   ph    =    getLocalPropertyHandler ( tokens . actualName )  ;", "if    ( ph    =  =    null )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . actualName )  )  ,     \" No   property   handler   found \"  )  ;", "}", "Assert . state (  (  ( tokens . keys )     !  =    null )  ,     \" No   token   keys \"  )  ;", "String   lastKey    =    tokens . keys [  (  ( tokens . keys . length )     -     1  )  ]  ;", "if    ( propValue . getClass (  )  . isArray (  )  )     {", "Class <  ?  >    requiredType    =    propValue . getClass (  )  . getComponentType (  )  ;", "int   arrayIndex    =    Integer . parseInt ( lastKey )  ;", "Object   oldValue    =    null ;", "try    {", "if    (  ( isExtractOldValueForEditor (  )  )     &  &     ( arrayIndex    <     ( Array . getLength ( propValue )  )  )  )     {", "oldValue    =    Array . get ( propValue ,    arrayIndex )  ;", "}", "Object   convertedValue    =    convertIfNecessary ( tokens . canonicalName ,    oldValue ,    pv . getValue (  )  ,    requiredType ,    ph . nested ( tokens . keys . length )  )  ;", "int   length    =    Array . getLength ( propValue )  ;", "if    (  ( arrayIndex    >  =    length )     &  &     ( arrayIndex    <     ( this . autoGrowCollectionLimit )  )  )     {", "Class <  ?  >    componentType    =    propValue . getClass (  )  . getComponentType (  )  ;", "Object   newArray    =    Array . newInstance ( componentType ,     ( arrayIndex    +     1  )  )  ;", "System . arraycopy ( propValue ,     0  ,    newArray ,     0  ,    length )  ;", "setPropertyValue ( tokens . actualName ,    newArray )  ;", "propValue    =    getPropertyValue ( tokens . actualName )  ;", "}", "Array . set ( propValue ,    arrayIndex ,    convertedValue )  ;", "}    catch    ( IndexOutOfBoundsException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  \" Invalid   array   index   in   property   path    '  \"     +     ( tokens . canonicalName )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "} else", "if    ( propValue   instanceof   List )     {", "Class <  ?  >    requiredType    =    ph . getCollectionType ( tokens . keys . length )  ;", "List < Object >    list    =     (  ( List < Object >  )     ( propValue )  )  ;", "int   index    =    Integer . parseInt ( lastKey )  ;", "Object   oldValue    =    null ;", "if    (  ( isExtractOldValueForEditor (  )  )     &  &     ( index    <     ( list . size (  )  )  )  )     {", "oldValue    =    list . get ( index )  ;", "}", "Object   convertedValue    =    convertIfNecessary ( tokens . canonicalName ,    oldValue ,    pv . getValue (  )  ,    requiredType ,    ph . nested ( tokens . keys . length )  )  ;", "int   size    =    list . size (  )  ;", "if    (  ( index    >  =    size )     &  &     ( index    <     ( this . autoGrowCollectionLimit )  )  )     {", "for    ( int   i    =    size ;    i    <    index ;    i +  +  )     {", "try    {", "list . add ( null )  ;", "}    catch    ( NullPointerException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  (  (  (  (  \" Cannot   set   element   with   index    \"     +    index )     +     \"    in   List   of   size    \"  )     +    size )     +     \"  ,    accessed   using   property   path    '  \"  )     +     ( tokens . canonicalName )  )     +     \"  '  :    List   does   not   support   filling   up   gaps   with   null   elements \"  )  )  ;", "}", "}", "list . add ( convertedValue )  ;", "} else    {", "try    {", "list . set ( index ,    convertedValue )  ;", "}    catch    ( IndexOutOfBoundsException   ex )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  \" Invalid   list   index   in   property   path    '  \"     +     ( tokens . canonicalName )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "} else", "if    ( propValue   instanceof   Map )     {", "Class <  ?  >    mapKeyType    =    ph . getMapKeyType ( tokens . keys . length )  ;", "Class <  ?  >    mapValueType    =    ph . getMapValueType ( tokens . keys . length )  ;", "Map < Object ,    Object >    map    =     (  ( Map < Object ,    Object >  )     ( propValue )  )  ;", "TypeDescriptor   typeDescriptor    =    valueOf ( mapKeyType )  ;", "Object   convertedMapKey    =    convertIfNecessary ( null ,    null ,    lastKey ,    mapKeyType ,    typeDescriptor )  ;", "Object   oldValue    =    null ;", "if    ( isExtractOldValueForEditor (  )  )     {", "oldValue    =    map . get ( convertedMapKey )  ;", "}", "Object   convertedMapValue    =    convertIfNecessary ( tokens . canonicalName ,    oldValue ,    pv . getValue (  )  ,    mapValueType ,    ph . nested ( tokens . keys . length )  )  ;", "map . put ( convertedMapKey ,    convertedMapValue )  ;", "} else    {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,     (  (  (  (  \" Property   referenced   in   indexed   property   path    '  \"     +     ( tokens . canonicalName )  )     +     \"  '    is   neither   an   array   nor   a   List   nor   a   Map ;    returned   value   was    [  \"  )     +    propValue )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processKeyedProperty"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "AbstractNestablePropertyAccessor . PropertyHandler   ph    =    getLocalPropertyHandler ( tokens . actualName )  ;", "if    (  ( ph    =  =    null )     |  |     (  !  ( ph . isWritable (  )  )  )  )     {", "if    ( pv . isOptional (  )  )     {", "if    ( AbstractNestablePropertyAccessor . logger . isDebugEnabled (  )  )     {", "AbstractNestablePropertyAccessor . logger . debug (  (  (  (  (  \" Ignoring   optional   value   for   property    '  \"     +     ( tokens . actualName )  )     +     \"  '     -    property   not   found   on   bean   class    [  \"  )     +     ( getRootClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "return ;", "} else    {", "throw   createNotWritablePropertyException ( tokens . canonicalName )  ;", "}", "}", "Object   oldValue    =    null ;", "try    {", "Object   originalValue    =    pv . getValue (  )  ;", "Object   valueToApply    =    originalValue ;", "if    (  !  ( Boolean . FALSE . equals ( pv . conversionNecessary )  )  )     {", "if    ( pv . isConverted (  )  )     {", "valueToApply    =    pv . getConvertedValue (  )  ;", "} else    {", "if    (  ( isExtractOldValueForEditor (  )  )     &  &     ( ph . isReadable (  )  )  )     {", "try    {", "oldValue    =    ph . getValue (  )  ;", "}    catch    ( Exception   ex )     {", "if    ( ex   instanceof   PrivilegedActionException )     {", "ex    =     (  ( PrivilegedActionException )     ( ex )  )  . getException (  )  ;", "}", "if    ( AbstractNestablePropertyAccessor . logger . isDebugEnabled (  )  )     {", "AbstractNestablePropertyAccessor . logger . debug (  (  (  (  \" Could   not   read   previous   value   of   property    '  \"     +     ( this . nestedPath )  )     +     ( tokens . canonicalName )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "valueToApply    =    convertForProperty ( tokens . canonicalName ,    oldValue ,    originalValue ,    ph . toTypeDescriptor (  )  )  ;", "}", "pv . getOriginalPropertyValue (  )  . conversionNecessary    =    valueToApply    !  =    originalValue ;", "}", "ph . setValue ( valueToApply )  ;", "}    catch    ( TypeMismatchException   ex )     {", "throw   ex ;", "}    catch    ( InvocationTargetException   ex )     {", "PropertyChangeEvent   propertyChangeEvent    =    new   PropertyChangeEvent ( getRootInstance (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,    oldValue ,    pv . getValue (  )  )  ;", "if    (  ( ex . getTargetException (  )  )    instanceof   ClassCastException )     {", "throw   new   TypeMismatchException ( propertyChangeEvent ,    ph . getPropertyType (  )  ,    ex . getTargetException (  )  )  ;", "} else    {", "Throwable   cause    =    ex . getTargetException (  )  ;", "if    ( cause   instanceof   UndeclaredThrowableException )     {", "cause    =    cause . getCause (  )  ;", "}", "throw   new   MethodInvocationException ( propertyChangeEvent ,    cause )  ;", "}", "}    catch    ( Exception   ex )     {", "PropertyChangeEvent   pce    =    new   PropertyChangeEvent ( getRootInstance (  )  ,     (  ( this . nestedPath )     +     ( tokens . canonicalName )  )  ,    oldValue ,    pv . getValue (  )  )  ;", "throw   new   MethodInvocationException ( pce ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["processLocalProperty"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "this . autoGrowCollectionLimit    =    autoGrowCollectionLimit ;", "}", "METHOD_END"], "methodName": ["setAutoGrowCollectionLimit"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "PropertyValue   pv    =    createDefaultPropertyValue ( tokens )  ;", "setPropertyValue ( tokens ,    pv )  ;", "Object   defaultValue    =    getPropertyValue ( tokens )  ;", "Assert . state (  ( defaultValue    !  =    null )  ,     \" Default   value   must   not   be   null \"  )  ;", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["setDefaultValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tokens . keys )     !  =    null )     {", "processKeyed ( tokens ,    pv )  ;", "} else    {", "processLocal ( tokens ,    pv )  ;", "}", "}", "METHOD_END"], "methodName": ["setPropertyValue"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "setWrappedInstance ( object ,     \"  \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["setWrappedInstance"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "this . wrappedObject    =    ObjectUtils . unwrapOptional ( object )  ;", "Assert . notNull ( this . wrappedObject ,     \" Target   object   must   not   be   null \"  )  ;", "this . nestedPath    =     ( nestedPath    !  =    null )     ?    nestedPath    :     \"  \"  ;", "this . rootObject    =     (  !  (  \"  \"  . equals ( this . nestedPath )  )  )     ?    rootObject    :    this . wrappedObject ;", "this . nesteds    =    null ;", "this . typeConverterDelegate    =    new   TypeConverterDelegate ( this ,    this . wrappedObject )  ;", "}", "METHOD_END"], "methodName": ["setWrappedInstance"], "fileName": "org.springframework.beans.AbstractNestablePropertyAccessor"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Spr 1  0  1  1  5 Bean   target    =    new   AbstractPropertyAccessorTests . Spr 1  0  1  1  5 Bean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" prop 1  \"  ,     \" val 1  \"  )  ;", "assertEquals (  \" val 1  \"  ,    AbstractPropertyAccessorTests . Spr 1  0  1  1  5 Bean . prop 1  )  ;", "}", "METHOD_END"], "methodName": ["cornerSpr10115"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Spr 1  3  8  3  7 Bean   target    =    new   AbstractPropertyAccessorTests . Spr 1  3  8  3  7 Bean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" something \"  ,     4  2  )  ;", "assertEquals ( Integer . valueOf (  4  2  )  ,    target . something )  ;", "}", "METHOD_END"], "methodName": ["cornerSpr13837"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractPropertyAccessorTests . Person ( name ,    new   AbstractPropertyAccessorTests . Address ( city ,    country )  )  ;", "}", "METHOD_END"], "methodName": ["createPerson"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "create ( null )  ;", "fail (  \" Must   throw   an   exception   when   constructed   with   null   object \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["createWithNullTarget"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "TestBean   tb 0     =    target . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    target . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( target . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( target . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 6     =     (  ( TestBean )     ( target . getSet (  )  . toArray (  )  [  0  ]  )  )  ;", "TestBean   tb 7     =     (  ( TestBean )     ( target . getSet (  )  . toArray (  )  [  1  ]  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( target . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( target . getMap (  )  . get (  \" key .  3  \"  )  )  )  ;", "assertEquals (  \" name 0  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 6  \"  ,    tb 6  . getName (  )  )  ;", "assertEquals (  \" name 7  \"  ,    tb 7  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    accessor . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    accessor . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    accessor . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    accessor . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 6  \"  ,    accessor . getPropertyValue (  \" set [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 7  \"  ,    accessor . getPropertyValue (  \" set [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    accessor . getPropertyValue (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    accessor . getPropertyValue (  \" map [ key .  3  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    accessor . getPropertyValue (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    accessor . getPropertyValue (  \" map [  \\  \" key .  3  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" nameX \"  ,    accessor . getPropertyValue (  \" map [ key 4  ]  [  0  ]  . name \"  )  )  ;", "assertEquals (  \" nameY \"  ,    accessor . getPropertyValue (  \" map [ key 4  ]  [  1  ]  . name \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" set [  0  ]  . name \"  ,     \" name 8  \"  )  ;", "pvs . add (  \" set [  1  ]  . name \"  ,     \" name 9  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key .  3  '  ]  . name \"  ,     \" name 0  \"  )  ;", "pvs . add (  \" map [ key 4  ]  [  0  ]  . name \"  ,     \" nameA \"  )  ;", "pvs . add (  \" map [ key 4  ]  [  1  ]  . name \"  ,     \" nameB \"  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertEquals (  \" name 5  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    accessor . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    accessor . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    accessor . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    accessor . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 8  \"  ,    accessor . getPropertyValue (  \" set [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 9  \"  ,    accessor . getPropertyValue (  \" set [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    accessor . getPropertyValue (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" name 0  \"  ,    accessor . getPropertyValue (  \" map [  ' key .  3  '  ]  . name \"  )  )  ;", "assertEquals (  \" nameA \"  ,    accessor . getPropertyValue (  \" map [ key 4  ]  [  0  ]  . name \"  )  )  ;", "assertEquals (  \" nameB \"  ,    accessor . getPropertyValue (  \" map [ key 4  ]  [  1  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAndSetIndexedProperties"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "TestBean   tb 0     =    target . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    target . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( target . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( target . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 6     =     (  ( TestBean )     ( target . getSet (  )  . toArray (  )  [  0  ]  )  )  ;", "TestBean   tb 7     =     (  ( TestBean )     ( target . getSet (  )  . toArray (  )  [  1  ]  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( target . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( target . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "assertEquals ( tb 0  ,    accessor . getPropertyValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals ( tb 1  ,    accessor . getPropertyValue (  \" array [  1  ]  \"  )  )  ;", "assertEquals ( tb 2  ,    accessor . getPropertyValue (  \" list [  0  ]  \"  )  )  ;", "assertEquals ( tb 3  ,    accessor . getPropertyValue (  \" list [  1  ]  \"  )  )  ;", "assertEquals ( tb 6  ,    accessor . getPropertyValue (  \" set [  0  ]  \"  )  )  ;", "assertEquals ( tb 7  ,    accessor . getPropertyValue (  \" set [  1  ]  \"  )  )  ;", "assertEquals ( tb 4  ,    accessor . getPropertyValue (  \" map [ key 1  ]  \"  )  )  ;", "assertEquals ( tb 5  ,    accessor . getPropertyValue (  \" map [ key 2  ]  \"  )  )  ;", "assertEquals ( tb 4  ,    accessor . getPropertyValue (  \" map [  ' key 1  '  ]  \"  )  )  ;", "assertEquals ( tb 5  ,    accessor . getPropertyValue (  \" map [  \\  \" key 2  \\  \"  ]  \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,    tb 5  )  ;", "pvs . add (  \" array [  1  ]  \"  ,    tb 4  )  ;", "pvs . add (  \" list [  0  ]  \"  ,    tb 3  )  ;", "pvs . add (  \" list [  1  ]  \"  ,    tb 2  )  ;", "pvs . add (  \" list [  2  ]  \"  ,    tb 0  )  ;", "pvs . add (  \" list [  4  ]  \"  ,    tb 1  )  ;", "pvs . add (  \" map [ key 1  ]  \"  ,    tb 1  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  \"  ,    tb 0  )  ;", "pvs . add (  \" map [ key 5  ]  \"  ,    tb 4  )  ;", "pvs . add (  \" map [  ' key 9  '  ]  \"  ,    tb 5  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertEquals ( tb 5  ,    target . getArray (  )  [  0  ]  )  ;", "assertEquals ( tb 4  ,    target . getArray (  )  [  1  ]  )  ;", "assertEquals ( tb 3  ,    target . getList (  )  . get (  0  )  )  ;", "assertEquals ( tb 2  ,    target . getList (  )  . get (  1  )  )  ;", "assertEquals ( tb 0  ,    target . getList (  )  . get (  2  )  )  ;", "assertEquals ( null ,    target . getList (  )  . get (  3  )  )  ;", "assertEquals ( tb 1  ,    target . getList (  )  . get (  4  )  )  ;", "assertEquals ( tb 1  ,    target . getMap (  )  . get (  \" key 1  \"  )  )  ;", "assertEquals ( tb 0  ,    target . getMap (  )  . get (  \" key 2  \"  )  )  ;", "assertEquals ( tb 4  ,    target . getMap (  )  . get (  \" key 5  \"  )  )  ;", "assertEquals ( tb 5  ,    target . getMap (  )  . get (  \" key 9  \"  )  )  ;", "assertEquals ( tb 5  ,    accessor . getPropertyValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals ( tb 4  ,    accessor . getPropertyValue (  \" array [  1  ]  \"  )  )  ;", "assertEquals ( tb 3  ,    accessor . getPropertyValue (  \" list [  0  ]  \"  )  )  ;", "assertEquals ( tb 2  ,    accessor . getPropertyValue (  \" list [  1  ]  \"  )  )  ;", "assertEquals ( tb 0  ,    accessor . getPropertyValue (  \" list [  2  ]  \"  )  )  ;", "assertEquals ( null ,    accessor . getPropertyValue (  \" list [  3  ]  \"  )  )  ;", "assertEquals ( tb 1  ,    accessor . getPropertyValue (  \" list [  4  ]  \"  )  )  ;", "assertEquals ( tb 1  ,    accessor . getPropertyValue (  \" map [  \\  \" key 1  \\  \"  ]  \"  )  )  ;", "assertEquals ( tb 0  ,    accessor . getPropertyValue (  \" map [  ' key 2  '  ]  \"  )  )  ;", "assertEquals ( tb 4  ,    accessor . getPropertyValue (  \" map [  \\  \" key 5  \\  \"  ]  \"  )  )  ;", "assertEquals ( tb 5  ,    accessor . getPropertyValue (  \" map [  ' key 9  '  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getAndSetIndexedPropertiesWithDirectAccess"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  \" rod \"  ,     3  1  )  ;", "ITestBean   kerry    =    new   TestBean (  \" kerry \"  ,     3  5  )  ;", "target . setSpouse ( kerry )  ;", "kerry . setSpouse ( target )  ;", "accessor    =    createAccessor ( target )  ;", "Integer   KA    =     (  ( Integer )     ( accessor . getPropertyValue (  \" spouse . age \"  )  )  )  ;", "assertTrue (  \" kerry   is    3  5  \"  ,     ( KA    =  =     3  5  )  )  ;", "Integer   RA    =     (  ( Integer )     ( accessor . getPropertyValue (  \" spouse . spouse . age \"  )  )  )  ;", "assertTrue (  (  \" rod   is    3  1  ,    not \"     +    RA )  ,     ( RA    =  =     3  1  )  )  ;", "ITestBean   spousesSpouse    =     (  ( ITestBean )     ( accessor . getPropertyValue (  \" spouse . spouse \"  )  )  )  ;", "assertTrue (  \" spousesSpouse    =    initial   point \"  ,     ( target    =  =    spousesSpouse )  )  ;", "}", "METHOD_END"], "methodName": ["getAnotherNestedDeepProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" London \"  ,     \" UK \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyValue (  \" address . country . name \"  )  ,    is (  \" UK \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getNestedDeepProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" London \"  ,     \" UK \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyValue (  \" address . city \"  )  ,    is (  \" London \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Foo   target    =    new   AbstractPropertyAccessorTests . Foo (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setConversionService ( new   DefaultConversionService (  )  )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" listOfMaps [  0  ]  [  ' luckyNumber '  ]  \"  ,     \"  9  \"  )  ;", "assertEquals (  \"  9  \"  ,    target . listOfMaps . get (  0  )  . get (  \" luckyNumber \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyIntermediateMapEntryIsNullWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" London \"  ,     \" UK \"  )  ;", "target . address    =    null ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . getPropertyValue (  \" address . country . name \"  )  ;", "fail (  \" Should   have   failed   to   get   value   with   null   intermediate   path \"  )  ;", "}    catch    ( NullValueInNestedPathException   e )     {", "assertEquals (  \" address \"  ,    e . getPropertyName (  )  )  ;", "assertEquals ( AbstractPropertyAccessorTests . Person . class ,    e . getBeanClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyIntermediatePropertyIsNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" London \"  ,     \" UK \"  )  ;", "target . address    =    null ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "assertEquals (  \" DefaultCountry \"  ,    accessor . getPropertyValue (  \" address . country . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyIntermediatePropertyIsNullWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyValue (  \" name \"  )  ,    is (  \" John \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" London \"  ,     \" UK \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "thrown . expect ( NotReadablePropertyException . class )  ;", "accessor . getPropertyValue (  \" address . bar \"  )  ;", "}", "METHOD_END"], "methodName": ["getUnknownNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . getPropertyValue (  \" foo \"  )  ;", "fail (  \" Should   have   failed   to   get   an   unknown   property .  \"  )  ;", "}    catch    ( NotReadablePropertyException   e )     {", "assertEquals ( AbstractPropertyAccessorTests . Simple . class ,    e . getBeanClass (  )  )  ;", "assertEquals (  \" foo \"  ,    e . getPropertyName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getUnknownProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  )  ;", "assertThat ( accessor . isReadableProperty (  \" name \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["isReadableProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . NoRead (  )  )  ;", "assertFalse ( accessor . isReadableProperty (  \" xxxxx \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isReadablePropertyNoSuchProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . NoRead (  )  )  ;", "assertFalse ( accessor . isReadableProperty (  \" age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isReadablePropertyNotReadable"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . NoRead (  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "accessor . isReadableProperty ( null )  ;", "}", "METHOD_END"], "methodName": ["isReadablePropertyNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "assertTrue ( accessor . isReadableProperty (  \" array \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" list \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" set \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map \"  )  )  ;", "assertFalse ( accessor . isReadableProperty (  \" xxx \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" array \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" list \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" set \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map \"  )  )  ;", "assertFalse ( accessor . isWritableProperty (  \" xxx \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" array [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" array [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" list [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" list [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" set [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" set [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 1  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 1  ]  . name \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 4  ]  [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 4  ]  [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 4  ]  [  1  ]  \"  )  )  ;", "assertTrue ( accessor . isReadableProperty (  \" map [ key 4  ]  [  1  ]  . name \"  )  )  ;", "assertFalse ( accessor . isReadableProperty (  \" array [ key 1  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" array [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" array [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" list [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" list [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" set [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" set [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 1  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 1  ]  . name \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 4  ]  [  0  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 4  ]  [  0  ]  . name \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 4  ]  [  1  ]  \"  )  )  ;", "assertTrue ( accessor . isWritableProperty (  \" map [ key 4  ]  [  1  ]  . name \"  )  )  ;", "assertFalse ( accessor . isWritableProperty (  \" array [ key 1  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isReadableWritableForIndexedProperties"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  )  ;", "assertThat ( accessor . isWritableProperty (  \" name \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["isWritableProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . NoRead (  )  )  ;", "assertFalse ( accessor . isWritableProperty (  \" xxxxx \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isWritablePropertyNoSuchProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessor   accessor    =    createAccessor ( new   AbstractPropertyAccessorTests . NoRead (  )  )  ;", "thrown . expect ( IllegalArgumentException . class )  ;", "accessor . isWritableProperty ( null )  ;", "}", "METHOD_END"], "methodName": ["isWritablePropertyNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertEquals ( String . class ,    accessor . getPropertyType (  \" address . city \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyType"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyTypeDescriptor (  \" address . city \"  )  ,    is ( notNullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyTypeDescriptor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyTypeDescriptor (  \" foo \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyTypeDescriptorUnknownProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "assertEquals ( null ,    accessor . getPropertyType (  \" map [ key 0  ]  \"  )  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" map [ key 0  ]  \"  ,     \" my   String \"  )  ;", "assertEquals ( String . class ,    accessor . getPropertyType (  \" map [ key 0  ]  \"  )  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String . class ,     \" map [ key 0  ]  \"  ,    new   StringTrimmerEditor ( false )  )  ;", "assertEquals ( String . class ,    accessor . getPropertyType (  \" map [ key 0  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyTypeIndexedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "assertThat ( accessor . getPropertyType (  \" foo \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyTypeUnknownProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  \" rod \"  ,     3  1  )  ;", "ITestBean   kerry    =    new   TestBean (  \" kerry \"  ,     0  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" spouse \"  ,    kerry )  ;", "assertTrue (  \" nested   set   worked \"  ,     (  ( target . getSpouse (  )  )     =  =    kerry )  )  ;", "assertTrue (  \" no   back   relation \"  ,     (  ( kerry . getSpouse (  )  )     =  =    null )  )  ;", "accessor . setPropertyValue ( new   PropertyValue (  \" spouse . spouse \"  ,    target )  )  ;", "assertTrue (  \" nested   set   worked \"  ,     (  ( kerry . getSpouse (  )  )     =  =    target )  )  ;", "assertTrue (  \" kerry   age   not   set \"  ,     (  ( kerry . getAge (  )  )     =  =     0  )  )  ;", "accessor . setPropertyValue ( new   PropertyValue (  \" spouse . age \"  ,     3  5  )  )  ;", "assertTrue (  \" Set   primitive   on   spouse \"  ,     (  ( kerry . getAge (  )  )     =  =     3  5  )  )  ;", "assertEquals ( kerry ,    accessor . getPropertyValue (  \" spouse \"  )  )  ;", "assertEquals ( target ,    accessor . getPropertyValue (  \" spouse . spouse \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setAnotherNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  \" rod \"  ,     3  1  )  ;", "accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" spouse . age \"  ,    new   Integer (  3  1  )  )  ;", "fail (  \" Shouldn ' t   have   succeeded   with   null   path \"  )  ;", "}    catch    ( NullValueInNestedPathException   ex )     {", "assertTrue (  (  \" it   was   the   spouse   property   that   was   null ,    not    \"     +     ( ex . getPropertyName (  )  )  )  ,    ex . getPropertyName (  )  . equals (  \" spouse \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAnotherPropertyIntermediatePropertyIsNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . ArrayToObject   target    =    new   AbstractPropertyAccessorTests . ArrayToObject (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "Object [  ]    array    =    new   Object [  ]  {     \"  1  \"  ,     \"  2  \"     }  ;", "accessor . setPropertyValue (  \" object \"  ,    array )  ;", "assertThat ( target . getObject (  )  ,    equalTo (  (  ( Object )     ( array )  )  )  )  ;", "array    =    new   Object [  ]  {     \"  1  \"     }  ;", "accessor . setPropertyValue (  \" object \"  ,    array )  ;", "assertThat ( target . getObject (  )  ,    equalTo (  (  ( Object )     ( array )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setArrayPropertyToObject"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "BooleanTestBean   target    =    new   BooleanTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" bool 2  \"  ,     \" true \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . TRUE . equals ( accessor . getPropertyValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    target . getBool 2  (  )  )  ;", "accessor . setPropertyValue (  \" bool 2  \"  ,     \" false \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . FALSE . equals ( accessor . getPropertyValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( target . getBool 2  (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setBooleanProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Collection < String >    coll    =    new   HashSet <  >  (  )  ;", "coll . add (  \" coll 1  \"  )  ;", "accessor . setPropertyValue (  \" collection \"  ,    coll )  ;", "Set < String >    set    =    new   HashSet <  >  (  )  ;", "set . add (  \" set 1  \"  )  ;", "accessor . setPropertyValue (  \" set \"  ,    set )  ;", "SortedSet < String >    sortedSet    =    new   TreeSet <  >  (  )  ;", "sortedSet . add (  \" sortedSet 1  \"  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,    sortedSet )  ;", "List < String >    list    =    new   LinkedList <  >  (  )  ;", "list . add (  \" list 1  \"  )  ;", "accessor . setPropertyValue (  \" list \"  ,    list )  ;", "assertSame ( coll ,    target . getCollection (  )  )  ;", "assertSame ( set ,    target . getSet (  )  )  ;", "assertSame ( sortedSet ,    target . getSortedSet (  )  )  ;", "assertSame ( list ,    target . getList (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Collection < String >    coll    =    new   ArrayList <  >  (  )  ;", "coll . add (  \" coll 1  \"  )  ;", "accessor . setPropertyValue (  \" collection \"  ,    coll )  ;", "List < String >    set    =    new   LinkedList <  >  (  )  ;", "set . add (  \" set 1  \"  )  ;", "accessor . setPropertyValue (  \" set \"  ,    set )  ;", "List < String >    sortedSet    =    new   ArrayList <  >  (  )  ;", "sortedSet . add (  \" sortedSet 1  \"  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,    sortedSet )  ;", "Set < String >    list    =    new   HashSet <  >  (  )  ;", "list . add (  \" list 1  \"  )  ;", "accessor . setPropertyValue (  \" list \"  ,    list )  ;", "assertEquals (  1  ,    target . getCollection (  )  . size (  )  )  ;", "assertTrue ( target . getCollection (  )  . containsAll ( coll )  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . containsAll ( set )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . containsAll ( sortedSet )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . containsAll ( list )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyNonMatchingType"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Collection < String >    coll    =    new   HashSet <  >  (  )  ;", "coll . add (  \" coll 1  \"  )  ;", "accessor . setPropertyValue (  \" collection \"  ,    coll . toArray (  )  )  ;", "List < String >    set    =    new   LinkedList <  >  (  )  ;", "set . add (  \" set 1  \"  )  ;", "accessor . setPropertyValue (  \" set \"  ,    set . toArray (  )  )  ;", "List < String >    sortedSet    =    new   ArrayList <  >  (  )  ;", "sortedSet . add (  \" sortedSet 1  \"  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,    sortedSet . toArray (  )  )  ;", "Set < String >    list    =    new   HashSet <  >  (  )  ;", "list . add (  \" list 1  \"  )  ;", "accessor . setPropertyValue (  \" list \"  ,    list . toArray (  )  )  ;", "assertEquals (  1  ,    target . getCollection (  )  . size (  )  )  ;", "assertTrue ( target . getCollection (  )  . containsAll ( coll )  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . containsAll ( set )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . containsAll ( sortedSet )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . containsAll ( list )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyWithArrayValue"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Collection < Integer >    coll    =    new   HashSet <  >  (  )  ;", "coll . add (  0  )  ;", "accessor . setPropertyValue (  \" collection \"  ,    new   int [  ]  {     0     }  )  ;", "List < Integer >    set    =    new   LinkedList <  >  (  )  ;", "set . add (  1  )  ;", "accessor . setPropertyValue (  \" set \"  ,    new   int [  ]  {     1     }  )  ;", "List < Integer >    sortedSet    =    new   ArrayList <  >  (  )  ;", "sortedSet . add (  2  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,    new   int [  ]  {     2     }  )  ;", "Set < Integer >    list    =    new   HashSet <  >  (  )  ;", "list . add (  3  )  ;", "accessor . setPropertyValue (  \" list \"  ,    new   int [  ]  {     3     }  )  ;", "assertEquals (  1  ,    target . getCollection (  )  . size (  )  )  ;", "assertTrue ( target . getCollection (  )  . containsAll ( coll )  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . containsAll ( set )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . containsAll ( sortedSet )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . containsAll ( list )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyWithIntArrayValue"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Collection < Integer >    coll    =    new   HashSet <  >  (  )  ;", "coll . add (  0  )  ;", "accessor . setPropertyValue (  \" collection \"  ,    new   Integer (  0  )  )  ;", "List < Integer >    set    =    new   LinkedList <  >  (  )  ;", "set . add (  1  )  ;", "accessor . setPropertyValue (  \" set \"  ,    new   Integer (  1  )  )  ;", "List < Integer >    sortedSet    =    new   ArrayList <  >  (  )  ;", "sortedSet . add (  2  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,    new   Integer (  2  )  )  ;", "Set < Integer >    list    =    new   HashSet <  >  (  )  ;", "list . add (  3  )  ;", "accessor . setPropertyValue (  \" list \"  ,    new   Integer (  3  )  )  ;", "assertEquals (  1  ,    target . getCollection (  )  . size (  )  )  ;", "assertTrue ( target . getCollection (  )  . containsAll ( coll )  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . containsAll ( set )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . containsAll ( sortedSet )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . containsAll ( list )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyWithIntegerValue"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "List < String >    set    =    new   LinkedList <  >  (  )  ;", "set . add (  \" set 1  \"  )  ;", "accessor . setPropertyValue (  \" set \"  ,     \" set 1  \"  )  ;", "List < String >    sortedSet    =    new   ArrayList <  >  (  )  ;", "sortedSet . add (  \" sortedSet 1  \"  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,     \" sortedSet 1  \"  )  ;", "Set < String >    list    =    new   HashSet <  >  (  )  ;", "list . add (  \" list 1  \"  )  ;", "accessor . setPropertyValue (  \" list \"  ,     \" list 1  \"  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . containsAll ( set )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . containsAll ( sortedSet )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . containsAll ( list )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyWithStringValue"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String . class ,     \" set \"  ,    new   StringTrimmerEditor ( false )  )  ;", "accessor . registerCustomEditor ( String . class ,     \" list \"  ,    new   StringTrimmerEditor ( false )  )  ;", "accessor . setPropertyValue (  \" set \"  ,     \" set 1     \"  )  ;", "accessor . setPropertyValue (  \" sortedSet \"  ,     \" sortedSet 1  \"  )  ;", "accessor . setPropertyValue (  \" list \"  ,     \" list 1     \"  )  ;", "assertEquals (  1  ,    target . getSet (  )  . size (  )  )  ;", "assertTrue ( target . getSet (  )  . contains (  \" set 1  \"  )  )  ;", "assertEquals (  1  ,    target . getSortedSet (  )  . size (  )  )  ;", "assertTrue ( target . getSortedSet (  )  . contains (  \" sortedSet 1  \"  )  )  ;", "assertEquals (  1  ,    target . getList (  )  . size (  )  )  ;", "assertTrue ( target . getList (  )  . contains (  \" list 1  \"  )  )  ;", "accessor . setPropertyValue (  \" list \"  ,    Collections . singletonList (  \" list 1     \"  )  )  ;", "assertTrue ( target . getList (  )  . contains (  \" list 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setCollectionPropertyWithStringValueAndCustomEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   age    =     5  0  ;", "String   name    =     \" Tony \"  ;", "target . setAge ( age )  ;", "target . setName ( name )  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "assertTrue (  \" age   is   OK \"  ,     (  ( target . getAge (  )  )     =  =    age )  )  ;", "assertTrue (  \" name   is   OK \"  ,    name . equals ( target . getName (  )  )  )  ;", "accessor . setPropertyValues ( new   MutablePropertyValues (  )  )  ;", "assertTrue (  \" age   is   OK \"  ,     (  ( target . getAge (  )  )     =  =    age )  )  ;", "assertTrue (  \" name   is   OK \"  ,    name . equals ( target . getName (  )  )  )  ;", "}    catch    ( BeansException   ex )     {", "fail (  \" Shouldn ' t   throw   exception   when   everything   is   valid \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setEmptyPropertyValues"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" age \"  ,     \"  \"  )  ;", "fail (  \" Should   throw   exception   on   type   mismatch \"  )  ;", "}    catch    ( TypeMismatchException   ex )     {", "}    catch    ( Exception   ex )     {", "fail (  \" Shouldn ' t   throw   exception   other   than   Type   mismatch \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setEmptyValueForPrimitiveProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . EnumTester   target    =    new   AbstractPropertyAccessorTests . EnumTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" autowire \"  ,     \" BY _ NAME \"  )  ;", "assertEquals ( Autowire . BY _ NAME ,    target . getAutowire (  )  )  ;", "accessor . setPropertyValue (  \" autowire \"  ,     \"       BY _ TYPE    \"  )  ;", "assertEquals ( Autowire . BY _ TYPE ,    target . getAutowire (  )  )  ;", "try    {", "accessor . setPropertyValue (  \" autowire \"  ,     \" NHERITED \"  )  ;", "fail (  \" Should   have   thrown   TypeMismatchException \"  )  ;", "}    catch    ( TypeMismatchException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["setEnumProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . SkipReaderStub   target    =    new   AbstractPropertyAccessorTests . SkipReaderStub (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "List < String >    values    =    new   LinkedList <  >  (  )  ;", "values . add (  \"  1  \"  )  ;", "values . add (  \"  2  \"  )  ;", "values . add (  \"  3  \"  )  ;", "values . add (  \"  4  \"  )  ;", "accessor . setPropertyValue (  \" items \"  ,    values )  ;", "Object [  ]    result    =    target . items ;", "assertEquals (  4  ,    result . length )  ;", "assertEquals (  \"  1  \"  ,    result [  0  ]  )  ;", "assertEquals (  \"  2  \"  ,    result [  1  ]  )  ;", "assertEquals (  \"  3  \"  ,    result [  2  ]  )  ;", "assertEquals (  \"  4  \"  ,    result [  3  ]  )  ;", "}", "METHOD_END"], "methodName": ["setGenericArrayProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . EnumConsumer   target    =    new   AbstractPropertyAccessorTests . EnumConsumer (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" enumValue \"  ,     (  ( AbstractPropertyAccessorTests . TestEnum . class . getName (  )  )     +     \"  . TEST _ VALUE \"  )  )  ;", "assertEquals ( AbstractPropertyAccessorTests . TestEnum . TEST _ VALUE ,    target . getEnumValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setGenericEnumProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   values    =    new   MutablePropertyValues (  )  ;", "values . add (  \" toBeIgnored [  0  ]  \"  ,     4  2  )  ;", "accessor    =    createAccessor ( new   Object (  )  )  ;", "accessor . setPropertyValues ( values ,    true )  ;", "}", "METHOD_END"], "methodName": ["setIndexedPropertyIgnored"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "String   newName    =     \" tony \"  ;", "int   newAge    =     6  5  ;", "String   newTouchy    =     \" valid \"  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" age \"  ,    new   Integer ( newAge )  )  ;", "accessor . setPropertyValue ( new   PropertyValue (  \" name \"  ,    newName )  )  ;", "accessor . setPropertyValue ( new   PropertyValue (  \" touchy \"  ,    newTouchy )  )  ;", "assertTrue (  \" Name   property   should   have   changed \"  ,    target . getName (  )  . equals ( newName )  )  ;", "assertTrue (  \" Touchy   property   should   have   changed \"  ,    target . getTouchy (  )  . equals ( newTouchy )  )  ;", "assertTrue (  \" Age   property   should   have   changed \"  ,     (  ( target . getAge (  )  )     =  =    newAge )  )  ;", "}    catch    ( BeansException   ex )     {", "fail (  \" Shouldn ' t   throw   exception   when   everything   is   valid \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setIndividualValidPropertyValues"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   int [  ]  {     4  ,     5  ,     2  ,     3     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )     &  &     (  ( target . intArray [  2  ]  )     =  =     2  )  )     &  &     (  ( target . intArray [  3  ]  )     =  =     3  )  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   String [  ]  {     \"  4  \"  ,     \"  5  \"  ,     \"  2  \"  ,     \"  3  \"     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )     &  &     (  ( target . intArray [  2  ]  )     =  =     2  )  )     &  &     (  ( target . intArray [  3  ]  )     =  =     3  )  )  )  ;", "List < Object >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  4  )  ;", "list . add (  \"  5  \"  )  ;", "list . add (  2  )  ;", "list . add (  \"  3  \"  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    list )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )     &  &     (  ( target . intArray [  2  ]  )     =  =     2  )  )     &  &     (  ( target . intArray [  3  ]  )     =  =     3  )  )  )  ;", "Set < Object >    set    =    new   HashSet <  >  (  )  ;", "set . add (  \"  4  \"  )  ;", "set . add (  5  )  ;", "set . add (  \"  3  \"  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    set )  ;", "assertTrue (  \" intArray   length    =     3  \"  ,     (  ( target . intArray . length )     =  =     3  )  )  ;", "List < Integer >    result    =    new   ArrayList <  >  (  )  ;", "result . add ( target . intArray [  0  ]  )  ;", "result . add ( target . intArray [  1  ]  )  ;", "result . add ( target . intArray [  2  ]  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  ( result . contains ( new   Integer (  4  )  )  )     &  &     ( result . contains ( new   Integer (  5  )  )  )  )     &  &     ( result . contains ( new   Integer (  3  )  )  )  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   Integer [  ]  {     1     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   Integer (  1  )  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   String [  ]  {     \"  1  \"     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,     \"  1  \"  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["setIntArrayProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( int . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )     {", "setValue ( new   Integer (  (  ( Integer . parseInt ( text )  )     +     1  )  )  )  ;", "}", "}  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   int [  ]  {     4  ,     5  ,     2  ,     3     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )     &  &     (  ( target . intArray [  2  ]  )     =  =     2  )  )     &  &     (  ( target . intArray [  3  ]  )     =  =     3  )  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   String [  ]  {     \"  3  \"  ,     \"  4  \"  ,     \"  1  \"  ,     \"  2  \"     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )     &  &     (  ( target . intArray [  2  ]  )     =  =     2  )  )     &  &     (  ( target . intArray [  3  ]  )     =  =     3  )  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   Integer (  1  )  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,    new   String [  ]  {     \"  0  \"     }  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,     \"  0  \"  )  ;", "assertTrue (  \" intArray   length    =     4  \"  ,     (  ( target . intArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . intArray [  0  ]  )     =  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["setIntArrayPropertyWithCustomEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . useConfigValueEditors (  )  ;", "accessor . setPropertyValue (  \" intArray \"  ,     \"  4  ,  5  \"  )  ;", "assertTrue (  \" intArray   length    =     2  \"  ,     (  ( target . intArray . length )     =  =     2  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  ( target . intArray [  0  ]  )     =  =     4  )     &  &     (  ( target . intArray [  1  ]  )     =  =     5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setIntArrayPropertyWithStringSplitting"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" key \"  ,     \" value \"  )  ;", "accessor . setPropertyValue (  \" map \"  ,    map )  ;", "SortedMap <  ?  ,     ?  >    sortedMap    =    new   TreeMap <  >  (  )  ;", "map . put (  \" sortedKey \"  ,     \" sortedValue \"  )  ;", "accessor . setPropertyValue (  \" sortedMap \"  ,    sortedMap )  ;", "assertSame ( map ,    target . getMap (  )  )  ;", "assertSame ( sortedMap ,    target . getSortedMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["setMapProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "Map < String ,    String >    map    =    new   TreeMap <  >  (  )  ;", "map . put (  \" key \"  ,     \" value \"  )  ;", "accessor . setPropertyValue (  \" map \"  ,    map )  ;", "Map < String ,    String >    sortedMap    =    new   TreeMap <  >  (  )  ;", "sortedMap . put (  \" sortedKey \"  ,     \" sortedValue \"  )  ;", "accessor . setPropertyValue (  \" sortedMap \"  ,    sortedMap )  ;", "assertEquals (  1  ,    target . getMap (  )  . size (  )  )  ;", "assertEquals (  \" value \"  ,    target . getMap (  )  . get (  \" key \"  )  )  ;", "assertEquals (  1  ,    target . getSortedMap (  )  . size (  )  )  ;", "assertEquals (  \" sortedValue \"  ,    target . getSortedMap (  )  . get (  \" sortedKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setMapPropertyNonMatchingType"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( TestBean . class ,     \" map \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "if    (  !  ( StringUtils . hasLength ( text )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "setValue ( new   TestBean ( text )  )  ;", "}", "}  )  ;", "Map < Object ,    Object >    inputMap    =    new   HashMap <  >  (  )  ;", "inputMap . put (  1  ,     \" rod \"  )  ;", "inputMap . put (  2  ,     \" rob \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" map \"  ,    new    . ReadOnlyMap <  >  ( inputMap )  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertEquals (  \" rod \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" rob \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  2  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setMapPropertyWithCustomUnmodifiableMap"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( TestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "if    (  !  ( StringUtils . hasLength ( text )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "setValue ( new   TestBean ( text )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" map [ key 1  ]  \"  ,     \" rod \"  )  ;", "pvs . add (  \" map [ key 2  ]  \"  ,     \" rob \"  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertEquals (  \" rod \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  \" key 1  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" rob \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  \" key 2  \"  )  )  )  . getName (  )  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" map [ key 1  ]  \"  ,     \" rod \"  )  ;", "pvs . add (  \" map [ key 2  ]  \"  ,     \"  \"  )  ;", "try    {", "accessor . setPropertyValues ( pvs )  ;", "fail (  \" Should   have   thrown   TypeMismatchException \"  )  ;", "}    catch    ( PropertyBatchUpdateException   ex )     {", "PropertyAccessException   pae    =    ex . getPropertyAccessException (  \" map [ key 2  ]  \"  )  ;", "assertTrue (  ( pae   instanceof   TypeMismatchException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setMapPropertyWithTypeConversion"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( TestBean . class ,     \" map \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "if    (  !  ( StringUtils . hasLength ( text )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "setValue ( new   TestBean ( text )  )  ;", "}", "}  )  ;", "Map < Integer ,    String >    inputMap    =    new   HashMap <  >  (  )  ;", "inputMap . put (  1  ,     \" rod \"  )  ;", "inputMap . put (  2  ,     \" rob \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" map \"  ,    Collections . unmodifiableMap ( inputMap )  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertEquals (  \" rod \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" rob \"  ,     (  ( TestBean )     ( target . getMap (  )  . get (  2  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setMapPropertyWithUnmodifiableMap"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" address . country . name \"  ,     \" UK \"  )  ;", "assertThat ( target . address . country . name ,    is (  \" UK \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setNestedDeepProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" address . city \"  ,     \" London \"  )  ;", "assertThat ( target . address . city ,    is (  \" London \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  \" rod \"  ,     3  1  )  ;", "ITestBean   kerry    =    new    . Employee (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" spouse \"  ,    kerry )  ;", "accessor . setPropertyValue (  \" spouse . age \"  ,    new   Integer (  3  5  )  )  ;", "accessor . setPropertyValue (  \" spouse . name \"  ,     \" Kerry \"  )  ;", "accessor . setPropertyValue (  \" spouse . company \"  ,     \" Lewisham \"  )  ;", "assertTrue (  \" kerry   name   is   Kerry \"  ,    kerry . getName (  )  . equals (  \" Kerry \"  )  )  ;", "assertTrue (  \" nested   set   worked \"  ,     (  ( target . getSpouse (  )  )     =  =    kerry )  )  ;", "assertTrue (  \" no   back   relation \"  ,     (  ( kerry . getSpouse (  )  )     =  =    null )  )  ;", "accessor . setPropertyValue ( new   PropertyValue (  \" spouse . spouse \"  ,    target )  )  ;", "assertTrue (  \" nested   set   worked \"  ,     (  ( kerry . getSpouse (  )  )     =  =    target )  )  ;", "AbstractPropertyAccessor   kerryAccessor    =    createAccessor ( kerry )  ;", "assertTrue (  \" spouse . spouse . spouse . spouse . company = Lewisham \"  ,     \" Lewisham \"  . equals ( kerryAccessor . getPropertyValue (  \" spouse . spouse . spouse . spouse . company \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setNestedPropertyPolymorphic"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NumberTestBean   target    =    new   NumberTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" short 2  \"  ,     \"  2  \"  )  ;", "accessor . setPropertyValue (  \" int 2  \"  ,     \"  8  \"  )  ;", "accessor . setPropertyValue (  \" long 2  \"  ,     \"  6  \"  )  ;", "accessor . setPropertyValue (  \" bigInteger \"  ,     \"  3  \"  )  ;", "accessor . setPropertyValue (  \" float 2  \"  ,     \"  8  .  1  \"  )  ;", "accessor . setPropertyValue (  \" double 2  \"  ,     \"  6  .  1  \"  )  ;", "accessor . setPropertyValue (  \" bigDecimal \"  ,     \"  4  .  0  \"  )  ;", "}    catch    ( BeansException   ex )     {", "fail (  (  \" Should   not   throw   BeansException :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( accessor . getPropertyValue (  \" short 2  \"  )  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( target . getShort 2  (  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( accessor . getPropertyValue (  \" int 2  \"  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( target . getInt 2  (  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( accessor . getPropertyValue (  \" long 2  \"  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( target . getLong 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( accessor . getPropertyValue (  \" bigInteger \"  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( target . getBigInteger (  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( accessor . getPropertyValue (  \" float 2  \"  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( target . getFloat 2  (  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( accessor . getPropertyValue (  \" double 2  \"  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( target . getDouble 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  0  \"  )  . equals ( accessor . getPropertyValue (  \" bigDecimal \"  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  0  \"  )  . equals ( target . getBigDecimal (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setNumberProperties"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "NumberTestBean   target    =    new   NumberTestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" short 2  \"  ,    new   Integer (  2  )  )  ;", "accessor . setPropertyValue (  \" int 2  \"  ,    new   Long (  8  )  )  ;", "accessor . setPropertyValue (  \" long 2  \"  ,    new   BigInteger (  \"  6  \"  )  )  ;", "accessor . setPropertyValue (  \" bigInteger \"  ,    new   Integer (  3  )  )  ;", "accessor . setPropertyValue (  \" float 2  \"  ,    new   Double (  8  .  1  )  )  ;", "accessor . setPropertyValue (  \" double 2  \"  ,    new   BigDecimal (  6  .  1  )  )  ;", "accessor . setPropertyValue (  \" bigDecimal \"  ,    new   Float (  4  .  0  )  )  ;", "}    catch    ( BeansException   ex )     {", "fail (  (  \" Should   not   throw   BeansException :     \"     +     ( ex . getMessage (  )  )  )  )  ;", "}", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( accessor . getPropertyValue (  \" short 2  \"  )  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( target . getShort 2  (  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( accessor . getPropertyValue (  \" int 2  \"  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( target . getInt 2  (  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( accessor . getPropertyValue (  \" long 2  \"  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( target . getLong 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( accessor . getPropertyValue (  \" bigInteger \"  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( target . getBigInteger (  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( accessor . getPropertyValue (  \" float 2  \"  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( target . getFloat 2  (  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( accessor . getPropertyValue (  \" double 2  \"  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( target . getDouble 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  0  \"  )  . equals ( accessor . getPropertyValue (  \" bigDecimal \"  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  0  \"  )  . equals ( target . getBigDecimal (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setNumberPropertiesWithCoercion"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PrimitiveArrayBean   target    =    new   AbstractPropertyAccessorTests . PrimitiveArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" array \"  ,    new   String [  ]  {     \"  1  \"  ,     \"  2  \"     }  )  ;", "assertEquals (  2  ,    target . getArray (  )  . length )  ;", "assertEquals (  1  ,    target . getArray (  )  [  0  ]  )  ;", "assertEquals (  2  ,    target . getArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveArrayProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging ( LogFactory . getLog (  . class )  )  ;", ". PrimitiveArrayBean   target    =    new    . PrimitiveArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "int [  ]    input    =    new   int [  1  0  2  4  ]  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" array 1  \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "}", "sw . stop (  )  ;", "assertEquals (  1  0  2  4  ,    target . getArray (  )  . length )  ;", "assertEquals (  0  ,    target . getArray (  )  [  0  ]  )  ;", "long   time 1     =    sw . getLastTaskTimeMillis (  )  ;", "assertTrue (  \" Took   too   long \"  ,     (  ( sw . getLastTaskTimeMillis (  )  )     <     1  0  0  )  )  ;", "accessor . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( false )  )  ;", "sw . start (  \" array 2  \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "}", "sw . stop (  )  ;", "assertTrue (  \" Took   too   long \"  ,     (  ( sw . getLastTaskTimeMillis (  )  )     <     1  2  5  )  )  ;", "accessor . registerCustomEditor ( int . class ,     \" array . somePath \"  ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "sw . start (  \" array 3  \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "}", "sw . stop (  )  ;", "assertTrue (  \" Took   too   long \"  ,     (  ( sw . getLastTaskTimeMillis (  )  )     <     1  0  0  )  )  ;", "accessor . registerCustomEditor ( int . class ,     \" array [  0  ]  . somePath \"  ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "sw . start (  \" array 3  \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "}", "sw . stop (  )  ;", "assertTrue (  \" Took   too   long \"  ,     (  ( sw . getLastTaskTimeMillis (  )  )     <     1  0  0  )  )  ;", "accessor . registerCustomEditor ( int . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "sw . start (  \" array 4  \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "}", "sw . stop (  )  ;", "assertEquals (  1  0  2  4  ,    target . getArray (  )  . length )  ;", "assertEquals (  0  ,    target . getArray (  )  [  0  ]  )  ;", "assertTrue (  \" Took   too   long \"  ,     (  ( sw . getLastTaskTimeMillis (  )  )     >    time 1  )  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveArrayPropertyLargeMatching"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PrimitiveArrayBean   target    =    new   AbstractPropertyAccessorTests . PrimitiveArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( int . class ,     \" array [  1  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setValue ( Object   value )     {", "if    ( value   instanceof   Integer )     {", "super . setValue ( new   Integer (  (  (  ( Integer )     ( value )  )     +     1  )  )  )  ;", "}", "}", "}  )  ;", "int [  ]    input    =    new   int [  1  0  2  4  ]  ;", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "assertEquals (  1  0  2  4  ,    target . getArray (  )  . length )  ;", "assertEquals (  0  ,    target . getArray (  )  [  0  ]  )  ;", "assertEquals (  1  ,    target . getArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveArrayPropertyLargeMatchingWithIndexSpecificEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PrimitiveArrayBean   target    =    new   AbstractPropertyAccessorTests . PrimitiveArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( int . class ,     \" array \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setValue ( Object   value )     {", "if    ( value   instanceof   Integer )     {", "super . setValue ( new   Integer (  (  (  ( Integer )     ( value )  )     +     1  )  )  )  ;", "}", "}", "}  )  ;", "int [  ]    input    =    new   int [  1  0  2  4  ]  ;", "accessor . setPropertyValue (  \" array \"  ,    input )  ;", "assertEquals (  1  0  2  4  ,    target . getArray (  )  . length )  ;", "assertEquals (  1  ,    target . getArray (  )  [  0  ]  )  ;", "assertEquals (  1  ,    target . getArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveArrayPropertyLargeMatchingWithSpecificEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PrimitiveArrayBean   target    =    new   AbstractPropertyAccessorTests . PrimitiveArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" array [  0  ]  \"  ,     1  )  ;", "assertEquals (  1  ,    target . getArray (  )  . length )  ;", "accessor . setPropertyValue (  \" array [  2  ]  \"  ,     3  )  ;", "assertEquals (  3  ,    target . getArray (  )  . length )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  ( target . getArray (  )  [  0  ]  )     =  =     1  )     &  &     (  ( target . getArray (  )  [  1  ]  )     =  =     0  )  )     &  &     (  ( target . getArray (  )  [  2  ]  )     =  =     3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveArrayPropertyWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . NumberPropertyBean   target    =    new   AbstractPropertyAccessorTests . NumberPropertyBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "String   byteValue    =     (  \"     \"     +     ( Byte . MAX _ VALUE )  )     +     \"     \"  ;", "String   shortValue    =     (  \"     \"     +     ( Short . MAX _ VALUE )  )     +     \"     \"  ;", "String   intValue    =     (  \"     \"     +     ( Integer . MAX _ VALUE )  )     +     \"     \"  ;", "String   longValue    =     (  \"     \"     +     ( Long . MAX _ VALUE )  )     +     \"     \"  ;", "String   floatValue    =     (  \"     \"     +     ( Float . MAX _ VALUE )  )     +     \"     \"  ;", "String   doubleValue    =     (  \"     \"     +     ( Double . MAX _ VALUE )  )     +     \"     \"  ;", "accessor . setPropertyValue (  \" myPrimitiveByte \"  ,    byteValue )  ;", "accessor . setPropertyValue (  \" myByte \"  ,    byteValue )  ;", "accessor . setPropertyValue (  \" myPrimitiveShort \"  ,    shortValue )  ;", "accessor . setPropertyValue (  \" myShort \"  ,    shortValue )  ;", "accessor . setPropertyValue (  \" myPrimitiveInt \"  ,    intValue )  ;", "accessor . setPropertyValue (  \" myInteger \"  ,    intValue )  ;", "accessor . setPropertyValue (  \" myPrimitiveLong \"  ,    longValue )  ;", "accessor . setPropertyValue (  \" myLong \"  ,    longValue )  ;", "accessor . setPropertyValue (  \" myPrimitiveFloat \"  ,    floatValue )  ;", "accessor . setPropertyValue (  \" myFloat \"  ,    floatValue )  ;", "accessor . setPropertyValue (  \" myPrimitiveDouble \"  ,    doubleValue )  ;", "accessor . setPropertyValue (  \" myDouble \"  ,    doubleValue )  ;", "assertEquals ( Byte . MAX _ VALUE ,    target . getMyPrimitiveByte (  )  )  ;", "assertEquals ( Byte . MAX _ VALUE ,    target . getMyByte (  )  . byteValue (  )  )  ;", "assertEquals ( Short . MAX _ VALUE ,    target . getMyPrimitiveShort (  )  )  ;", "assertEquals ( Short . MAX _ VALUE ,    target . getMyShort (  )  . shortValue (  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    target . getMyPrimitiveInt (  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    target . getMyInteger (  )  . intValue (  )  )  ;", "assertEquals ( Long . MAX _ VALUE ,    target . getMyPrimitiveLong (  )  )  ;", "assertEquals ( Long . MAX _ VALUE ,    target . getMyLong (  )  . longValue (  )  )  ;", "assertEquals ( Float . MAX _ VALUE ,    target . getMyPrimitiveFloat (  )  ,     0  .  0  0  1  )  ;", "assertEquals ( Float . MAX _ VALUE ,    target . getMyFloat (  )  . floatValue (  )  ,     0  .  0  0  1  )  ;", "assertEquals ( Double . MAX _ VALUE ,    target . getMyPrimitiveDouble (  )  ,     0  .  0  0  1  )  ;", "assertEquals ( Double . MAX _ VALUE ,    target . getMyDouble (  )  . doubleValue (  )  ,     0  .  0  0  1  )  ;", "}", "METHOD_END"], "methodName": ["setPrimitiveProperties"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" name \"  ,     \" ptest \"  )  ;", "String   ps    =     \" peace = war \\ nfreedom = slavery \"  ;", "accessor . setPropertyValue (  \" properties \"  ,    ps )  ;", "assertTrue (  \" name   was   set \"  ,    target . name . equals (  \" ptest \"  )  )  ;", "assertTrue (  \" properties   non   null \"  ,     (  ( target . properties )     !  =    null )  )  ;", "String   freedomVal    =    target . properties . getProperty (  \" freedom \"  )  ;", "String   peaceVal    =    target . properties . getProperty (  \" peace \"  )  ;", "assertTrue (  \" peace =  = war \"  ,    peaceVal . equals (  \" war \"  )  )  ;", "assertTrue (  \" Freedom =  = slavery \"  ,    freedomVal . equals (  \" slavery \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertiesProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "DerivedFromProtectedBaseBean   target    =    new   DerivedFromProtectedBaseBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" someProperty \"  ,     \" someValue \"  )  ;", "assertEquals (  \" someValue \"  ,    accessor . getPropertyValue (  \" someProperty \"  )  )  ;", "assertEquals (  \" someValue \"  ,    target . getSomeProperty (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyInProtectedBaseBean"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Foo   target    =    new   AbstractPropertyAccessorTests . Foo (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setConversionService ( new   DefaultConversionService (  )  )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" favoriteNumber \"  ,     \"  9  \"  )  ;", "accessor . setPropertyValue (  \" list [  0  ]  \"  ,    map )  ;", "assertEquals ( map ,    target . list . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyIntermediateListIsNullWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Foo   target    =    new   AbstractPropertyAccessorTests . Foo (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setConversionService ( new   GenericConversionService (  )     {", "@ Override", "public   Object   convert (  @ Nullable", "Object   source ,     @ Nullable", "TypeDescriptor   sourceType ,    TypeDescriptor   targetType )     {", "throw   new   ConversionFailedException ( sourceType ,    targetType ,    source ,    null )  ;", "}", "}  )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" listOfMaps [  0  ]  [  ' luckyNumber '  ]  \"  ,     \"  9  \"  )  ;", "assertEquals (  \"  9  \"  ,    target . listOfMaps . get (  0  )  . get (  \" luckyNumber \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyIntermediateListIsNullWithBadConversionService"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Foo   target    =    new   AbstractPropertyAccessorTests . Foo (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" listOfMaps [  0  ]  [  ' luckyNumber '  ]  \"  ,     \"  9  \"  )  ;", "assertEquals (  \"  9  \"  ,    target . listOfMaps . get (  0  )  . get (  \" luckyNumber \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyIntermediateListIsNullWithNoConversionService"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "target . address . country    =    null ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" address . country . name \"  ,     \" UK \"  )  ;", "fail (  \" Should   have   failed   to   set   value   with   intermediate   null   value \"  )  ;", "}    catch    ( NullValueInNestedPathException   e )     {", "assertEquals (  \" address . country \"  ,    e . getPropertyName (  )  )  ;", "assertEquals ( AbstractPropertyAccessorTests . Person . class ,    e . getBeanClass (  )  )  ;", "}", "assertThat ( target . address . country ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyIntermediatePropertyIsNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "target . address . country    =    null ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" address . country . name \"  ,     \" UK \"  )  ;", "assertThat ( target . address . country . name ,    is (  \" UK \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyIntermediatePropertyIsNullWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "int   newAge    =     3  3  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "target . setAge ( newAge )  ;", "Object   bwAge    =    accessor . getPropertyValue (  \" age \"  )  ;", "assertTrue (  \" Age   is   an   integer \"  ,     ( bwAge   instanceof   Integer )  )  ;", "assertTrue (  \" Bean   wrapper   must   pick   up   changes \"  ,     (  (  ( int )     ( bwAge )  )     =  =    newAge )  )  ;", "}    catch    ( Exception   ex )     {", "fail (  \" Shouldn ' t   throw   exception   when   everything   is   valid \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPropertyIsReflectedImmediately"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setName (  \" Frank \"  )  ;", "target . setSpouse ( target )  ;", "accessor    =    createAccessor ( target )  ;", "assertTrue (  \" name   is   not   null   to   start   off \"  ,     (  ( target . getName (  )  )     !  =    null )  )  ;", "accessor . setPropertyValue (  \" name \"  ,    null )  ;", "assertTrue (  \" name   is   now   null \"  ,     (  ( target . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" spouse   is   not   null   to   start   off \"  ,     (  ( target . getSpouse (  )  )     !  =    null )  )  ;", "accessor . setPropertyValue (  \" spouse \"  ,    null )  ;", "assertTrue (  \" spouse   is   now   null \"  ,     (  ( target . getSpouse (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyToNull"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" age \"  ,     \" foobar \"  )  ;", "fail (  \" Should   throw   exception   on   type   mismatch \"  )  ;", "}    catch    ( TypeMismatchException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["setPropertyTypeMismatch"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" rod \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" graceful . rubbish \"  ,     \" tony \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" more . garbage \"  ,    new   Object (  )  )  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValues ( pvs ,    true )  ;", "assertTrue (  \" Set   valid   and   ignored   invalid \"  ,    target . getName (  )  . equals (  \" rod \"  )  )  ;", "try    {", "accessor . setPropertyValues ( pvs ,    false )  ;", "fail (  \" Shouldn ' t   have   ignored   invalid   updates \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["setPropertyValuesIgnoresInvalidNestedOnRequest"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   values    =    new   MutablePropertyValues (  )  ;", "values . add (  \" name \"  ,    Integer . class )  ;", "TestBean   target    =    new   TestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setValue ( Object   value )     {", "super . setValue ( value . toString (  )  )  ;", "}", "}  )  ;", "accessor . setPropertyValues ( values )  ;", "assertEquals ( Integer . class . toString (  )  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyWithCustomEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   values    =    new   MutablePropertyValues (  )  ;", "values . add (  \" name \"  ,     4  2  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValues ( values )  ;", "assertEquals (  \"  4  2  \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyWithPrimitiveConversion"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   target    =    new   IndexedTestBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "Map   inputMap    =    new   HashMap (  )  ;", "inputMap . put (  1  ,     \" rod \"  )  ;", "inputMap . put (  2  ,     \" rob \"  )  ;", ". ReadOnlyMap   readOnlyMap    =    new    . ReadOnlyMap ( inputMap )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" map \"  ,    readOnlyMap )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertSame ( readOnlyMap ,    target . getMap (  )  )  ;", "assertFalse ( readOnlyMap . isAccessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["setRawMapPropertyWithNoEditorRegistered"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" name \"  ,     \" SomeValue \"  )  ;", "assertThat ( target . name ,    is (  \" SomeValue \"  )  )  ;", "assertThat ( target . getName (  )  ,    is (  \" SomeValue \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setSimpleProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    new   String [  ]  {     \" foo \"  ,     \" fi \"  ,     \" fi \"  ,     \" fum \"     }  )  ;", "assertTrue (  \" stringArray   length    =     4  \"  ,     (  ( target . stringArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  ( target . stringArray [  0  ]  . equals (  \" foo \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  2  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  3  ]  . equals (  \" fum \"  )  )  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \" foo \"  )  ;", "list . add (  \" fi \"  )  ;", "list . add (  \" fi \"  )  ;", "list . add (  \" fum \"  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    list )  ;", "assertTrue (  \" stringArray   length    =     4  \"  ,     (  ( target . stringArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  ( target . stringArray [  0  ]  . equals (  \" foo \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  2  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  3  ]  . equals (  \" fum \"  )  )  )  )  ;", "Set < String >    set    =    new   HashSet <  >  (  )  ;", "set . add (  \" foo \"  )  ;", "set . add (  \" fi \"  )  ;", "set . add (  \" fum \"  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    set )  ;", "assertTrue (  \" stringArray   length    =     3  \"  ,     (  ( target . stringArray . length )     =  =     3  )  )  ;", "List < String >    result    =    Arrays . asList ( target . stringArray )  ;", "assertTrue (  \" correct   values \"  ,     (  (  ( result . contains (  \" foo \"  )  )     &  &     ( result . contains (  \" fi \"  )  )  )     &  &     ( result . contains (  \" fum \"  )  )  )  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,     \" one \"  )  ;", "assertTrue (  \" stringArray   length    =     1  \"  ,     (  ( target . stringArray . length )     =  =     1  )  )  ;", "assertTrue (  \" stringArray   elt   is   ok \"  ,    target . stringArray [  0  ]  . equals (  \" one \"  )  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    null )  ;", "assertTrue (  \" stringArray   is   null \"  ,     (  ( target . stringArray )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["setStringArrayProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String [  ]  . class ,     \" stringArray \"  ,    new   StringArrayPropertyEditor (  \"  -  \"  )  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,     \" a 1  - b 2  \"  )  ;", "assertTrue (  \" stringArray   length    =     2  \"  ,     (  ( target . stringArray . length )     =  =     2  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . stringArray [  0  ]  . equals (  \" a 1  \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" b 2  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setStringArrayPropertyWithCustomStringDelimiter"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String . class ,     \" stringArray \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )     {", "setValue ( text . substring (  1  )  )  ;", "}", "}  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    new   String [  ]  {     \"  4 foo \"  ,     \"  7 fi \"  ,     \"  6 fi \"  ,     \"  5 fum \"     }  )  ;", "assertTrue (  \" stringArray   length    =     4  \"  ,     (  ( target . stringArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  ( target . stringArray [  0  ]  . equals (  \" foo \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  2  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  3  ]  . equals (  \" fum \"  )  )  )  )  ;", "List < String >    list    =    new   ArrayList <  >  (  )  ;", "list . add (  \"  4 foo \"  )  ;", "list . add (  \"  7 fi \"  )  ;", "list . add (  \"  6 fi \"  )  ;", "list . add (  \"  5 fum \"  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    list )  ;", "assertTrue (  \" stringArray   length    =     4  \"  ,     (  ( target . stringArray . length )     =  =     4  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  (  (  ( target . stringArray [  0  ]  . equals (  \" foo \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  2  ]  . equals (  \" fi \"  )  )  )     &  &     ( target . stringArray [  3  ]  . equals (  \" fum \"  )  )  )  )  ;", "Set < String >    set    =    new   HashSet <  >  (  )  ;", "set . add (  \"  4 foo \"  )  ;", "set . add (  \"  7 fi \"  )  ;", "set . add (  \"  6 fum \"  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,    set )  ;", "assertTrue (  \" stringArray   length    =     3  \"  ,     (  ( target . stringArray . length )     =  =     3  )  )  ;", "List < String >    result    =    Arrays . asList ( target . stringArray )  ;", "assertTrue (  \" correct   values \"  ,     (  (  ( result . contains (  \" foo \"  )  )     &  &     ( result . contains (  \" fi \"  )  )  )     &  &     ( result . contains (  \" fum \"  )  )  )  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,     \"  8 one \"  )  ;", "assertTrue (  \" stringArray   length    =     1  \"  ,     (  ( target . stringArray . length )     =  =     1  )  )  ;", "assertTrue (  \" correct   values \"  ,    target . stringArray [  0  ]  . equals (  \" one \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setStringArrayPropertyWithCustomStringEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . PropsTester   target    =    new   AbstractPropertyAccessorTests . PropsTester (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . useConfigValueEditors (  )  ;", "accessor . setPropertyValue (  \" stringArray \"  ,     \" a 1  , b 2  \"  )  ;", "assertTrue (  \" stringArray   length    =     2  \"  ,     (  ( target . stringArray . length )     =  =     2  )  )  ;", "assertTrue (  \" correct   values \"  ,     (  ( target . stringArray [  0  ]  . equals (  \" a 1  \"  )  )     &  &     ( target . stringArray [  1  ]  . equals (  \" b 2  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setStringArrayPropertyWithStringSplitting"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . StringArrayBean   target    =    new   AbstractPropertyAccessorTests . StringArrayBean (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" array [  0  ]  \"  ,     \" Test 0  \"  )  ;", "assertEquals (  1  ,    target . getArray (  )  . length )  ;", "accessor . setPropertyValue (  \" array [  2  ]  \"  ,     \" Test 2  \"  )  ;", "assertEquals (  3  ,    target . getArray (  )  . length )  ;", "assertTrue (  \" correct   values \"  ,     (  (  ( target . getArray (  )  [  0  ]  . equals (  \" Test 0  \"  )  )     &  &     (  ( target . getArray (  )  [  1  ]  )     =  =    null )  )     &  &     ( target . getArray (  )  [  2  ]  . equals (  \" Test 2  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setStringArrayWithAutoGrow"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . registerCustomEditor ( String . class ,     \" name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setValue ( Object   value )     {", "if    ( value   instanceof   String [  ]  )     {", "setValue ( StringUtils . arrayToDelimitedString (  (  ( String [  ]  )     ( value )  )  ,     \"  -  \"  )  )  ;", "} else    {", "super . setValue (  ( value    !  =    null    ?    value    :     \"  \"  )  )  ;", "}", "}", "}  )  ;", "accessor . setPropertyValue (  \" name \"  ,    new   String [  ]  {        }  )  ;", "assertEquals (  \"  \"  ,    target . getName (  )  )  ;", "accessor . setPropertyValue (  \" name \"  ,    new   String [  ]  {     \" a 1  \"  ,     \" b 2  \"     }  )  ;", "assertEquals (  \" a 1  - b 2  \"  ,    target . getName (  )  )  ;", "accessor . setPropertyValue (  \" name \"  ,    null )  ;", "assertEquals (  \"  \"  ,    target . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["setStringPropertyWithCustomEditor"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Person   target    =    createPerson (  \" John \"  ,     \" Paris \"  ,     \" FR \"  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "thrown . expect ( NotWritablePropertyException . class )  ;", "accessor . setPropertyValue (  \" address . bar \"  ,     \" value \"  )  ;", "}", "METHOD_END"], "methodName": ["setUnknownNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "PropertyValue   value    =    new   PropertyValue (  \" foo \"  ,     \" value \"  )  ;", "value . setOptional ( true )  ;", "accessor . setPropertyValue ( value )  ;", "}    catch    ( NotWritablePropertyException   e )     {", "fail (  \" Should   not   have   failed   to   set   an   unknown   optional   property .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setUnknownOptionalProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" name 1  \"  ,     \" value \"  )  ;", "fail (  \" Should   have   failed   to   set   an   unknown   property .  \"  )  ;", "}    catch    ( NotWritablePropertyException   e )     {", "assertEquals ( AbstractPropertyAccessorTests . Simple . class ,    e . getBeanClass (  )  )  ;", "assertEquals (  \" name 1  \"  ,    e . getPropertyName (  )  )  ;", "assertEquals (  \" Invalid   number   of   possible   matches \"  ,     1  ,    e . getPossibleMatches (  )  . length )  ;", "assertEquals (  \" name \"  ,    e . getPossibleMatches (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["setUnknownProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . Simple   target    =    new   AbstractPropertyAccessorTests . Simple (  \" John \"  ,     2  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . setPropertyValue (  \" foo \"  ,     \" value \"  )  ;", "fail (  \" Should   have   failed   to   set   an   unknown   property .  \"  )  ;", "}    catch    ( NotWritablePropertyException   e )     {", "assertEquals ( AbstractPropertyAccessorTests . Simple . class ,    e . getBeanClass (  )  )  ;", "assertEquals (  \" foo \"  ,    e . getPropertyName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setUnknownPropertyWithPossibleMatches"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "String   newName    =     \" tony \"  ;", "int   newAge    =     6  5  ;", "String   newTouchy    =     \" valid \"  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,    newAge )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,    newName )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" touchy \"  ,    newTouchy )  )  ;", "accessor . setPropertyValues ( pvs )  ;", "assertTrue (  \" Name   property   should   have   changed \"  ,    target . getName (  )  . equals ( newName )  )  ;", "assertTrue (  \" Touchy   property   should   have   changed \"  ,    target . getTouchy (  )  . equals ( newTouchy )  )  ;", "assertTrue (  \" Age   property   should   have   changed \"  ,     (  ( target . getAge (  )  )     =  =    newAge )  )  ;", "}    catch    ( BeansException   ex )     {", "fail (  \" Shouldn ' t   throw   exception   when   everything   is   valid \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setValidPropertyValues"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyAccessorTests . WildcardEnumConsumer   target    =    new   AbstractPropertyAccessorTests . WildcardEnumConsumer (  )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" enumValue \"  ,     (  ( AbstractPropertyAccessorTests . TestEnum . class . getName (  )  )     +     \"  . TEST _ VALUE \"  )  )  ;", "assertEquals ( AbstractPropertyAccessorTests . TestEnum . TEST _ VALUE ,    target . getEnumValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setWildcardEnumProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "String   doctorCompany    =     \"  \"  ;", "String   lawyerCompany    =     \" Dr .    Sueem \"  ;", "TestBean   target    =    new   TestBean (  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" doctor . company \"  ,    doctorCompany )  ;", "accessor . setPropertyValue (  \" lawyer . company \"  ,    lawyerCompany )  ;", "assertEquals ( doctorCompany ,    target . getDoctor (  )  . getCompany (  )  )  ;", "assertEquals ( lawyerCompany ,    target . getLawyer (  )  . getCompany (  )  )  ;", "}", "METHOD_END"], "methodName": ["setYetAnotherNestedProperties"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   target    =    new   TestBean (  )  ;", "ITestBean   child    =    new    . DifferentTestBean (  )  ;", "child . setName (  \" test \"  )  ;", "target . setSpouse ( child )  ;", "AbstractPropertyAccessor   accessor    =    createAccessor ( target )  ;", "try    {", "accessor . getPropertyValue (  \" spouse . bla \"  )  ;", "}    catch    ( NotReadablePropertyException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains ( TestBean . class . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testErrorMessageOfNestedProperty"], "fileName": "org.springframework.beans.AbstractPropertyAccessorTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Contains    3  \"  ,     (  ( pvs . getPropertyValues (  )  . length )     =  =     3  )  )  ;", "assertTrue (  \" Contains   forname \"  ,    pvs . contains (  \" forname \"  )  )  ;", "assertTrue (  \" Contains   surname \"  ,    pvs . contains (  \" surname \"  )  )  ;", "assertTrue (  \" Contains   age \"  ,    pvs . contains (  \" age \"  )  )  ;", "assertTrue (  \" Doesn ' t   contain   tory \"  ,     (  !  ( pvs . contains (  \" tory \"  )  )  )  )  ;", "PropertyValue [  ]    ps    =    pvs . getPropertyValues (  )  ;", "Map < String ,    String >    m    =    new   HashMap <  >  (  )  ;", "m . put (  \" forname \"  ,     \" Tony \"  )  ;", "m . put (  \" surname \"  ,     \" Blair \"  )  ;", "m . put (  \" age \"  ,     \"  5  0  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( ps . length )  ;    i +  +  )     {", "Object   val    =    m . get ( ps [ i ]  . getName (  )  )  ;", "assertTrue (  \" Can ' t   have   unexpected   value \"  ,     ( val    !  =    null )  )  ;", "assertTrue (  \" Val   i   string \"  ,     ( val   instanceof   String )  )  ;", "assertTrue (  \" val   matches   expected \"  ,    val . equals ( ps [ i ]  . getValue (  )  )  )  ;", "m . remove ( ps [ i ]  . getName (  )  )  ;", "}", "assertTrue (  \" Map   size   is    0  \"  ,     (  ( m . size (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestTony"], "fileName": "org.springframework.beans.AbstractPropertyValuesTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClass ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.BeanInstantiationException"}, {"methodBody": ["METHOD_START", "{", "return   this . constructingMethod ;", "}", "METHOD_END"], "methodName": ["getConstructingMethod"], "fileName": "org.springframework.beans.BeanInstantiationException"}, {"methodBody": ["METHOD_START", "{", "return   this . constructor ;", "}", "METHOD_END"], "methodName": ["getConstructor"], "fileName": "org.springframework.beans.BeanInstantiationException"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.BeanMetadataAttribute"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.beans.BeanMetadataAttribute"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.BeanMetadataAttribute"}, {"methodBody": ["METHOD_START", "{", "super . setAttribute ( attribute . getName (  )  ,    attribute )  ;", "}", "METHOD_END"], "methodName": ["addMetadataAttribute"], "fileName": "org.springframework.beans.BeanMetadataAttributeAccessor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( BeanMetadataAttribute )     ( super . getAttribute ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["getMetadataAttribute"], "fileName": "org.springframework.beans.BeanMetadataAttributeAccessor"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.BeanMetadataAttributeAccessor"}, {"methodBody": ["METHOD_START", "{", "BeanUtils . copyProperties ( source ,    target ,    null ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyProperties"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "BeanUtils . copyProperties ( source ,    target ,    editable ,     (  ( String [  ]  )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["copyProperties"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \" Source   must   not   be   null \"  )  ;", "Assert . notNull ( target ,     \" Target   must   not   be   null \"  )  ;", "Class <  ?  >    actualEditable    =    target . getClass (  )  ;", "if    ( editable    !  =    null )     {", "if    (  !  ( editable . isInstance ( target )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Target   class    [  \"     +     ( target . getClass (  )  . getName (  )  )  )     +     \"  ]    not   assignable   to   Editable   class    [  \"  )     +     ( editable . getName (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "actualEditable    =    editable ;", "}", "PropertyDescriptor [  ]    targetPds    =     . getPropertyDescriptors ( actualEditable )  ;", "List < String >    ignoreList    =     ( ignoreProperties    !  =    null )     ?    Arrays . asList ( ignoreProperties )     :    null ;", "for    ( PropertyDescriptor   targetPd    :    targetPds )     {", "Method   writeMethod    =    targetPd . getWriteMethod (  )  ;", "if    (  ( writeMethod    !  =    null )     &  &     (  ( ignoreList    =  =    null )     |  |     (  !  ( ignoreList . contains ( targetPd . getName (  )  )  )  )  )  )     {", "PropertyDescriptor   sourcePd    =     . getPropertyDescriptor ( source . getClass (  )  ,    targetPd . getName (  )  )  ;", "if    ( sourcePd    !  =    null )     {", "Method   readMethod    =    sourcePd . getReadMethod (  )  ;", "if    (  ( readMethod    !  =    null )     &  &     ( ClassUtils . isAssignable ( writeMethod . getParameterTypes (  )  [  0  ]  ,    readMethod . getReturnType (  )  )  )  )     {", "try    {", "if    (  !  ( Modifier . isPublic ( readMethod . getDeclaringClass (  )  . getModifiers (  )  )  )  )     {", "readMethod . setAccessible ( true )  ;", "}", "Object   value    =    readMethod . invoke ( source )  ;", "if    (  !  ( Modifier . isPublic ( writeMethod . getDeclaringClass (  )  . getModifiers (  )  )  )  )     {", "writeMethod . setAccessible ( true )  ;", "}", "writeMethod . invoke ( target ,    value )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   FatalBeanException (  (  (  \" Could   not   copy   property    '  \"     +     ( targetPd . getName (  )  )  )     +     \"  '    from   source   to   target \"  )  ,    ex )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["copyProperties"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "BeanUtils . copyProperties ( source ,    target ,    null ,    ignoreProperties )  ;", "}", "METHOD_END"], "methodName": ["copyProperties"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   clazz . getDeclaredMethod ( methodName ,    paramTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "if    (  ( clazz . getSuperclass (  )  )     !  =    null )     {", "return    . findDeclaredMethod ( clazz . getSuperclass (  )  ,    methodName ,    paramTypes )  ;", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findDeclaredMethod"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Method   targetMethod    =    BeanUtils . findMethodWithMinimalParameters ( clazz . getDeclaredMethods (  )  ,    methodName )  ;", "if    (  ( targetMethod    =  =    null )     &  &     (  ( clazz . getSuperclass (  )  )     !  =    null )  )     {", "targetMethod    =    BeanUtils . findDeclaredMethodWithMinimalParameters ( clazz . getSuperclass (  )  ,    methodName )  ;", "}", "return   targetMethod ;", "}", "METHOD_END"], "methodName": ["findDeclaredMethodWithMinimalParameters"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( targetType    =  =    null )     |  |     ( targetType . isArray (  )  )  )     |  |     ( BeanUtils . unknownEditorTypes . contains ( targetType )  )  )     {", "return   null ;", "}", "ClassLoader   cl    =    targetType . getClassLoader (  )  ;", "if    ( cl    =  =    null )     {", "try    {", "cl    =    ClassLoader . getSystemClassLoader (  )  ;", "if    ( cl    =  =    null )     {", "return   null ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( BeanUtils . logger . isDebugEnabled (  )  )     {", "BeanUtils . logger . debug (  (  \" Could   not   access   system   ClassLoader :     \"     +    ex )  )  ;", "}", "return   null ;", "}", "}", "String   editorName    =     ( targetType . getName (  )  )     +     \" Editor \"  ;", "try    {", "Class <  ?  >    editorClass    =    cl . loadClass ( editorName )  ;", "if    (  !  ( PropertyEditor . class . isAssignableFrom ( editorClass )  )  )     {", "if    ( BeanUtils . logger . isWarnEnabled (  )  )     {", "BeanUtils . logger . warn (  (  (  \" Editor   class    [  \"     +    editorName )     +     \"  ]    does   not   implement    [ PropertyEditor ]    interface \"  )  )  ;", "}", "BeanUtils . unknownEditorTypes . add ( targetType )  ;", "return   null ;", "}", "return    (  ( PropertyEditor )     ( BeanUtils . instantiateClass ( editorClass )  )  )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "if    ( BeanUtils . logger . isDebugEnabled (  )  )     {", "BeanUtils . logger . debug (  (  (  (  (  \" No   property   editor    [  \"     +    editorName )     +     \"  ]    found   for   type    \"  )     +     ( targetType . getName (  )  )  )     +     \"    according   to    ' Editor '    suffix   convention \"  )  )  ;", "}", "BeanUtils . unknownEditorTypes . add ( targetType )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["findEditorByConvention"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   clazz . getMethod ( methodName ,    paramTypes )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return    . findDeclaredMethod ( clazz ,    methodName ,    paramTypes )  ;", "}", "}", "METHOD_END"], "methodName": ["findMethod"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Method   targetMethod    =    BeanUtils . findMethodWithMinimalParameters ( clazz . getMethods (  )  ,    methodName )  ;", "if    ( targetMethod    =  =    null )     {", "targetMethod    =    BeanUtils . findDeclaredMethodWithMinimalParameters ( clazz ,    methodName )  ;", "}", "return   targetMethod ;", "}", "METHOD_END"], "methodName": ["findMethodWithMinimalParameters"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Method   targetMethod    =    null ;", "int   numMethodsFoundWithCurrentMinimumArgs    =     0  ;", "for    ( Method   method    :    methods )     {", "if    ( method . getName (  )  . equals ( methodName )  )     {", "int   numParams    =    method . getPaterCount (  )  ;", "if    (  ( targetMethod    =  =    null )     |  |     ( numParams    <     ( targetMethod . getPaterCount (  )  )  )  )     {", "targetMethod    =    method ;", "numMethodsFoundWithCurrentMinimumArgs    =     1  ;", "} else", "if    (  (  !  ( method . isBridge (  )  )  )     &  &     (  ( targetMethod . getPaterCount (  )  )     =  =    numParams )  )     {", "if    ( targetMethod . isBridge (  )  )     {", "targetMethod    =    method ;", "} else    {", "numMethodsFoundWithCurrentMinimumArgs +  +  ;", "}", "}", "}", "}", "if    ( numMethodsFoundWithCurrentMinimumArgs    >     1  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Cannot   resolve   method    '  \"     +    methodName )     +     \"  '    to   a   unique   method .    Attempted   to   resolve   to   overloaded   method   with    \"  )     +     \" the   least   number   of   paters   but   there   were    \"  )     +    numMethodsFoundWithCurrentMinimumArgs )     +     \"    candidates .  \"  )  )  ;", "}", "return   targetMethod ;", "}", "METHOD_END"], "methodName": ["findMethodWithMinimalParameters"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "if    ( KotlinDetector . isKotlinType ( clazz )  )     {", "Constructor < T >    kotlinPrimaryConstructor    =     . KotlinDelegate . findPrimaryConstructor ( clazz )  ;", "if    ( kotlinPrimaryConstructor    !  =    null )     {", "return   kotlinPrimaryConstructor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findPrimaryConstructor"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "return   BeanUtils . findPropertyForMethod ( method ,    method . getDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["findPropertyForMethod"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "PropertyDescriptor [  ]    pds    =     . getPropertyDescriptors ( clazz )  ;", "for    ( PropertyDescriptor   pd    :    pds )     {", "if    (  ( method . equals ( pd . getReadMethod (  )  )  )     |  |     ( method . equals ( pd . getWriteMethod (  )  )  )  )     {", "return   pd ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findPropertyForMethod"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( beanClasses    !  =    null )     {", "for    ( Class <  ?  >    beanClass    :    beanClasses )     {", "PropertyDescriptor   pd    =     . getPropertyDescriptor ( beanClass ,    propertyName )  ;", "if    ( pd    !  =    null )     {", "return   pd . getPropertyType (  )  ;", "}", "}", "}", "return   Object . class ;", "}", "METHOD_END"], "methodName": ["findPropertyType"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "CachedIntrospectionResults   cr    =    CachedIntrospectionResults . forClass ( clazz )  ;", "return   cr . getPropertyDescriptor ( propertyN )  ;", "}", "METHOD_END"], "methodName": ["getPropertyDescriptor"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "CachedIntrospectionResults   cr    =    CachedIntrospectionResults . forClass ( clazz )  ;", "return   cr . getPropertyDescriptors (  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyDescriptors"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( pd   instanceof   GenericTypeAwarePropertyDescriptor )     {", "return   new   MethodPater (  (  ( GenericTypeAwarePropertyDescriptor )     ( pd )  )  . getWriteMethodPater (  )  )  ;", "} else    {", "Method   writeMethod    =    pd . getWriteMethod (  )  ;", "Assert . state (  ( writeMethod    !  =    null )  ,     \" No   write   method   available \"  )  ;", "return   new   MethodPater ( writeMethod ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["getWriteMethodParameter"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "if    ( clazz . isInterface (  )  )     {", "throw   new   InstantiationException ( clazz ,     \" Specified   class   is   an   interface \"  )  ;", "}", "try    {", "return   clazz . newInstance (  )  ;", "}    catch    ( InstantiationException   ex )     {", "throw   new   InstantiationException ( clazz ,     \" Is   it   an   abstract   class ?  \"  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   InstantiationException ( clazz ,     \" Is   the   constructor   accessible ?  \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiate"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "if    ( clazz . isInterface (  )  )     {", "throw   new   BeanInstantiationException ( clazz ,     \" Specified   class   is   an   interface \"  )  ;", "}", "try    {", "Constructor < T >    ctor    =     ( KotlinDetector . isKotlinType ( clazz )  )     ?     . KotlinDelegate . getPrimaryConstructor ( clazz )     :    clazz . getDeclaredConstructor (  )  ;", "return    . instantiateClass ( ctor )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "throw   new   BeanInstantiationException ( clazz ,     \" No   default   constructor   found \"  ,    ex )  ;", "}    catch    ( LinkageError   err )     {", "throw   new   BeanInstantiationException ( clazz ,     \" Unresolvable   class   definition \"  ,    err )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateClass"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . isAssignable ( assignableTo ,    clazz )  ;", "return    (  ( T )     (  . instantiateClass ( clazz )  )  )  ;", "}", "METHOD_END"], "methodName": ["instantiateClass"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( ctor ,     \" Constructor   must   not   be   null \"  )  ;", "try    {", "ReflectionUtils . makeAccessible ( ctor )  ;", "return   KotlinDetector . isKotlinType ( ctor . getDeclaringClass (  )  )     ?     . KotlinDelegate . instantiateClass ( ctor ,    args )     :    ctor . newInstance ( args )  ;", "}    catch    ( InstantiationException   ex )     {", "throw   new   BeanInstantiationException ( ctor ,     \" Is   it   an   abstract   class ?  \"  ,    ex )  ;", "}    catch    ( IllegalAccessException   ex )     {", "throw   new   BeanInstantiationException ( ctor ,     \" Is   the   constructor   accessible ?  \"  ,    ex )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   BeanInstantiationException ( ctor ,     \" Illegal   arguments   for   constructor \"  ,    ex )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   new   BeanInstantiationException ( ctor ,     \" Constructor   threw   exception \"  ,    ex . getTargetException (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateClass"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "return    (  . isSimpleValueType ( clazz )  )     |  |     (  ( clazz . isArray (  )  )     &  &     (  . isSimpleValueType ( clazz . getComponentType (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSimpleProperty"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  ( ClassUtils . isPrimitiveOrWrapper ( clazz )  )     |  |     ( Enum . class . isAssignableFrom ( clazz )  )  )     |  |     ( CharSequence . class . isAssignableFrom ( clazz )  )  )     |  |     ( Number . class . isAssignableFrom ( clazz )  )  )     |  |     ( Date . class . isAssignableFrom ( clazz )  )  )     |  |     (  ( URI . class )     =  =    clazz )  )     |  |     (  ( URL . class )     =  =    clazz )  )     |  |     (  ( Locale . class )     =  =    clazz )  )     |  |     (  ( Class . class )     =  =    clazz )  ;", "}", "METHOD_END"], "methodName": ["isSimpleValueType"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( signature ,     \"  ' signature '    must   not   be   empty \"  )  ;", "Assert . notNull ( clazz ,     \" Class   must   not   be   null \"  )  ;", "int   startParen    =    signature . indexOf (  '  (  '  )  ;", "int   endParen    =    signature . indexOf (  '  )  '  )  ;", "if    (  ( startParen    >     (  -  1  )  )     &  &     ( endParen    =  =     (  -  1  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   method   signature    '  \"     +    signature )     +     \"  '  :    expected   closing    '  )  '    for   args   list \"  )  )  ;", "} else", "if    (  ( startParen    =  =     (  -  1  )  )     &  &     ( endParen    >     (  -  1  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   method   signature    '  \"     +    signature )     +     \"  '  :    expected   opening    '  (  '    for   args   list \"  )  )  ;", "} else", "if    ( startParen    =  =     (  -  1  )  )     {", "return   BeanUtils . findMethodWithMinimalParameters ( clazz ,    signature )  ;", "} else    {", "String   methodName    =    signature . substring (  0  ,    startParen )  ;", "String [  ]    parameterTypeNames    =    util . StringUtils . commaDelimitedListToStringArray ( signature . substring (  ( startParen    +     1  )  ,    endParen )  )  ;", "Class <  ?  >  [  ]    parameterTypes    =    new   Class <  ?  >  [ parameterTypeNames . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( parameterTypeNames . length )  ;    i +  +  )     {", "String   parameterTypeName    =    parameterTypeNames [ i ]  . trim (  )  ;", "try    {", "parameterTypes [ i ]     =    util . ClassUtils . forName ( parameterTypeName ,    clazz . getClassLoader (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Invalid   method   signature :    unable   to   resolve   type    [  \"     +    parameterTypeName )     +     \"  ]    for   argument    \"  )     +    i )     +     \"  .    Root   cause :     \"  )     +    ex )  )  ;", "}", "}", "return   BeanUtils . findMethod ( clazz ,    methodName ,    parameterTypes )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveSignature"], "fileName": "org.springframework.beans.BeanUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( desiredMethod ,    BeanUtils . resolveSignature ( signature ,    BeanUtilsTests . MethodSignatureBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["assertSignatureEquals"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor [  ]    descriptors    =    BeanUtils . getPropertyDescriptors ( BeanUtilsTests . ContainerBean . class )  ;", "for    ( PropertyDescriptor   descriptor    :    descriptors )     {", "if    (  \" containedBeans \"  . equals ( descriptor . getName (  )  )  )     {", "assertTrue (  \" Property   should   be   an   array \"  ,    descriptor . getPropertyType (  )  . isArray (  )  )  ;", "assertEquals ( descriptor . getPropertyType (  )  . getComponentType (  )  ,    BeanUtilsTests . ContainedBean . class )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testBeanPropertyIsArray"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" rod \"  )  ;", "tb . setAge (  3  2  )  ;", "tb . setTouchy (  \" touchy \"  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "assertTrue (  \" Name   empty \"  ,     (  ( tb 2  . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" Age   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", ". copyProperties ( tb ,    tb 2  )  ;", "assertTrue (  \" Name   copied \"  ,    tb 2  . getName (  )  . equals ( tb . getName (  )  )  )  ;", "assertTrue (  \" Age   copied \"  ,     (  ( tb 2  . getAge (  )  )     =  =     ( tb . getAge (  )  )  )  )  ;", "assertTrue (  \" Touchy   copied \"  ,    tb 2  . getTouchy (  )  . equals ( tb . getTouchy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyProperties"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "tb . setName (  \" rod \"  )  ;", "tb . setAge (  3  2  )  ;", "tb . setTouchy (  \" touchy \"  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "assertTrue (  \" Name   empty \"  ,     (  ( tb 2  . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" Age   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", ". copyProperties ( tb ,    tb 2  )  ;", "assertTrue (  \" Name   copied \"  ,    tb 2  . getName (  )  . equals ( tb . getName (  )  )  )  ;", "assertTrue (  \" Age   copied \"  ,     (  ( tb 2  . getAge (  )  )     =  =     ( tb . getAge (  )  )  )  )  ;", "assertTrue (  \" Touchy   copied \"  ,    tb 2  . getTouchy (  )  . equals ( tb . getTouchy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithDifferentTypes1"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" rod \"  )  ;", "tb . setAge (  3  2  )  ;", "tb . setTouchy (  \" touchy \"  )  ;", "DerivedTestBean   tb 2     =    new   DerivedTestBean (  )  ;", "assertTrue (  \" Name   empty \"  ,     (  ( tb 2  . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" Age   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", ". copyProperties ( tb ,    tb 2  )  ;", "assertTrue (  \" Name   copied \"  ,    tb 2  . getName (  )  . equals ( tb . getName (  )  )  )  ;", "assertTrue (  \" Age   copied \"  ,     (  ( tb 2  . getAge (  )  )     =  =     ( tb . getAge (  )  )  )  )  ;", "assertTrue (  \" Touchy   copied \"  ,    tb 2  . getTouchy (  )  . equals ( tb . getTouchy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithDifferentTypes2"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "assertTrue (  \" Name   empty \"  ,     (  ( tb . getName (  )  )     =  =    null )  )  ;", "tb . setAge (  3  2  )  ;", "tb . setTouchy (  \" bla \"  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "tb 2  . setName (  \" rod \"  )  ;", "assertTrue (  \" Age   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", ". copyProperties ( tb ,    tb 2  ,    ITestBean . class )  ;", "assertTrue (  \" Name   copied \"  ,     (  ( tb 2  . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" Age   copied \"  ,     (  ( tb 2  . getAge (  )  )     =  =     3  2  )  )  ;", "assertTrue (  \" Touchy   still   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithEditable"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "assertTrue (  \" Name   empty \"  ,     (  ( tb . getName (  )  )     =  =    null )  )  ;", "tb . setAge (  3  2  )  ;", "tb . setTouchy (  \" bla \"  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "tb 2  . setName (  \" rod \"  )  ;", "assertTrue (  \" Age   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", ". copyProperties ( tb ,    tb 2  ,     \" spouse \"  ,     \" touchy \"  ,     \" age \"  )  ;", "assertTrue (  \" Name   copied \"  ,     (  ( tb 2  . getName (  )  )     =  =    null )  )  ;", "assertTrue (  \" Age   still   empty \"  ,     (  ( tb 2  . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Touchy   still   empty \"  ,     (  ( tb 2  . getTouchy (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithIgnore"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BeanUtilsTests . NameAndSpecialProperty   source    =    new   BeanUtilsTests . NameAndSpecialProperty (  )  ;", "source . setName (  \" name \"  )  ;", "TestBean   target    =    new   TestBean (  )  ;", "BeanUtils . copyProperties ( source ,    target ,     \" specialProperty \"  )  ;", "assertEquals ( target . getName (  )  ,     \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithIgnoredNonExistingProperty"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BeanUtilsTests . InvalidProperty   source    =    new   BeanUtilsTests . InvalidProperty (  )  ;", "source . setName (  \" name \"  )  ;", "source . setFlag 1  ( true )  ;", "source . setFlag 2  ( true )  ;", "BeanUtilsTests . InvalidProperty   target    =    new   BeanUtilsTests . InvalidProperty (  )  ;", "BeanUtils . copyProperties ( source ,    target )  ;", "assertEquals (  \" name \"  ,    target . getName (  )  )  ;", "assertTrue ( target . getFlag 1  (  )  )  ;", "assertTrue ( target . getFlag 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyPropertiesWithInvalidProperty"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( ResourceEditor . class ,    BeanUtils . findEditorByConvention ( Resource . class )  . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFindEditorByConvention"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor [  ]    actual    =    Introspector . getBeanInfo ( TestBean . class )  . getPropertyDescriptors (  )  ;", "PropertyDescriptor [  ]    descriptors    =     . getPropertyDescriptors ( TestBean . class )  ;", "assertNotNull (  \" Descriptors   should   not   be   null \"  ,    descriptors )  ;", "assertEquals (  \" Invalid   number   of   descriptors   returned \"  ,    actual . length ,    descriptors . length )  ;", "}", "METHOD_END"], "methodName": ["testGetPropertyDescriptors"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "BeanUtils . instantiateClass ( ArrayList . class )  ;", "try    {", "BeanUtils . instantiateClass ( List . class )  ;", "fail (  \" Should   have   thrown   FatalBeanException \"  )  ;", "}    catch    ( FatalBeanException   ex )     {", "}", "try    {", "BeanUtils . instantiateClass ( CustomDateEditor . class )  ;", "fail (  \" Should   have   thrown   FatalBeanException \"  )  ;", "}    catch    ( FatalBeanException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testInstantiateClass"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "BeanUtils . resolveSignature (  \" doSomething (  \"  ,     . MethodSignatureBean . class )  ;", "fail (  \" Should   not   be   able   to   parse   with   opening   but   no   closing   paren .  \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "try    {", "BeanUtils . resolveSignature (  \" doSomething )  \"  ,     . MethodSignatureBean . class )  ;", "fail (  \" Should   not   be   able   to   parse   with   closing   but   no   opening   paren .  \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testResolveInvalidSignature"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" overloaded \"  )  ;", "assertSignatureEquals ( desiredMethod ,     \" overloaded (  )  \"  )  ;", "desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" overloaded \"  ,    String . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" overloaded ( String )  \"  )  ;", "desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" overloaded \"  ,    String . class ,    BeanFactory . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" overloaded ( String ,    factory . BeanFactory )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveOverloadedSignature"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" doSomethingWithAnArray \"  ,    String [  ]  . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomethingWithAnArray ( String [  ]  )  \"  )  ;", "desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" doSomethingWithAMultiDimensionalArray \"  ,    String [  ]  [  ]  . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomethingWithAMultiDimensionalArray ( String [  ]  [  ]  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveSignatureWithArray"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" doSomething \"  )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomething \"  )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomething (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveSimpleSignature"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" doSomethingElse \"  ,    String . class ,    int . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomethingElse ( String ,    int )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testResolveTypedSignature"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Method   desiredMethod    =    BeanUtilsTests . MethodSignatureBean . class . getMethod (  \" doSomethingElse \"  ,    String . class ,    int . class )  ;", "assertSignatureEquals ( desiredMethod ,     \" doSomethingElse \"  )  ;", "assertNull ( BeanUtils . resolveSignature (  \" doSomethingElse (  )  \"  ,    BeanUtilsTests . MethodSignatureBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveWithAndWithoutArgList"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor [  ]    descrs    =    BeanUtils . getPropertyDescriptors ( BeanUtilsTests . Bean . class )  ;", "PropertyDescriptor   keyDescr    =    BeanUtils . getPropertyDescriptor ( BeanUtilsTests . Bean . class ,     \" value \"  )  ;", "assertEquals ( String . class ,    keyDescr . getPropertyType (  )  )  ;", "for    ( PropertyDescriptor   propertyDescriptor    :    descrs )     {", "if    ( propertyDescriptor . getName (  )  . equals ( keyDescr . getName (  )  )  )     {", "assertEquals (  (  ( propertyDescriptor . getName (  )  )     +     \"    has   unexpected   type \"  )  ,    keyDescr . getPropertyType (  )  ,    propertyDescriptor . getPropertyType (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSPR6063"], "fileName": "org.springframework.beans.BeanUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" array [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    bean . getArray (  )  . length )  ;", "assertThat ( bean . getArray (  )  [  0  ]  ,    instanceOf (  . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowArray"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" array [  4  ]  \"  )  )  ;", "assertEquals (  5  ,    bean . getArray (  )  . length )  ;", "assertThat ( bean . getArray (  )  [  0  ]  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getArray (  )  [  1  ]  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getArray (  )  [  2  ]  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getArray (  )  [  3  ]  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getArray (  )  [  4  ]  ,    instanceOf (  . Bean . class )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" array [  0  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" array [  1  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" array [  2  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" array [  3  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowArrayBySeveralElements"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" list [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    bean . getList (  )  . size (  )  )  ;", "assertThat ( bean . getList (  )  . get (  0  )  ,    instanceOf (  . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowList"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" list [  4  ]  \"  )  )  ;", "assertEquals (  5  ,    bean . getList (  )  . size (  )  )  ;", "assertThat ( bean . getList (  )  . get (  0  )  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getList (  )  . get (  1  )  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getList (  )  . get (  2  )  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getList (  )  . get (  3  )  ,    instanceOf (  . Bean . class )  )  ;", "assertThat ( bean . getList (  )  . get (  4  )  ,    instanceOf (  . Bean . class )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" list [  0  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" list [  1  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" list [  2  ]  \"  )  )  ;", "assertNotNull ( wrapper . getPropertyValue (  \" list [  3  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowListBySeveralElements"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setAutoGrowCollectionLimit (  2  )  ;", "try    {", "assertNotNull ( wrapper . getPropertyValue (  \" list [  4  ]  \"  )  )  ;", "fail (  \" Should   have   thrown   InvalidPropertyException \"  )  ;", "}    catch    ( InvalidPropertyException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   IndexOutOfBoundsException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowListFailsAgainstLimit"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . getPropertyValue (  \" listNotParameterized [  0  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowListNotParameterized"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" multiArray [  0  ]  [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    bean . getMultiArray (  )  [  0  ]  . length )  ;", "assertThat ( bean . getMultiArray (  )  [  0  ]  [  0  ]  ,    instanceOf (  . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowMultiDimensionalArray"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( wrapper . getPropertyValue (  \" multiList [  0  ]  [  0  ]  \"  )  )  ;", "assertEquals (  1  ,    bean . getMultiList (  )  . get (  0  )  . size (  )  )  ;", "assertThat ( bean . getMultiList (  )  . get (  0  )  . get (  0  )  ,    instanceOf (  . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueAutoGrowMultiDimensionalList"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( wrapper . getPropertyValue (  \" nested . prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueNullValueInNestedPath"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . getPropertyValue (  \" nestedNoConstructor . prop \"  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValueNullValueInNestedPathNoDefaultConstructor"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setPropertyValue (  \" map [ A ]  . nested \"  ,    new   BeanWrapperAutoGrowingTests . Bean (  )  )  ;", "assertThat ( bean . getMap (  )  . get (  \" A \"  )  . getNested (  )  ,    instanceOf ( BeanWrapperAutoGrowingTests . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["setNestedPropertyValueAutoGrowMap"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setPropertyValue (  \" array [  0  ]  . prop \"  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    bean . getArray (  )  [  0  ]  . getProp (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyValueAutoGrowArray"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setPropertyValue (  \" list [  0  ]  . prop \"  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    bean . getList (  )  . get (  0  )  . getProp (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyValueAutoGrowList"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setPropertyValue (  \" map [ A ]  \"  ,    new   BeanWrapperAutoGrowingTests . Bean (  )  )  ;", "assertThat ( bean . getMap (  )  . get (  \" A \"  )  ,    instanceOf ( BeanWrapperAutoGrowingTests . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyValueAutoGrowMap"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setPropertyValue (  \" nested . prop \"  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    bean . getNested (  )  . getProp (  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyValueNullValueInNestedPath"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "wrapper . setAutoGrowNestedPaths ( true )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.BeanWrapperAutoGrowingTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnum \"  ,     \" VALUE _  1  \"  )  ;", "assertEquals ( CustomEnum . VALUE _  1  ,    gb . getCustomEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnum"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumArray \"  ,    new   String [  ]  {     \" VALUE _  1  \"  ,     \" VALUE _  2  \"     }  )  ;", "assertEquals (  2  ,    gb . getCustomEnumArray (  )  . length )  ;", "assertEquals ( CustomEnum . VALUE _  1  ,    gb . getCustomEnumArray (  )  [  0  ]  )  ;", "assertEquals ( CustomEnum . VALUE _  2  ,    gb . getCustomEnumArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumArrayWithMultipleValues"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumArray \"  ,     \" VALUE _  1  , VALUE _  2  \"  )  ;", "assertEquals (  2  ,    gb . getCustomEnumArray (  )  . length )  ;", "assertEquals ( CustomEnum . VALUE _  1  ,    gb . getCustomEnumArray (  )  [  0  ]  )  ;", "assertEquals ( CustomEnum . VALUE _  2  ,    gb . getCustomEnumArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumArrayWithMultipleValuesAsCsv"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumArray \"  ,     \" VALUE _  1  \"  )  ;", "assertEquals (  1  ,    gb . getCustomEnumArray (  )  . length )  ;", "assertEquals ( CustomEnum . VALUE _  1  ,    gb . getCustomEnumArray (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumArrayWithSingleValue"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumSetMismatch \"  ,    new   String [  ]  {     \" VALUE _  1  \"  ,     \" VALUE _  2  \"     }  )  ;", "assertEquals (  2  ,    gb . getCustomEnumSet (  )  . size (  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  1  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumSetWithGetterSetterMismatch"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumSet \"  ,    new   String [  ]  {     \" VALUE _  1  \"  ,     \" VALUE _  2  \"     }  )  ;", "assertEquals (  2  ,    gb . getCustomEnumSet (  )  . size (  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  1  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumSetWithMultipleValues"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumSet \"  ,     \" VALUE _  1  , VALUE _  2  \"  )  ;", "assertEquals (  2  ,    gb . getCustomEnumSet (  )  . size (  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  1  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumSetWithMultipleValuesAsCsv"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnumSet \"  ,     \" VALUE _  1  \"  )  ;", "assertEquals (  1  ,    gb . getCustomEnumSet (  )  . size (  )  )  ;", "assertTrue ( gb . getCustomEnumSet (  )  . contains ( CustomEnum . VALUE _  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumSetWithSingleValue"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnum \"  ,     \"  \"  )  ;", "assertEquals ( null ,    gb . getCustomEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumWithEmptyString"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" customEnum \"  ,    null )  ;", "assertEquals ( null ,    gb . getCustomEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEnumWithNull"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperEnumTests . NonPublicEnumHolder   holder    =    new   BeanWrapperEnumTests . NonPublicEnumHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" nonPublicEnum \"  ,     \" VALUE _  1  \"  )  ;", "assertEquals ( BeanWrapperEnumTests . NonPublicEnum . VALUE _  1  ,    holder . getNonPublicEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonPublicEnum"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setAutoGrowNestedPaths ( true )  ;", "assertNull ( gb . getStandardEnumMap (  )  )  ;", "bw . setPropertyValue (  \" standardEnumMap [ VALUE _  1  ]  \"  ,     1  )  ;", "assertEquals (  1  ,    gb . getStandardEnumMap (  )  . size (  )  )  ;", "assertEquals ( new   Integer (  1  )  ,    gb . getStandardEnumMap (  )  . get ( CustomEnum . VALUE _  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardEnumMapWithAutoGrowing"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setConversionService ( new   DefaultConversionService (  )  )  ;", "assertNull ( gb . getStandardEnumMap (  )  )  ;", "Map < String ,    Integer >    map    =    new   LinkedHashMap <  >  (  )  ;", "map . put (  \" VALUE _  1  \"  ,     1  )  ;", "map . put (  \" VALUE _  2  \"  ,     2  )  ;", "bw . setPropertyValue (  \" standardEnumMap \"  ,    map )  ;", "assertEquals (  2  ,    gb . getStandardEnumMap (  )  . size (  )  )  ;", "assertEquals ( new   Integer (  1  )  ,    gb . getStandardEnumMap (  )  . get ( CustomEnum . VALUE _  1  )  )  ;", "assertEquals ( new   Integer (  2  )  ,    gb . getStandardEnumMap (  )  . get ( CustomEnum . VALUE _  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardEnumMapWithMultipleValues"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setAutoGrowNestedPaths ( true )  ;", "assertNull ( gb . getStandardEnumSet (  )  )  ;", "bw . getPropertyValue (  \" standardEnumSet . class \"  )  ;", "assertEquals (  0  ,    gb . getStandardEnumSet (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardEnumSetWithAutoGrowing"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setConversionService ( new   DefaultConversionService (  )  )  ;", "assertNull ( gb . getStandardEnumSet (  )  )  ;", "bw . setPropertyValue (  \" standardEnumSet \"  ,    new   String [  ]  {     \" VALUE _  1  \"  ,     \" VALUE _  2  \"     }  )  ;", "assertEquals (  2  ,    gb . getStandardEnumSet (  )  . size (  )  )  ;", "assertTrue ( gb . getStandardEnumSet (  )  . contains ( CustomEnum . VALUE _  1  )  )  ;", "assertTrue ( gb . getStandardEnumSet (  )  . contains ( CustomEnum . VALUE _  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardEnumSetWithMultipleValues"], "fileName": "org.springframework.beans.BeanWrapperEnumTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    inputValue    =    new   LinkedList <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" derivedIndexedMap [  1  ]  \"  ,    inputValue )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getDerivedIndexedMap (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getDerivedIndexedMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexDerivedIndexedMapEntry"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    inputValue    =    new   HashSet <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" derivedIndexedMap [  1  ]  \"  ,    inputValue )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getDerivedIndexedMap (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getDerivedIndexedMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexDerivedIndexedMapEntryWithCollectionConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    inputValue    =    new   LinkedList <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" genericIndexedMap [  1  ]  \"  ,    inputValue )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getGenericIndexedMap (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getGenericIndexedMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexGenericIndexedMapEntry"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Set < String >    inputValue    =    new   HashSet <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" genericIndexedMap [  1  ]  \"  ,    inputValue )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getGenericIndexedMap (  )  . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getGenericIndexedMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexGenericIndexedMapEntryWithCollectionConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Map < List < String >  ,    List < String >  >    inputMap    =    new   HashMap <  >  (  )  ;", "List < String >    inputKey    =    new   LinkedList <  >  (  )  ;", "inputKey . add (  \"  1  \"  )  ;", "List < String >    inputValue    =    new   LinkedList <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", "inputMap . put ( inputKey ,    inputValue )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" genericMap \"  ,    inputMap )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getGenericMap (  )  . keySet (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getGenericMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexGenericMap"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Map < Set < String >  ,    Set < String >  >    inputMap    =    new   HashMap <  >  (  )  ;", "Set < String >    inputKey    =    new   HashSet <  >  (  )  ;", "inputKey . add (  \"  1  \"  )  ;", "Set < String >    inputValue    =    new   HashSet <  >  (  )  ;", "inputValue . add (  \"  1  0  \"  )  ;", "inputMap . put ( inputKey ,    inputValue )  ;", ". ComplexMapHolder   holder    =    new    . ComplexMapHolder (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( holder )  ;", "bw . setPropertyValue (  \" genericMap \"  ,    inputMap )  ;", "assertEquals ( new   Integer (  1  )  ,    holder . getGenericMap (  )  . keySet (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "assertEquals ( new   Long (  1  0  )  ,    holder . getGenericMap (  )  . values (  )  . iterator (  )  . next (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexGenericMapWithCollectionConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "List < String >    input    =    new   ArrayList <  >  (  )  ;", "input . add (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "input . add (  \" http :  /  / localhost :  9  0  9  0  \"  )  ;", "bw . setPropertyValue (  \" resourceList \"  ,    input )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericList"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "gb . setResourceList ( new   ArrayList <  >  (  )  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" resourceList [  0  ]  \"  ,     \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListElement"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "ArrayList < String [  ]  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  )  ;", "gb . setListOfArrays ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" listOfArrays [  0  ]  [  1  ]  \"  ,     \" str 3     \"  )  ;", "assertEquals (  \" str 3     \"  ,    bw . getPropertyValue (  \" listOfArrays [  0  ]  [  1  ]  \"  )  )  ;", "assertEquals (  \" str 3     \"  ,    gb . getListOfArrays (  )  . get (  0  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfArrays"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "ArrayList < String [  ]  >    list    =    new   ArrayList <  >  (  )  ;", "list . add ( new   String [  ]  {     \" str 1  \"  ,     \" str 2  \"     }  )  ;", "gb . setListOfArrays ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( false )  )  ;", "bw . setPropertyValue (  \" listOfArrays [  0  ]  [  1  ]  \"  ,     \" str 3     \"  )  ;", "assertEquals (  \" str 3  \"  ,    bw . getPropertyValue (  \" listOfArrays [  0  ]  [  1  ]  \"  )  )  ;", "assertEquals (  \" str 3  \"  ,    gb . getListOfArrays (  )  . get (  0  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfArraysWithElementConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "List < List < Integer >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   LinkedList <  >  (  )  )  ;", "gb . setListOfLists ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" listOfLists [  0  ]  [  0  ]  \"  ,    new   Integer (  5  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    bw . getPropertyValue (  \" listOfLists [  0  ]  [  0  ]  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getListOfLists (  )  . get (  0  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfLists"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "List < List < Integer >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   LinkedList <  >  (  )  )  ;", "gb . setListOfLists ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" listOfLists [  0  ]  [  0  ]  \"  ,     \"  5  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    bw . getPropertyValue (  \" listOfLists [  0  ]  [  0  ]  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getListOfLists (  )  . get (  0  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfListsWithElementConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "List < Map < Integer ,    Long >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   HashMap <  >  (  )  )  ;", "gb . setListOfMaps ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" listOfMaps [  0  ]  [  1  0  ]  \"  ,    new   Long (  5  )  )  ;", "assertEquals ( new   Long (  5  )  ,    bw . getPropertyValue (  \" listOfMaps [  0  ]  [  1  0  ]  \"  )  )  ;", "assertEquals ( new   Long (  5  )  ,    gb . getListOfMaps (  )  . get (  0  )  . get (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfMaps"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "List < Map < Integer ,    Long >  >    list    =    new   LinkedList <  >  (  )  ;", "list . add ( new   HashMap <  >  (  )  )  ;", "gb . setListOfMaps ( list )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" listOfMaps [  0  ]  [  1  0  ]  \"  ,     \"  5  \"  )  ;", "assertEquals ( new   Long (  5  )  ,    bw . getPropertyValue (  \" listOfMaps [  0  ]  [  1  0  ]  \"  )  )  ;", "assertEquals ( new   Long (  5  )  ,    gb . getListOfMaps (  )  . get (  0  )  . get (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfMapsWithElementConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . registerCustomEditor ( Number . class ,    new   CustomNumberEditor ( Integer . class ,    true )  )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "bw . setPropertyValue (  \" numberSet \"  ,    input )  ;", "assertTrue ( gb . getNumberSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getNumberSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericLowerBoundedSet"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "bw . setPropertyValue (  \" shortMap \"  ,    input )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMap"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "gb . setShortMap ( new   HashMap <  >  (  )  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" shortMap [  4  ]  \"  ,     \"  5  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    bw . getPropertyValue (  \" shortMap [  4  ]  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapElement"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "gb . setCollectionMap ( new   HashMap <  >  (  )  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . registerCustomEditor ( Number . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "HashSet < Integer >    value 1     =    new   HashSet <  >  (  )  ;", "value 1  . add ( new   Integer (  1  )  )  ;", "bw . setPropertyValue (  \" collectionMap [  1  ]  \"  ,    value 1  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  1  )  )  )    instanceof   HashSet )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapElementWithCollectionValue"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "gb . setLongMap ( new   HashMap < Long ,    Integer >  (  )  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" longMap [  4  ]  \"  ,     \"  5  \"  )  ;", "assertEquals (  \"  5  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  4  \"  )  )  )  ;", "assertEquals (  \"  5  \"  ,    bw . getPropertyValue (  \" longMap [  4  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapElementWithKeyType"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "Properties   input    =    new   Properties (  )  ;", "input . setProperty (  \"  4  \"  ,     \"  5  \"  )  ;", "input . setProperty (  \"  6  \"  ,     \"  7  \"  )  ;", "bw . setPropertyValue (  \" shortMap \"  ,    input )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapFromProperties"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "Map < Integer ,    List < Integer >  >    map    =    new   HashMap <  >  (  )  ;", "map . put ( new   Integer (  1  )  ,    new   LinkedList <  >  (  )  )  ;", "gb . setMapOfLists ( map )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" mapOfLists [  1  ]  [  0  ]  \"  ,    new   Integer (  5  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    bw . getPropertyValue (  \" mapOfLists [  1  ]  [  0  ]  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getMapOfLists (  )  . get ( new   Integer (  1  )  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapOfLists"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "Map < Integer ,    List < Integer >  >    map    =    new   HashMap <  >  (  )  ;", "map . put ( new   Integer (  1  )  ,    new   LinkedList <  >  (  )  )  ;", "gb . setMapOfLists ( map )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" mapOfLists [  1  ]  [  0  ]  \"  ,     \"  5  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    bw . getPropertyValue (  \" mapOfLists [  1  ]  [  0  ]  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getMapOfLists (  )  . get ( new   Integer (  1  )  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapOfListsWithElementConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "Map < String ,    Map < Integer ,    Long >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" mykey \"  ,    new   HashMap <  >  (  )  )  ;", "gb . setMapOfMaps ( map )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" mapOfMaps [ mykey ]  [  1  0  ]  \"  ,    new   Long (  5  )  )  ;", "assertEquals ( new   Long (  5  )  ,    bw . getPropertyValue (  \" mapOfMaps [ mykey ]  [  1  0  ]  \"  )  )  ;", "assertEquals ( new   Long (  5  )  ,    gb . getMapOfMaps (  )  . get (  \" mykey \"  )  . get (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapOfMaps"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean < String >    gb    =    new   GenericBean <  >  (  )  ;", "Map < String ,    Map < Integer ,    Long >  >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" mykey \"  ,    new   HashMap <  >  (  )  )  ;", "gb . setMapOfMaps ( map )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" mapOfMaps [ mykey ]  [  1  0  ]  \"  ,     \"  5  \"  )  ;", "assertEquals ( new   Long (  5  )  ,    bw . getPropertyValue (  \" mapOfMaps [ mykey ]  [  1  0  ]  \"  )  )  ;", "assertEquals ( new   Long (  5  )  ,    gb . getMapOfMaps (  )  . get (  \" mykey \"  )  . get (  1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapOfMapsWithElementConversion"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . registerCustomEditor ( Number . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "Map < String ,    Collection >    input    =    new   HashMap <  >  (  )  ;", "HashSet < Integer >    value 1     =    new   HashSet <  >  (  )  ;", "value 1  . add ( new   Integer (  1  )  )  ;", "input . put (  \"  1  \"  ,    value 1  )  ;", "ArrayList < Boolean >    value 2     =    new   ArrayList <  >  (  )  ;", "value 2  . add ( Boolean . TRUE )  ;", "input . put (  \"  2  \"  ,    value 2  )  ;", "bw . setPropertyValue (  \" collectionMap \"  ,    input )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  1  )  )  )    instanceof   HashSet )  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  2  )  )  )    instanceof   ArrayList )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithCollectionValue"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "bw . setPropertyValue (  \" longMap \"  ,    input )  ;", "assertEquals (  \"  5  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  4  \"  )  )  )  ;", "assertEquals (  \"  7  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithKeyType"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "bw . setPropertyValue (  \" integerSet \"  ,    input )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSet"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericBean <  ?  >    gb    =    new   GenericBean <  >  (  )  ;", "bw    =    new   Impl ( gb )  ;", "Set < TestBean >    input    =    new   HashSet <  >  (  )  ;", "input . add ( new   TestBean (  )  )  ;", "try    {", "bw . setPropertyValue (  \" integerSet \"  ,    input )  ;", "fail (  \" Should   have   thrown   TypeMismatchException \"  )  ;", "}    catch    ( TypeMismatchException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . indexOf (  \" Integer \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGenericSetWithConversionFailure"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "List < Map < String ,    String >  >    list    =    new   LinkedList <  >  (  )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" testKey \"  ,     \"  5  \"  )  ;", "list . add ( map )  ;", ". NestedGenericCollectionBean   gb    =    new    . NestedGenericCollectionBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( gb )  ;", "bw . setPropertyValue (  \" listOfMapOfInteger \"  ,    list )  ;", "Object   obj    =    gb . getListOfMapOfInteger (  )  . get (  0  )  . get (  \" testKey \"  )  ;", "assertTrue (  ( obj   instanceof   Integer )  )  ;", "assertEquals (  5  ,     (  ( Integer )     ( obj )  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericTypeNestingListOfMapOfInteger"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" testKey \"  ,     \"  1  0  0  \"  )  ;", ". NestedGenericCollectionBean   gb    =    new    . NestedGenericCollectionBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( gb )  ;", "bw . setPropertyValue (  \" mapOfInteger \"  ,    map )  ;", "Object   obj    =    gb . getMapOfInteger (  )  . get (  \" testKey \"  )  ;", "assertTrue (  ( obj   instanceof   Integer )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericTypeNestingMapOfInteger"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    map    =    new   HashMap <  >  (  )  ;", "List < String >    list    =    Arrays . asList ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  )  ;", "map . put (  \" testKey \"  ,    list )  ;", ". NestedGenericCollectionBean   gb    =    new    . NestedGenericCollectionBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( gb )  ;", "bw . setPropertyValue (  \" mapOfListOfInteger \"  ,    map )  ;", "Object   obj    =    gb . getMapOfListOfInteger (  )  . get (  \" testKey \"  )  . get (  0  )  ;", "assertTrue (  ( obj   instanceof   Integer )  )  ;", "assertEquals (  1  ,     (  ( Integer )     ( obj )  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericTypeNestingMapOfListOfInteger"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < List < String >  >  >    map    =    new   HashMap <  >  (  )  ;", "List < String >    list    =    Arrays . asList ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"  ,     \"  3  \"     }  )  ;", "map . put (  \" testKey \"  ,    Collections . singletonList ( list )  )  ;", ". NestedGenericCollectionBean   gb    =    new    . NestedGenericCollectionBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( gb )  ;", "bw . setPropertyValue (  \" mapOfListOfListOfInteger \"  ,    map )  ;", "Object   obj    =    gb . getMapOfListOfListOfInteger (  )  . get (  \" testKey \"  )  . get (  0  )  . get (  0  )  ;", "assertTrue (  ( obj   instanceof   Integer )  )  ;", "assertEquals (  1  ,     (  ( Integer )     ( obj )  )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericTypeNestingMapOfListOfListOfInteger"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericIntegerBean   gb    =    new   GenericIntegerBean (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" genericProperty \"  ,     \"  1  0  \"  )  ;", "bw . setPropertyValue (  \" genericListProperty \"  ,    new   String [  ]  {     \"  2  0  \"  ,     \"  3  0  \"     }  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    gb . getGenericProperty (  )  )  ;", "assertEquals ( new   Integer (  2  0  )  ,    gb . getGenericListProperty (  )  . get (  0  )  )  ;", "assertEquals ( new   Integer (  3  0  )  ,    gb . getGenericListProperty (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericallyTypedIntegerBean"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "GenericSetOfIntegerBean   gb    =    new   GenericSetOfIntegerBean (  )  ;", "bw    =    new   Impl ( gb )  ;", "bw . setPropertyValue (  \" genericProperty \"  ,     \"  1  0  \"  )  ;", "bw . setPropertyValue (  \" genericListProperty \"  ,    new   String [  ]  {     \"  2  0  \"  ,     \"  3  0  \"     }  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    gb . getGenericProperty (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Integer (  2  0  )  ,    gb . getGenericListProperty (  )  . get (  0  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Integer (  3  0  )  ,    gb . getGenericListProperty (  )  . get (  1  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericallyTypedSetOfIntegerBean"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperGenericsTests . Bar   bar    =    new   BeanWrapperGenericsTests . Bar (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bar )  ;", "bw . setPropertyValue (  \" version \"  ,     \"  1  0  \"  )  ;", "assertEquals ( new   Double (  1  0  .  0  )  ,    bar . getVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSettingGenericPropertyWithReadOnlyInterface"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperGenericsTests . Promotion   bean    =    new   BeanWrapperGenericsTests . Promotion (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . setPropertyValue (  \" id \"  ,     \"  1  0  \"  )  ;", "assertEquals ( new   Long (  1  0  )  ,    bean . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSettingLongPropertyWithGenericInterface"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "class   Holder < D >     {", "private   final   D   data ;", "public   Holder ( D   data )     {", "this . data    =    data ;", "}", "public   D   getData (  )     {", "return   this . data ;", "}", "}", "Map < String ,    Object >    data    =    new   HashMap <  >  (  )  ;", "data . put (  \" x \"  ,     \" y \"  )  ;", "Holder < Map < String ,    Object >  >    context    =    new   Holder <  >  ( data )  ;", "bw    =    PropertyAccessorFactory . forBeanPropertyAccess ( context )  ;", "assertEquals (  \" y \"  ,    bw . getPropertyValue (  \" data [  ' x '  ]  \"  )  )  ;", "bw . setPropertyValue (  \" data [  ' message '  ]  \"  ,     \" it   works !  \"  )  ;", "assertEquals (  \" it   works !  \"  ,    data . get (  \" message \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUntypedPropertyWithMapAtRuntime"], "fileName": "org.springframework.beans.BeanWrapperGenericsTests"}, {"methodBody": ["METHOD_START", "{", "CachedIntrospectionResults   cachedIntrospectionResults    =    getCachedIntrospectionResults (  )  ;", "PropertyDescriptor   pd    =    cachedIntrospectionResults . getPropertyDescriptor ( propertyN )  ;", "if    ( pd    =  =    null )     {", "throw   new   InvalidPropertyException ( getRootClass (  )  ,     (  ( getNestedPath (  )  )     +    propertyN )  ,     (  (  \" No   property    '  \"     +    propertyN )     +     \"  '    found \"  )  )  ;", "}", "TypeDescriptor   td    =    cachedIntrospectionResults . getTypeDescriptor ( pd )  ;", "if    ( td    =  =    null )     {", "td    =    cachedIntrospectionResults . addTypeDescriptor ( pd ,    new   TypeDescriptor ( property ( pd )  )  )  ;", "}", "return   convertForProperty ( propertyN ,    null ,    value ,    td )  ;", "}", "METHOD_END"], "methodName": ["convertForProperty"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . cachedIntrospectionResults )     =  =    null )     {", "this . cachedIntrospectionResults    =    CachedIntrospectionResults . forClass ( getdClass (  )  )  ;", "}", "return   this . cachedIntrospectionResults ;", "}", "METHOD_END"], "methodName": ["getCachedIntrospectionResults"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "return   this . acc ;", "}", "METHOD_END"], "methodName": ["getSecurityContext"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "GenericTypeAwarePropertyDescriptor   gpd    =     (  ( GenericTypeAwarePropertyDescriptor )     ( pd )  )  ;", "return   new   Property ( gpd . getClass (  )  ,    gpd . getReadMethod (  )  ,    gpd . getWriteMethod (  )  ,    gpd . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "this . wrappedObject    =    object ;", "this . rootObject    =    object ;", "this . typeConverterDelegate    =    new   TypeConverterDelegate ( this ,    this . wrappedObject )  ;", "setIntrospectionClass ( object . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setBeanInstance"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . cachedIntrospectionResults )     !  =    null )     &  &     (  ( this . cachedIntrospectionResults . getBeanClass (  )  )     !  =    clazz )  )     {", "this . cachedIntrospectionResults    =    null ;", "}", "}", "METHOD_END"], "methodName": ["setIntrospectionClass"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "this . acc    =    acc ;", "}", "METHOD_END"], "methodName": ["setSecurityContext"], "fileName": "org.springframework.beans.BeanWrapperImpl"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . GetterBean   target    =    new   BeanWrapperTests . GetterBean (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" aliasedName \"  ,     \" tom \"  )  ;", "assertTrue (  \" Set   name   to   tom \"  ,    target . getAliasedName (  )  . equals (  \" tom \"  )  )  ;", "}", "METHOD_END"], "methodName": ["aliasedSetterThroughDefaultMethod"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" ag \"  ,     \" foobar \"  )  ;", "fail (  \" Should   throw   exception   on   invalid   property \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "assertEquals (  1  ,    ex . getPossibleMatches (  )  . length )  ;", "assertEquals (  \" age \"  ,    ex . getPossibleMatches (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNotWritablePropertyHoldPossibleMatches"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . GetterWithOptional   target    =    new   BeanWrapperTests . GetterWithOptional (  )  ;", "TestBean   tb    =    new   TestBean (  \" x \"  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" object \"  ,    tb )  ;", "assertSame ( tb ,    target . value )  ;", "assertSame ( tb ,    target . getObject (  )  . get (  )  )  ;", "assertSame ( tb ,     (  ( Optional < String >  )     ( accessor . getPropertyValue (  \" object \"  )  )  )  . get (  )  )  ;", "assertEquals (  \" x \"  ,    target . value . getName (  )  )  ;", "assertEquals (  \" x \"  ,    target . getObject (  )  . get (  )  . getName (  )  )  ;", "assertEquals (  \" x \"  ,    accessor . getPropertyValue (  \" object . name \"  )  )  ;", "accessor . setPropertyValue (  \" object . name \"  ,     \" y \"  )  ;", "assertSame ( tb ,    target . value )  ;", "assertSame ( tb ,    target . getObject (  )  . get (  )  )  ;", "assertSame ( tb ,     (  ( Optional < String >  )     ( accessor . getPropertyValue (  \" object \"  )  )  )  . get (  )  )  ;", "assertEquals (  \" y \"  ,    target . value . getName (  )  )  ;", "assertEquals (  \" y \"  ,    target . getObject (  )  . get (  )  . getName (  )  )  ;", "assertEquals (  \" y \"  ,    accessor . getPropertyValue (  \" object . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyWithOptional"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . GetterWithOptional   target    =    new   BeanWrapperTests . GetterWithOptional (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setAutoGrowNestedPaths ( true )  ;", "accessor . setPropertyValue (  \" object . name \"  ,     \" x \"  )  ;", "assertEquals (  \" x \"  ,    target . value . getName (  )  )  ;", "assertEquals (  \" x \"  ,    target . getObject (  )  . get (  )  . getName (  )  )  ;", "assertEquals (  \" x \"  ,    accessor . getPropertyValue (  \" object . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getPropertyWithOptionalAndAutoGrow"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . GetterBean   target    =    new   BeanWrapperTests . GetterBean (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setExtractOldValueForEditor ( true )  ;", "accessor . setPropertyValue (  \" name \"  ,     \" tom \"  )  ;", "assertTrue (  \" Set   name   to   tom \"  ,    target . getName (  )  . equals (  \" tom \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getterSilentlyFailWithOldValueExtraction"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \"  [  '  ]  \"  ,     \" foobar \"  )  ;", "fail (  \" Should   throw   exception   on   invalid   property \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "assertNull ( ex . getPossibleMatches (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["incompletelyQuotedKeyLeadsToPropertyException"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . IntelliBean   target    =    new   BeanWrapperTests . IntelliBean (  )  ;", "BeanWrapper   bw    =    createAccessor ( target )  ;", "try    {", "bw . setPropertyValue (  \" names \"  ,     \" Alef \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "assertNotNull (  \" Possible   matches   not   determined \"  ,    ex . getPossibleMatches (  )  )  ;", "assertEquals (  \" Invalid   amount   of   alternatives \"  ,     1  ,    ex . getPossibleMatches (  )  . length )  ;", "}", "}", "METHOD_END"], "methodName": ["notWritablePropertyExceptionContainsAlternativeMatch"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . IntelliBean   target    =    new   BeanWrapperTests . IntelliBean (  )  ;", "BeanWrapper   bw    =    createAccessor ( target )  ;", "try    {", "bw . setPropertyValue (  \" mystring \"  ,     \" Arjen \"  )  ;", "}    catch    ( NotWritablePropertyException   ex )     {", "assertNotNull (  \" Possible   matches   not   determined \"  ,    ex . getPossibleMatches (  )  )  ;", "assertEquals (  \" Invalid   amount   of   alternatives \"  ,     3  ,    ex . getPossibleMatches (  )  . length )  ;", "}", "}", "METHOD_END"], "methodName": ["notWritablePropertyExceptionContainsAlternativeMatches"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "target . setSpouse ( new   TestBean (  )  )  ;", "accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" name \"  ,     \" a \"  )  ;", "accessor . setPropertyValue (  \" spouse . name \"  ,     \" b \"  )  ;", "assertEquals (  \" a \"  ,    target . getName (  )  )  ;", "assertEquals (  \" b \"  ,    target . getSpouse (  )  . getName (  )  )  ;", "assertEquals (  \" a \"  ,    accessor . getPropertyValue (  \" name \"  )  )  ;", "assertEquals (  \" b \"  ,    accessor . getPropertyValue (  \" spouse . name \"  )  )  ;", "assertEquals ( String . class ,    accessor . getPropertyDescriptor (  \" name \"  )  . getPropertyType (  )  )  ;", "assertEquals ( String . class ,    accessor . getPropertyDescriptor (  \" spouse . name \"  )  . getPropertyType (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDescriptors"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . PropertyTypeMismatch   target    =    new   BeanWrapperTests . PropertyTypeMismatch (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" object \"  ,     \" a   String \"  )  ;", "assertEquals (  \" a   String \"  ,    target . value )  ;", "assertTrue (  (  ( target . getObject (  )  )     =  =     8  )  )  ;", "assertEquals (  8  ,    accessor . getPropertyValue (  \" object \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setPropertyTypeMismatch"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . TypedReadOnlyMap   map    =    new   BeanWrapperTests . TypedReadOnlyMap ( Collections . singletonMap (  \" key \"  ,    new   TestBean (  )  )  )  ;", "BeanWrapperTests . TypedReadOnlyMapClient   target    =    new   BeanWrapperTests . TypedReadOnlyMapClient (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" map \"  ,    map )  ;", "}", "METHOD_END"], "methodName": ["setReadOnlyMapProperty"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   target    =    new   TestBean (  )  ;", "String   newName    =     \" tony \"  ;", "String   invalidTouchy    =     \"  . valid \"  ;", "try    {", "accessor    =    createAccessor ( target )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \" foobar \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,    newName )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" touchy \"  ,    invalidTouchy )  )  ;", "accessor . setPropertyValues ( pvs )  ;", "fail (  \" Should   throw   exception   when   everything   is   valid \"  )  ;", "}    catch    ( PropertyBatchUpdateException   ex )     {", "assertTrue (  \" Must   contain    2    exceptions \"  ,     (  ( ex . getExceptionCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Vaid   set   property   must   stick \"  ,    target . getName (  )  . equals ( newName )  )  ;", "assertTrue (  \" Invalid   set   property   must   retain   old   value \"  ,     (  ( target . getAge (  )  )     =  =     0  )  )  ;", "assertTrue (  \" New   value   of   dodgy   setter   must   be   available   through   exception \"  ,    ex . getPropertyAccessException (  \" touchy \"  )  . getPropertyChangeEvent (  )  . getNewValue (  )  . equals ( invalidTouchy )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setValidAndInvalidPropertyValuesShouldContainExceptionDetails"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperTests . GetterBean   target    =    new   BeanWrapperTests . GetterBean (  )  ;", "BeanWrapper   accessor    =    createAccessor ( target )  ;", "accessor . setPropertyValue (  \" name \"  ,     \" tom \"  )  ;", "assertTrue (  \" Set   name   to   tom \"  ,    target . getName (  )  . equals (  \" tom \"  )  )  ;", "}", "METHOD_END"], "methodName": ["setterDoesNotCallGetter"], "fileName": "org.springframework.beans.BeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "if    ( classLoader    !  =    null )     {", ". acceptedClassLoaders . add ( classLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["acceptClassLoader"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "TypeDescriptor   existing    =    this . typeDescriptorCache . putIfAbsent ( pd ,    td )  ;", "return   existing    !  =    null    ?    existing    :    td ;", "}", "METHOD_END"], "methodName": ["addTypeDescriptor"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   GenericTypeAwarePropertyDescriptor ( beanClass ,    pd . getName (  )  ,    pd . getReadMethod (  )  ,    pd . getWriteMethod (  )  ,    pd . getPropertyEditorClass (  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   FatalBeanException (  (  (  \" Failed   to   re - introspect   class    [  \"     +     ( beanClass . getName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["buildGenericTypeAwarePropertyDescriptor"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "CachedIntrospectionResults . acceptedClassLoaders . removeIf (  (    registeredLoader )     -  >    CachedIntrospectionResults . isUnderneathClassLoader ( registeredLoader ,    classLoader )  )  ;", "CachedIntrospectionResults . strongClassCache . keySet (  )  . removeIf (  (    beanClass )     -  >    CachedIntrospectionResults . isUnderneathClassLoader ( beanClass . getClassLoader (  )  ,    classLoader )  )  ;", "CachedIntrospectionResults . softClassCache . keySet (  )  . removeIf (  (    beanClass )     -  >    CachedIntrospectionResults . isUnderneathClassLoader ( beanClass . getClassLoader (  )  ,    classLoader )  )  ;", "}", "METHOD_END"], "methodName": ["clearClassLoader"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "CachedIntrospectionResults   results    =    CachedIntrospectionResults . strongClassCache . get ( beanClass )  ;", "if    ( results    !  =    null )     {", "return   results ;", "}", "results    =    CachedIntrospectionResults . softClassCache . get ( beanClass )  ;", "if    ( results    !  =    null )     {", "return   results ;", "}", "results    =    new   CachedIntrospectionResults ( beanClass )  ;", "ConcurrentMap < Class <  ?  >  ,    CachedIntrospectionResults >    classCacheToUse ;", "if    (  ( ClassUtils . isCacheSafe ( beanClass ,    CachedIntrospectionResults . class . getClassLoader (  )  )  )     |  |     ( CachedIntrospectionResults . isClassLoaderAccepted ( beanClass . getClassLoader (  )  )  )  )     {", "classCacheToUse    =    CachedIntrospectionResults . strongClassCache ;", "} else    {", "if    ( CachedIntrospectionResults . logger . isDebugEnabled (  )  )     {", "CachedIntrospectionResults . logger . debug (  (  (  \" Not   strongly   caching   class    [  \"     +     ( beanClass . getName (  )  )  )     +     \"  ]    because   it   is   not   cache - safe \"  )  )  ;", "}", "classCacheToUse    =    CachedIntrospectionResults . softClassCache ;", "}", "CachedIntrospectionResults   existing    =    classCacheToUse . putIfAbsent ( beanClass ,    results )  ;", "return   existing    !  =    null    ?    existing    :    results ;", "}", "METHOD_END"], "methodName": ["forClass"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "return   this . beanInfo . getBeanDescriptor (  )  . getBeanClass (  )  ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "return   this . beanInfo ;", "}", "METHOD_END"], "methodName": ["getBeanInfo"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanInfoFactory   beanInfoFactory    :    CachedIntrospectionResults . beanInfoFactories )     {", "BeanInfo   beanInfo    =    beanInfoFactory . getBeanInfo ( beanClass )  ;", "if    ( beanInfo    !  =    null )     {", "return   beanInfo ;", "}", "}", "return   CachedIntrospectionResults . shouldIntrospectorIgnoreBeaninfoClasses    ?    Introspector . getBeanInfo ( beanClass ,    Introspector . IGNORE _ ALL _ BEANINFO )     :    Introspector . getBeanInfo ( beanClass )  ;", "}", "METHOD_END"], "methodName": ["getBeanInfo"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor   pd    =    this . propertyDescriptorCache . get ( name )  ;", "if    (  ( pd    =  =    null )     &  &     ( StringUtils . hasLength ( name )  )  )     {", "pd    =    this . propertyDescriptorCache . get ( StringUtils . uncapitalize ( name )  )  ;", "if    ( pd    =  =    null )     {", "pd    =    this . propertyDescriptorCache . get ( StringUtils . capitalize ( name )  )  ;", "}", "}", "return    ( pd    =  =    null )     |  |     ( pd   instanceof   GenericTypeAwarePropertyDescriptor )     ?    pd    :    buildGenericTypeAwarePropertyDescriptor ( getBeanClass (  )  ,    pd )  ;", "}", "METHOD_END"], "methodName": ["getPropertyDescriptor"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor [  ]    pds    =    new   PropertyDescriptor [ this . propertyDescriptorCache . size (  )  ]  ;", "int   i    =     0  ;", "for    ( PropertyDescriptor   pd    :    this . propertyDescriptorCache . values (  )  )     {", "pds [ i ]     =     ( pd   instanceof   GenericTypeAwarePropertyDescriptor )     ?    pd    :    buildGenericTypeAwarePropertyDescriptor ( getBeanClass (  )  ,    pd )  ;", "i +  +  ;", "}", "return   pds ;", "}", "METHOD_END"], "methodName": ["getPropertyDescriptors"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "return   this . typeDescriptorCache . get ( pd )  ;", "}", "METHOD_END"], "methodName": ["getTypeDescriptor"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "for    ( ClassLoader   acceptedLoader    :    CachedIntrospectionResults . acceptedClassLoaders )     {", "if    ( CachedIntrospectionResults . isUnderneathClassLoader ( classLoader ,    acceptedLoader )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isClassLoaderAccepted"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "if    ( candidate    =  =    parent )     {", "return   true ;", "}", "if    ( candidate    =  =    null )     {", "return   false ;", "}", "ClassLoader   classLoaderToCheck    =    candidate ;", "while    ( classLoaderToCheck    !  =    null )     {", "classLoaderToCheck    =    classLoaderToCheck . getParent (  )  ;", "if    ( classLoaderToCheck    =  =    parent )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isUnderneathClassLoader"], "fileName": "org.springframework.beans.CachedIntrospectionResults"}, {"methodBody": ["METHOD_START", "{", "BeanWrapper   bw    =    new   BeanWrapperImpl ( TestBean . class )  ;", "assertTrue ( bw . isWritableProperty (  \" name \"  )  )  ;", "assertTrue ( bw . isWritableProperty (  \" age \"  )  )  ;", "assertTrue (  . strongClassCache . containsKey ( TestBean . class )  )  ;", "ClassLoader   child    =    new   OverridingClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "Class <  ?  >    tbClass    =    child . loadClass (  \" TestBean \"  )  ;", "assertFalse (  . strongClassCache . containsKey ( tbClass )  )  ;", ". acceptClassLoader ( child )  ;", "bw    =    new   BeanWrapperImpl ( tbClass )  ;", "assertTrue ( bw . isWritableProperty (  \" name \"  )  )  ;", "assertTrue ( bw . isWritableProperty (  \" age \"  )  )  ;", "assertTrue (  . strongClassCache . containsKey ( tbClass )  )  ;", ". clearClassLoader ( child )  ;", "assertFalse (  . strongClassCache . containsKey ( tbClass )  )  ;", "assertTrue (  . strongClassCache . containsKey ( TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["acceptAndClearClassLoader"], "fileName": "org.springframework.beans.CachedIntrospectionResultsTests"}, {"methodBody": ["METHOD_START", "{", "BeanUtils . getPropertyDescriptors ( ArrayList . class )  ;", "assertTrue (  . strongClassCache . containsKey ( ArrayList . class )  )  ;", ". clearClassLoader ( ArrayList . class . getClassLoader (  )  )  ;", "assertFalse (  . strongClassCache . containsKey ( ArrayList . class )  )  ;", "}", "METHOD_END"], "methodName": ["clearClassLoaderForSystemClassLoader"], "fileName": "org.springframework.beans.CachedIntrospectionResultsTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setFoo ( String   s )     {", "return   this ;", "}", "public   String   getFoo (  )     {", "return   null ;", "}", "}", "results    =     . forClass ( C . class )  ;", "BeanInfo   info    =    results . getBeanInfo (  )  ;", "PropertyDescriptor   pd    =    null ;", "for    ( PropertyDescriptor   candidate    :    info . getPropertyDescriptors (  )  )     {", "if    ( candidate . getName (  )  . equals (  \" foo \"  )  )     {", "pd    =    candidate ;", "}", "}", "assertThat ( pd ,    notNullValue (  )  )  ;", "assertThat ( pd . getReadMethod (  )  ,    equalTo ( C . class . getMethod (  \" getFoo \"  )  )  )  ;", "assertThat (  (  \" No   write   method   found   for   non - void   returning    ' setFoo '    method .     \"     +     (  \" Check   to   see   if      is   delegating   to    \"     +     \" ExtendedBeanInfo   as   expected \"  )  )  ,    pd . getWriteMethod (  )  ,    equalTo ( C . class . getMethod (  \" setFoo \"  ,    String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldUseExtendedBeanInfoWhenApplicable"], "fileName": "org.springframework.beans.CachedIntrospectionResultsTests"}, {"methodBody": ["METHOD_START", "{", "ConcurrentBeanWrapperTests . TestBean   bean    =    new   ConcurrentBeanWrapperTests . TestBean (  )  ;", "Properties   p    =     (  ( Properties )     ( System . getProperties (  )  . clone (  )  )  )  ;", "assertTrue (  \" The   System   properties   must   not   be   empty \"  ,     (  ( p . size (  )  )     !  =     0  )  )  ;", "for    ( Iterator <  ?  >    i    =    p . entrySet (  )  . iterator (  )  ;    i . hasNext (  )  ;  )     {", "i . next (  )  ;", "if    (  ( Math . random (  )  )     >     0  .  9  )     {", "i . remove (  )  ;", "}", "}", "ByteArrayOutputStream   buffer    =    new   ByteArrayOutputStream (  )  ;", "try    {", "p . store ( buffer ,    null )  ;", "}    catch    ( IOException   e )     {", "}", "String   value    =    new   String ( buffer . toByteArray (  )  )  ;", "BeanWrapperImpl   wrapper    =    new   BeanWrapperImpl ( bean )  ;", "wrapper . setPropertyValue (  \" properties \"  ,    value )  ;", "assertEquals ( p ,    bean . getProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["performSet"], "fileName": "org.springframework.beans.ConcurrentBeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", ". TestRun   run    =    new    . TestRun ( this )  ;", "set . add ( run )  ;", "Thread   t    =    new   Thread ( run )  ;", "t . setDaemon ( true )  ;", "t . start (  )  ;", "}", "logger . info (  (  (  \" Thread   creation   over ,     \"     +     ( set . size (  )  )  )     +     \"    still   active .  \"  )  )  ;", "synchronized ( this )     {", "while    (  (  !  ( set . isEmpty (  )  )  )     &  &     (  ( ex )     =  =    null )  )     {", "try    {", "wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "logger . info ( e . toString (  )  )  ;", "}", "logger . info (  (  ( set . size (  )  )     +     \"    threads   still   active .  \"  )  )  ;", "}", "}", "if    (  ( ex )     !  =    null )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testConcurrent"], "fileName": "org.springframework.beans.ConcurrentBeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", ". performSet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleThread"], "fileName": "org.springframework.beans.ConcurrentBeanWrapperTests"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   sb    =    new   StringBuilder (  )  ;", "@ SuppressWarnings (  \" serial \"  )", "TestBean   target    =    new   TestBean (  )     {", "@ SuppressWarnings (  \" unused \"  )", "StringBuilder   name    =    sb ;", "}  ;", "dfa    =    createAccessor ( target )  ;", "assertEquals ( StringBuilder . class ,    dfa . getPropertyType (  \" name \"  )  )  ;", "assertEquals ( sb ,    dfa . getPropertyValue (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["withShadowedField"], "fileName": "org.springframework.beans.DirectFieldAccessorTests"}, {"methodBody": ["METHOD_START", "{", "List < Method >    matches    =    new   ArrayList <  >  (  )  ;", "for    ( MethodDescriptor   methodDescriptor    :    methodDescriptors )     {", "Method   method    =    methodDescriptor . getMethod (  )  ;", "if    (  . isCandidateWriteMethod ( method )  )     {", "matches . add ( method )  ;", "}", "}", "matches . sort (  (    m 1  ,    m 2  )     -  >    m 2  . toString (  )  . compareTo ( m 1  . toString (  )  )  )  ;", "return   matches ;", "}", "METHOD_END"], "methodName": ["findCandidateWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfo"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyDescriptor   pd    :    this . propertyDescriptors )     {", "final   Class <  ?  >    candidateType ;", "final   St   candidateName    =    pd . getName (  )  ;", "if    ( pd   instanceof   IndexedPropertyDescriptor )     {", "IndexedPropertyDescriptor   ipd    =     (  ( IndexedPropertyDescriptor )     ( pd )  )  ;", "candidateType    =    ipd . getIndexedPropertyType (  )  ;", "if    (  ( candidateName . equals ( propertyName )  )     &  &     (  ( candidateType . equals ( propertyType )  )     |  |     ( candidateType . equals ( propertyType . getComponentType (  )  )  )  )  )     {", "return   pd ;", "}", "} else    {", "candidateType    =    pd . getPropertyType (  )  ;", "if    (  ( candidateName . equals ( propertyName )  )     &  &     (  ( candidateType . equals ( propertyType )  )     |  |     ( propertyType . equals ( candidateType . getComponentType (  )  )  )  )  )     {", "return   pd ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findExistingPropertyDescriptor"], "fileName": "org.springframework.beans.ExtendedBeanInfo"}, {"methodBody": ["METHOD_START", "{", "int   nParams    =    method . getParameterCount (  )  ;", "String   propertyName    =    propertyNameFor ( method )  ;", "Class <  ?  >    propertyType    =    method . getParameterTypes (  )  [  ( nParams    -     1  )  ]  ;", "PropertyDescriptor   existingPd    =    findExistingPropertyDescriptor ( propertyName ,    propertyType )  ;", "if    ( nParams    =  =     1  )     {", "if    ( existingPd    =  =    null )     {", "this . propertyDescriptors . add ( new    . SimplePropertyDescriptor ( propertyName ,    null ,    method )  )  ;", "} else    {", "existingPd . setWriteMethod ( method )  ;", "}", "} else", "if    ( nParams    =  =     2  )     {", "if    ( existingPd    =  =    null )     {", "this . propertyDescriptors . add ( new    . SimpleIndexedPropertyDescriptor ( propertyName ,    null ,    null ,    null ,    method )  )  ;", "} else", "if    ( existingPd   instanceof   IndexedPropertyDescriptor )     {", "(  ( IndexedPropertyDescriptor )     ( existingPd )  )  . setIndexedWriteMethod ( method )  ;", "} else    {", "this . propertyDescriptors . remove ( existingPd )  ;", "this . propertyDescriptors . add ( new    . SimpleIndexedPropertyDescriptor ( propertyName ,    existingPd . getReadMethod (  )  ,    existingPd . getWriteMethod (  )  ,    null ,    method )  )  ;", "}", "} else    {", "throw   new   IllegalArgumentException (  (  \" Write   method   must   have   exactly    1    or    2    parameters :     \"     +    method )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleCandidateWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfo"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =    method . getName (  )  ;", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "int   nParams    =    parameterTypes . length ;", "return    (  (  (  (  ( methodName . length (  )  )     >     3  )     &  &     ( methodName . startsWith (  \" set \"  )  )  )     &  &     ( Modifier . isPublic ( method . getModifiers (  )  )  )  )     &  &     (  (  !  ( void . class . isAssignableFrom ( method . getReturnType (  )  )  )  )     |  |     ( Modifier . isStatic ( method . getModifiers (  )  )  )  )  )     &  &     (  ( nParams    =  =     1  )     |  |     (  ( nParams    =  =     2  )     &  &     (  ( int . class )     =  =     ( parameterTypes [  0  ]  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCandidateWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfo"}, {"methodBody": ["METHOD_START", "{", "return   Introspector . decapitalize ( method . getName (  )  . substring (  3  ,    method . getName (  )  . length (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyNameFor"], "fileName": "org.springframework.beans.ExtendedBeanInfo"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    beanClass . getMethods (  )  )     {", "if    (  . isCandidateWriteMethod ( method )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["supports"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactory"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "void   setBar ( String   s )     {", "}", "}", "assertThat ( factory . get ( C . class )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotSupportClassHavingNonPublicNonVoidReturningIndexedSetter"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "C   set ( String   s )     {", "return   this ;", "}", "}", "assertThat ( factory . get ( C . class )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotSupportClassHavingNonVoidReturningMethodNamedSet"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "C   setBar (  )     {", "return   this ;", "}", "}", "assertThat ( factory . get ( C . class )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotSupportClassHavingNonVoidReturningParameterlessSetter"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   setFoo ( String   s )     {", "}", "}", "assertThat ( factory . get ( C . class )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldNotSupportClassHavingOnlyVoidReturningSetter"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   C   setFoo ( int   i ,    String   s )     {", "return   this ;", "}", "}", "assertThat ( factory . get ( C . class )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportClassHavingNonVoidReturningIndexedSetter"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   C   setFoo ( String   s )     {", "return   this ;", "}", "}", "assertThat ( factory . get ( C . class )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSupportClassHavingNonVoidReturningSetter"], "fileName": "org.springframework.beans.ExtendedBeanInfoFactoryTests"}, {"methodBody": ["METHOD_START", "{", "new   ExtendedBeanInfo ( Introspector . getBeanInfo ( BigDecimal . class )  )  ;", "}", "METHOD_END"], "methodName": ["cornerSpr10111"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   A    {", "public   void   setAddress ( String   addr )     {", "}", "public   void   setAddress ( int   index ,    String   addr )     {", "}", "public   String   getAddress ( int   index )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( A . class )  ;", "boolean   hasReadMethod    =    hasReadMethodForProperty ( bi ,     \" address \"  )  ;", "boolean   hasWriteMethod    =    hasWriteMethodForProperty ( bi ,     \" address \"  )  ;", "boolean   hasIndexedReadMethod    =    hasIndexedReadMethodForProperty ( bi ,     \" address \"  )  ;", "boolean   hasIndexedWriteMethod    =    hasIndexedWriteMethodForProperty ( bi ,     \" address \"  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertEquals ( hasReadMethod ,    hasReadMethodForProperty ( ebi ,     \" address \"  )  )  ;", "assertEquals ( hasWriteMethod ,    hasWriteMethodForProperty ( ebi ,     \" address \"  )  )  ;", "assertEquals ( hasIndexedReadMethod ,    hasIndexedReadMethodForProperty ( ebi ,     \" address \"  )  )  ;", "assertEquals ( hasIndexedWriteMethod ,    hasIndexedWriteMethodForProperty ( ebi ,     \" address \"  )  )  ;", "}", "METHOD_END"], "methodName": ["cornerSpr8937AndSpr12582"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "class   A    {", "@ SuppressWarnings (  \" unused \"  )", "public   boolean   isTargetMethod (  )     {", "return   false ;", "}", "}", "class   B   extends   A    {", "@ Override", "public   boolean   isTargetMethod (  )     {", "return   false ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( B . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" targetMethod \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" targetMethod \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" targetMethod \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" targetMethod \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["cornerSpr8949"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   Parent    {", "public   Number   getProperty 1  (  )     {", "return    1  ;", "}", "}", "class   Child   extends   Parent    {", "@ Override", "public   Integer   getProperty 1  (  )     {", "return    2  ;", "}", "}", "{", "bi    =    new    ( Introspector . getBeanInfo ( Parent . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" property 1  \"  )  ,    is ( true )  )  ;", "}", "{", "bi    =    new    ( Introspector . getBeanInfo ( Child . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" property 1  \"  )  ,    is ( true )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cornerSpr9414"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "final   class   Bean   implements   ExtendedBeanInfoTests . Spr 9  4  5  3  < Class <  ?  >  >     {", "@ Override", "public   Class <  ?  >    getProp (  )     {", "return   null ;", "}", "}", "{", "BeanInfo   info    =    Introspector . getBeanInfo ( Bean . class )  ;", "assertThat ( info . getPropertyDescriptors (  )  . length ,    equalTo (  2  )  )  ;", "}", "{", "BeanInfo   info    =    new   ExtendedBeanInfo ( Introspector . getBeanInfo ( Bean . class )  )  ;", "assertThat ( info . getPropertyDescriptors (  )  . length ,    equalTo (  2  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cornerSpr9453"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   setFoos ( String [  ]    foos )     {", "}", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "}", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   C   setFoos ( String [  ]    foos )     {", "return   this ;", "}", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cornerSpr9702"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   set ( Object   o )     {", "return   null ;", "}", "public   Object   set ( int   i ,    Object   o )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( ebi . getPropertyDescriptors (  )  ,    equalTo ( bi . getPropertyDescriptors (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyPropertiesIgnored"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyDescriptor   pd    :    beanInfo . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals ( propertyName )  )     {", "if    (  !  ( pd   instanceof   IndexedPropertyDescriptor )  )     {", "return   false ;", "}", "return    (  (  ( IndexedPropertyDescriptor )     ( pd )  )  . getIndexedReadMethod (  )  )     !  =    null ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasIndexedReadMethodForProperty"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyDescriptor   pd    :    beanInfo . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals ( propertyName )  )     {", "if    (  !  ( pd   instanceof   IndexedPropertyDescriptor )  )     {", "return   false ;", "}", "return    (  (  ( IndexedPropertyDescriptor )     ( pd )  )  . getIndexedWriteMethod (  )  )     !  =    null ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasIndexedWriteMethodForProperty"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyDescriptor   pd    :    beanInfo . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals ( propertyName )  )     {", "return    ( pd . getReadMethod (  )  )     !  =    null ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasReadMethodForProperty"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyDescriptor   pd    :    beanInfo . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals ( propertyName )  )     {", "return    ( pd . getWriteMethod (  )  )     !  =    null ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasWriteMethodForProperty"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "public   void   setFoos ( int   i ,    String   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadAndIndexedWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "public   C   setFoos ( int   i ,    String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadAndNonStandardIndexedWrite"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   C   setFoos ( String [  ]    foos )     {", "return   this ;", "}", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "public   C   setFoos ( int   i ,    String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadAndNonStandardWriteAndNonStandardIndexedWrite"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadMethodOnly"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Integer   getFoos ( int   index )     {", "return   null ;", "}", "public   void   setFoo ( int   index ,    Number   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadMethodReturnsSubtypeOfIndexedWriteMethodParameter"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Number   getFoos ( int   index )     {", "return   null ;", "}", "public   void   setFoos ( int   index ,    Integer   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertEquals ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  )  ;", "}", "METHOD_END"], "methodName": ["indexedReadMethodReturnsSupertypeOfIndexedWriteMethodParameter"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   setFoos ( int   i ,    String   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["indexedWriteMethodOnly"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "String   getFoo (  )     {", "return   null ;", "}", "C   setFoo ( String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["nonPublicStandardReadAndWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   getFoo (  )     {", "}", "public   void   setFoo ( String   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["nonStandardReadMethodAndStandardWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   C   setFoo ( String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["nonStandardWriteMethodOnly"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setFoo ( String   p )     {", "return   new   Object (  )  ;", "}", "public   Object   setFoo ( int   p )     {", "return   new   Object (  )  ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "for    ( PropertyDescriptor   pd    :    ebi . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals (  \" foo \"  )  )     {", "assertThat ( pd . getWriteMethod (  )  ,    is ( C . class . getMethod (  \" setFoo \"  ,    String . class )  )  )  ;", "return ;", "}", "}", "fail (  \" never   matched   write   method \"  )  ;", "}", "METHOD_END"], "methodName": ["overloadedNonStandardWriteMethodsOnly_orderA"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setFoo ( int   p )     {", "return   new   Object (  )  ;", "}", "public   Object   setFoo ( String   p )     {", "return   new   Object (  )  ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "for    ( PropertyDescriptor   pd    :    ebi . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals (  \" foo \"  )  )     {", "assertThat ( pd . getWriteMethod (  )  ,    is ( C . class . getMethod (  \" setFoo \"  ,    String . class )  )  )  ;", "return ;", "}", "}", "fail (  \" never   matched   write   method \"  )  ;", "}", "METHOD_END"], "methodName": ["overloadedNonStandardWriteMethodsOnly_orderB"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanInfo   bi    =    Introspector . getBeanInfo ( TestBean . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( ebi . getPropertyDescriptors (  )  . length ,    equalTo ( bi . getPropertyDescriptors (  )  . length )  )  ;", "}", "METHOD_END"], "methodName": ["propertyCountsMatch"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "class   ExtendedTestBean   extends   TestBean    {", "@ SuppressWarnings (  \" unused \"  )", "public   ExtendedTestBean   setFoo ( String   s )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( ExtendedTestBean . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "boolean   found    =    false ;", "for    ( PropertyDescriptor   pd    :    ebi . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals (  \" foo \"  )  )     {", "found    =    true ;", "}", "}", "assertThat ( found ,    is ( true )  )  ;", "assertThat ( ebi . getPropertyDescriptors (  )  . length ,    equalTo (  (  ( bi . getPropertyDescriptors (  )  . length )     +     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyCountsWithNonStandardWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "ExtendedBeanInfo . PropertyDescriptorComparator   c    =    new   ExtendedBeanInfo . PropertyDescriptorComparator (  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" a \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" a \"  ,    null ,    null )  )  ,    equalTo (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  )  ,    equalTo (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" a \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" b \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" b \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" a \"  ,    null ,    null )  )  ,    greaterThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" abd \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" xyz \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \"  1  2  3  \"  ,    null ,    null )  )  ,    greaterThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" a \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" a \"  ,    null ,    null )  )  ,    greaterThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" abc \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" b \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \"     \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" a \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \"  1  \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" a \"  ,    null ,    null )  )  ,    lessThan (  0  )  )  ;", "assertThat ( c . compare ( new   PropertyDescriptor (  \" a \"  ,    null ,    null )  ,    new   PropertyDescriptor (  \" A \"  ,    null ,    null )  )  ,    greaterThan (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyDescriptorComparator"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanInfo   bi    =    Introspector . getBeanInfo ( TestBean . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "for    ( int   i    =     0  ;    i    <     ( bi . getPropertyDescriptors (  )  . length )  ;    i +  +  )     {", "assertThat (  (  (  \" element    \"     +    i )     +     \"    in   BeanInfo   and      propertyDescriptor   arrays   do   not   match \"  )  ,    ebi . getPropertyDescriptors (  )  [ i ]  . getName (  )  ,    equalTo ( bi . getPropertyDescriptors (  )  [ i ]  . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyDescriptorOrderIsEqual"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String [  ]    getFoos (  )     {", "return   null ;", "}", "public   String   getFoos ( int   i )     {", "return   null ;", "}", "public   void   setFoos ( String [  ]    foos )     {", "}", "public   void   setFoos ( int   i ,    String   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( Introspector . getBeanInfo ( C . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foos \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["readAndWriteAndIndexedReadAndIndexedWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Integer   getFoo (  )     {", "return   null ;", "}", "public   void   setFoo ( Number   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["readMethodReturnsSubtypeOfWriteMethodParameter"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Number   getFoo (  )     {", "return   null ;", "}", "public   void   setFoo ( Integer   foo )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertEquals ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    hasWriteMethodForProperty ( ebi ,     \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readMethodReturnsSupertypeOfWriteMethodParameter"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setDateFormat ( String   pattern )     {", "return   new   Object (  )  ;", "}", "public   Object   setDateFormat ( int   style )     {", "return   new   Object (  )  ;", "}", "public   Object   setDateFormat ( int   dateStyle ,    int   timeStyle )     {", "return   new   Object (  )  ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" dateFormat \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( ebi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" dateFormat \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["reproSpr8522"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "Introspector . getBeanInfo ( ExtendedBeanInfoTests . LawLibrary . class )  ;", "new   ExtendedBeanInfo ( Introspector . getBeanInfo ( ExtendedBeanInfoTests . LawLibrary . class )  )  ;", "}", "METHOD_END"], "methodName": ["reproSpr8806"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanInfo   bi    =    new   ExtendedBeanInfo ( Introspector . getBeanInfo ( Window . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" locationByPlatform \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" locationByPlatform \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" locationByPlatform \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" locationByPlatform \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["shouldDetectValidPropertiesAndIgnoreInvalidProperties"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "{", "BeanInfo   bi    =    Introspector . getBeanInfo ( ExtendedBeanInfoTests . WithStaticWriteMethod . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "}", "{", "BeanInfo   bi    =    new   ExtendedBeanInfo ( Introspector . getBeanInfo ( ExtendedBeanInfoTests . WithStaticWriteMethod . class )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( true )  )  ;", "assertThat ( hasIndexedReadMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" prop 1  \"  )  ,    is ( false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldSupportStaticWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String [  ]    getFoo (  )     {", "return   null ;", "}", "public   C   setFoo ( int   i ,    String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasIndexedWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadAndNonStandardIndexedWriteMethod"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoo (  )     {", "return   null ;", "}", "public   C   setFoo ( String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadAndNonStandardWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   setFoo ( String   f )     {", "}", "public   String   getFoo (  )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadAndWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "abstract   class   B < This   extends   B < This >  >     {", "@ SuppressWarnings (  \" unchecked \"  )", "protected   final   This   instance    =     (  ( This )     ( this )  )  ;", "private   String   foo ;", "public   String   getFoo (  )     {", "return   foo ;", "}", "public   This   setFoo ( String   foo )     {", "this . foo    =    foo ;", "return   this . instance ;", "}", "}", "class   C   extends   B < C >     {", "private   int   bar    =     -  1  ;", "public   int   getBar (  )     {", "return   bar ;", "}", "public   C   setBar ( int   bar )     {", "this . bar    =    bar ;", "return   this . instance ;", "}", "}", "C   c    =    new   C (  )  . setFoo (  \" blue \"  )  . setBar (  4  2  )  ;", "assertThat ( c . getFoo (  )  ,    is (  \" blue \"  )  )  ;", "assertThat ( c . getBar (  )  ,    is (  4  2  )  )  ;", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" bar \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" bar \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" bar \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" bar \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" bar \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" bar \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadMethodInSuperAndSubclassesAndGenericBuilderStyleNonStandardWriteMethodInSuperAndSubclasses"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   B    {", "public   String   getFoo (  )     {", "return   null ;", "}", "}", "@ SuppressWarnings (  \" unused \"  )", "class   C   extends   B    {", "public   C   setFoo ( String   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadMethodInSuperclassAndNonStandardWriteMethodInSubclass"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoo (  )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["standardReadMethodOnly"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   String   getFoo (  )     {", "return   null ;", "}", "public   C   setFoo ( String   foo )     {", "return   this ;", "}", "public   C   setFoo ( Number   foo )     {", "return   this ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "for    ( PropertyDescriptor   pd    :    ebi . getPropertyDescriptors (  )  )     {", "if    ( pd . getName (  )  . equals (  \" foo \"  )  )     {", "assertThat ( pd . getWriteMethod (  )  ,    is ( C . class . getMethod (  \" setFoo \"  ,    String . class )  )  )  ;", "return ;", "}", "}", "fail (  \" never   matched   write   method \"  )  ;", "}", "METHOD_END"], "methodName": ["standardReadMethodsAndOverloadedNonStandardWriteMethods"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   void   setFoo ( String   f )     {", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["standardWriteMethodOnly"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unused \"  )", "class   B    {", "public   String   getFoo (  )     {", "return   null ;", "}", "public   Number   setFoo ( String   foo )     {", "return   null ;", "}", "}", "class   C   extends   B    {", "@ Override", "public   String   getFoo (  )     {", "return   null ;", "}", "@ Override", "public   Integer   setFoo ( String   foo )     {", "return   null ;", "}", "}", "BeanInfo   bi    =    Introspector . getBeanInfo ( C . class )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "BeanInfo   ebi    =    new    ( bi )  ;", "assertThat ( hasReadMethodForProperty ( bi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( bi ,     \" foo \"  )  ,    is ( false )  )  ;", "assertThat ( hasReadMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( hasWriteMethodForProperty ( ebi ,     \" foo \"  )  ,    is ( true )  )  ;", "assertThat ( ebi . getPropertyDescriptors (  )  . length ,    equalTo ( bi . getPropertyDescriptors (  )  . length )  )  ;", "}", "METHOD_END"], "methodName": ["subclassWriteMethodWithCovariantReturnType"], "fileName": "org.springframework.beans.ExtendedBeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClass ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.GenericTypeAwarePropertyDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . writeMethod )     !  =    null )  ,     \" No   write   method   available \"  )  ;", "Set < Method >    ambiguousCandidates    =    this . ambiguousWriteMethods ;", "if    ( ambiguousCandidates    !  =    null )     {", "this . ambiguousWriteMethods    =    null ;", "LogFactory . getLog (  . class )  . warn (  (  (  (  (  (  \" Invalid   JavaBean   property    '  \"     +     ( getName (  )  )  )     +     \"  '    being   accessed !    Ambiguous   write   methods   found   next   to   actually   used    [  \"  )     +     ( this . writeMethod )  )     +     \"  ]  :     \"  )     +    ambiguousCandidates )  )  ;", "}", "return   this . writeMethod ;", "}", "METHOD_END"], "methodName": ["getWriteMethodForActualAccess"], "fileName": "org.springframework.beans.GenericTypeAwarePropertyDescriptor"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . writeMethodParameter )     !  =    null )  ,     \" No   write   method   available \"  )  ;", "return   this . writeMethodParameter ;", "}", "METHOD_END"], "methodName": ["getWriteMethodParameter"], "fileName": "org.springframework.beans.GenericTypeAwarePropertyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   beanClass ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.InvalidPropertyException"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.springframework.beans.InvalidPropertyException"}, {"methodBody": ["METHOD_START", "{", "addPropertyValue ( new   PropertyValue ( propertyName ,    propertyValue )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "addPropertyValue ( new   PropertyValue ( propertyName ,    propertyValue )  )  ;", "}", "METHOD_END"], "methodName": ["addPropertyValue"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . propertyValueList . size (  )  )  ;    i +  +  )     {", "currentPv    =    this . propertyValueList . get ( i )  ;", "if    ( currentPv . getName (  )  . equals ( pv . getName (  )  )  )     {", "pv    =    mergeIfRequired ( pv ,    currentPv )  ;", "setAt ( pv ,    i )  ;", "return   this ;", "}", "}", "this . propertyValueList . add ( pv )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addPropertyValue"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "if    ( other    !  =    null )     {", "other . forEach (  (    attrName ,    attrValue )     -  >    add ( new    ( attrName . toString (  )  ,    attrValue )  )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addPropertyValues"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "if    ( other    !  =    null )     {", "PropertyValue [  ]    pvs    =    other . get (  )  ;", "for    ( PropertyValue   pv    :    pvs )     {", "addPropertyValue ( new   PropertyValue ( pv )  )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addPropertyValues"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . processedProperties )     !  =    null )     {", "this . processedProperties . remove ( propertyName )  ;", "}", "}", "METHOD_END"], "methodName": ["clearProcessedProperty"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "PropertyValue   pv    =    getPropertyValue ( propertyName )  ;", "return   pv    !  =    null    ?    pv . getValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyValueList ;", "}", "METHOD_END"], "methodName": ["getPropertyValueList"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "return   this . converted ;", "}", "METHOD_END"], "methodName": ["isConverted"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    newPv . getValue (  )  ;", "if    ( value   instanceof   Mergeable )     {", "Mergeable   mergeable    =     (  ( Mergeable )     ( value )  )  ;", "if    ( mergeable . isMergeEnabled (  )  )     {", "Object   merged    =    mergeable . merge ( currentPv . getValue (  )  )  ;", "return   new    ( newPv . getName (  )  ,    merged )  ;", "}", "}", "return   newPv ;", "}", "METHOD_END"], "methodName": ["mergeIfRequired"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . processedProperties )     =  =    null )     {", "this . processedProperties    =    new   HashSet <  >  (  4  )  ;", "}", "this . processedProperties . add ( propertyName )  ;", "}", "METHOD_END"], "methodName": ["registerProcessedProperty"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "this . propertyValueList . remove ( getPropertyValue ( propertyName )  )  ;", "}", "METHOD_END"], "methodName": ["removePropertyValue"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "this . propertyValueList . remove ( pv )  ;", "}", "METHOD_END"], "methodName": ["removePropertyValue"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "this . converted    =    true ;", "}", "METHOD_END"], "methodName": ["setConverted"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "this . propertyValueList . set ( i ,    pv )  ;", "}", "METHOD_END"], "methodName": ["setPropertyValueAt"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyValueList . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.springframework.beans.MutablePropertyValues"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" forname \"  ,     \" Tony \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" surname \"  ,     \" Blair \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  5  0  \"  )  )  ;", "doTestTony ( pvs )  ;", "PropertyValue   addedPv    =    new   PropertyValue (  \" rod \"  ,     \" Rod \"  )  ;", "pvs . addPropertyValue ( addedPv )  ;", "assertTrue ( pvs . getPropertyValue (  \" rod \"  )  . equals ( addedPv )  )  ;", "PropertyValue   changedPv    =    new   PropertyValue (  \" forname \"  ,     \" Greg \"  )  ;", "pvs . addPropertyValue ( changedPv )  ;", "assertTrue ( pvs . getPropertyValue (  \" forname \"  )  . equals ( changedPv )  )  ;", "}", "METHOD_END"], "methodName": ["testAddOrOverride"], "fileName": "org.springframework.beans.MutablePropertyValuesTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" forname \"  ,     \" Tony \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" surname \"  ,     \" Blair \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  5  0  \"  )  )  ;", "MutablePropertyValues   pvs 2     =    new   MutablePropertyValues ( pvs )  ;", "PropertyValues   changes    =    pvs 2  . changesSince ( pvs )  ;", "assertTrue (  (  \" changes   are   empty ,    not   of   length    \"     +     ( changes . getPropertyValues (  )  . length )  )  ,     (  ( changes . getPropertyValues (  )  . length )     =  =     0  )  )  ;", "pvs 2  . addPropertyValue ( new   PropertyValue (  \" forname \"  ,     \" Gordon \"  )  )  ;", "changes    =    pvs 2  . changesSince ( pvs )  ;", "assertEquals (  \"  1    change \"  ,     1  ,    changes . getPropertyValues (  )  . length )  ;", "PropertyValue   fn    =    changes . getPropertyValue (  \" forname \"  )  ;", "assertTrue (  \" change   is   forname \"  ,     ( fn    !  =    null )  )  ;", "assertTrue (  \" new   value   is   gordon \"  ,    fn . getValue (  )  . equals (  \" Gordon \"  )  )  ;", "MutablePropertyValues   pvs 3     =    new   MutablePropertyValues ( pvs )  ;", "changes    =    pvs 3  . changesSince ( pvs )  ;", "assertTrue (  (  \" changes   are   empty ,    not   of   length    \"     +     ( changes . getPropertyValues (  )  . length )  )  ,     (  ( changes . getPropertyValues (  )  . length )     =  =     0  )  )  ;", "pvs 3  . addPropertyValue ( new   PropertyValue (  \" foo \"  ,     \" bar \"  )  )  ;", "pvs 3  . addPropertyValue ( new   PropertyValue (  \" fi \"  ,     \" fum \"  )  )  ;", "changes    =    pvs 3  . changesSince ( pvs )  ;", "assertTrue (  \"  2    change \"  ,     (  ( changes . getPropertyValues (  )  . length )     =  =     2  )  )  ;", "fn    =    changes . getPropertyValue (  \" foo \"  )  ;", "assertTrue (  \" change   in   foo \"  ,     ( fn    !  =    null )  )  ;", "assertTrue (  \" new   value   is   bar \"  ,    fn . getValue (  )  . equals (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangeOfOneField"], "fileName": "org.springframework.beans.MutablePropertyValuesTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" forname \"  ,     \" Tony \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" surname \"  ,     \" Blair \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  5  0  \"  )  )  ;", "MutablePropertyValues   pvs 2     =    pvs ;", "PropertyValues   changes    =    pvs 2  . changesSince ( pvs )  ;", "assertTrue (  \" changes   are   empty \"  ,     (  ( changes . getPropertyValues (  )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testChangesOnEquals"], "fileName": "org.springframework.beans.MutablePropertyValuesTests"}, {"methodBody": ["METHOD_START", "{", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" forname \"  ,     \" Tony \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" surname \"  ,     \" Blair \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,     \"  5  0  \"  )  )  ;", "doTestTony ( pvs )  ;", "MutablePropertyValues   deepCopy    =    new   MutablePropertyValues ( pvs )  ;", "doTestTony ( deepCopy )  ;", "deepCopy . setPropertyValueAt ( new   PropertyValue (  \" name \"  ,     \" Gordon \"  )  ,     0  )  ;", "doTestTony ( pvs )  ;", "assertEquals (  \" Gordon \"  ,    deepCopy . getPropertyValue (  \" name \"  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testValid"], "fileName": "org.springframework.beans.MutablePropertyValuesTests"}, {"methodBody": ["METHOD_START", "{", "return   this . possibleMatches ;", "}", "METHOD_END"], "methodName": ["getPossibleMatches"], "fileName": "org.springframework.beans.NotWritablePropertyException"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyChangeEvent ;", "}", "METHOD_END"], "methodName": ["getPropertyChangeEvent"], "fileName": "org.springframework.beans.PropertyAccessException"}, {"methodBody": ["METHOD_START", "{", "return    ( this . propertyChangeEvent )     !  =    null    ?    this . propertyChangeEvent . getPropertyName (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.springframework.beans.PropertyAccessException"}, {"methodBody": ["METHOD_START", "{", "return    ( this . propertyChangeEvent )     !  =    null    ?    this . propertyChangeEvent . getNewValue (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.beans.PropertyAccessException"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanWrapperImpl ( target )  ;", "}", "METHOD_END"], "methodName": ["forBeanPropertyAccess"], "fileName": "org.springframework.beans.PropertyAccessorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectFieldAccessor ( target )  ;", "}", "METHOD_END"], "methodName": ["forDirectFieldAccess"], "fileName": "org.springframework.beans.PropertyAccessorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( propertyName    =  =    null )     {", "return    \"  \"  ;", "}", "StringBuilder   sb    =    new   StringBuilder ( propertyName )  ;", "int   searchIndex    =     0  ;", "while    ( searchIndex    !  =     (  -  1  )  )     {", "int   keyStart    =    sb . indexOf (  . PROPERTY _ KEY _ PREFIX ,    searchIndex )  ;", "searchIndex    =     -  1  ;", "if    ( keyStart    !  =     (  -  1  )  )     {", "int   keyEnd    =    sb . indexOf (  . PROPERTY _ KEY _ SUFFIX ,     ( keyStart    +     (  . PROPERTY _ KEY _ PREFIX . length (  )  )  )  )  ;", "if    ( keyEnd    !  =     (  -  1  )  )     {", "String   key    =    sb . substring (  ( keyStart    +     (  . PROPERTY _ KEY _ PREFIX . length (  )  )  )  ,    keyEnd )  ;", "if    (  (  ( key . startsWith (  \"  '  \"  )  )     &  &     ( key . endsWith (  \"  '  \"  )  )  )     |  |     (  ( key . startsWith (  \"  \\  \"  \"  )  )     &  &     ( key . endsWith (  \"  \\  \"  \"  )  )  )  )     {", "sb . delete (  ( keyStart    +     1  )  ,     ( keyStart    +     2  )  )  ;", "sb . delete (  ( keyEnd    -     2  )  ,     ( keyEnd    -     1  )  )  ;", "keyEnd    =    keyEnd    -     2  ;", "}", "searchIndex    =    keyEnd    +     (  . PROPERTY _ KEY _ SUFFIX . length (  )  )  ;", "}", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["canonicalPropertyName"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( propertyNames    =  =    null )     {", "return   null ;", "}", "String [  ]    result    =    new   String [ propertyNames . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( propertyNames . length )  ;    i +  +  )     {", "result [ i ]     =     . canonicalPropertyName ( propertyNames [ i ]  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["canonicalPropertyNames"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "return   PropertyAccessorUtils . getNestedPropertySeparatorIndex ( propertyPath ,    false )  ;", "}", "METHOD_END"], "methodName": ["getFirstNestedPropertySeparatorIndex"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "return   PropertyAccessorUtils . getNestedPropertySeparatorIndex ( propertyPath ,    true )  ;", "}", "METHOD_END"], "methodName": ["getLastNestedPropertySeparatorIndex"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   inKey    =    false ;", "int   length    =    propertyPath . length (  )  ;", "int   i    =     ( last )     ?    length    -     1     :     0  ;", "while    ( last    ?    i    >  =     0     :    i    <    length )     {", "switch    ( propertyPath . charAt ( i )  )     {", "case    . PROPERTY _ KEY _ PREFIX _ CHAR    :", "case    . PROPERTY _ KEY _ SUFFIX _ CHAR    :", "inKey    =     ! inKey ;", "break ;", "case    . NESTED _ PROPERTY _ SEPARATOR _ CHAR    :", "if    (  ! inKey )     {", "return   i ;", "}", "}", "if    ( last )     {", "i -  -  ;", "} else    {", "i +  +  ;", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getNestedPropertySeparatorIndex"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "int   separatorIndex    =     ( propertyPath . endsWith ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )  )     ?    propertyPath . indexOf ( PropertyAccessor . PROPERTY _ KEY _ PREFIX _ CHAR )     :     -  1  ;", "return   separatorIndex    !  =     (  -  1  )     ?    propertyPath . substring (  0  ,    separatorIndex )     :    propertyPath ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( propertyPath    =  =    null )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( propertyPath . length (  )  )  ;    i +  +  )     {", "char   ch    =    propertyPath . charAt ( i )  ;", "if    (  ( ch    =  =     (  . NESTED _ PROPERTY _ SEPARATOR _ CHAR )  )     |  |     ( ch    =  =     (  . PROPERTY _ KEY _ PREFIX _ CHAR )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isNestedOrIndexedProperty"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( registeredPath . startsWith ( propertyPath )  )  )     {", "return   false ;", "}", "if    (  ( registeredPath . length (  )  )     =  =     ( propertyPath . length (  )  )  )     {", "return   true ;", "}", "if    (  ( registeredPath . charAt ( propertyPath . length (  )  )  )     !  =     (  . PROPERTY _ KEY _ PREFIX _ CHAR )  )     {", "return   false ;", "}", "return    ( registeredPath . indexOf (  . PROPERTY _ KEY _ SUFFIX _ CHAR ,     (  ( propertyPath . length (  )  )     +     1  )  )  )     =  =     (  ( registeredPath . length (  )  )     -     1  )  ;", "}", "METHOD_END"], "methodName": ["matchesProperty"], "fileName": "org.springframework.beans.PropertyAccessorUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" map \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [ key 1  ]  \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [  ' key 1  '  ]  \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [  \\  \" key 1  \\  \"  ]  \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  [ key 2  ]  \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [ key 1  ]  [ key 2  ]  \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  [ key 2  ]  \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [  \\  ' key 1  \\  '  ]  [  \\  \" key 2  \\  \"  ]  \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  . name \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  . name \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  \" map [ key 1  ]  . name \"  ,    PropertyAccessorUtils . canonicalPropertyName (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanonicalPropertyName"], "fileName": "org.springframework.beans.PropertyAccessorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    original    =    new   String [  ]  {     \" map \"  ,     \" map [ key 1  ]  \"  ,     \" map [  ' key 1  '  ]  \"  ,     \" map [  \\  \" key 1  \\  \"  ]  \"  ,     \" map [ key 1  ]  [ key 2  ]  \"  ,     \" map [  \\  ' key 1  \\  '  ]  [  \\  \" key 2  \\  \"  ]  \"  ,     \" map [ key 1  ]  . name \"  ,     \" map [  ' key 1  '  ]  . name \"  ,     \" map [  \\  \" key 1  \\  \"  ]  . name \"     }  ;", "String [  ]    canonical    =    new   String [  ]  {     \" map \"  ,     \" map [ key 1  ]  \"  ,     \" map [ key 1  ]  \"  ,     \" map [ key 1  ]  \"  ,     \" map [ key 1  ]  [ key 2  ]  \"  ,     \" map [ key 1  ]  [ key 2  ]  \"  ,     \" map [ key 1  ]  . name \"  ,     \" map [ key 1  ]  . name \"  ,     \" map [ key 1  ]  . name \"     }  ;", "assertTrue ( Arrays . equals ( canonical ,     . canonicalPropertyNames ( original )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanonicalPropertyNames"], "fileName": "org.springframework.beans.PropertyAccessorUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyAccessExceptions . length ;", "}", "METHOD_END"], "methodName": ["getExceptionCount"], "fileName": "org.springframework.beans.PropertyBatchUpdateException"}, {"methodBody": ["METHOD_START", "{", "for    ( PropertyAccessException   pae    :    this . propertyAccessExceptions )     {", "if    ( ObjectUtils . nullSafeEquals ( propertyName ,    pae . getPropertyName (  )  )  )     {", "return   pae ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessException"], "fileName": "org.springframework.beans.PropertyBatchUpdateException"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyAccessExceptions ;", "}", "METHOD_END"], "methodName": ["getPropertyAccessExceptions"], "fileName": "org.springframework.beans.PropertyBatchUpdateException"}, {"methodBody": ["METHOD_START", "{", "target . setExpert ( source . isExpert (  )  )  ;", "target . setHidden ( source . isHidden (  )  )  ;", "target . setPreferred ( source . isPreferred (  )  )  ;", "target . setName ( source . getName (  )  )  ;", "target . setShortion ( source . getShortion (  )  )  ;", "target . setDisplayName ( source . getDisplayName (  )  )  ;", "Enumeration < String >    keys    =    source . attributeNames (  )  ;", "while    ( keys . hasMoreElements (  )  )     {", "String   key    =    keys . nextElement (  )  ;", "target . setValue ( key ,    source . getValue ( key )  )  ;", "}", "target . setPropertyEditorClass ( source . getPropertyEditorClass (  )  )  ;", "target . setBound ( source . isBound (  )  )  ;", "target . setConstrained ( source . isConstrained (  )  )  ;", "}", "METHOD_END"], "methodName": ["copyNonMethodProperties"], "fileName": "org.springframework.beans.PropertyDescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( ObjectUtils . nullSafeEquals ( pd . getReadMethod (  )  ,    otherPd . getReadMethod (  )  )  )     &  &     ( ObjectUtils . nullSafeEquals ( pd . getWriteMethod (  )  ,    otherPd . getWriteMethod (  )  )  )  )     &  &     ( ObjectUtils . nullSafeEquals ( pd . getPropertyType (  )  ,    otherPd . getPropertyType (  )  )  )  )     &  &     ( ObjectUtils . nullSafeEquals ( pd . getPropertyEditorClass (  )  ,    otherPd . getPropertyEditorClass (  )  )  )  )     &  &     (  ( pd . isBound (  )  )     =  =     ( otherPd . isBound (  )  )  )  )     &  &     (  ( pd . isConstrained (  )  )     =  =     ( otherPd . isConstrained (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.springframework.beans.PropertyDescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    indexedPropertyType    =    null ;", "if    ( indexedReadMethod    !  =    null )     {", "Class <  ?  >  [  ]    params    =    indexedReadMethod . getParameterTypes (  )  ;", "if    (  ( params . length )     !  =     1  )     {", "throw   new   IntrospectionException (  (  \" Bad   indexed   read   method   arg   count :     \"     +    indexedReadMethod )  )  ;", "}", "if    (  ( params [  0  ]  )     !  =     ( Integer . TYPE )  )     {", "throw   new   IntrospectionException (  (  \" Non   int   index   to   indexed   read   method :     \"     +    indexedReadMethod )  )  ;", "}", "indexedPropertyType    =    indexedReadMethod . getReturnType (  )  ;", "if    ( indexedPropertyType    =  =     ( Void . TYPE )  )     {", "throw   new   IntrospectionException (  (  \" Indexed   read   method   returns   void :     \"     +    indexedReadMethod )  )  ;", "}", "}", "if    ( indexedWriteMethod    !  =    null )     {", "Class <  ?  >  [  ]    params    =    indexedWriteMethod . getParameterTypes (  )  ;", "if    (  ( params . length )     !  =     2  )     {", "throw   new   IntrospectionException (  (  \" Bad   indexed   write   method   arg   count :     \"     +    indexedWriteMethod )  )  ;", "}", "if    (  ( params [  0  ]  )     !  =     ( Integer . TYPE )  )     {", "throw   new   IntrospectionException (  (  \" Non   int   index   to   indexed   write   method :     \"     +    indexedWriteMethod )  )  ;", "}", "if    ( indexedPropertyType    !  =    null )     {", "if    ( indexedPropertyType . isAssignableFrom ( params [  1  ]  )  )     {", "indexedPropertyType    =    params [  1  ]  ;", "} else", "if    ( params [  1  ]  . isAssignableFrom ( indexedPropertyType )  )     {", "} else    {", "throw   new   IntrospectionException (  (  (  (  \" Type   mismatch   between   indexed   read   and   write   methods :     \"     +    indexedReadMethod )     +     \"     -     \"  )     +    indexedWriteMethod )  )  ;", "}", "} else    {", "indexedPropertyType    =    params [  1  ]  ;", "}", "}", "if    (  ( propertyType    !  =    null )     &  &     (  (  !  ( propertyType . isArray (  )  )  )     |  |     (  ( propertyType . getComponentType (  )  )     !  =    indexedPropertyType )  )  )     {", "throw   new   IntrospectionException (  (  (  (  \" Type   mismatch   between   indexed   and   non - indexed   methods :     \"     +    indexedReadMethod )     +     \"     -     \"  )     +    indexedWriteMethod )  )  ;", "}", "return   indexedPropertyType ;", "}", "METHOD_END"], "methodName": ["findIndexedPropertyType"], "fileName": "org.springframework.beans.PropertyDescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    propertyType    =    null ;", "if    ( readMethod    !  =    null )     {", "Class <  ?  >  [  ]    params    =    readMethod . getParameterTypes (  )  ;", "if    (  ( params . length )     !  =     0  )     {", "throw   new   IntrospectionException (  (  \" Bad   read   method   arg   count :     \"     +    readMethod )  )  ;", "}", "propertyType    =    readMethod . getReturnType (  )  ;", "if    ( propertyType    =  =     ( Void . TYPE )  )     {", "throw   new   IntrospectionException (  (  \" Read   method   returns   void :     \"     +    readMethod )  )  ;", "}", "}", "if    ( writeMethod    !  =    null )     {", "Class <  ?  >  [  ]    params    =    writeMethod . getParameterTypes (  )  ;", "if    (  ( params . length )     !  =     1  )     {", "throw   new   IntrospectionException (  (  \" Bad   write   method   arg   count :     \"     +    writeMethod )  )  ;", "}", "if    ( propertyType    !  =    null )     {", "if    ( propertyType . isAssignableFrom ( params [  0  ]  )  )     {", "propertyType    =    params [  0  ]  ;", "} else", "if    ( params [  0  ]  . isAssignableFrom ( propertyType )  )     {", "} else    {", "throw   new   IntrospectionException (  (  (  (  \" Type   mismatch   between   read   and   write   methods :     \"     +    readMethod )     +     \"     -     \"  )     +    writeMethod )  )  ;", "}", "} else    {", "propertyType    =    params [  0  ]  ;", "}", "}", "return   propertyType ;", "}", "METHOD_END"], "methodName": ["findPropertyType"], "fileName": "org.springframework.beans.PropertyDescriptorUtils"}, {"methodBody": ["METHOD_START", "{", "int   startIndex    =    propertyPath . indexOf ( PropertyAccessor . PROPERTY _ KEY _ PREFIX _ CHAR )  ;", "if    ( startIndex    !  =     (  -  1  )  )     {", "int   endIndex    =    propertyPath . indexOf ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX _ CHAR )  ;", "if    ( endIndex    !  =     (  -  1  )  )     {", "String   prefix    =    propertyPath . substring (  0  ,    startIndex )  ;", "String   key    =    propertyPath . substring ( startIndex ,     ( endIndex    +     1  )  )  ;", "String   suffix    =    propertyPath . substring (  ( endIndex    +     1  )  ,    propertyPath . length (  )  )  ;", "strippedPaths . add (  (  ( nestedPath    +    prefix )     +    suffix )  )  ;", "addStrippedPropertyPaths ( strippedPaths ,     ( nestedPath    +    prefix )  ,    suffix )  ;", "addStrippedPropertyPaths ( strippedPaths ,     (  ( nestedPath    +    prefix )     +    key )  ,    suffix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addStrippedPropertyPaths"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "String   actualPropertyName    =     ( nestedProperty    !  =    null )     ?    PropertyAccessorUtils . getPropertyName ( nestedProperty )     :    null ;", "if    (  ( this . customEditors )     !  =    null )     {", "this . customEditors . forEach ( target :  : registerCustomEditor )  ;", "}", "if    (  ( this . customEditorsForPath )     !  =    null )     {", "this . customEditorsForPath . forEach (  (    editorPath ,    editorHolder )     -  >     {", "if    ( nestedProperty    !  =    null )     {", "int   pos    =    PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( editorPath )  ;", "if    ( pos    !  =     (  -  1  )  )     {", "String   editorNestedProperty    =    editorPath . substring (  0  ,    pos )  ;", "String   editorNestedPath    =    editorPath . substring (  ( pos    +     1  )  )  ;", "if    (  ( editorNestedProperty . equals ( nestedProperty )  )     |  |     ( editorNestedProperty . equals ( actualPropertyName )  )  )     {", "target . registerCustomEditor ( editorHolder . getRegisteredType (  )  ,    editorNestedPath ,    editorHolder . get (  )  )  ;", "}", "}", "} else    {", "target . registerCustomEditor ( editorHolder . getRegisteredType (  )  ,    editorPath ,    editorHolder . get (  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyCustomEditorsTo"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "target . defaultEditorsActive    =    this . defaultEditorsActive ;", "target . configValueEditorsActive    =    this . configValueEditorsActive ;", "target . defaultEditors    =    this . defaultEditors ;", "target . overriddenDefaultEditors    =    this . overriddenDefaultEditors ;", "}", "METHOD_END"], "methodName": ["copyDefaultEditorsTo"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "this . defaultEditors    =    new   HashMap <  >  (  6  4  )  ;", "this . defaultEditors . put ( Charset . class ,    new   CharsetEditor (  )  )  ;", "this . defaultEditors . put ( Class . class ,    new   ClassEditor (  )  )  ;", "this . defaultEditors . put ( Class [  ]  . class ,    new   ClassArrayEditor (  )  )  ;", "this . defaultEditors . put ( Currency . class ,    new   CurrencyEditor (  )  )  ;", "this . defaultEditors . put ( File . class ,    new   FileEditor (  )  )  ;", "this . defaultEditors . put ( InputStream . class ,    new   InputStreamEditor (  )  )  ;", "this . defaultEditors . put ( InputSource . class ,    new   InputSourceEditor (  )  )  ;", "this . defaultEditors . put ( Locale . class ,    new   LocaleEditor (  )  )  ;", "this . defaultEditors . put ( Path . class ,    new   PathEditor (  )  )  ;", "this . defaultEditors . put ( Pattern . class ,    new   PatternEditor (  )  )  ;", "this . defaultEditors . put ( Properties . class ,    new   PropertiesEditor (  )  )  ;", "this . defaultEditors . put ( Reader . class ,    new   ReaderEditor (  )  )  ;", "this . defaultEditors . put ( Resource [  ]  . class ,    new   ResourceArray (  )  )  ;", "this . defaultEditors . put ( TimeZone . class ,    new   TimeZoneEditor (  )  )  ;", "this . defaultEditors . put ( URI . class ,    new   URIEditor (  )  )  ;", "this . defaultEditors . put ( URL . class ,    new   URLEditor (  )  )  ;", "this . defaultEditors . put ( UUID . class ,    new   UUIDEditor (  )  )  ;", "this . defaultEditors . put ( ZoneId . class ,    new   ZoneIdEditor (  )  )  ;", "this . defaultEditors . put ( Collection . class ,    new   CustomCollectionEditor ( Collection . class )  )  ;", "this . defaultEditors . put ( Set . class ,    new   CustomCollectionEditor ( Set . class )  )  ;", "this . defaultEditors . put ( SortedSet . class ,    new   CustomCollectionEditor ( SortedSet . class )  )  ;", "this . defaultEditors . put ( List . class ,    new   CustomCollectionEditor ( List . class )  )  ;", "this . defaultEditors . put ( SortedMap . class ,    new   CustomMapEditor ( SortedMap . class )  )  ;", "this . defaultEditors . put ( byte [  ]  . class ,    new   ByteArray (  )  )  ;", "this . defaultEditors . put ( char [  ]  . class ,    new   CharArray (  )  )  ;", "this . defaultEditors . put ( char . class ,    new   CharacterEditor ( false )  )  ;", "this . defaultEditors . put ( Character . class ,    new   CharacterEditor ( true )  )  ;", "this . defaultEditors . put ( boolean . class ,    new   CustomBooleanEditor ( false )  )  ;", "this . defaultEditors . put ( Boolean . class ,    new   CustomBooleanEditor ( true )  )  ;", "this . defaultEditors . put ( byte . class ,    new   CustomNumberEditor ( Byte . class ,    false )  )  ;", "this . defaultEditors . put ( Byte . class ,    new   CustomNumberEditor ( Byte . class ,    true )  )  ;", "this . defaultEditors . put ( short . class ,    new   CustomNumberEditor ( Short . class ,    false )  )  ;", "this . defaultEditors . put ( Short . class ,    new   CustomNumberEditor ( Short . class ,    true )  )  ;", "this . defaultEditors . put ( int . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "this . defaultEditors . put ( Integer . class ,    new   CustomNumberEditor ( Integer . class ,    true )  )  ;", "this . defaultEditors . put ( long . class ,    new   CustomNumberEditor ( Long . class ,    false )  )  ;", "this . defaultEditors . put ( Long . class ,    new   CustomNumberEditor ( Long . class ,    true )  )  ;", "this . defaultEditors . put ( float . class ,    new   CustomNumberEditor ( Float . class ,    false )  )  ;", "this . defaultEditors . put ( Float . class ,    new   CustomNumberEditor ( Float . class ,    true )  )  ;", "this . defaultEditors . put ( double . class ,    new   CustomNumberEditor ( Double . class ,    false )  )  ;", "this . defaultEditors . put ( Double . class ,    new   CustomNumberEditor ( Double . class ,    true )  )  ;", "this . defaultEditors . put ( BigDecimal . class ,    new   CustomNumberEditor ( BigDecimal . class ,    true )  )  ;", "this . defaultEditors . put ( BigInteger . class ,    new   CustomNumberEditor ( BigInteger . class ,    true )  )  ;", "if    ( this . configValueEditorsActive )     {", "StringArray   sae    =    new   StringArray (  )  ;", "this . defaultEditors . put ( String [  ]  . class ,    sae )  ;", "this . defaultEditors . put ( short [  ]  . class ,    sae )  ;", "this . defaultEditors . put ( int [  ]  . class ,    sae )  ;", "this . defaultEditors . put ( long [  ]  . class ,    sae )  ;", "}", "}", "METHOD_END"], "methodName": ["createDefaultEditors"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "return   this . conversionService ;", "}", "METHOD_END"], "methodName": ["getConversionService"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( requiredType    =  =    null )     |  |     (  ( this . customEditors )     =  =    null )  )     {", "return   null ;", "}", "editor    =    this . customEditors . get ( requiredType )  ;", "if    ( editor    =  =    null )     {", "if    (  ( this . customEditorCache )     !  =    null )     {", "editor    =    this . customEditorCache . get ( requiredType )  ;", "}", "if    ( editor    =  =    null )     {", "for    ( Iterator < Class <  ?  >  >    it    =    this . customEditors . keySet (  )  . iterator (  )  ;     ( it . hasNext (  )  )     &  &     ( editor    =  =    null )  ;  )     {", "Class <  ?  >    key    =    it . next (  )  ;", "if    ( key . isAssignableFrom ( requiredType )  )     {", "editor    =    this . customEditors . get ( key )  ;", "if    (  ( this . customEditorCache )     =  =    null )     {", "this . customEditorCache    =    new   HashMap <  >  (  )  ;", "}", "this . customEditorCache . put ( requiredType ,    editor )  ;", "}", "}", "}", "}", "return   editor ;", "}", "METHOD_END"], "methodName": ["getCustomEditor"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "PropertyEditorRegistrySupport . CustomEditorHolder   holder    =     (  ( this . customEditorsForPath )     !  =    null )     ?    this . customEditorsForPath . get ( propertyName )     :    null ;", "return   holder    !  =    null    ?    holder . getPropertyEditor ( requiredType )     :    null ;", "}", "METHOD_END"], "methodName": ["getCustomEditor"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . defaultEditorsActive )  )     {", "return   null ;", "}", "if    (  ( this . overriddenDefaultEditors )     !  =    null )     {", "editor    =    this . overriddenDefaultEditors . get ( requiredType )  ;", "if    ( editor    !  =    null )     {", "return   editor ;", "}", "}", "if    (  ( this . defaultEditors )     =  =    null )     {", "createDefaultEditors (  )  ;", "}", "return   this . defaultEditors . get ( requiredType )  ;", "}", "METHOD_END"], "methodName": ["getDefaultEditor"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getPropertyType"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . customEditorsForPath )     !  =    null )     {", ". CustomEditorHolder   editorHolder    =    this . customEditorsForPath . get ( propertyName )  ;", "if    ( editorHolder    =  =    null )     {", "List < String >    strippedPaths    =    new   LinkedList <  >  (  )  ;", "addStrippedPropertyPaths ( strippedPaths ,     \"  \"  ,    propertyName )  ;", "for    ( Iterator < String >    it    =    strippedPaths . iterator (  )  ;     ( it . hasNext (  )  )     &  &     ( editorHolder    =  =    null )  ;  )     {", "String   strippedName    =    it . next (  )  ;", "editorHolder    =    this . customEditorsForPath . get ( strippedName )  ;", "}", "}", "if    ( editorHolder    !  =    null )     {", "return   editorHolder . getRegisteredType (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["guessPropertyTypeFromEditors"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( propertyPath    !  =    null )     &  &     (  ( this . customEditorsForPath )     !  =    null )  )     {", "for    ( Map . Entry < String ,     . CustomEditorHolder >    entry    :    this . customEditorsForPath . entrySet (  )  )     {", "if    (  ( PropertyAccessorUtils . matchesProperty ( entry . getKey (  )  ,    propertyPath )  )     &  &     (  ( entry . getValue (  )  . getPropertyEditor ( elementType )  )     !  =    null )  )     {", "return   true ;", "}", "}", "}", "return    (  ( elementType    !  =    null )     &  &     (  ( this . customEditors )     !  =    null )  )     &  &     ( this . customEditors . containsKey ( elementType )  )  ;", "}", "METHOD_END"], "methodName": ["hasCustomEditorForElement"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . overriddenDefaultEditors )     =  =    null )     {", "this . overriddenDefaultEditors    =    new   HashMap <  >  (  )  ;", "}", "this . overriddenDefaultEditors . put ( requiredType ,    p )  ;", "}", "METHOD_END"], "methodName": ["overrideDefaultEditor"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "this . defaultEditorsActive    =    true ;", "}", "METHOD_END"], "methodName": ["registerDefaultEditors"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "this . conversionService    =    conversionService ;", "}", "METHOD_END"], "methodName": ["setConversionService"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "this . configValueEditorsActive    =    true ;", "}", "METHOD_END"], "methodName": ["useConfigValueEditors"], "fileName": "org.springframework.beans.PropertyEditorRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "msg . append (  \" Did   you   mean    \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( this . possible . length )  ;    i +  +  )     {", "msg . append (  '  \\  '  '  )  ;", "msg . append ( this . possible [ i ]  )  ;", "if    ( i    <     (  ( this . possible . length )     -     2  )  )     {", "msg . append (  \"  '  ,     \"  )  ;", "} else", "if    ( i    =  =     (  ( this . possible . length )     -     2  )  )     {", "msg . append (  \"  '  ,    or    \"  )  ;", "}", "}", "msg . append (  \"  '  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["appendHintMessage"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "if    ( s 1  . isEmpty (  )  )     {", "return   s 2  . length (  )  ;", "}", "if    ( s 2  . isEmpty (  )  )     {", "return   s 1  . length (  )  ;", "}", "int [  ]  [  ]    d    =    new   int [  ( s 1  . length (  )  )     +     1  ]  [  ( s 2  . length (  )  )     +     1  ]  ;", "for    ( int   i    =     0  ;    i    <  =     ( s 1  . length (  )  )  ;    i +  +  )     {", "d [ i ]  [  0  ]     =    i ;", "}", "for    ( int   j    =     0  ;    j    <  =     ( s 2  . length (  )  )  ;    j +  +  )     {", "d [  0  ]  [ j ]     =    j ;", "}", "for    ( int   i    =     1  ;    i    <  =     ( s 1  . length (  )  )  ;    i +  +  )     {", "char   c 1     =    s 1  . charAt (  ( i    -     1  )  )  ;", "for    ( int   j    =     1  ;    j    <  =     ( s 2  . length (  )  )  ;    j +  +  )     {", "int   cost ;", "char   c 2     =    s 2  . charAt (  ( j    -     1  )  )  ;", "if    ( c 1     =  =    c 2  )     {", "cost    =     0  ;", "} else    {", "cost    =     1  ;", "}", "d [ i ]  [ j ]     =    h . min ( h . min (  (  ( d [  ( i    -     1  )  ]  [ j ]  )     +     1  )  ,     (  ( d [ i ]  [  ( j    -     1  )  ]  )     +     1  )  )  ,     (  ( d [  ( i    -     1  )  ]  [  ( j    -     1  )  ]  )     +    cost )  )  ;", "}", "}", "return   d [ s 1  . length (  )  ]  [ s 2  . length (  )  ]  ;", "}", "METHOD_END"], "methodName": ["calculateStringDistance"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   PropertyMatches . forField ( propertyName ,    beanClass ,    PropertyMatches . DEFAULT _ MAX _ DISTANCE )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyMatches . FieldPropertyMatches ( propertyName ,    beanClass ,    maxDistance )  ;", "}", "METHOD_END"], "methodName": ["forField"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   PropertyMatches . forProperty ( propertyName ,    beanClass ,    PropertyMatches . DEFAULT _ MAX _ DISTANCE )  ;", "}", "METHOD_END"], "methodName": ["forProperty"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyMatches . BeanPropertyMatches ( propertyName ,    beanClass ,    maxDistance )  ;", "}", "METHOD_END"], "methodName": ["forProperty"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   this . possibleMatches ;", "}", "METHOD_END"], "methodName": ["getPossibleMatches"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.springframework.beans.PropertyMatches"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" counter \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "String   msg    =    matches . buildErrorMessage (  )  ;", "assertThat ( msg ,    containsString (  \" counter \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 1  \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 2  \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["complexBeanPropertyErrorMessage"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" desriptn \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    emptyArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["complexBeanPropertyTypo"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" counter \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "String   msg    =    matches . buildErrorMessage (  )  ;", "assertThat ( msg ,    containsString (  \" counter \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 1  \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 2  \"  )  )  ;", "assertThat ( msg ,    containsString (  \" counter 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["complexFieldPropertyErrorMessage"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" desriptn \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    emptyArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["complexFieldPropertyTypo"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" counter \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 1  \"  )  )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 2  \"  )  )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["severalMatchesBeanProperty"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" counter \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 1  \"  )  )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 2  \"  )  )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" counter 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["severalMatchesFieldProperty"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" naem \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "String   msg    =    matches . buildErrorMessage (  )  ;", "assertThat ( msg ,    containsString (  \" naem \"  )  )  ;", "assertThat ( msg ,    containsString (  \" name \"  )  )  ;", "assertThat ( msg ,    containsString (  \" setter \"  )  )  ;", "assertThat ( msg ,    not ( containsString (  \" field \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleBeanPropertyErrorMessage"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" naem \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleBeanPropertyTypo"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" naem \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "String   msg    =    matches . buildErrorMessage (  )  ;", "assertThat ( msg ,    containsString (  \" naem \"  )  )  ;", "assertThat ( msg ,    containsString (  \" name \"  )  )  ;", "assertThat ( msg ,    containsString (  \" field \"  )  )  ;", "assertThat ( msg ,    not ( containsString (  \" setter \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleFieldPropertyErrorMessage"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" naem \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    hasItemInArray (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleFieldPropertyTypo"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forProperty (  \" unknown \"  ,    PropertyMatchesTests . SampleBeanProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    emptyArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["unknownBeanProperty"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "PropertyMatches   matches    =    PropertyMatches . forField (  \" unknown \"  ,    PropertyMatchesTests . SampleFieldProperties . class )  ;", "assertThat ( matches . getPossibleMatches (  )  ,    emptyArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["unknownFieldProperty"], "fileName": "org.springframework.beans.PropertyMatchesTests"}, {"methodBody": ["METHOD_START", "{", "return   this . convertedValue ;", "}", "METHOD_END"], "methodName": ["getConvertedValue"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "PropertyValue   original    =    this ;", "Object   source    =    getSource (  )  ;", "while    (  ( source   instanceof   PropertyValue )     &  &     ( source    !  =    original )  )     {", "original    =     (  ( PropertyValue )     ( source )  )  ;", "source    =    original . getSource (  )  ;", "}", "return   original ;", "}", "METHOD_END"], "methodName": ["getOriginalPropertyValue"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "return   this . converted ;", "}", "METHOD_END"], "methodName": ["isConverted"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "return   this . optional ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "this . converted    =    true ;", "this . converted    =    value ;", "}", "METHOD_END"], "methodName": ["setConvertedValue"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "this . optional    =    optional ;", "}", "METHOD_END"], "methodName": ["setOptional"], "fileName": "org.springframework.beans.PropertyValue"}, {"methodBody": ["METHOD_START", "{", "Object   pd 1     =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 1  )  )  ;", "Object   pd 2     =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 2  )  )  ;", "assertThat ( pd 2  ,    equalTo ( pd 1  )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setFoo ( int   i ,    String   foo )     {", "return   null ;", "}", "public   String   getFoo ( int   i )     {", "return   null ;", "}", "}", "Method   wm 1     =    C . class . getMethod (  \" setFoo \"  ,    int . class ,    String . class )  ;", "Object   pd 3     =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    wm 1  )  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 3  )  )  )  ;", "assertThat ( pd 3  ,    not ( equalTo ( pd 1  )  )  )  ;", "Method   rm 1     =    C . class . getMethod (  \" getFoo \"  ,    int . class )  ;", "Object   pd 4     =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    rm 1  ,    null )  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 4  )  )  )  ;", "assertThat ( pd 4  ,    not ( equalTo ( pd 1  )  )  )  ;", "Object   pd 5     =    new   IndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 5  )  )  ;", "assertThat ( pd 5  ,    equalTo ( pd 1  )  )  ;", "Object   pd 6     =     \" not   a   PD \"  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 6  )  )  )  ;", "assertThat ( pd 6  ,    not ( equalTo ( pd 1  )  )  )  ;", "Object   pd 7     =    null ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 7  )  )  )  ;", "assertThat ( pd 7  ,    not ( equalTo ( pd 1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["indexedEquality"], "fileName": "org.springframework.beans.SimplePropertyDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   pd 1     =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 1  )  )  ;", "Object   pd 2     =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 2  )  )  ;", "assertThat ( pd 2  ,    equalTo ( pd 1  )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "class   C    {", "public   Object   setFoo ( String   foo )     {", "return   null ;", "}", "public   String   getFoo (  )     {", "return   null ;", "}", "}", "Method   wm 1     =    C . class . getMethod (  \" setFoo \"  ,    String . class )  ;", "Object   pd 3     =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    null ,    wm 1  )  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 3  )  )  )  ;", "assertThat ( pd 3  ,    not ( equalTo ( pd 1  )  )  )  ;", "Method   rm 1     =    C . class . getMethod (  \" getFoo \"  )  ;", "Object   pd 4     =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    rm 1  ,    null )  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 4  )  )  )  ;", "assertThat ( pd 4  ,    not ( equalTo ( pd 1  )  )  )  ;", "Object   pd 5     =    new   PropertyDescriptor (  \" foo \"  ,    null ,    null )  ;", "assertThat ( pd 1  ,    equalTo ( pd 5  )  )  ;", "assertThat ( pd 5  ,    equalTo ( pd 1  )  )  ;", "Object   pd 6     =     \" not   a   PD \"  ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 6  )  )  )  ;", "assertThat ( pd 6  ,    not ( equalTo ( pd 1  )  )  )  ;", "Object   pd 7     =    null ;", "assertThat ( pd 1  ,    not ( equalTo ( pd 7  )  )  )  ;", "assertThat ( pd 7  ,    not ( equalTo ( pd 1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nonIndexedEquality"], "fileName": "org.springframework.beans.SimplePropertyDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "{", "Object   pd    =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    null ,    null )  ;", "assertThat ( pd . toString (  )  ,    containsString (  \" PropertyDescriptor [ name = foo ,    propertyType = null ,    readMethod = null \"  )  )  ;", "}", "{", "class   C    {", "@ SuppressWarnings (  \" unused \"  )", "public   Object   setFoo ( String   foo )     {", "return   null ;", "}", "}", "Method   m    =    C . class . getMethod (  \" setFoo \"  ,    String . class )  ;", "Object   pd    =    new   ExtendedBeanInfo . SimplePropertyDescriptor (  \" foo \"  ,    null ,    m )  ;", "assertThat ( pd . toString (  )  ,    allOf ( containsString (  \" PropertyDescriptor [ name = foo \"  )  ,    containsString (  \" propertyType = class   String \"  )  ,    containsString (  \" readMethod = null ,    writeMethod = public   Object \"  )  )  )  ;", "}", "{", "Object   pd    =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    null )  ;", "assertThat ( pd . toString (  )  ,    containsString (  \" PropertyDescriptor [ name = foo ,    propertyType = null ,    indexedPropertyType = null \"  )  )  ;", "}", "{", "class   C    {", "@ SuppressWarnings (  \" unused \"  )", "public   Object   setFoo ( int   i ,    String   foo )     {", "return   null ;", "}", "}", "Method   m    =    C . class . getMethod (  \" setFoo \"  ,    int . class ,    String . class )  ;", "Object   pd    =    new   ExtendedBeanInfo . SimpleIndexedPropertyDescriptor (  \" foo \"  ,    null ,    null ,    null ,    m )  ;", "assertThat ( pd . toString (  )  ,    allOf ( containsString (  \" PropertyDescriptor [ name = foo ,    propertyType = null \"  )  ,    containsString (  \" indexedPropertyType = class   String \"  )  ,    containsString (  \" indexedWriteMethod = public   Object \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toStringOutput"], "fileName": "org.springframework.beans.SimplePropertyDescriptorTests"}, {"methodBody": ["METHOD_START", "{", "Object   convertedValue    =    currentConvertedValue ;", "if    (  (  ( Enum . class )     =  =    requiredType )     &  &     (  ( this . targetObject )     !  =    null )  )     {", "int   index    =    trimmedValue . lastIndexOf (  '  .  '  )  ;", "if    ( index    >     (  -  1  )  )     {", "String   enumType    =    trimmedValue . substring (  0  ,    index )  ;", "String   fieldName    =    trimmedValue . substring (  ( index    +     1  )  )  ;", "ClassLoader   cl    =    this . targetObject . getClass (  )  . getClassLoader (  )  ;", "try    {", "Class <  ?  >    enumValueType    =    ClassUtils . forName ( enumType ,    cl )  ;", "Field   enumField    =    enumValueType . getField ( fieldName )  ;", "convertedValue    =    enumField . get ( null )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Enum   class    [  \"     +    enumType )     +     \"  ]    cannot   be   loaded \"  )  ,    ex )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  \" Field    [  \"     +    fieldName )     +     \"  ]    isn ' t   an   enum   value   for   type    [  \"  )     +    enumType )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "}", "if    ( convertedValue    =  =    currentConvertedValue )     {", "try    {", "Field   enumField    =    requiredType . getField ( trimmedValue )  ;", "ReflectionUtils . makeAccessible ( enumField )  ;", "convertedValue    =    enumField . get ( null )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Field    [  \"     +    convertedValue )     +     \"  ]    isn ' t   an   enum   value \"  )  ,    ex )  ;", "}", "}", "}", "return   convertedValue ;", "}", "METHOD_END"], "methodName": ["attemptToConvertStringToEnum"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return   propertyName    !  =    null    ?     (  ( propertyName    +     ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )  )     +    index )     +     ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )     :    null ;", "}", "METHOD_END"], "methodName": ["buildIndexedPropertyName"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return   propertyName    !  =    null    ?     (  ( propertyName    +     ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )  )     +    key )     +     ( PropertyAccessor . PROPERTY _ KEY _ SUFFIX )     :    null ;", "}", "METHOD_END"], "methodName": ["buildKeyedPropertyName"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  !  ( requiredType . isInterface (  )  )  )     &  &     (  !  ( Modifier . isAbstract ( requiredType . getModifiers (  )  )  )  )  )     &  &     ( Modifier . isPublic ( requiredType . getModifiers (  )  )  )  )     &  &     ( ClassUtils . hasConstructor ( requiredType )  )  ;", "}", "METHOD_END"], "methodName": ["canCreateCopy"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return   convertIfNecessary ( null ,    null ,    newValue ,    requiredType ,     ( field    !  =    null    ?    new   TypeDescriptor ( field )     :    TypeDescriptor . valueOf ( requiredType )  )  )  ;", "}", "METHOD_END"], "methodName": ["convertIfNecessary"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return   convertIfNecessary ( null ,    null ,    newValue ,    requiredType ,     ( methodParam    !  =    null    ?    new   TypeDescriptor ( methodParam )     :    TypeDescriptor . valueOf ( requiredType )  )  )  ;", "}", "METHOD_END"], "methodName": ["convertIfNecessary"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "return   convertIfNecessary ( propertyName ,    oldValue ,    newValue ,    requiredType ,    TypeDescriptor . valueOf ( requiredType )  )  ;", "}", "METHOD_END"], "methodName": ["convertIfNecessary"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    this . propertyEditorRegistry . findCustomEditor ( requiredType ,    propertyName )  ;", "ConversionFailedException   conversionAttemptEx    =    null ;", "ConversionService   conversionService    =    this . propertyEditorRegistry . getConversionService (  )  ;", "if    (  (  (  ( editor    =  =    null )     &  &     ( conversionService    !  =    null )  )     &  &     ( newValue    !  =    null )  )     &  &     ( typeDescriptor    !  =    null )  )     {", "TypeDescriptor   sourceTypeDesc    =    TypeDescriptor . forObject ( newValue )  ;", "if    ( conversionService . canConvert ( sourceTypeDesc ,    typeDescriptor )  )     {", "try    {", "return    (  ( T )     ( conversionService . convert ( newValue ,    sourceTypeDesc ,    typeDescriptor )  )  )  ;", "}    catch    ( ConversionFailedException   ex )     {", "conversionAttemptEx    =    ex ;", "}", "}", "}", "Object   convertedValue    =    newValue ;", "if    (  ( editor    !  =    null )     |  |     (  ( requiredType    !  =    null )     &  &     (  !  ( ClassUtils . isAssignableValue ( requiredType ,    convertedValue )  )  )  )  )     {", "if    (  (  (  ( typeDescriptor    !  =    null )     &  &     ( requiredType    !  =    null )  )     &  &     ( Collection . class . isAssignableFrom ( requiredType )  )  )     &  &     ( convertedValue   instanceof   String )  )     {", "TypeDescriptor   elementTypeDesc    =    typeDescriptor . getElementTypeDescriptor (  )  ;", "if    ( elementTypeDesc    !  =    null )     {", "Class <  ?  >    elementType    =    elementTypeDesc . getType (  )  ;", "if    (  (  ( Class . class )     =  =    elementType )     |  |     ( Enum . class . isAssignableFrom ( elementType )  )  )     {", "convertedValue    =    StringUtils . commaDelimitedListToStringArray (  (  ( String )     ( convertedValue )  )  )  ;", "}", "}", "}", "if    ( editor    =  =    null )     {", "editor    =    findDefaultEditor ( requiredType )  ;", "}", "convertedValue    =    doConvertValue ( oldValue ,    convertedValue ,    requiredType ,    editor )  ;", "}", "boolean   standardConversion    =    false ;", "if    ( requiredType    !  =    null )     {", "if    ( convertedValue    !  =    null )     {", "if    (  ( Object . class )     =  =    requiredType )     {", "return    (  ( T )     ( convertedValue )  )  ;", "} else", "if    ( requiredType . isArray (  )  )     {", "if    (  ( convertedValue   instanceof   String )     &  &     ( Enum . class . isAssignableFrom ( requiredType . getComponentType (  )  )  )  )     {", "convertedValue    =    StringUtils . commaDelimitedListToStringArray (  (  ( String )     ( convertedValue )  )  )  ;", "}", "return    (  ( T )     ( convertToTypedArray ( convertedValue ,    propertyName ,    requiredType . getComponentType (  )  )  )  )  ;", "} else", "if    ( convertedValue   instanceof   Collection )     {", "convertedValue    =    convertToTypedCollection (  (  ( Collection <  ?  >  )     ( convertedValue )  )  ,    propertyName ,    requiredType ,    typeDescriptor )  ;", "standardConversion    =    true ;", "} else", "if    ( convertedValue   instanceof   Map )     {", "convertedValue    =    convertToTypedMap (  (  ( Map <  ?  ,     ?  >  )     ( convertedValue )  )  ,    propertyName ,    requiredType ,    typeDescriptor )  ;", "standardConversion    =    true ;", "}", "if    (  ( convertedValue . getClass (  )  . isArray (  )  )     &  &     (  ( Array . getLength ( convertedValue )  )     =  =     1  )  )     {", "convertedValue    =    Array . get ( convertedValue ,     0  )  ;", "standardConversion    =    true ;", "}", "if    (  (  ( String . class )     =  =    requiredType )     &  &     ( ClassUtils . isPrimitiveOrWrapper ( convertedValue . getClass (  )  )  )  )     {", "return    (  ( T )     ( convertedValue . toString (  )  )  )  ;", "} else", "if    (  ( convertedValue   instanceof   String )     &  &     (  !  ( requiredType . isInstance ( convertedValue )  )  )  )     {", "if    (  (  ( conversionAttemptEx    =  =    null )     &  &     (  !  ( requiredType . isInterface (  )  )  )  )     &  &     (  !  ( requiredType . isEnum (  )  )  )  )     {", "try    {", "Constructor < T >    strCtor    =    requiredType . getConstructor ( String . class )  ;", "return   BeanUtils . instantiateClass ( strCtor ,    convertedValue )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" No   String   constructor   found   on   type    [  \"     +     ( requiredType . getName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Construction   via   String   failed   for   type    [  \"     +     ( requiredType . getName (  )  )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "String   trimmedValue    =     (  ( String )     ( convertedValue )  )  . trim (  )  ;", "if    (  ( requiredType . isEnum (  )  )     &  &     (  \"  \"  . equals ( trimmedValue )  )  )     {", "return   null ;", "}", "convertedValue    =    attemptToConvertStringToEnum ( requiredType ,    trimmedValue ,    convertedValue )  ;", "standardConversion    =    true ;", "} else", "if    (  ( convertedValue   instanceof   Number )     &  &     ( Number . class . isAssignableFrom ( requiredType )  )  )     {", "convertedValue    =    convertNumberToTargetClass (  (  ( Number )     ( convertedValue )  )  ,     (  ( Class < Number >  )     ( requiredType )  )  )  ;", "standardConversion    =    true ;", "}", "} else    {", "if    ( requiredType    =  =     ( Optional . class )  )     {", "convertedValue    =    Optional . empty (  )  ;", "}", "}", "if    (  !  ( ClassUtils . isAssignableValue ( requiredType ,    convertedValue )  )  )     {", "if    ( conversionAttemptEx    !  =    null )     {", "throw   conversionAttemptEx ;", "} else", "if    (  ( conversionService    !  =    null )     &  &     ( typeDescriptor    !  =    null )  )     {", "TypeDescriptor   sourceTypeDesc    =    TypeDescriptor . forObject ( newValue )  ;", "if    ( conversionService . canConvert ( sourceTypeDesc ,    typeDescriptor )  )     {", "return    (  ( T )     ( conversionService . convert ( newValue ,    sourceTypeDesc ,    typeDescriptor )  )  )  ;", "}", "}", "StringBuilder   msg    =    new   StringBuilder (  )  ;", "msg . append (  \" Cannot   convert   value   of   type    '  \"  )  . append ( ClassUtils . getDescriptiveType ( newValue )  )  ;", "msg . append (  \"  '    to   required   type    '  \"  )  . append ( ClassUtils . getQualifiedName ( requiredType )  )  . append (  \"  '  \"  )  ;", "if    ( propertyName    !  =    null )     {", "msg . append (  \"    for   property    '  \"  )  . append ( propertyName )  . append (  \"  '  \"  )  ;", "}", "if    ( editor    !  =    null )     {", "msg . append (  \"  :    PropertyEditor    [  \"  )  . append ( editor . getClass (  )  . getName (  )  )  . append (  \"  ]    returned   inappropriate   value   of   type    '  \"  )  . append ( ClassUtils . getDescriptiveType ( convertedValue )  )  . append (  \"  '  \"  )  ;", "throw   new   IllegalArgumentException ( msg . toString (  )  )  ;", "} else    {", "msg . append (  \"  :    no   matching   editors   or   conversion   strategy   found \"  )  ;", "throw   new   IllegalStateException ( msg . toString (  )  )  ;", "}", "}", "}", "if    ( conversionAttemptEx    !  =    null )     {", "if    (  (  (  ( editor    =  =    null )     &  &     (  ! standardConversion )  )     &  &     ( requiredType    !  =    null )  )     &  &     (  ( Object . class )     !  =    requiredType )  )     {", "throw   conversionAttemptEx ;", "}", ". logger . debug (  (  \" Original   ConversionService   attempt   failed    -    ignored   since    \"     +     \" PropertyEditor   based   conversion   eventually   succeeded \"  )  ,    conversionAttemptEx )  ;", "}", "return    (  ( T )     ( convertedValue )  )  ;", "}", "METHOD_END"], "methodName": ["convertIfNecessary"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "if    ( input   instanceof   Collection )     {", "Collection <  ?  >    coll    =     (  ( Collection <  ?  >  )     ( input )  )  ;", "Object   result    =    Array . newInstance ( componentType ,    coll . size (  )  )  ;", "int   i    =     0  ;", "for    ( Iterator <  ?  >    it    =    coll . iterator (  )  ;    it . hasNext (  )  ;    i +  +  )     {", "Object   value    =    cIfNecessary ( buildIndexedPropertyName ( propertyName ,    i )  ,    null ,    it . next (  )  ,    componentType )  ;", "Array . set ( result ,    i ,    value )  ;", "}", "return   result ;", "} else", "if    ( input . getClass (  )  . isArray (  )  )     {", "if    (  ( componentType . equals ( input . getClass (  )  . getComponentType (  )  )  )     &  &     (  !  ( this . propertyEditorRegistry . hasCustomEditorForElement ( componentType ,    propertyName )  )  )  )     {", "return   input ;", "}", "int   arrayLength    =    Array . getLength ( input )  ;", "Object   result    =    Array . newInstance ( componentType ,    arrayLength )  ;", "for    ( int   i    =     0  ;    i    <    arrayLength ;    i +  +  )     {", "Object   value    =    cIfNecessary ( buildIndexedPropertyName ( propertyName ,    i )  ,    null ,    Array . get ( input ,    i )  ,    componentType )  ;", "Array . set ( result ,    i ,    value )  ;", "}", "return   result ;", "} else    {", "Object   result    =    Array . newInstance ( componentType ,     1  )  ;", "Object   value    =    cIfNecessary ( buildIndexedPropertyName ( propertyName ,     0  )  ,    null ,    input ,    componentType )  ;", "Array . set ( result ,     0  ,    value )  ;", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["convertToTypedArray"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Collection . class . isAssignableFrom ( requiredType )  )  )     {", "return   original ;", "}", "boolean   approximable    =    CollectionFactory . isApproximableCollectionType ( requiredType )  ;", "if    (  (  ! approximable )     &  &     (  !  ( canCreateCopy ( requiredType )  )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Custom   Collection   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   allow   for   creating   a   copy    -    injecting   original   Collection   as - is \"  )  )  ;", "}", "return   original ;", "}", "boolean   originalAllowed    =    requiredType . isInstance ( original )  ;", "TypeDescriptor   elementType    =     ( typeDescriptor    !  =    null )     ?    typeDescriptor . getElementTypeDescriptor (  )     :    null ;", "if    (  (  ( elementType    =  =    null )     &  &    originalAllowed )     &  &     (  !  ( this . propertyEditorRegistry . hasCustomEditorForElement ( null ,    propertyName )  )  )  )     {", "return   original ;", "}", "Iterator <  ?  >    it ;", "try    {", "it    =    original . iterator (  )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   access   Collection   of   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]     -    injecting   original   Collection   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "Collection < Object >    convertedCopy ;", "try    {", "if    ( approximable )     {", "convertedCopy    =    CollectionFactory . createApproximateCollection ( original ,    original . size (  )  )  ;", "} else    {", "convertedCopy    =     (  ( Collection < Object >  )     ( ReflectionUtils . accessibleConstructor ( requiredType )  . newInstance (  )  )  )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   create   copy   of   Collection   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]     -    injecting   original   Collection   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "int   i    =     0  ;", "for    (  ;    it . hasNext (  )  ;    i +  +  )     {", "Object   element    =    it . next (  )  ;", "String   indexedPropertyName    =    buildIndexedPropertyName ( propertyName ,    i )  ;", "Object   convertedElement    =    convertIfNecessary ( indexedPropertyName ,    null ,    element ,     ( elementType    !  =    null    ?    elementType . getType (  )     :    null )  ,    elementType )  ;", "try    {", "convertedCopy . add ( convertedElement )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Collection   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]    seems   to   be   read - only    -    injecting   original   Collection   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "originalAllowed    =    originalAllowed    &  &     ( element    =  =    convertedElement )  ;", "}", "return   originalAllowed    ?    original    :    convertedCopy ;", "}", "METHOD_END"], "methodName": ["convertToTypedCollection"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Map . class . isAssignableFrom ( requiredType )  )  )     {", "return   original ;", "}", "boolean   approximable    =    CollectionFactory . isApproximableMapType ( requiredType )  ;", "if    (  (  ! approximable )     &  &     (  !  ( canCreateCopy ( requiredType )  )  )  )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Custom   Map   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   allow   for   creating   a   copy    -    injecting   original   Map   as - is \"  )  )  ;", "}", "return   original ;", "}", "boolean   originalAllowed    =    requiredType . isInstance ( original )  ;", "TypeDescriptor   keyType    =     ( typeDescriptor    !  =    null )     ?    typeDescriptor . getMapKeyTypeDescriptor (  )     :    null ;", "TypeDescriptor   valueType    =     ( typeDescriptor    !  =    null )     ?    typeDescriptor . getMapValueTypeDescriptor (  )     :    null ;", "if    (  (  (  ( keyType    =  =    null )     &  &     ( valueType    =  =    null )  )     &  &    originalAllowed )     &  &     (  !  ( this . propertyEditorRegistry . hasCustomEditorForElement ( null ,    propertyName )  )  )  )     {", "return   original ;", "}", "Iterator <  ?  >    it ;", "try    {", "it    =    original . entrySet (  )  . iterator (  )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   access   Map   of   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]     -    injecting   original   Map   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "Map < Object ,    Object >    convertedCopy ;", "try    {", "if    ( approximable )     {", "convertedCopy    =    CollectionFactory . createApproximateMap ( original ,    original . size (  )  )  ;", "} else    {", "convertedCopy    =     (  ( Map < Object ,    Object >  )     ( ReflectionUtils . accessibleConstructor ( requiredType )  . newInstance (  )  )  )  ;", "}", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Cannot   create   copy   of   Map   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]     -    injecting   original   Map   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "while    ( it . hasNext (  )  )     {", "Map . Entry <  ?  ,     ?  >    entry    =     (  ( Map . Entry <  ?  ,     ?  >  )     ( it . next (  )  )  )  ;", "Object   key    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "String   keyedPropertyName    =    buildKeyedPropertyName ( propertyName ,    key )  ;", "Object   convertedKey    =    convertIfNecessary ( keyedPropertyName ,    null ,    key ,     ( keyType    !  =    null    ?    keyType . getType (  )     :    null )  ,    keyType )  ;", "Object   convertedValue    =    convertIfNecessary ( keyedPropertyName ,    null ,    value ,     ( valueType    !  =    null    ?    valueType . getType (  )     :    null )  ,    valueType )  ;", "try    {", "convertedCopy . put ( convertedKey ,    convertedValue )  ;", "}    catch    ( Throwable   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  \" Map   type    [  \"     +     ( original . getClass (  )  . getName (  )  )  )     +     \"  ]    seems   to   be   read - only    -    injecting   original   Map   as - is :     \"  )     +    ex )  )  ;", "}", "return   original ;", "}", "originalAllowed    =     ( originalAllowed    &  &     ( key    =  =    convertedKey )  )     &  &     ( value    =  =    convertedValue )  ;", "}", "return   originalAllowed    ?    original    :    convertedCopy ;", "}", "METHOD_END"], "methodName": ["convertToTypedMap"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "try    {", "editor . setValue ( oldValue )  ;", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" PropertyEditor    [  \"     +     ( editor . getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   support   setValue   call \"  )  ,    ex )  ;", "}", "}", "editor . setAsText ( newTextValue )  ;", "return   editor . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["doConvertTextValue"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "Object   convertedValue    =    newValue ;", "if    (  ( editor    !  =    null )     &  &     (  !  ( convertedValue   instanceof   String )  )  )     {", "try    {", "editor . setValue ( convertedValue )  ;", "Object   newConvertedValue    =    editor . getValue (  )  ;", "if    ( newConvertedValue    !  =    convertedValue )     {", "convertedValue    =    newConvertedValue ;", "editor    =    null ;", "}", "}    catch    ( Exception   ex )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" PropertyEditor    [  \"     +     ( editor . getClass (  )  . getName (  )  )  )     +     \"  ]    does   not   support   setValue   call \"  )  ,    ex )  ;", "}", "}", "}", "Object   returnValue    =    convertedValue ;", "if    (  (  ( requiredType    !  =    null )     &  &     (  !  ( requiredType . isArray (  )  )  )  )     &  &     ( convertedValue   instanceof   String [  ]  )  )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  \" Converting   String   array   to   comma - delimited   String    [  \"     +    convertedValue )     +     \"  ]  \"  )  )  ;", "}", "convertedValue    =    StringUtils . arrayToCommaDelimitedString (  (  ( String [  ]  )     ( convertedValue )  )  )  ;", "}", "if    ( convertedValue   instanceof   String )     {", "if    ( editor    !  =    null )     {", "if    (  . logger . isTraceEnabled (  )  )     {", ". logger . trace (  (  (  (  (  \" Converting   String   to    [  \"     +    requiredType )     +     \"  ]    using   property   editor    [  \"  )     +    editor )     +     \"  ]  \"  )  )  ;", "}", "String   newTextValue    =     (  ( String )     ( convertedValue )  )  ;", "return   doConvertTextValue ( oldValue ,    newTextValue ,    editor )  ;", "} else", "if    (  ( String . class )     =  =    requiredType )     {", "returnValue    =    convertedValue ;", "}", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["doConvertValue"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   editor    =    null ;", "if    ( requiredType    !  =    null )     {", "editor    =    this . propertyEditorRegistry . getDefaultEditor ( requiredType )  ;", "if    (  ( editor    =  =    null )     &  &     (  ( String . class )     !  =    requiredType )  )     {", "editor    =    BeanUtils . findEditorByntion ( requiredType )  ;", "}", "}", "return   editor ;", "}", "METHOD_END"], "methodName": ["findDefaultEditor"], "fileName": "org.springframework.beans.TypeConverterDelegate"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . typeConverterDelegate )     !  =    null )  ,     \" No   TypeConverterDelegate \"  )  ;", "try    {", "if    ( field    !  =    null )     {", "return   this . typeConverterDelegate . convertIfNecessary ( value ,    requiredType ,    field )  ;", "} else    {", "return   this . typeConverterDelegate . convertIfNecessary ( value ,    requiredType ,    methodParam )  ;", "}", "}    catch    ( ConverterNotFoundException    |    IllegalStateException   ex )     {", "throw   new   ConversionNotSupportedException ( value ,    requiredType ,    ex )  ;", "}    catch    ( ConversionException    |    IllegalArgumentException   ex )     {", "throw   new   TypeMismatchException ( value ,    requiredType ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doConvert"], "fileName": "org.springframework.beans.TypeConverterSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . requiredType ;", "}", "METHOD_END"], "methodName": ["getRequiredType"], "fileName": "org.springframework.beans.TypeMismatchException"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . propertyName )     =  =    null )  ,     \" Property   name   already   initialized \"  )  ;", "this . propertyName    =    propertyName ;", "}", "METHOD_END"], "methodName": ["initPropertyName"], "fileName": "org.springframework.beans.TypeMismatchException"}, {"methodBody": ["METHOD_START", "{", "AnnotationBeanUtils . copyPropertiesToBean ( ann ,    bean ,    null ,    excludedProperties )  ;", "}", "METHOD_END"], "methodName": ["copyPropertiesToBean"], "fileName": "org.springframework.beans.annotation.AnnotationBeanUtils"}, {"methodBody": ["METHOD_START", "{", "Set < String >    excluded    =    new   HashSet <  >  ( Arrays . asList ( excludedProperties )  )  ;", "Method [  ] Properties    =    annType (  )  . getDeclaredMethods (  )  ;", "BeanWrapper   bw    =    PropertyAccessorFactory . forBeanPropertyAccess ( bean )  ;", "for    ( MethodProperty    : Properties )     {", "String   propertyName    = Property . getName (  )  ;", "if    (  (  !  ( excluded . contains ( propertyName )  )  )     &  &     ( bw . isWritableProperty ( propertyName )  )  )     {", "Object   value    =    ReflectionUtils . invokeMethodProperty ,    ann )  ;", "if    (  ( valueResolver    !  =    null )     &  &     ( value   instanceof   String )  )     {", "value    =    valueResolver . resolveStringValue (  (  ( String )     ( value )  )  )  ;", "}", "bw . setPropertyValue ( propertyName ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyPropertiesToBean"], "fileName": "org.springframework.beans.annotation.AnnotationBeanUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . relatedCauses )     =  =    null )     {", "this . relatedCauses    =    new   LinkedList <  >  (  )  ;", "}", "this . relatedCauses . add ( ex )  ;", "}", "METHOD_END"], "methodName": ["addRelatedCause"], "fileName": "org.springframework.beans.factory.BeanCreationException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.BeanCreationException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . relatedCauses )     =  =    null )     {", "return   null ;", "}", "return   this . relatedCauses . toArray ( new   Throwable [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getRelatedCauses"], "fileName": "org.springframework.beans.factory.BeanCreationException"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceDescription ;", "}", "METHOD_END"], "methodName": ["getResourceDescription"], "fileName": "org.springframework.beans.factory.BeanCreationException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.BeanDefinitionStoreException"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceDescription ;", "}", "METHOD_END"], "methodName": ["getResourceDescription"], "fileName": "org.springframework.beans.factory.BeanDefinitionStoreException"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "String [  ]    result    =    lbf . getBeanNamesForAnnotation ( annotationType )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "String [  ]    parentResult    =     . beanNamesForAnnotationIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    annotationType )  ;", "result    =     . mergeNamesWithParent ( result ,    parentResult ,    hbf )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beanNamesForAnnotationIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "String [  ]    result    =    lbf . getBeanNamesForType ( type )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "String [  ]    parentResult    =     . beanNamesForTypeIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    type )  ;", "result    =     . mergeNamesWithParent ( result ,    parentResult ,    hbf )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beanNamesForTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "String [  ]    result    =    lbf . getBeanNamesForType ( type ,    includeNonSingletons ,    allowEagerInit )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "String [  ]    parentResult    =     . beanNamesForTypeIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    type ,    includeNonSingletons ,    allowEagerInit )  ;", "result    =     . mergeNamesWithParent ( result ,    parentResult ,    hbf )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beanNamesForTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "String [  ]    result    =    lbf . getBeanNamesForType ( type )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "String [  ]    parentResult    =     . beanNamesForTypeIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    type )  ;", "result    =     . mergeNamesWithParent ( result ,    parentResult ,    hbf )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beanNamesForTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( lbf ,    Object . class )  ;", "}", "METHOD_END"], "methodName": ["beanNamesIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "Map < String ,    T >    beansOfType    =    lbf . getBeansOfType ( type )  ;", "return    . uniqueBean ( type ,    beansOfType )  ;", "}", "METHOD_END"], "methodName": ["beanOfType"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "Map < String ,    T >    beansOfType    =    lbf . getBeansOfType ( type ,    includeNonSingletons ,    allowEagerInit )  ;", "return    . uniqueBean ( type ,    beansOfType )  ;", "}", "METHOD_END"], "methodName": ["beanOfType"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    T >    beansOfType    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( lbf ,    type )  ;", "return   BeanFactoryUtils . uniqueBean ( type ,    beansOfType )  ;", "}", "METHOD_END"], "methodName": ["beanOfTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    T >    beansOfType    =    BeanFactoryUtils . beansOfTypeIncludingAncestors ( lbf ,    type ,    includeNonSingletons ,    allowEagerInit )  ;", "return   BeanFactoryUtils . uniqueBean ( type ,    beansOfType )  ;", "}", "METHOD_END"], "methodName": ["beanOfTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "Map < String ,    T >    result    =    new   LinkedHashMap <  >  (  4  )  ;", "result . putAll ( lbf . getBeansOfType ( type )  )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "Map < String ,    T >    parentResult    =     . beansOfTypeIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    type )  ;", "parentResult . forEach (  (    beanName ,    beanType )     -  >     {", "if    (  (  !  ( result . containsKey ( beanName )  )  )     &  &     (  !  ( hbf . containsLocalBean ( beanName )  )  )  )     {", "result . put ( beanName ,    beanType )  ;", "}", "}  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beansOfTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( lbf ,     \" ListableBeanFactory   must   not   be   null \"  )  ;", "Map < String ,    T >    result    =    new   LinkedHashMap <  >  (  4  )  ;", "result . putAll ( lbf . getBeansOfType ( type ,    includeNonSingletons ,    allowEagerInit )  )  ;", "if    ( lbf   instanceof   HierarchicalBeanFactory )     {", "HierarchicalBeanFactory   hbf    =     (  ( HierarchicalBeanFactory )     ( lbf )  )  ;", "if    (  ( hbf . getParentBeanFactory (  )  )    instanceof   ListableBeanFactory )     {", "Map < String ,    T >    parentResult    =     . beansOfTypeIncludingAncestors (  (  ( ListableBeanFactory )     ( hbf . getParentBeanFactory (  )  )  )  ,    type ,    includeNonSingletons ,    allowEagerInit )  ;", "parentResult . forEach (  (    beanName ,    beanType )     -  >     {", "if    (  (  !  ( result . containsKey ( beanName )  )  )     &  &     (  !  ( hbf . containsLocalBean ( beanName )  )  )  )     {", "result . put ( beanName ,    beanType )  ;", "}", "}  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["beansOfTypeIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return   BeanFactoryUtils . beanNamesIncludingAncestors ( lbf )  . length ;", "}", "METHOD_END"], "methodName": ["countBeansIncludingAncestors"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( name    !  =    null )     &  &     ( name . startsWith ( BeanFactory . FACTORY _ BEAN _ PREFIX )  )  ;", "}", "METHOD_END"], "methodName": ["isFactoryDereference"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( name    !  =    null )     &  &     ( name . contains ( BeanFactoryUtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )  ;", "}", "METHOD_END"], "methodName": ["isGeneratedBeanName"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parentResult . length )     =  =     0  )     {", "return   result ;", "}", "List < String >    merged    =    new   ArrayList <  >  (  (  ( result . length )     +     ( parentResult . length )  )  )  ;", "merged . addAll ( Arrays . asList ( result )  )  ;", "for    ( String   beanName    :    parentResult )     {", "if    (  (  !  ( merged . contains ( beanName )  )  )     &  &     (  !  ( hbf . containsLocalBean ( beanName )  )  )  )     {", "merged . add ( beanName )  ;", "}", "}", "return   String . toStringArray ( merged )  ;", "}", "METHOD_END"], "methodName": ["mergeNamesWithParent"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' name '    must   not   be   null \"  )  ;", "int   separatorIndex    =    name . indexOf (  . GENERATED _ BEAN _ NAME _ SEPARATOR )  ;", "return   separatorIndex    !  =     (  -  1  )     ?    name . substring (  0  ,    separatorIndex )     :    name ;", "}", "METHOD_END"], "methodName": ["originalBeanName"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( name ,     \"  ' name '    must   not   be   null \"  )  ;", "String   beanName    =    name ;", "while    ( beanName . startsWith (  . FACTORY _ BEAN _ PREFIX )  )     {", "beanName    =    beanName . substring (  . FACTORY _ BEAN _ PREFIX . length (  )  )  ;", "}", "return   beanName ;", "}", "METHOD_END"], "methodName": ["transformedBeanName"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "int   count    =    matchingBeans . size (  )  ;", "if    ( count    =  =     1  )     {", "return   matchingBeans . values (  )  . iterator (  )  . next (  )  ;", "} else", "if    ( count    >     1  )     {", "throw   new   NoUniqueBeanDefinitionException ( type ,    matchingBeans . keySet (  )  )  ;", "} else    {", "throw   new   NoSuchBeanDefinitionException ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["uniqueBean"], "fileName": "org.springframework.beans.factory.BeanFactoryUtils"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   grandParent    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( grandParent )  . loadBeanDefinitions (  . ROOT _ CONTEXT )  ;", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory ( grandParent )  ;", "new   XmlBeanDefinitionReader ( parent )  . loadBeanDefinitions (  . MIDDLE _ CONTEXT )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( child )  . loadBeanDefinitions (  . LEAF _ CONTEXT )  ;", "this . dependentBeansFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( this . dependentBeansFactory )  . loadBeanDefinitions (  . DEPENDENT _ BEANS _ CONTEXT )  ;", "dependentBeansFactory . preInstantiateSingletons (  )  ;", "this . listableBeanFactory    =    child ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    deps    =    this . dependentBeansFactory . getDependentBeans (  \" a \"  )  ;", "assertTrue ( ObjectUtils . isEmpty ( deps )  )  ;", "}", "METHOD_END"], "methodName": ["testADependencies"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    deps    =    this . dependentBeansFactory . getDependentBeans (  \" b \"  )  ;", "assertTrue ( Arrays . equals ( new   String [  ]  {     \" c \"     }  ,    deps )  )  ;", "}", "METHOD_END"], "methodName": ["testBDependencies"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    deps    =    this . dependentBeansFactory . getDependentBeans (  \" c \"  )  ;", "assertTrue ( Arrays . equals ( new   String [  ]  {     \" int \"  ,     \" long \"     }  ,    deps )  )  ;", "}", "METHOD_END"], "methodName": ["testCDependencies"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   test 3     =    this . listableBeanFactory . getBean (  \" test 3  \"  )  ;", "Object   test    =    this . listableBeanFactory . getBean (  \" test \"  )  ;", "TestBean   t 1     =    new   TestBean (  )  ;", "TestBean   t 2     =    new   TestBean (  )  ;", "DummyFactory   t 3     =    new   DummyFactory (  )  ;", "DummyFactory   t 4     =    new   DummyFactory (  )  ;", "t 4  . setSingleton ( false )  ;", "this . listableBeanFactory . registerSingleton (  \" t 1  \"  ,    t 1  )  ;", "this . listableBeanFactory . registerSingleton (  \" t 2  \"  ,    t 2  )  ;", "this . listableBeanFactory . registerSingleton (  \" t 3  \"  ,    t 3  )  ;", "this . listableBeanFactory . registerSingleton (  \" t 4  \"  ,    t 4  )  ;", "Map < String ,     ?  >    beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    true ,    false )  ;", "assertEquals (  6  ,    beans . size (  )  )  ;", "assertEquals ( test 3  ,    beans . get (  \" test 3  \"  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "assertEquals ( t 1  ,    beans . get (  \" t 1  \"  )  )  ;", "assertEquals ( t 2  ,    beans . get (  \" t 2  \"  )  )  ;", "assertEquals ( t 3  . getObject (  )  ,    beans . get (  \" t 3  \"  )  )  ;", "assertTrue (  (  ( beans . get (  \" t 4  \"  )  )    instanceof   TestBean )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    false ,    true )  ;", "Object   testFactory 1     =    this . listableBeanFactory . getBean (  \" testFactory 1  \"  )  ;", "assertEquals (  5  ,    beans . size (  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "assertEquals ( testFactory 1  ,    beans . get (  \" testFactory 1  \"  )  )  ;", "assertEquals ( t 1  ,    beans . get (  \" t 1  \"  )  )  ;", "assertEquals ( t 2  ,    beans . get (  \" t 2  \"  )  )  ;", "assertEquals ( t 3  . getObject (  )  ,    beans . get (  \" t 3  \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    true ,    true )  ;", "assertEquals (  8  ,    beans . size (  )  )  ;", "assertEquals ( test 3  ,    beans . get (  \" test 3  \"  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "assertEquals ( testFactory 1  ,    beans . get (  \" testFactory 1  \"  )  )  ;", "assertTrue (  (  ( beans . get (  \" testFactory 2  \"  )  )    instanceof   TestBean )  )  ;", "assertEquals ( t 1  ,    beans . get (  \" t 1  \"  )  )  ;", "assertEquals ( t 2  ,    beans . get (  \" t 2  \"  )  )  ;", "assertEquals ( t 3  . getObject (  )  ,    beans . get (  \" t 3  \"  )  )  ;", "assertTrue (  (  ( beans . get (  \" t 4  \"  )  )    instanceof   TestBean )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    DummyFactory . class ,    true ,    true )  ;", "assertEquals (  4  ,    beans . size (  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 1  \"  )  ,    beans . get (  \"  & testFactory 1  \"  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 2  \"  )  ,    beans . get (  \"  & testFactory 2  \"  )  )  ;", "assertEquals ( t 3  ,    beans . get (  \"  & t 3  \"  )  )  ;", "assertEquals ( t 4  ,    beans . get (  \"  & t 4  \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    FactoryBean . class ,    true ,    true )  ;", "assertEquals (  4  ,    beans . size (  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 1  \"  )  ,    beans . get (  \"  & testFactory 1  \"  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 2  \"  )  ,    beans . get (  \"  & testFactory 2  \"  )  )  ;", "assertEquals ( t 3  ,    beans . get (  \"  & t 3  \"  )  )  ;", "assertEquals ( t 4  ,    beans . get (  \"  & t 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFindsBeansOfTypeWithDefaultFactory"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticListableBeanFactory   lbf    =    new   StaticListableBeanFactory (  )  ;", "TestBean   t 1     =    new   TestBean (  )  ;", "TestBean   t 2     =    new   TestBean (  )  ;", "DummyFactory   t 3     =    new   DummyFactory (  )  ;", "DummyFactory   t 4     =    new   DummyFactory (  )  ;", "t 4  . setSingleton ( false )  ;", "lbf . addBean (  \" t 1  \"  ,    t 1  )  ;", "lbf . addBean (  \" t 2  \"  ,    t 2  )  ;", "lbf . addBean (  \" t 3  \"  ,    t 3  )  ;", "lbf . addBean (  \" t 4  \"  ,    t 4  )  ;", "Map < String ,     ?  >    beans    =     . beansOfTypeIncludingAncestors ( lbf ,    ITestBean . class ,    true ,    true )  ;", "assertEquals (  4  ,    beans . size (  )  )  ;", "assertEquals ( t 1  ,    beans . get (  \" t 1  \"  )  )  ;", "assertEquals ( t 2  ,    beans . get (  \" t 2  \"  )  )  ;", "assertEquals ( t 3  . getObject (  )  ,    beans . get (  \" t 3  \"  )  )  ;", "assertTrue (  (  ( beans . get (  \" t 4  \"  )  )    instanceof   TestBean )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( lbf ,    DummyFactory . class ,    true ,    true )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( t 3  ,    beans . get (  \"  & t 3  \"  )  )  ;", "assertEquals ( t 4  ,    beans . get (  \"  & t 4  \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( lbf ,    FactoryBean . class ,    true ,    true )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( t 3  ,    beans . get (  \"  & t 3  \"  )  )  ;", "assertEquals ( t 4  ,    beans . get (  \"  & t 4  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFindsBeansOfTypeWithStaticFactory"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "AnnotatedBean   annotatedBean    =    new   AnnotatedBean (  )  ;", "this . listableBeanFactory . registerSingleton (  \" anotherAnnotatedBean \"  ,    annotatedBean )  ;", "List < String >    names    =    Arrays . asList (  . beanNamesForAnnotationIncludingAncestors ( this . listableBeanFactory ,    TestAnnotation . class )  )  ;", "assertEquals (  2  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" annotatedBean \"  )  )  ;", "assertTrue ( names . contains (  \" anotherAnnotatedBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanNamesForAnnotationWithOverride"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Arrays . asList ( BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class )  )  ;", "assertEquals (  4  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" test \"  )  )  ;", "assertTrue ( names . contains (  \" test 3  \"  )  )  ;", "assertTrue ( names . contains (  \" testFactory 1  \"  )  )  ;", "assertTrue ( names . contains (  \" testFactory 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanNamesForTypeWithOverride"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticListableBeanFactory   lbf    =    new   StaticListableBeanFactory (  )  ;", "lbf . addBean (  \" t 1  \"  ,    new   TestBean (  )  )  ;", "lbf . addBean (  \" t 2  \"  ,    new   TestBean (  )  )  ;", "assertTrue (  (  (  . countBeansIncludingAncestors ( lbf )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalCountBeansWithNonHierarchicalFactory"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  ( this . listableBeanFactory . getBeanDefinitionCount (  )  )     =  =     1  )  )  ;", "assertTrue (  (  \" Should   count    8    beans ,    not    \"     +     (  . countBeansIncludingAncestors ( this . listableBeanFactory )  )  )  ,     (  (  . countBeansIncludingAncestors ( this . listableBeanFactory )  )     =  =     8  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalCountBeansWithOverride"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Arrays . asList ( BeanFactoryUtils . beanNamesForAnnotationIncludingAncestors ( this . listableBeanFactory ,    TestAnnotation . class )  )  ;", "assertEquals (  1  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" annotatedBean \"  )  )  ;", "assertTrue (  (  ( listableBeanFactory . getBeanNamesForAnnotation ( TestAnnotation . class )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalNamesForAnnotationWithMatchOnlyInRoot"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Arrays . asList ( BeanFactoryUtils . beanNamesForAnnotationIncludingAncestors ( this . listableBeanFactory ,    Override . class )  )  ;", "assertEquals (  0  ,    names . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalNamesForAnnotationWithNoMatch"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Arrays . asList ( BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . listableBeanFactory ,    IndexedTestBean . class )  )  ;", "assertEquals (  1  ,    names . size (  )  )  ;", "assertTrue ( names . contains (  \" indexedBean \"  )  )  ;", "assertTrue (  (  ( listableBeanFactory . getBeanNamesForType ( IndexedTestBean . class )  . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalNamesWithMatchOnlyInRoot"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Arrays . asList ( BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this . listableBeanFactory ,    NoOp . class )  )  ;", "assertEquals (  0  ,    names . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalNamesWithNoMatch"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "Object   test 3     =    this . listableBeanFactory . getBean (  \" test 3  \"  )  ;", "Object   test    =    this . listableBeanFactory . getBean (  \" test \"  )  ;", "Map < String ,     ?  >    beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    true ,    false )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( test 3  ,    beans . get (  \" test 3  \"  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    false ,    false )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    false ,    true )  ;", "Object   testFactory 1     =    this . listableBeanFactory . getBean (  \" testFactory 1  \"  )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "assertEquals ( testFactory 1  ,    beans . get (  \" testFactory 1  \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    ITestBean . class ,    true ,    true )  ;", "assertEquals (  4  ,    beans . size (  )  )  ;", "assertEquals ( test 3  ,    beans . get (  \" test 3  \"  )  )  ;", "assertEquals ( test ,    beans . get (  \" test \"  )  )  ;", "assertEquals ( testFactory 1  ,    beans . get (  \" testFactory 1  \"  )  )  ;", "assertTrue (  (  ( beans . get (  \" testFactory 2  \"  )  )    instanceof   TestBean )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    DummyFactory . class ,    true ,    true )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 1  \"  )  ,    beans . get (  \"  & testFactory 1  \"  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 2  \"  )  ,    beans . get (  \"  & testFactory 2  \"  )  )  ;", "beans    =     . beansOfTypeIncludingAncestors ( this . listableBeanFactory ,    FactoryBean . class ,    true ,    true )  ;", "assertEquals (  2  ,    beans . size (  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 1  \"  )  ,    beans . get (  \"  & testFactory 1  \"  )  )  ;", "assertEquals ( this . listableBeanFactory . getBean (  \"  & testFactory 2  \"  )  ,    beans . get (  \"  & testFactory 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testHierarchicalResolutionWithOverride"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    deps    =    this . dependentBeansFactory . getDependentBeans (  \" int \"  )  ;", "assertTrue ( Arrays . equals ( new   String [  ]  {     \" buffer \"     }  ,    deps )  )  ;", "}", "METHOD_END"], "methodName": ["testIntDependencies"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "StaticListableBeanFactory   lbf    =    new   StaticListableBeanFactory (  )  ;", "lbf . addBean (  \" foo \"  ,    new   Object (  )  )  ;", "Map < String ,     ?  >    beans    =     . beansOfTypeIncludingAncestors ( lbf ,    ITestBean . class ,    true ,    false )  ;", "assertTrue ( beans . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNoBeansOfType"], "fileName": "org.springframework.beans.factory.BeanFactoryUtilsTests"}, {"methodBody": ["METHOD_START", "{", "return   this . actualType ;", "}", "METHOD_END"], "methodName": ["getActualType"], "fileName": "org.springframework.beans.factory.BeanNotOfRequiredTypeException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.BeanNotOfRequiredTypeException"}, {"methodBody": ["METHOD_START", "{", "return   this . requiredType ;", "}", "METHOD_END"], "methodName": ["getRequiredType"], "fileName": "org.springframework.beans.factory.BeanNotOfRequiredTypeException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanClassName ;", "}", "METHOD_END"], "methodName": ["getBeanClassName"], "fileName": "org.springframework.beans.factory.CannotLoadBeanClassException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.CannotLoadBeanClassException"}, {"methodBody": ["METHOD_START", "{", "return   this . resourceDescription ;", "}", "METHOD_END"], "methodName": ["getResourceDescription"], "fileName": "org.springframework.beans.factory.CannotLoadBeanClassException"}, {"methodBody": ["METHOD_START", "{", "ConcurrentBeanFactoryTests . ConcurrentBean   b 1     =     (  ( ConcurrentBeanFactoryTests . ConcurrentBean )     ( factory . getBean (  \" bean 1  \"  )  )  )  ;", "ConcurrentBeanFactoryTests . ConcurrentBean   b 2     =     (  ( ConcurrentBeanFactoryTests . ConcurrentBean )     ( factory . getBean (  \" bean 2  \"  )  )  )  ;", "assertEquals ( ConcurrentBeanFactoryTests . DATE _  1  ,    b 1  . getDate (  )  )  ;", "assertEquals ( ConcurrentBeanFactoryTests . DATE _  2  ,    b 2  . getDate (  )  )  ;", "}", "METHOD_END"], "methodName": ["performTest"], "fileName": "org.springframework.beans.factory.ConcurrentBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . CONTEXT )  ;", "factory . addPropertyEditorRegistrar ( new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "registry . registerCustomEditor ( Date . class ,    new   CustomDateEditor (  (  ( DateFormat )     (  . DATE _ FORMAT . clone (  )  )  )  ,    false )  )  ;", "}", "}  )  ;", "this . factory    =    factory ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.ConcurrentBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", ". TestRun   run    =    new    . TestRun (  )  ;", "run . setDaemon ( true )  ;", "set . add ( run )  ;", "}", "for    ( Iterator <  . TestRun >    it    =    new   HashSet <  >  ( set )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", ". TestRun   run    =    it . next (  )  ;", "run . start (  )  ;", "}", ". logger . info (  (  (  \" Thread   creation   over ,     \"     +     ( set . size (  )  )  )     +     \"    still   active .  \"  )  )  ;", "synchronized ( set )     {", "while    (  (  !  ( set . isEmpty (  )  )  )     &  &     (  ( ex )     =  =    null )  )     {", "try    {", "set . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", ". logger . info ( e . toString (  )  )  ;", "}", ". logger . info (  (  ( set . size (  )  )     +     \"    threads   still   active .  \"  )  )  ;", "}", "}", "if    (  ( ex )     !  =    null )     {", "fail ( ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testConcurrent"], "fileName": "org.springframework.beans.factory.ConcurrentBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "perform (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleThread"], "fileName": "org.springframework.beans.factory.ConcurrentBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( DefaultListableBeanFactoryTests . ConstructorDependency . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( String . valueOf ( age )  )  ;", "return   bd ;", "}", "METHOD_END"], "methodName": ["createConstructorDependencyBeanDefinition"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "int   ageSetByPropertyValue    =     2  7  ;", "bd . getPropertyValues (  )  . addPropertyValue ( new   PropertyValue (  \" age \"  ,    new   Integer ( ageSetByPropertyValue )  )  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "final   String   nameSetOnField    =     \" nameSetOnField \"  ;", "lbf . addBeanPostProcessor ( new   InstantiationAwareBeanPostProcessorAdapter (  )     {", "@ Override", "public   boolean   postProcessAfterInstantiation ( Object   bean ,    String   beanName )    throws   BeansException    {", "TestBean   tb    =     (  ( TestBean )     ( bean )  )  ;", "try    {", "Field   f    =    TestBean . class . getDeclaredField (  \" name \"  )  ;", "f . setAccessible ( true )  ;", "f . set ( tb ,    nameSetOnField )  ;", "return    ! skipPropertyPopulation ;", "}    catch    ( Exception   ex )     {", "fail (  (  \" Unexpected   exception :     \"     +    ex )  )  ;", "throw   new   IllegalStateException (  )  ;", "}", "}", "}  )  ;", "lbf . preInstantiateSingletons (  )  ;", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" Name   was   set   on   field   by   IAPP \"  ,    nameSetOnField ,    tb . getName (  )  )  ;", "if    (  ! skipPropertyPopulation )     {", "assertEquals (  \" Property   value   still   set \"  ,    ageSetByPropertyValue ,    tb . getAge (  )  )  ;", "} else    {", "assertEquals (  \" Property   value   was   NOT   set   and   still   has   default   value \"  ,     0  ,    tb . getAge (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doTestFieldSettingWithInstantiationAwarePostProcessor"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( Optional . class )  ;", "bd . setFactoryMethodName (  \" empty \"  )  ;", "bf . registerBeanDefinition (  \" optionalBean \"  ,    bd )  ;", "assertSame ( Optional . empty (  )  ,    bf . getBean ( Optional . class )  )  ;", "}", "METHOD_END"], "methodName": ["emptyJavaUtilOptionalBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   expectedNameFromProperties    =     \" tony \"  ;", "String   expectedNameFromArgs    =     \" gordon \"  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   instanceFactoryDefinition    =    new   RootBeanDefinition (  . BeanWithFactoryMethod . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,    expectedNameFromProperties )  ;", "instanceFactoryDefinition . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" factoryBeanInstance \"  ,    instanceFactoryDefinition )  ;", "RootBeanDefinition   factoryMethodDefinitionWithProperties    =    new   RootBeanDefinition (  )  ;", "factoryMethodDefinitionWithProperties . setFactoryBeanName (  \" factoryBeanInstance \"  )  ;", "factoryMethodDefinitionWithProperties . setFactoryMethodName (  \" create \"  )  ;", "if    (  ! singleton )     {", "factoryMethodDefinitionWithProperties . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "}", "lbf . registerBeanDefinition (  \" fmWithProperties \"  ,    factoryMethodDefinitionWithProperties )  ;", "RootBeanDefinition   factoryMethodDefinitionGeneric    =    new   RootBeanDefinition (  )  ;", "factoryMethodDefinitionGeneric . setFactoryBeanName (  \" factoryBeanInstance \"  )  ;", "factoryMethodDefinitionGeneric . setFactoryMethodName (  \" createGeneric \"  )  ;", "if    (  ! singleton )     {", "factoryMethodDefinitionGeneric . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "}", "lbf . registerBeanDefinition (  \" fmGeneric \"  ,    factoryMethodDefinitionGeneric )  ;", "RootBeanDefinition   factoryMethodDefinitionWithArgs    =    new   RootBeanDefinition (  )  ;", "factoryMethodDefinitionWithArgs . setFactoryBeanName (  \" factoryBeanInstance \"  )  ;", "factoryMethodDefinitionWithArgs . setFactoryMethodName (  \" createWithArgs \"  )  ;", "ConstructorArgumentValues   cvals    =    new   ConstructorArgumentValues (  )  ;", "cvals . addGenericArgumentValue ( expectedNameFromArgs )  ;", "factoryMethodDefinitionWithArgs . setConstructorArgumentValues ( cvals )  ;", "if    (  ! singleton )     {", "factoryMethodDefinitionWithArgs . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "}", "lbf . registerBeanDefinition (  \" fmWithArgs \"  ,    factoryMethodDefinitionWithArgs )  ;", "assertEquals (  4  ,    lbf . getBeanDefinitionCount (  )  )  ;", "List < String >    tbNames    =    Arrays . asList ( lbf . getBeanNamesForType ( TestBean . class )  )  ;", "assertTrue ( tbNames . contains (  \" fmWithProperties \"  )  )  ;", "assertTrue ( tbNames . contains (  \" fmWithArgs \"  )  )  ;", "assertEquals (  2  ,    tbNames . size (  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" fmWithProperties \"  )  )  )  ;", "TestBean   second    =     (  ( TestBean )     ( lbf . getBean (  \" fmWithProperties \"  )  )  )  ;", "if    ( singleton )     {", "assertSame ( tb ,    second )  ;", "} else    {", "assertNotSame ( tb ,    second )  ;", "}", "assertEquals ( expectedNameFromProperties ,    tb . getName (  )  )  ;", "tb    =     (  ( TestBean )     ( lbf . getBean (  \" fmGeneric \"  )  )  )  ;", "second    =     (  ( TestBean )     ( lbf . getBean (  \" fmGeneric \"  )  )  )  ;", "if    ( singleton )     {", "assertSame ( tb ,    second )  ;", "} else    {", "assertNotSame ( tb ,    second )  ;", "}", "assertEquals ( expectedNameFromProperties ,    tb . getName (  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( lbf . getBean (  \" fmWithArgs \"  )  )  )  ;", "second    =     (  ( TestBean )     ( lbf . getBean (  \" fmWithArgs \"  )  )  )  ;", "if    ( singleton )     {", "assertSame ( tb 2  ,    second )  ;", "} else    {", "assertNotSame ( tb 2  ,    second )  ;", "}", "assertEquals ( expectedNameFromArgs ,    tb 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["findTypeOfPrototypeFactoryMethodOnBeanInstance"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( Optional . class )  ;", "bd . setFactoryMethodName (  \" of \"  )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" CONTENT \"  )  ;", "bf . registerBeanDefinition (  \" optionalBean \"  ,    bd )  ;", "assertEquals ( Optional . of (  \" CONTENT \"  )  ,    bf . getBean ( Optional . class )  )  ;", "}", "METHOD_END"], "methodName": ["populatedJavaUtilOptionalBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "StringValueResolver   r 1     =    mock ( StringValueResolver . class )  ;", "StringValueResolver   r 2     =    mock ( StringValueResolver . class )  ;", "StringValueResolver   r 3     =    mock ( StringValueResolver . class )  ;", "bf . addEmbeddedValueResolver ( r 1  )  ;", "bf . addEmbeddedValueResolver ( r 2  )  ;", "bf . addEmbeddedValueResolver ( r 3  )  ;", "given ( r 1  . resolveStringValue (  \" A \"  )  )  . willReturn (  \" B \"  )  ;", "given ( r 2  . resolveStringValue (  \" B \"  )  )  . willReturn ( null )  ;", "given ( r 3  . resolveStringValue ( isNull (  )  )  )  . willThrow ( new   IllegalArgumentException (  )  )  ;", "bf . resolveEmbeddedValue (  \" A \"  )  ;", "verify ( r 1  )  . resolveStringValue (  \" A \"  )  ;", "verify ( r 2  )  . resolveStringValue (  \" B \"  )  ;", "verify ( r 3  ,    never (  )  )  . resolveStringValue ( isNull (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveEmbeddedValue"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "lbf . registerAlias (  \" test \"  ,     \" testAlias \"  )  ;", "lbf . registerAlias (  \" testAlias \"  ,     \" testAlias 2  \"  )  ;", "lbf . registerAlias (  \" testAlias 2  \"  ,     \" testAlias 3  \"  )  ;", "Object   bean    =    lbf . getBean (  \" test \"  )  ;", "assertSame ( bean ,    lbf . getBean (  \" testAlias \"  )  )  ;", "assertSame ( bean ,    lbf . getBean (  \" testAlias 2  \"  )  )  ;", "assertSame ( bean ,    lbf . getBean (  \" testAlias 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAliasChaining"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerAlias (  \" test \"  ,     \" test 2  \"  )  ;", "lbf . registerAlias (  \" test 2  \"  ,     \" test 3  \"  )  ;", "try    {", "lbf . registerAlias (  \" test 3  \"  ,     \" test 2  \"  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "try    {", "lbf . registerAlias (  \" test 3  \"  ,     \" test \"  )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "lbf . registerAlias (  \" test \"  ,     \" test 3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAliasCircle"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  9  9  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "lbf . applyBeanPropertyValues ( tb ,     \" test \"  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyBeanPropertyValues"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  9  9  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "lbf . applyBeanPropertyValues ( tb ,     \" test \"  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "assertNull ( tb . getBeanFactory (  )  )  ;", "assertNull ( tb . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyBeanPropertyValuesWithIncompleteDefinition"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" integer 1  \"  ,    new   Integer (  4  )  )  ;", "bf . registerSingleton (  \" integer 2  \"  ,    new   Integer (  5  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertEquals ( new   Integer (  4  )  ,    ab . getIntegerArray (  )  [  0  ]  )  ;", "assertEquals ( new   Integer (  5  )  ,    ab . getIntegerArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testArrayConstructorWithAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertNull ( ab . getIntegerArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayConstructorWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    ab . getResourceArray (  )  [  0  ]  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    ab . getResourceArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testArrayPropertyWithAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertNull ( ab . getResourceArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayPropertyWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    true )  )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( lbf . getBean (  \" spouse \"  )  )  )  ;", "assertEquals ( spouse ,    bean . getSpouse (  )  )  ;", "assertTrue (  (  ( BeanFactoryUtils . beanOfType ( lbf ,    TestBean . class )  )     =  =    spouse )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByName"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spous \"  ,    bd )  ;", "try    {", "lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireBeanByNameWithDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spous \"  ,    bd )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    false )  )  )  ;", "assertNull ( bean . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByNameWithNoDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  )  )  ;", "TestBean   test    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals ( test ,    bean . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByType"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  )  )  ;", "assertThat ( bean . getSpouse (  )  ,    equalTo ( lbf . getBean (  \" spouse \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypePrimaryTakesPrecedenceOverPriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "try    {", "lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "try    {", "lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertNotNull (  \" Exception   should   have   cause \"  ,    ex . getCause (  )  )  ;", "assertEquals (  \" Wrong   cause   type \"  ,    NoUniqueBeanDefinitionException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  5  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithIdenticalPriorityCandidates"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    false )  )  )  ;", "assertNull ( bean . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithNoDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "try    {", "lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" test \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" spouse \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithTwoMatches"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPrimary ( true )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  )  )  ;", "assertThat ( bean . getSpouse (  )  ,    equalTo ( lbf . getBean (  \" test \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithTwoMatchesAndOnePrimary"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . LowPriorityTestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "DependenciesBean   bean    =     (  ( DependenciesBean )     ( lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  )  )  ;", "assertThat ( bean . getSpouse (  )  ,    equalTo ( lbf . getBean (  \" test \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithTwoMatchesAndPriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPrimary ( true )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd 2  )  ;", "try    {", "lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertNotNull (  \" Exception   should   have   cause \"  ,    ex . getCause (  )  )  ;", "assertEquals (  \" Wrong   cause   type \"  ,    NoUniqueBeanDefinitionException . class ,    ex . getCause (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowireBeanByTypeWithTwoPrimaryCandidates"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . LazyInitFactory . class )  ;", "lbf . registerBeanDefinition (  \" factoryBean \"  ,    bd )  ;", ". LazyInitFactory   factoryBean    =     (  (  . LazyInitFactory )     ( lbf . getBean (  \"  & factoryBean \"  )  )  )  ;", "assertNotNull (  \" The   FactoryBean   should   have   been   registered .  \"  ,    factoryBean )  ;", "lbf . autowire (  . FactoryBeanDependentBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanWithFactoryBeanByName"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . LazyInitFactory . class )  ;", "lbf . registerBeanDefinition (  \" factoryBean \"  ,    bd )  ;", ". LazyInitFactory   factoryBean    =     (  (  . LazyInitFactory )     ( lbf . getBean (  \"  & factoryBean \"  )  )  )  ;", "assertNotNull (  \" The   FactoryBean   should   have   been   registered .  \"  ,    factoryBean )  ;", ". FactoryBeanDependentBean   bean    =     (  (  . FactoryBeanDependentBean )     ( lbf . autowire (  . FactoryBeanDependentBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  )  )  ;", "assertEquals (  \" The   FactoryBeanDependentBean   should   have   been   autowired    ' by   type '    with   the   LazyInitFactory .  \"  ,    factoryBean ,    bean . getFactoryBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireBeanWithFactoryBeanByType"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd )  ;", "ConstructorDependenciesBean   bean    =     (  ( ConstructorDependenciesBean )     ( lbf . autowire ( ConstructorDependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ CONSTRUCTOR ,    true )  )  )  ;", "Object   spouse    =    lbf . getBean (  \" spouse \"  )  ;", "assertTrue (  (  ( bean . getSpouse 1  (  )  )     =  =    spouse )  )  ;", "assertTrue (  (  ( BeanFactoryUtils . beanOfType ( lbf ,    TestBean . class )  )     =  =    spouse )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireConstructor"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    true )  ;", "TestBean   spouse    =     (  ( TestBean )     ( lbf . getBean (  \" spouse \"  )  )  )  ;", "assertEquals ( existingBean . getSpouse (  )  ,    spouse )  ;", "assertSame ( spouse ,    BeanFactoryUtils . beanOfType ( lbf ,    TestBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByName"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spous \"  ,    bd )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "try    {", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByNameWithDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spous \"  ,    bd )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ NAME ,    false )  ;", "assertNull ( existingBean . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByNameWithNoDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "TestBean   test    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals ( existingBean . getSpouse (  )  ,    test )  ;", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByType"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "try    {", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByTypeWithDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "DependenciesBean   existingBean    =    new   DependenciesBean (  )  ;", "lbf . autowireBeanProperties ( existingBean ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    false )  ;", "assertNull ( existingBean . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireExistingBeanByTypeWithNoDependencyCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" rod \"  ,    bd )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "Object   registered    =    lbf . autowire (  . NoDependencies . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    false )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "assertTrue (  ( registered   instanceof    . NoDependencies )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireWithNoDependencies"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" rod \"  ,    bd )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "Object   registered    =    lbf . autowire (  . ConstructorDependency . class ,    AutowireCapableBeanFactory . AUTOWIRE _ CONSTRUCTOR ,    false )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", ". ConstructorDependency   kerry    =     (  (  . ConstructorDependency )     ( registered )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( lbf . getBean (  \" rod \"  )  )  )  ;", "assertSame ( rod ,    kerry . spouse )  ;", "}", "METHOD_END"], "methodName": ["testAutowireWithSatisfiedConstructorDependency"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Rod \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" rod \"  ,    bd )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "Object   registered    =    lbf . autowire ( DependenciesBean . class ,    AutowireCapableBeanFactory . AUTOWIRE _ BY _ TYPE ,    true )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "DependenciesBean   kerry    =     (  ( DependenciesBean )     ( registered )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( lbf . getBean (  \" rod \"  )  )  )  ;", "assertSame ( rod ,    kerry . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireWithSatisfiedJavaBeanDependency"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" rod \"  ,    bd )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" rod 2  \"  ,    bd 2  )  ;", "try    {", "lbf . autowire (  . ConstructorDependency . class ,    AutowireCapableBeanFactory . AUTOWIRE _ CONSTRUCTOR ,    false )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" rod \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \" rod 2  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAutowireWithTwoMatchesForConstructorDependency"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,     \" Rod \"  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" rod \"  ,    bd )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "try    {", "lbf . autowire (  . UnsatisfiedConstructorDependency . class ,    AutowireCapableBeanFactory . AUTOWIRE _ CONSTRUCTOR ,    true )  ;", "fail (  \" Should   have   unsatisfied   constructor   dependency   on   SideEffectBean \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testAutowireWithUnsatisfiedConstructorDependency"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyFactoryBean . class )  ;", "bd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( String . class )  ;", "bd 2  . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "lbf . registerBeanDefinition (  \" string \"  ,    bd 2  )  ;", "lbf . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testAvoidCircularReferenceThroughAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "lbf . registerAlias (  \" otherTest \"  ,     \" test 2  \"  )  ;", "lbf . registerAlias (  \" test \"  ,     \" test 2  \"  )  ;", "assertTrue (  (  ( lbf . getBean (  \" test \"  )  )    instanceof   NestedTestBean )  )  ;", "assertTrue (  (  ( lbf . getBean (  \" test 2  \"  )  )    instanceof   NestedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionOverriding"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setAllowBeanDefinitionOverriding ( false )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "try    {", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertEquals (  \" test \"  ,    ex . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBeanDefinitionOverridingNotAllowed"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "lbf . registerAlias (  \" test \"  ,     \" testAlias \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "lbf . registerAlias (  \" test \"  ,     \" testAlias \"  )  ;", "assertTrue (  (  ( lbf . getBean (  \" test \"  )  )    instanceof   NestedTestBean )  )  ;", "assertTrue (  (  ( lbf . getBean (  \" testAlias \"  )  )    instanceof   NestedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionOverridingWithAlias"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setAllowBeanDefinitionOverriding ( false )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "lbf . registerAlias (  \" test \"  ,     \" test 2  \"  )  ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . removeBeanDefinition (  \" test \"  )  ;", "lbf . removeAlias (  \" test 2  \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( NestedTestBean . class )  )  ;", "lbf . registerAlias (  \" test \"  ,     \" test 2  \"  )  ;", "assertTrue (  (  ( lbf . getBean (  \" test \"  )  )    instanceof   NestedTestBean )  )  ;", "assertTrue (  (  ( lbf . getBean (  \" test 2  \"  )  )    instanceof   NestedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitionRemoval"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( AbstractBeanFactory . class )  )  ;", "try    {", "lbf . getBean (  \" test \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertEquals (  \" test \"  ,    ex . getBeanName (  )  )  ;", "assertTrue ( ex . getMessage (  )  . toLowerCase (  )  . contains (  \" abstract \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBeanDefinitionWithAbstractClass"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition ( ITestBean . class )  )  ;", "try    {", "lbf . getBean (  \" test \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertEquals (  \" test \"  ,    ex . getBeanName (  )  )  ;", "assertTrue ( ex . getMessage (  )  . toLowerCase (  )  . contains (  \" interface \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBeanDefinitionWithInterface"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . BeanWithCloseable . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   beanName )     {", "return   new   TestBean (  )  ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   beanName )     {", "return   bean ;", "}", "}  )  ;", ". BeanWithDisposableBean . closed    =    false ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . destroySingletons (  )  ;", "assertTrue (  \" Destroy   method   invoked \"  ,     . BeanWithCloseable . closed )  ;", "}", "METHOD_END"], "methodName": ["testBeanPostProcessorWithWrappedObjectAndCloseable"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . BeanWithDestroyMethod . class )  ;", "bd . setDestroyMethodName (  \" close \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   beanName )     {", "return   new   TestBean (  )  ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   beanName )     {", "return   bean ;", "}", "}  )  ;", ". BeanWithDestroyMethod . closeCount    =     0  ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . destroySingletons (  )  ;", "assertEquals (  \" Destroy   methods   invoked \"  ,     1  ,     . BeanWithDestroyMethod . closeCount )  ;", "}", "METHOD_END"], "methodName": ["testBeanPostProcessorWithWrappedObjectAndDestroyMethod"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . BeanWithDisposableBean . class )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   beanName )     {", "return   new   TestBean (  )  ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   beanName )     {", "return   bean ;", "}", "}  )  ;", ". BeanWithDisposableBean . closed    =    false ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . destroySingletons (  )  ;", "assertTrue (  \" Destroy   method   invoked \"  ,     . BeanWithDisposableBean . closed )  ;", "}", "METHOD_END"], "methodName": ["testBeanPostProcessorWithWrappedObjectAndDisposableBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" r .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" r . name \"  ,     \" rod \"  )  ;", "p . setProperty (  \" k .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" k . name \"  ,     \" kerry \"  )  ;", "p . setProperty (  \" k . spouse \"  ,     \"  * r \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "TestBean   k    =     (  ( TestBean )     ( lbf . getBean (  \" k \"  )  )  )  ;", "TestBean   r    =     (  ( TestBean )     ( lbf . getBean (  \" r \"  )  )  )  ;", "assertTrue (  (  ( k . getSpouse (  )  )     =  =    r )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanReferenceWithNewSyntax"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "bf . registerBeanDefinition (  (  \" a \"     +    i )  ,    new   RootBeanDefinition (  . A . class )  )  ;", "}", "bf . registerBeanDefinition (  \" b \"  ,    new   RootBeanDefinition (  . B . class )  )  ;", "bf . freezeConfiguration (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  ;    i +  +  )     {", "bf . getBean (  . B . class )  ;", "}", "}", "METHOD_END"], "methodName": ["testByTypeLookupIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \"  * name \"  ;", "lbf    =    new    (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" r .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" r . name \"  ,     (  \"  *  \"     +    name )  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "TestBean   r    =     (  ( TestBean )     ( lbf . getBean (  \" r \"  )  )  )  ;", "assertTrue ( r . getName (  )  . equals ( name )  )  ;", "}", "METHOD_END"], "methodName": ["testCanEscapeBeanReferenceSyntax"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   String   EXPECTED _ NAME    =     \" Juergen \"  ;", "final   int   EXPECTED _ AGE    =     4  1  ;", "RootBeanDefinition   parentDefinition    =    new   RootBeanDefinition ( TestBean . class )  ;", "parentDefinition . setAbstract ( true )  ;", "parentDefinition . getPropertyValues (  )  . add (  \" name \"  ,    EXPECTED _ NAME )  ;", "parentDefinition . getPropertyValues (  )  . add (  \" age \"  ,    EXPECTED _ AGE )  ;", "ChildBeanDefinition   childDefinition    =    new   ChildBeanDefinition (  \" alias \"  )  ;", "factory    =    new    (  )  ;", "factory . registerBeanDefinition (  \" parent \"  ,    parentDefinition )  ;", "factory . registerBeanDefinition (  \" child \"  ,    childDefinition )  ;", "factory . registerAlias (  \" parent \"  ,     \" alias \"  )  ;", "TestBean   child    =     (  ( TestBean )     ( factory . getBean (  \" child \"  )  )  )  ;", "assertEquals ( EXPECTED _ NAME ,    child . getName (  )  )  ;", "assertEquals ( EXPECTED _ AGE ,    child . getAge (  )  )  ;", "assertEquals (  \" Use   cached   merged   bean   definition \"  ,    factory . getMergedBeanDefinition (  \" child \"  )  ,    factory . getMergedBeanDefinition (  \" child \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanReferenceParentBeanFromChildViaAlias"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyBean . class )  ;", "bd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "try    {", "lbf . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCircularReferenceThroughAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyFactoryBean . class )  ;", "bd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "try    {", "lbf . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCircularReferenceThroughFactoryBeanAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyFactoryBean . class )  ;", "bd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "try    {", "lbf . getBeansOfType ( String . class )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testCircularReferenceThroughFactoryBeanTypeCheck"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  9  9  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "assertEquals (  0  ,    tb . getAge (  )  )  ;", "lbf . configureBean ( tb ,     \" test \"  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "assertSame ( lbf ,    tb . getBeanFactory (  )  )  ;", "assertNull ( tb . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigureBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    bd )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  9  9  \"  )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ NAME )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    tbd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "lbf . configureBean ( tb ,     \" test \"  )  ;", "assertSame ( lbf ,    tb . getBeanFactory (  )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( lbf . getBean (  \" spouse \"  )  )  )  ;", "assertEquals ( spouse ,    tb . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConfigureBeanWithAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyWithClassResolution . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" String \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "lbf . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorDependencyWithClassResolution"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorDependencyWithClassResolution . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" Strin \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "try    {", "lbf . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   expected )     {", "assertTrue ( expected . toString (  )  . contains (  \" Strin \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testConstructorDependencyWithUnresolvableClass"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" abs \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . setAbstract ( true )  . getBeanDefinition (  )  )  ;", "assertThat ( bf . containsBean (  \" abs \"  )  ,    equalTo ( true )  )  ;", "assertThat ( bf . containsBean (  \" bogus \"  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testContainsBeanReturnsTrueEvenForAbstractBeanDefinition"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "TestBean   tb    =    lbf . createBean ( TestBean . class )  ;", "assertSame ( lbf ,    tb . getBeanFactory (  )  )  ;", "lbf . destroyBean ( tb )  ;", "}", "METHOD_END"], "methodName": ["testCreateBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "DerivedTestBean   tb    =    lbf . createBean ( DerivedTestBean . class )  ;", "assertSame ( lbf ,    tb . getBeanFactory (  )  )  ;", "lbf . destroyBean ( tb )  ;", "assertTrue ( tb . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateBeanWithDisposableBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "GenericConversionService   conversionService    =    new   DefaultConversionService (  )  ;", "conversionService . addConverter ( new   Converter < String ,    Float >  (  )     {", "@ Override", "public   Float   convert ( String   source )     {", "try    {", "NumberFormat   nf    =    NumberFormat . getInstance ( Locale . GERMAN )  ;", "return   nf . parse ( source )  . floatValue (  )  ;", "}    catch    ( ParseException   ex )     {", "throw   new   IllegalArgumentException ( ex )  ;", "}", "}", "}  )  ;", "lbf . setConversionService ( conversionService )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  1  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "TestBean   testBean    =     (  ( TestBean )     ( lbf . getBean (  \" testBean \"  )  )  )  ;", "assertTrue (  (  ( testBean . getMyFloat (  )  . floatValue (  )  )     =  =     1  .  1 F )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomConverter"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . addPropertyEditorRegistrar ( new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "NumberFormat   nf    =    NumberFormat . getInstance ( Locale . GERMAN )  ;", "registry . registerCustomEditor ( Float . class ,    new   CustomNumberEditor ( Float . class ,    nf ,    true )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  1  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "TestBean   testBean    =     (  ( TestBean )     ( lbf . getBean (  \" testBean \"  )  )  )  ;", "assertTrue (  (  ( testBean . getMyFloat (  )  . floatValue (  )  )     =  =     1  .  1 F )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditor"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . addPropertyEditorRegistrar ( new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "NumberFormat   nf    =    NumberFormat . getInstance ( Locale . GERMAN )  ;", "registry . registerCustomEditor ( Float . class ,    new   CustomNumberEditor ( Float . class ,    nf ,    true )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,    new   RuntimeBeanReference (  \" myFloat \"  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "lbf . registerSingleton (  \" myFloat \"  ,     \"  1  ,  1  \"  )  ;", "TestBean   testBean    =     (  ( TestBean )     ( lbf . getBean (  \" testBean \"  )  )  )  ;", "assertTrue (  (  ( testBean . getMyFloat (  )  . floatValue (  )  )     =  =     1  .  1 F )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorWithBeanReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "NumberFormat   nf    =    NumberFormat . getInstance ( Locale . GERMAN )  ;", "lbf . setTypeConverter ( new    . CustomTypeConverter ( nf )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,     \"  1  ,  1  \"  )  ;", "ConstructorArgumentValues   cav    =    new   ConstructorArgumentValues (  )  ;", "cav . addIndexedArgumentValue (  0  ,     \" myName \"  )  ;", "cav . addIndexedArgumentValue (  1  ,     \" myAge \"  )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class ,    cav ,    pvs )  )  ;", "TestBean   testBean    =     (  ( TestBean )     ( lbf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    testBean . getName (  )  )  ;", "assertEquals (  5  ,    testBean . getAge (  )  )  ;", "assertTrue (  (  ( testBean . getMyFloat (  )  . floatValue (  )  )     =  =     1  .  1 F )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomTypeConverter"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "NumberFormat   nf    =    NumberFormat . getInstance ( Locale . GERMAN )  ;", "lbf . setTypeConverter ( new    . CustomTypeConverter ( nf )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" myFloat \"  ,    new   RuntimeBeanReference (  \" myFloat \"  )  )  ;", "ConstructorArgumentValues   cav    =    new   ConstructorArgumentValues (  )  ;", "cav . addIndexedArgumentValue (  0  ,     \" myName \"  )  ;", "cav . addIndexedArgumentValue (  1  ,     \" myAge \"  )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class ,    cav ,    pvs )  )  ;", "lbf . registerSingleton (  \" myFloat \"  ,     \"  1  ,  1  \"  )  ;", "TestBean   testBean    =     (  ( TestBean )     ( lbf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    testBean . getName (  )  )  ;", "assertEquals (  5  ,    testBean . getAge (  )  )  ;", "assertTrue (  (  ( testBean . getMyFloat (  )  . floatValue (  )  )     =  =     1  .  1 F )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomTypeConverterWithBeanReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setDependsOn (  \" tb 2  \"  )  ;", "lbf . registerBeanDefinition (  \" tb 1  \"  ,    bd 1  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setDependsOn (  \" tb 1  \"  )  ;", "lbf . registerBeanDefinition (  \" tb 2  \"  ,    bd 2  )  ;", "try    {", "lbf . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Circular \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  ' tb 2  '  \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  ' tb 1  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDependsOnCycle"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   innerBd    =    new   RootBeanDefinition (  . BeanWithDestroyMethod . class )  ;", "innerBd . setDestroyMethodName (  \" close \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . BeanWithDestroyMethod . class )  ;", "bd . setDestroyMethodName (  \" close \"  )  ;", "bd . getPropertyValues (  )  . add (  \" inner \"  ,    innerBd )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", ". BeanWithDestroyMethod . closeCount    =     0  ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . destroySingletons (  )  ;", "assertEquals (  \" Destroy   methods   invoked \"  ,     2  ,     . BeanWithDestroyMethod . closeCount )  ;", "}", "METHOD_END"], "methodName": ["testDestroyMethodOnInnerBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   innerBd    =    new   RootBeanDefinition (  . BeanWithDestroyMethod . class )  ;", "innerBd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "innerBd . setDestroyMethodName (  \" close \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . BeanWithDestroyMethod . class )  ;", "bd . setDestroyMethodName (  \" close \"  )  ;", "bd . getPropertyValues (  )  . add (  \" inner \"  ,    innerBd )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", ". BeanWithDestroyMethod . closeCount    =     0  ;", "lbf . preInstantiateSingletons (  )  ;", "lbf . destroySingletons (  )  ;", "assertEquals (  \" Destroy   methods   invoked \"  ,     1  ,     . BeanWithDestroyMethod . closeCount )  ;", "}", "METHOD_END"], "methodName": ["testDestroyMethodOnInnerBeanAsPrototype"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" integer 1  \"  ,    new   Integer (  4  )  )  ;", "bf . registerSingleton (  \" integer 2  \"  ,    new   Integer (  5  )  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertEquals ( new   Integer (  4  )  ,    ab . getIntegerArray (  )  [  0  ]  )  ;", "assertEquals ( new   Integer (  5  )  ,    ab . getIntegerArray (  )  [  1  ]  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    ab . getResourceArray (  )  [  0  ]  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    ab . getResourceArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleArrayConstructorWithAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . ArrayBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" arrayBean \"  ,    rbd )  ;", ". ArrayBean   ab    =     (  (  . ArrayBean )     ( bf . getBean (  \" arrayBean \"  )  )  )  ;", "assertNull ( ab . getIntegerArray (  )  )  ;", "assertNull ( ab . getResourceArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleArrayConstructorWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "assertTrue (  \" No   beans   defined    -  -  >    array    !  =    null \"  ,     (  ( lbf . getBeanDefinitionNames (  )  )     !  =    null )  )  ;", "assertTrue (  \" No   beans   defined   after   no   arg   constructor \"  ,     (  ( lbf . getBeanDefinitionNames (  )  . length )     =  =     0  )  )  ;", "assertTrue (  \" No   beans   defined   after   no   arg   constructor \"  ,     (  ( lbf . getBeanDefinitionCount (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmpty"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" No   beans   defined   after   ignorable   invalid \"  ,     (  ( lbf . getBeanDefinitionCount (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyPropertiesPopulation"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   theChildScope    =     \" bonanza !  \"  ;", "RootBeanDefinition   parent    =    new   RootBeanDefinition (  )  ;", "parent . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "AbstractBeanDefinition   child    =    BeanDefinitionBuilder . childBeanDefinition (  \" parent \"  )  . getBeanDefinition (  )  ;", "child . setBeanClass ( TestBean . class )  ;", "child . setScope ( theChildScope )  ;", "factory    =    new    (  )  ;", "factory . registerBeanDefinition (  \" parent \"  ,    parent )  ;", "factory . registerBeanDefinition (  \" child \"  ,    child )  ;", "AbstractBeanDefinition   def    =     (  ( AbstractBeanDefinition )     ( factory . getBeanDefinition (  \" child \"  )  )  )  ;", "assertEquals (  \" Child    ' scope '    not   overriding   parent   scope    ( it   must )  .  \"  ,    theChildScope ,    def . getScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExplicitScopeInheritanceForChildBeanDefinitions"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "BeanExpressionResolver   beanExpressionResolver    =    mock ( BeanExpressionResolver . class )  ;", "when ( beanExpressionResolver . evaluate ( eq (  \"  #  { foo }  \"  )  ,    ArgumentMatchers . any ( BeanExpressionContext . class )  )  )  . thenReturn (  \" classpath :  / org / springframework / beans / factory / xml / util . properties \"  )  ;", "bf . setBeanExpressionResolver ( beanExpressionResolver )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( PropertiesFactoryBean . class )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" locations \"  ,    new   String [  ]  {     \"  #  { foo }  \"     }  )  ;", "rbd . setPropertyValues ( pvs )  ;", "bf . registerBeanDefinition (  \" myProperties \"  ,    rbd )  ;", "Properties   properties    =     (  ( Properties )     ( bf . getBean (  \" myProperties \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    properties . getProperty (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExpressionInStringArray"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse \"  ,    new   RuntimeBeanReference (  (  \" bean \"     +     ( i    <     9  9     ?    i    +     1     :     0  )  )  )  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  (  \" bean \"     +    i )  ,    bd )  ;", "}", "lbf . preInstantiateSingletons (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "TestBean   bean    =     (  ( TestBean )     ( lbf . getBean (  (  \" bean \"     +    i )  )  )  )  ;", "TestBean   otherBean    =     (  ( TestBean )     ( lbf . getBean (  (  \" bean \"     +     ( i    <     9  9     ?    i    +     1     :     0  )  )  )  )  )  ;", "assertTrue (  (  ( bean . getSpouse (  )  )     =  =    otherBean )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExtensiveCircularReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DummyFactory . class . getName (  )  )  ;", "DummyFactory . reset (  )  ;", "p . setProperty (  \" x 1  . singleton \"  ,     \" false \"  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "lbf . preInstantiateSingletons (  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "lbf . getBean (  \" x 1  \"  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertTrue (  \" prototype   was   instantiated \"  ,    DummyFactory . wasPrototypeCreated (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanDidNotCreatePrototype"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestFieldSettingWithInstantiationAwarePostProcessor ( false )  ;", "}", "METHOD_END"], "methodName": ["testFieldSettingWithInstantiationAwarePostProcessorNoShortCircuit"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "doTestFieldSettingWithInstantiationAwarePostProcessor ( true )  ;", "}", "METHOD_END"], "methodName": ["testFieldSettingWithInstantiationAwarePostProcessorWithShortCircuit"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "findTypeOfPrototypeFactoryMethodOnBeanInstance ( false )  ;", "}", "METHOD_END"], "methodName": ["testFindTypeOfPrototypeFactoryMethodOnBeanInstance"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "findTypeOfPrototypeFactoryMethodOnBeanInstance ( true )  ;", "}", "METHOD_END"], "methodName": ["testFindTypeOfSingletonFactoryMethodOnBeanInstance"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "parent . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory ( parent )  ;", "TestBean   bean    =    lbf . getBean ( TestBean . class )  ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeDefinedInParent"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   na 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "na 1  . setAutowireCandidate ( false )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" na 1  \"  ,    na 1  )  ;", "TestBean   actual    =    lbf . getBean ( TestBean . class )  ;", "assertSame ( lbf . getBean (  \" bd 1  \"  ,    TestBean . class )  ,    actual )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "try    {", "lbf . getBean ( TestBean . class )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeFiltersOutNonAutowireCandidates"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   parent    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    createConstructorDependencyBeanDefinition (  9  9  )  ;", "parent . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory ( parent )  ;", ". ConstructorDependency   bean    =    lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "assertThat ( bean . beanName ,    equalTo (  \" bd 1  \"  )  )  ;", "assertThat ( bean . spouseAge ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceDefinedInParent"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    createConstructorDependencyBeanDefinition (  9  9  )  ;", "RootBeanDefinition   bd 2     =    createConstructorDependencyBeanDefinition (  4  3  )  ;", "RootBeanDefinition   na 1     =    createConstructorDependencyBeanDefinition (  2  1  )  ;", "na 1  . setAutowireCandidate ( false )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" na 1  \"  ,    na 1  )  ;", ". ConstructorDependency   actual    =    lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "assertThat ( actual . beanName ,    equalTo (  \" bd 1  \"  )  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "try    {", "lbf . getBean ( TestBean . class ,     6  7  )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceFiltersOutNonAutowireCandidates"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    createConstructorDependencyBeanDefinition (  9  9  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . ConstructorDependency . class )  ;", "bd 2  . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bd 2  . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \"  4  3  \"  )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "thrown . expect ( NoUniqueBeanDefinitionException . class )  ;", "lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceWithAmbiguity"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    createConstructorDependencyBeanDefinition (  9  9  )  ;", "RootBeanDefinition   bd 2     =    createConstructorDependencyBeanDefinition (  4  3  )  ;", "bd 1  . setPrimary ( true )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "thrown . expect ( NoUniqueBeanDefinitionException . class )  ;", "thrown . expectMessage ( containsString (  \" more   than   one    ' primary '  \"  )  )  ;", "lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceWithMultiplePrimary"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceWithNoneFound"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    createConstructorDependencyBeanDefinition (  9  9  )  ;", "RootBeanDefinition   bd 2     =    createConstructorDependencyBeanDefinition (  4  3  )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", ". ConstructorDependency   bean    =    lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "assertThat ( bean . beanName ,    equalTo (  \" bd 2  \"  )  )  ;", "assertThat ( bean . spouseAge ,    equalTo (  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeInstanceWithPrimary"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "TestBean   bean    =    lbf . getBean ( TestBean . class )  ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypePrimaryHasPrecedenceOverPriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "lbf . getBean ( TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithAmbiguity"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setPrimary ( true )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "thrown . expect ( NoUniqueBeanDefinitionException . class )  ;", "thrown . expectMessage ( containsString (  \" more   than   one    ' primary '  \"  )  )  ;", "lbf . getBean ( TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithMultiplePrimary"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "thrown . expect ( NoUniqueBeanDefinitionException . class )  ;", "thrown . expectMessage ( containsString (  \" Multiple   beans   found   with   the   same   priority \"  )  )  ;", "thrown . expectMessage ( containsString (  \"  5  \"  )  )  ;", "lbf . getBean ( TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithMultiplePriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . getBean ( TestBean . class )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithNoneFound"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setLazyInit ( true )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPrimary ( true )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "TestBean   bean    =    lbf . getBean ( TestBean . class )  ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 2  \"  )  )  ;", "assertFalse ( lbf . containsSingleton (  \" bd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithPrimary"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . LowPriorityTestBean . class )  ;", "RootBeanDefinition   bd 3     =    new   RootBeanDefinition (  . NullTestBeanFactoryBean . class )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "lbf . registerBeanDefinition (  \" bd 3  \"  ,    bd 3  )  ;", "lbf . preInstantiateSingletons (  )  ;", "TestBean   bean    =    lbf . getBean ( TestBean . class )  ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithPriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . NullTestBeanFactoryBean . class )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "TestBean   bean    =    lbf . getBean ( TestBean . class )  ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanByTypeWithPriorityAndNullInstance"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" factoryBean \"  ,    new   RootBeanDefinition (  . FactoryBeanThatShouldntBeCalled . class )  )  ;", "lbf . getBean (  \"  & factoryBean \"  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( Runnable . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType ( Callable . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType (  . RepositoryFactoryInformation . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType ( FactoryBean . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanNamesForTypeAfterFactoryBeanCreation"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" factoryBean \"  ,    new   RootBeanDefinition (  . FactoryBeanThatShouldntBeCalled . class )  )  ;", "assertFalse ( lbf . containsSingleton (  \" factoryBean \"  )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( Runnable . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType ( Callable . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType (  . RepositoryFactoryInformation . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "beanNames    =    lbf . getBeanNamesForType ( FactoryBean . class ,    false ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \"  & factoryBean \"  ,    beanNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanNamesForTypeBeforeFactoryBeanCreation"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . ConstructorDependency . class )  ;", "bd 1  . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . ConstructorDependencyFactoryBean . class )  ;", "bd 2  . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", ". ConstructorDependency   bean    =    lbf . getBean (  . ConstructorDependency . class ,     4  2  )  ;", "assertThat ( bean . beanName ,    equalTo (  \" bd 1  \"  )  )  ;", "assertThat ( bean . spouseAge ,    equalTo (  4  2  )  )  ;", "assertEquals (  1  ,    lbf . getBeanNamesForType (  . ConstructorDependency . class )  . length )  ;", "assertEquals (  1  ,    lbf . getBeanNamesForType (  . ConstructorDependencyFactoryBean . class )  . length )  ;", "assertEquals (  1  ,    lbf . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( FactoryBean . class ,    Object . class )  )  . length )  ;", "assertEquals (  0  ,    lbf . getBeanNamesForType ( ResolvableType . forClassWithGenerics ( FactoryBean . class ,    String . class )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testGetBeanWithArgsNotCreatedForFactoryBeanChecking"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . FactoryBeanThatShouldntBeCalled . class )  ;", "bd . setAbstract ( true )  ;", "lbf . registerBeanDefinition (  \" factoryBean \"  ,    bd )  ;", "assertNull ( lbf . getType (  \" factoryBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTypeForAbstractFactoryBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   parentDefinition    =    new   RootBeanDefinition ( TestBean . class )  ;", "ChildBeanDefinition   childDefinition    =    new   ChildBeanDefinition (  \" parent \"  ,    DerivedTestBean . class ,    null ,    null )  ;", "factory    =    new    (  )  ;", "factory . registerBeanDefinition (  \" parent \"  ,    parentDefinition )  ;", "factory . registerBeanDefinition (  \" child \"  ,    childDefinition )  ;", "factory . freezeConfiguration (  )  ;", "assertEquals ( TestBean . class ,    factory . getType (  \" parent \"  )  )  ;", "assertEquals ( DerivedTestBean . class ,    factory . getType (  \" child \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTypeWorksAfterParentChildMerging"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" foo \"  ,     \" bar \"  )  ;", "p . setProperty (  \" qwert \"  ,     \" er \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p ,     \" test \"  )  ;", "assertTrue (  \" No   beans   defined   after   harmless   ignorable   rubbish \"  ,     (  ( lbf . getBeanDefinitionCount (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testHarmlessIgnorableRubbish"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setDependsOn (  \" tb 2  \"  )  ;", "lbf . registerBeanDefinition (  \" tb 1  \"  ,    bd 1  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setDependsOn (  \" tb 3  \"  )  ;", "lbf . registerBeanDefinition (  \" tb 2  \"  ,    bd 2  )  ;", "RootBeanDefinition   bd 3     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 3  . setDependsOn (  \" tb 1  \"  )  ;", "lbf . registerBeanDefinition (  \" tb 3  \"  ,    bd 3  )  ;", "try    {", "lbf . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" Circular \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  ' tb 3  '  \"  )  )  ;", "assertTrue ( ex . getMessage (  )  . contains (  \"  ' tb 1  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testImplicitDependsOnCycle"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "final   DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . TestSecuredBean . class )  ;", "bd . setScope ( ConfigurableBeanFactory . SCOPE _ PROTOTYPE )  ;", "bd . setInitMethodName (  \" init \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "final   Subject   subject    =    new   Subject (  )  ;", "subject . getPrincipals (  )  . add ( new    . TestPrincipal (  \" user 1  \"  )  )  ;", ". TestSecuredBean   bean    =     (  (  . TestSecuredBean )     ( Subject . doAsPrivileged ( subject ,    new   PrivilegedAction (  )     {", "@ Override", "public   Object   run (  )     {", "return   lbf . getBean (  \" test \"  )  ;", "}", "}  ,    null )  )  )  ;", "assertNotNull ( bean )  ;", "assertEquals (  \" user 1  \"  ,    bean . getUserName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitSecurityAwarePrototypeBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DummyFactory . class . getName (  )  )  ;", "DummyFactory . reset (  )  ;", "p . setProperty (  \" x 1  . singleton \"  ,     \" false \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "lbf . preInstantiateSingletons (  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" x 1  \"  ,    beanNames [  0  ]  )  ;", "assertTrue ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    DummyFactory . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    Object . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    Object . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( DummyFactory . class ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "lbf . registerAlias (  \" x 1  \"  ,     \" x 2  \"  )  ;", "assertTrue ( lbf . containsBean (  \" x 2  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \" x 2  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \"  & x 2  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 2  \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 2  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 2  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 2  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 2  \"  ,    DummyFactory . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 2  \"  ,    Object . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 2  \"  ,    Object . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 2  \"  )  )  ;", "assertEquals ( DummyFactory . class ,    lbf . getType (  \"  & x 2  \"  )  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \" x 1  \"  )  . length )  ;", "assertEquals (  \" x 2  \"  ,    lbf . getAliases (  \" x 1  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \"  & x 1  \"  )  . length )  ;", "assertEquals (  \"  & x 2  \"  ,    lbf . getAliases (  \"  & x 1  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \" x 2  \"  )  . length )  ;", "assertEquals (  \" x 1  \"  ,    lbf . getAliases (  \" x 2  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \"  & x 2  \"  )  . length )  ;", "assertEquals (  \"  & x 1  \"  ,    lbf . getAliases (  \"  & x 2  \"  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testInitializedFactoryBeanFoundByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "try    {", "lbf . autowireBeanProperties ( new   TestBean (  )  ,    AutowireCapableBeanFactory . AUTOWIRE _ CONSTRUCTOR ,    false )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testInvalidAutowireMode"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition (  . LazyInitFactory . class )  )  ;", "lbf . preInstantiateSingletons (  )  ;", ". LazyInitFactory   factory    =     (  (  . LazyInitFactory )     ( lbf . getBean (  \"  & test \"  )  )  )  ;", "assertFalse ( factory . initialized )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitFactory"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactoryTests . KnowsIfInstantiated . clearInstantiationRecord (  )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DefaultListableBeanFactoryTests . KnowsIfInstantiated . class . getName (  )  )  ;", "p . setProperty (  \" x 1  .  ( lazy - init )  \"  ,     \" true \"  )  ;", "assertTrue (  \" singleton   not   instantiated \"  ,     (  !  ( DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  )  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" singleton   not   instantiated \"  ,     (  !  ( DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  )  )  ;", "lbf . preInstantiateSingletons (  )  ;", "assertTrue (  \" singleton   not   instantiated \"  ,     (  !  ( DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  )  )  ;", "lbf . getBean (  \" x 1  \"  )  ;", "assertTrue (  \" singleton   was   instantiated \"  ,    DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLazyInitialization"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . setDependencyComparator ( INSTANCE )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . HighPriorityTestBean . class )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . LowPriorityTestBean . class )  ;", "RootBeanDefinition   bd 3     =    new   RootBeanDefinition (  . NullTestBeanFactoryBean . class )  ;", "RootBeanDefinition   bd 4     =    new   RootBeanDefinition (  . TestBeanRecipient . class ,    RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR ,    false )  ;", "lbf . registerBeanDefinition (  \" bd 1  \"  ,    bd 1  )  ;", "lbf . registerBeanDefinition (  \" bd 2  \"  ,    bd 2  )  ;", "lbf . registerBeanDefinition (  \" bd 3  \"  ,    bd 3  )  ;", "lbf . registerBeanDefinition (  \" bd 4  \"  ,    bd 4  )  ;", "lbf . preInstantiateSingletons (  )  ;", "TestBean   bean    =    lbf . getBean (  . TestBeanRecipient . class )  . testBean ;", "assertThat ( bean . getBeanName (  )  ,    equalTo (  \" bd 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapInjectionWithPriority"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "try    {", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertEquals (  \" kerry \"  ,    ex . getBeanName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNameAlreadyBound"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DummyFactory . class . getName (  )  )  ;", "DummyFactory . reset (  )  ;", "p . setProperty (  \" x 1  . singleton \"  ,     \" false \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "beanNames    =    lbf . getBeanNamesForAnnotation ( SuppressWarnings . class )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    DummyFactory . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClass ( DummyFactory . class )  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    Object . class )  )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    String . class )  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( DummyFactory . class ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonInitializedFactoryBeanIgnoredByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . NonPublicEnumHolder . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" VALUE _  1  \"  )  ;", "bf . registerBeanDefinition (  \" holderBean \"  ,    bd )  ;", ". NonPublicEnumHolder   holder    =     (  (  . NonPublicEnumHolder )     ( bf . getBean (  \" holderBean \"  )  )  )  ;", "assertEquals (  . NonPublicEnum . VALUE _  1  ,    holder . getNonPublicEnum (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonPublicEnum"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   factoryBd    =    new   RootBeanDefinition (  . TestBeanFactory . class )  ;", "lbf . registerBeanDefinition (  \" factory \"  ,    factoryBd )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . TestBeanFactory . class )  ;", "rbd . setFactoryBeanName (  \" factory \"  )  ;", "rbd . setFactoryMethodName (  \" createTestBeanNonStatic \"  )  ;", "lbf . registerBeanDefinition (  \" x 1  \"  ,    rbd )  ;", ". TestBeanFactory . initialized    =    false ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" x 1  \"  ,    beanNames [  0  ]  )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( null ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertFalse (  . TestBeanFactory . initialized )  ;", "}", "METHOD_END"], "methodName": ["testNonStaticFactoryMethodFoundByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   factoryBd    =    new   RootBeanDefinition (  . TestBeanFactory . class )  ;", "lbf . registerBeanDefinition (  \" factory \"  ,    factoryBd )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" factory \"  )  ;", "rbd . setFactoryMethodName (  \" createTestBeanNonStatic \"  )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" x 1  \"  ,    rbd )  ;", ". TestBeanFactory . initialized    =    false ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" x 1  \"  ,    beanNames [  0  ]  )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . containsLocalBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    Object . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    Object . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( null ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertFalse (  . TestBeanFactory . initialized )  ;", "lbf . registerAlias (  \" x 1  \"  ,     \" x 2  \"  )  ;", "assertTrue ( lbf . containsBean (  \" x 2  \"  )  )  ;", "assertFalse ( lbf . containsBean (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . containsLocalBean (  \" x 2  \"  )  )  ;", "assertFalse ( lbf . containsLocalBean (  \"  & x 2  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 2  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 2  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 2  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 2  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 2  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 2  \"  ,    Object . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 2  \"  ,    Object . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 2  \"  )  )  ;", "assertEquals ( null ,    lbf . getType (  \"  & x 2  \"  )  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \" x 1  \"  )  . length )  ;", "assertEquals (  \" x 2  \"  ,    lbf . getAliases (  \" x 1  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \"  & x 1  \"  )  . length )  ;", "assertEquals (  \"  & x 2  \"  ,    lbf . getAliases (  \"  & x 1  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \" x 2  \"  )  . length )  ;", "assertEquals (  \" x 1  \"  ,    lbf . getAliases (  \" x 2  \"  )  [  0  ]  )  ;", "assertEquals (  1  ,    lbf . getAliases (  \"  & x 2  \"  )  . length )  ;", "assertEquals (  \"  & x 1  \"  ,    lbf . getAliases (  \"  & x 2  \"  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testNonStaticPrototypeFactoryMethodFoundByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "lbf    =    new    (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" ag \"  ,     \" foobar \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" tb \"  ,    bd )  ;", "lbf . getBean (  \" tb \"  )  ;", "fail (  \" Should   throw   exception   on   invalid   property \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   NotWritablePropertyException )  )  ;", "NotWritablePropertyException   cause    =     (  ( NotWritablePropertyException )     ( ex . getCause (  )  )  )  ;", "assertEquals (  1  ,    cause . getPossibleMatches (  )  . length )  ;", "assertEquals (  \" age \"  ,    cause . getPossibleMatches (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPossibleMatches"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" test .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" test . name \"  ,     \" Tony \"  )  ;", "p . setProperty (  \" test . age \"  ,     \"  4  8  \"  )  ;", "int   count    =    new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  (  \"  1    beans   registered ,    not    \"     +    count )  ,     ( count    =  =     1  )  )  ;", "testSingleTestBean ( lbf )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesPopulationWithNullPrefix"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   PREFIX    =     \" beans .  \"  ;", "lbf    =    new    (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  ( PREFIX    +     \" test .  ( class )  \"  )  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  ( PREFIX    +     \" test . name \"  )  ,     \" Tony \"  )  ;", "p . setProperty (  ( PREFIX    +     \" test . age \"  )  ,     \"  0 x 3  0  \"  )  ;", "int   count    =    new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p ,    PREFIX )  ;", "assertTrue (  (  \"  1    beans   registered ,    not    \"     +    count )  ,     ( count    =  =     1  )  )  ;", "testSingleTestBean ( lbf )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesPopulationWithPrefix"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" tb .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" tb . someMap [ my . key ]  \"  ,     \" my . value \"  )  ;", "int   count    =    new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  (  \"  1    beans   registered ,    not    \"     +    count )  ,     ( count    =  =     1  )  )  ;", "assertEquals (  1  ,    lbf . getBeanDefinitionCount (  )  )  ;", "TestBean   tb    =    lbf . getBean (  \" tb \"  ,    TestBean . class )  ;", "assertEquals (  \" my . value \"  ,    tb . getSomeMap (  )  . get (  \" my . key \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertiesWithDotsInKey"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "TestBean   kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "TestBean   kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Non   null \"  ,     ( kerry 1     !  =    null )  )  ;", "assertTrue (  \" Singletons   equal \"  ,     ( kerry 1     =  =    kerry 2  )  )  ;", "lbf    =    new   DefaultListableBeanFactory (  )  ;", "p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry .  ( scope )  \"  ,     \" prototype \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Non   null \"  ,     ( kerry 1     !  =    null )  )  ;", "assertTrue (  \" Prototypes   NOT   equal \"  ,     ( kerry 1     !  =    kerry 2  )  )  ;", "lbf    =    new   DefaultListableBeanFactory (  )  ;", "p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry .  ( scope )  \"  ,     \" singleton \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Non   null \"  ,     ( kerry 1     !  =    null )  )  ;", "assertTrue (  \" Specified   singletons   equal \"  ,     ( kerry 1     =  =    kerry 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototype"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "p . setProperty (  \" kerry . spouse \"  ,     \"  * rod \"  )  ;", "p . setProperty (  \" rod .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" rod .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" rod . age \"  ,     \"  3  4  \"  )  ;", "p . setProperty (  \" rod . spouse \"  ,     \"  * kerry \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "try    {", "lbf . getBean (  \" kerry \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . contains ( BeanCurrentlyInCreationException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPrototypeCircleLeadsToException"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "lbf . getBean (  \" test \"  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" juergen \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \"  9  9  \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" juergen \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithConstructorArgumentsIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( LifecycleBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . setDependencyCheck ( RootBeanDefinition . DEPENDENCY _ CHECK _ OBJECTS )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "lbf . addBeanPostProcessor ( new   LifecycleBean . PostProcessor (  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "lbf . getBean (  \" test \"  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithDependencyCheckIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . getPropertyValues (  )  . add (  \" name \"  ,     \" juergen \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" age \"  ,     \"  9  9  \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" juergen \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     3  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithPropertiesIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   RuntimeBeanReference (  \" spouse \"  )  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( lbf . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     4  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithResolvedConstructorArgumentsIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "Assume . notLogging (  . factoryLog )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" spouse \"  )  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    rbd )  ;", "lbf . registerBeanDefinition (  \" spouse \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "TestBean   spouse    =     (  ( TestBean )     ( lbf . getBean (  \" spouse \"  )  )  )  ;", "StopWatch   sw    =    new   StopWatch (  )  ;", "sw . start (  \" prototype \"  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertSame ( spouse ,    tb . getSpouse (  )  )  ;", "}", "sw . stop (  )  ;", "assertTrue (  (  \" Prototype   creation   took   too   long :     \"     +     ( sw . getTotalTimeMillis (  )  )  )  ,     (  ( sw . getTotalTimeMillis (  )  )     <     4  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeCreationWithResolvedPropertiesIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" wife .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" wife . name \"  ,     \" kerry \"  )  ;", "p . setProperty (  \" kerry .  ( parent )  \"  ,     \" wife \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "TestBean   kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "TestBean   kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertEquals (  \" kerry \"  ,    kerry 1  . getName (  )  )  ;", "assertNotNull (  \" Non   null \"  ,    kerry 1  )  ;", "assertTrue (  \" Singletons   equal \"  ,     ( kerry 1     =  =    kerry 2  )  )  ;", "lbf    =    new   DefaultListableBeanFactory (  )  ;", "p    =    new   Properties (  )  ;", "p . setProperty (  \" wife .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" wife . name \"  ,     \" kerry \"  )  ;", "p . setProperty (  \" wife .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" kerry .  ( parent )  \"  ,     \" wife \"  )  ;", "p . setProperty (  \" kerry .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertFalse ( lbf . isSingleton (  \" kerry \"  )  )  ;", "kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Non   null \"  ,     ( kerry 1     !  =    null )  )  ;", "assertTrue (  \" Prototypes   NOT   equal \"  ,     ( kerry 1     !  =    kerry 2  )  )  ;", "lbf    =    new   DefaultListableBeanFactory (  )  ;", "p    =    new   Properties (  )  ;", "p . setProperty (  \" kerry .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" kerry .  ( singleton )  \"  ,     \" true \"  )  ;", "p . setProperty (  \" kerry . age \"  ,     \"  3  5  \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "kerry 1     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "kerry 2     =     (  ( TestBean )     ( lbf . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Non   null \"  ,     ( kerry 1     !  =    null )  )  ;", "assertTrue (  \" Specified   singletons   equal \"  ,     ( kerry 1     =  =    kerry 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeExtendsPrototype"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DummyFactory . class . getName (  )  )  ;", "DummyFactory . reset (  )  ;", "p . setProperty (  \" x 1  .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" x 1  . singleton \"  ,     \" false \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "beanNames    =    lbf . getBeanNamesForAnnotation ( SuppressWarnings . class )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    DummyFactory . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClass ( DummyFactory . class )  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    Object . class )  )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    String . class )  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( DummyFactory . class ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeFactoryBeanIgnoredByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition (  . FactoryBeanThatShouldntBeCalled . class )  )  ;", "lbf . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeFactoryBeanNotEagerlyCalled"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition (  . FactoryBeanThatShouldntBeCalled . class . getName (  )  ,    null ,    null )  )  ;", "lbf . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeFactoryBeanNotEagerlyCalledInCaseOfBeanClassName"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   stringDef    =    new   RootBeanDefinition ( String . class )  ;", "stringDef . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "stringDef . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   TypedStringValue (  \" value \"  )  )  ;", "lbf . registerBeanDefinition (  \" string \"  ,    stringDef )  ;", "String   val 1     =    lbf . getBean (  \" string \"  ,    String . class )  ;", "String   val 2     =    lbf . getBean (  \" string \"  ,    String . class )  ;", "assertEquals (  \" value \"  ,    val 1  )  ;", "assertEquals (  \" value \"  ,    val 2  )  ;", "assertNotSame ( val 1  ,    val 2  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeStringCreatedRepeatedly"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "List < String >    list    =    new   ManagedList <  >  (  )  ;", "list . add (  \" myName \"  )  ;", "list . add (  \" myBeanName \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( DerivedTestBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( list )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "DerivedTestBean   tb    =     (  ( DerivedTestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" myBeanName \"  ,    tb . getBeanName (  )  )  ;", "DerivedTestBean   tb 2     =     (  ( DerivedTestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertTrue (  ( tb    !  =    tb 2  )  )  ;", "assertEquals (  \" myName \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" myBeanName \"  ,    tb 2  . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeWithArrayConversionForConstructor"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "List < String >    list    =    new   ManagedList <  >  (  )  ;", "list . add (  \" myName \"  )  ;", "list . add (  \" myBeanName \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( DerivedTestBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bd . setFactoryMethodName (  \" create \"  )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( list )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "DerivedTestBean   tb    =     (  ( DerivedTestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals (  \" myName \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" myBeanName \"  ,    tb . getBeanName (  )  )  ;", "DerivedTestBean   tb 2     =     (  ( DerivedTestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertTrue (  ( tb    !  =    tb 2  )  )  ;", "assertEquals (  \" myName \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" myBeanName \"  ,    tb 2  . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeWithArrayConversionForFactoryMethod"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Object   singletonObject    =    new   TestBean (  )  ;", "lbf . registerSingleton (  \" singletonObject \"  ,    singletonObject )  ;", "try    {", "lbf . registerSingleton (  \" singletonObject \"  ,    singletonObject )  ;", "fail (  \" Should   have   thrown   IllegalStateException \"  )  ;", "}    catch    ( IllegalStateException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testRegisterExistingSingletonWithAlreadyBound"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" name \"  ,     \" Tony \"  )  ;", "pvs . add (  \" age \"  ,     \"  4  8  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( DependenciesBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "bd . setDependencyCheck ( RootBeanDefinition . DEPENDENCY _ CHECK _ OBJECTS )  ;", "bd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bd )  ;", "Object   singletonObject    =    new   TestBean (  )  ;", "lbf . registerSingleton (  \" singletonObject \"  ,    singletonObject )  ;", "assertTrue ( lbf . containsBean (  \" singletonObject \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \" singletonObject \"  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" singletonObject \"  )  )  ;", "assertEquals (  0  ,    lbf . getAliases (  \" singletonObject \"  )  . length )  ;", "DependenciesBean   test    =     (  ( DependenciesBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals ( singletonObject ,    lbf . getBean (  \" singletonObject \"  )  )  ;", "assertEquals ( singletonObject ,    test . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterExistingSingletonWithAutowire"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" test .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" test . name \"  ,     \" Tony \"  )  ;", "p . setProperty (  \" test . age \"  ,     \"  4  8  \"  )  ;", "p . setProperty (  \" test . spouse ( ref )  \"  ,     \" singletonObject \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "lbf . registerBeanDefinition (  \" singletonObject \"  ,    new   RootBeanDefinition ( PropertiesFactoryBean . class )  )  ;", "Object   singletonObject    =    new   TestBean (  )  ;", "lbf . registerSingleton (  \" singletonObject \"  ,    singletonObject )  ;", "lbf . preInstantiateSingletons (  )  ;", "assertTrue ( lbf . isSingleton (  \" singletonObject \"  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" singletonObject \"  )  )  ;", "TestBean   test    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals ( singletonObject ,    lbf . getBean (  \" singletonObject \"  )  )  ;", "assertEquals ( singletonObject ,    test . getSpouse (  )  )  ;", "Map <  ?  ,     ?  >    beansOfType    =    lbf . getBeansOfType ( TestBean . class ,    false ,    true )  ;", "assertEquals (  2  ,    beansOfType . size (  )  )  ;", "assertTrue ( beansOfType . containsValue ( test )  )  ;", "assertTrue ( beansOfType . containsValue ( singletonObject )  )  ;", "beansOfType    =    lbf . getBeansOfType ( null ,    false ,    true )  ;", "Iterator < String >    beanNames    =    lbf . getBeanNamesIterator (  )  ;", "assertEquals (  \" test \"  ,    beanNames . next (  )  )  ;", "assertEquals (  \" singletonObject \"  ,    beanNames . next (  )  )  ;", "assertFalse ( beanNames . hasNext (  )  )  ;", "assertEquals (  2  ,    beansOfType . size (  )  )  ;", "assertTrue ( lbf . containsSingleton (  \" test \"  )  )  ;", "assertTrue ( lbf . containsSingleton (  \" singletonObject \"  )  )  ;", "assertTrue ( lbf . containsBeanDefinition (  \" test \"  )  )  ;", "assertTrue ( lbf . containsBeanDefinition (  \" singletonObject \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterExistingSingletonWithNameOverriding"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" test .  ( class )  \"  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  \" test . name \"  ,     \" Tony \"  )  ;", "p . setProperty (  \" test . age \"  ,     \"  4  8  \"  )  ;", "p . setProperty (  \" test . spouse ( ref )  \"  ,     \" singletonObject \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "Object   singletonObject    =    new   TestBean (  )  ;", "lbf . registerSingleton (  \" singletonObject \"  ,    singletonObject )  ;", "assertTrue ( lbf . isSingleton (  \" singletonObject \"  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" singletonObject \"  )  )  ;", "TestBean   test    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertEquals ( singletonObject ,    lbf . getBean (  \" singletonObject \"  )  )  ;", "assertEquals ( singletonObject ,    test . getSpouse (  )  )  ;", "Map <  ?  ,     ?  >    beansOfType    =    lbf . getBeansOfType ( TestBean . class ,    false ,    true )  ;", "assertEquals (  2  ,    beansOfType . size (  )  )  ;", "assertTrue ( beansOfType . containsValue ( test )  )  ;", "assertTrue ( beansOfType . containsValue ( singletonObject )  )  ;", "beansOfType    =    lbf . getBeansOfType ( null ,    false ,    true )  ;", "assertEquals (  2  ,    beansOfType . size (  )  )  ;", "Iterator < String >    beanNames    =    lbf . getBeanNamesIterator (  )  ;", "assertEquals (  \" test \"  ,    beanNames . next (  )  )  ;", "assertEquals (  \" singletonObject \"  ,    beanNames . next (  )  )  ;", "assertFalse ( beanNames . hasNext (  )  )  ;", "assertTrue ( lbf . containsSingleton (  \" test \"  )  )  ;", "assertTrue ( lbf . containsSingleton (  \" singletonObject \"  )  )  ;", "assertTrue ( lbf . containsBeanDefinition (  \" test \"  )  )  ;", "assertFalse ( lbf . containsBeanDefinition (  \" singletonObject \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRegisterExistingSingletonWithReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" b \"  ,    new   RootBeanDefinition (  . B . class )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "bf . registerBeanDefinition (  (  \" a \"     +    i )  ,    new   RootBeanDefinition (  . A . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRegistrationOfManyBeanDefinitionsIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( PERFORMANCE )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" b \"  ,    new   RootBeanDefinition (  . B . class )  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  0  0  ;    i +  +  )     {", "bf . registerSingleton (  (  \" a \"     +    i )  ,    new    . A (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRegistrationOfManySingletonsIsFastEnough"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    bd 1  )  ;", "assertTrue (  (  ( lbf . getBean (  \" testBean \"  )  )    instanceof   TestBean )  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( NestedTestBean . class )  ;", "bd 2  . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "lbf . registerBeanDefinition (  \" testBean \"  ,    bd 2  )  ;", "assertTrue (  (  ( lbf . getBean (  \" testBean \"  )  )    instanceof   NestedTestBean )  )  ;", "}", "METHOD_END"], "methodName": ["testReregisterBeanDefinition"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   parent    =    new   RootBeanDefinition (  )  ;", "parent . setScope (  \" bonanza !  \"  )  ;", "AbstractBeanDefinition   child    =    new   ChildBeanDefinition (  \" parent \"  )  ;", "child . setBeanClass ( TestBean . class )  ;", "factory    =    new    (  )  ;", "factory . registerBeanDefinition (  \" parent \"  ,    parent )  ;", "factory . registerBeanDefinition (  \" child \"  ,    child )  ;", "BeanDefinition   def    =    factory . getMergedBeanDefinition (  \" child \"  )  ;", "assertEquals (  \" Child    ' scope '    not   inherited \"  ,     \" bonanza !  \"  ,    def . getScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopeInheritanceForChildBeanDefinitions"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  ;", "AbstractBeanDefinition   beanDefinition    =    builder . getBeanDefinition (  )  ;", "beanDefinition . setScope (  \" he   put   himself   so   low   could   hardly   look   me   in   the   face \"  )  ;", "factory    =    new    (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDefinition )  ;", "factory . getBean (  \" testBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testScopingBeanToUnregisteredScopeResultsInAnException"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" self \"  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "lbf . registerBeanDefinition (  \" self \"  ,    bd )  ;", "TestBean   self    =     (  ( TestBean )     ( lbf . getBean (  \" self \"  )  )  )  ;", "assertEquals ( self ,    self . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelfReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   PREFIX    =     \" beans .  \"  ;", "lbf    =    new    (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  ( PREFIX    +     \" rod .  ( class )  \"  )  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  ( PREFIX    +     \" rod . name \"  )  ,     \" Rod \"  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry .  ( class )  \"  )  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . name \"  )  ,     \" Kerry \"  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . age \"  )  ,     \"  3  5  \"  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . spouse ( ref )  \"  )  ,     \" rod \"  )  ;", "int   count    =    new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p ,    PREFIX )  ;", "assertTrue (  (  \"  2    beans   registered ,    not    \"     +    count )  ,     ( count    =  =     2  )  )  ;", "TestBean   kerry    =    lbf . getBean (  \" kerry \"  ,    TestBean . class )  ;", "assertTrue (  \" Kerry   name   is   Kerry \"  ,     \" Kerry \"  . equals ( kerry . getName (  )  )  )  ;", "ITestBean   spouse    =    kerry . getSpouse (  )  ;", "assertTrue (  \" Kerry   spouse   is   non   null \"  ,     ( spouse    !  =    null )  )  ;", "assertTrue (  \" Kerry   spouse   name   is   Rod \"  ,     \" Rod \"  . equals ( spouse . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \"  1    beans   defined \"  ,     (  ( lbf . getBeanDefinitionCount (  )  )     =  =     1  )  )  ;", "String [  ]    names    =    lbf . getBeanDefinitionNames (  )  ;", "assertTrue (  ( names    !  =     ( lbf . getBeanDefinitionNames (  )  )  )  )  ;", "assertTrue (  \" Array   length    =  =     1  \"  ,     (  ( names . length )     =  =     1  )  )  ;", "assertTrue (  \"  0 th   element    =  =    test \"  ,    names [  0  ]  . equals (  \" test \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( lbf . getBean (  \" test \"  )  )  )  ;", "assertTrue (  \" Test   is   non   null \"  ,     ( tb    !  =    null )  )  ;", "assertTrue (  \" Test   bean   name   is   Tony \"  ,     \" Tony \"  . equals ( tb . getName (  )  )  )  ;", "assertTrue (  \" Test   bean   age   is    4  8  \"  ,     (  ( tb . getAge (  )  )     =  =     4  8  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingleTestBean"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DummyFactory . class . getName (  )  )  ;", "DummyFactory . reset (  )  ;", "p . setProperty (  \" x 1  .  ( singleton )  \"  ,     \" false \"  )  ;", "p . setProperty (  \" x 1  . singleton \"  ,     \" true \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "beanNames    =    lbf . getBeanNamesForAnnotation ( SuppressWarnings . class )  ;", "assertEquals (  0  ,    beanNames . length )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    DummyFactory . class )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClass ( DummyFactory . class )  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    Object . class )  )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    ResolvableType . forClassWithGenerics ( FactoryBean . class ,    String . class )  )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( DummyFactory . class ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertTrue (  \" prototype   not   instantiated \"  ,     (  !  ( DummyFactory . wasPrototypeCreated (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingletonFactoryBeanIgnoredByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    new   RootBeanDefinition (  . EagerInitFactory . class )  )  ;", "lbf . preInstantiateSingletons (  )  ;", ". EagerInitFactory   factory    =     (  (  . EagerInitFactory )     ( lbf . getBean (  \"  & test \"  )  )  )  ;", "assertTrue ( factory . initialized )  ;", "}", "METHOD_END"], "methodName": ["testSmartInitFactory"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . TestBeanFactory . class )  ;", "rbd . setFactoryMethodName (  \" createTestBean \"  )  ;", "lbf . registerBeanDefinition (  \" x 1  \"  ,    rbd )  ;", ". TestBeanFactory . initialized    =    false ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" x 1  \"  ,    beanNames [  0  ]  )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( null ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertFalse (  . TestBeanFactory . initialized )  ;", "}", "METHOD_END"], "methodName": ["testStaticFactoryMethodFoundByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . TestBeanFactory . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "rbd . setFactoryMethodName (  \" createTestBean \"  )  ;", "lbf . registerBeanDefinition (  \" x 1  \"  ,    rbd )  ;", ". TestBeanFactory . initialized    =    false ;", "String [  ]    beanNames    =    lbf . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertEquals (  1  ,    beanNames . length )  ;", "assertEquals (  \" x 1  \"  ,    beanNames [  0  ]  )  ;", "assertFalse ( lbf . containsSingleton (  \" x 1  \"  )  )  ;", "assertTrue ( lbf . containsBean (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . containsBean (  \"  & x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isSingleton (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isPrototype (  \" x 1  \"  )  )  ;", "assertFalse ( lbf . isPrototype (  \"  & x 1  \"  )  )  ;", "assertTrue ( lbf . isTypeMatch (  \" x 1  \"  ,    TestBean . class )  )  ;", "assertFalse ( lbf . isTypeMatch (  \"  & x 1  \"  ,    TestBean . class )  )  ;", "assertEquals ( TestBean . class ,    lbf . getType (  \" x 1  \"  )  )  ;", "assertEquals ( null ,    lbf . getType (  \"  & x 1  \"  )  )  ;", "assertFalse (  . TestBeanFactory . initialized )  ;", "}", "METHOD_END"], "methodName": ["testStaticPrototypeFactoryMethodFoundByNonEagerTypeMatching"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactoryTests . KnowsIfInstantiated . clearInstantiationRecord (  )  ;", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "Properties   p    =    new   Properties (  )  ;", "p . setProperty (  \" x 1  .  ( class )  \"  ,    DefaultListableBeanFactoryTests . KnowsIfInstantiated . class . getName (  )  )  ;", "assertTrue (  \" singleton   not   instantiated \"  ,     (  !  ( DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  )  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p )  ;", "lbf . preInstantiateSingletons (  )  ;", "assertTrue (  \" singleton   was   instantiated \"  ,    DefaultListableBeanFactoryTests . KnowsIfInstantiated . wasInstantiated (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnreferencedSingletonWasInstantiated"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String   PREFIX    =     \" beans .  \"  ;", "lbf    =    new    (  )  ;", "Properties   p    =    new   Properties (  )  ;", "try    {", "p . setProperty (  ( PREFIX    +     \" kerry .  ( class )  \"  )  ,    TestBean . class . getName (  )  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . name \"  )  ,     \" Kerry \"  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . age \"  )  ,     \"  3  5  \"  )  ;", "p . setProperty (  ( PREFIX    +     \" kerry . spouse ( ref )  \"  )  ,     \" rod \"  )  ;", "new   PropertiesBeanDefinitionReader ( lbf )  . registerBeanDefinitions ( p ,    PREFIX )  ;", "lbf . getBean (  \" kerry \"  )  ;", "fail (  \" Unresolved   reference   should   have   been   detected \"  )  ;", "}    catch    ( BeansException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testUnresolvedReference"], "fileName": "org.springframework.beans.factory.DefaultListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isSingleton"], "fileName": "org.springframework.beans.factory.FactoryBean"}, {"methodBody": ["METHOD_START", "{", "Object   fooFactory    =    beanFactory . getBean (  \"  & fooFactory \"  )  ;", "assertThat ( fooFactory ,    instanceOf ( Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["factoryBeanLookupByNameDereferencing"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "FooFactoryBean   fooFactory    =    beanFactory . getBean ( FooFactoryBean . class )  ;", "assertNotNull ( fooFactory )  ;", "}", "METHOD_END"], "methodName": ["factoryBeanLookupByType"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "FooFactoryBean   fooFactory    =    beanFactory . getBean (  \"  & fooFactory \"  ,    FooFactoryBean . class )  ;", "assertNotNull ( fooFactory )  ;", "}", "METHOD_END"], "methodName": ["factoryBeanLookupByTypeAndNameDereference"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "Object   fooFactory    =    beanFactory . getBean (  \" fooFactory \"  )  ;", "assertThat ( fooFactory ,    instanceOf ( Foo . class )  )  ;", "}", "METHOD_END"], "methodName": ["factoryBeanObjectLookupByName"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "Foo   foo    =    beanFactory . getBean (  \" fooFactory \"  ,    Foo . class )  ;", "assertNotNull ( foo )  ;", "}", "METHOD_END"], "methodName": ["factoryBeanObjectLookupByNameAndType"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader (  (  ( BeanDefinitionRegistry )     ( beanFactory )  )  )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - context . xml \"  ,    this . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.FactoryBeanLookupTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . ABSTRACT _ CONTEXT )  ;", "factory . getBeansWithAnnotation ( Component . class )  ;", "}", "METHOD_END"], "methodName": ["testAbstractFactoryBeanViaAnnotation"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . ABSTRACT _ CONTEXT )  ;", "factory . getBeansOfType (  . AbstractFactoryBean . class )  ;", "}", "METHOD_END"], "methodName": ["testAbstractFactoryBeanViaType"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . CIRCULAR _ CONTEXT )  ;", ". CountingPostProcessor   counter    =    new    . CountingPostProcessor (  )  ;", "factory . addBeanPostProcessor ( counter )  ;", ". BeanImpl 1    impl 1     =    factory . getBean (  . BeanImpl 1  . class )  ;", "assertNotNull ( impl 1  )  ;", "assertNotNull ( impl 1  . getImpl 2  (  )  )  ;", "assertNotNull ( impl 1  . getImpl 2  (  )  )  ;", "assertSame ( impl 1  ,    impl 1  . getImpl 2  (  )  . getImpl 1  (  )  )  ;", "assertEquals (  1  ,    counter . getCount (  \" bean 1  \"  )  )  ;", "assertEquals (  1  ,    counter . getCount (  \" bean 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularReferenceWithPostProcessor"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . RETURNS _ NULL _ CONTEXT )  ;", "assertEquals (  \" null \"  ,    factory . getBean (  \" factoryBean \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanReturnsNull"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . WITH _ AUTOWIRING _ CONTEXT )  ;", "BeanFactoryPostProcessor   ppc    =     (  ( BeanFactoryPostProcessor )     ( factory . getBean (  \" propertyPlaceholderConfigurer \"  )  )  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "assertNull ( factory . getType (  \" betaFactory \"  )  )  ;", ". Alpha   alpha    =     (  (  . Alpha )     ( factory . getBean (  \" alpha \"  )  )  )  ;", ". Beta   beta    =     (  (  . Beta )     ( factory . getBean (  \" beta \"  )  )  )  ;", ". Gamma   gamma    =     (  (  . Gamma )     ( factory . getBean (  \" gamma \"  )  )  )  ;", ". Gamma   gamma 2     =     (  (  . Gamma )     ( factory . getBean (  \" gammaFactory \"  )  )  )  ;", "assertSame ( beta ,    alpha . getBeta (  )  )  ;", "assertSame ( gamma ,    beta . getGamma (  )  )  ;", "assertSame ( gamma 2  ,    beta . getGamma (  )  )  ;", "assertEquals (  \" yourName \"  ,    beta . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeansWithAutowiring"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( factory )  . loadBeanDefinitions (  . WITH _ AUTOWIRING _ CONTEXT )  ;", "BeanFactoryPostProcessor   ppc    =     (  ( BeanFactoryPostProcessor )     ( factory . getBean (  \" propertyPlaceholderConfigurer \"  )  )  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", ". Beta   beta    =     (  (  . Beta )     ( factory . getBean (  \" beta \"  )  )  )  ;", ". Alpha   alpha    =     (  (  . Alpha )     ( factory . getBean (  \" alpha \"  )  )  )  ;", ". Gamma   gamma    =     (  (  . Gamma )     ( factory . getBean (  \" gamma \"  )  )  )  ;", "assertSame ( beta ,    alpha . getBeta (  )  )  ;", "assertSame ( gamma ,    beta . getGamma (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeansWithIntermediateFactoryBeanAutowiringFailure"], "fileName": "org.springframework.beans.factory.FactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return    ( this . field )     !  =    null    ?    this . field    :    obtainMethodParameter (  )  . getAnnotatedElement (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotatedElement"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return    ( this . field )     !  =    null    ?    this . field . getAnnotation ( annotationType )     :    obtainMethodParameter (  )  . getParameterAnnotation ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . field )     !  =    null )     {", "Annota [  ]    fieldAnnotas    =    this . fieldAnnotas ;", "if    ( fieldAnnotas    =  =    null )     {", "fieldAnnotas    =    this . field . getAnnotas (  )  ;", "this . fieldAnnotas    =    fieldAnnotas ;", "}", "return   fieldAnnotas ;", "} else    {", "return   obtainMethodParameter (  )  . getParameterAnnotas (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return    ( this . field )     !  =    null    ?    this . field . getType (  )     :    obtainMethodParameter (  )  . getParameterType (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredType"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return   this . field ;", "}", "METHOD_END"], "methodName": ["getField"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return    ( this . field )     !  =    null    ?    this . field    :    obtainMethodParameter (  )  . getMember (  )  ;", "}", "METHOD_END"], "methodName": ["getMember"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return   this . methodParameter ;", "}", "METHOD_END"], "methodName": ["getMethodParameter"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . methodParameter )     !  =    null )  ,     \" Neither   Field   nor   MethodParameter \"  )  ;", "return   this . methodParameter ;", "}", "METHOD_END"], "methodName": ["obtainMethodParameter"], "fileName": "org.springframework.beans.factory.InjectionPoint"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.NoSuchBeanDefinitionException"}, {"methodBody": ["METHOD_START", "{", "return    ( this . resolvableType )     !  =    null    ?    this . resolvableType . resolve (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getBeanType"], "fileName": "org.springframework.beans.factory.NoSuchBeanDefinitionException"}, {"methodBody": ["METHOD_START", "{", "return    0  ;", "}", "METHOD_END"], "methodName": ["getNumberOfBeansFound"], "fileName": "org.springframework.beans.factory.NoSuchBeanDefinitionException"}, {"methodBody": ["METHOD_START", "{", "return   this . resolvableType ;", "}", "METHOD_END"], "methodName": ["getResolvableType"], "fileName": "org.springframework.beans.factory.NoSuchBeanDefinitionException"}, {"methodBody": ["METHOD_START", "{", "return   this . beanNamesFound ;", "}", "METHOD_END"], "methodName": ["getBeanNamesFound"], "fileName": "org.springframework.beans.factory.NoUniqueBeanDefinitionException"}, {"methodBody": ["METHOD_START", "{", "T   dependency    =    getIfAvailable (  )  ;", "return   dependency    !  =    null    ?    dependency    :    defaultSupplier . get (  )  ;", "}", "METHOD_END"], "methodName": ["getIfAvailable"], "fileName": "org.springframework.beans.factory.ObjectProvider"}, {"methodBody": ["METHOD_START", "{", "T   dependency    =    getIfUnique (  )  ;", "return   dependency    !  =    null    ?    dependency    :    defaultSupplier . get (  )  ;", "}", "METHOD_END"], "methodName": ["getIfUnique"], "fileName": "org.springframework.beans.factory.ObjectProvider"}, {"methodBody": ["METHOD_START", "{", "T   dependency    =    getIfAvailable (  )  ;", "if    ( dependency    !  =    null )     {", "dependencyConsumer . accept ( dependency )  ;", "}", "}", "METHOD_END"], "methodName": ["ifAvailable"], "fileName": "org.springframework.beans.factory.ObjectProvider"}, {"methodBody": ["METHOD_START", "{", "T   dependency    =    getIfUnique (  )  ;", "if    ( dependency    !  =    null )     {", "dependencyConsumer . accept ( dependency )  ;", "}", "}", "METHOD_END"], "methodName": ["ifUnique"], "fileName": "org.springframework.beans.factory.ObjectProvider"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isEagerInit"], "fileName": "org.springframework.beans.factory.SmartFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isPrototype"], "fileName": "org.springframework.beans.factory.SmartFactoryBean"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory    =    new   DefaultListableBeanFactory (  )  ;", "registerBeanDefinition (  \" foo \"  ,    bd )  ;", "try    {", "preInstantiateSingletons (  )  ;", "fail (  \" should   have   failed   with   BeanCreationException   due   to   incorrectly   invoked   method \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertThat ( ex . getMessage (  )  ,    equalTo ( expectedMessage )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertExceptionMessageForMisconfiguredFactoryMethod"], "fileName": "org.springframework.beans.factory.Spr5475Tests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionMessageForMisconfiguredFactoryMethod ( BeanDefinitionBuilder . rootBeanDefinition ( Spr 5  4  7  5 Tests . Foo . class )  . setFactoryMethod (  \" noArgFactory \"  )  . addConstructorArgValue (  \" bogusArg \"  )  . getBeanDefinition (  )  ,     (  \" Error   creating   bean   with   name    ' foo '  :    No   matching   factory   method   found :    factory   method    ' noArgFactory ( String )  '  .     \"     +     \" Check   that   a   method   with   the   specified   name   and   arguments   exists   and   that   it   is   static .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noArgFactoryMethodInvokedWithOneArg"], "fileName": "org.springframework.beans.factory.Spr5475Tests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionMessageForMisconfiguredFactoryMethod ( BeanDefinitionBuilder . rootBeanDefinition ( Spr 5  4  7  5 Tests . Foo . class )  . setFactoryMethod (  \" noArgFactory \"  )  . addConstructorArgValue (  \" bogusArg 1  \"  )  . addConstructorArgValue (  \" bogusArg 2  \"  . getBytes (  )  )  . getBeanDefinition (  )  ,     (  \" Error   creating   bean   with   name    ' foo '  :    No   matching   factory   method   found :    factory   method    ' noArgFactory ( String , byte [  ]  )  '  .     \"     +     \" Check   that   a   method   with   the   specified   name   and   arguments   exists   and   that   it   is   static .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noArgFactoryMethodInvokedWithTwoArgs"], "fileName": "org.springframework.beans.factory.Spr5475Tests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   def    =    new   RootBeanDefinition ( Spr 5  4  7  5 Tests . Foo . class )  ;", "def . setFactoryMethodName (  \" noArgFactory \"  )  ;", "ConstructorArgumentValues   cav    =    new   ConstructorArgumentValues (  )  ;", "cav . addIndexedArgumentValue (  0  ,     \" bogusArg 1  \"  ,    CharSequence . class . getName (  )  )  ;", "cav . addIndexedArgumentValue (  1  ,     \" bogusArg 2  \"  . getBytes (  )  )  ;", "def . setConstructorArgumentValues ( cav )  ;", "assertExceptionMessageForMisconfiguredFactoryMethod ( def ,     (  \" Error   creating   bean   with   name    ' foo '  :    No   matching   factory   method   found :    factory   method    ' noArgFactory ( CharSequence , byte [  ]  )  '  .     \"     +     \" Check   that   a   method   with   the   specified   name   and   arguments   exists   and   that   it   is   static .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["noArgFactoryMethodInvokedWithTwoArgsAndTypesSpecified"], "fileName": "org.springframework.beans.factory.Spr5475Tests"}, {"methodBody": ["METHOD_START", "{", "assertExceptionMessageForMisconfiguredFactoryMethod ( BeanDefinitionBuilder . rootBeanDefinition ( Spr 5  4  7  5 Tests . Foo . class )  . setFactoryMethod (  \" singleArgFactory \"  )  . getBeanDefinition (  )  ,     (  \" Error   creating   bean   with   name    ' foo '  :     \"     +     (  (  \" Unsatisfied   dependency   expressed   through   method    ' singleArgFactory '    parameter    0  :     \"     +     \" Ambiguous   argument   values   for   parameter   of   type    [ String ]     -     \"  )     +     \" did   you   specify   the   correct   bean   references   as   arguments ?  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["singleArgFactoryMethodInvokedWithNoArgs"], "fileName": "org.springframework.beans.factory.Spr5475Tests"}, {"methodBody": ["METHOD_START", "{", "return   this . injectionPoint ;", "}", "METHOD_END"], "methodName": ["getInjectionPoint"], "fileName": "org.springframework.beans.factory.UnsatisfiedDependencyException"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Autowire . NO . equals ( annotation . autowire (  )  )  )  )     {", "return   new    ( annotation . autowire (  )  . value (  )  ,    annotation . dependencyCheck (  )  )  ;", "} else    {", "if    (  !  (  \"  \"  . equals ( annotation . value (  )  )  )  )     {", "return   new    ( annotation . value (  )  ,    false )  ;", "} else    {", "return   new    ( getDefaultBeanName ( beanInstance )  ,    true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["buildWiringInfo"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver"}, {"methodBody": ["METHOD_START", "{", "return   ClassUtils . getUserClass ( beanInstance )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultBeanName"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . resolveWiringInfo ( null )  ;", "fail (  \" Must   have   thrown   an   IllegalArgumentException   by   this   point    ( null   argument )  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testResolveWiringInfo"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationBeanWiringInfoResolver   resolver    =    new   AnnotationBeanWiringInfoResolver (  )  ;", "BeanWiringInfo   info    =    resolver . resolveWiringInfo (  \" String   is   not    @ Configurable \"  )  ;", "assertNull (  \" Must   be   returning   null   for   a   non -  @ Configurable   class   instance \"  ,    info )  ;", "}", "METHOD_END"], "methodName": ["testResolveWiringInfoWithAnInstanceOfANonAnnotatedClass"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationBeanWiringInfoResolver   resolver    =    new   AnnotationBeanWiringInfoResolver (  )  ;", "BeanWiringInfo   info    =    resolver . resolveWiringInfo ( new    . Soap (  )  )  ;", "assertNotNull (  \" Must    * not *    be   returning   null   for   a   non -  @ Configurable   class   instance \"  ,    info )  ;", "}", "METHOD_END"], "methodName": ["testResolveWiringInfoWithAnInstanceOfAnAnnotatedClass"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationBeanWiringInfoResolver   resolver    =    new   AnnotationBeanWiringInfoResolver (  )  ;", "BeanWiringInfo   info    =    resolver . resolveWiringInfo ( new    . WirelessSoap (  )  )  ;", "assertNotNull (  \" Must    * not *    be   returning   null   for   an    @ Configurable   class   instance   even   when   autowiring   is   NO \"  ,    info )  ;", "assertFalse ( info . indicatesAutowiring (  )  )  ;", "assertEquals (  . WirelessSoap . class . getName (  )  ,    info . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveWiringInfoWithAnInstanceOfAnAnnotatedClassWithAutowiringTurnedOffExplicitly"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "AnnotationBeanWiringInfoResolver   resolver    =    new   AnnotationBeanWiringInfoResolver (  )  ;", "BeanWiringInfo   info    =    resolver . resolveWiringInfo ( new    . NamedWirelessSoap (  )  )  ;", "assertNotNull (  \" Must    * not *    be   returning   null   for   an    @ Configurable   class   instance   even   when   autowiring   is   NO \"  ,    info )  ;", "assertFalse ( info . indicatesAutowiring (  )  )  ;", "assertEquals (  \" DerBigStick \"  ,    info . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolveWiringInfoWithAnInstanceOfAnAnnotatedClassWithAutowiringTurnedOffExplicitlyAndCustomBeanName"], "fileName": "org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this )     =  =     ( Autowire . BY _ NAME )  )     |  |     (  ( this )     =  =     ( Autowire . BY _ TYPE )  )  ;", "}", "METHOD_END"], "methodName": ["isAutowire"], "fileName": "org.springframework.beans.factory.annotation.Autowire"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["value"], "fileName": "org.springframework.beans.factory.annotation.Autowire"}, {"methodBody": ["METHOD_START", "{", "LinkedList < InjectionMetadata . InjectedElement >    elements    =    new   LinkedList <  >  (  )  ;", "Class <  ?  >    targetClass    =    clazz ;", "do    {", "final   LinkedList < InjectionMetadata . InjectedElement >    currElements    =    new   LinkedList <  >  (  )  ;", "ReflectionUtils . doWithLocalFields ( targetClass ,     (    field )     -  >     {", "AnnotationAttributes   ann    =    find ( field )  ;", "if    ( ann    !  =    null )     {", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Autowired   annotation   is   not   supported   on   static   fields :     \"     +    field )  )  ;", "}", "return ;", "}", "boolean   required    =    determineRequiredStatus ( ann )  ;", "currElements . add ( new   AutowiredFieldElement ( field ,    required )  )  ;", "}", "}  )  ;", "ReflectionUtils . doWithLocalMethods ( targetClass ,     (    method )     -  >     {", "Method   bridgedMethod    =    BridgeMethodResolver . findBridgedMethod ( method )  ;", "if    (  !  ( BridgeMethodResolver . isVisibilityBridgeMethodPair ( method ,    bridgedMethod )  )  )     {", "return ;", "}", "AnnotationAttributes   ann    =    find ( bridgedMethod )  ;", "if    (  ( ann    !  =    null )     &  &     ( method . equals ( ClassUtils . getMostSpecificMethod ( method ,    clazz )  )  )  )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Autowired   annotation   is   not   supported   on   static   methods :     \"     +    method )  )  ;", "}", "return ;", "}", "if    (  ( method . getParameterCount (  )  )     =  =     0  )     {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Autowired   annotation   should   only   be   used   on   methods   with   parameters :     \"     +    method )  )  ;", "}", "}", "boolean   required    =    determineRequiredStatus ( ann )  ;", "PropertyDescriptor   pd    =    BeanUtils . findPropertyForMethod ( bridgedMethod ,    clazz )  ;", "currElements . add ( new   AutowiredMethodElement ( method ,    required ,    pd )  )  ;", "}", "}  )  ;", "elements . addAll (  0  ,    currElements )  ;", "targetClass    =    targetClass . getSuperclass (  )  ;", "}    while    (  ( targetClass    !  =    null )     &  &     ( targetClass    !  =     ( Object . class )  )     )  ;", "return   new   InjectionMetadata ( clazz ,    elements )  ;", "}", "METHOD_END"], "methodName": ["buildAutowiringMetadata"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( ann . containsKey ( this . requiredParameterName )  )  )     |  |     (  ( this . requiredParameterValue )     =  =     ( ann . getBoolean ( this . requiredParameterName )  )  )  ;", "}", "METHOD_END"], "methodName": ["determineRequiredStatus"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   BeanFactory   configured    -     \"     +     \" override   the   getBeanOfType   method   or   specify   the    ' beanFactory '    property \"  )  )  ;", "}", "return   BeanFactoryUtils . beansOfTypeIncludingAncestors ( this . beanFactory ,    type )  ;", "}", "METHOD_END"], "methodName": ["findAutowireCandidates"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ao . getAnnotations (  )  . length )     >     0  )     {", "for    ( Class <  ?    extends   Annotation >    type    :    this . aTypes )     {", "AnnotationAttributes   attributes    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( ao ,    type )  ;", "if    ( attributes    !  =    null )     {", "return   attributes ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findAutowiredAnnotation"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "String   cacheKey    =     ( StringUtils . hasLength ( beanName )  )     ?    beanName    :    clazz . getName (  )  ;", "InjectionMetadata   metadata    =    this . injectionMetadataCache . get ( cacheKey )  ;", "if    ( InjectionMetadata . needsRefresh ( metadata ,    clazz )  )     {", "synchronized ( this . injectionMetadataCache )     {", "metadata    =    this . injectionMetadataCache . get ( cacheKey )  ;", "if    ( InjectionMetadata . needsRefresh ( metadata ,    clazz )  )     {", "if    ( metadata    !  =    null )     {", "metadata . clear ( pvs )  ;", "}", "metadata    =    buildingMetadata ( clazz )  ;", "this . injectionMetadataCache . put ( cacheKey ,    metadata )  ;", "}", "}", "}", "return   metadata ;", "}", "METHOD_END"], "methodName": ["findAutowiringMetadata"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    clazz    =    bean . getClass (  )  ;", "InjectionMetadata   metadata    =    findAutowiringMetadata ( clazz . getName (  )  ,    clazz ,    null )  ;", "try    {", "metadata . inject ( bean ,    null ,    null )  ;", "}    catch    ( BeanCreationException   ex )     {", "throw   ex ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException (  (  (  \" Injection   of   a   dependencies   failed   for   class    [  \"     +    clazz )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["processInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( beanName    !  =    null )     {", "for    ( String   aBeanName    :    aBeanNames )     {", "if    (  (  ( this . beanFactory )     !  =    null )     &  &     ( this . beanFactory . containsBean ( aBeanName )  )  )     {", "this . beanFactory . registerDependentBean ( aBeanName ,    beanName )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Autowiring   by   type   from   bean   name    '  \"     +    beanName )     +     \"  '    to   bean   named    '  \"  )     +    aBeanName )     +     \"  '  \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["registerDependentBeans"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( cachedArgument   instanceof   DependencyDescriptor )     {", "DependencyDescriptor   descriptor    =     (  ( DependencyDescriptor )     ( cachedArgument )  )  ;", "Assert . state (  (  ( beanF    !  =    null )  ,     \" No   BeanFavailable \"  )  ;", "return   this . beanFresolveDependency ( descriptor ,    beanName ,    null ,    null )  ;", "} else    {", "return   cachedArgument ;", "}", "}", "METHOD_END"], "methodName": ["resolvedCachedArgument"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( autowiredAnnotationType ,     \"  ' autowiredAnnotationType '    must   not   be   null \"  )  ;", "this . autowiredAnnotationTypes . clear (  )  ;", "this . autowiredAnnotationTypes . add ( autowiredAnnotationType )  ;", "}", "METHOD_END"], "methodName": ["setAutowiredAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notEmpty ( autowiredAnnotationTypes ,     \"  ' autowiredAnnotationTypes '    must   not   be   empty \"  )  ;", "this . autowiredAnnotationTypes . clear (  )  ;", "this . autowiredAnnotationTypes . addAll ( autowiredAnnotationTypes )  ;", "}", "METHOD_END"], "methodName": ["setAutowiredAnnotationTypes"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . requiredParameterName    =    requiredParameterName ;", "}", "METHOD_END"], "methodName": ["setRequiredParameterName"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . requiredParameterValue    =    requiredParameterValue ;", "}", "METHOD_END"], "methodName": ["setRequiredParameterValue"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addBeanPostProcessor ( new   AutowiredAnnotationBeanPostProcessor (  )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedDefaultConstructorBean . class )  )  ;", "assertNotNull ( bf . getBean (  \" annotatedBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotatedDefaultConstructor"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . OptionalCollectionResourceInjectionBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    rbd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", ". FixedOrder 2 NestedTestBean   ntb 1     =    new    . FixedOrder 2 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". FixedOrder 1 NestedTestBean   ntb 2     =    new    . FixedOrder 1 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalCollectionResourceInjectionBean   bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansSetter . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansSetter . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansSetter . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOrderedCollectionResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", ". FixedOrder 2 NestedTestBean   ntb 1     =    new    . FixedOrder 2 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". FixedOrder 1 NestedTestBean   ntb 2     =    new    . FixedOrder 1 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalResourceInjectionBean   bean    =     (  (  . OptionalResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . length )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  [  0  ]  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  [  1  ]  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . length )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField [  0  ]  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField [  1  ]  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotationOrderedResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" factoryBeanDependentBean \"  ,    new   RootBeanDefinition (  . FactoryBeanDependentBean . class )  )  ;", "bf . registerSingleton (  \" stringFactoryBean \"  ,    new    . StringFactoryBean (  )  )  ;", "final    . StringFactoryBean   factoryBean    =     (  (  . StringFactoryBean )     ( bf . getBean (  \"  & stringFactoryBean \"  )  )  )  ;", "final    . FactoryBeanDependentBean   bean    =     (  (  . FactoryBeanDependentBean )     ( bf . getBean (  \" factoryBeanDependentBean \"  )  )  )  ;", "assertNotNull (  \" The   singleton   StringFactoryBean   should   have   been   registered .  \"  ,    factoryBean )  ;", "assertNotNull (  \" The   factoryBeanDependentBean   should   have   been   registered .  \"  ,    bean )  ;", "assertEquals (  \" The   FactoryBeanDependentBean   should   have   been   autowired    ' by   type '    with   the   StringFactoryBean .  \"  ,    factoryBean ,    bean . getFactoryBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testBeanAutowiredWithFactoryBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    new   RootBeanDefinition (  . MyCallable . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . SecondCallable . class )  )  ;", "bf . registerBeanDefinition (  \" bean 3  \"  ,    new   RootBeanDefinition (  . FooBar . class )  )  ;", "assertNotNull ( bf . getBean (  . FooBar . class )  )  ;", "}", "METHOD_END"], "methodName": ["testBridgeMethodHandling"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    new   RootBeanDefinition (  . StockServiceImpl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . StockMovementDaoImpl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 3  \"  ,    new   RootBeanDefinition (  . StockMovementImpl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 4  \"  ,    new   RootBeanDefinition (  . StockMovementInstructionImpl . class )  )  ;", ". StockServiceImpl   service    =    bf . getBean (  . StockServiceImpl . class )  ;", "assertSame ( bf . getBean (  . StockMovementDaoImpl . class )  ,    service . stockMovementDao )  ;", "}", "METHOD_END"], "methodName": ["testCircularTypeReference"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . CustomMapConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   tbm    =    new   RootBeanDefinition (  . CustomCollectionFactoryMethods . class )  ;", "tbm . setUniqueFactoryMethodName (  \" testBeanMap \"  )  ;", "bf . registerBeanDefinition (  \" myTestBeanMap \"  ,    tbm )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    new   TestBean (  )  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    new   TestBean (  )  )  ;", ". CustomMapConstructorInjectionBean   bean    =     (  (  . CustomMapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanMap \"  )  ,    bean . getTestBeanMap (  )  )  ;", "bean    =     (  (  . CustomMapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanMap \"  )  ,    bean . getTestBeanMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithCustomMapAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . CustomSetConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   tbs    =    new   RootBeanDefinition (  . CustomCollectionFactoryMethods . class )  ;", "tbs . setUniqueFactoryMethodName (  \" testBeanSet \"  )  ;", "bf . registerBeanDefinition (  \" myTestBeanSet \"  ,    tbs )  ;", ". CustomSetConstructorInjectionBean   bean    =     (  (  . CustomSetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanSet \"  )  ,    bean . getTestBeanSet (  )  )  ;", "bean    =     (  (  . CustomSetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanSet \"  )  ,    bean . getTestBeanSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithCustomSetAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb 1     =    new   TestBean (  \" tb 1  \"  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "RootBeanDefinition   tb 2     =    new   RootBeanDefinition (  . NullFactoryMethods . class )  ;", "tb 2  . setFactoryMethodName (  \" createTestBean \"  )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    tb 2  )  ;", ". MapConstructorInjectionBean   bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertSame ( tb 1  ,    bean . getTestBeanMap (  )  . get (  \" testBean 1  \"  )  )  ;", "assertNull ( bean . getTestBeanMap (  )  . get (  \" testBean 2  \"  )  )  ;", "bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertSame ( tb 1  ,    bean . getTestBeanMap (  )  . get (  \" testBean 1  \"  )  )  ;", "assertNull ( bean . getTestBeanMap (  )  . get (  \" testBean 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   tbm    =    new   RootBeanDefinition (  . CollectionFactoryMethods . class )  ;", "tbm . setUniqueFactoryMethodName (  \" testBeanMap \"  )  ;", "bf . registerBeanDefinition (  \" myTestBeanMap \"  ,    tbm )  ;", "bf . registerSingleton (  \" otherMap \"  ,    new   HashMap <  >  (  )  )  ;", ". MapConstructorInjectionBean   bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanMap \"  )  ,    bean . getTestBeanMap (  )  )  ;", "bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanMap \"  )  ,    bean . getTestBeanMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithPlainMapAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . SetConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   tbs    =    new   RootBeanDefinition (  . CollectionFactoryMethods . class )  ;", "tbs . setUniqueFactoryMethodName (  \" testBeanSet \"  )  ;", "bf . registerBeanDefinition (  \" myTestBeanSet \"  ,    tbs )  ;", "bf . registerSingleton (  \" otherSet \"  ,    new   HashSet <  >  (  )  )  ;", ". SetConstructorInjectionBean   bean    =     (  (  . SetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanSet \"  )  ,    bean . getTestBeanSet (  )  )  ;", "bean    =     (  (  . SetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" myTestBeanSet \"  )  ,    bean . getTestBeanSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithPlainSetAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". MyTestBeanMap   tbm    =    new    . MyTestBeanMap (  )  ;", "tbm . put (  \" testBean 1  \"  ,    new   TestBean (  \" tb 1  \"  )  )  ;", "tbm . put (  \" testBean 2  \"  ,    new   TestBean (  \" tb 2  \"  )  )  ;", "bf . registerSingleton (  \" testBeans \"  ,    tbm )  ;", "bf . registerSingleton (  \" otherMap \"  ,    new   Properties (  )  )  ;", ". MapConstructorInjectionBean   bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tbm ,    bean . getTestBeanMap (  )  )  ;", "bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tbm ,    bean . getTestBeanMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithTypedMapAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . SetConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". MyTestBeanSet   tbs    =    new    . MyTestBeanSet (  )  ;", "tbs . add ( new   TestBean (  \" tb 1  \"  )  )  ;", "tbs . add ( new   TestBean (  \" tb 2  \"  )  )  ;", "bf . registerSingleton (  \" testBeans \"  ,    tbs )  ;", "bf . registerSingleton (  \" otherSet \"  ,    new   HashSet <  >  (  )  )  ;", ". SetConstructorInjectionBean   bean    =     (  (  . SetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tbs ,    bean . getTestBeanSet (  )  )  ;", "bean    =     (  (  . SetConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tbs ,    bean . getTestBeanSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithTypedSetAsBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". ConstructorResourceInjectionBean   bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsCollectionResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "bf . registerBeanDefinition (  \" nestedTestBean 1  \"  ,    new   RootBeanDefinition (  . NullNestedTestBeanFactoryBean . class )  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsCollectionResourceInjectionBean   bean    =     (  (  . ConstructorsCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertNull ( bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "Map < String ,    NestedTestBean >    map    =    bf . getBeansOfType ( NestedTestBean . class )  ;", "assertNull ( map . get (  \" nestedTestBean 1  \"  )  )  ;", "assertSame ( ntb 2  ,    map . get (  \" nestedTestBean 2  \"  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithCollectionAndNullFromFactoryBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsResourceInjectionBean   bean    =     (  (  . ConstructorsResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . length )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  [  0  ]  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  [  1  ]  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidates"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsResourceInjectionBean . class )  )  ;", ". ConstructorsResourceInjectionBean   bean    =     (  (  . ConstructorsResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAndDefaultFallback"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". ConstructorsResourceInjectionBean   bean    =     (  (  . ConstructorsResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAndFallback"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsCollectionResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsCollectionResourceInjectionBean   bean    =     (  (  . ConstructorsCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAsCollection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsCollectionResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". FixedOrder 2 NestedTestBean   ntb 1     =    new    . FixedOrder 2 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". FixedOrder 1 NestedTestBean   ntb 2     =    new    . FixedOrder 1 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsCollectionResourceInjectionBean   bean    =     (  (  . ConstructorsCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAsOrderedCollection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". FixedOrder 2 NestedTestBean   ntb 1     =    new    . FixedOrder 2 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". FixedOrder 1 NestedTestBean   ntb 2     =    new    . FixedOrder 1 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsResourceInjectionBean   bean    =     (  (  . ConstructorsResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . length )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  [  0  ]  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  [  1  ]  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleOrderedCandidates"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorWithoutFallbackBean . class )  )  ;", "try    {", "bf . getBean (  \" annotatedBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . ConstructorWithoutFallbackBean . class ,    ex . getInjectionPoint (  )  . getMethodParameter (  )  . getDeclaringClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithNoCandidatesAndNoFallback"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "bf . registerBeanDefinition (  \" nestedTestBean \"  ,    new   RootBeanDefinition (  . NullNestedTestBeanFactoryBean . class )  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    new   NestedTestBean (  )  )  ;", ". ConstructorResourceInjectionBean   bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithNullFromFactoryBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   tb    =    new   RootBeanDefinition (  . NullFactoryMethods . class )  ;", "tb . setFactoryMethodName (  \" createTestBean \"  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    tb )  ;", "RootBeanDefinition   ntb    =    new   RootBeanDefinition (  . NullFactoryMethods . class )  ;", "ntb . setFactoryMethodName (  \" createNestedTestBean \"  )  ;", "bf . registerBeanDefinition (  \" nestedTestBean \"  ,    ntb )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    new   NestedTestBean (  )  )  ;", ". ConstructorResourceInjectionBean   bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithNullFromFactoryMethod"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalFieldResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". CustomAnnotationOptionalFieldResourceInjectionBean   bean    =     (  (  . CustomAnnotationOptionalFieldResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalFieldResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalFieldResourceInjectionBean . class )  )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationOptionalFieldResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getField (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalFieldResourceInjectionWhenMultipleDependenciesFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalFieldResourceInjectionBean . class )  )  ;", ". CustomAnnotationOptionalFieldResourceInjectionBean   bean    =     (  (  . CustomAnnotationOptionalFieldResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalFieldResourceInjectionWhenNoDependencyFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalMethodResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". CustomAnnotationOptionalMethodResourceInjectionBean   bean    =     (  (  . CustomAnnotationOptionalMethodResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalMethodResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalMethodResourceInjectionBean . class )  )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationOptionalMethodResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getMethodParameter (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalMethodResourceInjectionWhenMultipleDependenciesFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationOptionalMethodResourceInjectionBean . class )  )  ;", ". CustomAnnotationOptionalMethodResourceInjectionBean   bean    =     (  (  . CustomAnnotationOptionalMethodResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationOptionalMethodResourceInjectionWhenNoDependencyFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredFieldResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". CustomAnnotationRequiredFieldResourceInjectionBean   bean    =     (  (  . CustomAnnotationRequiredFieldResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredFieldResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredFieldResourceInjectionBean . class )  )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationRequiredFieldResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getField (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredFieldResourceInjectionFailsWhenMultipleDependenciesFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredFieldResourceInjectionBean . class )  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationRequiredFieldResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getField (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredFieldResourceInjectionFailsWhenNoDependencyFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredMethodResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". CustomAnnotationRequiredMethodResourceInjectionBean   bean    =     (  (  . CustomAnnotationRequiredMethodResourceInjectionBean )     ( bf . getBean (  \" customBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredMethodResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredMethodResourceInjectionBean . class )  )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationRequiredMethodResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getMethodParameter (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredMethodResourceInjectionFailsWhenMultipleDependenciesFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setAutowiredAnnotationType (  . MyAutowired . class )  ;", "bpp . setRequiredParameterName (  \" optional \"  )  ;", "bpp . setRequiredParameterValue ( false )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" customBean \"  ,    new   RootBeanDefinition (  . CustomAnnotationRequiredMethodResourceInjectionBean . class )  )  ;", "try    {", "bf . getBean (  \" customBean \"  )  ;", "fail (  \" Should   have   thrown   UnsatisfiedDependencyException \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . CustomAnnotationRequiredMethodResourceInjectionBean . class ,    ex . getInjectionPoint (  )  . getMethodParameter (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testCustomAnnotationRequiredMethodResourceInjectionFailsWhenNoDependencyFound"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "String [  ]    depBeans    =    bf . getDependenciesForBean (  \" annotatedBean \"  )  ;", "assertEquals (  2  ,    depBeans . length )  ;", "assertEquals (  \" testBean \"  ,    depBeans [  0  ]  )  ;", "assertEquals (  \" nestedTestBean \"  ,    depBeans [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithAtRequired"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBd    =    new   RootBeanDefinition (  . DefaultMethodResourceInjectionBean . class )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". DefaultMethodResourceInjectionBean   bean    =     (  (  . DefaultMethodResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertNull ( bean . getBeanFactory (  )  )  ;", "assertTrue ( bean . baseInjected )  ;", "assertTrue ( bean . subInjected )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithDefaultMethod"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", "TestBean   tb    =    bf . getBean (  \" testBean \"  ,    TestBean . class )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" testBean \"  ,     \" nestedTestBean \"     }  ,    bf . getDependenciesForBean (  \" annotatedBean \"  )  )  ;", "bf . destroySingleton (  \" testBean \"  )  ;", "assertFalse ( bf . containsSingleton (  \" testBean \"  )  )  ;", "assertFalse ( bf . containsSingleton (  \" annotatedBean \"  )  )  ;", "assertTrue ( bean . destroyed )  ;", "assertSame (  0  ,    bf . getDependenciesForBean (  \" annotatedBean \"  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithDestruction"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "annotatedBd . getPropertyValues (  )  . add (  \" testBean 2  \"  ,    tb 2  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithOverriding"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBd    =    new   RootBeanDefinition (  . OverriddenExtendedResourceInjectionBean . class )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". OverriddenExtendedResourceInjectionBean   bean    =     (  (  . OverriddenExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertNull ( bean . getBeanFactory (  )  )  ;", "assertTrue ( bean . baseInjected )  ;", "assertTrue ( bean . subInjected )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithSkippedOverriddenMethods"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SelfInjectingFactoryBean . class )  )  ;", ". SelfInjectingFactoryBean   bean    =    bf . getBean (  . SelfInjectingFactoryBean . class )  ;", "assertSame ( bf . getBean (  \" annotatedBean \"  )  ,    bean . testBean )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanSelfInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . SelfInjectingFactoryBean . class )  ;", "bd . setFactoryMethodName (  \" create \"  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". SelfInjectingFactoryBean   bean    =    bf . getBean (  . SelfInjectingFactoryBean . class )  ;", "assertSame ( bf . getBean (  \" annotatedBean \"  )  ,    bean . testBean )  ;", "}", "METHOD_END"], "methodName": ["testFactoryBeanSelfInjectionViaFactoryMethod"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapFieldInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb 1     =    new   TestBean (  \" tb 1  \"  )  ;", "TestBean   tb 2     =    new   TestBean (  \" tb 2  \"  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 2  )  ;", ". MapFieldInjectionBean   bean    =     (  (  . MapFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "bean    =     (  (  . MapFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryConstructorInjectionBean   bean    =     (  (  . RepositoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedConstructorInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". GenericRepository   gr    =    new    . GenericRepositorySubclass (  )  ;", "bf . registerSingleton (  \" genericRepo \"  ,    gr )  ;", ". RepositoryConstructorInjectionBean   bean    =     (  (  . RepositoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( gr ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( gr ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( gr ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( gr ,    bean . integerRepositoryMap . get (  \" genericRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedConstructorInjectionWithMixedTargets"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". SimpleRepository   ngr    =    new    . SimpleRepositorySubclass (  )  ;", "bf . registerSingleton (  \" simpleRepo \"  ,    ngr )  ;", ". RepositoryConstructorInjectionBean   bean    =     (  (  . RepositoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ngr ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ngr ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ngr ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ngr ,    bean . integerRepositoryMap . get (  \" simpleRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedConstructorInjectionWithMixedTargetsIncludingNonGeneric"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". SimpleRepository   ngr    =    new    . SimpleRepository (  )  ;", "bf . registerSingleton (  \" simpleRepo \"  ,    ngr )  ;", ". RepositoryConstructorInjectionBean   bean    =     (  (  . RepositoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( ngr ,    bean . stringRepository )  ;", "assertSame ( ngr ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( ngr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ngr ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( ngr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ngr ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( ngr ,    bean . stringRepositoryMap . get (  \" simpleRepo \"  )  )  ;", "assertSame ( ngr ,    bean . integerRepositoryMap . get (  \" simpleRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedConstructorInjectionWithNonGenericTarget"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". GenericRepository   gr    =    new    . GenericRepository (  )  ;", "bf . registerSingleton (  \" genericRepo \"  ,    gr )  ;", ". RepositoryConstructorInjectionBean   bean    =     (  (  . RepositoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( gr ,    bean . stringRepository )  ;", "assertSame ( gr ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( gr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( gr ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( gr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( gr ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( gr ,    bean . stringRepositoryMap . get (  \" genericRepo \"  )  )  ;", "assertSame ( gr ,    bean . integerRepositoryMap . get (  \" genericRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedConstructorInjectionWithNonTypedTarget"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFactoryBeanInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" repoFactoryBean \"  ,    new   RootBeanDefinition (  . RepositoryFactoryBean . class )  )  ;", ". RepositoryFactoryBeanInjectionBean   bean    =     (  (  . RepositoryFactoryBeanInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". RepositoryFactoryBean <  ?  >    repoFactoryBean    =    bf . getBean (  \"  & repoFactoryBean \"  ,     . RepositoryFactoryBean . class )  ;", "assertSame ( repoFactoryBean ,    bean . repositoryFactoryBean )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFactoryBeanInjectionWithBeanDefinition"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFactoryBeanInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "bf . registerSingleton (  \" repoFactoryBean \"  ,    new    . RepositoryFactoryBean <  >  (  )  )  ;", ". RepositoryFactoryBeanInjectionBean   bean    =     (  (  . RepositoryFactoryBeanInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". RepositoryFactoryBean <  ?  >    repoFactoryBean    =    bf . getBean (  \"  & repoFactoryBean \"  ,     . RepositoryFactoryBean . class )  ;", "assertSame ( repoFactoryBean ,    bean . repositoryFactoryBean )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFactoryBeanInjectionWithSingletonBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "String   sv    =     \" X \"  ;", "bf . registerSingleton (  \" stringValue \"  ,    sv )  ;", "Integer   iv    =     1  ;", "bf . registerSingleton (  \" integerValue \"  ,    iv )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryFieldInjectionBean   bean    =     (  (  . RepositoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sv ,    bean . string )  ;", "assertSame ( iv ,    bean . integer )  ;", "assertSame (  1  ,    bean . stringArray . length )  ;", "assertSame (  1  ,    bean . integerArray . length )  ;", "assertSame ( sv ,    bean . stringArray [  0  ]  )  ;", "assertSame ( iv ,    bean . integerArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringList . size (  )  )  ;", "assertSame (  1  ,    bean . integerList . size (  )  )  ;", "assertSame ( sv ,    bean . stringList . get (  0  )  )  ;", "assertSame ( iv ,    bean . integerList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerMap . size (  )  )  ;", "assertSame ( sv ,    bean . stringMap . get (  \" stringValue \"  )  )  ;", "assertSame ( iv ,    bean . integerMap . get (  \" integerValue \"  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithQualifiers . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  . Repository . class )  ;", "bf . registerBeanDefinition (  \" stringRepo \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  . Repository . class )  ;", "rbd . setQualifiedElement ( ReflectionUtils . findField ( getClass (  )  ,     \" integerRepositoryQualifierProvider \"  )  )  ;", "bf . registerBeanDefinition (  \" integerRepository \"  ,    rbd )  ;", ". RepositoryFieldInjectionBeanWithQualifiers   bean    =     (  (  . RepositoryFieldInjectionBeanWithQualifiers )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". Repository <  ?  >    sr    =    bf . getBean (  \" stringRepo \"  ,     . Repository . class )  ;", ". Repository <  ?  >    ir    =    bf . getBean (  \" integerRepository \"  ,     . Repository . class )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepository \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithMocks"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithQualifiers . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryFieldInjectionBeanWithQualifiers   bean    =     (  (  . RepositoryFieldInjectionBeanWithQualifiers )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithQualifiers"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithSimpleMatch . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "bf . registerSingleton (  \" repo \"  ,    new    . StringRepository (  )  )  ;", ". RepositoryFieldInjectionBeanWithSimpleMatch   bean    =     (  (  . RepositoryFieldInjectionBeanWithSimpleMatch )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". Repository <  ?  >    repo    =    bf . getBean (  \" repo \"  ,     . Repository . class )  ;", "assertSame ( repo ,    bean . repository )  ;", "assertSame ( repo ,    bean . stringRepository )  ;", "assertSame (  1  ,    bean . repositoryArray . length )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame ( repo ,    bean . repositoryArray [  0  ]  )  ;", "assertSame ( repo ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . repositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryList . get (  0  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . repositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryMap . get (  \" repo \"  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryMap . get (  \" repo \"  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" repo \"     }  ,    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . Repository . class ,    String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithSimpleMatch"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithSimpleMatch . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  . Repository . class )  ;", "bf . registerBeanDefinition (  \" repo \"  ,    rbd )  ;", ". RepositoryFieldInjectionBeanWithSimpleMatch   bean    =     (  (  . RepositoryFieldInjectionBeanWithSimpleMatch )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". Repository <  ?  >    repo    =    bf . getBean (  \" repo \"  ,     . Repository . class )  ;", "assertSame ( repo ,    bean . repository )  ;", "assertSame ( repo ,    bean . stringRepository )  ;", "assertSame (  1  ,    bean . repositoryArray . length )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame ( repo ,    bean . repositoryArray [  0  ]  )  ;", "assertSame ( repo ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . repositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryList . get (  0  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . repositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryMap . get (  \" repo \"  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryMap . get (  \" repo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithSimpleMatchAndMock"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithSimpleMatch . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setBeanClassName ( Mockito . class . getName (  )  )  ;", "rbd . setFactoryMethodName (  \" mock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   TypedStringValue (  . Repository . class . getName (  )  )  )  ;", "bf . registerBeanDefinition (  \" repo \"  ,    rbd )  ;", ". RepositoryFieldInjectionBeanWithSimpleMatch   bean    =     (  (  . RepositoryFieldInjectionBeanWithSimpleMatch )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". Repository <  ?  >    repo    =    bf . getBean (  \" repo \"  ,     . Repository . class )  ;", "assertSame ( repo ,    bean . repository )  ;", "assertSame ( repo ,    bean . stringRepository )  ;", "assertSame (  1  ,    bean . repositoryArray . length )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame ( repo ,    bean . repositoryArray [  0  ]  )  ;", "assertSame ( repo ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . repositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryList . get (  0  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . repositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame ( repo ,    bean . repositoryMap . get (  \" repo \"  )  )  ;", "assertSame ( repo ,    bean . stringRepositoryMap . get (  \" repo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithSimpleMatchAndMockito"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryFieldInjectionBeanWithSubstitutedVariables . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "String   sv    =     \" X \"  ;", "bf . registerSingleton (  \" stringValue \"  ,    sv )  ;", "Integer   iv    =     1  ;", "bf . registerSingleton (  \" integerValue \"  ,    iv )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryFieldInjectionBeanWithSubstitutedVariables   bean    =     (  (  . RepositoryFieldInjectionBeanWithSubstitutedVariables )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sv ,    bean . string )  ;", "assertSame ( iv ,    bean . integer )  ;", "assertSame (  1  ,    bean . stringArray . length )  ;", "assertSame (  1  ,    bean . integerArray . length )  ;", "assertSame ( sv ,    bean . stringArray [  0  ]  )  ;", "assertSame ( iv ,    bean . integerArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringList . size (  )  )  ;", "assertSame (  1  ,    bean . integerList . size (  )  )  ;", "assertSame ( sv ,    bean . stringList . get (  0  )  )  ;", "assertSame ( iv ,    bean . integerList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerMap . size (  )  )  ;", "assertSame ( sv ,    bean . stringMap . get (  \" stringValue \"  )  )  ;", "assertSame ( iv ,    bean . integerMap . get (  \" integerValue \"  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedFieldInjectionWithSubstitutedVariables"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . GenericInterface 1 Impl . class )  ;", "bd . setFactoryMethodName (  \" create \"  )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . GenericInterface 2 Impl . class )  )  ;", ". GenericInterface 1 Impl   bean 1     =     (  (  . GenericInterface 1 Impl )     ( bf . getBean (  \" bean 1  \"  )  )  )  ;", ". GenericInterface 2 Impl   bean 2     =     (  (  . GenericInterface 2 Impl )     ( bf . getBean (  \" bean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean 1  . gi 2  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedInjectionIntoMatchingTypeVariable"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . GenericInterface 1 Impl . class )  ;", "bd . setFactoryMethodName (  \" create \"  )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . GenericInterface 2 Impl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2 a \"  ,    new   RootBeanDefinition (  . ReallyGenericInterface 2 Impl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2 b \"  ,    new   RootBeanDefinition (  . PlainGenericInterface 2 Impl . class )  )  ;", ". GenericInterface 1 Impl   bean 1     =     (  (  . GenericInterface 1 Impl )     ( bf . getBean (  \" bean 1  \"  )  )  )  ;", ". GenericInterface 2 Impl   bean 2     =     (  (  . GenericInterface 2 Impl )     ( bf . getBean (  \" bean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean 1  . gi 2  )  ;", "assertArrayEquals ( new   String [  ]  {     \" bean 1  \"     }  ,    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . GenericInterface 1  . class ,    String . class )  )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" bean 2  \"     }  ,    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . GenericInterface 2  . class ,    String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedInjectionIntoTypeVariableSelectingBestMatch"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . GenericInterface 1 Impl . class )  ;", "bd . setFactoryMethodName (  \" createErased \"  )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . GenericInterface 2 Impl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2 a \"  ,    new   RootBeanDefinition (  . ReallyGenericInterface 2 Impl . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2 b \"  ,    new   RootBeanDefinition (  . PlainGenericInterface 2 Impl . class )  )  ;", ". GenericInterface 1 Impl   bean 1     =     (  (  . GenericInterface 1 Impl )     ( bf . getBean (  \" bean 1  \"  )  )  )  ;", ". GenericInterface 2 Impl   bean 2     =     (  (  . GenericInterface 2 Impl )     ( bf . getBean (  \" bean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean 1  . gi 2  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedInjectionIntoTypeVariableSelectingBestMatchAgainstFactoryMethodSignature"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . GenericInterface 1 Impl . class )  ;", "bd . setFactoryMethodName (  \" createPlain \"  )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    new   RootBeanDefinition (  . GenericInterface 2 Impl . class )  )  ;", ". GenericInterface 1 Impl   bean 1     =     (  (  . GenericInterface 1 Impl )     ( bf . getBean (  \" bean 1  \"  )  )  )  ;", ". GenericInterface 2 Impl   bean 2     =     (  (  . GenericInterface 2 Impl )     ( bf . getBean (  \" bean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean 1  . gi 2  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedInjectionIntoUnresolvedTypeVariable"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition (  . GenericInterface 2 Bean . class )  ;", "bd 1  . setTargetType ( ResolvableType . forClassWithGenerics (  . GenericInterface 2 Bean . class ,    String . class )  )  ;", "bf . registerBeanDefinition (  \" bean 1  \"  ,    bd 1  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition (  . GenericInterface 2 Bean . class )  ;", "bd 2  . setTargetType ( ResolvableType . forClassWithGenerics (  . GenericInterface 2 Bean . class ,    Integer . class )  )  ;", "bf . registerBeanDefinition (  \" bean 2  \"  ,    bd 2  )  ;", "bf . registerBeanDefinition (  \" bean 3  \"  ,    new   RootBeanDefinition (  . MultiGenericFieldInjection . class )  )  ;", "assertEquals (  \" bean 1    a   bean 2     1  2  3  \"  ,    bf . getBean (  \" bean 3  \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedInjectionWithBeanDefinitionTargetResolvableType"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryMethodInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "String   sv    =     \" X \"  ;", "bf . registerSingleton (  \" stringValue \"  ,    sv )  ;", "Integer   iv    =     1  ;", "bf . registerSingleton (  \" integerValue \"  ,    iv )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryMethodInjectionBean   bean    =     (  (  . RepositoryMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sv ,    bean . string )  ;", "assertSame ( iv ,    bean . integer )  ;", "assertSame (  1  ,    bean . stringArray . length )  ;", "assertSame (  1  ,    bean . integerArray . length )  ;", "assertSame ( sv ,    bean . stringArray [  0  ]  )  ;", "assertSame ( iv ,    bean . integerArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringList . size (  )  )  ;", "assertSame (  1  ,    bean . integerList . size (  )  )  ;", "assertSame ( sv ,    bean . stringList . get (  0  )  )  ;", "assertSame ( iv ,    bean . integerList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerMap . size (  )  )  ;", "assertSame ( sv ,    bean . stringMap . get (  \" stringValue \"  )  )  ;", "assertSame ( iv ,    bean . integerMap . get (  \" integerValue \"  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedMethodInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . RepositoryMethodInjectionBeanWithSubstitutedVariables . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "String   sv    =     \" X \"  ;", "bf . registerSingleton (  \" stringValue \"  ,    sv )  ;", "Integer   iv    =     1  ;", "bf . registerSingleton (  \" integerValue \"  ,    iv )  ;", ". StringRepository   sr    =    new    . StringRepository (  )  ;", "bf . registerSingleton (  \" stringRepo \"  ,    sr )  ;", ". IntegerRepository   ir    =    new    . IntegerRepository (  )  ;", "bf . registerSingleton (  \" integerRepo \"  ,    ir )  ;", ". RepositoryMethodInjectionBeanWithSubstitutedVariables   bean    =     (  (  . RepositoryMethodInjectionBeanWithSubstitutedVariables )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( sv ,    bean . string )  ;", "assertSame ( iv ,    bean . integer )  ;", "assertSame (  1  ,    bean . stringArray . length )  ;", "assertSame (  1  ,    bean . integerArray . length )  ;", "assertSame ( sv ,    bean . stringArray [  0  ]  )  ;", "assertSame ( iv ,    bean . integerArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringList . size (  )  )  ;", "assertSame (  1  ,    bean . integerList . size (  )  )  ;", "assertSame ( sv ,    bean . stringList . get (  0  )  )  ;", "assertSame ( iv ,    bean . integerList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerMap . size (  )  )  ;", "assertSame ( sv ,    bean . stringMap . get (  \" stringValue \"  )  )  ;", "assertSame ( iv ,    bean . integerMap . get (  \" integerValue \"  )  )  ;", "assertSame ( sr ,    bean . stringRepository )  ;", "assertSame ( ir ,    bean . integerRepository )  ;", "assertSame (  1  ,    bean . stringRepositoryArray . length )  ;", "assertSame (  1  ,    bean . integerRepositoryArray . length )  ;", "assertSame ( sr ,    bean . stringRepositoryArray [  0  ]  )  ;", "assertSame ( ir ,    bean . integerRepositoryArray [  0  ]  )  ;", "assertSame (  1  ,    bean . stringRepositoryList . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryList . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryList . get (  0  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryList . get (  0  )  )  ;", "assertSame (  1  ,    bean . stringRepositoryMap . size (  )  )  ;", "assertSame (  1  ,    bean . integerRepositoryMap . size (  )  )  ;", "assertSame ( sr ,    bean . stringRepositoryMap . get (  \" stringRepo \"  )  )  ;", "assertSame ( ir ,    bean . integerRepositoryMap . get (  \" integerRepo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericsBasedMethodInjectionWithSubstitutedVariables"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bpp    =    new    (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   GenericBeanDefinition (  )  )  ;", "try    {", "bf . getBean (  \" testBean \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIncompleteBeanDefinition"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". MapMethodInjectionBean   bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "try    {", "bf . getBean (  \" annotatedBean \"  )  ;", "fail (  \" should   have   failed ,    more   than   one   bean   of   type \"  )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "assertSame (  . MapMethodInjectionBean . class ,    ex . getInjectionPoint (  )  . getMethodParameter (  )  . getDeclaringClass (  )  )  ;", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMapAndMultipleMatches"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "RootBeanDefinition   rbd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd 2  . setAutowireCandidate ( false )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    rbd 2  )  ;", ". MapMethodInjectionBean   bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean 1  \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMapAndMultipleMatchesButOnlyOneAutowireCandidate"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  )  ;", ". MapMethodInjectionBean   bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBeanMap (  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMapAndNoMatches"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryConstructorInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryConstructorInjectionBean   bean    =     (  (  . ObjectFactoryConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryConstructorInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryFieldInjectionBean   bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryFieldInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBeanDefinition    =    new   RootBeanDefinition (  . ObjectFactoryFieldInjectionBean . class )  ;", "annotatedBeanDefinition . setScope ( BeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBeanDefinition )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryFieldInjectionBean   bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", ". ObjectFactoryFieldInjectionBean   anotherBean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotSame ( anotherBean ,    bean )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    anotherBean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryInjectionIntoPrototypeBean"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryQualifierInjectionBean . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" testBean \"  )  )  ;", "bf . registerBeanDefinition (  \" dependencyBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" dependencyBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryQualifierInjectionBean   bean    =     (  (  . ObjectFactoryQualifierInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" dependencyBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryQualifierInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryQualifierInjectionBean . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setQualifiedElement ( ReflectionUtils . findMethod ( getClass (  )  ,     \" testBeanQualifierProvider \"  )  )  ;", "bf . registerBeanDefinition (  \" dependencyBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" dependencyBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryQualifierInjectionBean   bean    =     (  (  . ObjectFactoryQualifierInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" dependencyBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryQualifierProviderInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryFieldInjectionBean   bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactorySerialization"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . OptionalCollectionResourceInjectionBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    rbd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalCollectionResourceInjectionBean   bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansSetter . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansSetter . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansSetter . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalCollectionResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . OptionalCollectionResourceInjectionBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    rbd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". OptionalCollectionResourceInjectionBean   bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  1  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertEquals (  1  ,    bean . nestedTestBeansSetter . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansSetter . get (  0  )  )  ;", "assertEquals (  1  ,    bean . nestedTestBeansField . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField . get (  0  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalCollectionResourceInjectionWithSingleElement"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalResourceInjectionBean   bean    =     (  (  . OptionalResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . length )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  [  0  ]  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  [  1  ]  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . length )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField [  0  ]  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField [  1  ]  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". OptionalResourceInjectionBean   bean    =     (  (  . OptionalResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBeans (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalResourceInjectionWithIncompleteDependencies"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalResourceInjectionBean . class )  )  ;", ". OptionalResourceInjectionBean   bean    =     (  (  . OptionalResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "assertNull ( bean . getTestBean 2  (  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "assertNull ( bean . getNestedTestBeans (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalResourceInjectionWithNoDependencies"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . OptionalCollectionResourceInjectionBean . class )  ;", "rbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    rbd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", ". OrderedNestedTestBean   ntb 1     =    new    . OrderedNestedTestBean (  )  ;", "ntb 1  . setOrder (  2  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". OrderedNestedTestBean   ntb 2     =    new    . OrderedNestedTestBean (  )  ;", "ntb 2  . setOrder (  1  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalCollectionResourceInjectionBean   bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "bean    =     (  (  . OptionalCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansSetter . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansSetter . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansSetter . get (  1  )  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOrderedCollectionResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "IndexedTestBean   itb    =    new   IndexedTestBean (  )  ;", "bf . registerSingleton (  \" indexedTestBean \"  ,    itb )  ;", ". OrderedNestedTestBean   ntb 1     =    new    . OrderedNestedTestBean (  )  ;", "ntb 1  . setOrder (  2  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". OrderedNestedTestBean   ntb 2     =    new    . OrderedNestedTestBean (  )  ;", "ntb 2  . setOrder (  1  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". OptionalResourceInjectionBean   bean    =     (  (  . OptionalResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( itb ,    bean . getIndexedTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . length )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  [  0  ]  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  [  1  ]  )  ;", "assertEquals (  2  ,    bean . nestedTestBeansField . length )  ;", "assertSame ( ntb 2  ,    bean . nestedTestBeansField [  0  ]  )  ;", "assertSame ( ntb 1  ,    bean . nestedTestBeansField [  1  ]  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOrderedResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SelfInjectionBean . class )  )  ;", ". SelfInjectionBean   bean    =     (  (  . SelfInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bean ,    bean . reference )  ;", "assertNull ( bean . referenceCollection )  ;", "}", "METHOD_END"], "methodName": ["testSelfReference"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SelfInjectionCollectionBean . class )  )  ;", ". SelfInjectionCollectionBean   bean    =     (  (  . SelfInjectionCollectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bean ,    bean . reference )  ;", "assertNull ( bean . referenceCollection )  ;", "}", "METHOD_END"], "methodName": ["testSelfReferenceCollection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SelfInjectionCollectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean 2  \"  ,    new   RootBeanDefinition (  . SelfInjectionCollectionBean . class )  )  ;", ". SelfInjectionCollectionBean   bean    =     (  (  . SelfInjectionCollectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". SelfInjectionCollectionBean   bean 2     =     (  (  . SelfInjectionCollectionBean )     ( bf . getBean (  \" annotatedBean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean . reference )  ;", "assertSame (  1  ,    bean 2  . referenceCollection . size (  )  )  ;", "assertSame ( bean 2  ,    bean . referenceCollection . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelfReferenceCollectionWithOther"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SelfInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean 2  \"  ,    new   RootBeanDefinition (  . SelfInjectionBean . class )  )  ;", ". SelfInjectionBean   bean    =     (  (  . SelfInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", ". SelfInjectionBean   bean 2     =     (  (  . SelfInjectionBean )     ( bf . getBean (  \" annotatedBean 2  \"  )  )  )  ;", "assertSame ( bean 2  ,    bean . reference )  ;", "assertEquals (  1  ,    bean . referenceCollection . size (  )  )  ;", "assertSame ( bean 2  ,    bean . referenceCollection . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSelfReferenceWithOther"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SingleConstructorCollectionInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". SingleConstructorCollectionInjectionBean   bean    =     (  (  . SingleConstructorCollectionInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertNull ( bean . getNestedTestBeans (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConstructorInjectionWithEmptyCollection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SingleConstructorCollectionInjectionBean . class )  )  ;", "bf . getBean (  \" annotatedBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConstructorInjectionWithMissingDependency"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setDependencyComparator ( INSTANCE )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SingleConstructorCollectionInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". FixedOrder 2 NestedTestBean   ntb 1     =    new    . FixedOrder 2 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", ". FixedOrder 1 NestedTestBean   ntb 2     =    new    . FixedOrder 1 NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". SingleConstructorCollectionInjectionBean   bean    =     (  (  . SingleConstructorCollectionInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConstructorInjectionWithMultipleCandidatesAsOrderedCollection"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SingleConstructorCollectionInjectionBean . class )  )  ;", "RootBeanDefinition   tb    =    new   RootBeanDefinition (  . NullFactoryMethods . class )  ;", "tb . setFactoryMethodName (  \" createTestBean \"  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    tb )  ;", "bf . getBean (  \" annotatedBean \"  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConstructorInjectionWithNullDependency"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ProvidedArgumentBean . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Collections . singletonList (  \" value \"  )  )  ;", "bf . registerBeanDefinition (  \" beanWithArgs \"  ,    bd )  ;", "assertNotNull ( bf . getBean (  . ProvidedArgumentBean . class )  )  ;", "}", "METHOD_END"], "methodName": ["testSingleConstructorWithProvidedArgument"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SmartObjectFactoryInjectionBean . class )  )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    tbd )  ;", ". SmartObjectFactoryInjectionBean   bean    =     (  (  . SmartObjectFactoryInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  ,     \" myName \"  )  ,    bean . getTestBean (  \" myName \"  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . getOptionalTestBean (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . getOptionalTestBeanWithDefault (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . consumeOptionalTestBean (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . getUniqueTestBean (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . getUniqueTestBeanWithDefault (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . consumeUniqueTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSmartObjectFactoryInjectionWithPrototype"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SmartObjectFactoryInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". SmartObjectFactoryInjectionBean   bean    =     (  (  . SmartObjectFactoryInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getOptionalTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getOptionalTestBeanWithDefault (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . consumeOptionalTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getUniqueTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getUniqueTestBeanWithDefault (  )  )  ;", "assertEquals ( bf . getBean (  \" testBean \"  )  ,    bean . consumeUniqueTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSmartObjectFactoryInjectionWithSingletonTarget"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SmartObjectFactoryInjectionBean . class )  )  ;", ". SmartObjectFactoryInjectionBean   bean    =     (  (  . SmartObjectFactoryInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "try    {", "bean . getTestBean (  )  ;", "fail (  \" Should   have   thrown   NoSuchBeanDefinitionException \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "assertNull ( bean . getOptionalTestBean (  )  )  ;", "assertNull ( bean . consumeOptionalTestBean (  )  )  ;", "assertEquals ( new   TestBean (  \" default \"  )  ,    bean . getOptionalTestBeanWithDefault (  )  )  ;", "assertEquals ( new   TestBean (  \" default \"  )  ,    bean . getUniqueTestBeanWithDefault (  )  )  ;", "assertNull ( bean . getUniqueTestBean (  )  )  ;", "assertNull ( bean . consumeUniqueTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSmartObjectFactoryInjectionWithTargetNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SmartObjectFactoryInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". SmartObjectFactoryInjectionBean   bean    =     (  (  . SmartObjectFactoryInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "try    {", "bean . getTestBean (  )  ;", "fail (  \" Should   have   thrown   NoUniqueBeanDefinitionException \"  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "}", "try    {", "bean . getOptionalTestBean (  )  ;", "fail (  \" Should   have   thrown   NoUniqueBeanDefinitionException \"  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "}", "try    {", "bean . consumeOptionalTestBean (  )  ;", "fail (  \" Should   have   thrown   NoUniqueBeanDefinitionException \"  )  ;", "}    catch    ( NoUniqueBeanDefinitionException   ex )     {", "}", "assertNull ( bean . getUniqueTestBean (  )  )  ;", "assertNull ( bean . consumeUniqueTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSmartObjectFactoryInjectionWithTargetNotUnique"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . SmartObjectFactoryInjectionBean . class )  )  ;", "RootBeanDefinition   tb 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "tb 1  . setPrimary ( true )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    tb 1  )  ;", "RootBeanDefinition   tb 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "tb 2  . setLazyInit ( true )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    tb 2  )  ;", ". SmartObjectFactoryInjectionBean   bean    =     (  (  . SmartObjectFactoryInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean 1  \"  )  ,    bean . getTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean 1  \"  )  ,    bean . getOptionalTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean 1  \"  )  ,    bean . consumeOptionalTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean 1  \"  )  ,    bean . getUniqueTestBean (  )  )  ;", "assertSame ( bf . getBean (  \" testBean 1  \"  )  ,    bean . consumeUniqueTestBean (  )  )  ;", "assertFalse ( bf . containsSingleton (  \" testBean 2  \"  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testSmartObjectFactoryInjectionWithTargetPrimary"], "fileName": "org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "if    ( qualifier . test ( beanName )  )     {", "return   true ;", "}", "if    ( beanFactory    !  =    null )     {", "for    ( String   alias    :    beanFactory . getAliases ( beanName )  )     {", "if    ( qualifier . test ( alias )  )     {", "return   true ;", "}", "}", "try    {", "if    ( beanFactory   instanceof   ConfigurableBeanFactory )     {", "BeanDefinition   bd    =     (  ( ConfigurableBeanFactory )     ( beanFactory )  )  . getMergedBeanDefinition ( beanName )  ;", "if    ( bd   instanceof   AbstractBeanDefinition )     {", "AbstractBeanDefinition   abd    =     (  ( AbstractBeanDefinition )     ( bd )  )  ;", "AutowireCandidateQualifier   candidate    =    abd . getQualifier ( Qualifier . class . getName (  )  )  ;", "if    ( candidate    !  =    null )     {", "Object   value    =    candidate . getAttribute ( AutowireCandidateQualifier . VALUE _ KEY )  ;", "if    (  ( value    !  =    null )     &  &     ( qualifier . test ( value . toString (  )  )  )  )     {", "return   true ;", "}", "}", "}", "if    ( bd   instanceof   RootBeanDefinition )     {", "Method   factoryMethod    =     (  ( RootBeanDefinition )     ( bd )  )  . getResolvedFactoryMethod (  )  ;", "if    ( factoryMethod    !  =    null )     {", "Qualifier   targetAnnotation    =     . getAnnotation ( factoryMethod ,    Qualifier . class )  ;", "if    ( targetAnnotation    !  =    null )     {", "return   qualifier . test ( targetAnnotation . value (  )  )  ;", "}", "}", "}", "}", "Class <  ?  >    beanType    =    beanFactory . getType ( beanName )  ;", "if    ( beanType    !  =    null )     {", "Qualifier   targetAnnotation    =     . getAnnotation ( beanType ,    Qualifier . class )  ;", "if    ( targetAnnotation    !  =    null )     {", "return   qualifier . test ( targetAnnotation . value (  )  )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isQualifierMatch"], "fileName": "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanFactory ,     \" BeanFactory   must   not   be   null \"  )  ;", "if    ( beanFactory   instanceof   ConfigurableListableBeanFactory )     {", "return   BeanFactoryAnnotationUtils . qualifiedBeanOfType (  (  ( ConfigurableListableBeanFactory )     ( beanFactory )  )  ,    beanType ,    qualifier )  ;", "} else", "if    ( beanFactory . containsBean ( qualifier )  )     {", "return   beanFactory . getBean ( qualifier ,    beanType )  ;", "} else    {", "throw   new   NoSuchBeanDefinitionException ( qualifier ,     (  (  (  (  (  \" No   matching    \"     +     ( beanType . getSimpleName (  )  )  )     +     \"    bean   found   for   bean   name    '  \"  )     +    qualifier )     +     \"  '  !     ( Note :    Qualifier   matching   not   supported   because   given    \"  )     +     \" BeanFactory   does   not   implement   ConfigurableListableBeanFactory .  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["qualifiedBeanOfType"], "fileName": "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "String [  ]    candidateBeans    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( bf ,    beanType )  ;", "String   matchingBean    =    null ;", "for    ( String   beanName    :    candidateBeans )     {", "if    ( BeanFactoryAnnotationUtils . isQualifierMatch ( qualifier :  : equals ,    beanName ,    bf )  )     {", "if    ( matchingBean    !  =    null )     {", "throw   new   NoUniqueBeanDefinitionException ( beanType ,    matchingBean ,    beanName )  ;", "}", "matchingBean    =    beanName ;", "}", "}", "if    ( matchingBean    !  =    null )     {", "return   bf . getBean ( matchingBean ,    beanType )  ;", "} else", "if    ( bf . containsBean ( qualifier )  )     {", "return   bf . getBean ( qualifier ,    beanType )  ;", "} else    {", "throw   new   NoSuchBeanDefinitionException ( qualifier ,     (  (  (  (  \" No   matching    \"     +     ( beanType . getSimpleName (  )  )  )     +     \"    bean   found   for   qualifier    '  \"  )     +    qualifier )     +     \"  '     -    neither   qualifier   match   nor   bean   name   match !  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["qualifiedBeanOfType"], "fileName": "org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils"}, {"methodBody": ["METHOD_START", "{", "this . customQualifierTypes    =    customQualifierTypes ;", "}", "METHOD_END"], "methodName": ["setCustomQualifierTypes"], "fileName": "org.springframework.beans.factory.annotation.CustomAutowireConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.annotation.CustomAutowireConfigurer"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . loadBeanDefinitions (  . CONTEXT )  ;", "CustomAutowireConfigurer   cac    =    new   CustomAutowireConfigurer (  )  ;", ". CustomResolver   customResolver    =    new    . CustomResolver (  )  ;", "bf . setAutowireCandidateResolver ( customResolver )  ;", "cac . postProcessBeanFactory ( bf )  ;", ". TestBean   testBean    =     (  (  . TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \"  #  1  !  \"  ,    testBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomResolver"], "fileName": "org.springframework.beans.factory.annotation.CustomAutowireConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "final   boolean   debug    =    logger . isDebugEnabled (  )  ;", "LinkedList <  . LifecycleElement >    initMethods    =    new   LinkedList <  >  (  )  ;", "LinkedList <  . LifecycleElement >    destroyMethods    =    new   LinkedList <  >  (  )  ;", "Class <  ?  >    targetClass    =    clazz ;", "do    {", "final   LinkedList <  . LifecycleElement >    currInitMethods    =    new   LinkedList <  >  (  )  ;", "final   LinkedList <  . LifecycleElement >    currDestroyMethods    =    new   LinkedList <  >  (  )  ;", "ReflectionUtils . doWithLocalMethods ( targetClass ,     (    method )     -  >     {", "if    (  (  ( initAnnotationType )     !  =    null )     &  &     ( method . isAnnotationPresent ( initAnnotationType )  )  )     {", "LifecycleElement   element    =    new   LifecycleElement ( method )  ;", "currInitMethods . add ( element )  ;", "if    ( debug )     {", "logger . debug (  (  (  (  \" Found   init   method   on   class    [  \"     +     ( clazz . getName (  )  )  )     +     \"  ]  :     \"  )     +    method )  )  ;", "}", "}", "if    (  (  ( destroyAnnotationType )     !  =    null )     &  &     ( method . isAnnotationPresent ( destroyAnnotationType )  )  )     {", "currDestroyMethods . add ( new   LifecycleElement ( method )  )  ;", "if    ( debug )     {", "logger . debug (  (  (  (  \" Found   destroy   method   on   class    [  \"     +     ( clazz . getName (  )  )  )     +     \"  ]  :     \"  )     +    method )  )  ;", "}", "}", "}  )  ;", "initMethods . addAll (  0  ,    currInitMethods )  ;", "destroyMethods . addAll ( currDestroyMethods )  ;", "targetClass    =    targetClass . getSuperclass (  )  ;", "}    while    (  ( targetClass    !  =    null )     &  &     ( targetClass    !  =     ( Object . class )  )     )  ;", "return   new    . LifecycleMetadata ( clazz ,    initMethods ,    destroyMethods )  ;", "}", "METHOD_END"], "methodName": ["buildLifecycleMetadata"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . lifecycleMetadataCache )     =  =    null )     {", "return   buildLifecycleMetadata ( clazz )  ;", "}", ". LifecycleMetadata   metadata    =    this . lifecycleMetadataCache . get ( clazz )  ;", "if    ( metadata    =  =    null )     {", "synchronized ( this . lifecycleMetadataCache )     {", "metadata    =    this . lifecycleMetadataCache . get ( clazz )  ;", "if    ( metadata    =  =    null )     {", "metadata    =    buildLifecycleMetadata ( clazz )  ;", "this . lifecycleMetadataCache . put ( clazz ,    metadata )  ;", "}", "return   metadata ;", "}", "}", "return   metadata ;", "}", "METHOD_END"], "methodName": ["findLifecycleMetadata"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "this . logger    =    LogFgetLog ( getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . destroyAnnotationType    =    destroyAnnotationType ;", "}", "METHOD_END"], "methodName": ["setDestroyAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . initAnnotationType    =    initAnnotationType ;", "}", "METHOD_END"], "methodName": ["setInitAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addBeanPostProcessor ( new   AutowiredAnnotationBeanPostProcessor (  )  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . AnnotatedDefaultConstructorBean . class )  )  ;", "assertNotNull ( bf . getBean (  \" annotatedBean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnnotatedDefaultConstructor"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" factoryBeanDependentBean \"  ,    new   RootBeanDefinition (  . FactoryBeanDependentBean . class )  )  ;", "bf . registerSingleton (  \" stringFactoryBean \"  ,    new    . StringFactoryBean (  )  )  ;", "final    . StringFactoryBean   factoryBean    =     (  (  . StringFactoryBean )     ( bf . getBean (  \"  & stringFactoryBean \"  )  )  )  ;", "final    . FactoryBeanDependentBean   bean    =     (  (  . FactoryBeanDependentBean )     ( bf . getBean (  \" factoryBeanDependentBean \"  )  )  )  ;", "assertNotNull (  \" The   singleton   StringFactoryBean   should   have   been   registered .  \"  ,    factoryBean )  ;", "assertNotNull (  \" The   factoryBeanDependentBean   should   have   been   registered .  \"  ,    bean )  ;", "assertEquals (  \" The   FactoryBeanDependentBean   should   have   been   autowired    ' by   type '    with   the   StringFactoryBean .  \"  ,    factoryBean ,    bean . getFactoryBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testBeanAutowiredWithFactoryBean"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapConstructorInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 1  )  ;", ". MapConstructorInjectionBean   bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "bean    =     (  (  . MapConstructorInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ConstructorResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". ConstructorResourceInjectionBean   bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . ConstructorResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". ConstructorsResourceInjectionBean   bean    =     (  (  . ConstructorsResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertNull ( bean . getTestBean 4  (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAndFallback"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ConstructorsCollectionResourceInjectionBean . class )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb 1     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 1  \"  ,    ntb 1  )  ;", "NestedTestBean   ntb 2     =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean 2  \"  ,    ntb 2  )  ;", ". ConstructorsCollectionResourceInjectionBean   bean    =     (  (  . ConstructorsCollectionResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertEquals (  2  ,    bean . getNestedTestBeans (  )  . size (  )  )  ;", "assertSame ( ntb 1  ,    bean . getNestedTestBeans (  )  . get (  0  )  )  ;", "assertSame ( ntb 2  ,    bean . getNestedTestBeans (  )  . get (  1  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testConstructorResourceInjectionWithMultipleCandidatesAsCollection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithAtRequired"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerResolvableDependency ( BeanFactory . class ,    bf )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBd    =    new   RootBeanDefinition (  . TypedExtendedResourceInjectionBean . class )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "annotatedBd . getPropertyValues (  )  . add (  \" testBean 2  \"  ,    tb 2  )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", "NestedTestBean   ntb    =    new   NestedTestBean (  )  ;", "bf . registerSingleton (  \" nestedTestBean \"  ,    ntb )  ;", ". TypedExtendedResourceInjectionBean   bean    =     (  (  . TypedExtendedResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb 2  ,    bean . getTestBean 2  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 3  (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 4  (  )  )  ;", "assertSame ( ntb ,    bean . getNestedTestBean (  )  )  ;", "assertSame ( bf ,    bean . getBeanFactory (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testExtendedResourceInjectionWithOverriding"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapFieldInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean 1  \"  ,    tb 1  )  ;", "bf . registerSingleton (  \" testBean 2  \"  ,    tb 1  )  ;", ". MapFieldInjectionBean   bean    =     (  (  . MapFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "bean    =     (  (  . MapFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  2  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 2  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 1  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testFieldInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "Autowired   bpp    =    new   Autowired (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   GenericBeanDefinition (  )  )  ;", "try    {", "bf . getBean (  \" testBean \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getRootCause (  )  )    instanceof   IllegalStateException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIncompleteBeanDefinition"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". MapMethodInjectionBean   bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMap"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "try    {", "bf . getBean (  \" annotatedBean \"  )  ;", "fail (  \" should   have   failed ,    more   than   one   bean   of   type \"  )  ;", "}    catch    ( BeanCreationException   e )     {", "}", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMapAndMultipleMatches"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . MapMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean 1  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "RootBeanDefinition   rbd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "rbd 2  . setAutowireCandidate ( false )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    rbd 2  )  ;", ". MapMethodInjectionBean   bean    =     (  (  . MapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" testBean 1  \"  )  )  )  ;", "assertEquals (  1  ,    bean . getTestBeanMap (  )  . size (  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . keySet (  )  . contains (  \" testBean 1  \"  )  )  ;", "assertTrue ( bean . getTestBeanMap (  )  . values (  )  . contains ( tb )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testMethodInjectionWithMapAndMultipleMatchesButOnlyOneAutowireCandidate"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . NullableFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". NullableFieldInjectionBean   bean    =     (  (  . NullableFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testNullableFieldInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . NullableFieldInjectionBean . class )  )  ;", ". NullableFieldInjectionBean   bean    =     (  (  . NullableFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testNullableFieldInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . NullableMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". NullableMethodInjectionBean   bean    =     (  (  . NullableMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testNullableMethodInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . NullableMethodInjectionBean . class )  )  ;", ". NullableMethodInjectionBean   bean    =     (  (  . NullableMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNull ( bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testNullableMethodInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBeanDefinition    =    new   RootBeanDefinition (  . ObjectFactoryQualifierFieldInjectionBean . class )  ;", "annotatedBeanDefinition . setScope ( BeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBeanDefinition )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" testBean \"  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryQualifierFieldInjectionBean   bean    =     (  (  . ObjectFactoryQualifierFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", ". ObjectFactoryQualifierFieldInjectionBean   anotherBean    =     (  (  . ObjectFactoryQualifierFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotSame ( anotherBean ,    bean )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryFieldInjectionIntoPrototypeBean"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryQualifierFieldInjectionBean . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" testBean \"  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryQualifierFieldInjectionBean   bean    =     (  (  . ObjectFactoryQualifierFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryInjection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   QualifierAnnotationAutowireCandidateResolver (  )  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   annotatedBeanDefinition    =    new   RootBeanDefinition (  . ObjectFactoryQualifierMethodInjectionBean . class )  ;", "annotatedBeanDefinition . setScope ( BeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    annotatedBeanDefinition )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" testBean \"  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", "bf . registerBeanDefinition (  \" testBean 2  \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ObjectFactoryQualifierMethodInjectionBean   bean    =     (  (  . ObjectFactoryQualifierMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", ". ObjectFactoryQualifierMethodInjectionBean   anotherBean    =     (  (  . ObjectFactoryQualifierMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertNotSame ( anotherBean ,    bean )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryMethodInjectionIntoPrototypeBean"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryQualifierFieldInjectionBean . class )  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . addQualifier ( new   AutowireCandidateQualifier ( Qualifier . class ,     \" testBean \"  )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    bd )  ;", ". ObjectFactoryQualifierFieldInjectionBean   bean    =     (  (  . ObjectFactoryQualifierFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryQualifierInjection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryFieldInjectionBean   bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryFieldInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithBeanField"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryMethodInjectionBean   bean    =     (  (  . ObjectFactoryMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryMethodInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithBeanMethod"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryListFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryListFieldInjectionBean   bean    =     (  (  . ObjectFactoryListFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryListFieldInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithTypedListField"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryListMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryListMethodInjectionBean   bean    =     (  (  . ObjectFactoryListMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryListMethodInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithTypedListMethod"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryMapFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryMapFieldInjectionBean   bean    =     (  (  . ObjectFactoryMapFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryMapFieldInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithTypedMapField"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ObjectFactoryMapMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", "bf . setSerializationId (  \" test \"  )  ;", ". ObjectFactoryMapMethodInjectionBean   bean    =     (  (  . ObjectFactoryMapMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bean    =     (  (  . ObjectFactoryMapMethodInjectionBean )     ( SerializationTestUtils . serializeAndDeserialize ( bean )  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testObjectFactoryWithTypedMapMethod"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". OptionalFieldInjectionBean   bean    =     (  (  . OptionalFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalFieldInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalFieldInjectionBean . class )  )  ;", ". OptionalFieldInjectionBean   bean    =     (  (  . OptionalFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalFieldInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalListFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". OptionalListFieldInjectionBean   bean    =     (  (  . OptionalListFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  . get (  0  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalListFieldInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalListFieldInjectionBean . class )  )  ;", ". OptionalListFieldInjectionBean   bean    =     (  (  . OptionalListFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalListFieldInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalListMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". OptionalListMethodInjectionBean   bean    =     (  (  . OptionalListMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  . get (  0  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalListMethodInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalListMethodInjectionBean . class )  )  ;", ". OptionalListMethodInjectionBean   bean    =     (  (  . OptionalListMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalListMethodInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". OptionalMethodInjectionBean   bean    =     (  (  . OptionalMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalMethodInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . OptionalMethodInjectionBean . class )  )  ;", ". OptionalMethodInjectionBean   bean    =     (  (  . OptionalMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testOptionalMethodInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ProviderOfOptionalFieldInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ProviderOfOptionalFieldInjectionBean   bean    =     (  (  . ProviderOfOptionalFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testProviderOfOptionalFieldInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ProviderOfOptionalFieldInjectionBean . class )  )  ;", ". ProviderOfOptionalFieldInjectionBean   bean    =     (  (  . ProviderOfOptionalFieldInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testProviderOfOptionalFieldInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ProviderOfOptionalMethodInjectionBean . class )  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    new   RootBeanDefinition ( TestBean . class )  )  ;", ". ProviderOfOptionalMethodInjectionBean   bean    =     (  (  . ProviderOfOptionalMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertTrue ( bean . getTestBean (  )  . isPresent (  )  )  ;", "assertSame ( bf . getBean (  \" testBean \"  )  ,    bean . getTestBean (  )  . get (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testProviderOfOptionalMethodInjectionWithBeanAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    new   RootBeanDefinition (  . ProviderOfOptionalMethodInjectionBean . class )  )  ;", ". ProviderOfOptionalMethodInjectionBean   bean    =     (  (  . ProviderOfOptionalMethodInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertFalse ( bean . getTestBean (  )  . isPresent (  )  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testProviderOfOptionalMethodInjectionWithBeanNotAvailable"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   bpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( bf )  ;", "bf . addBeanPostProcessor ( bpp )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition (  . ResourceInjectionBean . class )  ;", "bd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "bf . registerBeanDefinition (  \" annotatedBean \"  ,    bd )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bf . registerSingleton (  \" testBean \"  ,    tb )  ;", ". ResourceInjectionBean   bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "bean    =     (  (  . ResourceInjectionBean )     ( bf . getBean (  \" annotatedBean \"  )  )  )  ;", "assertSame ( tb ,    bean . getTestBean (  )  )  ;", "assertSame ( tb ,    bean . getTestBean 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceInjection"], "fileName": "org.springframework.beans.factory.annotation.InjectAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Set < InjectionMetadata . InjectedElement >    checkedElements    =    new   LinkedHashSet <  >  ( this . injectedElements . size (  )  )  ;", "for    ( InjectionMetadata . InjectedElement   element    :    this . injectedElements )     {", "Member   member    =    element . getMember (  )  ;", "if    (  !  ( beanDefinition . isExternallyManagedConfigMember ( member )  )  )     {", "beanDefinition . registerExternallyManagedConfigMember ( member )  ;", "checkedElements . add ( element )  ;", "if    ( InjectionMetadata . logger . isDebugEnabled (  )  )     {", "InjectionMetadata . logger . debug (  (  (  (  \" Registered   injected   element   on   class    [  \"     +     ( this . targetClass . getName (  )  )  )     +     \"  ]  :     \"  )     +    element )  )  ;", "}", "}", "}", "this . checkedElements    =    checkedElements ;", "}", "METHOD_END"], "methodName": ["checkConfigMembers"], "fileName": "org.springframework.beans.factory.annotation.InjectionMetadata"}, {"methodBody": ["METHOD_START", "{", "Collection < InjectionMetadata . InjectedElement >    checkedElements    =    this . checkedElements ;", "Collection < InjectionMetadata . InjectedElement >    elementsToIterate    =     ( checkedElements    !  =    null )     ?    checkedElements    :    this . injectedElements ;", "if    (  !  ( elementsToIterate . isEmpty (  )  )  )     {", "for    ( InjectionMetadata . InjectedElement   element    :    elementsToIterate )     {", "element . clearPropertySkipping ( pvs )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.beans.factory.annotation.InjectionMetadata"}, {"methodBody": ["METHOD_START", "{", "Collection < InjectionMetadata . InjectedElement >    checkedElements    =    this . checkedElements ;", "Collection < InjectionMetadata . InjectedElement >    elementsToIterate    =     ( checkedElements    !  =    null )     ?    checkedElements    :    this . injectedElements ;", "if    (  !  ( elementsToIterate . isEmpty (  )  )  )     {", "boolean   debug    =    InjectionMetadata . logger . isDebugEnabled (  )  ;", "for    ( InjectionMetadata . InjectedElement   element    :    elementsToIterate )     {", "if    ( debug )     {", "InjectionMetadata . logger . debug (  (  (  (  \" Processing   injected   element   of   bean    '  \"     +    beanName )     +     \"  '  :     \"  )     +    element )  )  ;", "}", "element . inject ( target ,    beanName ,    pvs )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.springframework.beans.factory.annotation.InjectionMetadata"}, {"methodBody": ["METHOD_START", "{", "return    ( metadata    =  =    null )     |  |     (  ( metadata . targetClass )     !  =    clazz )  ;", "}", "METHOD_END"], "methodName": ["needsRefresh"], "fileName": "org.springframework.beans.factory.annotation.InjectionMetadata"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "AutowiredAnnotationBeanPostProcessor   aabpp    =    new   AutowiredAnnotationBeanPostProcessor (  )  ;", "aabpp . setBeanFactory ( beanFactory )  ;", "beanFactory . addBeanPostProcessor ( aabpp )  ;", "beanFactory . registerBeanDefinition (  \" abstractBean \"  ,    new   RootBeanDefinition (  . AbstractBean . class )  )  ;", "beanFactory . registerBeanDefinition (  \" beanConsumer \"  ,    new   RootBeanDefinition (  . BeanConsumer . class )  )  ;", "RootBeanDefinition   tbd    =    new   RootBeanDefinition ( TestBean . class )  ;", "tbd . setScope ( RootBeanDefinition . SCOPE _ PROTOTYPE )  ;", "beanFactory . registerBeanDefinition (  \" testBean \"  ,    tbd )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =    beanFactory . getBean (  \" beanConsumer \"  ,    LookupAnnotationTests . BeanConsumer . class )  . abstractBean ;", "assertNotNull ( bean )  ;", "Object   expected    =    bean . get (  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithEarlyInjection"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =     (  ( LookupAnnotationTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . getOneArgument (  \" haha \"  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithOneConstructorArg"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =     (  ( LookupAnnotationTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . get (  \" haha \"  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithOverloadedArg"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =     (  ( LookupAnnotationTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "try    {", "bean . getThreeArguments (  \" name \"  ,     1  ,     2  )  ;", "fail (  \" TestBean   does   not   have   a   three   arg   constructor   so   this   should   not   have   worked \"  )  ;", "}    catch    ( AbstractMethodError   ex )     {", "}", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithThreeArgsShouldFail"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =     (  ( LookupAnnotationTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . getTwoArguments (  \" haha \"  ,     7  2  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "assertEquals (  7  2  ,    expected . getAge (  )  )  ;", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithTwoConstructorArg"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "LookupAnnotationTests . AbstractBean   bean    =     (  ( LookupAnnotationTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "Object   expected    =    bean . get (  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertSame ( bean ,    beanFactory . getBean ( LookupAnnotationTests . BeanConsumer . class )  . abstractBean )  ;", "}", "METHOD_END"], "methodName": ["testWithoutConstructorArg"], "fileName": "org.springframework.beans.factory.annotation.LookupAnnotationTests"}, {"methodBody": ["METHOD_START", "{", "this . qualifierTypes . add ( qualifierType )  ;", "}", "METHOD_END"], "methodName": ["addQualifierType"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   Annotation >    type    =    annotation . annotationType (  )  ;", "RootBeanDefinition   bd    =     (  ( RootBeanDefinition )     ( bdHolder . getBeanDefinition (  )  )  )  ;", "Qualifier   qualifier    =    bd . getQualifier ( type . getName (  )  )  ;", "if    ( qualifier    =  =    null )     {", "qualifier    =    bd . getQualifier ( ClassUtils . getShortName ( type )  )  ;", "}", "if    ( qualifier    =  =    null )     {", "Annotation   targetAnnotation    =    getQualifiedElementAnnotation ( bd ,    type )  ;", "if    ( targetAnnotation    =  =    null )     {", "targetAnnotation    =    getFactoryMethodAnnotation ( bd ,    type )  ;", "}", "if    ( targetAnnotation    =  =    null )     {", "RootBeanDefinition   dbd    =    getResolvedDecoratedDefinition ( bd )  ;", "if    ( dbd    !  =    null )     {", "targetAnnotation    =    getFactoryMethodAnnotation ( dbd ,    type )  ;", "}", "}", "if    ( targetAnnotation    =  =    null )     {", "if    (  ( getBeanFactory (  )  )     !  =    null )     {", "try    {", "Class <  ?  >    beanType    =    getBeanFactory (  )  . getType ( bdHolder . getBeanName (  )  )  ;", "if    ( beanType    !  =    null )     {", "targetAnnotation    =    AnnotationUtils . getAnnotation ( ClassUtils . getUserClass ( beanType )  ,    type )  ;", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "if    (  ( targetAnnotation    =  =    null )     &  &     ( bd . hasBeanClass (  )  )  )     {", "targetAnnotation    =    AnnotationUtils . getAnnotation ( ClassUtils . getUserClass ( bd . getBeanClass (  )  )  ,    type )  ;", "}", "}", "if    (  ( targetAnnotation    !  =    null )     &  &     ( targetAnnotation . equals ( annotation )  )  )     {", "return   true ;", "}", "}", "Map < String ,    Object >    attributes    =    AnnotationUtils . getAnnotationAttributes ( annotation )  ;", "if    (  ( attributes . isEmpty (  )  )     &  &     ( qualifier    =  =    null )  )     {", "return   false ;", "}", "for    ( Map . Entry < String ,    Object >    entry    :    attributes . entrySet (  )  )     {", "String   attributeName    =    entry . getKey (  )  ;", "Object   expectedValue    =    entry . getValue (  )  ;", "Object   actualValue    =    null ;", "if    ( qualifier    !  =    null )     {", "actualValue    =    qualifier . getAttribute ( attributeName )  ;", "}", "if    ( actualValue    =  =    null )     {", "actualValue    =    bd . getAttribute ( attributeName )  ;", "}", "if    (  (  (  ( actualValue    =  =    null )     &  &     ( attributeName . equals ( Qualifier . VALUE _ KEY )  )  )     &  &     ( expectedValue   instanceof   String )  )     &  &     ( bdHolder . matchesName (  (  ( String )     ( expectedValue )  )  )  )  )     {", "continue ;", "}", "if    (  ( actualValue    =  =    null )     &  &     ( qualifier    !  =    null )  )     {", "actualValue    =    AnnotationUtils . getDefaultValue ( annotation ,    attributeName )  ;", "}", "if    ( actualValue    !  =    null )     {", "actualValue    =    typeConverter . convertIfNecessary ( actualValue ,    expectedValue . getClass (  )  )  ;", "}", "if    (  !  ( expectedValue . equals ( actualValue )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkQualifier"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( ObjectUtils . isEmpty ( ToSearch )  )     {", "return   true ;", "}", "SimpleTypeConverter   typeConverter    =    new   SimpleTypeConverter (  )  ;", "for    ( Annotation    :    ToSearch )     {", "Class <  ?    extends   Annotation >    type    =    ype (  )  ;", "boolean   checkMeta    =    true ;", "boolean   fallbackToMeta    =    false ;", "if    ( isQualifier ( type )  )     {", "if    (  !  ( checkQualifier ( bdHolder ,       typeConverter )  )  )     {", "fallbackToMeta    =    true ;", "} else    {", "checkMeta    =    false ;", "}", "}", "if    ( checkMeta )     {", "boolean   foundMeta    =    false ;", "for    ( Annotation   metaAnn    :    type . getAnnotations (  )  )     {", "Class <  ?    extends   Annotation >    metaType    =    metaAnn . ype (  )  ;", "if    ( isQualifier ( metaType )  )     {", "foundMeta    =    true ;", "if    (  ( fallbackToMeta    &  &     ( StringUtils . isEmpty ( AnnotationUtils . getValue ( metaAnn )  )  )  )     |  |     (  !  ( checkQualifier ( bdHolder ,    metaAnn ,    typeConverter )  )  )  )     {", "return   false ;", "}", "}", "}", "if    ( fallbackToMeta    &  &     (  ! foundMeta )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkQualifiers"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    attr . get ( VALUE )  ;", "if    ( value    =  =    null )     {", "throw   new   IllegalStateException (  \" Value      must   have   a   value   attribute \"  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["extractValue"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "AnnotationAttributes   attr    =    AnnotatedElementUtils . getMergedAnnotationAttributes ( AnnotatedElementUtils . forAnnotations ( annotationsToSearch )  ,    this . valueAnnotationType )  ;", "if    ( attr    !  =    null )     {", "return   extractValue ( attr )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findValue"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "Method   resolvedFactoryMethod    =    bd . getResolvedFactoryMethod (  )  ;", "return   resolvedFactoryMethod    !  =    null    ?    Utils . get ( resolvedFactoryMethod ,    type )     :    null ;", "}", "METHOD_END"], "methodName": ["getFactoryMethodAnnotation"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "AnnotatedElement   qualifiedElement    =    bd . getQualifiedElement (  )  ;", "return   qualifiedElement    !  =    null    ?    Utils . get ( qualifiedElement ,    type )     :    null ;", "}", "METHOD_END"], "methodName": ["getQualifiedElementAnnotation"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?    extends   Annotation >    qualifierType    :    this . qualifierTypes )     {", "if    (  ( annotationType . equals ( qualifierType )  )     |  |     ( annotationType . isAnnotationPresent ( qualifierType )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isQualifier"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "this . valueAnnotationType    =    valueAnnotationType ;", "}", "METHOD_END"], "methodName": ["setValueAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "int   size    =    invalidProperties . size (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  ( size    =  =     1     ?     \" Property \"     :     \" Properties \"  )  )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "String   propertyName    =    invalidProperties . get ( i )  ;", "if    ( i    >     0  )     {", "if    ( i    =  =     ( size    -     1  )  )     {", "sb . append (  \"    and \"  )  ;", "} else    {", "sb . append (  \"  ,  \"  )  ;", "}", "}", "sb . append (  \"     '  \"  )  . append ( propertyName )  . append (  \"  '  \"  )  ;", "}", "sb . append (  ( size    =  =     1     ?     \"    is \"     :     \"    are \"  )  )  ;", "sb . append (  \"    r   for   bean    '  \"  )  . append ( beanName )  . append (  \"  '  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildExceptionMessage"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   this . requiredAnnotationType ;", "}", "METHOD_END"], "methodName": ["getRequiredAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Method   setter    =    propertyDescriptor . getWriteMethod (  )  ;", "return    ( setter    !  =    null )     &  &     (  ( AnnotationUtils . getAnnotation ( setter ,    getType (  )  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isRequiredProperty"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( requiredAnnotationType ,     \"  ' requiredAnnotationType '    must   not   be   null \"  )  ;", "this . requiredAnnotationType    =    requiredAnnotationType ;", "}", "METHOD_END"], "methodName": ["setRequiredAnnotationType"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanFactory    =  =    null )     |  |     (  !  ( beanFactory . containsBeanDefinition ( beanName )  )  )  )     {", "return   false ;", "}", "BeanDefinition   beanDefinition    =    beanFactory . getBeanDefinition ( beanName )  ;", "if    (  ( beanDefinition . getFactoryBeanName (  )  )     !  =    null )     {", "return   true ;", "}", "Object   value    =    beanDefinition . getAttribute (  . SKIP _ REQUIRED _ CHECK _ ATTRIBUTE )  ;", "return    ( value    !  =    null )     &  &     (  ( Boolean . TRUE . equals ( value )  )     |  |     ( Boolean . valueOf ( value . toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldSkip"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . addPropertyValue (  \" age \"  ,     \"  2  4  \"  )  . addPropertyValue (  \" favouriteColour \"  ,     \" Blue \"  )  . addPropertyValue (  \" jobTitle \"  ,     \" Grand   Poobah \"  )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", ". RequiredTestBean   bean    =     (  (  . RequiredTestBean )     ( factory . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  2  4  ,    bean . getAge (  )  )  ;", "assertEquals (  \" Blue \"  ,    bean . getFavouriteColour (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithAllRequiredPropertiesSpecified"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "RequiredAnnotationBeanPostProcessor   rabpp    =    new   RequiredAnnotationBeanPostProcessor (  )  ;", "rabpp . setRequiredAnnotationType (  . MyRequired . class )  ;", "factory . addBeanPostProcessor ( rabpp )  ;", "factory . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "String   message    =    ex . getCause (  )  . getMessage (  )  ;", "assertTrue ( message . contains (  \" Property \"  )  )  ;", "assertTrue ( message . contains (  \" name \"  )  )  ;", "assertTrue ( message . contains (  \" testBean \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithCustomAnnotation"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   beanDef    =    new   RootBeanDefinition (  . RequiredTestBean . class )  ;", "beanDef . setFactoryBeanName (  \" testBeanFactory \"  )  ;", "beanDef . setFactoryMethodName (  \" create \"  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . registerBeanDefinition (  \" testBeanFactory \"  ,    new   RootBeanDefinition (  . RequiredTestBeanFactory . class )  )  ;", "RequiredAnnotationBeanPostProcessor   bpp    =    new   RequiredAnnotationBeanPostProcessor (  )  ;", "bpp . setBeanFactory ( factory )  ;", "factory . addBeanPostProcessor ( bpp )  ;", "factory . preInstantiateSingletons (  )  ;", "}", "METHOD_END"], "methodName": ["testWithFactoryBean"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . addPropertyValue (  \" name \"  ,     \" Rob   Harrop \"  )  . addPropertyValue (  \" favouriteColour \"  ,     \" Blue \"  )  . addPropertyValue (  \" jobTitle \"  ,     \" Grand   Poobah \"  )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "String   message    =    ex . getCause (  )  . getMessage (  )  ;", "assertTrue ( message . contains (  \" Property \"  )  )  ;", "assertTrue ( message . contains (  \" age \"  )  )  ;", "assertTrue ( message . contains (  \" testBean \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithRequiredPropertyOmitted"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . setFactoryMethod (  \" create \"  )  . addPropertyValue (  \" name \"  ,     \" Rob   Harrop \"  )  . addPropertyValue (  \" favouriteColour \"  ,     \" Blue \"  )  . addPropertyValue (  \" jobTitle \"  ,     \" Grand   Poobah \"  )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "String   message    =    ex . getCause (  )  . getMessage (  )  ;", "assertTrue ( message . contains (  \" Property \"  )  )  ;", "assertTrue ( message . contains (  \" age \"  )  )  ;", "assertTrue ( message . contains (  \" testBean \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithStaticFactoryMethod"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . setFactoryMethod (  \" create \"  )  . addPropertyValue (  \" age \"  ,     \"  2  4  \"  )  . addPropertyValue (  \" favouriteColour \"  ,     \" Blue \"  )  . addPropertyValue (  \" jobTitle \"  ,     \" Grand   Poobah \"  )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", ". RequiredTestBean   bean    =     (  (  . RequiredTestBean )     ( factory . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  2  4  ,    bean . getAge (  )  )  ;", "assertEquals (  \" Blue \"  ,    bean . getFavouriteColour (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithStaticFactoryMethodAndRequiredPropertiesSpecified"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   beanDef    =    BeanDefinitionBuilder . genericBeanDefinition (  . RequiredTestBean . class )  . addPropertyValue (  \" name \"  ,     \" Rob   Harrop \"  )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" testBean \"  ,    beanDef )  ;", "factory . addBeanPostProcessor ( new   RequiredAnnotationBeanPostProcessor (  )  )  ;", "factory . preInstantiateSingletons (  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "String   message    =    ex . getCause (  )  . getMessage (  )  ;", "assertTrue ( message . contains (  \" Properties \"  )  )  ;", "assertTrue ( message . contains (  \" age \"  )  )  ;", "assertTrue ( message . contains (  \" favouriteColour \"  )  )  ;", "assertTrue ( message . contains (  \" jobTitle \"  )  )  ;", "assertTrue ( message . contains (  \" testBean \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWithThreeRequiredPropertiesOmitted"], "fileName": "org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    getBeanFactory (  )  ;", "if    ( beanFactory   instanceof   ConfigurableBeanFactory )     {", "return    (  ( ConfigurableBeanFactory )     ( beanFactory )  )  . getTypeConverter (  )  ;", "} else    {", "return   new   SimpleTypeConverter (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBeanTypeConverter"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    ifcs    =    getEarlySingletonInterfaces (  )  ;", "if    ( ifcs    =  =    null )     {", "throw   new   NotInitializedException (  (  ( getClass (  )  . getName (  )  )     +     \"    does   not   support   circular   references \"  )  )  ;", "}", "if    (  ( this . earlySingletonInstance )     =  =    null )     {", "this . earlySingletonInstance    =     (  ( T )     ( Proxy . newProxyInstance ( this . beanClassLoader ,    ifcs ,    new   EarlySingletonInvocationHandler (  )  )  )  )  ;", "}", "return   this . earlySingletonInstance ;", "}", "METHOD_END"], "methodName": ["getEarlySingletonInstance"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =    getObjectType (  )  ;", "return    ( type    !  =    null )     &  &     ( type . isIntere (  )  )     ?    new   Class <  ?  >  [  ]  {    type    }     :    null ;", "}", "METHOD_END"], "methodName": ["getEarlySingletonInterfaces"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "Assert . state ( this . initialized ,     \" Singleton   instance   not   initialized   yet \"  )  ;", "return   this . singletonInstance ;", "}", "METHOD_END"], "methodName": ["getSingletonInstance"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.beans.factory.config.AbstractFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getConstructorArgumentValues (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasConstructorArgumentValues"], "fileName": "org.springframework.beans.factory.config.BeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return    !  ( getPropertyValues (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasPropertyValues"], "fileName": "org.springframework.beans.factory.config.BeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . aliases ;", "}", "METHOD_END"], "methodName": ["getAliases"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . beanDefinition ;", "}", "METHOD_END"], "methodName": ["getBeanDefinition"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( getShortDescription (  )  )  ;", "sb . append (  \"  :     \"  )  . append ( this . b )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getLongDescription"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \" Bean   d   with   name    '  \"  )  . append ( this . beanName )  . append (  \"  '  \"  )  ;", "if    (  ( this . aliases )     !  =    null )     {", "sb . append (  \"    and   aliases    [  \"  )  . append ( StringUtils . arrayToCommaDelimitedString ( this . aliases )  )  . append (  \"  ]  \"  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getShortDescription"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "return    ( candidateName    !  =    null )     &  &     (  (  ( candidateName . equals ( this . beanName )  )     |  |     ( candidateName . equals ( BeanFactoryUtils . transformedBeanName ( this . beanName )  )  )  )     |  |     ( ObjectUtils . containsElement ( this . aliases ,    candidateName )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . valueResolver )     =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   StValueResolver   specified    -    pass   a   resolver    \"     +     \" object   into   the   constructor   or   override   the    ' resolveStValue '    method \"  )  )  ;", "}", "St   resolvedValue    =    this . valueResolver . resolveStValue ( strVal )  ;", "return   strVal . equals ( resolvedValue )     ?    strVal    :    resolvedValue ;", "}", "METHOD_END"], "methodName": ["resolveStringValue"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   BeanDefinition )     {", "visitBeanDefinition (  (  ( BeanDefinition )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   BeanDefinitionHolder )     {", "visitBeanDefinition (  (  ( BeanDefinitionHolder )     ( value )  )  . getBeanDefinition (  )  )  ;", "} else", "if    ( value   instanceof   RuntimeBeanReference )     {", "RuntimeBeanReference   ref    =     (  ( RuntimeBeanReference )     ( value )  )  ;", "String   newBeanName    =    resolveStringValue ( ref . getBeanName (  )  )  ;", "if    ( newBeanName    =  =    null )     {", "return   null ;", "}", "if    (  !  ( newBeanName . equals ( ref . getBeanName (  )  )  )  )     {", "return   new   RuntimeBeanReference ( newBeanName )  ;", "}", "} else", "if    ( value   instanceof   RuntimeBeanNameReference )     {", "RuntimeBeanNameReference   ref    =     (  ( RuntimeBeanNameReference )     ( value )  )  ;", "String   newBeanName    =    resolveStringValue ( ref . getBeanName (  )  )  ;", "if    ( newBeanName    =  =    null )     {", "return   null ;", "}", "if    (  !  ( newBeanName . equals ( ref . getBeanName (  )  )  )  )     {", "return   new   RuntimeBeanNameReference ( newBeanName )  ;", "}", "} else", "if    ( value   instanceof   Object [  ]  )     {", "visitArray (  (  ( Object [  ]  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   List )     {", "visitList (  (  ( List )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   Set )     {", "visitSet (  (  ( Set )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   Map )     {", "visitMap (  (  ( Map )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   TypedStringValue )     {", "TypedStringValue   typedStringValue    =     (  ( TypedStringValue )     ( value )  )  ;", "String   stringValue    =    typedStringValue . getValue (  )  ;", "if    ( stringValue    !  =    null )     {", "String   visitedString    =    resolveStringValue ( stringValue )  ;", "typedStringValue . setValue ( visitedString )  ;", "}", "} else", "if    ( value   instanceof   String )     {", "return   resolveStringValue (  (  ( String )     ( value )  )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["resolveValue"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( arrayVal . length )  ;    i +  +  )     {", "Object   elem    =    arrayVal [ i ]  ;", "Object   newVal    =    resolveValue ( elem )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( newVal ,    elem )  )  )     {", "arrayVal [ i ]     =    newVal ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitArray"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "String   beanClassName    =    beanDefinition . getBeanClassName (  )  ;", "if    ( beanClassName    !  =    null )     {", "String   resolvedName    =    resolveStringValue ( beanClassName )  ;", "if    (  !  ( beanClassName . equals ( resolvedName )  )  )     {", "beanDefinition . setBeanClassName ( resolvedName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitBeanClassName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "visitParentName ( beanDefinition )  ;", "visitBeanClassName ( beanDefinition )  ;", "visitFactoryBeanName ( beanDefinition )  ;", "visitFactoryMethodName ( beanDefinition )  ;", "visitScope ( beanDefinition )  ;", "if    ( beanDefinition . hasPropertyValues (  )  )     {", "visitPropertyValues ( beanDefinition . getPropertyValues (  )  )  ;", "}", "if    ( beanDefinition . hasConstructorArgumentValues (  )  )     {", "ConstructorArgumentValues   cas    =    beanDefinition . getConstructorArgumentValues (  )  ;", "visitIndexedArgumentValues ( cas . getIndexedArgumentValues (  )  )  ;", "visitGenericArgumentValues ( cas . getGenericArgumentValues (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitBeanDefinition"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "String   factoryBeanName    =    beanDefinition . getFactoryBeanName (  )  ;", "if    ( factoryBeanName    !  =    null )     {", "String   resolvedName    =    resolveStringValue ( factoryBeanName )  ;", "if    (  !  ( factoryBeanName . equals ( resolvedName )  )  )     {", "beanDefinition . setFactoryBeanName ( resolvedName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitFactoryBeanName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "String   factoryMethodName    =    beanDefinition . getFactoryMethodName (  )  ;", "if    ( factoryMethodName    !  =    null )     {", "String   resolvedName    =    resolveStringValue ( factoryMethodName )  ;", "if    (  !  ( factoryMethodName . equals ( resolvedName )  )  )     {", "beanDefinition . setFactoryMethodName ( resolvedName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitFactoryMethodName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( ConstructorArgumentValues . ValueHolder   valueHolder    :    gas )     {", "Object   newVal    =    resolveValue ( valueHolder . getValue (  )  )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( newVal ,    valueHolder . getValue (  )  )  )  )     {", "valueHolder . setValue ( newVal )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitGenericArgumentValues"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( ConstructorArgumentValues . ValueHolder   valueHolder    :    ias . values (  )  )     {", "Object   newVal    =    resolveValue ( valueHolder . getValue (  )  )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( newVal ,    valueHolder . getValue (  )  )  )  )     {", "valueHolder . setValue ( newVal )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitIndexedArgumentValues"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( listVal . size (  )  )  ;    i +  +  )     {", "Object   elem    =    listVal . get ( i )  ;", "Object   newVal    =    resolveValue ( elem )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( newVal ,    elem )  )  )     {", "listVal . set ( i ,    newVal )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitList"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "Map   newContent    =    new   LinkedHashMap (  )  ;", "bool   entriesModified    =    false ;", "for    ( Map . Entry   entry    :    mapVal . entrySet (  )  )     {", "Object   key    =    entry . getKey (  )  ;", "int   keyHash    =     ( key    !  =    null )     ?    key . hashCode (  )     :     0  ;", "Object   newKey    =    resolveValue ( key )  ;", "int   newKeyHash    =     ( newKey    !  =    null )     ?    newKey . hashCode (  )     :     0  ;", "Object   val    =    entry . getValue (  )  ;", "Object   newVal    =    resolveValue ( val )  ;", "newContent . put ( newKey ,    newVal )  ;", "entriesModified    =    entriesModified    |  |     (  (  ( newVal    !  =    val )     |  |     ( newKey    !  =    key )  )     |  |     ( newKeyHash    !  =    keyHash )  )  ;", "}", "if    ( entriesModified )     {", "mapVal . clear (  )  ;", "mapVal . putAll ( newContent )  ;", "}", "}", "METHOD_END"], "methodName": ["visitMap"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "String   parentName    =    beanDefinition . getParentName (  )  ;", "if    ( parentName    !  =    null )     {", "String   resolvedName    =    resolveStringValue ( parentName )  ;", "if    (  !  ( parentName . equals ( resolvedName )  )  )     {", "beanDefinition . setParentName ( resolvedName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitParentName"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "PropertyValue [  ]    pvArray    =    pvs . getPropertyValues (  )  ;", "for    ( PropertyValue   pv    :    pvArray )     {", "Object   newVal    =    resolveValue ( pv . getValue (  )  )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( newVal ,    pv . getValue (  )  )  )  )     {", "pvs . add ( pv . getN (  )  ,    newVal )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitPropertyValues"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "String   scope    =    beanDefinition . getScope (  )  ;", "if    ( scope    !  =    null )     {", "String   resolvedScope    =    resolveStringValue ( scope )  ;", "if    (  !  ( scope . equals ( resolvedScope )  )  )     {", "beanDefinition . setScope ( resolvedScope )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitScope"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "Set   newContent    =    new   LinkedHashSet (  )  ;", "bool   entriesModified    =    false ;", "for    ( Object   elem    :    setVal )     {", "int   elemHash    =     ( elem    !  =    null )     ?    elem . hashCode (  )     :     0  ;", "Object   newVal    =    resolveValue ( elem )  ;", "int   newValHash    =     ( newVal    !  =    null )     ?    newVal . hashCode (  )     :     0  ;", "newContent . add ( newVal )  ;", "entriesModified    =    entriesModified    |  |     (  ( newVal    !  =    elem )     |  |     ( newValHash    !  =    elemHash )  )  ;", "}", "if    ( entriesModified )     {", "setVal . clear (  )  ;", "setVal . addAll ( newContent )  ;", "}", "}", "METHOD_END"], "methodName": ["visitSet"], "fileName": "org.springframework.beans.factory.config.BeanDefinitionVisitor"}, {"methodBody": ["METHOD_START", "{", "return    ( this . beanFactory . containsBean ( key )  )     |  |     (  (  ( this . scope )     !  =    null )     &  &     (  ( this . scope . resolveContextualObject ( key )  )     !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["containsObject"], "fileName": "org.springframework.beans.factory.config.BeanExpressionContext"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.beans.factory.config.BeanExpressionContext"}, {"methodBody": ["METHOD_START", "{", "if    ( this . beanFactory . containsBean ( key )  )     {", "return   this . beanFactory . getBean ( key )  ;", "} else", "if    (  ( this . scope )     !  =    null )     {", "return   this . scope . resolveContextualObject ( key )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getObject"], "fileName": "org.springframework.beans.factory.config.BeanExpressionContext"}, {"methodBody": ["METHOD_START", "{", "return   this . scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.springframework.beans.factory.config.BeanExpressionContext"}, {"methodBody": ["METHOD_START", "{", "return   bean ;", "}", "METHOD_END"], "methodName": ["postProcessAfterInitialization"], "fileName": "org.springframework.beans.factory.config.BeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   bean ;", "}", "METHOD_END"], "methodName": ["postProcessBeforeInitialization"], "fileName": "org.springframework.beans.factory.config.BeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "if    ( other    !  =    null )     {", "other . indexed . forEach (  (    index ,    argValue )     -  >    addOrMergeIndexedArgumentValue ( index ,    argValue . copy (  )  )  )  ;", "other . generic . stream (  )  . filter (  (    valueHolder )     -  >     !  ( this . generic . contains ( valueHolder )  )  )  . forEach (  (    valueHolder )     -  >    addOrMergeGenericArgumentValue ( valueHolder . copy (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addArgumentValues"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "this . genericArgumentValues . add ( new   ConstructorArgumentValues . ValueHolder ( value )  )  ;", "}", "METHOD_END"], "methodName": ["addGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "this . genericArgumentValues . add ( new   ConstructorArgumentValues . ValueHolder ( value ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["addGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( newValue ,     \" ValueHolder   must   not   be   null \"  )  ;", "if    (  !  ( this . generic . contains ( newValue )  )  )     {", "addOrMergeGenericArgumentValue ( newValue )  ;", "}", "}", "METHOD_END"], "methodName": ["addGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "addIndexedArgumentValue ( index ,    new   ConstructorArgumentValues . ValueHolder ( value )  )  ;", "}", "METHOD_END"], "methodName": ["addIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "addIndexedArgumentValue ( index ,    new   ConstructorArgumentValues . ValueHolder ( value ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["addIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( index    >  =     0  )  ,     \" Index   must   not   be   negative \"  )  ;", "Assert . notNull ( newValue ,     \" ValueHolder   must   not   be   null \"  )  ;", "addOrMergeIndexed ( index ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["addIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "if    (  ( newValue . getName (  )  )     !  =    null )     {", "for    ( Iterator <  . ValueHolder >    it    =    this . genericArgumentValues . iterator (  )  ;    it . hasNext (  )  ;  )     {", ". ValueHolder   currentValue    =    it . next (  )  ;", "if    ( newValue . getName (  )  . equals ( currentValue . getName (  )  )  )     {", "if    (  ( newValue . getValue (  )  )    instanceof   Mergeable )     {", "Mergeable   mergeable    =     (  ( Mergeable )     ( newValue . getValue (  )  )  )  ;", "if    ( mergeable . isMergeEnabled (  )  )     {", "newValue . setValue ( mergeable . merge ( currentValue . getValue (  )  )  )  ;", "}", "}", "it . remove (  )  ;", "}", "}", "}", "this . genericArgumentValues . add ( newValue )  ;", "}", "METHOD_END"], "methodName": ["addOrMergeGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "ConstructorArgumentValues . ValueHolder   currentValue    =    this . indexedArgumentValues . get ( key )  ;", "if    (  ( currentValue    !  =    null )     &  &     (  ( newValue . getValue (  )  )    instanceof   Mergeable )  )     {", "Mergeable   mergeable    =     (  ( Mergeable )     ( newValue . getValue (  )  )  )  ;", "if    ( mergeable . isMergeEnabled (  )  )     {", "newValue . setValue ( mergeable . merge ( currentValue . getValue (  )  )  )  ;", "}", "}", "this . indexedArgumentValues . put ( key ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["addOrMergeIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "this . indexedArgumentValues . clear (  )  ;", "this . genericArgumentValues . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return    ( this . indexedArgumentValues . size (  )  )     +     ( this . genericArgumentValues . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentCount"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   getArgumentValue ( index ,    requiredType ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["getArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   getArgumentValue ( index ,    requiredType ,    requiredName ,    null )  ;", "}", "METHOD_END"], "methodName": ["getArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( index    >  =     0  )  ,     \" Index   must   not   be   negative \"  )  ;", ". ValueHolder   valueHolder    =    getIndexedArgumentValue ( index ,    requiredType ,    requiredName )  ;", "if    ( valueHolder    =  =    null )     {", "valueHolder    =    getGenericArgumentValue ( requiredType ,    requiredName ,    usedValueHolders )  ;", "}", "return   valueHolder ;", "}", "METHOD_END"], "methodName": ["getArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   getGenericArgumentValue ( requiredType ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["getGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   getGenericArgumentValue ( requiredType ,    requiredName ,    null )  ;", "}", "METHOD_END"], "methodName": ["getGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "for    ( ConstructorArgumentValues . ValueHolder   valueHolder    :    this . genericArgumentValues )     {", "if    (  ( usedValueHolders    !  =    null )     &  &     ( usedValueHolders . contains ( valueHolder )  )  )     {", "continue ;", "}", "if    (  (  (  ( valueHolder . getName (  )  )     !  =    null )     &  &     (  !  (  \"  \"  . equals ( requiredName )  )  )  )     &  &     (  ( requiredName    =  =    null )     |  |     (  !  ( valueHolder . getName (  )  . equals ( requiredName )  )  )  )  )     {", "continue ;", "}", "if    (  (  ( valueHolder . getType (  )  )     !  =    null )     &  &     (  ( requiredType    =  =    null )     |  |     (  !  ( ClassUtils . matchesTypeName ( requiredType ,    valueHolder . getType (  )  )  )  )  )  )     {", "continue ;", "}", "if    (  (  (  ( requiredType    !  =    null )     &  &     (  ( valueHolder . getType (  )  )     =  =    null )  )     &  &     (  ( valueHolder . getName (  )  )     =  =    null )  )     &  &     (  !  ( ClassUtils . isAssignableValue ( requiredType ,    valueHolder . getValue (  )  )  )  )  )     {", "continue ;", "}", "return   valueHolder ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getGenericArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . genericArgumentValues )  ;", "}", "METHOD_END"], "methodName": ["getGenericArgumentValues"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   getIndexedArgumentValue ( index ,    requiredType ,    null )  ;", "}", "METHOD_END"], "methodName": ["getIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "Assert . isTrue (  ( index    >  =     0  )  ,     \" Index   must   not   be   negative \"  )  ;", ". ValueHolder   valueHolder    =    this . indexedArgumentValues . get ( index )  ;", "if    (  (  ( valueHolder    !  =    null )     &  &     (  (  ( valueHolder . getType (  )  )     =  =    null )     |  |     (  ( requiredType    !  =    null )     &  &     ( ClassUtils . matchesTypeName ( requiredType ,    valueHolder . getType (  )  )  )  )  )  )     &  &     (  (  (  ( valueHolder . getName (  )  )     =  =    null )     |  |     (  \"  \"  . equals ( requiredName )  )  )     |  |     (  ( requiredName    !  =    null )     &  &     ( requiredName . equals ( valueHolder . getName (  )  )  )  )  )  )     {", "return   valueHolder ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( this . indexedArgumentValues )  ;", "}", "METHOD_END"], "methodName": ["getIndexedArgumentValues"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return   this . indexedArgumentValues . containsKey ( index )  ;", "}", "METHOD_END"], "methodName": ["hasIndexedArgumentValue"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "return    ( this . indexedArgumentValues . isEmpty (  )  )     &  &     ( this . genericArgumentValues . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.beans.factory.config.ConstructorArgumentValues"}, {"methodBody": ["METHOD_START", "{", "this . customEditors    =    customEditors ;", "}", "METHOD_END"], "methodName": ["setCustomEditors"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . propertyEditorRegistrars    =    propertyEditorRegistrars ;", "}", "METHOD_END"], "methodName": ["setPropertyEditorRegistrars"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurer"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CustomEditorConfigurer   cec    =    new   CustomEditorConfigurer (  )  ;", "Map < Class <  ?  >  ,    Class <  ?    extends   PropertyEditor >  >    editors    =    new   HashMap <  >  (  )  ;", "editors . put ( Date . class ,     . MyDateEditor . class )  ;", "cec . setCustomEditors ( editors )  ;", "cec . postProcessBeanFactory ( bf )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" date \"  ,     \"  2  .  1  2  .  1  9  7  5  \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "bf . registerBeanDefinition (  \" tb \"  ,    bd )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" tb \"  )  )  )  ;", "DateFormat   df    =    DateFormat . getDateInstance ( DateFormat . SHORT ,    Locale . GERMAN )  ;", "assertEquals ( df . parse (  \"  2  .  1  2  .  1  9  7  5  \"  )  ,    tb . getDate (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorConfigurerWithEditorAsClass"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "cec    =    new    (  )  ;", "final   DateFormat   df    =    DateFormat . getDateInstance ( DateFormat . SHORT ,    Locale . GERMAN )  ;", "cec . setPropertyEditorRegistrars ( new   PropertyEditorRegistrar [  ]  {    new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "registry . registerCustomEditor ( Date . class ,    new   CustomDateEditor ( df ,    true )  )  ;", "}", "}     }  )  ;", "cec . postProcessBeanFactory ( bf )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" date \"  ,     \"  2  .  1  2  .  1  9  7  5  \"  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setPropertyValues ( pvs )  ;", "bf . registerBeanDefinition (  \" tb 1  \"  ,    bd 1  )  ;", "pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" someMap [ myKey ]  \"  ,    new   TypedStringValue (  \"  2  .  1  2  .  1  9  7  5  \"  ,    Date . class )  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPropertyValues ( pvs )  ;", "bf . registerBeanDefinition (  \" tb 2  \"  ,    bd 2  )  ;", "TestBean   tb 1     =     (  ( TestBean )     ( bf . getBean (  \" tb 1  \"  )  )  )  ;", "assertEquals ( df . parse (  \"  2  .  1  2  .  1  9  7  5  \"  )  ,    tb 1  . getDate (  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bf . getBean (  \" tb 2  \"  )  )  )  ;", "assertEquals ( df . parse (  \"  2  .  1  2  .  1  9  7  5  \"  )  ,    tb 2  . getSomeMap (  )  . get (  \" myKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorConfigurerWithPropertyEditorRegistrar"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "CustomEditorConfigurer   cec    =    new   CustomEditorConfigurer (  )  ;", "Map < Class <  ?  >  ,    Class <  ?    extends   PropertyEditor >  >    editors    =    new   HashMap <  >  (  )  ;", "editors . put ( String [  ]  . class ,     . MyTestEditor . class )  ;", "cec . setCustomEditors ( editors )  ;", "cec . postProcessBeanFactory ( bf )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" stringArray \"  ,     \" xxx \"  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "bf . registerBeanDefinition (  \" tb \"  ,    bd )  ;", "TestBean   tb    =     (  ( TestBean )     ( bf . getBean (  \" tb \"  )  )  )  ;", "assertTrue (  (  (  ( tb . getStringArray (  )  )     !  =    null )     &  &     (  ( tb . getStringArray (  )  . length )     =  =     1  )  )  )  ;", "assertEquals (  \" test \"  ,    tb . getStringArray (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorConfigurerWithRequiredTypeArray"], "fileName": "org.springframework.beans.factory.config.CustomEditorConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . scopes )     =  =    null )     {", "this . scopes    =    new   LinkedHashMap <  >  (  1  )  ;", "}", "this . scopes . put ( scopeName ,    scope )  ;", "}", "METHOD_END"], "methodName": ["addScope"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . scopes    =    scopes ;", "}", "METHOD_END"], "methodName": ["setScopes"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurer"}, {"methodBody": ["METHOD_START", "{", "factory    =    new   DefaultListableBeanFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    scopes    =    new   HashMap <  >  (  )  ;", "scopes . put (  . FOO _ SCOPE ,    NoOpScope . class )  ;", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "assertTrue (  (  ( factory . getRegisteredScope (  . FOO _ SCOPE )  )    instanceof   NoOpScope )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayWithBonaFideScopeClass"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    scopes    =    new   HashMap <  >  (  )  ;", "scopes . put (  . FOO _ SCOPE ,    NoOpScope . class . getName (  )  )  ;", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "assertTrue (  (  ( factory . getRegisteredScope (  . FOO _ SCOPE )  )    instanceof   NoOpScope )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayWithBonaFideScopeClassname"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Scope   scope    =    mock ( Scope . class )  ;", "factory . registerScope (  . FOO _ SCOPE ,    scope )  ;", "Map < String ,    Object >    scopes    =    new   HashMap <  >  (  )  ;", "scopes . put (  . FOO _ SCOPE ,    scope )  ;", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDayWithBonaFideScopeInstance"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    scopes    =    new   HashMap <  >  (  )  ;", "scopes . put (  . FOO _ SCOPE ,    this )  ;", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["testWhereScopeMapHasNonScopeInstanceInEntrySet"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map   scopes    =    new   HashMap (  )  ;", "scopes . put ( this ,    new   NoOpScope (  )  )  ;", "figurer    =    new    (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["testWhereScopeMapHasNonStringTypedScopeNameInKeySet"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    scopes    =    new   HashMap <  >  (  )  ;", "scopes . put (  . FOO _ SCOPE ,    null )  ;", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . setScopes ( scopes )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["testWhereScopeMapHasNullScopeValueInEntrySet"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "CustomScopeConfigurer   figurer    =    new   CustomScopeConfigurer (  )  ;", "figurer . postProcessBeanFactory ( factory )  ;", "}", "METHOD_END"], "methodName": ["testWithNoScopes"], "fileName": "org.springframework.beans.factory.config.CustomScopeConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["fallbackMatchAllowed"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   new   DependencyDescriptor ( this )     {", "@ Override", "public   boolean   fallbackMatchAllowed (  )     {", "return   true ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["forFallbackMatch"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return    ( this . field )     !  =    null    ?    this . field . getName (  )     :    obtainMethodParameter (  )  . getParameterName (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyName"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . field )     !  =    null )     {", "if    (  ( this . nestingLevel )     >     1  )     {", "Type   type    =    this . field . getGenericType (  )  ;", "for    ( int   i    =     2  ;    i    <  =     ( this . nestingLevel )  ;    i +  +  )     {", "if    ( type   instanceof   PaterizedType )     {", "Type [  ]    args    =     (  ( PaterizedType )     ( type )  )  . getActualTypeArguments (  )  ;", "type    =    args [  (  ( args . length )     -     1  )  ]  ;", "}", "}", "if    ( type   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( type )  )  ;", "} else", "if    ( type   instanceof   PaterizedType )     {", "Type   arg    =     (  ( PaterizedType )     ( type )  )  . getRawType (  )  ;", "if    ( arg   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( arg )  )  ;", "}", "}", "return   Object . class ;", "} else    {", "return   this . field . getType (  )  ;", "}", "} else    {", "return   obtainMethodPater (  )  . getNestedPaterType (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependencyType"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   resolvableType    =    this . resolvableType ;", "if    ( resolvableType    =  =    null )     {", "resolvableType    =     (  ( this . field )     !  =    null )     ?    ResolvableType . forField ( this . field ,    this . nestingLevel ,    this . containingClass )     :    ResolvableType . forMethodPater ( obtainMethodPater (  )  )  ;", "this . resolvableType    =    resolvableType ;", "}", "return   resolvableType ;", "}", "METHOD_END"], "methodName": ["getResolvableType"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   ann    :    getAnnotations (  )  )     {", "if    (  \" Nullable \"  . equals ( ann . annotationType (  )  . getSimpleN (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasNullableAnnotation"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "( this . nestingLevel )  +  +  ;", "this . resolvableType    =    null ;", "if    (  ( this . methodPater )     !  =    null )     {", "this . methodPater . increaseNestingLevel (  )  ;", "}", "}", "METHOD_END"], "methodName": ["increaseNestingLevel"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . methodParameter )     !  =    null )     {", "this . methodParameter . initParameterNameDiscovery ( parameterNameDiscoverer )  ;", "}", "}", "METHOD_END"], "methodName": ["initParameterNameDiscovery"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   this . eager ;", "}", "METHOD_END"], "methodName": ["isEager"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . required )  )     {", "return   false ;", "}", "if    (  ( this . field )     !  =    null )     {", "return    !  (  (  (  ( this . field . getType (  )  )     =  =     ( Optional . class )  )     |  |     ( hasNullableAnnotation (  )  )  )     |  |     (  ( KotlinDetector . isKotlinType ( this . field . getDeclaringClass (  )  )  )     &  &     (  . KotlinDelegate . isNullable ( this . field )  )  )  )  ;", "} else    {", "return    !  ( obtainMethodParameter (  )  . isOptional (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "ois . defaultReadObject (  )  ;", "try    {", "if    (  ( this . fieldName )     !  =    null )     {", "this . field    =    this . declaClass . getDeclaredField ( this . fieldName )  ;", "} else    {", "if    (  ( this . methodName )     !  =    null )     {", "this . methodParameter    =    new   MethodParameter ( this . declaClass . getDeclaredMethod ( this . methodName ,    this . parameterTypes )  ,    this . parameterIndex )  ;", "} else    {", "this . methodParameter    =    new   MethodParameter ( this . declaClass . getDeclaredConstructor ( this . parameterTypes )  ,    this . parameterIndex )  ;", "}", "for    ( int   i    =     1  ;    i    <     ( this . nestingLevel )  ;    i +  +  )     {", "this . methodParameter . increaseNestingLevel (  )  ;", "}", "}", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalStateException (  \" Could   not   find   original   class   structure \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory . getBean ( beanName )  ;", "}", "METHOD_END"], "methodName": ["resolveCandidate"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "throw   new   NoUniqueBeanDefinitionException ( type ,    matchingBeans . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNotUnique"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveShortcut"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . containingClass    =    containingClass ;", "this . resolvableType    =    null ;", "if    (  ( this . methodParameter )     !  =    null )     {", "GenericTypeResolver . resolveParameterType ( this . methodParameter ,    containingClass )  ;", "}", "}", "METHOD_END"], "methodName": ["setContainingClass"], "fileName": "org.springframework.beans.factory.config.DependencyDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   logger . isWarnEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isLogEnabled"], "fileName": "org.springframework.beans.factory.config.DeprecatedBeanWarner"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append ( beanType )  ;", "builder . append (  \"     [  '  \"  )  ;", "builder . append ( beanName )  ;", "builder . append (  '  \\  '  '  )  ;", "String   resourceDescription    =    beanDefinition . getResourceDescription (  )  ;", "if    ( StringUtils . hasLength ( resourceDescription )  )     {", "builder . append (  \"    in    \"  )  ;", "builder . append ( resourceDescription )  ;", "}", "builder . append (  \"  ]    has   been   d \"  )  ;", "writeToLog ( builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["logDeprecatedBean"], "fileName": "org.springframework.beans.factory.config.DeprecatedBeanWarner"}, {"methodBody": ["METHOD_START", "{", "this . logger    =    LogFactory . getLog ( loggerName )  ;", "}", "METHOD_END"], "methodName": ["setLoggerName"], "fileName": "org.springframework.beans.factory.config.DeprecatedBeanWarner"}, {"methodBody": ["METHOD_START", "{", "logger . warn ( message )  ;", "}", "METHOD_END"], "methodName": ["writeToLog"], "fileName": "org.springframework.beans.factory.config.DeprecatedBeanWarner"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinition   def    =    new   RootBeanDefinition ( MyDeprecatedBean . class )  ;", "String   beanName    =     \" deprecated \"  ;", "beanFactory . registerBeanDefinition ( beanName ,    def )  ;", "warner    =    new    . MyDeprecatedBeanWarner (  )  ;", "warner . postProcessBeanFactory ( beanFactory )  ;", "assertEquals ( beanName ,    this . beanName )  ;", "assertEquals ( def ,    this . beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["postProcess"], "fileName": "org.springframework.beans.factory.config.DeprecatedBeanWarnerTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["requiresDestruction"], "fileName": "org.springframework.beans.factory.config.DestructionAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   targetClass ;", "}", "METHOD_END"], "methodName": ["getTargetClass"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . targetField ;", "}", "METHOD_END"], "methodName": ["getTargetField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "return   this . targetObject ;", "}", "METHOD_END"], "methodName": ["getTargetObject"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . staticField    =    StringUtils . trimAllWhitespace ( staticField )  ;", "}", "METHOD_END"], "methodName": ["setStaticField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetClass    =    targetClass ;", "}", "METHOD_END"], "methodName": ["setTargetClass"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetField    =     ( targetField    !  =    null )     ?    StringUtils . trimAllWhitespace ( targetField )     :    null ;", "}", "METHOD_END"], "methodName": ["setTargetField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetObject    =    targetObject ;", "}", "METHOD_END"], "methodName": ["setTargetObject"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions (  . CONTEXT )  ;", "TestBean   testBean    =     (  ( TestBean )     ( bf . getBean (  \" testBean \"  )  )  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    testBean . getSomeIntegerArray (  )  [  0  ]  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    testBean . getSomeIntegerArray (  )  [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testBeanNameSyntaxWithBeanFactory"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setTargetClass ( Connection . class )  ;", "try    {", "fr . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testJustTargetClass"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setTargetField (  \" TRANSACTION _ SERIALIZABLE \"  )  ;", "try    {", "fr . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testJustTargetField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setTargetObject ( new    . PublicFieldHolder (  )  )  ;", "try    {", "fr . afterPropertiesSet (  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testJustTargetObject"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", ". PublicFieldHolder   target    =    new    . PublicFieldHolder (  )  ;", "fr . setTargetObject ( target )  ;", "fr . setTargetField (  \" publicField \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals ( target . publicField ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonStaticField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setBeanName (  \" TRANSACTION _ SERIALIZABLE \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNothingButBeanName"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setStaticField (  \" TRANSACTION _ SERIALIZABLE \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticField"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setTargetClass ( Connection . class )  ;", "fr . setTargetField (  \" TRANSACTION _ SERIALIZABLE \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticFieldViaClassAndFieldName"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setStaticField (  \"       TRANSACTION _ SERIALIZABLE       \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals ( new   Integer ( Connection . TRANSACTION _ SERIALIZABLE )  ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStaticFieldWithWhitespace"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "FieldRetrievingFactoryBean   fr    =    new   FieldRetrievingFactoryBean (  )  ;", "fr . setBeanName (  \" CONSTANT \"  )  ;", "fr . afterPropertiesSet (  )  ;", "assertEquals (  \" Wuby \"  ,    fr . getObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithConstantOnClassWithPackageLevelVisibility"], "fileName": "org.springframework.beans.factory.config.FieldRetrievingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["postProcessAfterInstantiation"], "fileName": "org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["postProcessBeforeInstantiation"], "fileName": "org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   pvs ;", "}", "METHOD_END"], "methodName": ["postProcessPropertyValues"], "fileName": "org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "this . sourceList    =    sourceList ;", "}", "METHOD_END"], "methodName": ["setSourceList"], "fileName": "org.springframework.beans.factory.config.ListFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( targeClass    =  =    null )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   not   be   null \"  )  ;", "}", "if    (  !  . class . isAssignableFrom ( targeClass )  )  )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   implement    [ util ]  \"  )  ;", "}", "this . targeClass    =    targeClass ;", "}", "METHOD_END"], "methodName": ["setTargetListClass"], "fileName": "org.springframework.beans.factory.config.ListFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . sourceMap    =    sourceMap ;", "}", "METHOD_END"], "methodName": ["setSourceMap"], "fileName": "org.springframework.beans.factory.config.MapFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( targeClass    =  =    null )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   not   be   null \"  )  ;", "}", "if    (  !  . class . isAssignableFrom ( targeClass )  )  )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   implement    [ util ]  \"  )  ;", "}", "this . targeClass    =    targeClass ;", "}", "METHOD_END"], "methodName": ["setTargetMapClass"], "fileName": "org.springframework.beans.factory.config.MapFactoryBean"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   ie (  )  ;", "}    catch    ( InvocationTargetException   ex )     {", "if    (  ( ex . getTargetException (  )  )    instanceof   Exception )     {", "throw    (  ( Exception )     ( ex . getTargetException (  )  )  )  ;", "}", "if    (  ( ex . getTargetException (  )  )    instanceof   Error )     {", "throw    (  ( Error )     ( ex . getTargetException (  )  )  )  ;", "}", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["invokeWithTargetException"], "fileName": "org.springframework.beans.factory.config.MethodInvokingBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "MethodInvokingFactoryBean   mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes \"  )  ;", "mcfb . setArguments ( new   ArrayList (  )  ,    new   ArrayList < Object >  (  )  ,     \" hello \"  ,     \" bogus \"  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail (  \" Matched   method   with   wrong   number   of   args \"  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes \"  )  ;", "mcfb . setArguments (  1  ,    new   Object (  )  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "mcfb . getObject (  )  ;", "fail (  \" Should   have   failed   on   getObject   with   mismatched   argument   types \"  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes 2  \"  )  ;", "mcfb . setArguments ( new   ArrayList (  )  ,    new   ArrayList < Object >  (  )  ,     \" hello \"  ,     \" bogus \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "assertEquals (  \" hello \"  ,    mcfb . getObject (  )  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes 2  \"  )  ;", "mcfb . setArguments ( new   ArrayList (  )  ,    new   ArrayList < Object >  (  )  ,    new   Object (  )  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail (  \" Matched   method   when   shouldn ' t   have   matched \"  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testArgumentConversion"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvokingFactoryBeanTests . TestClass 1    tc 1     =    new   MethodInvokingFactoryBeanTests . TestClass 1  (  )  ;", "MethodInvokingFactoryBean   mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( tc 1  )  ;", "mcfb . setTargetMethod (  \" method 1  \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "Integer   i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "tc 1     =    new   MethodInvokingFactoryBeanTests . TestClass 1  (  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( tc 1  )  ;", "mcfb . setTargetMethod (  \" method 1  \"  )  ;", "mcfb . setSingleton ( false )  ;", "mcfb . afterPropertiesSet (  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  2  ,    i . intValue (  )  )  ;", "MethodInvokingFactoryBeanTests . TestClass 1  .  _ staticField 1     =     0  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" staticMethod 1  \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "MethodInvokingFactoryBeanTests . TestClass 1  .  _ staticField 1     =     0  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setStaticMethod (  \"  $ TestClass 1  . staticMethod 1  \"  )  ;", "mcfb . setSingleton ( false )  ;", "mcfb . afterPropertiesSet (  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  1  ,    i . intValue (  )  )  ;", "i    =     (  ( Integer )     ( mcfb . getObject (  )  )  )  ;", "assertEquals (  2  ,    i . intValue (  )  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" voidRetvalMethod \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "assertNull ( mcfb . getObject (  )  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes \"  )  ;", "mcfb . setArguments ( new   ArrayList (  )  ,    new   ArrayList < Object >  (  )  ,     \" hello \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testGetObject"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvokingFactoryBeanTests . TestClass 1    tc 1     =    new   MethodInvokingFactoryBeanTests . TestClass 1  (  )  ;", "MethodInvokingFactoryBean   mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( tc 1  )  ;", "mcfb . setTargetMethod (  \" method 1  \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "assertTrue ( int . class . equals ( mcfb . getObjectType (  )  )  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" voidRetvalMethod \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "Class <  ?  >    objType    =    mcfb . getObjectType (  )  ;", "assertSame ( objType ,    void . class )  ;", "MethodInvokingFactoryBeanTests . TestClass 1  .  _ staticField 1     =     0  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes \"  )  ;", "mcfb . setArguments ( new   ArrayList (  )  ,    new   ArrayList < Object >  (  )  ,     \" hello \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "mcfb . getObjectType (  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . registerCustomEditor ( String . class ,    new   StringTrimmerEditor ( false )  )  ;", "mcfb . setTargetClass ( MethodInvokingFactoryBeanTests . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" supertypes \"  )  ;", "mcfb . setArguments (  \"  1  \"  ,    new   Object (  )  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail (  \" Should   have   thrown   NoSuchMethodException \"  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testGetObjectType"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentConvertingMethodInvoker   methodInvoker    =    new   ArgumentConvertingMethodInvoker (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArgument \"  )  ;", "methodInvoker . setArguments (  5  )  ;", "methodInvoker . prepare (  )  ;", "methodInvoker . invoke (  )  ;", "methodInvoker    =    new   ArgumentConvertingMethodInvoker (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArgument \"  )  ;", "methodInvoker . setArguments (  5  )  ;", "methodInvoker . prepare (  )  ;", "methodInvoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeWithIntArgument"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvokingBean   methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments ( new   Object [  ]  {    new   Integer [  ]  {     5  ,     1  0     }     }  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments ( new   Object [  ]  {    new   String [  ]  {     \"  5  \"  ,     \"  1  0  \"     }     }  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments ( new   Object [  ]  {    new   Integer [  ]  {     5  ,     1  0     }     }  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments (  \"  5  \"  ,     \"  1  0  \"  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments ( new   Object [  ]  {    new   Integer [  ]  {     5  ,     1  0     }     }  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "methodInvoker    =    new   MethodInvokingBean (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" intArguments \"  )  ;", "methodInvoker . setArguments (  \"  5  \"  ,     \"  1  0  \"  )  ;", "methodInvoker . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeWithIntArguments"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "MethodInvoker   methodInvoker    =    new   MethodInvoker (  )  ;", "methodInvoker . setTargetClass (  . TestClass 1  . class )  ;", "methodInvoker . setTargetMethod (  \" nullArgument \"  )  ;", "methodInvoker . setArguments ( new   Object [  ]  {    null    }  )  ;", "methodInvoker . prepare (  )  ;", "methodInvoker . invoke (  )  ;", "}", "METHOD_END"], "methodName": ["testInvokeWithNullArgument"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "String   validationError    =     \" improper   validation   of   input   properties \"  ;", "MethodInvokingFactoryBean   mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( this )  ;", "mcfb . setTargetMethod (  \" whatever \"  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" some . bogus . Method . name \"  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" method 1  \"  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( this )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( this )  ;", "mcfb . setTargetMethod (  \" bogus \"  )  ;", "try    {", "mcfb . afterPropertiesSet (  )  ;", "fail ( validationError )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", ". TestClass 1  .  _ staticField 1     =     0  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetClass (  . TestClass 1  . class )  ;", "mcfb . setTargetMethod (  \" staticMethod 1  \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", ". TestClass 1    tc 1     =    new    . TestClass 1  (  )  ;", "mcfb    =    new   MethodInvokingFactoryBean (  )  ;", "mcfb . setTargetObject ( tc 1  )  ;", "mcfb . setTargetMethod (  \" method 1  \"  )  ;", "mcfb . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testParameterValidation"], "fileName": "org.springframework.beans.factory.config.MethodInvokingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanInstance ;", "}", "METHOD_END"], "methodName": ["getBeanInstance"], "fileName": "org.springframework.beans.factory.config.NamedBeanHolder"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions (  . CONTEXT )  ;", "this . beanFactory . setSerializationId (  \" test \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . setSerializationId ( null )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "final   String   targetBeanName    =     \" singleton \"  ;", "final   String   expectedSingleton    =     \" Alicia   Keys \"  ;", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "given ( beanFactory . getBean ( targetBeanName )  )  . willReturn ( expectedSingleton )  ;", "factory    =    new    (  )  ;", "factory . setTargetBeanName ( targetBeanName )  ;", "factory . setBeanFactory ( beanFactory )  ;", "factory . afterPropertiesSet (  )  ;", "ObjectFactory <  ?  >    objectFactory    =    factory . getObject (  )  ;", "Object   actualSingleton    =    objectFactory . getObject (  )  ;", "assertSame ( expectedSingleton ,    actualSingleton )  ;", "}", "METHOD_END"], "methodName": ["testDoesNotComplainWhenTargetBeanNameRefersToSingleton"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Must   be   reporting   that   it   creates   ObjectFactory   instances    ( as   per   class   contract )  .  \"  ,    ObjectFactory . class ,    new   ObjectFactoryCreatingFactoryBean (  )  . getObjectType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnsureOFBFBReportsThatItActuallyCreatesObjectFactoryInstances"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ObjectFactoryCreatingFactoryBeanTests . FactoryTestBean   testBean    =    beanFactory . getBean (  \" factoryTestBean \"  ,    ObjectFactoryCreatingFactoryBeanTests . FactoryTestBean . class )  ;", "ObjectFactory <  ?  >    objectFactory    =    testBean . getObjectFactory (  )  ;", "Date   date 1     =     (  ( Date )     ( objectFactory . getObject (  )  )  )  ;", "Date   date 2     =     (  ( Date )     ( objectFactory . getObject (  )  )  )  ;", "assertTrue (  ( date 1     !  =    date 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryOperation"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ObjectFactoryCreatingFactoryBeanTests . FactoryTestBean   testBean    =    beanFactory . getBean (  \" factoryTestBean \"  ,    ObjectFactoryCreatingFactoryBeanTests . FactoryTestBean . class )  ;", "ObjectFactory <  ?  >    objectFactory    =    testBean . getObjectFactory (  )  ;", "objectFactory    =     (  ( ObjectFactory )     ( SerializationTestUtils . serializeAndDeserialize ( objectFactory )  )  )  ;", "Date   date 1     =     (  ( Date )     ( objectFactory . getObject (  )  )  )  ;", "Date   date 2     =     (  ( Date )     ( objectFactory . getObject (  )  )  )  ;", "assertTrue (  ( date 1     !  =    date 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactorySerialization"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ObjectFactoryCreatingFactoryBeanTests . ProviderTestBean   testBean    =    beanFactory . getBean (  \" providerTestBean \"  ,    ObjectFactoryCreatingFactoryBeanTests . ProviderTestBean . class )  ;", "Provider <  ?  >    provider    =    testBean . getProvider (  )  ;", "Date   date 1     =     (  ( Date )     ( provider . get (  )  )  )  ;", "Date   date 2     =     (  ( Date )     ( provider . get (  )  )  )  ;", "assertTrue (  ( date 1     !  =    date 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testProviderOperation"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ObjectFactoryCreatingFactoryBeanTests . ProviderTestBean   testBean    =    beanFactory . getBean (  \" providerTestBean \"  ,    ObjectFactoryCreatingFactoryBeanTests . ProviderTestBean . class )  ;", "Provider <  ?  >    provider    =    testBean . getProvider (  )  ;", "provider    =     (  ( Provider )     ( SerializationTestUtils . serializeAndDeserialize ( provider )  )  )  ;", "Date   date 1     =     (  ( Date )     ( provider . get (  )  )  )  ;", "Date   date 2     =     (  ( Date )     ( provider . get (  )  )  )  ;", "assertTrue (  ( date 1     !  =    date 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testProviderSerialization"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "factory    =    new    (  )  ;", "factory . setTargetBeanName (  \"  \"  )  ;", "factory . afterPropertiesSet (  )  ;", "fail (  \" Must   have   thrown   an   IllegalArgumentException ;     ' targetBeanName '    property   set   to    ( invalid )    empty   string .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testWhenTargetBeanNameIsEmptyString"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . afterPropertiesSet (  )  ;", "fail (  \" Must   have   thrown   an   IllegalArgumentException ;     ' targetBeanName '    property   not   set .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testWhenTargetBeanNameIsNull"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "factory    =    new    (  )  ;", "factory . setTargetBeanName (  \"        \\ t \"  )  ;", "factory . afterPropertiesSet (  )  ;", "fail (  \" Must   have   thrown   an   IllegalArgumentException ;     ' targetBeanName '    property   set   to    ( invalid )    only - whitespace   string .  \"  )  ;", "}    catch    ( IllegalArgumentException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testWhenTargetBeanNameIsWhitespacedString"], "fileName": "org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionVisitor   visitor    =    new   BeanDefinitionVisitor ( valueResolver )  ;", "String [  ]    beanNames    =    beanFToProcess . getBeanDefinitionNames (  )  ;", "for    ( String   curName    :    beanNames )     {", "if    (  !  (  ( curName . equals ( this . beanName )  )     &  &     ( beanFToProcess . equals ( this . beanF )  )  )  )     {", "BeanDefinition   bd    =    beanFToProcess . getBeanDefinition ( curName )  ;", "try    {", "visitor . visitBeanDefinition ( bd )  ;", "}    catch    ( Exception   ex )     {", "throw   new   BeanDefinitionStoreException ( bd . getResourceDescription (  )  ,    curName ,    ex . getMessage (  )  ,    ex )  ;", "}", "}", "}", "beanFToProcess . resolveAliases ( valueResolver )  ;", "beanFToProcess . addEmbeddedValueResolver ( valueResolver )  ;", "}", "METHOD_END"], "methodName": ["doProcessProperties"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . ignoreUnresolvablePlaceholders    =    ignoreUnresolvablePlaceholders ;", "}", "METHOD_END"], "methodName": ["setIgnoreUnresolvablePlaceholders"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . nullValue    =    nullValue ;", "}", "METHOD_END"], "methodName": ["setNullValue"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . placeholderPrefix    =    placeholderPrefix ;", "}", "METHOD_END"], "methodName": ["setPlaceholderPrefix"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . placeholderSuffix    =    placeholderSuffix ;", "}", "METHOD_END"], "methodName": ["setPlaceholderSuffix"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . trimValues    =    trimValues ;", "}", "METHOD_END"], "methodName": ["setTrimValues"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "this . valueSeparator    =    valueSeparator ;", "}", "METHOD_END"], "methodName": ["setValueSeparator"], "fileName": "org.springframework.beans.factory.config.PlaceholderConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( path    !  =    null )     {", "try    {", "if    ( p . nodeExists ( path )  )     {", "return   p . node ( path )  . get ( key ,    null )  ;", "} else    {", "return   null ;", "}", "}    catch    ( BackingStoreException   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Cannot   access   specified   node   path    [  \"     +    path )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "return   p . get ( key ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["resolvePlaceholder"], "fileName": "org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . systemTreePath    =    systemTreePath ;", "}", "METHOD_END"], "methodName": ["setSystemTreePath"], "fileName": "org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . userTreePath    =    userTreePath ;", "}", "METHOD_END"], "methodName": ["setUserTreePath"], "fileName": "org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   mergeProperties (  )  ;", "}", "METHOD_END"], "methodName": ["createProperties"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBean"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "Properties   localProps    =    new   Properties (  )  ;", "localProps . setProperty (  \" key 2  \"  ,     \" value 2  \"  )  ;", "pfb . setProperties ( localProps )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \" value 2  \"  ,    props . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithLocalProperties"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setLocation (  . TEST _ PROPS )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  9  9  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPropertiesFile"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setLocation (  . TEST _ PROPS )  ;", "Properties   localProps    =    new   Properties (  )  ;", "localProps . setProperty (  \" key 2  \"  ,     \" value 2  \"  )  ;", "localProps . setProperty (  \" tb . array [  0  ]  . age \"  ,     \"  0  \"  )  ;", "pfb . setProperties ( localProps )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  9  9  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    props . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPropertiesFileAndLocalProperties"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setLocation (  . TEST _ PROPS )  ;", "Properties   localProps    =    new   Properties (  )  ;", "localProps . setProperty (  \" key 2  \"  ,     \" value 2  \"  )  ;", "localProps . setProperty (  \" tb . array [  0  ]  . age \"  ,     \"  0  \"  )  ;", "pfb . setProperties ( localProps )  ;", "pfb . setLocalOverride ( true )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  0  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    props . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPropertiesFileAndLocalPropertiesAndLocalOverride"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setLocation (  . TEST _ PROPS )  ;", "Properties   props 1     =    new   Properties (  )  ;", "props 1  . setProperty (  \" key 2  \"  ,     \" value 2  \"  )  ;", "props 1  . setProperty (  \" tb . array [  0  ]  . age \"  ,     \"  0  \"  )  ;", "Properties   props 2     =    new   Properties (  )  ;", "props 2  . setProperty (  \" spring \"  ,     \" framework \"  )  ;", "props 2  . setProperty (  \" Don \"  ,     \" Mattingly \"  )  ;", "Properties   props 3     =    new   Properties (  )  ;", "props 3  . setProperty (  \" spider \"  ,     \" man \"  )  ;", "props 3  . setProperty (  \" bat \"  ,     \" man \"  )  ;", "pfb . setPropertiesArray ( new   Properties [  ]  {    props 1  ,    props 2  ,    props 3     }  )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  9  9  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    props . getProperty (  \" key 2  \"  )  )  ;", "assertEquals (  \" framework \"  ,    props . getProperty (  \" spring \"  )  )  ;", "assertEquals (  \" Mattingly \"  ,    props . getProperty (  \" Don \"  )  )  ;", "assertEquals (  \" man \"  ,    props . getProperty (  \" spider \"  )  )  ;", "assertEquals (  \" man \"  ,    props . getProperty (  \" bat \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPropertiesFileAndMultipleLocalProperties"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setLocation (  . TEST _ PROPS _ XML )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  9  9  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPropertiesXmlFile"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesFactoryBean   pfb    =    new   PropertiesFactoryBean (  )  ;", "pfb . setSingleton ( false )  ;", "pfb . setLocation (  . TEST _ PROPS )  ;", "Properties   localProps    =    new   Properties (  )  ;", "localProps . setProperty (  \" key 2  \"  ,     \" value 2  \"  )  ;", "pfb . setProperties ( localProps )  ;", "pfb . afterPropertiesSet (  )  ;", "Properties   props    =    pfb . getObject (  )  ;", "assertEquals (  \"  9  9  \"  ,    props . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    props . getProperty (  \" key 2  \"  )  )  ;", "Properties   newProps    =    pfb . getObject (  )  ;", "assertTrue (  ( props    !  =    newProps )  )  ;", "assertEquals (  \"  9  9  \"  ,    newProps . getProperty (  \" tb . array [  0  ]  . age \"  )  )  ;", "assertEquals (  \" value 2  \"  ,    newProps . getProperty (  \" key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithPrototype"], "fileName": "org.springframework.beans.factory.config.PropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   bd    =    factory . getBeanDefinition ( beanName )  ;", "BeanDefinition   bdToUse    =    bd ;", "while    ( bd    !  =    null )     {", "bdToUse    =    bd ;", "bd    =    bd . getOriginatingBeanDefinition (  )  ;", "}", "PropertyValue   pv    =    new   PropertyValue ( property ,    value )  ;", "pv . setOptional ( this . ignoreInvalidKeys )  ;", "bdToUse . getPropertyValues (  )  . addPropertyValue ( pv )  ;", "}", "METHOD_END"], "methodName": ["applyPropertyValue"], "fileName": "org.springframework.beans.factory.config.PropertyOverrideConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   this . beanNames . contains ( beanName )  ;", "}", "METHOD_END"], "methodName": ["hasPropertyOverridesFor"], "fileName": "org.springframework.beans.factory.config.PropertyOverrideConfigurer"}, {"methodBody": ["METHOD_START", "{", "int   separatorIndex    =    key . indexOf ( this . beanNameSeparator )  ;", "if    ( separatorIndex    =  =     (  -  1  )  )     {", "throw   new   BeanInitializationException (  (  (  (  (  \" Invalid   key    '  \"     +    key )     +     \"  '  :    expected    ' beanName \"  )     +     ( this . beanNameSeparator )  )     +     \" property '  \"  )  )  ;", "}", "String   beanName    =    key . substring (  0  ,    separatorIndex )  ;", "String   bean    =    key . substring (  ( separatorIndex    +     1  )  )  ;", "this . beanNames . add ( beanName )  ;", "applyValue ( factory ,    beanName ,    bean ,    value )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \"     '  \"     +    key )     +     \"  '    set   to   value    [  \"  )     +    value )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processKey"], "fileName": "org.springframework.beans.factory.config.PropertyOverrideConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . beanNameSeparator    =    beanNameSeparator ;", "}", "METHOD_END"], "methodName": ["setBeanNameSeparator"], "fileName": "org.springframework.beans.factory.config.PropertyOverrideConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . ignoreInvalidKeys    =    ignoreInvalidKeys ;", "}", "METHOD_END"], "methodName": ["setIgnoreInvalidKeys"], "fileName": "org.springframework.beans.factory.config.PropertyOverrideConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . propertyPath    =    StringUtils . trimAllWhitespace ( propertyPath )  ;", "}", "METHOD_END"], "methodName": ["setPropertyPath"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . resultType    =    resultType ;", "}", "METHOD_END"], "methodName": ["setResultType"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    StringUtils . trimAllWhitespace ( targetBeanName )  ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanWrapper    =    PropertyAccessorFactory . forBeanPropertyAccess ( targetObject )  ;", "}", "METHOD_END"], "methodName": ["setTargetObject"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBean"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "TestBean   spouse    =     (  ( TestBean )     ( xbf . getBean (  \" otb . spouse \"  )  )  )  ;", "TestBean   tbWithInner    =     (  ( TestBean )     ( xbf . getBean (  \" tbWithInner \"  )  )  )  ;", "assertSame ( spouse ,    tbWithInner . getSpouse (  )  )  ;", "assertTrue (  (  !  ( tbWithInner . getFriends (  )  . isEmpty (  )  )  )  )  ;", "assertSame ( spouse ,    tbWithInner . getFriends (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanAsInnerBean"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "assertNull ( xbf . getBean (  \" tbWithInnerNull \"  ,    TestBean . class )  . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanAsInnerNull"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "assertNull ( xbf . getBean (  \" tbWithNullReference \"  ,    TestBean . class )  . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanAsNullReference"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "assertNull ( xbf . getType (  \" tb . spouse . spouse \"  )  )  ;", "assertEquals (  \" null \"  ,    xbf . getBean (  \" tb . spouse . spouse \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanWithNullResult"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "assertNull ( xbf . getType (  \" tb . spouse \"  )  )  ;", "assertEquals ( TestBean . class ,    xbf . getType (  \" propertyPath 3  \"  )  )  ;", "Object   result 1     =    xbf . getBean (  \" tb . spouse \"  )  ;", "Object   result 2     =    xbf . getBean (  \" propertyPath 3  \"  )  ;", "Object   result 3     =    xbf . getBean (  \" propertyPath 3  \"  )  ;", "assertTrue (  ( result 1    instanceof   TestBean )  )  ;", "assertTrue (  ( result 2    instanceof   TestBean )  )  ;", "assertTrue (  ( result 3    instanceof   TestBean )  )  ;", "assertEquals (  1  1  ,     (  ( TestBean )     ( result 1  )  )  . getAge (  )  )  ;", "assertEquals (  1  1  ,     (  ( TestBean )     ( result 2  )  )  . getAge (  )  )  ;", "assertEquals (  1  1  ,     (  ( TestBean )     ( result 3  )  )  . getAge (  )  )  ;", "assertTrue (  ( result 1     !  =    result 2  )  )  ;", "assertTrue (  ( result 1     !  =    result 3  )  )  ;", "assertTrue (  ( result 2     !  =    result 3  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanWithPrototypeResult"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( xbf )  . loadBeanDefinitions (  . CONTEXT )  ;", "assertEquals ( new   Integer (  1  2  )  ,    xbf . getBean (  \" propertyPath 1  \"  )  )  ;", "assertEquals ( new   Integer (  1  1  )  ,    xbf . getBean (  \" propertyPath 2  \"  )  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    xbf . getBean (  \" tb . age \"  )  )  ;", "assertEquals ( ITestBean . class ,    xbf . getType (  \" otb . spouse \"  )  )  ;", "Object   result 1     =    xbf . getBean (  \" otb . spouse \"  )  ;", "Object   result 2     =    xbf . getBean (  \" otb . spouse \"  )  ;", "assertTrue (  ( result 1    instanceof   TestBean )  )  ;", "assertTrue (  ( result 1     =  =    result 2  )  )  ;", "assertEquals (  9  9  ,     (  ( TestBean )     ( result 1  )  )  . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPathFactoryBeanWithSingletonResult"], "fileName": "org.springframework.beans.factory.config.PropertyPathFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "return   props . getProperty ( placeholder )  ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholder"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "String   propVal    =    null ;", "if    ( systemPropertiesMode    =  =     (  . SYSTEM _ PROPERTIES _ MODE _ OVERRIDE )  )     {", "propVal    =    resolveSystemProperty ( placeholder )  ;", "}", "if    ( propVal    =  =    null )     {", "propVal    =    resolvePlaceholder ( placeholder ,    props )  ;", "}", "if    (  ( propVal    =  =    null )     &  &     ( systemPropertiesMode    =  =     (  . SYSTEM _ PROPERTIES _ MODE _ FALLBACK )  )  )     {", "propVal    =    resolveSystemProperty ( placeholder )  ;", "}", "return   propVal ;", "}", "METHOD_END"], "methodName": ["resolvePlaceholder"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   value    =    System . get ( key )  ;", "if    (  ( value    =  =    null )     &  &     ( this . searchSystemEnvironment )  )     {", "value    =    System . getenv ( key )  ;", "}", "return   value ;", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Could   not   access   system   property    '  \"     +    key )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["resolveSystemProperty"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . searchSystemEnvironment    =    searchSystemEnvironment ;", "}", "METHOD_END"], "methodName": ["setSearchSystemEnvironment"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . systemPropertiesMode    =    systemPropertiesMode ;", "}", "METHOD_END"], "methodName": ["setSystemPropertiesMode"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . systemPropertiesMode    =    PropertyPlaceholderConfigurer . constants . asNumber ( constantName )  . intValue (  )  ;", "}", "METHOD_END"], "methodName": ["setSystemPropertiesModeName"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"}, {"methodBody": ["METHOD_START", "{", "System . clearProperty ( PropertyPlaceholderConfigurerTests . P 1  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "ppc . setPlaceholderPrefix (  \"  @  <  \"  )  ;", "ppc . setPlaceholderSuffix (  \"  >  \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  @  < key 1  >  \"  )  . addPropertyValue (  \" sex \"  ,     \"  $  { key 2  }  \"  )  . getBeanDefinition (  )  )  ;", "System . setProperty (  \" key 1  \"  ,     \" systemKey 1 Value \"  )  ;", "System . setProperty (  \" key 2  \"  ,     \" systemKey 2 Value \"  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "System . clearProperty (  \" key 1  \"  )  ;", "System . clearProperty (  \" key 2  \"  )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    is (  \" systemKey 1 Value \"  )  )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getSex (  )  ,    is (  \"  $  { key 2  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["customPlaceholderPrefixAndSuffix"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholderConfigurer   pc    =    new   PropertyPlaceholderConfigurer (  )  ;", "Resource   resource    =    new   ClassPathResource (  \"  . properties \"  ,    this . getClass (  )  )  ;", "pc . setLocation ( resource )  ;", "pc . postProcessBeanFactory ( bf )  ;", "}", "METHOD_END"], "methodName": ["localPropertiesViaResource"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "ppc . setNullValue (  \" customNull \"  )  ;", "System . setProperty (  \" my . name \"  ,     \" customNull \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    nullValue (  )  )  ;", "System . clearProperty (  \" my . name \"  )  ;", "}", "METHOD_END"], "methodName": ["nullValueIsPreserved"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "System . clearProperty ( PropertyPlaceholderConfigurerTests . P 1  )  ;", "BeanDefinitionReaderUtils . registerWithGeneratedName ( p 1 BeanDef ,    bf )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "TestBean   bean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( bean . getName (  )  ,    equalTo ( PropertyPlaceholderConfigurerTests . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFromLocalProperties"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" otherKey \"  ,     \" systemValue \"  )  ;", "p 1 BeanDef    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     (  (  \"  $  {  \"     +     (  . P 1  )  )     +     \"  }  \"  )  )  . addPropertyValue (  \" sex \"  ,     \"  $  { otherKey }  \"  )  . getBeanDefinition (  )  ;", "BeanDefinitionReaderUtils . registerWithGeneratedName ( p 1 BeanDef ,    bf )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "TestBean   bean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( bean . getName (  )  ,    equalTo (  . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "assertThat ( bean . getSex (  )  ,    equalTo (  \" systemValue \"  )  )  ;", "System . clearProperty (  \" otherKey \"  )  ;", "}", "METHOD_END"], "methodName": ["resolveFromSystemProperties"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerWithGeneratedName ( p 1 BeanDef ,    bf )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "TestBean   bean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( bean . getName (  )  ,    equalTo (  . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "}", "METHOD_END"], "methodName": ["setSystemPropertiesMode_defaultIsFallback"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerWithGeneratedName ( p 1 BeanDef ,    bf )  ;", "ppc . setSystemPropertiesMode ( PropertyPlaceholderConfigurer . SYSTEM _ PROPERTIES _ MODE _ OVERRIDE )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "TestBean   bean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( bean . getName (  )  ,    equalTo (  . P 1  _ SYSTEM _ PROPS _ VAL )  )  ;", "}", "METHOD_END"], "methodName": ["setSystemSystemPropertiesMode_toOverride_andResolveFromSystemProperties"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerWithGeneratedName ( p 1 BeanDef ,    bf )  ;", "System . clearProperty (  . P 1  )  ;", "ppc . setSearchSystemEnvironment ( false )  ;", "ppc . setSystemPropertiesMode ( PropertyPlaceholderConfigurer . SYSTEM _ PROPERTIES _ MODE _ OVERRIDE )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "TestBean   bean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( bean . getName (  )  ,    equalTo (  . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "}", "METHOD_END"], "methodName": ["setSystemSystemPropertiesMode_toOverride_andSetSearchSystemEnvironment_toFalse"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "p 1 BeanDef    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     (  (  \"  $  {  \"     +     ( PropertyPlaceholderConfigurerTests . P 1  )  )     +     \"  }  \"  )  )  . getBeanDefinition (  )  ;", "bf    =    new   DefaultListableBeanFactory (  )  ;", "ppcProperties    =    new   Properties (  )  ;", "ppcProperties . setProperty ( PropertyPlaceholderConfigurerTests . P 1  ,    PropertyPlaceholderConfigurerTests . P 1  _ LOCAL _ PROPS _ VAL )  ;", "System . setProperty ( PropertyPlaceholderConfigurerTests . P 1  ,    PropertyPlaceholderConfigurerTests . P 1  _ SYSTEM _ PROPS _ VAL )  ;", "ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "ppc . setProperties ( ppcProperties )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "ppc . setTrimValues ( true )  ;", "System . setProperty (  \" my . name \"  ,     \"    myValue       \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \" myValue \"  )  )  ;", "System . clearProperty (  \" my . name \"  )  ;", "}", "METHOD_END"], "methodName": ["trimValuesIsApplied"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "PropertyPlaceholderConfigurer   ppc    =    new   PropertyPlaceholderConfigurer (  )  ;", "System . setProperty (  \" my . name \"  ,     \"    myValue       \"  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" testBean \"  ,    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my . name }  \"  )  . getBeanDefinition (  )  )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "assertThat ( bf . getBean ( TestBean . class )  . getName (  )  ,    equalTo (  \"    myValue       \"  )  )  ;", "System . clearProperty (  \" my . name \"  )  ;", "}", "METHOD_END"], "methodName": ["trimValuesIsOffByDefault"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "String   P 2     =     \" p 2  \"  ;", "String   P 2  _ LOCAL _ PROPS _ VAL    =     \" p 2 LocalPropsVal \"  ;", "String   P 2  _ SYSTEM _ PROPS _ VAL    =     \" p 2 SystemPropsVal \"  ;", "String   P 2  _ SYSTEM _ ENV _ VAL    =     \" p 2 SystemEnvVal \"  ;", "AbstractBeanDefinition   p 2 BeanDef    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     (  (  \"  $  {  \"     +     (  . P 1  )  )     +     \"  }  \"  )  )  . addPropertyValue (  \" country \"  ,     (  (  \"  $  {  \"     +    P 2  )     +     \"  }  \"  )  )  . getBeanDefinition (  )  ;", "bf . registerBeanDefinition (  \" p 1 Bean \"  ,    p 1 BeanDef )  ;", "bf . registerBeanDefinition (  \" p 2 Bean \"  ,    p 2 BeanDef )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( bf )  ;", "System . setProperty ( P 2  ,    P 2  _ SYSTEM _ PROPS _ VAL )  ;", "Properties   ppc 2 Properties    =    new   Properties (  )  ;", "ppc 2 Properties . put ( P 2  ,    P 2  _ LOCAL _ PROPS _ VAL )  ;", "PropertyPlaceholderConfigurer   ppc 2     =    new   PropertyPlaceholderConfigurer (  )  ;", "ppc 2  . setSystemPropertiesMode ( PropertyPlaceholderConfigurer . SYSTEM _ PROPERTIES _ MODE _ OVERRIDE )  ;", "ppc 2  . setProperties ( ppc 2 Properties )  ;", "ppc 2 Properties    =    new   Properties (  )  ;", "ppc 2 Properties . setProperty ( P 2  ,    P 2  _ LOCAL _ PROPS _ VAL )  ;", "ppc 2  . postProcessBeanFactory ( bf )  ;", "TestBean   p 1 Bean    =    bf . getBean (  \" p 1 Bean \"  ,    TestBean . class )  ;", "assertThat ( p 1 Bean . getName (  )  ,    equalTo (  . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "TestBean   p 2 Bean    =    bf . getBean (  \" p 2 Bean \"  ,    TestBean . class )  ;", "assertThat ( p 2 Bean . getName (  )  ,    equalTo (  . P 1  _ LOCAL _ PROPS _ VAL )  )  ;", "assertThat ( p 2 Bean . getCountry (  )  ,    equalTo ( P 2  _ SYSTEM _ PROPS _ VAL )  )  ;", "System . clearProperty ( P 2  )  ;", "}", "METHOD_END"], "methodName": ["twoPlaceholderConfigurers_withConflictingSettings"], "fileName": "org.springframework.beans.factory.config.PropertyPlaceholderConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "Enumeration <  ?  >    propertyNames    =    props . propertyNames (  )  ;", "while    ( propertyNames . hasMoreElements (  )  )     {", "String   propertyName    =     (  ( String )     ( propertyNames . nextElement (  )  )  )  ;", "String   propertyValue    =    props . get ( propertyName )  ;", "String   convertedValue    =    convert ( propertyName ,    propertyValue )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( propertyValue ,    convertedValue )  )  )     {", "props . set ( propertyName ,    convertedValue )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["convertProperties"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   convertPropertyValue ( propertyValue )  ;", "}", "METHOD_END"], "methodName": ["convertProperty"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   originalValue ;", "}", "METHOD_END"], "methodName": ["convertPropertyValue"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurer"}, {"methodBody": ["METHOD_START", "{", "this . order    =    order ;", "}", "METHOD_END"], "methodName": ["setOrder"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurer"}, {"methodBody": ["METHOD_START", "{", "Map   singletonMap    =    Collections . singletonMap (  \" myKey \"  ,     \" myValue \"  )  ;", "if    ( parentChildSeparation )     {", "MutablePropertyValues   pvs 1     =    new   MutablePropertyValues (  )  ;", "pvs 1  . add (  \" age \"  ,     \"  $  { age }  \"  )  ;", "MutablePropertyValues   pvs 2     =    new   MutablePropertyValues (  )  ;", "pvs 2  . add (  \" name \"  ,     \" name $  { var }  $  { var }  $  {  \"  )  ;", "pvs 2  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "pvs 2  . add (  \" someMap \"  ,    singletonMap )  ;", "RootBeanDefinition   parent    =    new   RootBeanDefinition ( TestBean . class )  ;", "parent . setPropertyValues ( pvs 1  )  ;", "ChildBeanDefinition   bd    =    new   ChildBeanDefinition (  \"  $  { parent }  \"  ,    pvs 2  )  ;", "factory . registerBeanDefinition (  \" parent 1  \"  ,    parent )  ;", "factory . registerBeanDefinition (  \" tb 1  \"  ,    bd )  ;", "} else    {", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" age \"  ,     \"  $  { age }  \"  )  ;", "pvs . add (  \" name \"  ,     \" name $  { var }  $  { var }  $  {  \"  )  ;", "pvs . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "pvs . add (  \" someMap \"  ,    singletonMap )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setPropertyValues ( pvs )  ;", "factory . registerBeanDefinition (  \" tb 1  \"  ,    bd )  ;", "}", "ConstructorArgumentValues   cas    =    new   ConstructorArgumentValues (  )  ;", "cas . addIndexedArgumentValue (  1  ,     \"  $  { age }  \"  )  ;", "cas . addGenericArgumentValue (  \"  $  { var } name $  { age }  \"  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" stringArray \"  ,    new   String [  ]  {     \"  $  { os . name }  \"  ,     \"  $  { age }  \"     }  )  ;", "List < Object >    friends    =    new   ManagedList <  >  (  )  ;", "friends . add (  \" na $  { age } me \"  )  ;", "friends . add ( new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "pvs . add (  \" friends \"  ,    friends )  ;", "Set < Object >    someSet    =    new   ManagedSet <  >  (  )  ;", "someSet . add (  \" na $  { age } me \"  )  ;", "someSet . add ( new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "someSet . add ( new   TypedStringValue (  \"  $  { age }  \"  ,    Integer . class )  )  ;", "pvs . add (  \" someSet \"  ,    someSet )  ;", "Map < Object ,    Object >    someMap    =    new   ManagedMap <  >  (  )  ;", "someMap . put ( new   TypedStringValue (  \" key $  { age }  \"  )  ,    new   TypedStringValue (  \"  $  { age }  \"  )  )  ;", "someMap . put ( new   TypedStringValue (  \" key $  { age } ref \"  )  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "someMap . put (  \" key 1  \"  ,    new   RuntimeBeanReference (  \"  $  { ref }  \"  )  )  ;", "someMap . put (  \" key 2  \"  ,     \"  $  { age } name \"  )  ;", "MutablePropertyValues   innerPvs    =    new   MutablePropertyValues (  )  ;", "innerPvs . add (  \" country \"  ,     \"  $  { os . name }  \"  )  ;", "RootBeanDefinition   innerBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "innerBd . setPropertyValues ( innerPvs )  ;", "someMap . put (  \" key 3  \"  ,    innerBd )  ;", "MutablePropertyValues   innerPvs 2     =    new   MutablePropertyValues ( innerPvs )  ;", "someMap . put (  \"  $  { key 4  }  \"  ,    new   BeanDefinitionHolder ( new   ChildBeanDefinition (  \" tb 1  \"  ,    innerPvs 2  )  ,     \" child \"  )  )  ;", "pvs . add (  \" someMap \"  ,    someMap )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class ,    cas ,    pvs )  ;", "factory . registerBeanDefinition (  \" tb 2  \"  ,    bd )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" age \"  ,     \"  9  8  \"  )  ;", "props . setProperty (  \" var \"  ,     \"  $  { m } var \"  )  ;", "props . setProperty (  \" ref \"  ,     \" tb 2  \"  )  ;", "props . setProperty (  \" m \"  ,     \" my \"  )  ;", "props . setProperty (  \" key 4  \"  ,     \" mykey 4  \"  )  ;", "props . setProperty (  \" parent \"  ,     \" parent 1  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb 1     =     (  ( TestBean )     ( factory . getBean (  \" tb 1  \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( factory . getBean (  \" tb 2  \"  )  )  )  ;", "assertEquals (  9  8  ,    tb 1  . getAge (  )  )  ;", "assertEquals (  9  8  ,    tb 2  . getAge (  )  )  ;", "assertEquals (  \" namemyvarmyvar $  {  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" myvarname 9  8  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals ( tb 2  ,    tb 1  . getSpouse (  )  )  ;", "assertEquals (  1  ,    tb 1  . getSomeMap (  )  . size (  )  )  ;", "assertEquals (  \" myValue \"  ,    tb 1  . getSomeMap (  )  . get (  \" myKey \"  )  )  ;", "assertEquals (  2  ,    tb 2  . getStringArray (  )  . length )  ;", "assertEquals ( System . getProperty (  \" os . name \"  )  ,    tb 2  . getStringArray (  )  [  0  ]  )  ;", "assertEquals (  \"  9  8  \"  ,    tb 2  . getStringArray (  )  [  1  ]  )  ;", "assertEquals (  2  ,    tb 2  . getFriends (  )  . size (  )  )  ;", "assertEquals (  \" na 9  8 me \"  ,    tb 2  . getFriends (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( tb 2  ,    tb 2  . getFriends (  )  . toArray (  )  [  1  ]  )  ;", "assertEquals (  3  ,    tb 2  . getSomeSet (  )  . size (  )  )  ;", "assertTrue ( tb 2  . getSomeSet (  )  . contains (  \" na 9  8 me \"  )  )  ;", "assertTrue ( tb 2  . getSomeSet (  )  . contains ( tb 2  )  )  ;", "assertTrue ( tb 2  . getSomeSet (  )  . contains ( new   Integer (  9  8  )  )  )  ;", "assertEquals (  6  ,    tb 2  . getSomeMap (  )  . size (  )  )  ;", "assertEquals (  \"  9  8  \"  ,    tb 2  . getSomeMap (  )  . get (  \" key 9  8  \"  )  )  ;", "assertEquals ( tb 2  ,    tb 2  . getSomeMap (  )  . get (  \" key 9  8 ref \"  )  )  ;", "assertEquals ( tb 2  ,    tb 2  . getSomeMap (  )  . get (  \" key 1  \"  )  )  ;", "assertEquals (  \"  9  8 name \"  ,    tb 2  . getSomeMap (  )  . get (  \" key 2  \"  )  )  ;", "TestBean   inner 1     =     (  ( TestBean )     ( tb 2  . getSomeMap (  )  . get (  \" key 3  \"  )  )  )  ;", "TestBean   inner 2     =     (  ( TestBean )     ( tb 2  . getSomeMap (  )  . get (  \" mykey 4  \"  )  )  )  ;", "assertEquals (  0  ,    inner 1  . getAge (  )  )  ;", "assertEquals ( null ,    inner 1  . getName (  )  )  ;", "assertEquals ( System . getProperty (  \" os . name \"  )  ,    inner 1  . getCountry (  )  )  ;", "assertEquals (  9  8  ,    inner 2  . getAge (  )  )  ;", "assertEquals (  \" namemyvarmyvar $  {  \"  ,    inner 2  . getName (  )  )  ;", "assertEquals ( System . getProperty (  \" os . name \"  )  ,    inner 2  . getCountry (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestPropertyPlaceholderConfigurer"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { myName }  \"  )  . addPropertyValue (  \" age \"  ,     \"  $  { myAge }  \"  )  . addPropertyValue (  \" touchy \"  ,     \"  $  { myTouchy }  \"  )  . getBeanDefinition (  )  )  ;", "PreferencesPlaceholder   ppc    =    new   PreferencesPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" myAge \"  ,     \"  9  9  \"  )  ;", "ppc . setProperties ( props )  ;", "Preferences . systemRoot (  )  . put (  \" myName \"  ,     \" myNameValue \"  )  ;", "Preferences . systemRoot (  )  . put (  \" myTouchy \"  ,     \" myTouchyValue \"  )  ;", "Preferences . userRoot (  )  . put (  \" myTouchy \"  ,     \" myOtherTouchyValue \"  )  ;", "ppc . afterPropertiesSet (  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" myNameValue \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "assertEquals (  \" myOtherTouchyValue \"  ,    tb . getTouchy (  )  )  ;", "Preferences . userRoot (  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . remove (  \" myName \"  )  ;", "}", "METHOD_END"], "methodName": ["testPreferencesPlaceholderConfigurer"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { myName }  \"  )  . addPropertyValue (  \" age \"  ,     \"  $  { myAge }  \"  )  . addPropertyValue (  \" touchy \"  ,     \"  $  { myTouchy }  \"  )  . getBeanDefinition (  )  )  ;", "PreferencesPlaceholder   ppc    =    new   PreferencesPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" myAge \"  ,     \"  9  9  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . setSystemTreePath (  \" mySystemPath \"  )  ;", "ppc . setUserTreePath (  \" myUserPath \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath \"  )  . put (  \" myName \"  ,     \" myNameValue \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath \"  )  . put (  \" myTouchy \"  ,     \" myTouchyValue \"  )  ;", "Preferences . userRoot (  )  . node (  \" myUserPath \"  )  . put (  \" myTouchy \"  ,     \" myOtherTouchyValue \"  )  ;", "ppc . afterPropertiesSet (  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" myNameValue \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "assertEquals (  \" myOtherTouchyValue \"  ,    tb . getTouchy (  )  )  ;", "Preferences . userRoot (  )  . node (  \" myUserPath \"  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath \"  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath \"  )  . remove (  \" myName \"  )  ;", "}", "METHOD_END"], "methodName": ["testPreferencesPlaceholderConfigurerWithCustomTreePaths"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { mypath / myName }  \"  )  . addPropertyValue (  \" age \"  ,     \"  $  { myAge }  \"  )  . addPropertyValue (  \" touchy \"  ,     \"  $  { myotherpath / myTouchy }  \"  )  . getBeanDefinition (  )  )  ;", "PreferencesPlaceholder   ppc    =    new   PreferencesPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" myAge \"  ,     \"  9  9  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . setSystemTreePath (  \" mySystemPath \"  )  ;", "ppc . setUserTreePath (  \" myUserPath \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath \"  )  . node (  \" mypath \"  )  . put (  \" myName \"  ,     \" myNameValue \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath / myotherpath \"  )  . put (  \" myTouchy \"  ,     \" myTouchyValue \"  )  ;", "Preferences . userRoot (  )  . node (  \" myUserPath / myotherpath \"  )  . put (  \" myTouchy \"  ,     \" myOtherTouchyValue \"  )  ;", "ppc . afterPropertiesSet (  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" myNameValue \"  ,    tb . getName (  )  )  ;", "assertEquals (  9  9  ,    tb . getAge (  )  )  ;", "assertEquals (  \" myOtherTouchyValue \"  ,    tb . getTouchy (  )  )  ;", "Preferences . userRoot (  )  . node (  \" myUserPath / myotherpath \"  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath / myotherpath \"  )  . remove (  \" myTouchy \"  )  ;", "Preferences . systemRoot (  )  . node (  \" mySystemPath / mypath \"  )  . remove (  \" myName \"  )  ;", "}", "METHOD_END"], "methodName": ["testPreferencesPlaceholderConfigurerWithPathInPlaceholder"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def 1     =    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb 1  \"  ,    def 1  )  ;", "BeanDefinition   def 2     =    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb 2  \"  ,    def 2  )  ;", "PropertyOverrid   poc 1  ;", "PropertyOverrid   poc 2  ;", "{", "poc 1     =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb 1  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test \"  )  ;", "poc 1  . setProperties ( props )  ;", "}", "{", "poc 2     =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb 2  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test 2  \"  )  ;", "poc 2  . setProperties ( props )  ;", "}", "poc 2  . postProcessBeanFactory ( factory )  ;", "poc 1  . postProcessBeanFactory ( factory )  ;", "TestBean   tb 1     =     (  ( TestBean )     ( factory . getBean (  \" tb 1  \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( factory . getBean (  \" tb 2  \"  )  )  )  ;", "assertEquals (  9  9  ,    tb 1  . getAge (  )  )  ;", "assertEquals (  9  9  ,    tb 2  . getAge (  )  )  ;", "assertEquals ( null ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" test \"  ,    tb 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurer"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", ". ConvertingOverrideConfigurer   bfpp    =    new    . ConvertingOverrideConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb . array [  0  ]  . name \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb . list [  1  ]  . name \"  ,     \" test \"  )  ;", "bfpp . setProperties ( props )  ;", "bfpp . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" X 9  9  \"  ,    tb . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" Xtest \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithConvertProperties"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( PropertyResourceConfigurerTests . PropertiesHolder . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrideConfigurer   poc ;", "poc    =    new   PropertyOverrideConfigurer (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb . heldProperties [ mail . smtp . auth ]  \"  ,     \" true \"  )  ;", "poc . setProperties ( props )  ;", "poc . postProcessBeanFactory ( factory )  ;", "PropertyResourceConfigurerTests . PropertiesHolder   tb    =     (  ( PropertyResourceConfigurerTests . PropertiesHolder )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" true \"  ,    tb . getHeldProperties (  )  . getProperty (  \" mail . smtp . auth \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithHeldProperties"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb 1  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "factory . registerBeanDefinition (  \" tb 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "{", "PropertyOverrid   poc    =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb 2  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test 2  \"  )  ;", "poc . setProperties ( props )  ;", "poc . setOrder (  0  )  ;", "poc . postProcessBeanFactory ( factory )  ;", "}", "{", "PropertyOverrid   poc    =    new   PropertyOverrid (  )  ;", "poc . setIgnoreInvalidKeys ( true )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" argh \"  ,     \" hgra \"  )  ;", "props . setProperty (  \" tb 1  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test \"  )  ;", "poc . setProperties ( props )  ;", "poc . postProcessBeanFactory ( factory )  ;", "}", "TestBean   tb 1     =     (  ( TestBean )     ( factory . getBean (  \" tb 1  \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( factory . getBean (  \" tb 2  \"  )  )  )  ;", "assertEquals (  9  9  ,    tb 1  . getAge (  )  )  ;", "assertEquals (  9  9  ,    tb 2  . getAge (  )  )  ;", "assertEquals ( null ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" test \"  ,    tb 2  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithIgnoreInvalidKeys"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb 1  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "factory . registerBeanDefinition (  \" tb 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "{", "PropertyOverrid   poc    =    new   PropertyOverrid (  )  ;", "poc . setIgnoreInvalidKeys ( true )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" argh \"  ,     \" hgra \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test \"  )  ;", "props . setProperty (  \" tb 2  . nam \"  ,     \" test \"  )  ;", "props . setProperty (  \" tb 3  . name \"  ,     \" test \"  )  ;", "poc . setProperties ( props )  ;", "poc . postProcessBeanFactory ( factory )  ;", "assertEquals (  \" test \"  ,    factory . getBean (  \" tb 2  \"  ,    TestBean . class )  . getName (  )  )  ;", "}", "{", "PropertyOverrid   poc    =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" argh \"  ,     \" hgra \"  )  ;", "props . setProperty (  \" tb 2  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb 2  . name \"  ,     \" test 2  \"  )  ;", "poc . setProperties ( props )  ;", "poc . setOrder (  0  )  ;", "try    {", "poc . postProcessBeanFactory ( factory )  ;", "}    catch    ( BeanInitializationException   ex )     {", "assertTrue ( ex . getMessage (  )  . toLowerCase (  )  . contains (  \" argh \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithInvalidKey"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrideConfigurer   poc    =    new   PropertyOverrideConfigurer (  )  ;", "poc . setLocations (  . TEST _ PROPS ,     . XTEST _ PROPS )  ;", "poc . setIgnoreResourceNotFound ( true )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  9  9  ,    tb . getArray (  )  [  0  ]  . getAge (  )  )  ;", "assertEquals (  \" test \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithInvalidPropertiesFile"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrid   poc ;", "poc    =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb . map [ key 1  ]  \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb . map [ key 2  . ext ]  \"  ,     \" test \"  )  ;", "poc . setProperties ( props )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \"  9  9  \"  ,    tb . getMap (  )  . get (  \" key 1  \"  )  )  ;", "assertEquals (  \" test \"  ,    tb . getMap (  )  . get (  \" key 2  . ext \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithNestedMapPropertyAndDotInMapKey"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrid   poc ;", "poc    =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" tb . array [  0  ]  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" tb . list [  1  ]  . name \"  ,     \" test \"  )  ;", "poc . setProperties ( props )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  9  9  ,    tb . getArray (  )  [  0  ]  . getAge (  )  )  ;", "assertEquals (  \" test \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithNestedProperty"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" my . tb \"  ,    def )  ;", "PropertyOverrid   poc ;", "poc    =    new   PropertyOverrid (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" my . tb _ array [  0  ]  . age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" my . tb _ list [  1  ]  . name \"  ,     \" test \"  )  ;", "poc . setProperties ( props )  ;", "poc . setBeanNameSeparator (  \"  _  \"  )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" my . tb \"  )  )  )  ;", "assertEquals (  9  9  ,    tb . getArray (  )  [  0  ]  . getAge (  )  )  ;", "assertEquals (  \" test \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithNestedPropertyAndDotInBeanName"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrideConfigurer   poc    =    new   PropertyOverrideConfigurer (  )  ;", "poc . setLocation (  . TEST _ PROPS )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  9  9  ,    tb . getArray (  )  [  0  ]  . getAge (  )  )  ;", "assertEquals (  \" test \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithPropertiesFile"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   def    =    BeanDefinitionBuilder . genericBeanDefinition ( IndexedTestBean . class )  . getBeanDefinition (  )  ;", "factory . registerBeanDefinition (  \" tb \"  ,    def )  ;", "PropertyOverrideConfigurer   poc    =    new   PropertyOverrideConfigurer (  )  ;", "poc . setLocation (  . TEST _ PROPS _ XML )  ;", "poc . postProcessBeanFactory ( factory )  ;", "IndexedTestBean   tb    =     (  ( IndexedTestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  9  9  ,    tb . getArray (  )  [  0  ]  . getAge (  )  )  ;", "assertEquals (  \" test \"  ,     (  ( TestBean )     ( tb . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyOverrideConfigurerWithPropertiesXmlFile"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "doTestPropertyPlaceholderConfigurer ( false )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurer"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" touchy \"  ,     \"  $  { test }  \"  )  . getBeanDefinition (  )  )  ;", "factory . registerAlias (  \" tb \"  ,     \"  $  { myAlias }  \"  )  ;", "factory . registerAlias (  \"  $  { myTarget }  \"  ,     \" alias 2  \"  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" test \"  ,     \" mytest \"  )  ;", "props . put (  \" myAlias \"  ,     \" alias \"  )  ;", "props . put (  \" myTarget \"  ,     \" tb \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" mytest \"  ,    tb . getTouchy (  )  )  ;", "tb    =     (  ( TestBean )     ( factory . getBean (  \" alias \"  )  )  )  ;", "assertEquals (  \" mytest \"  ,    tb . getTouchy (  )  )  ;", "tb    =     (  ( TestBean )     ( factory . getBean (  \" alias 2  \"  )  )  )  ;", "assertEquals (  \" mytest \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithAliases"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" age \"  ,     \"  $  { age }  \"  )  . addPropertyValue (  \" name \"  ,     \" name $  { var }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" age \"  ,     \"  9  9  \"  )  ;", "props . setProperty (  \" var \"  ,     \"  $  { m }  \"  )  ;", "props . setProperty (  \" m \"  ,     \"  $  { var }  \"  )  ;", "ppc . setProperties ( props )  ;", "try    {", "ppc . postProcessBeanFactory ( factory )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithCircularReference"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" touchy \"  ,     \"  $  { test }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" test \"  ,     \" mytest \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" mytest \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithDefaultProperties"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . setNullValue (  \"  \"  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertNull ( tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithEmptyStringAsNull"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { ref }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . setNullValue (  \"  \"  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" ref \"  ,     \"  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertNull ( tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithEmptyStringInPlaceholderAsNull"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { ref }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . setIgnoreUnresolvablePlaceholders ( true )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \"  $  { ref }  \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithIgnoreUnresolvablePlaceholder"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" touchy \"  ,     \"  $  { test : mytest }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" mytest \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithInlineDefault"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { my $  { key } key }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" key \"  ,     \" new \"  )  ;", "props . put (  \" mynewkey \"  ,     \" myname \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" myname \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithNestedPlaceholderInKey"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" country \"  ,     \"  $  { os . name }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" os . name \"  ,     \" myos \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . setSystemPropertiesMode ( PropertyPlaceholder . SYSTEM _ PROPERTIES _ MODE _ OVERRIDE )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals ( System . getProperty (  \" os . name \"  )  ,    tb . getCountry (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithOverridingSystemProperty"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "doTestPropertyPlaceholderConfigurer ( true )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithParentChildSeparation"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "factory . registerAlias (  \" tb \"  ,     \"  $  { alias }  \"  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" alias \"  ,     \" tb 2  \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( factory . getBean (  \" tb 2  \"  )  )  )  ;", "assertSame ( tb ,    tb 2  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithPlaceholderInAlias"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . getBeanDefinition (  )  )  ;", "factory . registerAlias (  \" tb \"  ,     \"  $  { alias }  \"  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . put (  \" alias \"  ,     \" tb \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertNotNull ( tb )  ;", "assertEquals (  0  ,    factory . getAliases (  \" tb \"  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithSelfReferencingPlaceholderInAlias"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" country \"  ,     \"  $  { os . name }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals ( System . getProperty (  \" os . name \"  )  ,    tb . getCountry (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithSystemPropertyFallback"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" country \"  ,     \"  $  { os . name }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  \" os . name \"  ,     \" myos \"  )  ;", "ppc . setProperties ( props )  ;", "ppc . postProcessBeanFactory ( factory )  ;", "TestBean   tb    =     (  ( TestBean )     ( factory . getBean (  \" tb \"  )  )  )  ;", "assertEquals (  \" myos \"  ,    tb . getCountry (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithSystemPropertyNotUsed"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" name \"  ,     \"  $  { ref }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "try    {", "ppc . postProcessBeanFactory ( factory )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" ref \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithUnresolvablePlaceholder"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "factory . registerBeanDefinition (  \" tb \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( TestBean . class )  . addPropertyValue (  \" touchy \"  ,     \"  $  { user . dir }  \"  )  . getBeanDefinition (  )  )  ;", "PropertyPlaceholder   ppc    =    new   PropertyPlaceholder (  )  ;", "ppc . setSystemPropertiesMode ( PropertyPlaceholder . SYSTEM _ PROPERTIES _ MODE _ NEVER )  ;", "try    {", "ppc . postProcessBeanFactory ( factory )  ;", "fail (  \" Should   have   thrown   BeanDefinitionStoreException \"  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" user . dir \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPropertyPlaceholderConfigurerWithUnresolvableSystemProperty"], "fileName": "org.springframework.beans.factory.config.PropertyResourceConfigurerTests"}, {"methodBody": ["METHOD_START", "{", "this . targetBeanName    =    targetBeanName ;", "}", "METHOD_END"], "methodName": ["setTargetBeanName"], "fileName": "org.springframework.beans.factory.config.ProviderCreatingFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.config.RuntimeBeanNameReference"}, {"methodBody": ["METHOD_START", "{", "return   this . toParent ;", "}", "METHOD_END"], "methodName": ["isToParent"], "fileName": "org.springframework.beans.factory.config.RuntimeBeanReference"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.config.RuntimeBeanReference"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    paramTypes    =    exceptionConstructor . getParameterTypes (  )  ;", "Object [  ]    args    =    new   Object [ paramTypes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( paramTypes . length )  ;    i +  +  )     {", "if    (  ( String . class )     =  =     ( paramTypes [ i ]  )  )     {", "args [ i ]     =    cause . getMessage (  )  ;", "} else", "if    ( paramTypes [ i ]  . isInstance ( cause )  )     {", "args [ i ]     =    cause ;", "}", "}", "return   BeanUtils . instantiateClass ( exceptionConstructor ,    args )  ;", "}", "METHOD_END"], "methodName": ["createServiceLocatorException"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Constructor < Exception >  )     ( exceptionClass . getConstructor ( String . class ,    Throwable . class )  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "try    {", "return    (  ( Constructor < Exception >  )     ( exceptionClass . getConstructor ( Throwable . class )  )  )  ;", "}    catch    ( NoSuchMethodException   ex 2  )     {", "try    {", "return    (  ( Constructor < Exception >  )     ( exceptionClass . getConstructor ( String . class )  )  )  ;", "}    catch    ( NoSuchMethodException   ex 3  )     {", "throw   new   IllegalArgumentException (  (  (  \"    locator   exception    [  \"     +     ( exceptionClass . getName (  )  )  )     +     \"  ]    neither   has   a    ( String ,    Throwable )    constructor   nor   a    ( String )    constructor \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["determineServiceLocatorExceptionConstructor"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceLocatorExceptionConstructor    =    determineServiceLocatorExceptionConstructor ( serviceLocatorExceptionClass )  ;", "}", "METHOD_END"], "methodName": ["setServiceLocatorExceptionClass"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceLocatorInterface    =    interfaceType ;", "}", "METHOD_END"], "methodName": ["setServiceLocatorInterface"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceMappings    =    serviceMappings ;", "}", "METHOD_END"], "methodName": ["setServiceMappings"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBean"}, {"methodBody": ["METHOD_START", "{", "bf    =    new   DefaultListableBeanFactory (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerAlias (  \" testService \"  ,     \"  1  \"  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator 3  . class )  . getBeanDefinition (  )  )  ;", "ServiceLocatorFactoryBeanTests . TestServiceLocator 3    factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator 3  )     ( bf . getBean (  \" factory \"  )  )  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 1     =    factory . getTestService (  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 2     =    factory . getTestService (  \" testService \"  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 3     =    factory . getTestService (  1  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 4     =    factory . someFactoryMethod (  )  ;", "assertNotSame ( testBean 1  ,    testBean 2  )  ;", "assertNotSame ( testBean 1  ,    testBean 3  )  ;", "assertNotSame ( testBean 1  ,    testBean 4  )  ;", "assertNotSame ( testBean 2  ,    testBean 3  )  ;", "assertNotSame ( testBean 2  ,    testBean 4  )  ;", "assertNotSame ( testBean 3  ,    testBean 4  )  ;", "assertTrue (  (  ( factory . toString (  )  . indexOf (  \" TestServiceLocator 3  \"  )  )     !  =     (  -  1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCombinedLocatorInterface"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" testServiceInstance 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator 2  . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory 3  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestService 2 Locator . class )  . getBeanDefinition (  )  )  ;", "try    {", "ServiceLocatorFactoryBeanTests . TestServiceLocator   factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator )     ( bf . getBean (  \" factory \"  )  )  )  ;", "factory . getTestService (  )  ;", "fail (  \" Must   fail   on   more   than   one   matching   type \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "try    {", "ServiceLocatorFactoryBeanTests . TestServiceLocator 2    factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator 2  )     ( bf . getBean (  \" factory 2  \"  )  )  )  ;", "factory . getTestService ( null )  ;", "fail (  \" Must   fail   on   more   than   one   matching   type \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "try    {", "ServiceLocatorFactoryBeanTests . TestService 2 Locator   factory    =     (  ( ServiceLocatorFactoryBeanTests . TestService 2 Locator )     ( bf . getBean (  \" factory 3  \"  )  )  )  ;", "factory . getTestService (  )  ;", "fail (  \" Must   fail   on   no   matching   types \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testErrorOnTooManyOrTooFew"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" testServiceInstance 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator . class )  . addPropertyValue (  \" serviceLocatorExceptionClass \"  ,    ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 1  . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator 2  . class )  . addPropertyValue (  \" serviceLocatorExceptionClass \"  ,    ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 2  . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory 3  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestService 2 Locator . class )  . addPropertyValue (  \" serviceLocatorExceptionClass \"  ,    ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 3  . class )  . getBeanDefinition (  )  )  ;", "try    {", "ServiceLocatorFactoryBeanTests . TestServiceLocator   factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator )     ( bf . getBean (  \" factory \"  )  )  )  ;", "factory . getTestService (  )  ;", "fail (  \" Must   fail   on   more   than   one   matching   type \"  )  ;", "}    catch    ( ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 1    expected )     {", "assertTrue (  (  ( expected . getCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "}", "try    {", "ServiceLocatorFactoryBeanTests . TestServiceLocator 2    factory 2     =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator 2  )     ( bf . getBean (  \" factory 2  \"  )  )  )  ;", "factory 2  . getTestService ( null )  ;", "fail (  \" Must   fail   on   more   than   one   matching   type \"  )  ;", "}    catch    ( ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 2    expected )     {", "assertTrue (  (  ( expected . getCause (  )  )    instanceof   NoSuchBeanDefinitionException )  )  ;", "}", "try    {", "ServiceLocatorFactoryBeanTests . TestService 2 Locator   factory 3     =     (  ( ServiceLocatorFactoryBeanTests . TestService 2 Locator )     ( bf . getBean (  \" factory 3  \"  )  )  )  ;", "factory 3  . getTestService (  )  ;", "fail (  \" Must   fail   on   no   matching   type \"  )  ;", "}    catch    ( ServiceLocatorFactoryBeanTests . CustomServiceLocatorException 3    ex )     {", "}", "}", "METHOD_END"], "methodName": ["testErrorOnTooManyOrTooFewWithCustomServiceLocatorException"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator . class )  . getBeanDefinition (  )  )  ;", "ServiceLocatorFactoryBeanTests . TestServiceLocator   factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator )     ( bf . getBean (  \" factory \"  )  )  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testService    =    factory . getTestService (  )  ;", "assertNotNull ( testService )  ;", "}", "METHOD_END"], "methodName": ["testNoArgGetter"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "new   ServiceLocatorFactoryBean (  )  . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testNoServiceLocatorInterfaceSupplied"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   beanFactory    =    mock ( BeanFactory . class )  ;", "try    {", "factory    =    new    (  )  ;", "factory . setBeanFactory ( beanFactory )  ;", "}    catch    ( FatalBeanException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testRequiresListableBeanFactoryAndChokesOnAnythingElse"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService 1  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" testService 2  \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . ExtendedTestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator 3  . class )  . addPropertyValue (  \" serviceMappings \"  ,     \"  = testService 1  \\ n 1  = testService 1  \\ n 2  = testService 2  \"  )  . getBeanDefinition (  )  )  ;", "ServiceLocatorFactoryBeanTests . TestServiceLocator 3    factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator 3  )     ( bf . getBean (  \" factory \"  )  )  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 1     =    factory . getTestService (  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 2     =    factory . getTestService (  \" testService 1  \"  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 3     =    factory . getTestService (  1  )  ;", "ServiceLocatorFactoryBeanTests . TestService   testBean 4     =    factory . getTestService (  2  )  ;", "assertNotSame ( testBean 1  ,    testBean 2  )  ;", "assertNotSame ( testBean 1  ,    testBean 3  )  ;", "assertNotSame ( testBean 1  ,    testBean 4  )  ;", "assertNotSame ( testBean 2  ,    testBean 3  )  ;", "assertNotSame ( testBean 2  ,    testBean 4  )  ;", "assertNotSame ( testBean 3  ,    testBean 4  )  ;", "assertFalse (  ( testBean 1    instanceof   ServiceLocatorFactoryBeanTests . ExtendedTestService )  )  ;", "assertFalse (  ( testBean 2    instanceof   ServiceLocatorFactoryBeanTests . ExtendedTestService )  )  ;", "assertFalse (  ( testBean 3    instanceof   ServiceLocatorFactoryBeanTests . ExtendedTestService )  )  ;", "assertTrue (  ( testBean 4    instanceof   ServiceLocatorFactoryBeanTests . ExtendedTestService )  )  ;", "}", "METHOD_END"], "methodName": ["testServiceMappings"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "bf . registerBeanDefinition (  \" testService \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBeanTests . TestService . class )  . getBeanDefinition (  )  )  ;", "bf . registerBeanDefinition (  \" factory \"  ,    BeanDefinitionBuilder . genericBeanDefinition ( ServiceLocatorFactoryBean . class )  . addPropertyValue (  \" serviceLocatorInterface \"  ,    ServiceLocatorFactoryBeanTests . TestServiceLocator 2  . class )  . getBeanDefinition (  )  )  ;", "ServiceLocatorFactoryBeanTests . TestServiceLocator 2    factory    =     (  ( ServiceLocatorFactoryBeanTests . TestServiceLocator 2  )     ( bf . getBean (  \" factory \"  )  )  )  ;", "@ SuppressWarnings (  \" unused \"  )", "ServiceLocatorFactoryBeanTests . TestService   testBean    =    factory . getTestService ( null )  ;", "testBean    =    factory . getTestService (  \" testService \"  )  ;", "try    {", "factory . getTestService (  \" bogusTestService \"  )  ;", "fail (  \" Illegal   operation   allowed \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testStringArgGetter"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ServiceLocatorFactoryBean   factory    =    new   ServiceLocatorFactoryBean (  )  ;", "factory . setServiceLocatorExceptionClass (  (  ( Class )     ( getClass (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhenServiceLocatorExceptionClassIsNotAnExceptionSubclass"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ServiceLocatorFactoryBean   factory    =    new   ServiceLocatorFactoryBean (  )  ;", "factory . setServiceLocatorExceptionClass (  . ExceptionClassWithOnlyZeroArgCtor . class )  ;", "}", "METHOD_END"], "methodName": ["testWhenServiceLocatorExceptionClassToExceptionTypeWithOnlyNoArgCtor"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ServiceLocatorFactoryBean   factory    =    new   ServiceLocatorFactoryBean (  )  ;", "factory . setServiceLocatorInterface ( getClass (  )  )  ;", "factory . afterPropertiesSet (  )  ;", "}", "METHOD_END"], "methodName": ["testWhenServiceLocatorInterfaceIsNotAnInterfaceType"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "ServiceLocatorFactoryBean   factory    =    new   ServiceLocatorFactoryBean (  )  ;", "factory . setServiceLocatorInterface (  . ServiceLocatorInterfaceWithExtraNonCompliantMethod . class )  ;", "factory . afterPropertiesSet (  )  ;", ". ServiceLocatorInterfaceWithExtraNonCompliantMethod   locator    =     (  (  . ServiceLocatorInterfaceWithExtraNonCompliantMethod )     ( factory . getObject (  )  )  )  ;", "locator . getTestService (  \" not \"  ,     \" allowed \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhenServiceLocatorMethodCalledWithTooManyParameters"], "fileName": "org.springframework.beans.factory.config.ServiceLocatorFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . sourceSet    =    sourceSet ;", "}", "METHOD_END"], "methodName": ["setSourceSet"], "fileName": "org.springframework.beans.factory.config.SetFactoryBean"}, {"methodBody": ["METHOD_START", "{", "if    ( targeClass    =  =    null )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   not   be   null \"  )  ;", "}", "if    (  !  . class . isAssignableFrom ( targeClass )  )  )     {", "throw   new   IllegalArgumentException (  \"  ' targeClass '    must   implement    [ util ]  \"  )  ;", "}", "this . targeClass    =    targeClass ;", "}", "METHOD_END"], "methodName": ["setTargetSetClass"], "fileName": "org.springframework.beans.factory.config.SetFactoryBean"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "Scope   scope    =    new   NoOpScope (  )     {", "private   int   index ;", "private   List < TestBean >    objects    =    new   LinkedList <  >  (  )  ;", "{", "objects . add ( new   TestBean (  )  )  ;", "objects . add ( new   TestBean (  )  )  ;", "}", "@ Override", "public   Object   get ( String   name ,    ObjectFactory <  ?  >    objectFactory )     {", "if    (  ( index )     >  =     ( objects . size (  )  )  )     {", "index    =     0  ;", "}", "return   objects . get (  (  ( index )  +  +  )  )  ;", "}", "}  ;", "beanFactory . registerScope (  \" myScope \"  ,    scope )  ;", "String [  ]    scopeNames    =    beanFactory . getRegisteredScopeNames (  )  ;", "assertEquals (  1  ,    scopeNames . length )  ;", "assertEquals (  \" myScope \"  ,    scopeNames [  0  ]  )  ;", "assertSame ( scope ,    beanFactory . getRegisteredScope (  \" myScope \"  )  )  ;", "XmlBeanDefinitionReader   xbdr    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "xbdr . loadBeanDefinitions (  . CONTEXT )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.config.SimpleScopeTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb 1     =     (  ( TestBean )     ( beanFactory . getBean (  \" usesScope \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( beanFactory . getBean (  \" usesScope \"  )  )  )  ;", "assertNotSame ( tb 1  ,    tb 2  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( beanFactory . getBean (  \" usesScope \"  )  )  )  ;", "assertSame ( tb 3  ,    tb 1  )  ;", "}", "METHOD_END"], "methodName": ["testCanGetScopedObject"], "fileName": "org.springframework.beans.factory.config.SimpleScopeTests"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["determineCandidateConstructors"], "fileName": "org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   bean ;", "}", "METHOD_END"], "methodName": ["getEarlyBeanReference"], "fileName": "org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["predictBeanType"], "fileName": "org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor"}, {"methodBody": ["METHOD_START", "{", "return   this . specifiedTypeName ;", "}", "METHOD_END"], "methodName": ["getSpecifiedTypeName"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "Object   targetTypeValue    =    this . targetType ;", "if    (  !  ( targetTypeValue   instanceof   Class )  )     {", "throw   new   IllegalStateException (  \" Typed      value   does   not   carry   a   resolved   target   type \"  )  ;", "}", "return    (  ( Class <  ?  >  )     ( targetTypeValue )  )  ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "Object   targetTypeValue    =    this . targetType ;", "if    ( targetTypeValue   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( targetTypeValue )  )  . getName (  )  ;", "} else    {", "return    (  (  )     ( targetTypeValue )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getTargetTypeName"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "return   this . value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "return    ( this . targetType )    instanceof   Class ;", "}", "METHOD_END"], "methodName": ["hasTargetType"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "return   this . dynamic ;", "}", "METHOD_END"], "methodName": ["isDynamic"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "String   typeName    =    getTargetTypeName (  )  ;", "if    ( typeName    =  =    null )     {", "return   null ;", "}", "Class <  ?  >    resolvedClass    =    ClassUtils . forName ( typeName ,    classLoader )  ;", "this . targetType    =    resolvedClass ;", "return   resolvedClass ;", "}", "METHOD_END"], "methodName": ["resolveTargetType"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "this . dynamic    =    true ;", "}", "METHOD_END"], "methodName": ["setDynamic"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "this . specifiedTypeName    =    specifiedTypeName ;", "}", "METHOD_END"], "methodName": ["setSpecifiedTypeName"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( targetType ,     \"  ' targetType '    must   not   be   null \"  )  ;", "this . targetType    =    targetType ;", "}", "METHOD_END"], "methodName": ["setTargetType"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "this . targetType    =    targetTypeName ;", "}", "METHOD_END"], "methodName": ["setTargetTypeName"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.springframework.beans.factory.config.TypedStringValue"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    result    =    new   LinkedHashMap <  >  (  )  ;", "process (  (    properties ,    map )     -  >    merge ( result ,    map )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createMap"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBean"}, {"methodBody": ["METHOD_START", "{", "map . forEach (  (    key ,    value )     -  >     {", "Object   existing    =    output . get ( key )  ;", "if    (  ( value   instanceof   Map )     &  &     ( existing   instanceof   Map )  )     {", "Map < St ,    Object >    result    =    new   LinkedHashMap <  >  (  (  ( Map < St ,    Object >  )     ( existing )  )  )  ;", "merge ( result ,     (  ( Map )     ( value )  )  )  ;", "output . put ( key ,    result )  ;", "} else    {", "output . put ( key ,    value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   ByteArrayResource (  \" mymap :  \\ n      foo :    bar \\ nmymap :  \\ n      bar :    foo \"  . getBytes (  )  )  )  ;", "Map < String ,    Object >    map    =    this . factory . getObject (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertTrue ( map . containsKey (  \" mymap \"  )  )  ;", "Object   object    =    map . get (  \" mymap \"  )  ;", "assertTrue (  ( object   instanceof   LinkedHashMap )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    sub    =     (  ( Map < String ,    Object >  )     ( object )  )  ;", "assertEquals (  1  ,    sub . size (  )  )  ;", "assertEquals (  \" foo \"  ,    sub . get (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDuplicateKey"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResolutionMethod ( YamlProcessor . ResolutionMethod . FIRST _ FOUND )  ;", "this . factory . setResources ( new   AbstractResource (  )     {", "@ Override", "public   String   getDescription (  )     {", "return    \" non - existent \"  ;", "}", "@ Override", "public   InputStream   getInputStream (  )    throws   IOException    {", "throw   new   IOException (  \" planned \"  )  ;", "}", "}  ,    new   ByteArrayResource (  \" foo :  \\ n      spam :    bar \"  . getBytes (  )  )  )  ;", "assertEquals (  1  ,    this . factory . getObject (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFirstFound"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   ByteArrayResource (  \" foo :    bar \"  . getBytes (  )  )  )  ;", "assertEquals (  1  ,    this . factory . getObject (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetObject"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n       ?    key 1  . key 2  \\ n       :     3  \"  . getBytes (  )  )  )  ;", "Map < String ,    Object >    map    =    this . factory . getObject (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertTrue ( map . containsKey (  \" foo \"  )  )  ;", "Object   object    =    map . get (  \" foo \"  )  ;", "assertTrue (  ( object   instanceof   LinkedHashMap )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    sub    =     (  ( Map < String ,    Object >  )     ( object )  )  ;", "assertEquals (  1  ,    sub . size (  )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    sub . get (  \" key 1  . key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithIntegerValue"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n       ?    key 1  . key 2  \\ n       :    value \"  . getBytes (  )  )  )  ;", "Map < String ,    Object >    map    =    this . factory . getObject (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertTrue ( map . containsKey (  \" foo \"  )  )  ;", "Object   object    =    map . get (  \" foo \"  )  ;", "assertTrue (  ( object   instanceof   LinkedHashMap )  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    sub    =     (  ( Map < String ,    Object >  )     ( object )  )  ;", "assertTrue ( sub . containsKey (  \" key 1  . key 2  \"  )  )  ;", "assertEquals (  \" value \"  ,    sub . get (  \" key 1  . key 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithPeriodsInKey"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n      bar :    spam \"  . getBytes (  )  )  ,    new   ByteArrayResource (  \" foo :  \\ n      spam :    bar \"  . getBytes (  )  )  )  ;", "assertEquals (  1  ,    this . factory . getObject (  )  . size (  )  )  ;", "assertEquals (  2  ,     (  ( Map < String ,    Object >  )     ( this . factory . getObject (  )  . get (  \" foo \"  )  )  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOverrideAndRemoveDefaults"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResources ( new   FileSystemResource (  \" non - exsitent - file . yml \"  )  )  ;", "assertEquals (  0  ,    this . factory . getObject (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetBarfOnResourceNotFound"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "this . factory . setResolutionMethod ( YamlProcessor . ResolutionMethod . OVERRIDE _ AND _ IGNORE )  ;", "this . factory . setResources ( new   FileSystemResource (  \" non - exsitent - file . yml \"  )  )  ;", "assertEquals (  0  ,    this . factory . getObject (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetIgnoreResourceNotFound"], "fileName": "org.springframework.beans.factory.config.YamlMapFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    result    =    new   LinkedHashMap <  >  (  )  ;", "if    (  !  ( object   instanceof   Map )  )     {", "result . put (  \" document \"  ,    object )  ;", "return   result ;", "}", "Map < Object ,    Object >    map    =     (  ( Map < Object ,    Object >  )     ( object )  )  ;", "map . forEach (  (    key ,    value )     -  >     {", "if    ( value   instanceof   Map )     {", "value    =    asMap ( value )  ;", "}", "if    ( key   instanceof   CharSequence )     {", "result . put ( key . toString (  )  ,    value )  ;", "} else    {", "result . put (  (  (  \"  [  \"     +     ( key . toString (  )  )  )     +     \"  ]  \"  )  ,    value )  ;", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["asMap"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "source . forEach (  (    key ,    value )     -  >     {", "if    ( StUtils . hasText ( path )  )     {", "if    ( key . startsWith (  \"  [  \"  )  )     {", "key    =    path    +    key ;", "} else    {", "key    =     ( path    +     '  .  '  )     +    key ;", "}", "}", "if    ( value   instanceof   St )     {", "result . put ( key ,    value )  ;", "} else", "if    ( value   instanceof   Map )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Map < St ,    Object >    map    =     (  ( Map < St ,    Object >  )     ( value )  )  ;", "buildFlattenedMap ( result ,    map ,    key )  ;", "} else", "if    ( value   instanceof   Collection )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Collection < Object >    collection    =     (  ( Collection < Object >  )     ( value )  )  ;", "int   count    =     0  ;", "for    ( Object   object    :    collection )     {", "buildFlattenedMap ( result ,    singletonMap (  (  (  \"  [  \"     +     ( count +  +  )  )     +     \"  ]  \"  )  ,    object )  ,    key )  ;", "}", "} else    {", "result . put ( key ,     ( value    !  =    null    ?    value    :     \"  \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["buildFlattenedMap"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   Yaml ( new   YamlProcessor . StrictMapAppenderConstructor (  )  )  ;", "}", "METHOD_END"], "methodName": ["createYaml"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    result    =    new   LinkedHashMap <  >  (  )  ;", "buildFlattenedMap ( result ,    source ,    null )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getFlattenedMap"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . resolutionMethod )     !  =     ( YamlProcessor . ResolutionMethod . FIRST _ FOUND )  )     &  &     (  ( this . resolutionMethod )     !  =     ( YamlProcessor . ResolutionMethod . OVERRIDE _ AND _ IGNORE )  )  )     {", "throw   new   IllegalStateException ( ex )  ;", "}", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  (  (  \" Could   not   load   map   from    \"     +    resource )     +     \"  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleProcessError"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    CollectionFactory . createStringAdaptingProperties (  )  ;", "properties . putAll ( getFlattenedMap ( map )  )  ;", "if    ( this . documentMatchers . isEmpty (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Merging   document    ( no   matchers   set )  :     \"     +    map )  )  ;", "}", "callback . process ( properties ,    map )  ;", "return   true ;", "}", ". MatchStatus   result    =     . MatchStatus . ABSTAIN ;", "for    (  . DocumentMatcher   matcher    :    this . documentMatchers )     {", ". MatchStatus   match    =    matcher . matches ( properties )  ;", "result    =     . MatchStatus . getMostSpecific ( match ,    result )  ;", "if    ( match    =  =     (  . MatchStatus . FOUND )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Matched   document   with   document   matcher :     \"     +    properties )  )  ;", "}", "callback . process ( properties ,    map )  ;", "return   true ;", "}", "}", "if    (  ( result    =  =     (  . MatchStatus . ABSTAIN )  )     &  &     ( this . matchDefault )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Matched   document   with   default   matcher :     \"     +    map )  )  ;", "}", "callback . process ( properties ,    map )  ;", "return   true ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Unmatched   document :     \"     +    map )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "Yaml   yaml    =    createYaml (  )  ;", "for    ( Resource   resource    :    this . resources )     {", "boolean   found    =    process ( callback ,    yaml ,    resource )  ;", "if    (  (  ( this . resolutionMethod )     =  =     (  . ResolutionMethod . FIRST _ FOUND )  )     &  &    found )     {", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "try    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Loading   from   YAML :     \"     +    resource )  )  ;", "}", "Reader   reader    =    new   UnicodeReader ( resource . getInputStream (  )  )  ;", "try    {", "for    ( Object   object    :    yaml . loadAll ( reader )  )     {", "if    (  ( object    !  =    null )     &  &     ( process ( asMap ( object )  ,    callback )  )  )     {", "count +  +  ;", "if    (  ( this . resolutionMethod )     =  =     (  . ResolutionMethod . FIRST _ FOUND )  )     {", "break ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" Loaded    \"     +    count )     +     \"    document \"  )     +     ( count    >     1     ?     \" s \"     :     \"  \"  )  )     +     \"    from   YAML   resource :     \"  )     +    resource )  )  ;", "}", "}    finally    {", "reader . close (  )  ;", "}", "}    catch    ( IOException   ex )     {", "handleProcessError ( resource ,    ex )  ;", "}", "return   count    >     0  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "this . documentMatchers    =    Arrays . asList ( matchers )  ;", "}", "METHOD_END"], "methodName": ["setDocumentMatchers"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "this . matchDefault    =    matchDefault ;", "}", "METHOD_END"], "methodName": ["setMatchDefault"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( resolutionMethod ,     \" ResolutionMethod   must   not   be   null \"  )  ;", "this . resolutionMethod    =    resolutionMethod ;", "}", "METHOD_END"], "methodName": ["setResolutionMethod"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "this . resources    =    resources ;", "}", "METHOD_END"], "methodName": ["setResources"], "fileName": "org.springframework.beans.factory.config.YamlProcessor"}, {"methodBody": ["METHOD_START", "{", "this . processor . setResources ( new   ByteArrayResource (  \" foo    #    a   document \\ nbar :    baz \"  . getBytes (  )  )  )  ;", "this . exception . expect ( ParserException . class )  ;", "this . exception . expectMessage (  \" line    2  ,    column    1  \"  )  ;", "this . processor . process ( new    . MatchCallback (  )     {", "@ Override", "public   void   process ( Properties   properties ,    Map < String ,    Object >    map )     {", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testBadDocumentStart"], "fileName": "org.springframework.beans.factory.config.YamlProcessorTests"}, {"methodBody": ["METHOD_START", "{", "this . processor . setResources ( new   ByteArrayResource (  \" foo :    bar \\ ncd \\ nspam :  \\ n      foo :    baz \"  . getBytes (  )  )  )  ;", "this . exception . expect ( ScannerException . class )  ;", "this . exception . expectMessage (  \" line    3  ,    column    1  \"  )  ;", "this . processor . process ( new    . MatchCallback (  )     {", "@ Override", "public   void   process ( Properties   properties ,    Map < String ,    Object >    map )     {", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testBadResource"], "fileName": "org.springframework.beans.factory.config.YamlProcessorTests"}, {"methodBody": ["METHOD_START", "{", "Properties   result    =    CollectionFactory . createStringAdaptingProperties (  )  ;", "process (  (    properties ,    map )     -  >    result . putAll ( properties )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["createProperties"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBean"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ ncd \\ nspam :  \\ n      foo :    baz \"  . getBytes (  )  )  )  ;", "this . exception . expect ( ScannerException . class )  ;", "this . exception . expectMessage (  \" line    3  ,    column    1  \"  )  ;", "factory . getObject (  )  ;", "}", "METHOD_END"], "methodName": ["testBadResource"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n -     1  \\ n -     2  \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo [  0  ]  \"  )  ,    equalTo (  \"  1  \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo [  1  ]  \"  )  ,    equalTo (  \"  2  \"  )  )  ;", "assertThat ( properties . get (  \" foo \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadArrayOfInteger"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n -    bar :  \\ n            spam :    crap \\ n -    baz \\ n -    one :    two \\ n      three :    four \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo [  0  ]  . bar . spam \"  )  ,    equalTo (  \" crap \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo [  1  ]  \"  )  ,    equalTo (  \" baz \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo [  2  ]  . one \"  )  ,    equalTo (  \" two \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo [  2  ]  . three \"  )  ,    equalTo (  \" four \"  )  )  ;", "assertThat ( properties . get (  \" foo \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadArrayOfObject"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n -    bar \\ n -    baz \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo [  0  ]  \"  )  ,    equalTo (  \" bar \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo [  1  ]  \"  )  ,    equalTo (  \" baz \"  )  )  ;", "assertThat ( properties . get (  \" foo \"  )  ,    is ( nullValue (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadArrayOfString"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResolutionMethod ( YamlProcessor . ResolutionMethod . OVERRIDE _ AND _ IGNORE )  ;", "factory . setResources ( new   ClassPathResource (  \" no - such - file . yml \"  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . size (  )  ,    equalTo (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadNonExistentResource"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :  \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bar \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadNull"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :  \\ n      foo :    baz \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bar \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam . foo \"  )  ,    equalTo (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResource"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setMatchDefault ( true )  ;", "factory . setResources ( new   ByteArrayResource (  \" one :    two \\ n -  -  -  \\ nfoo :    bar \\ nspam :    baz \\ n -  -  -  \\ nfoo :    bag \\ nspam :    bad \"  . getBytes (  )  )  )  ;", "factory . setDocumentMatchers ( new   YamlProcessor . DocumentMatcher (  )     {", "@ Override", "public   YamlProcessor . MatchStatus   matches ( Properties   properties )     {", "if    (  !  ( properties . containsKey (  \" foo \"  )  )  )     {", "return   YamlProcessor . MatchStatus . ABSTAIN ;", "}", "return    \" bag \"  . equals ( properties . getProperty (  \" foo \"  )  )     ?    YamlProcessor . MatchStatus . FOUND    :    YamlProcessor . MatchStatus . NOT _ FOUND ;", "}", "}  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bag \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \" bad \"  )  )  ;", "assertThat ( properties . getProperty (  \" one \"  )  ,    equalTo (  \" two \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourceWithDefaultMatch"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setMatchDefault ( true )  ;", "factory . setResources ( new   ByteArrayResource (  \" one :    two \\ n -  -  -  \\ nfoo :    bag \\ nspam :    bad \\ n -  -  -  \\ nfoo :    bar \\ nspam :    baz \"  . getBytes (  )  )  )  ;", "factory . setDocumentMatchers ( new   YamlProcessor . DocumentMatcher (  )     {", "@ Override", "public   YamlProcessor . MatchStatus   matches ( Properties   properties )     {", "if    (  !  ( properties . containsKey (  \" foo \"  )  )  )     {", "return   YamlProcessor . MatchStatus . ABSTAIN ;", "}", "return    \" bag \"  . equals ( properties . getProperty (  \" foo \"  )  )     ?    YamlProcessor . MatchStatus . FOUND    :    YamlProcessor . MatchStatus . NOT _ FOUND ;", "}", "}  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bag \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \" bad \"  )  )  ;", "assertThat ( properties . getProperty (  \" one \"  )  ,    equalTo (  \" two \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourceWithDefaultMatchSkippingMissedMatch"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :    baz \\ n -  -  -  \\ nfoo :    bag \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bag \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \" baz \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourceWithMultipleDocuments"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :    baz \\ n -  -  -  \\ nfoo :    bag \\ nspam :    bad \"  . getBytes (  )  )  )  ;", "factory . setDocumentMatchers ( new   YamlProcessor . DocumentMatcher (  )     {", "@ Override", "public   YamlProcessor . MatchStatus   matches ( Properties   properties )     {", "return    \" bag \"  . equals ( properties . getProperty (  \" foo \"  )  )     ?    YamlProcessor . MatchStatus . FOUND    :    YamlProcessor . MatchStatus . NOT _ FOUND ;", "}", "}  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bag \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \" bad \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourceWithSelectedDocuments"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setMatchDefault ( false )  ;", "factory . setResources ( new   ByteArrayResource (  \" one :    two \\ n -  -  -  \\ nfoo :    bar \\ nspam :    baz \\ n -  -  -  \\ nfoo :    bag \\ nspam :    bad \"  . getBytes (  )  )  )  ;", "factory . setDocumentMatchers ( new   YamlProcessor . DocumentMatcher (  )     {", "@ Override", "public   YamlProcessor . MatchStatus   matches ( Properties   properties )     {", "if    (  !  ( properties . containsKey (  \" foo \"  )  )  )     {", "return   YamlProcessor . MatchStatus . ABSTAIN ;", "}", "return    \" bag \"  . equals ( properties . getProperty (  \" foo \"  )  )     ?    YamlProcessor . MatchStatus . FOUND    :    YamlProcessor . MatchStatus . NOT _ FOUND ;", "}", "}  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bag \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam \"  )  ,    equalTo (  \" bad \"  )  )  ;", "assertThat ( properties . getProperty (  \" one \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourceWithoutDefaultMatch"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :  \\ n      foo :    baz \\ nfoo :    bucket \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bucket \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourcesWithInternalOverride"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :  \\ n      bar :    spam \\ n      foo :    baz \\ nbreak :    it \\ nfoo :    bucket \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo . bar \"  )  ,    equalTo (  \" spam \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourcesWithNestedInternalOverride"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "YamlPropertiesFactoryBean   factory    =    new   YamlPropertiesFactoryBean (  )  ;", "factory . setResources ( new   ByteArrayResource (  \" foo :    bar \\ nspam :  \\ n      foo :    baz \"  . getBytes (  )  )  ,    new   ByteArrayResource (  \" foo :  \\ n      bar :    spam \"  . getBytes (  )  )  )  ;", "Properties   properties    =    factory . getObject (  )  ;", "assertThat ( properties . getProperty (  \" foo \"  )  ,    equalTo (  \" bar \"  )  )  ;", "assertThat ( properties . getProperty (  \" spam . foo \"  )  ,    equalTo (  \" baz \"  )  )  ;", "assertThat ( properties . getProperty (  \" foo . bar \"  )  ,    equalTo (  \" spam \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadResourcesWithOverride"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "Yaml   yaml    =    new   Yaml (  )  ;", "Map < String ,     ?  >    map    =    yaml . loadAs (  \" foo :    bar \\ nspam :  \\ n      foo :    baz \"  ,    Map . class )  ;", "assertThat ( map . get (  \" foo \"  )  ,    equalTo (  (  ( Object )     (  \" bar \"  )  )  )  )  ;", "assertThat (  (  ( Map < String ,    Object >  )     ( map . get (  \" spam \"  )  )  )  . get (  \" foo \"  )  ,    equalTo (  (  ( Object )     (  \" baz \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testYaml"], "fileName": "org.springframework.beans.factory.config.YamlPropertiesFactoryBeanTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( newValue   instanceof   List )     |  |     ( newValue   instanceof   Map )  )     {", "this . deferredProperties . put (  (  (  ( this . currentBeanDefinition . getBeanName (  )  )     +     '  .  '  )     +    property )  ,    new    . DeferredProperty ( this . currentBeanDefinition ,    property ,    newValue )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["addDeferredProperty"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   GString )     {", "value    =    value . toString (  )  ;", "}", "if    ( addDeferredProperty ( name ,    value )  )     {", "return ;", "} else", "if    ( value   instanceof   groovy . lang . Closure )     {", "Wrapper   current    =    this . currentBeanDefinition ;", "try    {", "groovy . lang . Closure   callable    =     (  ( groovy . lang . Closure )     ( value )  )  ;", "Class <  ?  >    parameterType    =    callable . getParameterTypes (  )  [  0  ]  ;", "if    (  ( Object . class )     =  =    parameterType )     {", "this . currentBeanDefinition    =    new   Wrapper (  \"  \"  )  ;", "callable . call ( this . currentBeanDefinition )  ;", "} else    {", "this . currentBeanDefinition    =    new   Wrapper ( null ,    parameterType )  ;", "callable . call (  (  ( Object )     ( null )  )  )  ;", "}", "value    =    this . currentBeanDefinition . getBeanDefinition (  )  ;", "}    finally    {", "this . currentBeanDefinition    =    current ;", "}", "}", "this . currentBeanDefinition . addProperty ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["applyPropertyToBeanDefinition"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   beanDefinition    =    new   GenericBeanDefinition (  )  ;", "beanDefinition . setBeanClass ( type )  ;", "return   beanDefinition ;", "}", "METHOD_END"], "methodName": ["bean"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "GroovyBeanDefinitionWrapper   current    =    this . currentBeanDefinition ;", "try    {", "Closure   callable    =    null ;", "Collection   constructorArgs    =    null ;", "if    (  !  ( ObjectUtils . isEmpty ( args )  )  )     {", "int   index    =    args . length ;", "Object   lastArg    =    args [  ( index    -     1  )  ]  ;", "if    ( lastArg   instanceof   Closure )     {", "callable    =     (  ( Closure )     ( lastArg )  )  ;", "index -  -  ;", "}", "if    ( index    >     (  -  1  )  )     {", "constructorArgs    =    resolveConstructorArguments ( args ,     0  ,    index )  ;", "}", "}", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( null ,    type ,    constructorArgs )  ;", "if    ( callable    !  =    null )     {", "callable . call ( this . currentBeanDefinition )  ;", "}", "return   this . currentBeanDefinition . getBeanDefinition (  )  ;", "}    finally    {", "this . currentBeanDefinition    =    current ;", "}", "}", "METHOD_END"], "methodName": ["bean"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   invokeBeanDefiningClosure ( closure )  ;", "}", "METHOD_END"], "methodName": ["beans"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "XmlReaderContext   readerContext    =    this . groovyDslXmlBeanDefinitionReader . createReaderContext ( new   DescriptiveResource (  \" Groovy \"  )  )  ;", "BeanDefinitionParserDelegate   delegate    =    new   BeanDefinitionParserDelegate ( readerContext )  ;", "boolean   decorating    =     ( this . currentBeanDefinition )     !  =    null ;", "if    (  ! decorating )     {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( namespace )  ;", "}", "return   new   GroovyDynamicElementReader ( namespace ,    this . namespaces ,    delegate ,    this . currentBeanDefinition ,    decorating )     {", "@ Override", "protected   void   afterInvocation (  )     {", "if    (  !  ( this . decorating )  )     {", "currentBeanDefinition    =    null ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createDynamicElementReader"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "for    ( GroovyBeanDefinitionReader . DeferredProperty   dp    :    this . deferredProperties . values (  )  )     {", "if    (  ( dp . value )    instanceof   List )     {", "dp . value    =    manageListIfNecessary (  (  ( List )     ( dp . value )  )  )  ;", "} else", "if    (  ( dp . value )    instanceof   Map )     {", "dp . value    =    manageMapIfNecessary (  (  ( Map )     ( dp . value )  )  )  ;", "}", "dp . apply (  )  ;", "}", "this . deferredProperties . clear (  )  ;", "}", "METHOD_END"], "methodName": ["finalizeDeferredProperties"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . binding ;", "}", "METHOD_END"], "methodName": ["getBinding"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . metaClass ;", "}", "METHOD_END"], "methodName": ["getMetaClass"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Binding   binding    =    getBinding (  )  ;", "if    (  ( binding    !  =    null )     &  &     ( binding . hasVariable ( name )  )  )     {", "return   binding . getVariable ( name )  ;", "} else    {", "if    ( this . namespaces . containsKey ( name )  )     {", "return   createDynamicElementReader ( name )  ;", "}", "if    ( getRegistry (  )  . containsBeanDefinition ( name )  )     {", "GroovyBeanDefinitionWrapper   beanDefinition    =     (  ( GroovyBeanDefinitionWrapper )     ( getRegistry (  )  . getBeanDefinition ( name )  . getAttribute ( GroovyBeanDefinitionWrapper . class . getName (  )  )  )  )  ;", "if    ( beanDefinition    !  =    null )     {", "return   new    . GroovyRuntimeBeanReference ( name ,    beanDefinition ,    false )  ;", "} else    {", "return   new   RuntimeBeanReference ( name ,    false )  ;", "}", "} else", "if    (  ( this . currentBeanDefinition )     !  =    null )     {", "MutablePropertyValues   pvs    =    this . currentBeanDefinition . getBeanDefinition (  )  . getPropertyValues (  )  ;", "if    ( pvs . contains ( name )  )     {", "return   pvs . get ( name )  ;", "} else    {", ". DeferredProperty   dp    =    this . deferredProperties . get (  (  ( this . currentBeanDefinition . getBeanName (  )  )     +    name )  )  ;", "if    ( dp    !  =    null )     {", "return   dp . value ;", "} else    {", "return   getMetaClass (  )  . getProperty ( this ,    name )  ;", "}", "}", "} else    {", "return   getMetaClass (  )  . getProperty ( this ,    name )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "loadBeanDefinitions ( resourcePattern )  ;", "}", "METHOD_END"], "methodName": ["importBeans"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "callable . setDelegate ( this )  ;", "callable . call (  )  ;", "alizeDeferredProperties (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["invokeBeanDefiningClosure"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "boolean   hasClosureArgument    =     ( args [  (  ( args . length )     -     1  )  ]  )    instanceof   Closure ;", "if    (  ( args [  0  ]  )    instanceof   Class )     {", "Class <  ?  >    beanClass    =     (  ( Class <  ?  >  )     ( args [  0  ]  )  )  ;", "if    ( hasClosureArgument )     {", "if    (  (  ( args . length )     -     1  )     !  =     1  )     {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,    beanClass ,    resolveConstructorArguments ( args ,     1  ,     (  ( args . length )     -     1  )  )  )  ;", "} else    {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,    beanClass )  ;", "}", "} else    {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,    beanClass ,    resolveConstructorArguments ( args ,     1  ,    args . length )  )  ;", "}", "} else", "if    (  ( args [  0  ]  )    instanceof   config . RuntimeBeanReference )     {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName )  ;", "this . currentBeanDefinition . getBeanDefinition (  )  . setFactoryBeanName (  (  ( config . RuntimeBeanReference )     ( args [  0  ]  )  )  . getBeanName (  )  )  ;", "} else", "if    (  ( args [  0  ]  )    instanceof   Map )     {", "if    (  (  ( args . length )     >     1  )     &  &     (  ( args [  1  ]  )    instanceof   Class )  )     {", "List   constructorArgs    =    resolveConstructorArguments ( args ,     2  ,     ( hasClosureArgument    ?     ( args . length )     -     1     :    args . length )  )  ;", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,     (  ( Class )     ( args [  1  ]  )  )  ,    constructorArgs )  ;", "Map   namedArgs    =     (  ( Map )     ( args [  0  ]  )  )  ;", "for    ( Object   o    :    namedArgs . keySet (  )  )     {", "String   propName    =     (  ( String )     ( o )  )  ;", "setProperty ( propName ,    namedArgs . get ( propName )  )  ;", "}", "} else    {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName )  ;", "Entry   factoryBeanEntry    =     (  ( Entry )     (  (  ( Map )     ( args [  0  ]  )  )  . entrySet (  )  . iterator (  )  . next (  )  )  )  ;", "int   constructorArgsTest    =     ( hasClosureArgument )     ?     2     :     1  ;", "if    (  ( args . length )     >    constructorArgsTest )     {", "int   endOfConstructArgs    =     ( hasClosureArgument )     ?     ( args . length )     -     1     :    args . length ;", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,    null ,    resolveConstructorArguments ( args ,     1  ,    endOfConstructArgs )  )  ;", "} else    {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName )  ;", "}", "this . currentBeanDefinition . getBeanDefinition (  )  . setFactoryBeanName ( factoryBeanEntry . getKey (  )  . toString (  )  )  ;", "this . currentBeanDefinition . getBeanDefinition (  )  . setFactoryMethodName ( factoryBeanEntry . getValue (  )  . toString (  )  )  ;", "}", "} else", "if    (  ( args [  0  ]  )    instanceof   Closure )     {", "this . currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName )  ;", "this . currentBeanDefinition . getBeanDefinition (  )  . setAbstract ( true )  ;", "} else    {", "List   constructorArgs    =    resolveConstructorArguments ( args ,     0  ,     ( hasClosureArgument    ?     ( args . length )     -     1     :    args . length )  )  ;", "currentBeanDefinition    =    new   GroovyBeanDefinitionWrapper ( beanName ,    null ,    constructorArgs )  ;", "}", "if    ( hasClosureArgument )     {", "Closure   callable    =     (  ( Closure )     ( args [  (  ( args . length )     -     1  )  ]  )  )  ;", "callable . setDelegate ( this )  ;", "callable . setResolveStrategy ( DELEGATE _ FIRST )  ;", "callable . call ( this . currentBeanDefinition )  ;", "}", "GroovyBeanDefinitionWrapper   beanDefinition    =    this . currentBeanDefinition ;", "this . currentBeanDefinition    =    null ;", "beanDefinition . getBeanDefinition (  )  . setAttribute ( GroovyBeanDefinitionWrapper . class . getName (  )  ,    beanDefinition )  ;", "getRegistry (  )  . registerBeanDefinition ( beanName ,    beanDefinition . getBeanDefinition (  )  )  ;", "return   beanDefinition ;", "}", "METHOD_END"], "methodName": ["invokeBeanDefiningMethod"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =     (  ( Object [  ]  )     ( arg )  )  ;", "if    (  (  (  \" beans \"  . equals ( name )  )     &  &     (  ( args . length )     =  =     1  )  )     &  &     (  ( args [  0  ]  )    instanceof   Closure )  )     {", "return   beans (  (  ( Closure )     ( args [  0  ]  )  )  )  ;", "} else", "if    (  \" ref \"  . equals ( name )  )     {", "String   refName ;", "if    (  ( args [  0  ]  )     =  =    null )", "throw   new   IllegalArgumentException (  \" Argument   to   ref (  )    is   not   a   valid   bean   or   was   not   found \"  )  ;", "if    (  ( args [  0  ]  )    instanceof   config . RuntimeBeanReference )     {", "refName    =     (  ( config . RuntimeBeanReference )     ( args [  0  ]  )  )  . getBeanName (  )  ;", "} else    {", "refName    =    args [  0  ]  . toString (  )  ;", "}", "boolean   parentRef    =    false ;", "if    (  (  ( args . length )     >     1  )     &  &     (  ( args [  1  ]  )    instanceof   Boolean )  )     {", "parentRef    =     (  ( Boolean )     ( args [  1  ]  )  )  ;", "}", "return   new   config . RuntimeBeanReference ( refName ,    parentRef )  ;", "} else", "if    (  (  ( this . namespaces . containsKey ( name )  )     &  &     (  ( args . length )     >     0  )  )     &  &     (  ( args [  0  ]  )    instanceof   Closure )  )     {", "GroovyDynamicElementReader   reader    =    createDynamicElementReader ( name )  ;", "reader . invokeMethod (  \" doCall \"  ,    args )  ;", "} else", "if    (  (  ( args . length )     >     0  )     &  &     (  ( args [  0  ]  )    instanceof   Closure )  )     {", "return   invokeBeanDefiningMethod ( name ,    args )  ;", "} else", "if    (  (  ( args . length )     >     0  )     &  &     (  (  (  ( args [  0  ]  )    instanceof   Class )     |  |     (  ( args [  0  ]  )    instanceof   config . RuntimeBeanReference )  )     |  |     (  ( args [  0  ]  )    instanceof   Map )  )  )     {", "return   invokeBeanDefiningMethod ( name ,    args )  ;", "} else", "if    (  (  ( args . length )     >     1  )     &  &     (  ( args [  (  ( args . length )     -     1  )  ]  )    instanceof   Closure )  )     {", "return   invokeBeanDefiningMethod ( name ,    args )  ;", "}", "MetaClass   mc    =    DefaultGroovyMethods . getMetaClass ( getRegistry (  )  )  ;", "if    (  !  ( mc . respondsTo ( getRegistry (  )  ,    name ,    args )  . isEmpty (  )  )  )     {", "return   mc . invokeMethod ( getRegistry (  )  ,    name ,    args )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   loadBeanDefinitions ( new   EncodedResource ( resource )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "String   filename    =    encodedResource . getResource (  )  . getFilename (  )  ;", "if    ( StringUtils . endsWithIgnoreCase ( filename ,     \"  . xml \"  )  )     {", "return   this . standardXml . loadBeanDefinitions ( encodedResource )  ;", "}", "Closure   beans    =    new   Closure ( this )     {", "@ Override", "public   Object   call ( Object [  ]    args )     {", "invokeBeanDefiningClosure (  (  ( Closure )     ( args [  0  ]  )  )  )  ;", "return   null ;", "}", "}  ;", "Binding   binding    =    new   Binding (  )     {", "@ Override", "public   void   setVariable ( String   name ,    Object   value )     {", "if    (  ( currentBeanDefinition )     !  =    null )     {", "applyPropertyToBeanDefinition ( name ,    value )  ;", "} else    {", "super . setVariable ( name ,    value )  ;", "}", "}", "}  ;", "binding . setVariable (  \" beans \"  ,    beans )  ;", "int   countBefore    =    getRegistry (  )  . getBeanDefinitionCount (  )  ;", "try    {", "GroovyShell   shell    =    new   GroovyShell ( getBeanClassLoader (  )  ,    binding )  ;", "shell . evaluate ( encodedResource . getReader (  )  ,     \" beans \"  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionParsingException ( new   Problem (  (  \" Error   evaluating   Groovy   script :     \"     +     ( ex . getMessage (  )  )  )  ,    new   Location ( encodedResource . getResource (  )  )  ,    null ,    ex )  )  ;", "}", "return    ( getRegistry (  )  . getBeanDefinitionCount (  )  )     -    countBefore ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "boolean   containsRuntimeRefs    =    false ;", "for    ( Object   element    :    list )     {", "if    ( element   instanceof   RuntimeReference )     {", "containsRuntimeRefs    =    true ;", "break ;", "}", "}", "if    ( containsRuntimeRefs )     {", "List < Object >    managedList    =    new   ManagedList <  >  (  )  ;", "managedList . addAll ( list )  ;", "return   managedList ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["manageListIfNecessary"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "boolean   containsRuntimeRefs    =    false ;", "for    ( Object   element    :    map . values (  )  )     {", "if    ( element   instanceof   RuntimeReference )     {", "containsRuntimeRefs    =    true ;", "break ;", "}", "}", "if    ( containsRuntimeRefs )     {", "Map < Object ,    Object >    managedMap    =    new   ManagedMap <  >  (  )  ;", "managedMap . putAll ( map )  ;", "return   managedMap ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["manageMapIfNecessary"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    constructorArgs    =    Arrays . copyOfRange ( args ,    start ,    end )  ;", "for    ( int   i    =     0  ;    i    <     ( constructorArgs . length )  ;    i +  +  )     {", "if    (  ( constructorArgs [ i ]  )    instanceof   GString )     {", "constructorArgs [ i ]     =    constructorArgs [ i ]  . toString (  )  ;", "} else", "if    (  ( constructorArgs [ i ]  )    instanceof   List )     {", "constructorArgs [ i ]     =    manageListIfNecessary (  (  ( List )     ( constructorArgs [ i ]  )  )  )  ;", "} else", "if    (  ( constructorArgs [ i ]  )    instanceof   Map )     {", "constructorArgs [ i ]     =    manageMapIfNecessary (  (  ( Map )     ( constructorArgs [ i ]  )  )  )  ;", "}", "}", "return   Arrays . asList ( constructorArgs )  ;", "}", "METHOD_END"], "methodName": ["resolveConstructorArguments"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . binding    =    binding ;", "}", "METHOD_END"], "methodName": ["setBinding"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . metaClass    =    metaClass ;", "}", "METHOD_END"], "methodName": ["setMetaClass"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . currentBeanDefinition )     !  =    null )     {", "applyPropertyToBeanDefinition ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( definition . isEmpty (  )  )  )     {", "for    ( Map . Entry < String ,    String >    entry    :    definition . entrySet (  )  )     {", "String   namespace    =    entry . getKey (  )  ;", "String   uri    =    entry . getValue (  )  ;", "if    ( uri    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Namespace   definition   must   supply   a   non - null   URI \"  )  ;", "}", "NamespaceHandler   namespaceHandler    =    this . groovyDslXml . getNamespaceHandlerResolver (  )  . resolve ( uri )  ;", "if    ( namespaceHandler    =  =    null )     {", "throw   new   BeanDefinitionParsingException ( new   Problem (  (  \" No   namespace   handler   found   for   URI :     \"     +    uri )  ,    new   Location ( new   DescriptiveResource (  \" Groovy \"  )  )  )  )  ;", "}", "this . namespaces . put ( namespace ,    uri )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["xmlns"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    ( propertyValue   instanceof   GroovyBeanDefinitionWrapper )     {", "propertyValue    =     (  ( GroovyBeanDefinitionWrapper )     ( propertyValue )  )  . getBeanDefinition (  )  ;", "}", "getBeanDefinition (  )  . getPropertyValues (  )  . add ( propertyName ,    propertyValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addProperty"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "AbstractBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setBeanClass ( this . clazz )  ;", "if    (  !  ( CollectionUtils . isEmpty ( this . constructorArgs )  )  )     {", "ConstructorArgumentValues   cav    =    new   ConstructorArgumentValues (  )  ;", "for    ( Object   constructorArg    :    this . constructorArgs )     {", "cav . addGenericArgumentValue ( constructorArg )  ;", "}", "bd . setConstructorArgumentValues ( cav )  ;", "}", "if    (  ( this . parentName )     !  =    null )     {", "bd . setParentName ( this . parentName )  ;", "}", "this . d    =    new   BeanWrapperImpl ( bd )  ;", "return   bd ;", "}", "METHOD_END"], "methodName": ["createBeanDefinition"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . definition )     =  =    null )     {", "this . definition    =    create (  )  ;", "}", "return   this . definition ;", "}", "METHOD_END"], "methodName": ["getBeanDefinition"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanDefinitionHolder ( getBeanDefinition (  )  ,    getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanDefinitionHolder"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "this . definition    =    definition ;", "}", "METHOD_END"], "methodName": ["setBeanDefinition"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "this . definition    =     (  ( AbstractBeanDefinition )     ( holder . getBeanDefinition (  )  )  )  ;", "this . beanName    =    holder . getBeanName (  )  ;", "}", "METHOD_END"], "methodName": ["setBeanDefinitionHolder"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Parent   bean   cannot   be   set   to   a   null   runtime   bean   reference !  \"  )  ;", "}", "if    ( obj   instanceof   String )     {", "this . parentName    =     (  ( String )     ( obj )  )  ;", "} else", "if    ( obj   instanceof   config . RuntimeBeanReference )     {", "this . parentName    =     (  ( config . RuntimeBeanReference )     ( obj )  )  . getBeanName (  )  ;", "} else", "if    ( obj   instanceof   GroovyBeanDefinitionWrapper )     {", "this . parentName    =     (  ( GroovyBeanDefinitionWrapper )     ( obj )  )  . getBeanName (  )  ;", "}", "getBeanDefinition (  )  . setParentName ( this . parentName )  ;", "getBeanDefinition (  )  . setAbstract ( false )  ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "org.springframework.beans.factory.groovy.GroovyBeanDefinitionWrapper"}, {"methodBody": ["METHOD_START", "{", "return   this . alias ;", "}", "METHOD_END"], "methodName": ["getAlias"], "fileName": "org.springframework.beans.factory.parsing.AliasDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.parsing.AliasDefinition"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( component ,     \" ComponentDefinition   must   not   be   null \"  )  ;", "this . nestedComponents . add ( component )  ;", "}", "METHOD_END"], "methodName": ["addNestedComponent"], "fileName": "org.springframework.beans.factory.parsing.CompositeComponentDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . nestedComponents . toArray ( new   ComponentDefinition [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getNestedComponents"], "fileName": "org.springframework.beans.factory.parsing.CompositeComponentDefinition"}, {"methodBody": ["METHOD_START", "{", "new   ConstructorArgumentEntry (  (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testCtorBailsOnNegativeCtorIndexArgument"], "fileName": "org.springframework.beans.factory.parsing.ConstructorArgumentEntryTests"}, {"methodBody": ["METHOD_START", "{", "this . problemReporter    =    new   CustomProblemReporterTests . CollatingProblemReporter (  )  ;", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "this . reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "this . reader . setProblemReporter ( this . problemReporter )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.parsing.CustomProblemReporterTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( CustomProblemReporterTests . CONTEXT )  ;", "assertEquals (  \" Incorrect   number   of   errors   collated \"  ,     4  ,    this . problemReporter . getErrors (  )  . length )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" validBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["testErrorsAreCollated"], "fileName": "org.springframework.beans.factory.parsing.CustomProblemReporterTests"}, {"methodBody": ["METHOD_START", "{", "this . logger    =     ( logger    !  =    null )     ?    logger    :    LogFactory . getLog ( getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["setLogger"], "fileName": "org.springframework.beans.factory.parsing.FailFastProblemReporter"}, {"methodBody": ["METHOD_START", "{", "FailFastProblemReporter   reporter    =    new   FailFastProblemReporter (  )  ;", "reporter . error ( new   Problem (  \" VGER \"  ,    new   Location ( new   DescriptiveResource (  \" here \"  )  )  ,    null ,    new   IllegalArgumentException (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testError"], "fileName": "org.springframework.beans.factory.parsing.FailFastProblemReporterTests"}, {"methodBody": ["METHOD_START", "{", "Problem   problem    =    new   Problem (  \" VGER \"  ,    new   Location ( new   DescriptiveResource (  \" here \"  )  )  ,    null ,    new   IllegalArgumentException (  )  )  ;", "Log   log    =    mock ( Log . class )  ;", "reporter    =    new    (  )  ;", "reporter . setLogger ( log )  ;", "reporter . warning ( problem )  ;", "verify ( log )  . warn ( any (  )  ,    isA ( IllegalArgumentException . class )  )  ;", "}", "METHOD_END"], "methodName": ["testWarn"], "fileName": "org.springframework.beans.factory.parsing.FailFastProblemReporterTests"}, {"methodBody": ["METHOD_START", "{", "return   this . actualResources ;", "}", "METHOD_END"], "methodName": ["getActualResources"], "fileName": "org.springframework.beans.factory.parsing.ImportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . importedResource ;", "}", "METHOD_END"], "methodName": ["getImportedResource"], "fileName": "org.springframework.beans.factory.parsing.ImportDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.beans.factory.parsing.Location"}, {"methodBody": ["METHOD_START", "{", "return   this . source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.beans.factory.parsing.Location"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    new   Object (  )  ;", "Object   extractedSource    =    new    (  )  . extractSource ( source ,    null )  ;", "assertNull (  \" The   contract   of      states   that   the   extraction    * always *    return   null \"  ,    extractedSource )  ;", "}", "METHOD_END"], "methodName": ["testPassThroughContract"], "fileName": "org.springframework.beans.factory.parsing.NullSourceExtractorTests"}, {"methodBody": ["METHOD_START", "{", "Object   extractedSource    =    new   NullSourceExtractor (  )  . extractSource ( null ,    null )  ;", "assertNull (  \" The   contract   of   NullSourceExtractor   states   that   the   extraction    * always *    return   null \"  ,    extractedSource )  ;", "}", "METHOD_END"], "methodName": ["testPassThroughContractEvenWithNull"], "fileName": "org.springframework.beans.factory.parsing.NullSourceExtractorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . state . isEmpty (  )     ?    null    :    this . state . peek (  )  ;", "}", "METHOD_END"], "methodName": ["peek"], "fileName": "org.springframework.beans.factory.parsing.ParseState"}, {"methodBody": ["METHOD_START", "{", "this . state . pop (  )  ;", "}", "METHOD_END"], "methodName": ["pop"], "fileName": "org.springframework.beans.factory.parsing.ParseState"}, {"methodBody": ["METHOD_START", "{", "this . state . push ( entry )  ;", "}", "METHOD_END"], "methodName": ["push"], "fileName": "org.springframework.beans.factory.parsing.ParseState"}, {"methodBody": ["METHOD_START", "{", "return   new   ParseState ( this )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.springframework.beans.factory.parsing.ParseState"}, {"methodBody": ["METHOD_START", "{", "ParseStateTests . MockEntry   one    =    new   ParseStateTests . MockEntry (  )  ;", "ParseStateTests . MockEntry   two    =    new   ParseStateTests . MockEntry (  )  ;", "ParseStateTests . MockEntry   three    =    new   ParseStateTests . MockEntry (  )  ;", "ParseState   parseState    =    new   ParseState (  )  ;", "parseState . push ( one )  ;", "assertEquals ( one ,    parseState . peek (  )  )  ;", "parseState . push ( two )  ;", "assertEquals ( two ,    parseState . peek (  )  )  ;", "parseState . push ( three )  ;", "assertEquals ( three ,    parseState . peek (  )  )  ;", "parseState . pop (  )  ;", "assertEquals ( two ,    parseState . peek (  )  )  ;", "parseState . pop (  )  ;", "assertEquals ( one ,    parseState . peek (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNesting"], "fileName": "org.springframework.beans.factory.parsing.ParseStateTests"}, {"methodBody": ["METHOD_START", "{", "ParseStateTests . MockEntry   entry    =    new   ParseStateTests . MockEntry (  )  ;", "ParseState   parseState    =    new   ParseState (  )  ;", "parseState . push ( entry )  ;", "assertEquals (  \" Incorrect   peek   value .  \"  ,    entry ,    parseState . peek (  )  )  ;", "parseState . pop (  )  ;", "assertNull (  \" Should   get   null   on   peek (  )  \"  ,    parseState . peek (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.springframework.beans.factory.parsing.ParseStateTests"}, {"methodBody": ["METHOD_START", "{", "ParseStateTests . MockEntry   entry    =    new   ParseStateTests . MockEntry (  )  ;", "ParseState   original    =    new   ParseState (  )  ;", "original . push ( entry )  ;", "ParseState   snapshot    =    original . snapshot (  )  ;", "original . push ( new   ParseStateTests . MockEntry (  )  )  ;", "assertEquals (  \" Snapshot   should   not   have   been   modified .  \"  ,    entry ,    snapshot . peek (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSnapshot"], "fileName": "org.springframework.beans.factory.parsing.ParseStateTests"}, {"methodBody": ["METHOD_START", "{", "Object   source    =    new   Object (  )  ;", "Object   extractedSource    =    new    (  )  . extractSource ( source ,    null )  ;", "assertSame (  (  \" The   contract   of      states   that   the   supplied    \"     +     \" source   object    * must *    be   returned   as - is \"  )  ,    source ,    extractedSource )  ;", "}", "METHOD_END"], "methodName": ["testPassThroughContract"], "fileName": "org.springframework.beans.factory.parsing.PassThroughSourceExtractorTests"}, {"methodBody": ["METHOD_START", "{", "Object   extractedSource    =    new   PassThroughSourceExtractor (  )  . extractSource ( null ,    null )  ;", "assertNull (  (  \" The   contract   of   PassThroughSourceExtractor   states   that   the   supplied    \"     +     \" source   object    * must *    be   returned   as - is    ( even   if   null )  \"  )  ,    extractedSource )  ;", "}", "METHOD_END"], "methodName": ["testPassThroughContractEvenWithNull"], "fileName": "org.springframework.beans.factory.parsing.PassThroughSourceExtractorTests"}, {"methodBody": ["METHOD_START", "{", "return   this . location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.springframework.beans.factory.parsing.Problem"}, {"methodBody": ["METHOD_START", "{", "return   this . message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.springframework.beans.factory.parsing.Problem"}, {"methodBody": ["METHOD_START", "{", "return   this . parseState ;", "}", "METHOD_END"], "methodName": ["getParseState"], "fileName": "org.springframework.beans.factory.parsing.Problem"}, {"methodBody": ["METHOD_START", "{", "return   getLocation (  )  . getResource (  )  . getDescription (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceDescription"], "fileName": "org.springframework.beans.factory.parsing.Problem"}, {"methodBody": ["METHOD_START", "{", "return   this . rootCause ;", "}", "METHOD_END"], "methodName": ["getRootCause"], "fileName": "org.springframework.beans.factory.parsing.Problem"}, {"methodBody": ["METHOD_START", "{", "new   PropertyEntry (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCtorBailsOnEmptyPropertyNameArgument"], "fileName": "org.springframework.beans.factory.parsing.PropertyEntryTests"}, {"methodBody": ["METHOD_START", "{", "new   PropertyEntry ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorBailsOnNullPropertyNameArgument"], "fileName": "org.springframework.beans.factory.parsing.PropertyEntryTests"}, {"methodBody": ["METHOD_START", "{", "new   PropertyEntry (  \"  \\ t          \"  )  ;", "}", "METHOD_END"], "methodName": ["testCtorBailsOnWhitespacedPropertyNameArgument"], "fileName": "org.springframework.beans.factory.parsing.PropertyEntryTests"}, {"methodBody": ["METHOD_START", "{", "error ( message ,    source ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "error ( message ,    source ,    null ,    cause )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "error ( message ,    source ,    parseState ,    null )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "Location   location    =    new   Location ( getResource (  )  ,    source )  ;", "this . problemReporter . error ( new   Problem ( message ,    location ,    eState ,    cause )  )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceExtractor . extractSource ( sourceCandidate ,    this . resource )  ;", "}", "METHOD_END"], "methodName": ["extractSource"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "fatal ( message ,    source ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["fatal"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "fatal ( message ,    source ,    null ,    cause )  ;", "}", "METHOD_END"], "methodName": ["fatal"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "fatal ( message ,    source ,    parseState ,    null )  ;", "}", "METHOD_END"], "methodName": ["fatal"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "Location   location    =    new   Location ( getResource (  )  ,    source )  ;", "this . problemReporter . fatal ( new   Problem ( message ,    location ,    eState ,    cause )  )  ;", "}", "METHOD_END"], "methodName": ["fatal"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "this . eventListener . aliasRegistered ( new   AliasDefinition ( beanName ,    alias ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["fireAliasRegistered"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "this . eventListener . componentRegistered ( componentDefinition )  ;", "}", "METHOD_END"], "methodName": ["fireComponentRegistered"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "this . eventListener . defaultsRegistered ( defaultsDefinition )  ;", "}", "METHOD_END"], "methodName": ["fireDefaultsRegistered"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "this . eventListener . importProcessed ( new   ImportDefinition ( importedResource ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["fireImportProcessed"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "this . eventListener . importProcessed ( new   ImportDefinition ( importedResource ,    actualResources ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["fireImportProcessed"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . sourceExtractor ;", "}", "METHOD_END"], "methodName": ["getSourceExtractor"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "warning ( message ,    source ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["warning"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "warning ( message ,    source ,    null ,    cause )  ;", "}", "METHOD_END"], "methodName": ["warning"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "warning ( message ,    source ,    parseState ,    null )  ;", "}", "METHOD_END"], "methodName": ["warning"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "Location   location    =    new   Location ( getResource (  )  ,    source )  ;", "this . problemReporter . warning ( new   Problem ( message ,    location ,    eState ,    cause )  )  ;", "}", "METHOD_END"], "methodName": ["warning"], "fileName": "org.springframework.beans.factory.parsing.ReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . serviceType ;", "}", "METHOD_END"], "methodName": ["getServiceType"], "fileName": "org.springframework.beans.factory.serviceloader.AbstractServiceLoaderBasedFactoryBean"}, {"methodBody": ["METHOD_START", "{", "this . serviceType    =    serviceType ;", "}", "METHOD_END"], "methodName": ["setServiceType"], "fileName": "org.springframework.beans.factory.serviceloader.AbstractServiceLoaderBasedFactoryBean"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( ServiceLoader . load ( DocumentBuilderFactory . class )  . iterator (  )  . hasNext (  )  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( ServiceFactoryBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" serviceType \"  ,    DocumentBuilderFactory . class . getName (  )  )  ;", "bf . registerBeanDefinition (  \" service \"  ,    bd )  ;", "assertTrue (  (  ( bf . getBean (  \" service \"  )  )    instanceof   DocumentBuilderFactory )  )  ;", "}", "METHOD_END"], "methodName": ["testServiceFactoryBean"], "fileName": "org.springframework.beans.factory.serviceloader.ServiceLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( ServiceLoader . load ( DocumentBuilderFactory . class )  . iterator (  )  . hasNext (  )  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( ServiceListFactoryBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" serviceType \"  ,    DocumentBuilderFactory . class . getName (  )  )  ;", "bf . registerBeanDefinition (  \" service \"  ,    bd )  ;", "List <  ?  >    serviceList    =     (  ( List <  ?  >  )     ( bf . getBean (  \" service \"  )  )  )  ;", "assertTrue (  (  ( serviceList . get (  0  )  )    instanceof   DocumentBuilderFactory )  )  ;", "}", "METHOD_END"], "methodName": ["testServiceListFactoryBean"], "fileName": "org.springframework.beans.factory.serviceloader.ServiceLoaderTests"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( ServiceLoader . load ( DocumentBuilderFactory . class )  . iterator (  )  . hasNext (  )  )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( ServiceLoaderFactoryBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" serviceType \"  ,    DocumentBuilderFactory . class . getName (  )  )  ;", "bf . registerBeanDefinition (  \" service \"  ,    bd )  ;", "ServiceLoader <  ?  >    serviceLoader    =     (  ( ServiceLoader <  ?  >  )     ( bf . getBean (  \" service \"  )  )  )  ;", "assertTrue (  (  ( serviceLoader . iterator (  )  . next (  )  )    instanceof   DocumentBuilderFactory )  )  ;", "}", "METHOD_END"], "methodName": ["testServiceLoaderFactoryBean"], "fileName": "org.springframework.beans.factory.serviceloader.ServiceLoaderTests"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   InstantiationAwarPostProcessor )     {", "InstantiationAwarPostProcessor   ibp    =     (  ( InstantiationAwarPostProcessor )     ( bp )  )  ;", "Object   result    =    ibp . postProcessBeforeInstantiation ( beanClass ,    beanName )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["applyBeanPostProcessorsBeforeInstantiation"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   MergedBeanDefinitionPostProcessor )     {", "MergedBeanDefinitionPostProcessor   bdp    =     (  ( MergedBeanDefinitionPostProcessor )     ( bp )  )  ;", "bdp . postProcessMergedBeanDefinition ( mbd ,    beanType ,    beanName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyMergedBeanDefinitionPostProcessors"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( pvs . isEmpty (  )  )     {", "return ;", "}", "if    (  (  ( System . getSecurityManager (  )  )     !  =    null )     &  &     ( bw   instanceof   BeanWrapperImpl )  )     {", "(  ( BeanWrapperImpl )     ( bw )  )  . setSecurityContext ( getAccessControlContext (  )  )  ;", "}", "MutablePropertyValues   mpvs    =    null ;", "List < PropertyValue >    original ;", "if    ( pvs   instanceof   MutablePropertyValues )     {", "mpvs    =     (  ( MutablePropertyValues )     ( pvs )  )  ;", "if    ( mpvs . isConverted (  )  )     {", "try    {", "bw . setPropertyValues ( mpvs )  ;", "return ;", "}    catch    ( BeansException   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Error   setting   property   values \"  ,    ex )  ;", "}", "}", "original    =    mpvs . getPropertyValueList (  )  ;", "} else    {", "original    =    Arrays . asList ( pvs . getPropertyValues (  )  )  ;", "}", "TypeConverter   converter    =    getCustomTypeConverter (  )  ;", "if    ( converter    =  =    null )     {", "converter    =    bw ;", "}", "BeanDefinitionValueResolver   valueResolver    =    new   BeanDefinitionValueResolver ( this ,    beanName ,    mbd ,    converter )  ;", "List < PropertyValue >    deepCopy    =    new   ArrayList <  >  ( original . size (  )  )  ;", "boolean   resolveNecessary    =    false ;", "for    ( PropertyValue   pv    :    original )     {", "if    ( pv . isConverted (  )  )     {", "deepCopy . add ( pv )  ;", "} else    {", "String   propertyName    =    pv . getName (  )  ;", "Object   originalValue    =    pv . getValue (  )  ;", "Object   resolvedValue    =    valueResolver . resolveValueIfNecessary ( pv ,    originalValue )  ;", "Object   convertedValue    =    resolvedValue ;", "boolean   convertible    =     ( bw . isWritableProperty ( propertyName )  )     &  &     (  !  ( PropertyAccessorUtils . isNestedOrIndexedProperty ( propertyName )  )  )  ;", "if    ( convertible )     {", "convertedValue    =    convertForProperty ( resolvedValue ,    propertyName ,    bw ,    converter )  ;", "}", "if    ( resolvedValue    =  =    originalValue )     {", "if    ( convertible )     {", "pv . setConvertedValue ( convertedValue )  ;", "}", "deepCopy . add ( pv )  ;", "} else", "if    (  (  ( convertible    &  &     ( originalValue   instanceof   config . TypedStringValue )  )     &  &     (  !  (  (  ( config . TypedStringValue )     ( originalValue )  )  . isDynamic (  )  )  )  )     &  &     (  !  (  ( convertedValue   instanceof   Collection )     |  |     ( isArray ( convertedValue )  )  )  )  )     {", "pv . setConvertedValue ( convertedValue )  ;", "deepCopy . add ( pv )  ;", "} else    {", "resolveNecessary    =    true ;", "deepCopy . add ( new   PropertyValue ( pv ,    convertedValue )  )  ;", "}", "}", "}", "if    (  ( mpvs    !  =    null )     &  &     (  ! resolveNecessary )  )     {", "mpvs . setConverted (  )  ;", "}", "try    {", "bw . setPropertyValues ( new   MutablePropertyValues ( deepCopy )  )  ;", "}    catch    ( BeansException   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Error   setting   property   values \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["applyPropertyValues"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String [  ]    propertyNames    =    unsatisfiedNonSimpleProperties ( mbd ,    bw )  ;", "for    ( String   propertyName    :    propertyNames )     {", "if    ( containsBean ( propertyName )  )     {", "Object   bean    =    getBean ( propertyName )  ;", "pvs . add ( propertyName ,    bean )  ;", "registerDependentBean ( propertyName ,    beanName )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  \" Added   aing   by   name   from   bean   name    '  \"     +    beanName )     +     \"  '    via   property    '  \"  )     +    propertyName )     +     \"  '    to   bean   named    '  \"  )     +    propertyName )     +     \"  '  \"  )  )  ;", "}", "} else    {", "if    ( logger . isTraceEnabled (  )  )     {", "logger . trace (  (  (  (  (  \" Not   aing   property    '  \"     +    propertyName )     +     \"  '    of   bean    '  \"  )     +    beanName )     +     \"  '    by   name :    no   matching   bean   found \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["autowireByName"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   converter    =    getCustomTypeConverter (  )  ;", "if    ( converter    =  =    null )     {", "converter    =    bw ;", "}", "Set < String >    autowiredBeanNames    =    new   LinkedHashSet <  >  (  4  )  ;", "String [  ]    propertyNames    =    unsatisfiedNonSimpleProperties ( mbd ,    bw )  ;", "for    ( String   propertyName    :    propertyNames )     {", "try    {", "PropertyDescriptor   pd    =    bw . getPropertyDescriptor ( propertyName )  ;", "if    (  ( Object . class )     !  =     ( pd . getPropertyType (  )  )  )     {", "MethodParameter   methodParam    =    BeanUtils . getWriteMethodParameter ( pd )  ;", "boolean   eager    =     !  ( PriorityOrdered . class . isInstance ( bw . getWrappedInstance (  )  )  )  ;", "DependencyDescriptor   desc    =    new    . AutowireByTypeDependencyDescriptor ( methodParam ,    eager )  ;", "Object   autowiredArgument    =    resolveDependency ( desc ,    beanName ,    autowiredBeanNames ,    converter )  ;", "if    ( autowiredArgument    !  =    null )     {", "pvs . add ( propertyName ,    autowiredArgument )  ;", "}", "for    ( String   autowiredBeanName    :    autowiredBeanNames )     {", "registerDependentBean ( autowiredBeanName ,    beanName )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  \" Autowiring   by   type   from   bean   name    '  \"     +    beanName )     +     \"  '    via   property    '  \"  )     +    propertyName )     +     \"  '    to   bean   named    '  \"  )     +    autowiredBeanName )     +     \"  '  \"  )  )  ;", "}", "}", "autowiredBeanNames . clear (  )  ;", "}", "}    catch    ( BeansException   ex )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    propertyName ,    ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["autowireByType"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ConstructorResolver ( this )  . autowireConstructor ( beanName ,    mbd ,    ctors ,    explicitArgs )  ;", "}", "METHOD_END"], "methodName": ["autowireConstructor"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "int   dependencyCheck    =    mbd . getDependencyCheck (  )  ;", "for    ( PropertyDescriptor   pd    :    pds )     {", "if    (  (  ( pd . getWriteMethod (  )  )     !  =    null )     &  &     (  !  ( pvs . contains ( pd . getName (  )  )  )  )  )     {", "boolean   isSimple    =    Utils . isSimpleProperty ( pd . getPropertyType (  )  )  ;", "boolean   unsatisfied    =     (  ( dependencyCheck    =  =     ( RootDefinition . DEPENDENCY _ CHECK _ ALL )  )     |  |     ( isSimple    &  &     ( dependencyCheck    =  =     ( RootDefinition . DEPENDENCY _ CHECK _ SIMPLE )  )  )  )     |  |     (  (  ! isSimple )     &  &     ( dependencyCheck    =  =     ( RootDefinition . DEPENDENCY _ CHECK _ OBJECTS )  )  )  ;", "if    ( unsatisfied )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    pd . getName (  )  ,     \" Set   this   property   value   or   disable   dependency   checking   for   this   bean .  \"  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkDependencies"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( converter   instanceof   BeanWrapperImpl )     {", "return    (  ( BeanWrapperImpl )     ( converter )  )  . convertForProperty ( value ,    propertyName )  ;", "} else    {", "PropertyDescriptor   pd    =    bw . getPropertyDescriptor ( propertyName )  ;", "MethodParameter   methodParam    =    BeanUtils . getWriteMethodParameter ( pd )  ;", "return   converter . convertIfNecessary ( value ,    pd . getPropertyType (  )  ,    methodParam )  ;", "}", "}", "METHOD_END"], "methodName": ["convertForProperty"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanClass    =    resolveBeanClass ( mbd ,    beanName )  ;", "if    (  (  ( beanClass    !  =    null )     &  &     (  !  ( Modifier . isPublic ( beanClass . getModifiers (  )  )  )  )  )     &  &     (  !  ( mbd . isNonPublicAccessAllowed (  )  )  )  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  \" Bean   class   isn ' t   public ,    and   non - public   access   not   allowed :     \"     +     ( beanClass . getName (  )  )  )  )  ;", "}", "Supplier <  ?  >    instanceSupplier    =    mbd . getInstanceSupplier (  )  ;", "if    ( instanceSupplier    !  =    null )     {", "return   obtainFromSupplier ( instanceSupplier ,    beanName )  ;", "}", "if    (  ( mbd . getFactoryMethodName (  )  )     !  =    null )     {", "return   instantiateUsingFactoryMethod ( beanName ,    mbd ,    args )  ;", "}", "boolean   resolved    =    false ;", "boolean   autowireNecessary    =    false ;", "if    ( args    =  =    null )     {", "synchronized ( mbd . constructorArgumentLock )     {", "if    (  ( mbd . resolvedConstructorOrFactoryMethod )     !  =    null )     {", "resolved    =    true ;", "autowireNecessary    =    mbd . constructorArgumentsResolved ;", "}", "}", "}", "if    ( resolved )     {", "if    ( autowireNecessary )     {", "return   aonstructor ( beanName ,    mbd ,    null ,    null )  ;", "} else    {", "return   instantiateBean ( beanName ,    mbd )  ;", "}", "}", "Constructor <  ?  >  [  ]    ctors    =    determineConstructorsFromBeanPostProcessors ( beanClass ,    beanName )  ;", "if    (  (  (  ( ctors    !  =    null )     |  |     (  ( mbd . getResolvedAutowireMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  )  )     |  |     ( mbd . hasConstructorArgumentValues (  )  )  )     |  |     (  !  ( ObjectUtils . isEmpty ( args )  )  )  )     {", "return   aonstructor ( beanName ,    mbd ,    ctors ,    args )  ;", "}", "return   instantiateBean ( beanName ,    mbd )  ;", "}", "METHOD_END"], "methodName": ["createBeanInstance"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beanClass    !  =    null )     &  &     ( hasInstantiationAwareBeanPostProcessors (  )  )  )     {", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   SmartInstantiationAwareBeanPostProcessor )     {", "SmartInstantiationAwareBeanPostProcessor   ibp    =     (  ( SmartInstantiationAwareBeanPostProcessor )     ( bp )  )  ;", "Constructor <  ?  >  [  ]    ctors    =    ibp . determineCandidateConstructors ( beanClass ,    beanName )  ;", "if    ( ctors    !  =    null )     {", "return   ctors ;", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineConstructorsFromBeanPostProcessors"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetType    =    mbd . getTargetType (  )  ;", "if    ( targetType    =  =    null )     {", "targetType    =     (  ( mbd . getMethodName (  )  )     !  =    null )     ?    getTypeForMethod ( beanName ,    mbd ,    typesToMatch )     :    resolveBeanClass ( mbd ,    beanName ,    typesToMatch )  ;", "if    (  ( ObjectUtils . isEmpty ( typesToMatch )  )     |  |     (  ( getTempClassLoader (  )  )     =  =    null )  )     {", "mbd . resolvedTargetType    =    targetType ;", "}", "}", "return   targetType ;", "}", "METHOD_END"], "methodName": ["determineTargetType"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "BeanWrapper   instanceWrapper    =    null ;", "if    ( mbd . isSingleton (  )  )     {", "instanceWrapper    =    this . factoryBeanInstanceCache . remove ( beanName )  ;", "}", "if    ( instanceWrapper    =  =    null )     {", "instanceWrapper    =    createBeanInstance ( beanName ,    mbd ,    args )  ;", "}", "final   Object   bean    =    instanceWrapper . getWrappedInstance (  )  ;", "Class <  ?  >    beanType    =    instanceWrapper . getWrappedClass (  )  ;", "if    ( beanType    !  =     ( NullBean . class )  )     {", "mbd . resolvedTargetType    =    beanType ;", "}", "synchronized ( mbd . postProcessingLock )     {", "if    (  !  ( mbd . postProcessed )  )     {", "try    {", "applyMergedBeanDefinitionPostProcessors ( mbd ,    beanType ,    beanName )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Post - processing   of   merged   bean   definition   failed \"  ,    ex )  ;", "}", "mbd . postProcessed    =    true ;", "}", "}", "boolean   earlySingletonExposure    =     (  ( mbd . isSingleton (  )  )     &  &     ( this . allowCircularReferences )  )     &  &     ( isSingletonCurrentlyInCreation ( beanName )  )  ;", "if    ( earlySingletonExposure )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Eagerly   caching   bean    '  \"     +    beanName )     +     \"  '    to   allow   for   resolving   potential   circular   references \"  )  )  ;", "}", "addSingletonFactory ( beanName ,     (  )     -  >    getEarlyBeanReference ( beanName ,    mbd ,    bean )  )  ;", "}", "Object   exposedObject    =    bean ;", "try    {", "populateBean ( beanName ,    mbd ,    instanceWrapper )  ;", "exposedObject    =    initializeBean ( beanName ,    exposedObject ,    mbd )  ;", "}    catch    ( Throwable   ex )     {", "if    (  ( ex   instanceof   BeanCreationException )     &  &     ( beanName . equals (  (  ( BeanCreationException )     ( ex )  )  . getBeanName (  )  )  )  )     {", "throw    (  ( BeanCreationException )     ( ex )  )  ;", "} else    {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Initialization   of   bean   failed \"  ,    ex )  ;", "}", "}", "if    ( earlySingletonExposure )     {", "Object   earlySingletonReference    =    getSingleton ( beanName ,    false )  ;", "if    ( earlySingletonReference    !  =    null )     {", "if    ( exposedObject    =  =    bean )     {", "exposedObject    =    earlySingletonReference ;", "} else", "if    (  (  !  ( this . allowRawInjectionDespiteWrapping )  )     &  &     ( hasDependentBean ( beanName )  )  )     {", "String [  ]    dependentBeans    =    getDependentBeans ( beanName )  ;", "Set < String >    actualDependentBeans    =    new   LinkedHashSet <  >  ( dependentBeans . length )  ;", "for    ( String   dependentBean    :    dependentBeans )     {", "if    (  !  ( removeSingletonIfCreatedForTypeCheckOnly ( dependentBean )  )  )     {", "actualDependentBeans . add ( dependentBean )  ;", "}", "}", "if    (  !  ( actualDependentBeans . isEmpty (  )  )  )     {", "throw   new   BeanCurrentlyInCreationException ( beanName ,     (  (  (  (  (  (  (  \" Bean   with   name    '  \"     +    beanName )     +     \"  '    has   been   injected   into   other   beans    [  \"  )     +     ( collectionToCommaDelimitedString ( actualDependentBeans )  )  )     +     \"  ]    in   its   raw   version   as   part   of   a   circular   reference ,    but   has   eventually   been    \"  )     +     \" wrapped .    This   means   that   said   other   beans   do   not   use   the   final   version   of   the    \"  )     +     \" bean .    This   is   often   the   result   of   over - eager   type   matching    -    consider   using    \"  )     +     \"  ' getBeanNamesOfType '    with   the    ' allowEagerInit '    flag   turned   off ,    for   example .  \"  )  )  ;", "}", "}", "}", "}", "try    {", "registerDisposableBeanIfNecessary ( beanName ,    bean ,    mbd )  ;", "}    catch    ( BeanDefinitionValidationException   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Invalid   destruction   signature \"  ,    ex )  ;", "}", "return   exposedObject ;", "}", "METHOD_END"], "methodName": ["doCreateBean"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "List < PropertyDescriptor >    pds    =    new   LinkedList <  >  ( Arrays . asList ( bw . getPropertyDescriptors (  )  )  )  ;", "pds . removeIf ( this :  : isExcludedFromDependencyCheck )  ;", "return   pds . toArray ( new   PropertyDescriptor [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["filterPropertyDescriptorsForDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "PropertyDescriptor [  ]    filtered    =    this . filteredPropertyDescriptorsCache . get ( bw . getWrappedClass (  )  )  ;", "if    ( filtered    =  =    null )     {", "filtered    =    filterPropertyDescriptorsForDependencyCheck ( bw )  ;", "if    ( cache )     {", "PropertyDescriptor [  ]    existing    =    this . filteredPropertyDescriptorsCache . putIfAbsent ( bw . getWrappedClass (  )  ,    filtered )  ;", "if    ( existing    !  =    null )     {", "filtered    =    existing ;", "}", "}", "}", "return   filtered ;", "}", "METHOD_END"], "methodName": ["filterPropertyDescriptorsForDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Object   exposedObject    =    bean ;", "if    (  (  !  ( mbd . isSynthetic (  )  )  )     &  &     ( hasInstantiationAwarPostProcessors (  )  )  )     {", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   SmartInstantiationAwarPostProcessor )     {", "SmartInstantiationAwarPostProcessor   ibp    =     (  ( SmartInstantiationAwarPostProcessor )     ( bp )  )  ;", "exposedObject    =    ibp . getEarlyBeanReference ( exposedObject ,    beanName )  ;", "}", "}", "}", "return   exposedObject ;", "}", "METHOD_END"], "methodName": ["getEarlyBeanReference"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . instantiationStrategy ;", "}", "METHOD_END"], "methodName": ["getInstantiationStrategy"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( isPrototypeCurrentlyInCreation ( beanName )  )     {", "return   null ;", "}", "Object   instance    =    null ;", "try    {", "beforePrototypeCreation ( beanName )  ;", "instance    =    resolveBeforeInstantiation ( beanName ,    mbd )  ;", "if    ( instance    =  =    null )     {", "BeanWrapper   bw    =    createBeanInstance ( beanName ,    mbd ,    null )  ;", "instance    =    bw . getWrappedInstance (  )  ;", "}", "}    catch    ( BeanCreationException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Bean   creation   exception   on   non - singleton   Bean   type   check :     \"     +    ex )  )  ;", "}", "onSuppressedException ( ex )  ;", "return   null ;", "}    finally    {", "afterPrototypeCreation ( beanName )  ;", "}", "return   getBean ( beanName ,    instance )  ;", "}", "METHOD_END"], "methodName": ["getNonSingletonFactoryBeanForTypeCheck"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["getParameterNameDiscoverer"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( getSingletonMutex (  )  )     {", "BeanWrapper   bw    =    thiBeanInstanceCache . get ( beanName )  ;", "if    ( bw    !  =    null )     {", "return    (  ( FactoryBean <  ?  >  )     ( bw . getWrappedInstance (  )  )  )  ;", "}", "Object   beanInstance    =    getSingleton ( beanName ,    false )  ;", "if    ( beanInstance   instanceof   FactoryBean )     {", "return    (  ( FactoryBean <  ?  >  )     ( beanInstance )  )  ;", "}", "if    (  ( isSingletonCurrentlyInCreation ( beanName )  )     |  |     (  (  ( mbd . getFactoryBeanName (  )  )     !  =    null )     &  &     ( isSingletonCurrentlyInCreation ( mbd . getFactoryBeanName (  )  )  )  )  )     {", "return   null ;", "}", "Object   instance ;", "try    {", "beforeSingletonCreation ( beanName )  ;", "instance    =    resolveBeforeInstantiation ( beanName ,    mbd )  ;", "if    ( instance    =  =    null )     {", "bw    =    createBeanInstance ( beanName ,    mbd ,    null )  ;", "instance    =    bw . getWrappedInstance (  )  ;", "}", "}    finally    {", "afterSingletonCreation ( beanName )  ;", "}", "FactoryBean <  ?  >    fb    =    getFactoryBean ( beanName ,    instance )  ;", "if    ( bw    !  =    null )     {", "thiBeanInstanceCache . put ( beanName ,    bw )  ;", "}", "return   fb ;", "}", "}", "METHOD_END"], "methodName": ["getSingletonFactoryBeanForTypeCheck"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "class   Holder    {", "@ Nullable", "Class <  ?  >    value    =    null ;", "}", "final   Holder   objectType    =    new   Holder (  )  ;", "Class <  ?  >    fbClass    =    ClassUtils . getUserClass ( beanClass )  ;", "ReflectionUtils . doWithMethods ( fbClass ,     (    method )     -  >     {", "if    (  ( method . getName (  )  . equals ( MethodName )  )     &  &     (  . class . isAssignableFrom ( method . getReturnType (  )  )  )  )     {", "Class <  ?  >    currentType    =    GenericTypeResolver . resolveReturnTypeArgument ( method ,     . class )  ;", "if    ( currentType    !  =    null )     {", "objectType . value    =    ClassUtils . determineCommonAncestor ( currentType ,    objectType . value )  ;", "}", "}", "}  )  ;", "return    (  ( objectType . value )     !  =    null )     &  &     (  ( Object . class )     !  =     ( objectType . value )  )     ?    objectType . value    :    null ;", "}", "METHOD_END"], "methodName": ["getTypeForFactoryBeanFromMethod"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   cachedReturnType    =    mbd . factoryMethodReturnType ;", "if    ( cachedReturnType    !  =    null )     {", "return   cachedReturnType . resolve (  )  ;", "}", "Class <  ?  >    factoryClass ;", "boolean   isStatic    =    true ;", "String   factoryBeanName    =    mbd . getFactoryBeanName (  )  ;", "if    ( factoryBeanName    !  =    null )     {", "if    ( factoryBeanName . equals ( beanName )  )     {", "throw   new   BeanDefinitionStoreException ( mbd . getResourceDescription (  )  ,    beanName ,     \" factory - bean   reference   points   back   to   the   same   bean   definition \"  )  ;", "}", "factoryClass    =    getType ( factoryBeanName )  ;", "isStatic    =    false ;", "} else    {", "factoryClass    =    resolveBeanClass ( mbd ,    beanName ,    typesToMatch )  ;", "}", "if    ( factoryClass    =  =    null )     {", "return   null ;", "}", "factoryClass    =    ClassUtils . getUserClass ( factoryClass )  ;", "Class <  ?  >    commonType    =    null ;", "Method   uniqueCandidate    =    null ;", "int   minNrOfArgs    =     ( mbd . hasConstructorArgumentValues (  )  )     ?    mbd . getConstructorArgumentValues (  )  . getArgumentCount (  )     :     0  ;", "Method [  ]    candidates    =    ReflectionUtils . getUniqueDeclaredMethods ( factoryClass )  ;", "for    ( Method   factoryMethod    :    candidates )     {", "if    (  (  (  ( Modifier . isStatic ( factoryMethod . getModifiers (  )  )  )     =  =    isStatic )     &  &     ( factoryMethod . getName (  )  . equals ( mbd . getFactoryMethodName (  )  )  )  )     &  &     (  ( factoryMethod . getParameterCount (  )  )     >  =    minNrOfArgs )  )     {", "if    (  ( factoryMethod . getTypeParameters (  )  . length )     >     0  )     {", "try    {", "Class <  ?  >  [  ]    paramTypes    =    factoryMethod . getParameterTypes (  )  ;", "String [  ]    paramNames    =    null ;", "ParameterNameDiscoverer   pnd    =    getParameterNameDiscoverer (  )  ;", "if    ( pnd    !  =    null )     {", "paramNames    =    pnd . getParameterNames ( factoryMethod )  ;", "}", "ConstructorArgumentValues   cav    =    mbd . getConstructorArgumentValues (  )  ;", "Set < ConstructorArgumentValues . ValueHolder >    usedValueHolders    =    new   HashSet <  >  ( paramTypes . length )  ;", "Object [  ]    args    =    new   Object [ paramTypes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "ConstructorArgumentValues . ValueHolder   valueHolder    =    cav . getArgumentValue ( i ,    paramTypes [ i ]  ,     ( paramNames    !  =    null    ?    paramNames [ i ]     :    null )  ,    usedValueHolders )  ;", "if    ( valueHolder    =  =    null )     {", "valueHolder    =    cav . getGenericArgumentValue ( null ,    null ,    usedValueHolders )  ;", "}", "if    ( valueHolder    !  =    null )     {", "args [ i ]     =    valueHolder . getValue (  )  ;", "usedValueHolders . add ( valueHolder )  ;", "}", "}", "Class <  ?  >    returnType    =    AutowireUtils . resolveReturnTypeForFactoryMethod ( factoryMethod ,    args ,    getBeanClassLoader (  )  )  ;", "uniqueCandidate    =     (  ( commonType    =  =    null )     &  &     ( returnType    =  =     ( factoryMethod . getReturnType (  )  )  )  )     ?    factoryMethod    :    null ;", "commonType    =    ClassUtils . determineCommonAncestor ( returnType ,    commonType )  ;", "if    ( commonType    =  =    null )     {", "return   null ;", "}", "}    catch    ( Throwable   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Failed   to   resolve   generic   return   type   for   factory   method :     \"     +    ex )  )  ;", "}", "}", "} else    {", "uniqueCandidate    =     ( commonType    =  =    null )     ?    factoryMethod    :    null ;", "commonType    =    ClassUtils . determineCommonAncestor ( factoryMethod . getReturnType (  )  ,    commonType )  ;", "if    ( commonType    =  =    null )     {", "return   null ;", "}", "}", "}", "}", "if    ( commonType    =  =    null )     {", "return   null ;", "}", "cachedReturnType    =     ( uniqueCandidate    !  =    null )     ?    ResolvableType . forMethodReturnType ( uniqueCandidate )     :    ResolvableType . forClass ( commonType )  ;", "mbd . factoryMethodReturnType    =    cachedReturnType ;", "return   cachedReturnType . resolve (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeForFactoryMethod"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . ignoredDependencyInterfaces . add ( ifc )  ;", "}", "METHOD_END"], "methodName": ["ignoreDependencyInterface"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . ignoredDependencyTypes . add ( type )  ;", "}", "METHOD_END"], "methodName": ["ignoreDependencyType"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >     {", "invokeAwareMethods ( Name ,     )  ;", "return   null ;", "}  )  )  ,    getAccessControlContext (  )  )  ;", "} else    {", "invokeAwareMethods ( Name ,     )  ;", "}", "Object   wrappedBean    =     ;", "if    (  ( mbd    =  =    null )     |  |     (  !  ( mbd . isSynthetic (  )  )  )  )     {", "wrappedBean    =    applyBeanPostProcessorsBeforeInitialization ( wrappedBean ,    Name )  ;", "}", "try    {", "invokeInitMethods ( Name ,    wrappedBean ,    mbd )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException (  ( mbd    !  =    null    ?    mbd . getResourceDescription (  )     :    null )  ,    Name ,     \" Invocation   of   init   method   failed \"  ,    ex )  ;", "}", "if    (  ( mbd    =  =    null )     |  |     (  !  ( mbd . isSynthetic (  )  )  )  )     {", "wrappedBean    =    applyBeanPostProcessorsAfterInitialization ( wrappedBean ,    Name )  ;", "}", "return   wrappedBean ;", "}", "METHOD_END"], "methodName": ["initializeBean"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   beanInstance ;", "final      parent    =    this ;", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "beanInstance    =    AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >    getInstantiationStrategy (  )  . instantiate ( mbd ,    beanName ,    parent )  )  )  ,    getAccessControlContext (  )  )  ;", "} else    {", "beanInstance    =    getInstantiationStrategy (  )  . instantiate ( mbd ,    beanName ,    parent )  ;", "}", "BeanWrapper   bw    =    new   BeanWrapperImpl ( beanInstance )  ;", "initBeanWrapper ( bw )  ;", "return   bw ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Instantiation   of   bean   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateBean"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   ConstructorResolver ( this )  . instantiateUsingFactoryMethod ( beanName ,    mbd ,    explicitArgs )  ;", "}", "METHOD_END"], "methodName": ["instantiateUsingFactoryMethod"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( bean   instanceof   Aware )     {", "if    ( bean   instanceof   BeanNameAware )     {", "(  ( BeanNameAware )     ( bean )  )  . setBeanName ( beanName )  ;", "}", "if    ( bean   instanceof   BeanClassLoaderAware )     {", "ClassLoader   bcl    =    getBeanClassLoader (  )  ;", "if    ( bcl    !  =    null )     {", "(  ( BeanClassLoaderAware )     ( bean )  )  . setBeanClassLoader ( bcl )  ;", "}", "}", "if    ( bean   instanceof   Aware )     {", "(  ( Aware )     ( bean )  )  . set ( this )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeAwareMethods"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   initMethodName    =    mbd . getInitMethodName (  )  ;", "Assert . state (  ( initMethodName    !  =    null )  ,     \" No   init   method   set \"  )  ;", "final   Method   initMethod    =     ( mbd . isNonPublicAccessAllowed (  )  )     ?    BeanUtils . findMethod ( bean . getClass (  )  ,    initMethodName )     :    ClassUtils . getMethodIfAvailable ( bean . getClass (  )  ,    initMethodName )  ;", "if    ( initMethod    =  =    null )     {", "if    ( mbd . isEnforceInitMethod (  )  )     {", "throw   new   BeanDefinitionValidationException (  (  (  (  (  \" Couldn ' t   find   an   init   method   named    '  \"     +    initMethodName )     +     \"  '    on   bean   with   name    '  \"  )     +    beanName )     +     \"  '  \"  )  )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" No   default   init   method   named    '  \"     +    initMethodName )     +     \"  '    found   on   bean   with   name    '  \"  )     +    beanName )     +     \"  '  \"  )  )  ;", "}", "return ;", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Invoking   init   method       '  \"     +    initMethodName )     +     \"  '    on   bean   with   name    '  \"  )     +    beanName )     +     \"  '  \"  )  )  ;", "}", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >     {", "ReflectionUtils . makeAccessible ( initMethod )  ;", "return   null ;", "}  )  )  )  ;", "try    {", "AccessController . doPrivileged (  (  ( PrivilegedExceptionAction < Object >  )     (  (  )     -  >    initMethod . invoke ( bean )  )  )  ,    getAccessControlContext (  )  )  ;", "}    catch    ( PrivilegedActionException   pae )     {", "InvocationTargetException   ex    =     (  ( InvocationTargetException )     ( pae . getException (  )  )  )  ;", "throw   ex . getTargetException (  )  ;", "}", "} else    {", "try    {", "ReflectionUtils . makeAccessible ( initMethod )  ;", "initMethod . invoke ( bean )  ;", "}    catch    ( InvocationTargetException   ex )     {", "throw   ex . getTargetException (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeCustomInitMethod"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "boolean   isInitializingBean    =    bean   instanceof   InitializingBean ;", "if    ( isInitializingBean    &  &     (  ( mbd    =  =    null )     |  |     (  !  ( mbd . isExternallyManagedInitMethod (  \" afterPropertiesSet \"  )  )  )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Invoking   afterPropertiesSet (  )    on   bean   with   name    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "try    {", "AccessController . doPrivileged (  (  ( PrivilegedExceptionAction < Object >  )     (  (  )     -  >     {", "(  ( InitializingBean )     ( bean )  )  . afterPropertiesSet (  )  ;", "return   null ;", "}  )  )  ,    getAccessControlContext (  )  )  ;", "}    catch    ( PrivilegedActionException   pae )     {", "throw   pae . getException (  )  ;", "}", "} else    {", "(  ( InitializingBean )     ( bean )  )  . afterPropertiesSet (  )  ;", "}", "}", "if    (  ( mbd    !  =    null )     &  &     (  ( bean . getClass (  )  )     !  =     ( NullBean . class )  )  )     {", "String   initMethodName    =    mbd . getInitMethodName (  )  ;", "if    (  (  ( StringUtils . hasLength ( initMethodName )  )     &  &     (  !  ( isInitializingBean    &  &     (  \" afterPropertiesSet \"  . equals ( initMethodName )  )  )  )  )     &  &     (  !  ( mbd . isExternallyManagedInitMethod ( initMethodName )  )  )  )     {", "invokeCustomInitMethod ( beanName ,    bean ,    mbd )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["invokeInitMethods"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( AutowireUtils . isExcludedFromDependencyCheck ( pd )  )     |  |     ( this . ignoredDependencyTypes . contains ( pd . getPropertyType (  )  )  )  )     |  |     ( AutowireUtils . isSetterDefinedInInterface ( pd ,    this . ignoredDependencyInterfaces )  )  ;", "}", "METHOD_END"], "methodName": ["isExcludedFromDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   outerBean    =    this . currentlyCreatedBean . get (  )  ;", "this . currentlyCreatedBean . set ( beanName )  ;", "Object   instance ;", "try    {", "instance    =    instanceSupplier . get (  )  ;", "}    finally    {", "if    ( outerBean    !  =    null )     {", "this . currentlyCreatedBean . set ( outerBean )  ;", "} else    {", "this . currentlyCreatedBean . remove (  )  ;", "}", "}", "BeanWrapper   bw    =    new   BeanWrapperImpl ( instance )  ;", "initBeanWrapper ( bw )  ;", "return   bw ;", "}", "METHOD_END"], "methodName": ["obtainFromSupplier"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( bw    =  =    null )     {", "if    ( mbd . hasPropertyValues (  )  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Cannot   apply   property   values   to   null   instance \"  )  ;", "} else    {", "return ;", "}", "}", "boolean   continueWithPropertyPopulation    =    true ;", "if    (  (  !  ( mbd . isSynthetic (  )  )  )     &  &     ( hasInstantiationAwareBeanPostProcessors (  )  )  )     {", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   InstantiationAwareBeanPostProcessor )     {", "InstantiationAwareBeanPostProcessor   ibp    =     (  ( InstantiationAwareBeanPostProcessor )     ( bp )  )  ;", "if    (  !  ( ibp . postProcessAfterInstantiation ( bw . getWrappedInstance (  )  ,    beanName )  )  )     {", "continueWithPropertyPopulation    =    false ;", "break ;", "}", "}", "}", "}", "if    (  ! continueWithPropertyPopulation )     {", "return ;", "}", "PropertyValues   pvs    =     ( mbd . hasPropertyValues (  )  )     ?    mbd . getPropertyValues (  )     :    null ;", "if    (  (  ( mbd . getResolvedMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ BY _ NAME )  )     |  |     (  ( mbd . getResolvedMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  )  )     {", "MutablePropertyValues   newPvs    =    new   MutablePropertyValues ( pvs )  ;", "if    (  ( mbd . getResolvedMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ BY _ NAME )  )     {", "autowireByName ( beanName ,    mbd ,    bw ,    newPvs )  ;", "}", "if    (  ( mbd . getResolvedMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  )     {", "autowireByType ( beanName ,    mbd ,    bw ,    newPvs )  ;", "}", "pvs    =    newPvs ;", "}", "boolean   hasInstAwareBpps    =    hasInstantiationAwareBeanPostProcessors (  )  ;", "boolean   needsDepCheck    =     ( mbd . getDependencyCheck (  )  )     !  =     ( RootBeanDefinition . DEPENDENCY _ CHECK _ NONE )  ;", "if    ( hasInstAwareBpps    |  |    needsDepCheck )     {", "if    ( pvs    =  =    null )     {", "pvs    =    mbd . getPropertyValues (  )  ;", "}", "PropertyDescriptor [  ]    filteredPds    =    filterPropertyDescriptorsForDependencyCheck ( bw ,    mbd . allowCaching )  ;", "if    ( hasInstAwareBpps )     {", "for    ( BeanPostProcessor   bp    :    getBeanPostProcessors (  )  )     {", "if    ( bp   instanceof   InstantiationAwareBeanPostProcessor )     {", "InstantiationAwareBeanPostProcessor   ibp    =     (  ( InstantiationAwareBeanPostProcessor )     ( bp )  )  ;", "pvs    =    ibp . postProcessPropertyValues ( pvs ,    filteredPds ,    bw . getWrappedInstance (  )  ,    beanName )  ;", "if    ( pvs    =  =    null )     {", "return ;", "}", "}", "}", "}", "if    ( needsDepCheck )     {", "checkDependencies ( beanName ,    mbd ,    filteredPds ,    pvs )  ;", "}", "}", "if    ( pvs    !  =    null )     {", "applyPropertyValues ( beanName ,    mbd ,    bw ,    pvs )  ;", "}", "}", "METHOD_END"], "methodName": ["populateBean"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Object   bean    =    null ;", "if    (  !  ( Boolean . FALSE . equals ( mbd . beforeInstantiationResolved )  )  )     {", "if    (  (  !  ( mbd . isSynthetic (  )  )  )     &  &     ( hasInstantiationAwarPostProcessors (  )  )  )     {", "Class <  ?  >    targetType    =    determineTargetType ( beanName ,    mbd )  ;", "if    ( targetType    !  =    null )     {", "bean    =    applyBeanPostProcessorsBeforeInstantiation ( targetType ,    beanName )  ;", "if    ( bean    !  =    null )     {", "bean    =    applyBeanPostProcessorsAfterInitialization ( bean ,    beanName )  ;", "}", "}", "}", "mbd . beforeInstantiationResolved    =    bean    !  =    null ;", "}", "return   bean ;", "}", "METHOD_END"], "methodName": ["resolveBeforeInstantiation"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . allowCircularReferences    =    allowCircularReferences ;", "}", "METHOD_END"], "methodName": ["setAllowCircularReferences"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . allowRawInjectionDespiteWrapping    =    allowRawInjectionDespiteWrapping ;", "}", "METHOD_END"], "methodName": ["setAllowRawInjectionDespiteWrapping"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . instantiationStrategy    =    instantiationStrategy ;", "}", "METHOD_END"], "methodName": ["setInstantiationStrategy"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . parameterNameDiscoverer    =    parameterNameDiscoverer ;", "}", "METHOD_END"], "methodName": ["setParameterNameDiscoverer"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Set < String >    result    =    new   TreeSet <  >  (  )  ;", "PropertyValues   pvs    =    mbd . getPropertyValues (  )  ;", "PropertyDescriptor [  ]    pds    =    bw . getPropertyDescriptors (  )  ;", "for    ( PropertyDescriptor   pd    :    pds )     {", "if    (  (  (  (  ( pd . getWriteMethod (  )  )     !  =    null )     &  &     (  !  ( isExcludedFromDependencyCheck ( pd )  )  )  )     &  &     (  !  ( pvs . contains ( pd . getName (  )  )  )  )  )     &  &     (  !  ( BeanUtils . isSimpleProperty ( pd . getPropertyType (  )  )  )  )  )     {", "result . add ( pd . getName (  )  )  ;", "}", "}", "return   StringUtils . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["unsatisfiedNonSimpleProperties"], "fileName": "org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . qualifiers . put ( qualifier . getTypeName (  )  ,    qualifier )  ;", "}", "METHOD_END"], "methodName": ["addQualifier"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "setLazyInit ( defaults . isLazyInit (  )  )  ;", "setAutowireMode ( defaults . getAutowireMode (  )  )  ;", "setDependencyCheck ( defaults . getDependencyCheck (  )  )  ;", "setInitMethodName ( defaults . getInitMethodName (  )  )  ;", "setEnforceInitMethod ( false )  ;", "setDestroyMethodName ( defaults . getDestroyMethodName (  )  )  ;", "setEnforceDestroyMethod ( false )  ;", "}", "METHOD_END"], "methodName": ["applyDefaults"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \" Source   must   not   be   null \"  )  ;", "this . qualifiers . putAll ( source . qualifiers )  ;", "}", "METHOD_END"], "methodName": ["copyQualifiersFrom"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . autowireMode ;", "}", "METHOD_END"], "methodName": ["getAutowireMode"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "Object   beanClassObject    =    this . beanClass ;", "if    ( beanClassObject    =  =    null )     {", "throw   new   IllegalStateException (  \" No   bean   class   specified   on   bean   d \"  )  ;", "}", "if    (  !  ( beanClassObject   instanceof   Class )  )     {", "throw   new   IllegalStateException (  (  (  \" Bean   class   name    [  \"     +    beanClassObject )     +     \"  ]    has   not   been   resolved   into   an   actual   Class \"  )  )  ;", "}", "return    (  ( Class <  ?  >  )     ( beanClassObject )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . dependencyCheck ;", "}", "METHOD_END"], "methodName": ["getDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . destroyMethodName ;", "}", "METHOD_END"], "methodName": ["getDestroyMethodName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . initMethodName ;", "}", "METHOD_END"], "methodName": ["getInitMethodName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . instanceSupplier ;", "}", "METHOD_END"], "methodName": ["getInstanceSupplier"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . methodOverrides )     =  =    null )     {", "this . methodOverrides    =    new   MethodOverrides (  )  ;", "}", "return   this . methodOverrides ;", "}", "METHOD_END"], "methodName": ["getMethodOverrides"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . qualifiers . get ( typeName )  ;", "}", "METHOD_END"], "methodName": ["getQualifier"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet <  >  ( this . qualifiers . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getQualifiers"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . autowireMode )     =  =     ( AbstractBeanDefinition . AUTOWIRE _ AUTODETECT )  )     {", "Constructor <  ?  >  [  ]    constructors    =    getBeanClass (  )  . getConstructors (  )  ;", "for    ( Constructor <  ?  >    constructor    :    constructors )     {", "if    (  ( constructor . getParameterCount (  )  )     =  =     0  )     {", "return   AbstractBeanDefinition . AUTOWIRE _ BY _ TYPE ;", "}", "}", "return   AbstractBeanDefinition . AUTOWIRE _ CONSTRUCTOR ;", "} else    {", "return   this . autowireMode ;", "}", "}", "METHOD_END"], "methodName": ["getResolvedAutowireMode"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return    ( this . beanClass )    instanceof   Class ;", "}", "METHOD_END"], "methodName": ["hasBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return    (  ( this . methodOverrides )     !  =    null )     &  &     (  !  ( this . methodOverrides . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasMethodOverrides"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . qualifiers . keySet (  )  . contains ( typeName )  ;", "}", "METHOD_END"], "methodName": ["hasQualifier"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . enforceDestroyMethod ;", "}", "METHOD_END"], "methodName": ["isEnforceDestroyMethod"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . enforceInitMethod ;", "}", "METHOD_END"], "methodName": ["isEnforceInitMethod"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . lenientConstructorResolution ;", "}", "METHOD_END"], "methodName": ["isLenientConstructorResolution"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . nonPublicAccessAllowed ;", "}", "METHOD_END"], "methodName": ["isNonPublicAccessAllowed"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . synthetic ;", "}", "METHOD_END"], "methodName": ["isSynthetic"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasLength ( other . getBeanClassName (  )  )  )     {", "setBeanClassName ( other . getBeanClassName (  )  )  ;", "}", "if    ( StringUtils . hasLength ( other . getScope (  )  )  )     {", "setScope ( other . getScope (  )  )  ;", "}", "setAbstract ( other . isAbstract (  )  )  ;", "setLazyInit ( other . isLazyInit (  )  )  ;", "if    ( StringUtils . hasLength ( other . getFactoryBeanName (  )  )  )     {", "setFactoryBeanName ( other . getFactoryBeanName (  )  )  ;", "}", "if    ( StringUtils . hasLength ( other . getFactoryMethodName (  )  )  )     {", "setFactoryMethodName ( other . getFactoryMethodName (  )  )  ;", "}", "setRole ( other . getRole (  )  )  ;", "setSource ( other . getSource (  )  )  ;", "copyAttributesFrom ( other )  ;", "if    ( other   instanceof    )     {", "otherAbd    =     (  (  )     ( other )  )  ;", "if    ( otherAbd . hasBeanClass (  )  )     {", "setBeanClass ( otherAbd . getBeanClass (  )  )  ;", "}", "if    ( otherAbd . hasConstructorArgumentValues (  )  )     {", "getConstructorArgumentValues (  )  . addArgumentValues ( other . getConstructorArgumentValues (  )  )  ;", "}", "if    ( otherAbd . hasPropertyValues (  )  )     {", "getPropertyValues (  )  . addPropertyValues ( other . getPropertyValues (  )  )  ;", "}", "if    ( otherAbd . hasMethodOverrides (  )  )     {", "getMethodOverrides (  )  . addOverrides ( otherAbd . getMethodOverrides (  )  )  ;", "}", "setAutowireMode ( otherAbd . getAutowireMode (  )  )  ;", "setDependencyCheck ( otherAbd . getDependencyCheck (  )  )  ;", "setDependsOn ( otherAbd . getDependsOn (  )  )  ;", "setAutowireCandidate ( otherAbd . isAutowireCandidate (  )  )  ;", "setPrimary ( otherAbd . isPrimary (  )  )  ;", "copyQualifiersFrom ( otherAbd )  ;", "setInstanceSupplier ( otherAbd . getInstanceSupplier (  )  )  ;", "setNonPublicAccessAllowed ( otherAbd . isNonPublicAccessAllowed (  )  )  ;", "setLenientConstructorResolution ( otherAbd . isLenientConstructorResolution (  )  )  ;", "if    (  ( otherAbd . getInitMethodName (  )  )     !  =    null )     {", "setInitMethodName ( otherAbd . getInitMethodName (  )  )  ;", "setEnforceInitMethod ( otherAbd . isEnforceInitMethod (  )  )  ;", "}", "if    (  ( otherAbd . getDestroyMethodName (  )  )     !  =    null )     {", "setDestroyMethodName ( otherAbd . getDestroyMethodName (  )  )  ;", "setEnforceDestroyMethod ( otherAbd . isEnforceDestroyMethod (  )  )  ;", "}", "setSynthetic ( otherAbd . isSynthetic (  )  )  ;", "setResource ( otherAbd . getResource (  )  )  ;", "} else    {", "getConstructorArgumentValues (  )  . addArgumentValues ( other . getConstructorArgumentValues (  )  )  ;", "getPropertyValues (  )  . addPropertyValues ( other . getPropertyValues (  )  )  ;", "setResourceDescription ( other . getResourceDescription (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["overrideFrom"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "int   count    =    ClassUtils . getMethodCountForName ( getBeanClass (  )  ,    mo . getMethodName (  )  )  ;", "if    ( count    =  =     0  )     {", "throw   new   ValidationException (  (  (  (  (  \" Invalid   method   override :    no   method   with   name    '  \"     +     ( mo . getMethodName (  )  )  )     +     \"  '    on   class    [  \"  )     +     ( getBeanClassName (  )  )  )     +     \"  ]  \"  )  )  ;", "} else", "if    ( count    =  =     1  )     {", "mo . setOverloaded ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareMethodOverride"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    ( hasMethodOverrides (  )  )     {", "Set < MethodOverride >    overrides    =    getMethodOverrides (  )  . getOverrides (  )  ;", "synchronized ( overrides )     {", "for    ( MethodOverride   mo    :    overrides )     {", "prepareMethodOverride ( mo )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["prepareMethodOverrides"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "String   className    =    getBeanClassName (  )  ;", "if    ( className    =  =    null )     {", "return   null ;", "}", "Class <  ?  >    resolvedClass    =    ClassUtils . forName ( className ,    classLoader )  ;", "this . beanClass    =    resolvedClass ;", "return   resolvedClass ;", "}", "METHOD_END"], "methodName": ["resolveBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . abstractFlag    =    abstractFlag ;", "}", "METHOD_END"], "methodName": ["setAbstract"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . autowireMode    =    autowireMode ;", "}", "METHOD_END"], "methodName": ["setAutowireMode"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . beanClass    =    beanClass ;", "}", "METHOD_END"], "methodName": ["setBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . constructorArgumentValues    =    constructorArgumentValues ;", "}", "METHOD_END"], "methodName": ["setConstructorArgumentValues"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . dependencyCheck    =    dependencyCheck ;", "}", "METHOD_END"], "methodName": ["setDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethodName    =    destroyMethodName ;", "}", "METHOD_END"], "methodName": ["setDestroyMethodName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . enforceDestroyMethod    =    enforceDestroyMethod ;", "}", "METHOD_END"], "methodName": ["setEnforceDestroyMethod"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . enforceInitMethod    =    enforceInitMethod ;", "}", "METHOD_END"], "methodName": ["setEnforceInitMethod"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . initMethodName    =    initMethodName ;", "}", "METHOD_END"], "methodName": ["setInitMethodName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . instanceSupplier    =    instanceSupplier ;", "}", "METHOD_END"], "methodName": ["setInstanceSupplier"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . lenientConstructorResolution    =    lenientConstructorResolution ;", "}", "METHOD_END"], "methodName": ["setLenientConstructorResolution"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . methodOverrides    =    methodOverrides ;", "}", "METHOD_END"], "methodName": ["setMethodOverrides"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . nonPublicAccessAllowed    =    nonPublicAccessAllowed ;", "}", "METHOD_END"], "methodName": ["setNonPublicAccessAllowed"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . resource    =    new   BeanDefinitionResource ( originatingBd )  ;", "}", "METHOD_END"], "methodName": ["setOriginatingBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . propertyValues    =    propertyValues ;", "}", "METHOD_END"], "methodName": ["setPropertyValues"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . resource    =    resource ;", "}", "METHOD_END"], "methodName": ["setResource"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . resource    =     ( resourceDescription    !  =    null )     ?    new   DescriptiveResource ( resourceDescription )     :    null ;", "}", "METHOD_END"], "methodName": ["setResourceDescription"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . role    =    role ;", "}", "METHOD_END"], "methodName": ["setRole"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . synthetic    =    synthetic ;", "}", "METHOD_END"], "methodName": ["setSynthetic"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hasMethodOverrides (  )  )     &  &     (  ( getFactoryMethodName (  )  )     !  =    null )  )     {", "throw   new   ValidationException (  (  \" Cannot   combine   static   factory   method   with   method   overrides :     \"     +     \" the   static   factory   method   must   create   the   instance \"  )  )  ;", "}", "if    ( hasBeanClass (  )  )     {", "prepareMethodOverrides (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . registry ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "ResourceLoader   resourceLoader    =    getResourceLoader (  )  ;", "if    ( resourceLoader    =  =    null )     {", "throw   new   StoreException (  (  (  \" Cannot   import   bean   definitions   from   location    [  \"     +    location )     +     \"  ]  :    no   ResourceLoader   available \"  )  )  ;", "}", "if    ( resourceLoader   instanceof   ResourcePatternResolver )     {", "try    {", "Resource [  ]    resources    =     (  ( ResourcePatternResolver )     ( resourceLoader )  )  . getResources ( location )  ;", "int   loadCount    =    loads ( resources )  ;", "if    ( actualResources    !  =    null )     {", "for    ( Resource   resource    :    resources )     {", "actualResources . add ( resource )  ;", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Loaded    \"     +    loadCount )     +     \"    bean   definitions   from   location   pattern    [  \"  )     +    location )     +     \"  ]  \"  )  )  ;", "}", "return   loadCount ;", "}    catch    ( IOException   ex )     {", "throw   new   StoreException (  (  (  \" Could   not   resolve   bean   definition   resource   pattern    [  \"     +    location )     +     \"  ]  \"  )  ,    ex )  ;", "}", "} else    {", "Resource   resource    =    resourceLoader . getResource ( location )  ;", "int   loadCount    =    loads ( resource )  ;", "if    ( actualResources    !  =    null )     {", "actualResources . add ( resource )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Loaded    \"     +    loadCount )     +     \"    bean   definitions   from   location    [  \"  )     +    location )     +     \"  ]  \"  )  )  ;", "}", "return   loadCount ;", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . beanClassLoader    =    beanClassLoader ;", "}", "METHOD_END"], "methodName": ["setBeanClassLoader"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . beanNameGenerator    =     ( beanNameGenerator    !  =    null )     ?    beanNameGenerator    :    new   DefaultBeanNameGenerator (  )  ;", "}", "METHOD_END"], "methodName": ["setBeanNameGenerator"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( environment ,     \" Environment   must   not   be   null \"  )  ;", "this . environment    =    environment ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . resourceLoader    =    resourceLoader ;", "}", "METHOD_END"], "methodName": ["setResourceLoader"], "fileName": "org.springframework.beans.factory.support.AbstractBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Object   curVal    =    this . prototypesCurrentlyInCreation . get (  )  ;", "if    ( curVal   instanceof   St )     {", "this . prototypesCurrentlyInCreation . remove (  )  ;", "} else", "if    ( curVal   instanceof   Set )     {", "Set < St >    beanNameSet    =     (  ( Set < St >  )     ( curVal )  )  ;", "beanNameSet . remove ( beanName )  ;", "if    ( beanNameSet . isEmpty (  )  )     {", "this . prototypesCurrentlyInCreation . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["afterPrototypeCreation"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Object   curVal    =    this . prototypesCurrentlyInCreation . get (  )  ;", "if    ( curVal    =  =    null )     {", "this . prototypesCurrentlyInCreation . set ( Name )  ;", "} else", "if    ( curVal   instanceof   String )     {", "Set < String >    NameSet    =    new   HashSet <  >  (  2  )  ;", "NameSet . add (  (  ( String )     ( curVal )  )  )  ;", "NameSet . add ( Name )  ;", "this . prototypesCurrentlyInCreation . set ( NameSet )  ;", "} else    {", "Set < String >    NameSet    =     (  ( Set < String >  )     ( curVal )  )  ;", "NameSet . add ( Name )  ;", "}", "}", "METHOD_END"], "methodName": ["beforePrototypeCreation"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( mbd . isAbstract (  )  )     {", "throw   new   BeanIsAbstractException ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["checkMergedBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . mergedBeanDefinitions )     {", "this . alreadyCreated . remove ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanupAfterBeanCreationFailure"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . mergedBeanDefinitions . remove ( beanName )  ;", "}", "METHOD_END"], "methodName": ["clearMergedBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . mergedBeanDefinitions . keySet (  )  . removeIf (  (    bean )     -  >     !  ( isBeanEligibleForMetadataCaching ( bean )  )  )  ;", "}", "METHOD_END"], "methodName": ["clearMetadataCache"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "new   DisposableBeanAdapter ( bean ,    beanName ,    mbd ,    getBeanPostProcessors (  )  ,    getAccessControlContext (  )  )  . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["destroyBean"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "final   String   beanName    =    transformedBeanName ( name )  ;", "Object   bean ;", "Object   sharedInstance    =    getSingleton ( beanName )  ;", "if    (  ( sharedInstance    !  =    null )     &  &     ( args    =  =    null )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "if    ( isSingletonCurrentlyInCreation ( beanName )  )     {", "logger . debug (  (  (  \" Returning   eagerly   cached   instance   of   singleton   bean    '  \"     +    beanName )     +     \"  '    that   is   not   fully   initialized   yet    -    a   consequence   of   a   circular   reference \"  )  )  ;", "} else    {", "logger . debug (  (  (  \" Returning   cached   instance   of   singleton   bean    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "}", "bean    =    getObjectForBeanInstance ( sharedInstance ,    name ,    beanName ,    null )  ;", "} else    {", "if    ( isPrototypeCurrentlyInCreation ( beanName )  )     {", "throw   new   BeanCurrentlyInCreationException ( beanName )  ;", "}", "BeanFactory   parentBeanFactory    =    getParentBeanFactory (  )  ;", "if    (  ( parentBeanFactory    !  =    null )     &  &     (  !  ( containsBeanDefinition ( beanName )  )  )  )     {", "String   nameToLookup    =    originalBeanName ( name )  ;", "if    ( parentBeanFactory   instanceof   AbstractBeanFactory )     {", "return    (  ( AbstractBeanFactory )     ( parentBeanFactory )  )  . doGetBean ( nameToLookup ,    requiredType ,    args ,    typeCheckOnly )  ;", "} else", "if    ( args    !  =    null )     {", "return    (  ( T )     ( parentBeanFactory . getBean ( nameToLookup ,    args )  )  )  ;", "} else    {", "return   parentBeanFactory . getBean ( nameToLookup ,    requiredType )  ;", "}", "}", "if    (  ! typeCheckOnly )     {", "markBeanAsCreated ( beanName )  ;", "}", "try    {", "final   RootBeanDefinition   mbd    =    getMergedLocalBeanDefinition ( beanName )  ;", "checkMergedBeanDefinition ( mbd ,    beanName ,    args )  ;", "String [  ]    dependsOn    =    mbd . getDependsOn (  )  ;", "if    ( dependsOn    !  =    null )     {", "for    ( String   dep    :    dependsOn )     {", "if    ( isDependent ( beanName ,    dep )  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  \" Circular   depends - on   relationship   between    '  \"     +    beanName )     +     \"  '    and    '  \"  )     +    dep )     +     \"  '  \"  )  )  ;", "}", "registerDependentBean ( dep ,    beanName )  ;", "try    {", "getBean ( dep )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  \"  '  \"     +    beanName )     +     \"  '    depends   on   missing   bean    '  \"  )     +    dep )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "if    ( mbd . isSingleton (  )  )     {", "sharedInstance    =    getSingleton ( beanName ,     (  )     -  >     {", "try    {", "return   createBean ( beanName ,    mbd ,    args )  ;", "}    catch    ( BeansException   ex )     {", "destroySingleton ( beanName )  ;", "throw   ex ;", "}", "}  )  ;", "bean    =    getObjectForBeanInstance ( sharedInstance ,    name ,    beanName ,    mbd )  ;", "} else", "if    ( mbd . isPrototype (  )  )     {", "Object   prototypeInstance    =    null ;", "try    {", "beforePrototypeCreation ( beanName )  ;", "prototypeInstance    =    createBean ( beanName ,    mbd ,    args )  ;", "}    finally    {", "afterPrototypeCreation ( beanName )  ;", "}", "bean    =    getObjectForBeanInstance ( prototypeInstance ,    name ,    beanName ,    mbd )  ;", "} else    {", "String   scopeName    =    mbd . getScope (  )  ;", "final   config . Scope   scope    =    this . scopes . get ( scopeName )  ;", "if    ( scope    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   Scope   registered   for   scope   name    '  \"     +    scopeName )     +     \"  '  \"  )  )  ;", "}", "try    {", "Object   scopedInstance    =    scope . get ( beanName ,     (  )     -  >     {", "beforePrototypeCreation ( beanName )  ;", "try    {", "return   createBean ( beanName ,    mbd ,    args )  ;", "}    finally    {", "afterPrototypeCreation ( beanName )  ;", "}", "}  )  ;", "bean    =    getObjectForBeanInstance ( scopedInstance ,    name ,    beanName ,    mbd )  ;", "}    catch    ( IllegalStateException   ex )     {", "throw   new   BeanCreationException ( beanName ,     (  (  (  \" Scope    '  \"     +    scopeName )     +     \"  '    is   not   active   for   the   current   thread ;    consider    \"  )     +     \" defining   a   scoped   proxy   for   this   bean   if   you   intend   to   refer   to   it   from   a   singleton \"  )  ,    ex )  ;", "}", "}", "}    catch    ( BeansException   ex )     {", "cleanupAfterBeanCreationFailure ( beanName )  ;", "throw   ex ;", "}", "}", "if    (  ( requiredType    !  =    null )     &  &     (  !  ( requiredType . isInstance ( bean )  )  )  )     {", "try    {", "T   convertedBean    =    getTypeConverter (  )  . convertIfNecessary ( bean ,    requiredType )  ;", "if    ( convertedBean    =  =    null )     {", "throw   new   BeanNotOfRequiredTypeException ( name ,    requiredType ,    bean . getClass (  )  )  ;", "}", "return   convertedBean ;", "}    catch    ( TypeMismatchException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Failed   to   convert   bean    '  \"     +    name )     +     \"  '    to   required   type    '  \"  )     +     ( ClassUtils . getQualifiedName ( requiredType )  )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "throw   new   BeanNotOfRequiredTypeException ( name ,    requiredType ,    bean . getClass (  )  )  ;", "}", "}", "return    (  ( T )     ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["doGetBean"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   beanClassLoader    =    getBeanClassLoader (  )  ;", "ClassLoader   classLoaderToUse    =    beanClassLoader ;", "if    (  !  ( ObjectUtils . isEmpty ( typesToMatch )  )  )     {", "ClassLoader   tempClassLoader    =    getTempClassLoader (  )  ;", "if    ( tempClassLoader    !  =    null )     {", "classLoaderToUse    =    tempClassLoader ;", "if    ( tempClassLoader   instanceof   DecoratingClassLoader )     {", "DecoratingClassLoader   dcl    =     (  ( DecoratingClassLoader )     ( tempClassLoader )  )  ;", "for    ( Class <  ?  >    typeToMatch    :    typesToMatch )     {", "dcl . excludeClass ( typeToMatch . getName (  )  )  ;", "}", "}", "}", "}", "String   className    =    mbd . getBeanClassName (  )  ;", "if    ( className    !  =    null )     {", "Object   evaluated    =    evaluateBeanDefinitionString ( className ,    mbd )  ;", "if    (  !  ( className . equals ( evaluated )  )  )     {", "if    ( evaluated   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( evaluated )  )  ;", "} else", "if    ( evaluated   instanceof   String )     {", "return   ClassUtils . forName (  (  ( String )     ( evaluated )  )  ,    classLoaderToUse )  ;", "} else    {", "throw   new   IllegalStateException (  (  \" Invalid   class   name   expression   result :     \"     +    evaluated )  )  ;", "}", "}", "if    ( classLoaderToUse    !  =    beanClassLoader )     {", "return   ClassUtils . forName ( className ,    classLoaderToUse )  ;", "}", "}", "return   mbd . resolveBeanClass ( beanClassLoader )  ;", "}", "METHOD_END"], "methodName": ["doResolveBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanExpressionResolver )     =  =    null )     {", "return   value ;", "}", "Scope   scope    =    null ;", "if    ( beanDefinition    !  =    null )     {", "String   scopeName    =    beanDefinition . getScope (  )  ;", "if    ( scopeName    !  =    null )     {", "scope    =    getRegisteredScope ( scopeName )  ;", "}", "}", "return   this . beanExpressionResolver . evaluate ( value ,    new   BeanExpressionContext ( this ,    scope )  )  ;", "}", "METHOD_END"], "methodName": ["evaluateBeanDefinitionString"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   doGetBean ( name ,    requiredType ,    args ,    false )  ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . beanPostProcessors ;", "}", "METHOD_END"], "methodName": ["getBeanPostProcessors"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . customEditors ;", "}", "METHOD_END"], "methodName": ["getCustomEditors"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . typeConverter ;", "}", "METHOD_END"], "methodName": ["getCustomTypeConverter"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   getMergedBeanDefinition ( beanName ,    bd ,    null )  ;", "}", "METHOD_END"], "methodName": ["getMergedBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . mergedBeanDefinitions )     {", "RootBeanDefinition   mbd    =    null ;", "if    ( containingBd    =  =    null )     {", "mbd    =    this . mergedBeanDefinitions . get ( beanName )  ;", "}", "if    ( mbd    =  =    null )     {", "if    (  ( bd . getParentName (  )  )     =  =    null )     {", "if    ( bd   instanceof   RootBeanDefinition )     {", "mbd    =     (  ( RootBeanDefinition )     ( bd )  )  . cloneBeanDefinition (  )  ;", "} else    {", "mbd    =    new   RootBeanDefinition ( bd )  ;", "}", "} else    {", "BeanDefinition   pbd ;", "try    {", "String   parentBeanName    =    transformedBeanName ( bd . getParentName (  )  )  ;", "if    (  !  ( beanName . equals ( parentBeanName )  )  )     {", "pbd    =    getMergedBeanDefinition ( parentBeanName )  ;", "} else    {", "BeanFactory   parent    =    getParentBeanFactory (  )  ;", "if    ( parent   instanceof   ConfigurableBeanFactory )     {", "pbd    =     (  ( ConfigurableBeanFactory )     ( parent )  )  . getMergedBeanDefinition ( parentBeanName )  ;", "} else    {", "throw   new   NoSuchBeanDefinitionException ( parentBeanName ,     (  (  (  (  \" Parent   name    '  \"     +    parentBeanName )     +     \"  '    is   equal   to   bean   name    '  \"  )     +    beanName )     +     \"  '  :    cannot   be   resolved   without   an      parent \"  )  )  ;", "}", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "throw   new   BeanDefinitionStoreException ( bd . getResourceDescription (  )  ,    beanName ,     (  (  \" Could   not   resolve   parent   bean   definition    '  \"     +     ( bd . getParentName (  )  )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "mbd    =    new   RootBeanDefinition ( pbd )  ;", "mbd . overrideFrom ( bd )  ;", "}", "if    (  !  ( StringUtils . hasLength ( mbd . getScope (  )  )  )  )     {", "mbd . setScope ( RootBeanDefinition . SCOPE _ SINGLETON )  ;", "}", "if    (  (  ( containingBd    !  =    null )     &  &     (  !  ( containingBd . isSingleton (  )  )  )  )     &  &     ( mbd . isSingleton (  )  )  )     {", "mbd . setScope ( containingBd . getScope (  )  )  ;", "}", "if    (  ( containingBd    =  =    null )     &  &     ( isCacheBeanMetadata (  )  )  )     {", "this . mergedBeanDefinitions . put ( beanName ,    mbd )  ;", "}", "}", "return   mbd ;", "}", "}", "METHOD_END"], "methodName": ["getMergedBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   mbd    =    this . mergedBeanDefinitions . get ( beanName )  ;", "if    ( mbd    !  =    null )     {", "return   mbd ;", "}", "return   getMergedBeanDefinition ( beanName ,    getBeanDefinition ( beanName )  )  ;", "}", "METHOD_END"], "methodName": ["getMergedLocalBeanDefinition"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( BeanFactoryUtils . isFactoryDereference ( name )  )     {", "if    ( beanInstance   instanceof   NullBean )     {", "return   beanInstance ;", "}", "if    (  !  ( beanInstance   instanceof   FactoryBean )  )     {", "throw   new   BeanIsNotAFactoryException ( transformedBeanName ( name )  ,    beanInstance . getClass (  )  )  ;", "}", "}", "if    (  (  !  ( beanInstance   instanceof   FactoryBean )  )     |  |     ( BeanFactoryUtils . isFactoryDereference ( name )  )  )     {", "return   beanInstance ;", "}", "Object   object    =    null ;", "if    ( mbd    =  =    null )     {", "object    =    getCachedObjectForFactoryBean ( beanName )  ;", "}", "if    ( object    =  =    null )     {", "FactoryBean <  ?  >    factory    =     (  ( FactoryBean <  ?  >  )     ( beanInstance )  )  ;", "if    (  ( mbd    =  =    null )     &  &     ( containsBeanDefinition ( beanName )  )  )     {", "mbd    =    getMergedLocalBeanDefinition ( beanName )  ;", "}", "boolean   synthetic    =     ( mbd    !  =    null )     &  &     ( mbd . isSynthetic (  )  )  ;", "object    =    getObjectFromFactoryBean ( factory ,    beanName ,     (  ! synthetic )  )  ;", "}", "return   object ;", "}", "METHOD_END"], "methodName": ["getObjectForBeanInstance"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . propertyEditorRegistrars ;", "}", "METHOD_END"], "methodName": ["getPropertyEditorRegistrars"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mbd . isSingleton (  )  )  )     {", "return   null ;", "}", "try    {", "FactoryBean <  ?  >    factoryBean    =    doGetBean (  (  (  . FACTORY _ BEAN _ PREFIX )     +    beanName )  ,    FactoryBean . class ,    null ,    true )  ;", "return   getTypeForFactoryBean ( factoryBean )  ;", "}    catch    ( BeanCreationException   ex )     {", "if    ( ex . contains ( BeanCurrentlyInCreationException . class )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Bean   currently   in   creation   on   FactoryBean   type   check :     \"     +    ex )  )  ;", "}", "} else", "if    ( mbd . isLazyInit (  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Bean   creation   exception   on   lazy   FactoryBean   type   check :     \"     +    ex )  )  ;", "}", "} else    {", "if    ( logger . isWarnEnabled (  )  )     {", "logger . warn (  (  \" Bean   creation   exception   on   non - lazy   FactoryBean   type   check :     \"     +    ex )  )  ;", "}", "}", "onSuppressedException ( ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getTypeForFactoryBean"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    !  ( this . alreadyCreated . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasBeanCreationStarted"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . hasDestructionAwareBeanPostProcessors ;", "}", "METHOD_END"], "methodName": ["hasDestructionAwareBeanPostProcessors"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . hasInstantiationAwareBeanPostProcessors ;", "}", "METHOD_END"], "methodName": ["hasInstantiationAwareBeanPostProcessors"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "bw . setConversionService ( getConversionService (  )  )  ;", "registerCustomEdis ( bw )  ;", "}", "METHOD_END"], "methodName": ["initBeanWrapper"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . alreadyCreated . contains ( beanName )  ;", "}", "METHOD_END"], "methodName": ["isBeanEligibleForMetadataCaching"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( isAlias ( beanName )  )     |  |     ( containsLocalBean ( beanName )  )  )     |  |     ( hasDependentBean ( beanName )  )  ;", "}", "METHOD_END"], "methodName": ["isBeanNameInUse"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    beanType    =    predictBeanType ( beanName ,    mbd ,    FactoryBean . class )  ;", "return    ( beanType    !  =    null )     &  &     ( FactoryBean . class . isAssignableFrom ( beanType )  )  ;", "}", "METHOD_END"], "methodName": ["isFactoryBean"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Object   curVal    =    this . prototypesCurrentlyInCreation . get (  )  ;", "return    ( curVal    !  =    null )     &  &     (  ( curVal . equals ( Name )  )     |  |     (  ( curVal   instanceof   Set )     &  &     (  (  ( Set <  ?  >  )     ( curVal )  )  . contains ( Name )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isPrototypeCurrentlyInCreation"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . alreadyCreated . contains ( beanName )  )  )     {", "synchronized ( this . mergedBeanDefinitions )     {", "if    (  !  ( this . alreadyCreated . contains ( beanName )  )  )     {", "clearMergedBeanDefinition ( beanName )  ;", "this . alreadyCreated . add ( beanName )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["markBeanAsCreated"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =    transformedBeanName ( name )  ;", "if    ( name . startsWith (  . FACTORY _ BEAN _ PREFIX )  )     {", "beanName    =     (  . FACTORY _ BEAN _ PREFIX )     +    beanName ;", "}", "return   beanName ;", "}", "METHOD_END"], "methodName": ["originalBeanName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetType    =    mbd . getTargetType (  )  ;", "if    ( targetType    !  =    null )     {", "return   targetType ;", "}", "if    (  ( mbd . getMethodName (  )  )     !  =    null )     {", "return   null ;", "}", "return   resolveBeanClass ( mbd ,    beanName ,    typesToMatch )  ;", "}", "METHOD_END"], "methodName": ["predictBeanType"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "PropertyEditorRegistrySregistryS =     ( registry   instanceof   PropertyEditorRegistryS    ?     (  ( PropertyEditorRegistryS    ( registry )  )     :    null ;", "if    ( registryS !  =    null )     {", "registrySuseConfigValueEditors (  )  ;", "}", "if    (  !  ( this . propertyEditorRegistrars . isEmpty (  )  )  )     {", "for    ( PropertyEditorRegistrar   registrar    :    this . propertyEditorRegistrars )     {", "try    {", "registrar . registerCustomEditors ( registry )  ;", "}    catch    ( BeanCreationException   ex )     {", "Throwable   rootCause    =    ex . getMostSpecificCause (  )  ;", "if    ( rootCause   instanceof   BeanCurrentlyInCreationException )     {", "BeanCreationException   bce    =     (  ( BeanCreationException )     ( rootCause )  )  ;", "String   bceBeanName    =    bce . getBeanName (  )  ;", "if    (  ( bceBeanName    !  =    null )     &  &     ( isCurrentlyInCreation ( bceBeanName )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" PropertyEditorRegistrar    [  \"     +     ( registrar . getClass (  )  . getName (  )  )  )     +     \"  ]    failed   because   it   tried   to   obtain   currently   created   bean    '  \"  )     +     ( ex . getBeanName (  )  )  )     +     \"  '  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "onSuppressedException ( ex )  ;", "continue ;", "}", "}", "throw   ex ;", "}", "}", "}", "if    (  !  ( this . customEditors . isEmpty (  )  )  )     {", "this . customEditors . forEach (  (    requiredType ,    editorClass )     -  >    registry . registerCustomEditor ( requiredType ,    BeanUtils . instantiateClass ( editorClass )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["registerCustomEditors"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "AccessControlContext   acc    =     (  ( System . getSecurityManager (  )  )     !  =    null )     ?    getAccessControlContext (  )     :    null ;", "if    (  (  !  ( mbd . isPrototype (  )  )  )     &  &     ( requiresDestruction ( bean ,    mbd )  )  )     {", "if    ( mbd . isSingleton (  )  )     {", "registerDisposableBean ( beanName ,    new   DisposableBeanAdapter ( bean ,    beanName ,    mbd ,    gePostProcessors (  )  ,    acc )  )  ;", "} else    {", "Scope   scope    =    this . scopes . get ( mbd . getScope (  )  )  ;", "if    ( scope    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   Scope   registered   for   scope   name    '  \"     +     ( mbd . getScope (  )  )  )     +     \"  '  \"  )  )  ;", "}", "scope . registerDestructionCallback ( beanName ,    new   DisposableBeanAdapter ( bean ,    beanName ,    mbd ,    gePostProcessors (  )  ,    acc )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerDisposableBeanIfNecessary"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . alreadyCreated . contains ( beanName )  )  )     {", "removeSingleton ( beanName )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["removeSingletonIfCreatedForTypeCheckOnly"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bean . getClass (  )  )     !  =     ( NullBean . class )  )     &  &     (  ( DisposableBeanAdapter . hasDestroyMethod ( bean ,    mbd )  )     |  |     (  ( hasDestructionAwareBeanPostProcessors (  )  )     &  &     ( DisposableBeanAdapter . hasApplicableProcessors ( bean ,    getBeanPostProcessors (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["requiresDestruction"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( mbd . hasBeanClass (  )  )     {", "return   mbd . geClass (  )  ;", "}", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedExceptionAction < Class <  ?  >  >  )     (  (  )     -  >    doResolveBeanClass ( mbd ,    typesToMatch )  )  )  ,    getAccessControlContext (  )  )  ;", "} else    {", "return   doResolveBeanClass ( mbd ,    typesToMatch )  ;", "}", "}    catch    ( PrivilegedActionException   pae )     {", "ClassNotFoundException   ex    =     (  ( ClassNotFoundException )     ( pae . getException (  )  )  )  ;", "throw   new   CannotLoadBeanClassException ( mbd . getResourceDescription (  )  ,    beanName ,    mbd . geClassName (  )  ,    ex )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   CannotLoadBeanClassException ( mbd . getResourceDescription (  )  ,    beanName ,    mbd . geClassName (  )  ,    ex )  ;", "}    catch    ( LinkageError   err )     {", "throw   new   CannotLoadBeanClassException ( mbd . getResourceDescription (  )  ,    beanName ,    mbd . geClassName (  )  ,    err )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveBeanClass"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . securityContextProvider    =    securityProvider ;", "}", "METHOD_END"], "methodName": ["setSecurityContextProvider"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   canonicalName ( BeanFactoryUtils . transformedBeanName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["transformedBeanName"], "fileName": "org.springframework.beans.factory.support.AbstractBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . typeName ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.springframework.beans.factory.support.AutowireCandidateQualifier"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getLazyResolutionProxyIfNecessary"], "fileName": "org.springframework.beans.factory.support.AutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getSuggestedValue"], "fileName": "org.springframework.beans.factory.support.AutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "return   bdHolder . getBeanDefinition (  )  . isAutowireCandidate (  )  ;", "}", "METHOD_END"], "methodName": ["isAutowireCandidate"], "fileName": "org.springframework.beans.factory.support.AutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "return   descriptor . isRequired (  )  ;", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.springframework.beans.factory.support.AutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "Method   wm    =    pd . getWriteMethod (  )  ;", "if    ( wm    =  =    null )     {", "return   false ;", "}", "if    (  !  ( wm . getDeclaringClass (  )  . getName (  )  . contains (  \"  $  $  \"  )  )  )     {", "return   false ;", "}", "Class <  ?  >    superclass    =    wm . getDeclaringClass (  )  . getSuperclass (  )  ;", "return    !  ( Class . hasMethod ( superclass ,    wm . getName (  )  ,    wm . getParameterTypes (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isExcludedFromDependencyCheck"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "Method   setter    =    pd . getWriteMethod (  )  ;", "if    ( setter    !  =    null )     {", "Class <  ?  >    targetClass    =    setter . getDeclaringClass (  )  ;", "for    ( Class <  ?  >    ifc    :    interfaces )     {", "if    (  ( ifc . isAssignableFrom ( targetClass )  )     &  &     ( Class . hasMethod ( ifc ,    setter . getName (  )  ,    setter . getParameterTypes (  )  )  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isSetterDefinedInInterface"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( autowiringValue   instanceof   ObjectFactory )     &  &     (  !  ( requiredType . isInstance ( autowiringValue )  )  )  )     {", "ObjectFactory <  ?  >    factory    =     (  ( ObjectFactory <  ?  >  )     ( autowiringValue )  )  ;", "if    (  ( autowiringValue   instanceof   Serializable )     &  &     ( requiredType . isInterface (  )  )  )     {", "autowiringValue    =    Proxy . newProxyInstance ( requiredType . getClassLoader (  )  ,    new   Class <  ?  >  [  ]  {    requiredType    }  ,    new    . ObjectFactoryDelegatingInvocationHandler ( factory )  )  ;", "} else    {", "return   factory . getObject (  )  ;", "}", "}", "return   autowiringValue ;", "}", "METHOD_END"], "methodName": ["resolveAutowiringValue"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( method ,     \" Method   must   not   be   null \"  )  ;", "Assert . notNull ( args ,     \" Argument   array   must   not   be   null \"  )  ;", "TypeVariable < Method >  [  ]    declaredTypeVariables    =    method . getTypeParameters (  )  ;", "Type   genericReturnType    =    method . getGenericReturnType (  )  ;", "Type [  ]    methodParameterTypes    =    method . getGenericParameterTypes (  )  ;", "Assert . isTrue (  (  ( args . length )     =  =     ( methodParameterTypes . length )  )  ,     \" Argument   array   does   not   match   parameter   count \"  )  ;", "boolean   locallyDeclaredTypeVariableMatchesReturnType    =    false ;", "for    ( TypeVariable < Method >    currentTypeVariable    :    declaredTypeVariables )     {", "if    ( currentTypeVariable . equals ( genericReturnType )  )     {", "locallyDeclaredTypeVariableMatchesReturnType    =    true ;", "break ;", "}", "}", "if    ( locallyDeclaredTypeVariableMatchesReturnType )     {", "for    ( int   i    =     0  ;    i    <     ( methodParameterTypes . length )  ;    i +  +  )     {", "Type   methodParameterType    =    methodParameterTypes [ i ]  ;", "Object   arg    =    args [ i ]  ;", "if    ( methodParameterType . equals ( genericReturnType )  )     {", "if    ( arg   instanceof   TypedStringValue )     {", "TypedStringValue   typedValue    =     (  ( TypedStringValue )     ( arg )  )  ;", "if    ( typedValue . hasTargetType (  )  )     {", "return   typedValue . getTargetType (  )  ;", "}", "try    {", "Class <  ?  >    resolvedType    =    typedValue . resolveTargetType ( classLoader )  ;", "if    ( resolvedType    !  =    null )     {", "return   resolvedType ;", "}", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Failed   to   resolve   value   type    [  \"     +     ( typedValue . getTargetTypeName (  )  )  )     +     \"  ]    for   factory   method   argument \"  )  ,    ex )  ;", "}", "} else", "if    (  ( arg    !  =    null )     &  &     (  !  ( arg   instanceof   BeanMetadataElement )  )  )     {", "return   arg . getClass (  )  ;", "}", "return   method . getReturnType (  )  ;", "} else", "if    ( methodParameterType   instanceof   ParameterizedType )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( methodParameterType )  )  ;", "Type [  ]    actualTypeArguments    =    parameterizedType . getActualTypeArguments (  )  ;", "for    ( Type   typeArg    :    actualTypeArguments )     {", "if    ( typeArg . equals ( genericReturnType )  )     {", "if    ( arg   instanceof   Class )     {", "return    (  ( Class <  ?  >  )     ( arg )  )  ;", "} else    {", "String   className    =    null ;", "if    ( arg   instanceof   String )     {", "className    =     (  ( String )     ( arg )  )  ;", "} else", "if    ( arg   instanceof   TypedStringValue )     {", "TypedStringValue   typedValue    =     (  ( TypedStringValue )     ( arg )  )  ;", "String   targetTypeName    =    typedValue . getTargetTypeName (  )  ;", "if    (  ( targetTypeName    =  =    null )     |  |     ( Class . class . getName (  )  . equals ( targetTypeName )  )  )     {", "className    =    typedValue . getValue (  )  ;", "}", "}", "if    ( className    !  =    null )     {", "try    {", "return   forName ( className ,    classLoader )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Could   not   resolve   class   name    [  \"     +    arg )     +     \"  ]    for   factory   method   argument \"  )  ,    ex )  ;", "}", "}", "return   method . getReturnType (  )  ;", "}", "}", "}", "}", "}", "}", "return   method . getReturnType (  )  ;", "}", "METHOD_END"], "methodName": ["resolveReturnTypeForFactoryMethod"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( constructors ,     (    c 1  ,    c 2  )     -  >     {", "boolean   p 1     =    Modifier . isPublic ( c 1  . getModifiers (  )  )  ;", "boolean   p 2     =    Modifier . isPublic ( c 2  . getModifiers (  )  )  ;", "if    ( p 1     !  =    p 2  )     {", "return   p 1     ?     -  1     :     1  ;", "}", "int   c 1 pl    =    c 1  . getParameterCount (  )  ;", "int   c 2 pl    =    c 2  . getParameterCount (  )  ;", "return   c 1 pl    <    c 2 pl    ?     1     :    c 1 pl    >    c 2 pl    ?     -  1     :     0  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["sortConstructors"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "Arrays . sort ( factoryMethods ,     (    fm 1  ,    fm 2  )     -  >     {", "boolean   p 1     =    Modifier . isPublic ( fm 1  . getModifiers (  )  )  ;", "boolean   p 2     =    Modifier . isPublic ( fm 2  . getModifiers (  )  )  ;", "if    ( p 1     !  =    p 2  )     {", "return   p 1     ?     -  1     :     1  ;", "}", "int   c 1 pl    =    fm 1  . getParameterCount (  )  ;", "int   c 2 pl    =    fm 2  . getParameterCount (  )  ;", "return   c 1 pl    <    c 2 pl    ?     1     :    c 1 pl    >    c 2 pl    ?     -  1     :     0  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["sortFactoryMethods"], "fileName": "org.springframework.beans.factory.support.AutowireUtils"}, {"methodBody": ["METHOD_START", "{", "Method   notParameterized    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" notParameterized \"  )  ;", "assertEquals ( String . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( notParameterized ,    new   Object [  ]  {        }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   notParameterizedWithArguments    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" notParameterizedWithArguments \"  ,    Integer . class ,    Boolean . class )  ;", "assertEquals ( String . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( notParameterizedWithArguments ,    new   Object [  ]  {     9  9  ,    true    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createProxy    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createProxy \"  ,    Object . class )  ;", "assertEquals ( String . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createProxy ,    new   Object [  ]  {     \" foo \"     }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createNamedProxyWithDifferentTypes    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createNamedProxy \"  ,    String . class ,    Object . class )  ;", "assertEquals ( Long . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createNamedProxyWithDifferentTypes ,    new   Object [  ]  {     \" enigma \"  ,     9  9 L    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createNamedProxyWithDuplicateTypes    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createNamedProxy \"  ,    String . class ,    Object . class )  ;", "assertEquals ( String . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createNamedProxyWithDuplicateTypes ,    new   Object [  ]  {     \" enigma \"  ,     \" foo \"     }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createMock    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createMock \"  ,    Class . class )  ;", "assertEquals ( Runnable . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createMock ,    new   Object [  ]  {    Runnable . class    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "assertEquals ( Runnable . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createMock ,    new   Object [  ]  {    Runnable . class . getName (  )     }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createNamedMock    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createNamedMock \"  ,    String . class ,    Class . class )  ;", "assertEquals ( Runnable . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createNamedMock ,    new   Object [  ]  {     \" foo \"  ,    Runnable . class    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   createVMock    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" createVMock \"  ,    Object . class ,    Class . class )  ;", "assertEquals ( Runnable . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( createVMock ,    new   Object [  ]  {     \" foo \"  ,    Runnable . class    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Method   extractValueFrom    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" extractValueFrom \"  ,    AutowireUtilsTests . MyInterfaceType . class )  ;", "assertEquals ( Object . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( extractValueFrom ,    new   Object [  ]  {    new   AutowireUtilsTests . MySimpleInterfaceType (  )     }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "Map < Integer ,    Boolean >    map    =    new   HashMap <  >  (  )  ;", "map . put (  0  ,    false )  ;", "map . put (  1  ,    true )  ;", "Method   extractMagicValue    =    ReflectionUtils . findMethod ( AutowireUtilsTests . MyTypeWithMethods . class ,     \" extractMagicValue \"  ,    Map . class )  ;", "assertEquals ( Object . class ,    AutowireUtils . resolveReturnTypeForFactoryMethod ( extractMagicValue ,    new   Object [  ]  {    map    }  ,    getClass (  )  . getClassLoader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["genericMethodReturnTypes"], "fileName": "org.springframework.beans.factory.support.AutowireUtilsTests"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  (  ( this . constructorArgIndex )  +  +  )  ,    new   RuntimeBeanReference ( beanName )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addConstructorArgReference"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  (  ( this . constructorArgIndex )  +  +  )  ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addConstructorArgValue"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanDefinition . getDependsOn (  )  )     =  =    null )     {", "this . beanDefinition . setDependsOn ( beanName )  ;", "} else    {", "String [  ]    added    =    ObjectUtils . addObjectToArray ( this . beanDefinition . getDependsOn (  )  ,    beanName )  ;", "this . beanDefinition . setDependsOn ( added )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["addDependsOn"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . getPropertyValues (  )  . add ( name ,    new   RuntimeBeanReference ( beanName )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addPropertyReference"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . getPropertyValues (  )  . add ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addPropertyValue"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( BeanDefinitionCustomizer   customizer    :    customizers )     {", "customizer . customize ( beanDefinition )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["applyCustomizers"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanDefinitionBuilder ( new   ChildBeanDefinition ( parentName )  )  ;", "}", "METHOD_END"], "methodName": ["childBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanDefinitionBuilder ( new   GenericBeanDefinition (  )  )  ;", "}", "METHOD_END"], "methodName": ["genericBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    new   BeanDefinitionBuilder ( new   GenericBeanDefinition (  )  )  ;", "builder . beanDefinition . setBeanClass ( beanClass )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["genericBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    new   BeanDefinitionBuilder ( new   GenericBeanDefinition (  )  )  ;", "builder . beanDefinition . setBeanClass ( beanClass )  ;", "builder . beanDefinition . setInstanceSupplier ( instanceSupplier )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["genericBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    new   BeanDefinitionBuilder ( new   GenericBeanDefinition (  )  )  ;", "builder . beanDefinition . setBeanClassName ( beanClassName )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["genericBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . validate (  )  ;", "return   this . beanDefinition ;", "}", "METHOD_END"], "methodName": ["getBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . beanDefinition ;", "}", "METHOD_END"], "methodName": ["getRawBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionBuilder . rootBeanDefinition ( beanClass ,    null )  ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    new   BeanDefinitionBuilder ( new   RootBeanDefinition (  )  )  ;", "builder . beanDefinition . setBeanClass ( beanClass )  ;", "builder . beanDefinition . setFactoryMethodName ( factoryMethodName )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionBuilder . rootBeanDefinition ( beanClassName ,    null )  ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   builder    =    new   BeanDefinitionBuilder ( new   RootBeanDefinition (  )  )  ;", "builder . beanDefinition . setBeanClassName ( beanClassName )  ;", "builder . beanDefinition . setFactoryMethodName ( factoryMethodName )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setAbstract ( flag )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAbstract"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "beanDefinition . setAutowireMode ( autowireMode )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setAutowireMode"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "beanDefinition . setDependencyCheck ( dependencyCheck )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDependencyCheck"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setDestroyMethodName ( methodName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDestroyMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setFactoryMethodName ( factoryMethod )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setFactoryMethodName ( factoryMethod )  ;", "this . beanDefinition . setFactoryBeanName ( factoryBean )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFactoryMethodOnBean"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setInitMethodName ( methodName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setInitMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setLazyInit ( lazy )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setLazyInit"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setParentName ( parentName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setParentName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setRole ( role )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRole"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . beanDefinition . setScope ( scope )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScope"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilder"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   bdb    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class . getName (  )  )  ;", "RootBeanDefinition   rbd    =     (  ( RootBeanDefinition )     ( bdb . getBeanDefinition (  )  )  )  ;", "assertFalse ( rbd . hasBeanClass (  )  )  ;", "assertEquals ( TestBean . class . getName (  )  ,    rbd . getBeanClassName (  )  )  ;", "}", "METHOD_END"], "methodName": ["beanClassName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilderTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   bdb    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class . getName (  )  ,     \" create \"  )  ;", "RootBeanDefinition   rbd    =     (  ( RootBeanDefinition )     ( bdb . getBeanDefinition (  )  )  )  ;", "assertFalse ( rbd . hasBeanClass (  )  )  ;", "assertEquals ( TestBean . class . getName (  )  ,    rbd . getBeanClassName (  )  )  ;", "assertEquals (  \" create \"  ,    rbd . getFactoryMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["beanClassNameWithFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilderTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionBuilder   bdb    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class ,     \" create \"  )  ;", "RootBeanDefinition   rbd    =     (  ( RootBeanDefinition )     ( bdb . getBeanDefinition (  )  )  )  ;", "assertTrue ( rbd . hasBeanClass (  )  )  ;", "assertEquals ( TestBean . class ,    rbd . getBeanClass (  )  )  ;", "assertEquals (  \" create \"  ,    rbd . getFactoryMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["beanClassWithFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilderTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    dependsOn    =    new   String [  ]  {     \" A \"  ,     \" B \"  ,     \" C \"     }  ;", "bdb    =     . rootBeanDefinition ( TestBean . class )  ;", "bdb . setScope ( BeanDefinition . SCOPE _ PROTOTYPE )  ;", "bdb . addPropertyReference (  \" age \"  ,     \"  1  5  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( dependsOn . length )  ;    i +  +  )     {", "bdb . addDependsOn ( dependsOn [ i ]  )  ;", "}", "RootBeanDefinition   rbd    =     (  ( RootBeanDefinition )     ( bdb . getBeanDefinition (  )  )  )  ;", "assertFalse ( rbd . isSingleton (  )  )  ;", "assertEquals ( TestBean . class ,    rbd . getBeanClass (  )  )  ;", "assertTrue (  \" Depends   on   was   added \"  ,    Arrays . equals ( dependsOn ,    rbd . getDependsOn (  )  )  )  ;", "assertTrue ( rbd . getPropertyValues (  )  . contains (  \" age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["beanClassWithSimpleProperty"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionBuilderTests"}, {"methodBody": ["METHOD_START", "{", "return   this . autowireMode ;", "}", "METHOD_END"], "methodName": ["getAutowireMode"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "return   this . dependencyCheck ;", "}", "METHOD_END"], "methodName": ["getDependencyCheck"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "return   this . destroyMethodName ;", "}", "METHOD_END"], "methodName": ["getDestroyMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "return   this . initMethodName ;", "}", "METHOD_END"], "methodName": ["getInitMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "return   this . lazyInit ;", "}", "METHOD_END"], "methodName": ["isLazyInit"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "this . autowireMode    =    autowireMode ;", "}", "METHOD_END"], "methodName": ["setAutowireMode"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "this . dependencyCheck    =    dependencyCheck ;", "}", "METHOD_END"], "methodName": ["setDependencyCheck"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethodName    =     ( StringUtils . hasText ( destroyMethodName )  )     ?    destroyMethodName    :    null ;", "}", "METHOD_END"], "methodName": ["setDestroyMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "this . initMethodName    =     ( StringUtils . hasText ( initMethodName )  )     ?    initMethodName    :    null ;", "}", "METHOD_END"], "methodName": ["setInitMethodName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "this . lazyInit    =    lazyInit ;", "}", "METHOD_END"], "methodName": ["setLazyInit"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionDefaults"}, {"methodBody": ["METHOD_START", "{", "GenericBeanDefinition   bd    =    new   GenericBeanDefinition (  )  ;", "bd . setParentName ( parentName )  ;", "if    ( className    !  =    null )     {", "if    ( classLoader    !  =    null )     {", "bd . setBeanClass ( ClassUtils . forName ( className ,    classLoader )  )  ;", "} else    {", "bd . setBeanClassName ( className )  ;", "}", "}", "return   bd ;", "}", "METHOD_END"], "methodName": ["createBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionReaderUtils"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionReaderUtils . generateBeanName ( beanDefinition ,    registry ,    false )  ;", "}", "METHOD_END"], "methodName": ["generateBeanName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionReaderUtils"}, {"methodBody": ["METHOD_START", "{", "String   generatedBeanName    =    definition . getBeanClassName (  )  ;", "if    ( generatedBeanName    =  =    null )     {", "if    (  ( definition . getParentName (  )  )     !  =    null )     {", "generatedBeanName    =     ( definition . getParentName (  )  )     +     \"  $ child \"  ;", "} else", "if    (  ( definition . getFactoryBeanName (  )  )     !  =    null )     {", "generatedBeanName    =     ( definition . getFactoryBeanName (  )  )     +     \"  $ created \"  ;", "}", "}", "if    (  !  ( StringUtils . hasText ( generatedBeanName )  )  )     {", "throw   new   BeanDefinitionStoreException (  (  \" Unnamed   bean   definition   specifies   neither    \"     +     \"  ' class '    nor    ' parent '    nor    ' factory - bean '     -    can ' t   generate   bean   name \"  )  )  ;", "}", "String   id    =    generatedBeanName ;", "if    ( isInnerBean )     {", "id    =     ( generatedBeanName    +     (  . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +     ( ObjectUtils . getIdentityHexString ( definition )  )  ;", "} else    {", "int   counter    =     -  1  ;", "while    (  ( counter    =  =     (  -  1  )  )     |  |     ( registry . containsBeanDefinition ( id )  )  )     {", "counter +  +  ;", "id    =     ( generatedBeanName    +     (  . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +    counter ;", "}", "}", "return   id ;", "}", "METHOD_END"], "methodName": ["generateBeanName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionReaderUtils"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =    definitionHolder . getBeanName (  )  ;", "registry . register ( beanName ,    definitionHolder . get (  )  )  ;", "String [  ]    aliases    =    definitionHolder . getAliases (  )  ;", "if    ( aliases    !  =    null )     {", "for    ( String   alias    :    aliases )     {", "registry . registerAlias ( beanName ,    alias )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionReaderUtils"}, {"methodBody": ["METHOD_START", "{", "String   generatedName    =    BeanDefinitionReaderUtils . generateBeanName ( definition ,    registry ,    false )  ;", "registry . registerBeanDefinition ( generatedName ,    definition )  ;", "return   generatedName ;", "}", "METHOD_END"], "methodName": ["registerWithGeneratedName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionReaderUtils"}, {"methodBody": ["METHOD_START", "{", "return   this . beanDefinition ;", "}", "METHOD_END"], "methodName": ["getBeanDefinition"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionResource"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setAbstract ( true )  ;", "bd . setLazyInit ( true )  ;", "bd . setScope (  \" request \"  )  ;", "RootBeanDefinition   otherBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . setAbstract ( true )  ;", "otherBd . setLazyInit ( true )  ;", "otherBd . setScope (  \" request \"  )  ;", "assertTrue ( bd . equals ( otherBd )  )  ;", "assertTrue ( otherBd . equals ( bd )  )  ;", "assertTrue (  (  ( bd . hashCode (  )  )     =  =     ( otherBd . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionEquality"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test \"  )  ;", "bd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  )  ;", "RootBeanDefinition   otherBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "otherBd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test \"  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  9  )  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  )  ;", "assertTrue ( bd . equals ( otherBd )  )  ;", "assertTrue ( otherBd . equals ( bd )  )  ;", "assertTrue (  (  ( bd . hashCode (  )  )     =  =     ( otherBd . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionEqualityWithConstructorArguments"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getPropertyValues (  )  . add (  \" name \"  ,     \" myName \"  )  ;", "bd . getPropertyValues (  )  . add (  \" age \"  ,     \"  9  9  \"  )  ;", "RootBeanDefinition   otherBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "otherBd . getPropertyValues (  )  . add (  \" name \"  ,     \" myName \"  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getPropertyValues (  )  . add (  \" age \"  ,     \"  1  1  \"  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getPropertyValues (  )  . add (  \" age \"  ,     \"  9  9  \"  )  ;", "assertTrue ( bd . equals ( otherBd )  )  ;", "assertTrue ( otherBd . equals ( bd )  )  ;", "assertTrue (  (  ( bd . hashCode (  )  )     =  =     ( otherBd . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionEqualityWithPropertyValues"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test \"  ,     \" int \"  )  ;", "bd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  ,     \" long \"  )  ;", "RootBeanDefinition   otherBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "otherBd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test \"  ,     \" int \"  )  ;", "otherBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  ,     \" int \"  )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  ,     \" long \"  )  ;", "assertTrue ( bd . equals ( otherBd )  )  ;", "assertTrue ( otherBd . equals ( bd )  )  ;", "assertTrue (  (  ( bd . hashCode (  )  )     =  =     ( otherBd . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionEqualityWithTypedConstructorArguments"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . setAbstract ( true )  ;", "bd . setLazyInit ( true )  ;", "bd . setScope (  \" request \"  )  ;", "BeanDefinitionHolder   holder    =    new   BeanDefinitionHolder ( bd ,     \" bd \"  )  ;", "RootBeanDefinition   otherBd    =    new   RootBeanDefinition ( TestBean . class )  ;", "assertTrue (  (  !  ( bd . equals ( otherBd )  )  )  )  ;", "assertTrue (  (  !  ( otherBd . equals ( bd )  )  )  )  ;", "otherBd . setAbstract ( true )  ;", "otherBd . setLazyInit ( true )  ;", "otherBd . setScope (  \" request \"  )  ;", "BeanDefinitionHolder   otherHolder    =    new   BeanDefinitionHolder ( bd ,     \" bd \"  )  ;", "assertTrue ( holder . equals ( otherHolder )  )  ;", "assertTrue ( otherHolder . equals ( holder )  )  ;", "assertTrue (  (  ( holder . hashCode (  )  )     =  =     ( otherHolder . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionHolderEquality"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   bd    =    new   RootBeanDefinition ( TestBean . class )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" test \"  )  ;", "bd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  1  ,    new   Integer (  5  )  )  ;", "bd . getPropertyValues (  )  . add (  \" name \"  ,     \" myName \"  )  ;", "bd . getPropertyValues (  )  . add (  \" age \"  ,     \"  9  9  \"  )  ;", "bd . setQualifiedElement ( getClass (  )  )  ;", "GenericBeanDefinition   childBd    =    new   GenericBeanDefinition (  )  ;", "childBd . setParentName (  \" bd \"  )  ;", "RootBeanDefinition   mergedBd    =    new   RootBeanDefinition ( bd )  ;", "mergedBd . overrideFrom ( childBd )  ;", "assertEquals (  2  ,    mergedBd . getConstructorArgumentValues (  )  . getArgumentCount (  )  )  ;", "assertEquals (  2  ,    mergedBd . getPropertyValues (  )  . size (  )  )  ;", "assertEquals ( bd ,    mergedBd )  ;", "mergedBd . getConstructorArgumentValues (  )  . getArgumentValue (  1  ,    null )  . setValue ( new   Integer (  9  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    bd . getConstructorArgumentValues (  )  . getArgumentValue (  1  ,    null )  . getValue (  )  )  ;", "assertEquals ( getClass (  )  ,    bd . getQualifiedElement (  )  )  ;", "}", "METHOD_END"], "methodName": ["beanDefinitionMerging"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "String   actualInnerBeanName    =    innerBeanName ;", "int   counter    =     0  ;", "while    ( this . beanFisBeanNameInUse ( actualInnerBeanName )  )     {", "counter +  +  ;", "actualInnerBeanName    =     ( innerBeanName    +     ( BeanFtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +    counter ;", "}", "return   actualInnerBeanName ;", "}", "METHOD_END"], "methodName": ["adaptInnerBeanName"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory . evaluateBeanDefinitionString ( value ,    this . beanDefinition )  ;", "}", "METHOD_END"], "methodName": ["doEvaluate"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   String )     {", "return   doEvaluate (  (  ( String )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   String [  ]  )     {", "String [  ]    values    =     (  ( String [  ]  )     ( value )  )  ;", "boolean   actuallyd    =    false ;", "Object [  ]    resolvedValues    =    new   Object [ values . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "String   originalValue    =    values [ i ]  ;", "Object   resolvedValue    =    doEvaluate ( originalValue )  ;", "if    ( resolvedValue    !  =    originalValue )     {", "actuallyd    =    true ;", "}", "resolvedValues [ i ]     =    resolvedValue ;", "}", "return   actuallyd    ?    resolvedValues    :    values ;", "} else    {", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "Object   result    =    doEvaluate ( value . getValue (  )  )  ;", "if    (  !  ( ObjectUtils . nullSafeEquals ( result ,    value . getValue (  )  )  )  )     {", "value . setDynamic (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   mbd    =    null ;", "try    {", "mbd    =    this . beanFactory . getMergedBeanDefinition ( innerBeanName ,    innerBd ,    this . beanDefinition )  ;", "String   actualInnerBeanName    =    innerBeanName ;", "if    ( mbd . isSingleton (  )  )     {", "actualInnerBeanName    =    adaptInnerBeanName ( innerBeanName )  ;", "}", "this . beanFactory . registerContainedBean ( actualInnerBeanName ,    this . beanName )  ;", "String [  ]    dependsOn    =    mbd . getDependsOn (  )  ;", "if    ( dependsOn    !  =    null )     {", "for    ( String   dependsOnBean    :    dependsOn )     {", "this . beanFactory . registerDependentBean ( dependsOnBean ,    actualInnerBeanName )  ;", "this . beanFactory . getBean ( dependsOnBean )  ;", "}", "}", "Object   innerBean    =    this . beanFactory . createBean ( actualInnerBeanName ,    mbd ,    null )  ;", "if    ( innerBean   instanceof   FactoryBean )     {", "boolean   synthetic    =    mbd . isSynthetic (  )  ;", "innerBean    =    this . beanFactory . getObjectFromFactoryBean (  (  ( FactoryBean <  ?  >  )     ( innerBean )  )  ,    actualInnerBeanName ,     (  ! synthetic )  )  ;", "}", "if    ( innerBean   instanceof   NullBean )     {", "innerBean    =    null ;", "}", "return   innerBean ;", "}    catch    ( BeansException   ex )     {", "throw   new   BeanCreationException ( this . beanDefinition . getResourceDescription (  )  ,    this . beanName ,     (  (  (  (  (  \" Cannot   create   inner   bean    '  \"     +    innerBeanName )     +     \"  '     \"  )     +     (  ( mbd    !  =    null )     &  &     (  ( mbd . getBeanClassName (  )  )     !  =    null )     ?     (  \" of   type    [  \"     +     ( mbd . getBeanClassName (  )  )  )     +     \"  ]     \"     :     \"  \"  )  )     +     \" while   setting    \"  )     +    argName )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveInnerBean"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "Object   resolved    =    Array . newInstance ( elementType ,    ml . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( ml . size (  )  )  ;    i +  +  )     {", "Array . set ( resolved ,    i ,    resolveValueIfNecessary ( new    . KeyedArgName ( argName ,    i )  ,    ml . get ( i )  )  )  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["resolveManagedArray"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "List < Object >    resolved    =    new   ArrayList <  >  ( ml . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( ml . size (  )  )  ;    i +  +  )     {", "resolved . add ( resolveValueIfNecessary ( new    . KeyedArgName ( argName ,    i )  ,    ml . get ( i )  )  )  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["resolveManagedList"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "Map < Object ,    Object >    resolved    =    new   LinkedHashMap <  >  ( mm . size (  )  )  ;", "mm . forEach (  (    key ,    value )     -  >     {", "Object   resolvedKey    =    resolveValueIfNecessary ( argName ,    key )  ;", "Object   resolvedValue    =    resolveValueIfNecessary ( new    . KeyedArgName ( argName ,    key )  ,    value )  ;", "resolved . put ( resolvedKey ,    resolvedValue )  ;", "}  )  ;", "return   resolved ;", "}", "METHOD_END"], "methodName": ["resolveManagedMap"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "Set < Object >    resolved    =    new   LinkedHashSet <  >  ( ms . size (  )  )  ;", "int   i    =     0  ;", "for    ( Object   m    :    ms )     {", "resolved . add ( resolveValueIfNecessary ( new    . KeyedArgName ( argName ,    i )  ,    m )  )  ;", "i +  +  ;", "}", "return   resolved ;", "}", "METHOD_END"], "methodName": ["resolveManagedSet"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   bean ;", "String   refName    =    ref . getBeanName (  )  ;", "refName    =    String . valueOf ( doEvaluate ( refName )  )  ;", "if    ( ref . isToParent (  )  )     {", "if    (  ( this . beanFactory . getParentBeanFactory (  )  )     =  =    null )     {", "throw   new   BeanCreationException ( this . b . getResourceDescription (  )  ,    this . beanName ,     (  (  \" Can ' t   resolve   reference   to   bean    '  \"     +    refName )     +     \"  '    in   parent   factory :    no   parent   factory   available \"  )  )  ;", "}", "bean    =    this . beanFactory . getParentBeanFactory (  )  . getBean ( refName )  ;", "} else    {", "bean    =    this . beanFactory . getBean ( refName )  ;", "this . beanFactory . registerDependentBean ( refName ,    this . beanName )  ;", "}", "if    ( bean   instanceof   NullBean )     {", "bean    =    null ;", "}", "return   bean ;", "}    catch    ( BeansException   ex )     {", "throw   new   BeanCreationException ( this . b . getResourceDescription (  )  ,    this . beanName ,     (  (  (  \" Cannot   resolve   reference   to   bean    '  \"     +     ( ref . getBeanName (  )  )  )     +     \"  '    while   setting    \"  )     +    argName )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveReference"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value . hasTargetType (  )  )     {", "return   value . getTargetType (  )  ;", "}", "return   value . resolveTargetType ( this . beanFgetBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveTargetType"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   RuntimeBeanReference )     {", "RuntimeBeanReference   ref    =     (  ( RuntimeBeanReference )     ( value )  )  ;", "return   resolveReference ( argName ,    ref )  ;", "} else", "if    ( value   instanceof   config . RuntimeBeanNameReference )     {", "String   refName    =     (  ( config . RuntimeBeanNameReference )     ( value )  )  . getBeanName (  )  ;", "refName    =    String . valueOf ( doEvaluate ( refName )  )  ;", "if    (  !  ( this . beanFactory . containsBean ( refName )  )  )     {", "throw   new   BeanDefinitionStoreException (  (  (  (  \" Invalid   bean   name    '  \"     +    refName )     +     \"  '    in   bean   reference   for    \"  )     +    argName )  )  ;", "}", "return   refName ;", "} else", "if    ( value   instanceof   config . BeanDefinitionHolder )     {", "config . BeanDefinitionHolder   bdHolder    =     (  ( config . BeanDefinitionHolder )     ( value )  )  ;", "return   resolveInnerBean ( argName ,    bdHolder . getBeanName (  )  ,    bdHolder . getBeanDefinition (  )  )  ;", "} else", "if    ( value   instanceof   config . BeanDefinition )     {", "config . BeanDefinition   bd    =     (  ( config . BeanDefinition )     ( value )  )  ;", "String   innerBeanName    =     (  \"  ( inner   bean )  \"     +     ( BeanFactoryUtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +     ( getIdentityHexString ( bd )  )  ;", "return   resolveInnerBean ( argName ,    innerBeanName ,    bd )  ;", "} else", "if    ( value   instanceof   ManagedArray )     {", "ManagedArray   array    =     (  ( ManagedArray )     ( value )  )  ;", "Class <  ?  >    elementType    =    array . resolvedElementType ;", "if    ( elementType    =  =    null )     {", "String   elementTypeName    =    array . getElementTypeName (  )  ;", "if    ( hasText ( elementTypeName )  )     {", "try    {", "elementType    =    forName ( elementTypeName ,    this . beanFactory . getBeanClassLoader (  )  )  ;", "array . resolvedElementType    =    elementType ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( this . beanDefinition . getResourceDescription (  )  ,    this . beanName ,     (  \" Error   resolving   array   type   for    \"     +    argName )  ,    ex )  ;", "}", "} else    {", "elementType    =    Object . class ;", "}", "}", "return   resolveManagedArray ( argName ,     (  ( List <  ?  >  )     ( value )  )  ,    elementType )  ;", "} else", "if    ( value   instanceof   ManagedList )     {", "return   resolveManagedList ( argName ,     (  ( List <  ?  >  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   ManagedSet )     {", "return   resolveManagedSet ( argName ,     (  ( Set <  ?  >  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   ManagedMap )     {", "return   resolveManagedMap ( argName ,     (  ( Map <  ?  ,     ?  >  )     ( value )  )  )  ;", "} else", "if    ( value   instanceof   ManagedProperties )     {", "Properties   original    =     (  ( Properties )     ( value )  )  ;", "Properties   copy    =    new   Properties (  )  ;", "original . forEach (  (    propKey ,    propValue )     -  >     {", "if    ( propKey   instanceof   config . TypedStringValue )     {", "propKey    =    evaluate (  (  ( config . TypedStringValue )     ( propKey )  )  )  ;", "}", "if    ( propValue   instanceof   config . TypedStringValue )     {", "propValue    =    evaluate (  (  ( config . TypedStringValue )     ( propValue )  )  )  ;", "}", "if    (  ( propKey    =  =    null )     |  |     ( propValue    =  =    null )  )     {", "throw   new   BeanCreationException ( this . beanDefinition . getResourceDescription (  )  ,    this . beanName ,     (  (  \" Error   converting   Properties   key / value   pair   for    \"     +    argName )     +     \"  :    resolved   to   null \"  )  )  ;", "}", "copy . put ( propKey ,    propValue )  ;", "}  )  ;", "return   copy ;", "} else", "if    ( value   instanceof   config . TypedStringValue )     {", "config . TypedStringValue   typedStringValue    =     (  ( config . TypedStringValue )     ( value )  )  ;", "Object   valueObject    =    evaluate ( typedStringValue )  ;", "try    {", "Class <  ?  >    resolvedTargetType    =    resolveTargetType ( typedStringValue )  ;", "if    ( resolvedTargetType    !  =    null )     {", "return   this . typeConverter . convertIfNecessary ( valueObject ,    resolvedTargetType )  ;", "} else    {", "return   valueObject ;", "}", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( this . beanDefinition . getResourceDescription (  )  ,    this . beanName ,     (  \" Error   converting   typed   String   value   for    \"     +    argName )  ,    ex )  ;", "}", "} else", "if    ( value   instanceof   NullBean )     {", "return   null ;", "} else    {", "return   evaluate ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveValueIfNecessary"], "fileName": "org.springframework.beans.factory.support.BeanDefinitionValueResolver"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Runnable . class )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addIndexedArgumentValue (  0  ,    Runnable . class )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethodWithIndexedArgument"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" x \"  )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertFalse ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertFalse ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertNull ( bf . getType (  \" mock \"  )  )  ;", "assertNull ( bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  0  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethodWithInvalidClassName"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Runnable . class . getName (  )  )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethodWithNonResolvedClassName"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setTempClassLoader ( new   OverridingClassLoader ( getClass (  )  . getClassLoader (  )  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . MocksControl . class )  ;", "bf . registerBeanDefinition (  \" mocksControl \"  ,    rbd )  ;", "rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setFactoryBeanName (  \" mocksControl \"  )  ;", "rbd . setFactoryMethodName (  \" createMock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Runnable . class )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethodWithTempClassLoader"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  )  ;", "rbd . setBeanClassName ( Mockito . class . getName (  )  )  ;", "rbd . setFactoryMethodName (  \" mock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( new   TypedStringValue ( Runnable . class . getName (  )  )  )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertTrue ( bf . isTypeMatch (  \" mock \"  ,    Runnable . class )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedInstanceFactoryMethodWithWrappedClassName"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( Mockito . class )  ;", "rbd . setFactoryMethodName (  \" mock \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Runnable . class )  ;", "DefaultListable   bf    =    new   DefaultListable (  )  ;", "bf . registerBeanDefinition (  \" mock \"  ,    rbd )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "assertEquals ( Runnable . class ,    bf . getType (  \" mock \"  )  )  ;", "Map < String ,    Runnable >    beans    =    bf . getBeansOfType ( Runnable . class )  ;", "assertEquals (  1  ,    beans . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedStaticFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( bf . getBean (  \" list \"  )  )  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( new   URL (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    list . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" listOfArrays \"  )  )  )  ;", "assertEquals (  1  ,    gb . getListOfArrays (  )  . size (  )  )  ;", "String [  ]    array    =    gb . getListOfArrays (  )  . get (  0  )  ;", "assertEquals (  2  ,    array . length )  ;", "assertEquals (  \" value 1  \"  ,    array [  0  ]  )  ;", "assertEquals (  \" value 2  \"  ,    array [  1  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListOfArraysProperty"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "List < String >    input    =    new   ArrayList <  >  (  )  ;", "input . add (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "input . add (  \" http :  /  / localhost :  9  0  9  0  \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" resourceList \"  ,    input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListProperty"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericIntegerBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericIntegerBean   gb    =     (  ( GenericIntegerBean )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListPropertyWithAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericIntegerBean . class )  ;", "List < Integer >    input    =    new   ArrayList <  >  (  )  ;", "input . add (  1  )  ;", "rbd . getPropertyValues (  )  . add (  \" testBeanList \"  ,    input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "try    {", "bf . getBean (  \" genericBean \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getMessage (  )  . contains (  \" genericBean \"  )  )     &  &     ( ex . getMessage (  )  . contains (  \" testBeanList [  0  ]  \"  )  )  )  )  ;", "assertTrue (  (  ( ex . getMessage (  )  . contains ( TestBean . class . getName (  )  )  )     &  &     ( ex . getMessage (  )  . contains (  \" Integer \"  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGenericListPropertyWithInvalidElementType"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertNull ( gb . getResourceList (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericListPropertyWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "Map <  ?  ,     ?  >    map    =     (  ( Map <  ?  ,     ?  >  )     ( bf . getBean (  \" map \"  )  )  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    map . keySet (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   URL (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    map . values (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  1  \"  ,     \"  0  \"  )  ;", "input . put (  \"  2  \"  ,     \"  3  \"  )  ;", "Map < String ,    String >    input 2     =    new   HashMap <  >  (  )  ;", "input 2  . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input 2  . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertNotSame ( gb . getPlainMap (  )  ,    gb . getShortMap (  )  )  ;", "assertEquals (  2  ,    gb . getPlainMap (  )  . size (  )  )  ;", "assertEquals (  \"  0  \"  ,    gb . getPlainMap (  )  . get (  \"  1  \"  )  )  ;", "assertEquals (  \"  3  \"  ,    gb . getPlainMap (  )  . get (  \"  2  \"  )  )  ;", "assertEquals (  2  ,    gb . getShortMap (  )  . size (  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapMapConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  1  \"  ,     \"  0  \"  )  ;", "input . put (  \"  2  \"  ,     \"  3  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertNotSame ( gb . getPlainMap (  )  ,    gb . getShortMap (  )  )  ;", "assertEquals (  2  ,    gb . getPlainMap (  )  . size (  )  )  ;", "assertEquals (  \"  0  \"  ,    gb . getPlainMap (  )  . get (  \"  1  \"  )  )  ;", "assertEquals (  \"  3  \"  ,    gb . getPlainMap (  )  . get (  \"  2  \"  )  )  ;", "assertEquals (  2  ,    gb . getShortMap (  )  . size (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  1  \"  )  )  )  ;", "assertEquals ( new   Integer (  3  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapMapConstructorWithSameRefAndConversion"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < Short ,    Integer >    input    =    new   HashMap <  >  (  )  ;", "input . put ( new   Short (  (  ( short )     (  1  )  )  )  ,    new   Integer (  0  )  )  ;", "input . put ( new   Short (  (  ( short )     (  2  )  )  )  ,    new   Integer (  3  )  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertSame ( gb . getPlainMap (  )  ,    gb . getShortMap (  )  )  ;", "assertEquals (  2  ,    gb . getShortMap (  )  . size (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  1  \"  )  )  )  ;", "assertEquals ( new   Integer (  3  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapMapConstructorWithSameRefAndNoConversion"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  1  \"  ,     \"  0  \"  )  ;", "input . put (  \"  2  \"  ,     \"  3  \"  )  ;", "Map < String ,    String >    input 2     =    new   HashMap <  >  (  )  ;", "input 2  . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input 2  . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals (  \"  0  \"  ,    gb . getPlainMap (  )  . get (  \"  1  \"  )  )  ;", "assertEquals (  \"  3  \"  ,    gb . getPlainMap (  )  . get (  \"  2  \"  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapMapFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" shortMap \"  ,    input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapProperty"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapResourceConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapResourceFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addPropertyEditorRegistrar ( new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "registry . registerCustomEditor ( Number . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "}", "}  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    AbstractCollection <  ?  >  >    input    =    new   HashMap <  >  (  )  ;", "HashSet < Integer >    value 1     =    new   HashSet <  >  (  )  ;", "value 1  . add ( new   Integer (  1  )  )  ;", "input . put (  \"  1  \"  ,    value 1  )  ;", "ArrayList < Boolean >    value 2     =    new   ArrayList <  >  (  )  ;", "value 2  . add ( Boolean . TRUE )  ;", "input . put (  \"  2  \"  ,    value 2  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Boolean . TRUE )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  1  )  )  )    instanceof   HashSet )  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  2  )  )  )    instanceof   ArrayList )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithCollectionValueConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . addPropertyEditorRegistrar ( new   PropertyEditorRegistrar (  )     {", "@ Override", "public   void   registerCustomEditors ( PropertyEditorRegistry   registry )     {", "registry . registerCustomEditor ( Number . class ,    new   CustomNumberEditor ( Integer . class ,    false )  )  ;", "}", "}  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Map < String ,    AbstractCollection <  ?  >  >    input    =    new   HashMap <  >  (  )  ;", "HashSet < Integer >    value 1     =    new   HashSet <  >  (  )  ;", "value 1  . add ( new   Integer (  1  )  )  ;", "input . put (  \"  1  \"  ,    value 1  )  ;", "ArrayList < Boolean >    value 2     =    new   ArrayList <  >  (  )  ;", "value 2  . add ( Boolean . TRUE )  ;", "input . put (  \"  2  \"  ,    value 2  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( Boolean . TRUE )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  1  )  )  )    instanceof   HashSet )  )  ;", "assertTrue (  (  ( gb . getCollectionMap (  )  . get ( new   Integer (  2  )  )  )    instanceof   ArrayList )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithCollectionValueFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals (  \"  5  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  4  \"  )  )  )  ;", "assertEquals (  \"  7  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithKeyTypeConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Map < String ,    String >    input    =    new   HashMap <  >  (  )  ;", "input . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertEquals (  \"  5  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  4  \"  )  )  )  ;", "assertEquals (  \"  7  \"  ,    gb . getLongMap (  )  . get ( new   Long (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMapWithKeyTypeFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   GenericTypeAwareAutowireCandidateResolver (  )  )  ;", "bf . registerBeanDefinition (  \" doubleStore \"  ,    new   RootBeanDefinition (  . NumberStore . class )  )  ;", "bf . registerBeanDefinition (  \" floatStore \"  ,    new   RootBeanDefinition (  . NumberStore . class )  )  ;", "bf . registerBeanDefinition (  \" numberBean \"  ,    new   RootBeanDefinition (  . NumberBean . class ,    RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR ,    false )  )  ;", ". NumberBean   nb    =    bf . getBean (  . NumberBean . class )  ;", "assertSame ( bf . getBean (  \" doubleStore \"  )  ,    nb . getDoubleStore (  )  )  ;", "assertSame ( bf . getBean (  \" floatStore \"  )  ,    nb . getFloatStore (  )  )  ;", "String [  ]    numberStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClass (  . NumberStore . class )  )  ;", "String [  ]    doubleStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . NumberStore . class ,    Double . class )  )  ;", "String [  ]    floatStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . NumberStore . class ,    Float . class )  )  ;", "assertEquals (  2  ,    numberStoreNames . length )  ;", "assertEquals (  \" doubleStore \"  ,    numberStoreNames [  0  ]  )  ;", "assertEquals (  \" floatStore \"  ,    numberStoreNames [  1  ]  )  ;", "assertEquals (  0  ,    doubleStoreNames . length )  ;", "assertEquals (  0  ,    floatStoreNames . length )  ;", "}", "METHOD_END"], "methodName": ["testGenericMatchingWithBeanNameDifferentiation"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . setAutowireCandidateResolver ( new   GenericTypeAwareAutowireCandidateResolver (  )  )  ;", "bf . registerBeanDefinition (  \" store 1  \"  ,    new   RootBeanDefinition (  . DoubleStore . class )  )  ;", "bf . registerBeanDefinition (  \" store 2  \"  ,    new   RootBeanDefinition (  . FloatStore . class )  )  ;", "bf . registerBeanDefinition (  \" numberBean \"  ,    new   RootBeanDefinition (  . NumberBean . class ,    RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR ,    false )  )  ;", ". NumberBean   nb    =    bf . getBean (  . NumberBean . class )  ;", "assertSame ( bf . getBean (  \" store 1  \"  )  ,    nb . getDoubleStore (  )  )  ;", "assertSame ( bf . getBean (  \" store 2  \"  )  ,    nb . getFloatStore (  )  )  ;", "String [  ]    numberStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClass (  . NumberStore . class )  )  ;", "String [  ]    doubleStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . NumberStore . class ,    Double . class )  )  ;", "String [  ]    floatStoreNames    =    bf . getBeanNamesForType ( ResolvableType . forClassWithGenerics (  . NumberStore . class ,    Float . class )  )  ;", "assertEquals (  2  ,    numberStoreNames . length )  ;", "assertEquals (  \" store 1  \"  ,    numberStoreNames [  0  ]  )  ;", "assertEquals (  \" store 2  \"  ,    numberStoreNames [  1  ]  )  ;", "assertEquals (  1  ,    doubleStoreNames . length )  ;", "assertEquals (  \" store 1  \"  ,    doubleStoreNames [  0  ]  )  ;", "assertEquals (  1  ,    floatStoreNames . length )  ;", "assertEquals (  \" store 2  \"  ,    floatStoreNames [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGenericMatchingWithFullTypeDifferentiation"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "Set <  ?  >    set    =     (  ( Set <  ?  >  )     ( bf . getBean (  \" set \"  )  )  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertEquals ( new   URL (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    set . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" integer 1  \"  ,    new   Integer (  4  )  )  ;", "bf . registerSingleton (  \" integer 2  \"  ,    new   Integer (  5  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetConstructorWithAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertNull ( gb . getIntegerSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetConstructorWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "List < String >    input 2     =    new   ArrayList <  >  (  )  ;", "input 2  . add (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "input 2  . add (  \" http :  /  / localhost :  9  0  9  0  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetListConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" integer 1  \"  ,    new   Integer (  4  )  )  ;", "bf . registerSingleton (  \" integer 2  \"  ,    new   Integer (  5  )  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetListConstructorWithAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerSingleton (  \" resource 1  \"  ,    new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  )  ;", "bf . registerSingleton (  \" resource 2  \"  ,    new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertNull ( gb . getIntegerSet (  )  )  ;", "assertNull ( gb . getResourceList (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetListConstructorWithOptionalAutowiring"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "List < String >    input 2     =    new   ArrayList <  >  (  )  ;", "input 2  . add (  \" http :  /  / localhost :  8  0  8  0  \"  )  ;", "input 2  . add (  \" http :  /  / localhost :  9  0  9  0  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  8  0  8  0  \"  )  ,    gb . getResourceList (  )  . get (  0  )  )  ;", "assertEquals ( new   UrlResource (  \" http :  /  / localhost :  9  0  9  0  \"  )  ,    gb . getResourceList (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetListFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "Map < String ,    String >    input 2     =    new   HashMap <  >  (  )  ;", "input 2  . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input 2  . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetMapConstructor"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "rbd . setFactoryMethodName (  \" createInstance \"  )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "Map < String ,    String >    input 2     =    new   HashMap <  >  (  )  ;", "input 2  . put (  \"  4  \"  ,     \"  5  \"  )  ;", "input 2  . put (  \"  6  \"  ,     \"  7  \"  )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input )  ;", "rbd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( input 2  )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "assertEquals ( new   Integer (  5  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  4  \"  )  )  )  ;", "assertEquals ( new   Integer (  7  )  ,    gb . getShortMap (  )  . get ( new   Short (  \"  6  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetMapFactoryMethod"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition ( GenericBean . class )  ;", "Set < String >    input    =    new   HashSet <  >  (  )  ;", "input . add (  \"  4  \"  )  ;", "input . add (  \"  5  \"  )  ;", "rbd . getPropertyValues (  )  . add (  \" integerSet \"  ,    input )  ;", "bf . registerBeanDefinition (  \" genericBean \"  ,    rbd )  ;", "GenericBean <  ?  >    gb    =     (  ( GenericBean <  ?  >  )     ( bf . getBean (  \" genericBean \"  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  4  )  )  )  ;", "assertTrue ( gb . getIntegerSet (  )  . contains ( new   Integer (  5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericSetProperty"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "GenericIntegerBean   gb    =     (  ( GenericIntegerBean )     ( bf . getBean (  \" integerBean \"  )  )  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    gb . getGenericProperty (  )  )  ;", "assertEquals ( new   Integer (  2  0  )  ,    gb . getGenericListProperty (  )  . get (  0  )  )  ;", "assertEquals ( new   Integer (  3  0  )  ,    gb . getGenericListProperty (  )  . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericallyTypedIntegerBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", "GenericSetOfIntegerBean   gb    =     (  ( GenericSetOfIntegerBean )     ( bf . getBean (  \" setOfIntegerBean \"  )  )  )  ;", "assertEquals ( new   Integer (  1  0  )  ,    gb . getGenericProperty (  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Integer (  2  0  )  ,    gb . getGenericListProperty (  )  . get (  0  )  . iterator (  )  . next (  )  )  ;", "assertEquals ( new   Integer (  3  0  )  ,    gb . getGenericListProperty (  )  . get (  1  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGenericallyTypedSetOfIntegerBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" genericBeanTests . xml \"  ,    getClass (  )  )  )  ;", ". UrlSet   us    =     (  (  . UrlSet )     ( bf . getBean (  \" setBean \"  )  )  )  ;", "assertEquals (  1  ,    us . size (  )  )  ;", "assertEquals ( new   URL (  \" http :  /  / www . springframework . org \"  )  ,    us . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetBean"], "fileName": "org.springframework.beans.factory.support.BeanFactoryGenericsTests"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperImpl   bw    =    new   BeanWrapperImpl (  )  ;", "this . beanFactory . initBeanWrapper ( bw )  ;", "Constructor <  ?  >    constructorToUse    =    null ;", ". ArgumentsHolder   argsHolderToUse    =    null ;", "Object [  ]    argsToUse    =    null ;", "if    ( explicitArgs    !  =    null )     {", "argsToUse    =    explicitArgs ;", "} else    {", "Object [  ]    argsToResolve    =    null ;", "synchronized ( mbd . constructorArgumentLock )     {", "constructorToUse    =     (  ( Constructor <  ?  >  )     ( mbd . resolvedConstructorOrFactoryMethod )  )  ;", "if    (  ( constructorToUse    !  =    null )     &  &     ( mbd . constructorArgumentsResolved )  )     {", "argsToUse    =    mbd . resolvedConstructorArguments ;", "if    ( argsToUse    =  =    null )     {", "argsToResolve    =    mbd . preparedConstructorArguments ;", "}", "}", "}", "if    ( argsToResolve    !  =    null )     {", "argsToUse    =    resolvePreparedArguments ( beanName ,    mbd ,    bw ,    constructorToUse ,    argsToResolve )  ;", "}", "}", "if    ( constructorToUse    =  =    null )     {", "boolean   autowiring    =     ( chosenCtors    !  =    null )     |  |     (  ( mbd . getResolvedAutowireMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  )  ;", "ConstructorArgumentValues   resolvedValues    =    null ;", "int   minNrOfArgs ;", "if    ( explicitArgs    !  =    null )     {", "minNrOfArgs    =    explicitArgs . length ;", "} else    {", "ConstructorArgumentValues   cargs    =    mbd . getConstructorArgumentValues (  )  ;", "resolvedValues    =    new   ConstructorArgumentValues (  )  ;", "minNrOfArgs    =    resolveConstructorArguments ( beanName ,    mbd ,    bw ,    cargs ,    resolvedValues )  ;", "}", "Constructor <  ?  >  [  ]    candidates    =    chosenCtors ;", "if    ( candidates    =  =    null )     {", "Class <  ?  >    beanClass    =    mbd . getBeanClass (  )  ;", "try    {", "candidates    =     ( mbd . isNonPublicAccessAllowed (  )  )     ?    beanClass . getDeclaredConstructors (  )     :    beanClass . getConstructors (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  \" Resolution   of   declared   constructors   on   bean   Class    [  \"     +     ( beanClass . getName (  )  )  )     +     \"  ]    from   ClassLoader    [  \"  )     +     ( beanClass . getClassLoader (  )  )  )     +     \"  ]    failed \"  )  ,    ex )  ;", "}", "}", "AutowireUtils . sortConstructors ( candidates )  ;", "int   minTypeDiffWeight    =    Integer . MAX _ VALUE ;", "Set < Constructor <  ?  >  >    ambiguousConstructors    =    null ;", "LinkedList < UnsatisfiedDependencyException >    causes    =    null ;", "for    ( Constructor <  ?  >    candidate    :    candidates )     {", "Class <  ?  >  [  ]    paramTypes    =    candidate . getParameterTypes (  )  ;", "if    (  ( constructorToUse    !  =    null )     &  &     (  ( argsToUse . length )     >     ( paramTypes . length )  )  )     {", "break ;", "}", "if    (  ( paramTypes . length )     <    minNrOfArgs )     {", "continue ;", "}", ". ArgumentsHolder   argsHolder ;", "if    ( resolvedValues    !  =    null )     {", "try    {", "String [  ]    paramNames    =     . ConstructorPropertiesChecker . evaluate ( candidate ,    paramTypes . length )  ;", "if    ( paramNames    =  =    null )     {", "ParameterNameDiscoverer   pnd    =    this . beanFactory . getParameterNameDiscoverer (  )  ;", "if    ( pnd    !  =    null )     {", "paramNames    =    pnd . getParameterNames ( candidate )  ;", "}", "}", "argsHolder    =    createArgumentArray ( beanName ,    mbd ,    resolvedValues ,    bw ,    paramTypes ,    paramNames ,    getUserDeclaredConstructor ( candidate )  ,    autowiring )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "if    ( this . beanFactory . logger . isTraceEnabled (  )  )     {", "this . beanFactory . logger . trace (  (  (  (  (  (  \" Ignoring   constructor    [  \"     +    candidate )     +     \"  ]    of   bean    '  \"  )     +    beanName )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "if    ( causes    =  =    null )     {", "causes    =    new   LinkedList <  >  (  )  ;", "}", "causes . add ( ex )  ;", "continue ;", "}", "} else    {", "if    (  ( paramTypes . length )     !  =     ( explicitArgs . length )  )     {", "continue ;", "}", "argsHolder    =    new    . ArgumentsHolder ( explicitArgs )  ;", "}", "int   typeDiffWeight    =     ( mbd . isLenientConstructorResolution (  )  )     ?    argsHolder . getTypeDifferenceWeight ( paramTypes )     :    argsHolder . getAssignabilityWeight ( paramTypes )  ;", "if    ( typeDiffWeight    <    minTypeDiffWeight )     {", "constructorToUse    =    candidate ;", "argsHolderToUse    =    argsHolder ;", "argsToUse    =    argsHolder . arguments ;", "minTypeDiffWeight    =    typeDiffWeight ;", "ambiguousConstructors    =    null ;", "} else", "if    (  ( constructorToUse    !  =    null )     &  &     ( typeDiffWeight    =  =    minTypeDiffWeight )  )     {", "if    ( ambiguousConstructors    =  =    null )     {", "ambiguousConstructors    =    new   LinkedHashSet <  >  (  )  ;", "ambiguousConstructors . add ( constructorToUse )  ;", "}", "ambiguousConstructors . add ( candidate )  ;", "}", "}", "if    ( constructorToUse    =  =    null )     {", "if    ( causes    !  =    null )     {", "UnsatisfiedDependencyException   ex    =    causes . removeLast (  )  ;", "for    ( Exception   cause    :    causes )     {", "this . beanFactory . onSuppressedException ( cause )  ;", "}", "throw   ex ;", "}", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  \" Could   not   resolve   matching   constructor    \"     +     \"  ( hint :    specify   index / type / name   arguments   for   simple   parameters   to   avoid   type   ambiguities )  \"  )  )  ;", "} else", "if    (  ( ambiguousConstructors    !  =    null )     &  &     (  !  ( mbd . isLenientConstructorResolution (  )  )  )  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  \" Ambiguous   constructor   matches   found   in   bean    '  \"     +    beanName )     +     \"  '     \"  )     +     \"  ( hint :    specify   index / type / name   arguments   for   simple   parameters   to   avoid   type   ambiguities )  :     \"  )     +    ambiguousConstructors )  )  ;", "}", "if    ( explicitArgs    =  =    null )     {", "argsHolderToUse . storeCache ( mbd ,    constructorToUse )  ;", "}", "}", "try    {", "final   InstantiationStrategy   strategy    =    beanFactory . getInstantiationStrategy (  )  ;", "Object   beanInstance ;", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "final   Constructor <  ?  >    ctorToUse    =    constructorToUse ;", "final   Object [  ]    argumentsToUse    =    argsToUse ;", "beanInstance    =    AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >    strategy . instantiate ( mbd ,    beanName ,    beanFactory ,    ctorToUse ,    argumentsToUse )  )  )  ,    beanFactory . getAccessControlContext (  )  )  ;", "} else    {", "beanInstance    =    strategy . instantiate ( mbd ,    beanName ,    this . beanFactory ,    constructorToUse ,    argsToUse )  ;", "}", "bw . setBeanInstance ( beanInstance )  ;", "return   bw ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Bean   instantiation   via   constructor   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["autowireConstructor"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   customConverter    =    this . beanFactory . getCustomTypeConverter (  )  ;", "TypeConverter   converter    =     ( customConverter    !  =    null )     ?    customConverter    :    bw ;", ". ArgumentsHolder   args    =    new    . ArgumentsHolder ( paramTypes . length )  ;", "Set < ConstructorArgumentValues . ValueHolder >    usedValueHolders    =    new   HashSet <  >  ( paramTypes . length )  ;", "Set < String >    autowiredBeanNames    =    new   LinkedHashSet <  >  (  4  )  ;", "for    ( int   paramIndex    =     0  ;    paramIndex    <     ( paramTypes . length )  ;    paramIndex +  +  )     {", "Class <  ?  >    paramType    =    paramTypes [ paramIndex ]  ;", "String   paramName    =     ( paramNames    !  =    null )     ?    paramNames [ paramIndex ]     :     \"  \"  ;", "ConstructorArgumentValues . ValueHolder   valueHolder    =    null ;", "if    ( resolvedValues    !  =    null )     {", "valueHolder    =    resolvedValues . getArgumentValue ( paramIndex ,    paramType ,    paramName ,    usedValueHolders )  ;", "if    (  ( valueHolder    =  =    null )     &  &     (  (  ! autowiring )     |  |     (  ( paramTypes . length )     =  =     ( resolvedValues . getArgumentCount (  )  )  )  )  )     {", "valueHolder    =    resolvedValues . getGenericArgumentValue ( null ,    null ,    usedValueHolders )  ;", "}", "}", "if    ( valueHolder    !  =    null )     {", "usedValueHolders . add ( valueHolder )  ;", "Object   originalValue    =    valueHolder . getValue (  )  ;", "Object   convertedValue ;", "if    ( valueHolder . isConverted (  )  )     {", "convertedValue    =    valueHolder . getConvertedValue (  )  ;", "args . preparedArguments [ paramIndex ]     =    convertedValue ;", "} else    {", "MethodParameter   methodParam    =    MethodParameter . forExecutable ( executable ,    paramIndex )  ;", "try    {", "convertedValue    =    converter . convertIfNecessary ( originalValue ,    paramType ,    methodParam )  ;", "}    catch    ( TypeMismatchException   ex )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    new   InjectionPoint ( methodParam )  ,     (  (  (  (  (  \" Could   not   convert   argument   value   of   type    [  \"     +     ( ObjectUtils . nullSafeClassName ( valueHolder . getValue (  )  )  )  )     +     \"  ]    to   required   type    [  \"  )     +     ( paramType . getName (  )  )  )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "Object   sourceHolder    =    valueHolder . getSource (  )  ;", "if    ( sourceHolder   instanceof   ConstructorArgumentValues . ValueHolder )     {", "Object   sourceValue    =     (  ( ConstructorArgumentValues . ValueHolder )     ( sourceHolder )  )  . getValue (  )  ;", "args . resolveNecessary    =    true ;", "args . preparedArguments [ paramIndex ]     =    sourceValue ;", "}", "}", "args . arguments [ paramIndex ]     =    convertedValue ;", "args . rawArguments [ paramIndex ]     =    originalValue ;", "} else    {", "MethodParameter   methodParam    =    MethodParameter . forExecutable ( executable ,    paramIndex )  ;", "if    (  ! autowiring )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    new   InjectionPoint ( methodParam )  ,     (  (  \" Ambiguous   argument   values   for   parameter   of   type    [  \"     +     ( paramType . getName (  )  )  )     +     \"  ]     -    did   you   specify   the   correct   bean   references   as   arguments ?  \"  )  )  ;", "}", "try    {", "Object   autowiredArgument    =    resolveAutowiredArgument ( methodParam ,    beanName ,    autowiredBeanNames ,    converter )  ;", "args . rawArguments [ paramIndex ]     =    autowiredArgument ;", "args . arguments [ paramIndex ]     =    autowiredArgument ;", "args . preparedArguments [ paramIndex ]     =    new    . AutowiredArgumentMarker (  )  ;", "args . resolveNecessary    =    true ;", "}    catch    ( BeansException   ex )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    new   InjectionPoint ( methodParam )  ,    ex )  ;", "}", "}", "}", "for    ( String   autowiredBeanName    :    autowiredBeanNames )     {", "this . beanFactory . registerDependentBean ( autowiredBeanName ,    beanName )  ;", "if    ( this . beanFactory . logger . isDebugEnabled (  )  )     {", "this . beanFactory . logger . debug (  (  (  (  (  (  (  \" Autowiring   by   type   from   bean   name    '  \"     +    beanName )     +     \"  '    via    \"  )     +     ( executable   instanceof   Constructor    ?     \" constructor \"     :     \" factory   method \"  )  )     +     \"    to   bean   named    '  \"  )     +    autowiredBeanName )     +     \"  '  \"  )  )  ;", "}", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["createArgumentArray"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < Method [  ]  >  )     (  (  )     -  >    mbd . isNonPublicAccessAllowed (  )     ?    ReflectionUtils . getAllDeclaredMethods ( Class )     :    Class . getMethods (  )  )  )  )  ;", "} else    {", "return   mbd . isNonPublicAccessAllowed (  )     ?    ReflectionUtils . getAllDeclaredMethods ( Class )     :    Class . getMethods (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCandidateMethods"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    declaringClass    =    constructor . getDeclaringClass (  )  ;", "Class <  ?  >    userClass    =    ClassUtils . getUserClass ( declaringClass )  ;", "if    ( userClass    !  =    declaringClass )     {", "try    {", "return   userClass . getDeclared ( constructor . getParameterTypes (  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "}", "}", "return   constructor ;", "}", "METHOD_END"], "methodName": ["getUserDeclaredConstructor"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "BeanWrapperImpl   bw    =    new   BeanWrapperImpl (  )  ;", "this . beanFactory . initBeanWrapper ( bw )  ;", "Object   factoryBean ;", "Class <  ?  >    factoryClass ;", "boolean   isStatic ;", "String   factoryBeanName    =    mbd . getFactoryBeanName (  )  ;", "if    ( factoryBeanName    !  =    null )     {", "if    ( factoryBeanName . equals ( beanName )  )     {", "throw   new   BeanDefinitionStoreException ( mbd . getResourceDescription (  )  ,    beanName ,     \" factory - bean   reference   points   back   to   the   same   bean   definition \"  )  ;", "}", "factoryBean    =    this . beanFactory . getBean ( factoryBeanName )  ;", "if    (  ( mbd . isSingleton (  )  )     &  &     ( this . beanFactory . containsSingleton ( beanName )  )  )     {", "throw   new   ImplicitlyAppearedSingletonException (  )  ;", "}", "factoryClass    =    factoryBean . getClass (  )  ;", "isStatic    =    false ;", "} else    {", "if    (  !  ( mbd . hasBeanClass (  )  )  )     {", "throw   new   BeanDefinitionStoreException ( mbd . getResourceDescription (  )  ,    beanName ,     \" bean   definition   declares   neither   a   bean   class   nor   a   factory - bean   reference \"  )  ;", "}", "factoryBean    =    null ;", "factoryClass    =    mbd . getBeanClass (  )  ;", "isStatic    =    true ;", "}", "Method   factoryMethodToUse    =    null ;", ". ArgumentsHolder   argsHolderToUse    =    null ;", "Object [  ]    argsToUse    =    null ;", "if    ( explicitArgs    !  =    null )     {", "argsToUse    =    explicitArgs ;", "} else    {", "Object [  ]    argsToResolve    =    null ;", "synchronized ( mbd . constructorArgumentLock )     {", "factoryMethodToUse    =     (  ( Method )     ( mbd . resolvedConstructorOrFactoryMethod )  )  ;", "if    (  ( factoryMethodToUse    !  =    null )     &  &     ( mbd . constructorArgumentsResolved )  )     {", "argsToUse    =    mbd . resolvedConstructorArguments ;", "if    ( argsToUse    =  =    null )     {", "argsToResolve    =    mbd . preparedConstructorArguments ;", "}", "}", "}", "if    ( argsToResolve    !  =    null )     {", "argsToUse    =    resolvePreparedArguments ( beanName ,    mbd ,    bw ,    factoryMethodToUse ,    argsToResolve )  ;", "}", "}", "if    (  ( factoryMethodToUse    =  =    null )     |  |     ( argsToUse    =  =    null )  )     {", "factoryClass    =    ClassUtils . getUserClass ( factoryClass )  ;", "Method [  ]    rawCandidates    =    getCandidateMethods ( factoryClass ,    mbd )  ;", "List < Method >    candidateSet    =    new   ArrayList <  >  (  )  ;", "for    ( Method   candidate    :    rawCandidates )     {", "if    (  (  ( Modifier . isStatic ( candidate . getModifiers (  )  )  )     =  =    isStatic )     &  &     ( mbd . isFactoryMethod ( candidate )  )  )     {", "candidateSet . add ( candidate )  ;", "}", "}", "Method [  ]    candidates    =    candidateSet . toArray ( new   Method [  0  ]  )  ;", "AutowireUtils . sortFactoryMethods ( candidates )  ;", "ConstructorArgumentValues   resolvedValues    =    null ;", "boolean   autowiring    =     ( mbd . getResolvedAutowireMode (  )  )     =  =     ( RootBeanDefinition . AUTOWIRE _ CONSTRUCTOR )  ;", "int   minTypeDiffWeight    =    Integer . MAX _ VALUE ;", "Set < Method >    ambiguousFactoryMethods    =    null ;", "int   minNrOfArgs ;", "if    ( explicitArgs    !  =    null )     {", "minNrOfArgs    =    explicitArgs . length ;", "} else    {", "if    ( mbd . hasConstructorArgumentValues (  )  )     {", "ConstructorArgumentValues   cargs    =    mbd . getConstructorArgumentValues (  )  ;", "resolvedValues    =    new   ConstructorArgumentValues (  )  ;", "minNrOfArgs    =    resolveConstructorArguments ( beanName ,    mbd ,    bw ,    cargs ,    resolvedValues )  ;", "} else    {", "minNrOfArgs    =     0  ;", "}", "}", "LinkedList < UnsatisfiedDependencyException >    causes    =    null ;", "for    ( Method   candidate    :    candidates )     {", "Class <  ?  >  [  ]    paramTypes    =    candidate . getParameterTypes (  )  ;", "if    (  ( paramTypes . length )     >  =    minNrOfArgs )     {", ". ArgumentsHolder   argsHolder ;", "if    ( explicitArgs    !  =    null )     {", "if    (  ( paramTypes . length )     !  =     ( explicitArgs . length )  )     {", "continue ;", "}", "argsHolder    =    new    . ArgumentsHolder ( explicitArgs )  ;", "} else    {", "try    {", "String [  ]    paramNames    =    null ;", "ParameterNameDiscoverer   pnd    =    this . beanFactory . getParameterNameDiscoverer (  )  ;", "if    ( pnd    !  =    null )     {", "paramNames    =    pnd . getParameterNames ( candidate )  ;", "}", "argsHolder    =    createArgumentArray ( beanName ,    mbd ,    resolvedValues ,    bw ,    paramTypes ,    paramNames ,    candidate ,    autowiring )  ;", "}    catch    ( UnsatisfiedDependencyException   ex )     {", "if    ( this . beanFactory . logger . isTraceEnabled (  )  )     {", "this . beanFactory . logger . trace (  (  (  (  (  (  \" Ignoring   factory   method    [  \"     +    candidate )     +     \"  ]    of   bean    '  \"  )     +    beanName )     +     \"  '  :     \"  )     +    ex )  )  ;", "}", "if    ( causes    =  =    null )     {", "causes    =    new   LinkedList <  >  (  )  ;", "}", "causes . add ( ex )  ;", "continue ;", "}", "}", "int   typeDiffWeight    =     ( mbd . isLenientConstructorResolution (  )  )     ?    argsHolder . getTypeDifferenceWeight ( paramTypes )     :    argsHolder . getAssignabilityWeight ( paramTypes )  ;", "if    ( typeDiffWeight    <    minTypeDiffWeight )     {", "factoryMethodToUse    =    candidate ;", "argsHolderToUse    =    argsHolder ;", "argsToUse    =    argsHolder . arguments ;", "minTypeDiffWeight    =    typeDiffWeight ;", "ambiguousFactoryMethods    =    null ;", "} else", "if    (  (  (  (  ( factoryMethodToUse    !  =    null )     &  &     ( typeDiffWeight    =  =    minTypeDiffWeight )  )     &  &     (  !  ( mbd . isLenientConstructorResolution (  )  )  )  )     &  &     (  ( paramTypes . length )     =  =     ( factoryMethodToUse . getParameterCount (  )  )  )  )     &  &     (  !  ( equals ( paramTypes ,    factoryMethodToUse . getParameterTypes (  )  )  )  )  )     {", "if    ( ambiguousFactoryMethods    =  =    null )     {", "ambiguousFactoryMethods    =    new   LinkedHashSet <  >  (  )  ;", "ambiguousFactoryMethods . add ( factoryMethodToUse )  ;", "}", "ambiguousFactoryMethods . add ( candidate )  ;", "}", "}", "}", "if    ( factoryMethodToUse    =  =    null )     {", "if    ( causes    !  =    null )     {", "UnsatisfiedDependencyException   ex    =    causes . removeLast (  )  ;", "for    ( Exception   cause    :    causes )     {", "this . beanFactory . onSuppressedException ( cause )  ;", "}", "throw   ex ;", "}", "List < String >    argTypes    =    new   ArrayList <  >  ( minNrOfArgs )  ;", "if    ( explicitArgs    !  =    null )     {", "for    ( Object   arg    :    explicitArgs )     {", "argTypes . add (  ( arg    !  =    null    ?    arg . getClass (  )  . getSimpleName (  )     :     \" null \"  )  )  ;", "}", "} else", "if    ( resolvedValues    !  =    null )     {", "Set < ConstructorArgumentValues . ValueHolder >    valueHolders    =    new   LinkedHashSet <  >  ( resolvedValues . getArgumentCount (  )  )  ;", "valueHolders . addAll ( resolvedValues . getIndexedArgumentValues (  )  . values (  )  )  ;", "valueHolders . addAll ( resolvedValues . getGenericArgumentValues (  )  )  ;", "for    ( ConstructorArgumentValues . ValueHolder   value    :    valueHolders )     {", "String   argType    =     (  ( value . getType (  )  )     !  =    null )     ?    ClassUtils . getShortName ( value . getType (  )  )     :     ( value . getValue (  )  )     !  =    null    ?    value . getValue (  )  . getClass (  )  . getSimpleName (  )     :     \" null \"  ;", "argTypes . add ( argType )  ;", "}", "}", "String   argDesc    =    StringUtils . collectionToCommaDelimitedString ( argTypes )  ;", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  (  (  (  (  (  (  (  \" No   matching   factory   method   found :     \"     +     (  ( mbd . getFactoryBeanName (  )  )     !  =    null    ?     (  \" factory   bean    '  \"     +     ( mbd . getFactoryBeanName (  )  )  )     +     \"  '  ;     \"     :     \"  \"  )  )     +     \" factory   method    '  \"  )     +     ( mbd . getFactoryMethodName (  )  )  )     +     \"  (  \"  )     +    argDesc )     +     \"  )  '  .     \"  )     +     \" Check   that   a   method   with   the   specified   name    \"  )     +     ( minNrOfArgs    >     0     ?     \" and   arguments    \"     :     \"  \"  )  )     +     \" exists   and   that   it   is    \"  )     +     ( isStatic    ?     \" static \"     :     \" non - static \"  )  )     +     \"  .  \"  )  )  ;", "} else", "if    (  ( void . class )     =  =     ( factoryMethodToUse . getReturnType (  )  )  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  \" Invalid   factory   method    '  \"     +     ( mbd . getFactoryMethodName (  )  )  )     +     \"  '  :    needs   to   have   a   non - void   return   type !  \"  )  )  ;", "} else", "if    ( ambiguousFactoryMethods    !  =    null )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  (  (  (  \" Ambiguous   factory   method   matches   found   in   bean    '  \"     +    beanName )     +     \"  '     \"  )     +     \"  ( hint :    specify   index / type / name   arguments   for   simple   parameters   to   avoid   type   ambiguities )  :     \"  )     +    ambiguousFactoryMethods )  )  ;", "}", "if    (  ( explicitArgs    =  =    null )     &  &     ( argsHolderToUse    !  =    null )  )     {", "argsHolderToUse . storeCache ( mbd ,    factoryMethodToUse )  ;", "}", "}", "try    {", "Object   beanInstance ;", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "final   Object   fb    =    factoryBean ;", "final   Method   factoryMethod    =    factoryMethodToUse ;", "final   Object [  ]    args    =    argsToUse ;", "beanInstance    =    AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >    beanFactory . getInstantiationStrategy (  )  . instantiate ( mbd ,    beanName ,    beanFactory ,    fb ,    factoryMethod ,    args )  )  )  ,    beanFactory . getAccessControlContext (  )  )  ;", "} else    {", "beanInstance    =    this . beanFactory . getInstantiationStrategy (  )  . instantiate ( mbd ,    beanName ,    this . beanFactory ,    factoryBean ,    factoryMethodToUse ,    argsToUse )  ;", "}", "bw . setBeanInstance ( beanInstance )  ;", "return   bw ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     \" Bean   instantiation   via   factory   method   failed \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateUsingFactoryMethod"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( InjectionPoint . class . isAssignableFrom ( param . getParameterType (  )  )  )     {", "InjectionPoint   injectionPoint    =     . currentInjectionPoint . get (  )  ;", "if    ( injectionPoint    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   current   InjectionPoint   available   for    \"     +    param )  )  ;", "}", "return   injectionPoint ;", "}", "return   this . beanFactory . resolveDependency ( new   DependencyDescriptor ( param ,    true )  ,    beanName ,    autowiredBeanNames ,    typeConverter )  ;", "}", "METHOD_END"], "methodName": ["resolveAutowiredArgument"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   customConverter    =    this . beanFactory . getCustomTypeConverter (  )  ;", "TypeConverter   converter    =     ( customConverter    !  =    null )     ?    customConverter    :    bw ;", "BeanDefinitionValueResolver   valueResolver    =    new   BeanDefinitionValueResolver ( this . beanFactory ,    beanName ,    mbd ,    converter )  ;", "int   minNrOfArgs    =    cargs . getArgumentCount (  )  ;", "for    ( Map . Entry < Integer ,    ArgumentValues . ValueHolder >    entry    :    cargs . getIndexedArgumentValues (  )  . entrySet (  )  )     {", "int   index    =    entry . getKey (  )  ;", "if    ( index    <     0  )     {", "throw   new   BeanCreationException ( mbd . getResourceDescription (  )  ,    beanName ,     (  \" Invalid   constructor   argument   index :     \"     +    index )  )  ;", "}", "if    ( index    >    minNrOfArgs )     {", "minNrOfArgs    =    index    +     1  ;", "}", "ArgumentValues . ValueHolder   valueHolder    =    entry . getValue (  )  ;", "if    ( valueHolder . isConverted (  )  )     {", "resolvedValues . addIndexedArgumentValue ( index ,    valueHolder )  ;", "} else    {", "Object   resolvedValue    =    valueResolver . resolveValueIfNecessary (  \" constructor   argument \"  ,    valueHolder . getValue (  )  )  ;", "ArgumentValues . ValueHolder   resolvedValueHolder    =    new   ArgumentValues . ValueHolder ( resolvedValue ,    valueHolder . getType (  )  ,    valueHolder . getName (  )  )  ;", "resolvedValueHolder . setSource ( valueHolder )  ;", "resolvedValues . addIndexedArgumentValue ( index ,    resolvedValueHolder )  ;", "}", "}", "for    ( ArgumentValues . ValueHolder   valueHolder    :    cargs . getGenericArgumentValues (  )  )     {", "if    ( valueHolder . isConverted (  )  )     {", "resolvedValues . addGenericArgumentValue ( valueHolder )  ;", "} else    {", "Object   resolvedValue    =    valueResolver . resolveValueIfNecessary (  \" constructor   argument \"  ,    valueHolder . getValue (  )  )  ;", "ArgumentValues . ValueHolder   resolvedValueHolder    =    new   ArgumentValues . ValueHolder ( resolvedValue ,    valueHolder . getType (  )  ,    valueHolder . getName (  )  )  ;", "resolvedValueHolder . setSource ( valueHolder )  ;", "resolvedValues . addGenericArgumentValue ( resolvedValueHolder )  ;", "}", "}", "return   minNrOfArgs ;", "}", "METHOD_END"], "methodName": ["resolveConstructorArguments"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    factoryClass ;", "boolean   isStatic ;", "if    (  ( mbd . getFactoryBeanName (  )  )     !  =    null )     {", "factoryClass    =    this . beanFactory . getType ( mbd . getFactoryBeanName (  )  )  ;", "isStatic    =    false ;", "} else    {", "factoryClass    =    mbd . getBeanClass (  )  ;", "isStatic    =    true ;", "}", "Assert . state (  ( factoryClass    !  =    null )  ,     \" Unresolvable   factory   class \"  )  ;", "factoryClass    =    ClassUtils . getUserClass ( factoryClass )  ;", "Method [  ]    candidates    =    getCandidateMethods ( factoryClass ,    mbd )  ;", "Method   uniqueCandidate    =    null ;", "for    ( Method   candidate    :    candidates )     {", "if    (  (  ( Modifier . isStatic ( candidate . getModifiers (  )  )  )     =  =    isStatic )     &  &     ( mbd . isFactoryMethod ( candidate )  )  )     {", "if    ( uniqueCandidate    =  =    null )     {", "uniqueCandidate    =    candidate ;", "} else", "if    (  !  ( equals ( uniqueCandidate . getParameterTypes (  )  ,    candidate . getParameterTypes (  )  )  )  )     {", "uniqueCandidate    =    null ;", "break ;", "}", "}", "}", "synchronized ( mbd . constructorArgumentLock )     {", "mbd . resolvedOrFactoryMethod    =    uniqueCandidate ;", "}", "}", "METHOD_END"], "methodName": ["resolveFactoryMethodIfPossible"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   customConverter    =    this . beanFactory . getCustomTypeConverter (  )  ;", "TypeConverter   converter    =     ( customConverter    !  =    null )     ?    customConverter    :    bw ;", "BeanDefinitionValueResolver   valueResolver    =    new   BeanDefinitionValueResolver ( this . beanFactory ,    beanName ,    mbd ,    converter )  ;", "Class <  ?  >  [  ]    paramTypes    =    executable . getParameterTypes (  )  ;", "Object [  ]    resolvedArgs    =    new   Object [ argsToResolve . length ]  ;", "for    ( int   argIndex    =     0  ;    argIndex    <     ( argsToResolve . length )  ;    argIndex +  +  )     {", "Object   argValue    =    argsToResolve [ argIndex ]  ;", "MethodParameter   methodParam    =    MethodParameter . forExecutable ( executable ,    argIndex )  ;", "GenericTypeResolver . resolveParameterType ( methodParam ,    executable . getDeclaringClass (  )  )  ;", "if    ( argValue   instanceof   ConstructorResolver . AutowiredArgumentMarker )     {", "argValue    =    resolveAutowiredArgument ( methodParam ,    beanName ,    null ,    converter )  ;", "} else", "if    ( argValue   instanceof   BeanMetadataElement )     {", "argValue    =    valueResolver . resolveValueIfNecessary (  \" constructor   argument \"  ,    argValue )  ;", "} else", "if    ( argValue   instanceof   String )     {", "argValue    =    this . beanFactory . evaluateBeanDefinitionString (  (  ( String )     ( argValue )  )  ,    mbd )  ;", "}", "Class <  ?  >    paramType    =    paramTypes [ argIndex ]  ;", "try    {", "resolvedArgs [ argIndex ]     =    converter . convertIfNecessary ( argValue ,    paramType ,    methodParam )  ;", "}    catch    ( TypeMismatchException   ex )     {", "throw   new   UnsatisfiedDependencyException ( mbd . getResourceDescription (  )  ,    beanName ,    new   InjectionPoint ( methodParam )  ,     (  (  (  (  (  \" Could   not   convert   argument   value   of   type    [  \"     +     ( ObjectUtils . nullSafeClassName ( argValue )  )  )     +     \"  ]    to   required   type    [  \"  )     +     ( paramType . getName (  )  )  )     +     \"  ]  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "return   resolvedArgs ;", "}", "METHOD_END"], "methodName": ["resolvePreparedArguments"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "InjectionPoint   old    =    ConstructorResolver . currentInjectionPoint . get (  )  ;", "if    ( injectionPoint    !  =    null )     {", "ConstructorResolver . currentInjectionPoint . set ( injectionPoint )  ;", "} else    {", "ConstructorResolver . currentInjectionPoint . remove (  )  ;", "}", "return   old ;", "}", "METHOD_END"], "methodName": ["setCurrentInjectionPoint"], "fileName": "org.springframework.beans.factory.support.ConstructorResolver"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparator    =    getDependencyComparator (  )  ;", "if    ( comparator   instanceof   OrderComparator )     {", "return    (  ( OrderComparator )     ( comparator )  )  . withSourceProvider ( createAwareOrderSourceProvider ( matchingBeans )  )  ;", "} else    {", "return   comparator ;", "}", "}", "METHOD_END"], "methodName": ["adaptDependencyComparator"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( descriptor   instanceof   DefaultListableBeanFactory . MultiElementDescriptor )     |  |     ( containsSingleton ( candidateName )  )  )     {", "Object   beanInstance    =    descriptor . resolveCandidate ( candidateName ,    requiredType ,    this )  ;", "candidates . put ( candidateName ,     ( beanInstance   instanceof   NullBean    ?    null    :    beanInstance )  )  ;", "} else    {", "candidates . put ( candidateName ,    getType ( candidateName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addCandidateEntry"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( String   beanName    :    this . beanDefinitionNames )     {", "RootBeanDefinition   mbd    =    getMergedLocalBeanDefinition ( beanName )  ;", "Class <  ?  >    targetType    =    mbd . getTargetType (  )  ;", "if    (  (  ( targetType    !  =    null )     &  &     ( type . isAssignableFrom ( targetType )  )  )     &  &     ( isAutowireCandidate ( beanName ,    mbd ,    descriptor ,    getAutowireCandidateResolver (  )  )  )  )     {", "Object   beanInstance    =    getSingleton ( beanName ,    false )  ;", "Class <  ?  >    beanType    =     (  ( beanInstance    !  =    null )     &  &     (  ( beanInstance . getClass (  )  )     !  =     ( NullBean . class )  )  )     ?    beanInstance . getClass (  )     :    predictBeanType ( beanName ,    mbd )  ;", "if    (  ( beanType    !  =    null )     &  &     (  !  ( type . isAssignableFrom ( beanType )  )  )  )     {", "throw   new   BeanNotOfRequiredTypeException ( beanName ,    type ,    beanType )  ;", "}", "}", "}", "BeanFactory   parent    =    getParentBeanFactory (  )  ;", "if    ( parent   instanceof    )     {", "(  (  )     ( parent )  )  . checkBeanNotOfRequiredType ( type ,    descriptor )  ;", "}", "}", "METHOD_END"], "methodName": ["checkBeanNotOfRequiredType"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . allBeanNamesByType . clear (  )  ;", "this . singletonBeanNamesByType . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearByTypeCache"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "IdentityHashMap < Object ,    String >    instancesToBeanNames    =    new   IdentityHashMap <  >  (  )  ;", "beans . forEach (  (    beanName ,    instance )     -  >    instancesToBeanNames . put ( instance ,    beanName )  )  ;", "return   new    . FactoryAwareOrderSourceProvider ( instancesToBeanNames )  ;", "}", "METHOD_END"], "methodName": ["createFactoryAwareOrderSourceProvider"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "DependencyDescriptor   descriptorToUse    =    new   DefaultListableBeanFactory . NestedDependencyDescriptor ( descriptor )     {", "@ Override", "public   boolean   isRequired (  )     {", "return   false ;", "}", "@ Override", "public   Object   resolveCandidate ( String   beanName ,    Class <  ?  >    requiredType ,    BeanFactory   beanFactory )     {", "return    !  ( ObjectUtils . isEmpty ( args )  )     ?    beanFactory . getBean ( beanName ,    args )     :    super . resolveCandidate ( beanName ,    requiredType ,    beanFactory )  ;", "}", "}  ;", "return   Optional . ofNullable ( doResolveDependency ( descriptorToUse ,    beanName ,    null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["createOptionalDependency"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    requiredType    =    descriptor . getDependencyType (  )  ;", "St   primaryCandidate    =    determinePrimaryCandidate ( candidates ,    requiredType )  ;", "if    ( primaryCandidate    !  =    null )     {", "return   primaryCandidate ;", "}", "St   priorityCandidate    =    determineHighestPriorityCandidate ( candidates ,    requiredType )  ;", "if    ( priorityCandidate    !  =    null )     {", "return   priorityCandidate ;", "}", "for    ( Map . Entry < St ,    Object >    entry    :    candidates . entrySet (  )  )     {", "St   candidateName    =    entry . getKey (  )  ;", "Object   beanInstance    =    entry . getValue (  )  ;", "if    (  (  ( beanInstance    !  =    null )     &  &     ( this . resolvableDependencies . containsValue ( beanInstance )  )  )     |  |     ( matchesBeanName ( candidateName ,    descriptor . getDependencyName (  )  )  )  )     {", "return   candidateName ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["determineAutowireCandidate"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   highestPriorityBeanName    =    null ;", "Integer   highestPriority    =    null ;", "for    ( Map . Entry < String ,    Object >    entry    :    candidates . entrySet (  )  )     {", "String   candidatName    =    entry . getKey (  )  ;", "Object   beanInstance    =    entry . getValue (  )  ;", "if    ( beanInstance    !  =    null )     {", "Integer   candidatePriority    =    getPriority ( beanInstance )  ;", "if    ( candidatePriority    !  =    null )     {", "if    ( highestPriorityBeanName    !  =    null )     {", "if    ( candidatePriority . equals ( highestPriority )  )     {", "throw   new   NoUniquDefinitionException ( requiredType ,    candidates . size (  )  ,     (  (  (  \" Multiple   beans   found   with   the   same   priority    (  '  \"     +    highestPriority )     +     \"  '  )    among   candidates :     \"  )     +     ( candidates . keySet (  )  )  )  )  ;", "} else", "if    ( candidatePriority    <    highestPriority )     {", "highestPriorityBeanName    =    candidatName ;", "highestPriority    =    candidatePriority ;", "}", "} else    {", "highestPriorityBeanName    =    candidatName ;", "highestPriority    =    candidatePriority ;", "}", "}", "}", "}", "return   highestPriorityBeanName ;", "}", "METHOD_END"], "methodName": ["determineHighestPriorityCandidate"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   primaryBeanName    =    null ;", "for    ( Map . Entry < String ,    Object >    entry    :    candidates . entrySet (  )  )     {", "String   candidatName    =    entry . getKey (  )  ;", "Object   beanInstance    =    entry . getValue (  )  ;", "if    ( isPrimary ( candidatName ,    beanInstance )  )     {", "if    ( primaryBeanName    !  =    null )     {", "boolean   candidateLocal    =    containsBeanDefinition ( candidatName )  ;", "boolean   primaryLocal    =    containsBeanDefinition ( primaryBeanName )  ;", "if    ( candidateLocal    &  &    primaryLocal )     {", "throw   new   NoUniquDefinitionException ( requiredType ,    candidates . size (  )  ,     (  \" more   than   one    ' primary '    bean   found   among   candidates :     \"     +     ( candidates . keySet (  )  )  )  )  ;", "} else", "if    ( candidateLocal )     {", "primaryBeanName    =    candidatName ;", "}", "} else    {", "primaryBeanName    =    candidatName ;", "}", "}", "}", "return   primaryBeanName ;", "}", "METHOD_END"], "methodName": ["determinePrimaryCandidate"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( String   beanName    :    this . beanDefinitionNames )     {", "if    (  !  ( isAlias ( beanName )  )  )     {", "try    {", "RootBeanDefinition   mbd    =    getMergedLocalBeanDefinition ( beanName )  ;", "if    (  (  !  ( mbd . isAbstract (  )  )  )     &  &     ( allowEagerInit    |  |     (  (  (  ( mbd . hasBeanClass (  )  )     |  |     (  !  ( mbd . isLazyInit (  )  )  )  )     |  |     ( isAllowEagerClassLoading (  )  )  )     &  &     (  !  ( requiresEagerInitForType ( mbd . getFactoryBeanName (  )  )  )  )  )  )  )     {", "boolean   isFactoryBean    =    isFactoryBean ( beanName ,    mbd )  ;", "BeanDefinitionHolder   dbd    =    mbd . getDecoratedDefinition (  )  ;", "boolean   matchFound    =     (  (  (  ( allowEagerInit    |  |     (  ! isFactoryBean )  )     |  |     (  ( dbd    !  =    null )     &  &     (  !  ( mbd . isLazyInit (  )  )  )  )  )     |  |     ( containsSingleton ( beanName )  )  )     &  &     ( includeNonSingletons    |  |     ( dbd    !  =    null    ?    mbd . isSingleton (  )     :    isSingleton ( beanName )  )  )  )     &  &     ( isTypeMatch ( beanName ,    type )  )  ;", "if    (  (  ! matchFound )     &  &    isFactoryBean )     {", "beanName    =     (  . FACTORY _ BEAN _ PREFIX )     +    beanName ;", "matchFound    =     ( includeNonSingletons    |  |     ( mbd . isSingleton (  )  )  )     &  &     ( isTypeMatch ( beanName ,    type )  )  ;", "}", "if    ( matchFound )     {", "result . add ( beanName )  ;", "}", "}", "}    catch    ( CannotLoadBeanClassException   ex )     {", "if    ( allowEagerInit )     {", "throw   ex ;", "}", "if    ( this . logger . isDebugEnabled (  )  )     {", "this . logger . debug (  (  (  \" Ignoring   bean   class   loading   failure   for   bean    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "onSuppressedException ( ex )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "if    ( allowEagerInit )     {", "throw   ex ;", "}", "if    ( this . logger . isDebugEnabled (  )  )     {", "this . logger . debug (  (  (  \" Ignoring   unresolvable   metadata   in   bean   definition    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "onSuppressedException ( ex )  ;", "}", "}", "}", "for    ( String   beanName    :    this . manualSingletonNames )     {", "try    {", "if    ( isFactoryBean ( beanName )  )     {", "if    (  ( includeNonSingletons    |  |     ( isSingleton ( beanName )  )  )     &  &     ( isTypeMatch ( beanName ,    type )  )  )     {", "result . add ( beanName )  ;", "continue ;", "}", "beanName    =     (  . FACTORY _ BEAN _ PREFIX )     +    beanName ;", "}", "if    ( isTypeMatch ( beanName ,    type )  )     {", "result . add ( beanName )  ;", "}", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Failed   to   check   manually   registered   singleton   with   name    '  \"     +    beanName )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "}", "return   StringUtils . toStringArray ( result )  ;", "}", "METHOD_END"], "methodName": ["doGetBeanNamesForType"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "InjectionPoint   previousInjectionPoint    =    ConstructorResolver . setCurrentInjectionPoint ( descriptor )  ;", "try    {", "Object   shortcut    =    descriptor . resolveShortcut ( this )  ;", "if    ( shortcut    !  =    null )     {", "return   shortcut ;", "}", "Class <  ?  >    type    =    descriptor . getDependencyType (  )  ;", "Object   value    =    getAutowireCandidateResolver (  )  . getSuggestedValue ( descriptor )  ;", "if    ( value    !  =    null )     {", "if    ( value   instanceof   String )     {", "String   strVal    =    resolveEmbeddedValue (  (  ( String )     ( value )  )  )  ;", "BeanDefinition   bd    =     (  ( beanName    !  =    null )     &  &     ( containsBean ( beanName )  )  )     ?    getMergedBeanDefinition ( beanName )     :    null ;", "value    =    evaluateBeanDefinitionString ( strVal ,    bd )  ;", "}", "TypeConverter   converter    =     ( typeConverter    !  =    null )     ?    typeConverter    :    getTypeConverter (  )  ;", "return    ( descriptor . getField (  )  )     !  =    null    ?    converter . convertIfNecessary ( value ,    type ,    descriptor . getField (  )  )     :    converter . convertIfNecessary ( value ,    type ,    descriptor . getMethodParameter (  )  )  ;", "}", "Object   multips    =    resolveMultips ( descriptor ,    beanName ,    autowiredBeanNames ,    typeConverter )  ;", "if    ( multips    !  =    null )     {", "return   multips ;", "}", "Map < String ,    Object >    matchingBeans    =    findAutowireCandidates ( beanName ,    type ,    descriptor )  ;", "if    ( matchingBeans . isEmpty (  )  )     {", "if    ( isRequired ( descriptor )  )     {", "raiseNoMatchingBeanFound ( type ,    descriptor . getResolvableType (  )  ,    descriptor )  ;", "}", "return   null ;", "}", "String   autowiredBeanName ;", "Object   instanceCandidate ;", "if    (  ( matchingBeans . size (  )  )     >     1  )     {", "autowiredBeanName    =    determineAutowireCandidate ( matchingBeans ,    descriptor )  ;", "if    ( autowiredBeanName    =  =    null )     {", "if    (  ( isRequired ( descriptor )  )     |  |     (  !  ( indicatesMultips ( type )  )  )  )     {", "return   descriptor . resolveNotUnique ( type ,    matchingBeans )  ;", "} else    {", "return   null ;", "}", "}", "instanceCandidate    =    matchingBeans . get ( autowiredBeanName )  ;", "} else    {", "Map . Entry < String ,    Object >    entry    =    matchingBeans . entrySet (  )  . iterator (  )  . next (  )  ;", "autowiredBeanName    =    entry . getKey (  )  ;", "instanceCandidate    =    entry . getValue (  )  ;", "}", "if    ( autowiredBeanNames    !  =    null )     {", "autowiredBeanNames . add ( autowiredBeanName )  ;", "}", "if    ( instanceCandidate   instanceof   Class )     {", "instanceCandidate    =    descriptor . resolveCandidate ( autowiredBeanName ,    type ,    this )  ;", "}", "Object   result    =    instanceCandidate ;", "if    ( result   instanceof   NullBean )     {", "if    ( isRequired ( descriptor )  )     {", "raiseNoMatchingBeanFound ( type ,    descriptor . getResolvableType (  )  ,    descriptor )  ;", "}", "result    =    null ;", "}", "if    (  !  ( ClassUtils . isAssignableValue ( type ,    result )  )  )     {", "throw   new   BeanNotOfRequiredTypeException ( autowiredBeanName ,    type ,    instanceCandidate . getClass (  )  )  ;", "}", "return   result ;", "}    finally    {", "ConstructorResolver . setCurrentInjectionPoint ( previousInjectionPoint )  ;", "}", "}", "METHOD_END"], "methodName": ["doResolveDependency"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String [  ]    candidateNames    =    BeanFactoryUtils . beanNamesForTypeIncludingAncestors ( this ,    requiredType ,    true ,    descriptor . isEager (  )  )  ;", "Map < String ,    Object >    result    =    new   LinkedHashMap <  >  ( candidateNames . length )  ;", "for    ( Class <  ?  >    autowiringType    :    this . resolvableDependencies . keySet (  )  )     {", "if    ( autowiringType . isAssignableFrom ( requiredType )  )     {", "Object   autowiringValue    =    this . resolvableDependencies . get ( autowiringType )  ;", "autowiringValue    =    AutowireUtils . resolveAutowiringValue ( autowiringValue ,    requiredType )  ;", "if    ( requiredType . isInstance ( autowiringValue )  )     {", "result . put ( ObjectUtils . identityToString ( autowiringValue )  ,    autowiringValue )  ;", "break ;", "}", "}", "}", "for    ( String   candidate    :    candidateNames )     {", "if    (  (  !  ( isSelfReference ( beanName ,    candidate )  )  )     &  &     ( isAutowireCandidate ( candidate ,    descriptor )  )  )     {", "addCandidateEntry ( result ,    candidate ,    descriptor ,    requiredType )  ;", "}", "}", "if    (  ( result . isEmpty (  )  )     &  &     (  !  ( indicatesMultipleBeans ( requiredType )  )  )  )     {", "DependencyDescriptor   fallbackDescriptor    =    descriptor . forFallbackMatch (  )  ;", "for    ( String   candidate    :    candidateNames )     {", "if    (  (  !  ( isSelfReference ( beanName ,    candidate )  )  )     &  &     ( isAutowireCandidate ( candidate ,    fallbackDescriptor )  )  )     {", "addCandidateEntry ( result ,    candidate ,    descriptor ,    requiredType )  ;", "}", "}", "if    ( result . isEmpty (  )  )     {", "for    ( String   candidate    :    candidateNames )     {", "if    (  (  ( isSelfReference ( beanName ,    candidate )  )     &  &     (  (  !  ( descriptor   instanceof    . MultiElementDescriptor )  )     |  |     (  !  ( beanName . equals ( candidate )  )  )  )  )     &  &     ( isAutowireCandidate ( candidate ,    fallbackDescriptor )  )  )     {", "addCandidateEntry ( result ,    candidate ,    descriptor ,    requiredType )  ;", "}", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findAutowireCandidates"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . autowireCandidateResolver ;", "}", "METHOD_END"], "methodName": ["getAutowireCandidateResolver"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . dependencyComparator ;", "}", "METHOD_END"], "methodName": ["getDependencyComparator"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Comparator < Object >    comparator    =    getDependencyComparator (  )  ;", "if    ( comparator   instanceof   OrderComparator )     {", "return    (  ( OrderComparator )     ( comparator )  )  . getPriority ( Instance )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPriority"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . serializationId ;", "}", "METHOD_END"], "methodName": ["getSerializationId"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( type . isArray (  )  )     |  |     (  ( type . isInterface (  )  )     &  &     (  ( Collection . class . isAssignableFrom ( type )  )     |  |     ( Map . class . isAssignableFrom ( type )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["indicatesMultipleBeans"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . allowBeanDefinitionOverriding ;", "}", "METHOD_END"], "methodName": ["isAllowBeanDefinitionOverriding"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . allowEagerClassLoading ;", "}", "METHOD_END"], "methodName": ["isAllowEagerClassLoading"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   beanDefinitionName    =    BeanFactoryUtils . transformedBeanName ( beanName )  ;", "if    ( containsBeanDefinition ( beanDefinitionName )  )     {", "return   isAutowireCandidate ( beanName ,    getMergedLocalBeanDefinition ( beanDefinitionName )  ,    descriptor ,    resolver )  ;", "} else", "if    ( containsSingleton ( beanName )  )     {", "return   isAutowireCandidate ( beanName ,    new   RootBeanDefinition ( getType ( beanName )  )  ,    descriptor ,    resolver )  ;", "}", "BeanFactory   parent    =    getParentBeanFactory (  )  ;", "if    ( parent   instanceof   DefaultListableBeanFactory )     {", "return    (  ( DefaultListableBeanFactory )     ( parent )  )  . isAutowireCandidate ( beanName ,    descriptor ,    resolver )  ;", "} else", "if    ( parent   instanceof   config . ConfigurableListableBeanFactory )     {", "return    (  ( config . ConfigurableListableBeanFactory )     ( parent )  )  . isAutowireCandidate ( beanName ,    descriptor )  ;", "} else    {", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["isAutowireCandidate"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "String   beanDefinitionName    =    BeanFactoryUtils . transformedBeanName ( beanName )  ;", "resolveBeanClass ( mbd ,    beanDefinitionName )  ;", "if    ( mbd . isFactoryMethodUnique )     {", "boolean   resolve ;", "synchronized ( mbd . constructorArgumentLock )     {", "resolve    =     ( mbd . resolvedConstructorOrFactoryMethod )     =  =    null ;", "}", "if    ( resolve )     {", "new   ConstructorResolver ( this )  . resolveFactoryMethodIfPossible ( mbd )  ;", "}", "}", "return   resolver . isAutowireCandidate ( new   BeanDefinitionHolder ( mbd ,    beanName ,    getAliases ( beanDefinitionName )  )  ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["isAutowireCandidate"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( containsBeanDefinition ( beanName )  )     {", "return   getMergedLocalBeanDefinition ( beanName )  . isPrimary (  )  ;", "}", "BeanFactory   parent    =    getParentBeanFactory (  )  ;", "return    ( parent   instanceof    )     &  &     (  (  (  )     ( parent )  )  . isPrimary ( beanName ,    beanInstance )  )  ;", "}", "METHOD_END"], "methodName": ["isPrimary"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return   getAutowireCandidateResolver (  )  . isRequired ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( beanName    !  =    null )     &  &     ( candidateName    !  =    null )  )     &  &     (  ( beanName . equals ( candidateName )  )     |  |     (  ( containsBeanDefinition ( candidateName )  )     &  &     ( beanName . equals ( getMergedLocalBeanDefinition ( candidateName )  . getFactoryBeanName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelfReference"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( candidateName    !  =    null )     &  &     (  ( candidateName . equals ( beanName )  )     |  |     ( ObjectUtils . containsElement ( getAliases ( beanName )  ,    candidateName )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchesBeanName"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "checkBeanNotOfRequiredType ( type ,    descriptor )  ;", "throw   new   NoSuchBeanDefinitionException ( resolvableType ,     (  (  \" expected   at   least    1    bean   which   qualifies   as   autowire   candidate .     \"     +     \" Dependency   annotations :     \"  )     +     ( ObjectUtils . nullSafeToString ( descriptor . getAnnotations (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["raiseNoMatchingBeanFound"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "throw   new   NotSerializableException (  (  \" DefaultListableBeanFactory   itself   is   not   deserializable    -     \"     +     \" just   a   SerializedBeanFactoryReference   is \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( factoryBeanName    !  =    null )     &  &     ( isFactoryBean ( factoryBeanName )  )  )     &  &     (  !  ( containsSingleton ( factoryBeanName )  )  )  ;", "}", "METHOD_END"], "methodName": ["requiresEagerInitForType"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "clearMergedBeanDefinitionName )  ;", "destroySingletonName )  ;", "for    ( String   bdName    :    thisDefinitionNames )     {", "if    (  ! Name . equals ( bdName )  )  )     {", "BeanDefinition   bd    =    thisDefinitionMap . get ( bdName )  ;", "if   Name . equals ( bd . getParentName (  )  )  )     {", "resetBeanDefinition ( bdName )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["resetBeanDefinition"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    type    =    descriptor . getDependencyType (  )  ;", "if    ( type . isArray (  )  )     {", "Class <  ?  >    componentType    =    type . getComponentType (  )  ;", "ResolvableType   resolvableType    =    descriptor . getResolvableType (  )  ;", "Class <  ?  >    resolvedArrayType    =    resolvableType . resolve (  )  ;", "if    (  ( resolvedArrayType    !  =    null )     &  &     ( resolvedArrayType    !  =    type )  )     {", "type    =    resolvedArrayType ;", "componentType    =    resolvableType . getComponentType (  )  . resolve (  )  ;", "}", "if    ( componentType    =  =    null )     {", "return   null ;", "}", "Map < String ,    Object >    matchingBeans    =    findAutowireCandidates ( beanName ,    componentType ,    new    . MultiElementDescriptor ( descriptor )  )  ;", "if    ( matchingBeans . isEmpty (  )  )     {", "return   null ;", "}", "if    ( autowiredBeanNames    !  =    null )     {", "autowiredBeanNames . addAll ( matchingBeans . keySet (  )  )  ;", "}", "TypeConverter   converter    =     ( typeConverter    !  =    null )     ?    typeConverter    :    getTypeConverter (  )  ;", "Object   result    =    converter . convertIfNecessary ( matchingBeans . values (  )  ,    type )  ;", "if    (  (  ( getDependencyComparator (  )  )     !  =    null )     &  &     ( result   instanceof   Object [  ]  )  )     {", "Arrays . sort (  (  ( Object [  ]  )     ( result )  )  ,    adaptDependencyComparator ( matchingBeans )  )  ;", "}", "return   result ;", "} else", "if    (  ( isAssignableFrom ( type )  )     &  &     ( type . isInterface (  )  )  )     {", "Class <  ?  >    elementType    =    descriptor . getResolvableType (  )  . asCollection (  )  . resolveGeneric (  )  ;", "if    ( elementType    =  =    null )     {", "return   null ;", "}", "Map < String ,    Object >    matchingBeans    =    findAutowireCandidates ( beanName ,    elementType ,    new    . MultiElementDescriptor ( descriptor )  )  ;", "if    ( matchingBeans . isEmpty (  )  )     {", "return   null ;", "}", "if    ( autowiredBeanNames    !  =    null )     {", "autowiredBeanNames . addAll ( matchingBeans . keySet (  )  )  ;", "}", "TypeConverter   converter    =     ( typeConverter    !  =    null )     ?    typeConverter    :    getTypeConverter (  )  ;", "Object   result    =    converter . convertIfNecessary ( matchingBeans . values (  )  ,    type )  ;", "if    (  (  ( getDependencyComparator (  )  )     !  =    null )     &  &     ( result   instanceof   List )  )     {", "(  ( List <  ?  >  )     ( result )  )  . sort ( adaptDependencyComparator ( matchingBeans )  )  ;", "}", "return   result ;", "} else", "if    (  ( Map . class )     =  =    type )     {", "ResolvableType   mapType    =    descriptor . getResolvableType (  )  . asMap (  )  ;", "Class <  ?  >    keyType    =    mapType . resolveGeneric (  0  )  ;", "if    (  ( String . class )     !  =    keyType )     {", "return   null ;", "}", "Class <  ?  >    valueType    =    mapType . resolveGeneric (  1  )  ;", "if    ( valueType    =  =    null )     {", "return   null ;", "}", "Map < String ,    Object >    matchingBeans    =    findAutowireCandidates ( beanName ,    valueType ,    new    . MultiElementDescriptor ( descriptor )  )  ;", "if    ( matchingBeans . isEmpty (  )  )     {", "return   null ;", "}", "if    ( autowiredBeanNames    !  =    null )     {", "autowiredBeanNames . addAll ( matchingBeans . keySet (  )  )  ;", "}", "return   matchingBeans ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["resolveMultipleBeans"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( requiredType ,     \" Required   type   must   not   be   null \"  )  ;", "String [  ]    candidateNames    =    getBeanNamesForType ( requiredType )  ;", "if    (  ( candidateNames . length )     >     1  )     {", "List < String >    autowireCandidates    =    new   ArrayList <  >  ( candidateNames . length )  ;", "for    ( String   beanName    :    candidateNames )     {", "if    (  (  !  ( containsBeanDefinition ( beanName )  )  )     |  |     ( getBeanDefinition ( beanName )  . isAutowireCandidate (  )  )  )     {", "autowireCandidates . add ( beanName )  ;", "}", "}", "if    (  !  ( autowireCandidates . isEmpty (  )  )  )     {", "candidateNames    =    StringUtils . toStringArray ( autowireCandidates )  ;", "}", "}", "if    (  ( candidateNames . length )     =  =     1  )     {", "String   beanName    =    candidateNames [  0  ]  ;", "return   new   NamedBeanHolder <  >  ( beanName ,    getBean ( beanName ,    requiredType ,    args )  )  ;", "} else", "if    (  ( candidateNames . length )     >     1  )     {", "Map < String ,    Object >    candidates    =    new   LinkedHashMap <  >  ( candidateNames . length )  ;", "for    ( String   beanName    :    candidateNames )     {", "if    (  ( containsSingleton ( beanName )  )     &  &     ( args    =  =    null )  )     {", "Object   beanInstance    =    getBean ( beanName )  ;", "candidates . put ( beanName ,     ( beanInstance   instanceof   NullBean    ?    null    :    beanInstance )  )  ;", "} else    {", "candidates . put ( beanName ,    getType ( beanName )  )  ;", "}", "}", "String   candidateName    =    determinePrimaryCandidate ( candidates ,    requiredType )  ;", "if    ( candidateName    =  =    null )     {", "candidateName    =    determineHighestPriorityCandidate ( candidates ,    requiredType )  ;", "}", "if    ( candidateName    !  =    null )     {", "Object   beanInstance    =    candidates . get ( candidateName )  ;", "if    (  ( beanInstance    =  =    null )     |  |     ( beanInstance   instanceof   Class )  )     {", "beanInstance    =    getBean ( candidateName ,    requiredType ,    args )  ;", "}", "return   new   NamedBeanHolder <  >  ( candidateName ,     (  ( T )     ( beanInstance )  )  )  ;", "}", "throw   new   NoUniqueBeanDefinitionException ( requiredType ,    candidates . keySet (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolveNamedBean"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . allowBeanDefinitionOverriding    =    allowBeanDefinitionOverriding ;", "}", "METHOD_END"], "methodName": ["setAllowBeanDefinitionOverriding"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . allowEagerClassLoading    =    allowEagerClassLoading ;", "}", "METHOD_END"], "methodName": ["setAllowEagerClassLoading"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( autowireCandidateResolver ,     \" AutowireCandidateResolver   must   not   be   null \"  )  ;", "if    ( autowireCandidateResolver   instanceof   Aware )     {", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >     {", "(  ( Aware )     ( autowireCandidateResolver )  )  . set ( this )  ;", "return   null ;", "}  )  )  ,    getAccessControlContext (  )  )  ;", "} else    {", "(  ( Aware )     ( autowireCandidateResolver )  )  . set ( this )  ;", "}", "}", "this . autowireCandidateResolver    =    autowireCandidateResolver ;", "}", "METHOD_END"], "methodName": ["setAutowireCandidateResolver"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "this . dependencyComparator    =    dependencyComparator ;", "}", "METHOD_END"], "methodName": ["setDependencyComparator"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( serializationId    !  =    null )     {", ". serializableFactories . put ( serializationId ,    new   WeakReference <  >  ( this )  )  ;", "} else", "if    (  ( this . serializationId )     !  =    null )     {", ". serializableFactories . remove ( this . serializationId )  ;", "}", "this . serializationId    =    serializationId ;", "}", "METHOD_END"], "methodName": ["setSerializationId"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . serializationId )     !  =    null )     {", "return   new    . SerializedBeanFactoryReference ( this . serializationId )  ;", "} else    {", "throw   new   NotSerializableException (  \"    has   no   serialization   id \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.springframework.beans.factory.support.DefaultListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . singletonObjects )     {", "this . singletonObjects . put ( beanName ,    singletonObject )  ;", "this . singletonFactories . remove ( beanName )  ;", "this . earlyObjects . remove ( beanName )  ;", "this . registereds . add ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["addSingleton"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( singletonFactory ,     \" Singleton   factory   must   not   be   null \"  )  ;", "synchronized ( this . singletonObjects )     {", "if    (  !  ( this . singletonObjects . containsKey ( beanName )  )  )     {", "this . singletonFactories . put ( beanName ,    singletonFactory )  ;", "this . earlySingletonObjects . remove ( beanName )  ;", "this . registeredSingletons . add ( beanName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addSingletonFactory"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . inCreationCheckExclusions . contains ( beanName )  )  )     &  &     (  !  ( this . singletonsCurrentlyInCreation . remove ( beanName )  )  )  )     {", "throw   new   IllegalStateException (  (  (  \"     '  \"     +    beanName )     +     \"  '    isn ' t   currently   in   creation \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterSingletonCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( this . inCreationCheckExclusions . contains ( beanName )  )  )     &  &     (  !  ( this . singletonsCurrentlyInCreation . add ( beanName )  )  )  )     {", "throw   new   BeanCurrentlyInCreationException ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["beforeSingletonCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . singletonObjects )     {", "this . singletonObjects . clear (  )  ;", "this . singletonFactories . clear (  )  ;", "this . earlyObjects . clear (  )  ;", "this . registereds . clear (  )  ;", "this . singletonsCurrentlyInDestruction    =    false ;", "}", "}", "METHOD_END"], "methodName": ["clearSingletonCache"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < String >    dependencies ;", "synchronized ( this . dependentBeanMap )     {", "dependencies    =    this . dependentBeanMap . remove ( beanName )  ;", "}", "if    ( dependencies    !  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Retrieved   dependent   beans   for   bean    '  \"     +    beanName )     +     \"  '  :     \"  )     +    dependencies )  )  ;", "}", "for    ( String   dependentBeanName    :    dependencies )     {", "destroy ( dependentBeanName )  ;", "}", "}", "if    ( bean    !  =    null )     {", "try    {", "bean . destroy (  )  ;", "}    catch    ( Throwable   ex )     {", "logger . error (  (  (  \" Destroy   method   on   bean   with   name    '  \"     +    beanName )     +     \"  '    threw   an   exception \"  )  ,    ex )  ;", "}", "}", "Set < String >    containedBeans ;", "synchronized ( this . containedBeanMap )     {", "containedBeans    =    this . containedBeanMap . remove ( beanName )  ;", "}", "if    ( containedBeans    !  =    null )     {", "for    ( String   containedBeanName    :    containedBeans )     {", "destroy ( containedBeanName )  ;", "}", "}", "synchronized ( this . dependentBeanMap )     {", "for    ( Iterator < Map . Entry < String ,    Set < String >  >  >    it    =    this . dependentBeanMap . entrySet (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "Map . Entry < String ,    Set < String >  >    entry    =    it . next (  )  ;", "Set < String >    dependenciesToClean    =    entry . getValue (  )  ;", "dependenciesToClean . remove ( beanName )  ;", "if    ( dependenciesToClean . isEmpty (  )  )     {", "it . remove (  )  ;", "}", "}", "}", "this . dependenciesForBeanMap . remove ( beanName )  ;", "}", "METHOD_END"], "methodName": ["destroyBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "removeSingleton ( beanName )  ;", "DisposableBean   disposableBean ;", "synchronized ( this . disposableBeans )     {", "disposableBean    =     (  ( DisposableBean )     ( this . disposableBeans . remove ( beanName )  )  )  ;", "}", "destroyBean ( beanName ,    disposableBean )  ;", "}", "METHOD_END"], "methodName": ["destroySingleton"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Destroying   singletons   in    \"     +     ( this )  )  )  ;", "}", "synchronized ( this . singletonObjects )     {", "this . singletonsCurrentlyInDestruction    =    true ;", "}", "String [  ]    disposableBeanNames ;", "synchronized ( this . disposableBeans )     {", "disposableBeanNames    =    StringUtils . toStringArray ( this . disposableBeans . keySet (  )  )  ;", "}", "for    ( int   i    =     ( disposableBeanNames . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "destroy ( disposableBeanNames [ i ]  )  ;", "}", "this . containedBeanMap . clear (  )  ;", "this . dependentBeanMap . clear (  )  ;", "this . dependenciesForBeanMap . clear (  )  ;", "clearCache (  )  ;", "}", "METHOD_END"], "methodName": ["destroySingletons"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < String >    dependenciesForBean    =    this . dependenciesForBeanMap . get ( beanName )  ;", "if    ( dependenciesForBean    =  =    null )     {", "return   new   String [  0  ]  ;", "}", "synchronized ( this . dependenciesForBeanMap )     {", "return   StringUtils . toStringArray ( dependenciesForBean )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependenciesForBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < String >    dependentBeans    =    this . dependentBeanMap . get ( beanName )  ;", "if    ( dependentBeans    =  =    null )     {", "return   new   String [  0  ]  ;", "}", "synchronized ( this . dependentBeanMap )     {", "return   StringUtils . toStringArray ( dependentBeans )  ;", "}", "}", "METHOD_END"], "methodName": ["getDependentBeans"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Object   singletonObject    =    this . singletonObjects . get ( beanName )  ;", "if    (  ( singletonObject    =  =    null )     &  &     ( isCurrentlyInCreation ( beanName )  )  )     {", "synchronized ( this . singletonObjects )     {", "singletonObject    =    this . earlyObjects . get ( beanName )  ;", "if    (  ( singletonObject    =  =    null )     &  &    allowEarlyReference )     {", "ObjectFactory <  ?  >    singletonFactory    =    this . singletonFactories . get ( beanName )  ;", "if    ( singletonFactory    !  =    null )     {", "singletonObject    =    singletonFactory . getObject (  )  ;", "this . earlyObjects . put ( beanName ,    singletonObject )  ;", "this . singletonFactories . remove ( beanName )  ;", "}", "}", "}", "}", "return   singletonObject ;", "}", "METHOD_END"], "methodName": ["getSingleton"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanName ,     \" Bean   name   must   not   be   null \"  )  ;", "synchronized ( this . singletonObjects )     {", "Object   singletonObject    =    this . singletonObjects . get ( beanName )  ;", "if    ( singletonObject    =  =    null )     {", "if    ( this . singletonsCurrentlyInDestruction )     {", "throw   new   BeanCreationNotAllowedException ( beanName ,     (  \"    bean   creation   not   allowed   while   singletons   of   this   factory   are   in   destruction    \"     +     \"  ( Do   not   request   a   bean   from   a   BeanFactory   in   a   destroy   method   implementation !  )  \"  )  )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Creating   shared   instance   of   singleton   bean    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "beforeCreation ( beanName )  ;", "boolean   new    =    false ;", "boolean   recordSuppressedExceptions    =     ( this . suppressedExceptions )     =  =    null ;", "if    ( recordSuppressedExceptions )     {", "this . suppressedExceptions    =    new   LinkedHashSet <  >  (  )  ;", "}", "try    {", "singletonObject    =    singletonFactory . getObject (  )  ;", "new    =    true ;", "}    catch    ( IllegalStateException   ex )     {", "singletonObject    =    this . singletonObjects . get ( beanName )  ;", "if    ( singletonObject    =  =    null )     {", "throw   ex ;", "}", "}    catch    ( BeanCreationException   ex )     {", "if    ( recordSuppressedExceptions )     {", "for    ( Exception   suppressedException    :    this . suppressedExceptions )     {", "ex . addRelatedCause ( suppressedException )  ;", "}", "}", "throw   ex ;", "}    finally    {", "if    ( recordSuppressedExceptions )     {", "this . suppressedExceptions    =    null ;", "}", "afterCreation ( beanName )  ;", "}", "if    ( new )     {", "add ( beanName ,    singletonObject )  ;", "}", "}", "return   singletonObject ;", "}", "}", "METHOD_END"], "methodName": ["getSingleton"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . singletonObjects ;", "}", "METHOD_END"], "methodName": ["getSingletonMutex"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . dependentBeanMap . containsKey ( beanName )  ;", "}", "METHOD_END"], "methodName": ["hasDependentBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "return   isSingletonCurrentlyInCreation ( beanName )  ;", "}", "METHOD_END"], "methodName": ["isActuallyInCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanName ,     \" Bean   name   must   not   be   null \"  )  ;", "return    (  !  ( this . inCreationCheckExclusions . contains ( beanName )  )  )     &  &     ( isActuallyInCreation ( beanName )  )  ;", "}", "METHOD_END"], "methodName": ["isCurrentlyInCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . dependentBeanMap )     {", "return   isDependent ( beanName ,    dependentBeanName ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["isDependent"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( alreadySeen    !  =    null )     &  &     ( alreadySeen . contains ( beanName )  )  )     {", "return   false ;", "}", "String   canonicalName    =    canonicalName ( beanName )  ;", "Set < String >    dependentB =    this . dependentBeanMap . get ( canonicalName )  ;", "if    ( dependentB =  =    null )     {", "return   false ;", "}", "if    ( dependentBcontains ( dependentBeanName )  )     {", "return   true ;", "}", "for    ( String   transitiveDependency    :    dependentB    {", "if    ( alreadySeen    =  =    null )     {", "alreadySeen    =    new   HashSet <  >  (  )  ;", "}", "alreadySeen . add ( beanName )  ;", "if    ( isDependent ( transitiveDependency ,    dependentBeanName ,    alreadySeen )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isDependent"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "return   this . singletonsCurrentlyInCreation . contains ( beanName )  ;", "}", "METHOD_END"], "methodName": ["isSingletonCurrentlyInCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . singletonObjects )     {", "if    (  ( this . suppressedExceptions )     !  =    null )     {", "this . suppressedExceptions . add ( ex )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["onSuppressedException"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . containedBeanMap )     {", "Set < String >    containedB =    this . containedBeanMap . computeIfAbsent ( containingBeanName ,     (    k )     -  >    new   LinkedHashSet <  >  (  8  )  )  ;", "if    (  !  ( containedBadd ( containedBeanName )  )  )     {", "return ;", "}", "}", "registerDependentBean ( containedBeanName ,    containingBeanName )  ;", "}", "METHOD_END"], "methodName": ["registerContainedBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "String   canonicalName    =    canonicalName ( beanName )  ;", "synchronized ( this . dependentBeanMap )     {", "Set < String >    dependentB =    this . dependentBeanMap . computeIfAbsent ( canonicalName ,     (    k )     -  >    new   LinkedHashSet <  >  (  8  )  )  ;", "if    (  !  ( dependentBadd ( dependentBeanName )  )  )     {", "return ;", "}", "}", "synchronized ( this . dependenciesForBeanMap )     {", "Set < String >    dependenciesForBean    =    this . dependenciesForBeanMap . computeIfAbsent ( dependentBeanName ,     (    k )     -  >    new   LinkedHashSet <  >  (  8  )  )  ;", "dependenciesForBean . add ( canonicalName )  ;", "}", "}", "METHOD_END"], "methodName": ["registerDependentBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . disposableB    {", "this . disposableBput ( beanName ,    bean )  ;", "}", "}", "METHOD_END"], "methodName": ["registerDisposableBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . singletonObjects )     {", "this . singletonObjects . remove ( beanName )  ;", "this . singletonFactories . remove ( beanName )  ;", "this . earlyObjects . remove ( beanName )  ;", "this . registereds . remove ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["removeSingleton"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanName ,     \" Bean   name   must   not   be   null \"  )  ;", "if    (  ! inCreation )     {", "this . inCreationCheckExclusions . add ( beanName )  ;", "} else    {", "this . inCreationCheckExclusions . remove ( beanName )  ;", "}", "}", "METHOD_END"], "methodName": ["setCurrentlyInCreation"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistry"}, {"methodBody": ["METHOD_START", "{", "DefaultSingletonBeanRegistry   beanRegistry    =    new   DefaultSingletonBeanRegistry (  )  ;", "beanRegistry . registerDependentBean (  \" a \"  ,     \" b \"  )  ;", "beanRegistry . registerDependentBean (  \" b \"  ,     \" c \"  )  ;", "beanRegistry . registerDependentBean (  \" c \"  ,     \" b \"  )  ;", "assertTrue ( beanRegistry . isDependent (  \" a \"  ,     \" b \"  )  )  ;", "assertTrue ( beanRegistry . isDependent (  \" b \"  ,     \" c \"  )  )  ;", "assertTrue ( beanRegistry . isDependent (  \" c \"  ,     \" b \"  )  )  ;", "assertTrue ( beanRegistry . isDependent (  \" a \"  ,     \" c \"  )  )  ;", "assertFalse ( beanRegistry . isDependent (  \" c \"  ,     \" a \"  )  )  ;", "assertFalse ( beanRegistry . isDependent (  \" b \"  ,     \" a \"  )  )  ;", "assertFalse ( beanRegistry . isDependent (  \" a \"  ,     \" a \"  )  )  ;", "assertTrue ( beanRegistry . isDependent (  \" b \"  ,     \" b \"  )  )  ;", "assertTrue ( beanRegistry . isDependent (  \" c \"  ,     \" c \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testDependentRegistration"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSingletonBeanRegistry   beanRegistry    =    new   DefaultSingletonBeanRegistry (  )  ;", "DerivedTestBean   tb    =    new   DerivedTestBean (  )  ;", "beanRegistry . registerSingleton (  \" tb \"  ,    tb )  ;", "beanRegistry . registerDisposableBean (  \" tb \"  ,    tb )  ;", "assertSame ( tb ,    beanRegistry . getSingleton (  \" tb \"  )  )  ;", "assertSame ( tb ,    beanRegistry . getSingleton (  \" tb \"  )  )  ;", "assertEquals (  1  ,    beanRegistry . getSingletonCount (  )  )  ;", "String [  ]    names    =    beanRegistry . getSingletonNames (  )  ;", "assertEquals (  1  ,    names . length )  ;", "assertEquals (  \" tb \"  ,    names [  0  ]  )  ;", "assertFalse ( tb . wasDestroyed (  )  )  ;", "beanRegistry . destroySingletons (  )  ;", "assertEquals (  0  ,    beanRegistry . getSingletonCount (  )  )  ;", "assertEquals (  0  ,    beanRegistry . getSingletonNames (  )  . length )  ;", "assertTrue ( tb . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDisposableBean"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultSingletonBeanRegistry   beanRegistry    =    new   DefaultSingletonBeanRegistry (  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "beanRegistry . registerSingleton (  \" tb \"  ,    tb )  ;", "assertSame ( tb ,    beanRegistry . getSingleton (  \" tb \"  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( beanRegistry . getSingleton (  \" tb 2  \"  ,    new   ObjectFactory < Object >  (  )     {", "@ Override", "public   Object   getObject (  )    throws   BeansException    {", "return   new   TestBean (  )  ;", "}", "}  )  )  )  ;", "assertSame ( tb 2  ,    beanRegistry . getSingleton (  \" tb 2  \"  )  )  ;", "assertSame ( tb ,    beanRegistry . getSingleton (  \" tb \"  )  )  ;", "assertSame ( tb 2  ,    beanRegistry . getSingleton (  \" tb 2  \"  )  )  ;", "assertEquals (  2  ,    beanRegistry . getSingletonCount (  )  )  ;", "String [  ]    names    =    beanRegistry . getSingletonNames (  )  ;", "assertEquals (  2  ,    names . length )  ;", "assertEquals (  \" tb \"  ,    names [  0  ]  )  ;", "assertEquals (  \" tb 2  \"  ,    names [  1  ]  )  ;", "beanRegistry . destroySingletons (  )  ;", "assertEquals (  0  ,    beanRegistry . getSingletonCount (  )  )  ;", "assertEquals (  0  ,    beanRegistry . getSingletonNames (  )  . length )  ;", "}", "METHOD_END"], "methodName": ["testSingletons"], "fileName": "org.springframework.beans.factory.support.DefaultSingletonBeanRegistryTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Should   be   equal \"  ,    master ,    equal )  ;", "assertEquals (  \" Hash   code   for   equal   instances   should   match \"  ,    master . h (  )  ,    equal . h (  )  )  ;", "assertNotEquals (  \" Should   not   be   equal \"  ,    master ,    notEqual )  ;", "assertNotEquals (  \" Hash   code   for   non - equal   instances   should   not   match \"  ,    master . h (  )  ,    notEqual . h (  )  )  ;", "assertEquals (  \" Subclass   should   be   equal \"  ,    master ,    subclass )  ;", "assertEquals (  \" Hash   code   for   subclass   should   match \"  ,    master . h (  )  ,    subclass . h (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertEqualsAndHashCodeContracts"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "ChildBeanDefinition   master    =    new   ChildBeanDefinition (  \" foo \"  )  ;", "ChildBeanDefinition   equal    =    new   ChildBeanDefinition (  \" foo \"  )  ;", "ChildBeanDefinition   notEqual    =    new   ChildBeanDefinition (  \" bar \"  )  ;", "ChildBeanDefinition   subclass    =    new   ChildBeanDefinition (  \" foo \"  )     {  }  ;", "setBaseProperties ( master )  ;", "setBaseProperties ( equal )  ;", "setBaseProperties ( notEqual )  ;", "setBaseProperties ( subclass )  ;", "assertEqualsAndHashCodeContracts ( master ,    equal ,    notEqual ,    subclass )  ;", "}", "METHOD_END"], "methodName": ["childBeanDefinition"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   master    =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   equal    =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   notEqual    =    new   RootBeanDefinition ( String . class )  ;", "RootBeanDefinition   subclass    =    new   RootBeanDefinition ( TestBean . class )     {  }  ;", "setBaseProperties ( master )  ;", "setBaseProperties ( equal )  ;", "setBaseProperties ( notEqual )  ;", "setBaseProperties ( subclass )  ;", "assertEqualsAndHashCodeContracts ( master ,    equal ,    notEqual ,    subclass )  ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinition"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "RootBeanDefinition   master    =    new   RootBeanDefinition ( TestBean . class )  ;", "RootBeanDefinition   equal    =    new   RootBeanDefinition ( TestBean . class )  ;", "setBaseProperties ( master )  ;", "setBaseProperties ( equal )  ;", "master . getMethodOverrides (  )  . getOverrides (  )  . iterator (  )  . next (  )  . setOverloaded ( false )  ;", "assertEquals (  \" Should   be   equal \"  ,    master ,    equal )  ;", "assertEquals (  \" Hash   code   for   equal   instances   must   match \"  ,    master . hashCode (  )  ,    equal . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["rootBeanDefinitionAndMethodOverridesWithDifferentOverloadedValues"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "RuntimeBeanReference   master    =    new   RuntimeBeanReference (  \" name \"  )  ;", "RuntimeBeanReference   equal    =    new   RuntimeBeanReference (  \" name \"  )  ;", "RuntimeBeanReference   notEqual    =    new   RuntimeBeanReference (  \" someOtherName \"  )  ;", "RuntimeBeanReference   subclass    =    new   RuntimeBeanReference (  \" name \"  )     {  }  ;", "assertEqualsAndContracts ( master ,    equal ,    notEqual ,    subclass )  ;", "}", "METHOD_END"], "methodName": ["runtimeBeanReference"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "definition . setAbstract ( true )  ;", "definition . setAttribute (  \" foo \"  ,     \" bar \"  )  ;", "definition . setAutowireCandidate ( false )  ;", "definition . setAutowireMode ( AbstractBean . AUTOWIRE _ BY _ TYPE )  ;", "definition . setDependencyCheck ( AbstractBean . DEPENDENCY _ CHECK _ OBJECTS )  ;", "definition . setDependsOn ( new   String [  ]  {     \" foo \"  ,     \" bar \"     }  )  ;", "definition . setDestroyMethodName (  \" destroy \"  )  ;", "definition . setEnforceDestroyMethod ( false )  ;", "definition . setEnforceInitMethod ( true )  ;", "definition . setFactoryBeanName (  \" factoryBean \"  )  ;", "definition . setFactoryMethodName (  \" factoryMethod \"  )  ;", "definition . setInitMethodName (  \" init \"  )  ;", "definition . setLazyInit ( true )  ;", "definition . getMethodOverrides (  )  . addOverride ( new   LookupOverride (  \" foo \"  ,     \" bar \"  )  )  ;", "definition . getMethodOverrides (  )  . addOverride ( new   ReplaceOverride (  \" foo \"  ,     \" bar \"  )  )  ;", "definition . getPropertyValues (  )  . add (  \" foo \"  ,     \" bar \"  )  ;", "definition . setResourceDescription (  \" desc \"  )  ;", "definition . setRole ( Bean . ROLE _ APPLICATION )  ;", "definition . setScope ( Bean . SCOPE _ PROTOTYPE )  ;", "definition . setSource (  \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["setBaseProperties"], "fileName": "org.springframework.beans.factory.support.DefinitionMetadataEqualsHashCodeTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < Method >  )     (  (  )     -  >    findDestroyMethod ( name )  )  )  )  ;", "} else    {", "return   findDestroyMethod ( name )  ;", "}", "}    catch    ( IllegalArgumentException   ex )     {", "throw   new   BeanDefinitionValidationException (  (  (  (  \" Could   not   find   unique   destroy   method   on   with   name    '  \"     +     ( thisName )  )     +     \"  :     \"  )     +     ( ex . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["determineDestroyMethod"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "List < DestructionAwareBeanPostProcessor >    filteredPostProcessors    =    null ;", "if    (  !  ( CollectionUtils . isEmpty ( processors )  )  )     {", "filteredPostProcessors    =    new   ArrayList <  >  ( processors . size (  )  )  ;", "for    ( BeanPostProcessor   processor    :    processors )     {", "if    ( processor   instanceof   DestructionAwareBeanPostProcessor )     {", "DestructionAwareBeanPostProcessor   dabpp    =     (  ( DestructionAwareBeanPostProcessor )     ( processor )  )  ;", "if    ( dabpp . requiresDestruction ( bean )  )     {", "filteredPostProcessors . add ( dabpp )  ;", "}", "}", "}", "}", "return   filteredPostProcessors ;", "}", "METHOD_END"], "methodName": ["filterPostProcessors"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "return   this . nonPublicAccessAllowed    ?    BeanUtils . findMethodWithMinimalParameters ( this . bean . getClass (  )  ,    name )     :    BeanUtils . findMethodWithMinimalParameters ( this . bean . getClass (  )  . getMethods (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["findDestroyMethod"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( CollectionUtils . isEmpty ( postProcessors )  )  )     {", "for    ( BeanPostProcessor   processor    :    postProcessors )     {", "if    ( processor   instanceof   DestructionAwarPostProcessor )     {", "DestructionAwarPostProcessor   dabpp    =     (  ( DestructionAwarPostProcessor )     ( processor )  )  ;", "if    ( dabpp . requiresDestruction ( bean )  )     {", "return   true ;", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasApplicableProcessors"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bean   instanceof   DisposableBean )     |  |     ( bean   instanceof   AutoCloseable )  )     {", "return   true ;", "}", "String   destroyMethodName    =    beanDefinition . getDestroyMethodName (  )  ;", "if    ( AbstractBeanDefinition . INFER _ METHOD . equals ( destroyMethodName )  )     {", "return    ( ClassUtils . hasMethod ( bean . getClass (  )  ,     . CLOSE _ METHOD _ NAME )  )     |  |     ( ClassUtils . hasMethod ( bean . getClass (  )  ,     . SHUTDOWN _ METHOD _ NAME )  )  ;", "}", "return   StringUtils . hasLength ( destroyMethodName )  ;", "}", "METHOD_END"], "methodName": ["hasDestroyMethod"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "String   destroyMethodName    =    beanDefinition . getDestroyMethodName (  )  ;", "if    (  ( AbstractBeanDefinition . INFER _ METHOD . equals ( destroyMethodName )  )     |  |     (  ( destroyMethodName    =  =    null )     &  &     ( bean   instanceof   AutoCloseable )  )  )     {", "if    (  !  ( bean   instanceof   DisposableBean )  )     {", "try    {", "return   bean . getClass (  )  . getMethod (  . CLOSE _ METHOD _ NAME )  . getName (  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "try    {", "return   bean . getClass (  )  . getMethod (  . SHUTDOWN _ METHOD _ NAME )  . getName (  )  ;", "}    catch    ( NoSuchMethodException   ex 2  )     {", "}", "}", "}", "return   null ;", "}", "return   StringUtils . hasLength ( destroyMethodName )     ?    destroyMethodName    :    null ;", "}", "METHOD_END"], "methodName": ["inferDestroyMethodIfNecessary"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    paramTypes    =    destroyMethod . getParameterTypes (  )  ;", "final   Object [  ]    args    =    new   Object [ paramTypes . length ]  ;", "if    (  ( paramTypes . length )     =  =     1  )     {", "args [  0  ]     =    Boolean . TRUE ;", "}", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  (  (  \" Invoking   destroy   method    '  \"     +     ( this . destroyMethodName )  )     +     \"  '    on   bean   with   name    '  \"  )     +     ( this . beanName )  )     +     \"  '  \"  )  )  ;", "}", "try    {", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "AccessController . doPrivileged (  (  ( PrivilegedAction < Object >  )     (  (  )     -  >     {", "ReflectionUtils . makeAccessible ( destroyMethod )  ;", "return   null ;", "}  )  )  )  ;", "try    {", "AccessController . doPrivileged (  (  ( PrivilegedExceptionAction < Object >  )     (  (  )     -  >    destroyMethod . invoke ( bean ,    args )  )  )  ,    acc )  ;", "}    catch    ( PrivilegedActionException   pax )     {", "throw    (  ( InvocationTargetException )     ( pax . getException (  )  )  )  ;", "}", "} else    {", "ReflectionUtils . makeAccessible ( destroyMethod )  ;", "destroyMethod . invoke ( bean ,    args )  ;", "}", "}    catch    ( InvocationTargetException   ex )     {", "String   msg    =     (  (  (  \" Invocation   of   destroy   method    '  \"     +     ( this . destroyMethodName )  )     +     \"  '    failed   on   bean   with   name    '  \"  )     +     ( this . beanName )  )     +     \"  '  \"  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . warn ( msg ,    ex . getTargetException (  )  )  ;", "} else    {", ". logger . warn (  (  ( msg    +     \"  :     \"  )     +     ( ex . getTargetException (  )  )  )  )  ;", "}", "}    catch    ( Throwable   ex )     {", ". logger . error (  (  (  (  (  \" Couldn ' t   invoke   destroy   method    '  \"     +     ( this . destroyMethodName )  )     +     \"  '    on   bean   with   name    '  \"  )     +     ( this . beanName )  )     +     \"  '  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeCustomDestroyMethod"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "List < DestructionAwareBeanPostProcessor >    serializablePostProcessors    =    null ;", "if    (  ( this . beanPostProcessors )     !  =    null )     {", "serializablePostProcessors    =    new   ArrayList <  >  (  )  ;", "for    ( DestructionAwareBeanPostProcessor   postProcessor    :    this . beanPostProcessors )     {", "if    ( postProcessor   instanceof   Serializable )     {", "serializablePostProcessors . add ( postProcessor )  ;", "}", "}", "}", "return   new    ( this . bean ,    this . beanName ,    this . invokeDisposableBean ,    this . nonPublicAccessAllowed ,    this . destroyMethodName ,    serializablePostProcessors )  ;", "}", "METHOD_END"], "methodName": ["writeReplace"], "fileName": "org.springframework.beans.factory.support.DisposableBeanAdapter"}, {"methodBody": ["METHOD_START", "{", "Object   object ;", "try    {", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "AccessControlContext   acc    =    getAccessControlContext (  )  ;", "try    {", "object    =    AccessController . doPrivileged (  (  ( PrivilegedExceptionAction < Object >  )     ( factory :  : getObject )  )  ,    acc )  ;", "}    catch    ( PrivilegedActionException   pae )     {", "throw   pae . getException (  )  ;", "}", "} else    {", "object    =    factory . getObject (  )  ;", "}", "}    catch    ( NotInitializedException   ex )     {", "throw   new   BeanCurrentlyInCreationException ( beanName ,    ex . toString (  )  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( beanName ,     \"    threw   exception   on   object   creation \"  ,    ex )  ;", "}", "if    ( object    =  =    null )     {", "if    ( isSingletonCurrentlyInCreation ( beanName )  )     {", "throw   new   BeanCurrentlyInCreationException ( beanName ,     \"    which   is   currently   in   creation   returned   null   from   getObject \"  )  ;", "}", "object    =    new   NullBean (  )  ;", "}", "return   object ;", "}", "METHOD_END"], "methodName": ["doGetObjectFromFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "return   AccessController . getContext (  )  ;", "}", "METHOD_END"], "methodName": ["getAccessControlContext"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "return   this . factoryBeanObjectCache . get ( beanName )  ;", "}", "METHOD_END"], "methodName": ["getCachedObjectForFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( beanInstance   instanceof   FactoryBean )  )     {", "throw   new   BeanCreationException ( beanName ,     (  (  \" Bean   instance   of   type    [  \"     +     ( beanInstance . getClass (  )  )  )     +     \"  ]    is   not   a   FactoryBean \"  )  )  ;", "}", "return    (  ( FactoryBean <  ?  >  )     ( beanInstance )  )  ;", "}", "METHOD_END"], "methodName": ["getFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  ( factory . isSingleton (  )  )     &  &     ( containsSingleton ( beanName )  )  )     {", "synchronized ( getSingletonMutex (  )  )     {", "Object   object    =    this . factoryBeanObjectCache . get ( beanName )  ;", "if    ( object    =  =    null )     {", "object    =    doGetObjectFrom ( factory ,    beanName )  ;", "Object   alreadyThere    =    this . factoryBeanObjectCache . get ( beanName )  ;", "if    ( alreadyThere    !  =    null )     {", "object    =    alreadyThere ;", "} else    {", "if    ( shouldPostProcess )     {", "try    {", "object    =    postProcessObjectFrom ( object ,    beanName )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( beanName ,     \" Post - processing   of    ' s   singleton   object   failed \"  ,    ex )  ;", "}", "}", "if    ( containsSingleton ( beanName )  )     {", "this . factoryBeanObjectCache . put ( beanName ,    object )  ;", "}", "}", "}", "return   object ;", "}", "} else    {", "Object   object    =    doGetObjectFrom ( factory ,    beanName )  ;", "if    ( shouldPostProcess )     {", "try    {", "object    =    postProcessObjectFrom ( object ,    beanName )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanCreationException ( beanName ,     \" Post - processing   of    ' s   object   failed \"  ,    ex )  ;", "}", "}", "return   object ;", "}", "}", "METHOD_END"], "methodName": ["getObjectFromFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( System . getSecurityManager (  )  )     !  =    null )     {", "return   AccessController . doPrivileged (  (  ( PrivilegedAction < Class <  ?  >  >  )     ( factoryBean :  : getObjectType )  )  ,    getAccessControlContext (  )  )  ;", "} else    {", "return   factoryBean . getObjectType (  )  ;", "}", "}    catch    ( Throwable   ex )     {", "logger . warn (  (  \"    threw   exception   from   getObjectType ,    despite   the   contract   saying    \"     +     \" that   it   should   return   null   if   the   type   of   its   object   cannot   be   determined   yet \"  )  ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getTypeForFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "return   object ;", "}", "METHOD_END"], "methodName": ["postProcessObjectFromFactoryBean"], "fileName": "org.springframework.beans.factory.support.FactoryBeanRegistrySupport"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   dependencyType    =    descriptor . getResolvableType (  )  ;", "if    (  ( dependencyType . getType (  )  )    instanceof   Class )     {", "return   true ;", "}", "ResolvableType   targetType    =    null ;", "boolean   cacheType    =    false ;", "RootBeanDefinition   rbd    =    null ;", "if    (  ( bdHolder . getBeanDefinition (  )  )    instanceof   RootBeanDefinition )     {", "rbd    =     (  ( RootBeanDefinition )     ( bdHolder . getBeanDefinition (  )  )  )  ;", "}", "if    ( rbd    !  =    null )     {", "targetType    =    rbd . targetType ;", "if    ( targetType    =  =    null )     {", "cacheType    =    true ;", "targetType    =    getReturnTypeForFactoryMethod ( rbd ,    descriptor )  ;", "if    ( targetType    =  =    null )     {", "RootBeanDefinition   dbd    =    getdDecoratedDefinition ( rbd )  ;", "if    ( dbd    !  =    null )     {", "targetType    =    dbd . targetType ;", "if    ( targetType    =  =    null )     {", "targetType    =    getReturnTypeForFactoryMethod ( dbd ,    descriptor )  ;", "}", "}", "}", "}", "}", "if    ( targetType    =  =    null )     {", "if    (  ( this . beanFactory )     !  =    null )     {", "Class <  ?  >    beanType    =    this . beanFactory . getType ( bdHolder . getBeanName (  )  )  ;", "if    ( beanType    !  =    null )     {", "targetType    =    ResolvableType . forClass ( ClassUtils . getUserClass ( beanType )  )  ;", "}", "}", "if    (  (  (  ( targetType    =  =    null )     &  &     ( rbd    !  =    null )  )     &  &     ( rbd . hasBeanClass (  )  )  )     &  &     (  ( rbd . getFactoryMethodName (  )  )     =  =    null )  )     {", "Class <  ?  >    beanClass    =    rbd . getBeanClass (  )  ;", "if    (  !  ( FactoryBean . class . isAssignableFrom ( beanClass )  )  )     {", "targetType    =    ResolvableType . forClass ( ClassUtils . getUserClass ( beanClass )  )  ;", "}", "}", "}", "if    ( targetType    =  =    null )     {", "return   true ;", "}", "if    ( cacheType )     {", "rbd . targetType    =    targetType ;", "}", "if    (  ( descriptor . fallbackMatchAllowed (  )  )     &  &     ( targetType . hasUnresolvableGenerics (  )  )  )     {", "return   true ;", "}", "return   dependencyType . isAssignableFrom ( targetType )  ;", "}", "METHOD_END"], "methodName": ["checkGenericTypeMatch"], "fileName": "org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "return   this . beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionHolder   decDef    =    rbd . getDecoratedDefinition (  )  ;", "if    (  ( decDef    !  =    null )     &  &     (  ( this . beanF )    instanceof   ConfigurableListableBeanF )  )     {", "ConfigurableListableBeanF   clbf    =     (  ( ConfigurableListableBeanF )     ( this . beanF )  )  ;", "if    ( clbf . containsBeanDefinition ( decDef . getBeanName (  )  )  )     {", "BeanDefinition   dbd    =    clbf . getMergedBeanDefinition ( decDef . getBeanName (  )  )  ;", "if    ( dbd   instanceof   RootBeanDefinition )     {", "return    (  ( RootBeanDefinition )     ( dbd )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getResolvedDecoratedDefinition"], "fileName": "org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "ResolvableType   returnType    =    rbd . factoryMethodReturnType ;", "if    ( returnType    =  =    null )     {", "Method   factoryMethod    =    rbd . getResolvedFactoryMethod (  )  ;", "if    ( factoryMethod    !  =    null )     {", "returnType    =    ResolvableType . forMethodReturnType ( factoryMethod )  ;", "}", "}", "if    ( returnType    !  =    null )     {", "Class <  ?  >    resolvedClass    =    returnType . resolve (  )  ;", "if    (  ( resolvedClass    !  =    null )     &  &     ( descriptor . getDependencyType (  )  . isAssignableFrom ( resolvedClass )  )  )     {", "return   returnType ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getReturnTypeForFactoryMethod"], "fileName": "org.springframework.beans.factory.support.GenericTypeAwareAutowireCandidateResolver"}, {"methodBody": ["METHOD_START", "{", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" l . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . getOneArgument (  \" haha \"  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithOneConstructorArg"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . get (  \" haha \"  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithOverloadedArg"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" extendedBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . getOneArgument (  \" haha \"  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "assertTrue ( expected . isJedi (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithOverriddenLookupMethod"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "try    {", "bean . getThreeArguments (  \" name \"  ,     1  ,     2  )  ;", "fail (  \" TestBean   does   not   have   a   three   arg   constructor   so   this   should   not   have   worked \"  )  ;", "}    catch    ( AbstractMethodError   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testWithThreeArgsShouldFail"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "TestBean   expected    =    bean . getTwoArguments (  \" haha \"  ,     7  2  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "assertEquals (  \" haha \"  ,    expected . getName (  )  )  ;", "assertEquals (  7  2  ,    expected . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithTwoConstructorArg"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "LookupMethodTests . AbstractBean   bean    =     (  ( LookupMethodTests . AbstractBean )     ( beanFactory . getBean (  \" abstractBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "Object   expected    =    bean . get (  )  ;", "assertEquals ( TestBean . class ,    expected . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithoutConstructorArg"], "fileName": "org.springframework.beans.factory.support.LookupMethodTests"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.support.LookupOverride"}, {"methodBody": ["METHOD_START", "{", "return   this . elementTypeName ;", "}", "METHOD_END"], "methodName": ["getElementTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedList"}, {"methodBody": ["METHOD_START", "{", "this . elementTypeName    =    elementTypeName ;", "}", "METHOD_END"], "methodName": ["setElementTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedList"}, {"methodBody": ["METHOD_START", "{", "this . mergeEnabled    =    mergeEnabled ;", "}", "METHOD_END"], "methodName": ["setMergeEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedList"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.support.ManagedList"}, {"methodBody": ["METHOD_START", "{", "ManagedList   parent    =    new   ManagedList (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedList   child    =    new   ManagedList (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "List   mergedList    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     3  ,    mergedList . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeChildValuesOverrideTheParents"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList   parent    =    new   ManagedList (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedList   child    =    new   ManagedList (  )  ;", "child . setMergeEnabled ( true )  ;", "List   mergedList    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedList . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeEmptyChild"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList   child    =    new   ManagedList (  )  ;", "child . merge ( null )  ;", "}", "METHOD_END"], "methodName": ["mergeNotAllowedWhenMergeNotEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList   parent    =    new   ManagedList (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedList   child    =    new   ManagedList (  )  ;", "child . add (  \" three \"  )  ;", "child . setMergeEnabled ( true )  ;", "List   mergedList    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     3  ,    mergedList . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSunnyDay"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList   child    =    new   ManagedList (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "child . merge (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNonCompatibleParentType"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "ManagedList   child    =    new   ManagedList (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "assertSame ( child ,    child . merge ( null )  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNullParent"], "fileName": "org.springframework.beans.factory.support.ManagedListTests"}, {"methodBody": ["METHOD_START", "{", "return   this . keyTypeName ;", "}", "METHOD_END"], "methodName": ["getKeyTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "return   this . valueTypeName ;", "}", "METHOD_END"], "methodName": ["getValueTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "this . keyTypeName    =    keyTypeName ;", "}", "METHOD_END"], "methodName": ["setKeyTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "this . mergeEnabled    =    mergeEnabled ;", "}", "METHOD_END"], "methodName": ["setMergeEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "this . valueTypeName    =    valueTypeName ;", "}", "METHOD_END"], "methodName": ["setValueTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedMap"}, {"methodBody": ["METHOD_START", "{", "ManagedMap   parent    =    new   ManagedMap (  )  ;", "parent . put (  \" one \"  ,     \" one \"  )  ;", "parent . put (  \" two \"  ,     \" two \"  )  ;", "ManagedMap   child    =    new   ManagedMap (  )  ;", "child . put (  \" one \"  ,     \" fork \"  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedMap . size (  )  )  ;", "assertEquals (  \" Parent   value   not   being   overridden   during   merge (  )  .  \"  ,     \" fork \"  ,    mergedMap . get (  \" one \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeChildValuesOverrideTheParents"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "ManagedMap   parent    =    new   ManagedMap (  )  ;", "parent . put (  \" one \"  ,     \" one \"  )  ;", "parent . put (  \" two \"  ,     \" two \"  )  ;", "ManagedMap   child    =    new   ManagedMap (  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedMap . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeEmptyChild"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "new   ManagedMap (  )  . merge ( null )  ;", "}", "METHOD_END"], "methodName": ["mergeNotAllowedWhenMergeNotEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "ManagedMap   parent    =    new   ManagedMap (  )  ;", "parent . put (  \" one \"  ,     \" one \"  )  ;", "parent . put (  \" two \"  ,     \" two \"  )  ;", "ManagedMap   child    =    new   ManagedMap (  )  ;", "child . put (  \" three \"  ,     \" three \"  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     3  ,    mergedMap . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSunnyDay"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "ManagedMap   map    =    new   ManagedMap (  )  ;", "map . setMergeEnabled ( true )  ;", "map . merge (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNonCompatibleParentType"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "ManagedMap   child    =    new   ManagedMap (  )  ;", "child . setMergeEnabled ( true )  ;", "assertSame ( child ,    child . merge ( null )  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNullParent"], "fileName": "org.springframework.beans.factory.support.ManagedMapTests"}, {"methodBody": ["METHOD_START", "{", "this . mergeEnabled    =    mergeEnabled ;", "}", "METHOD_END"], "methodName": ["setMergeEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedProperties"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.support.ManagedProperties"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   parent    =    new   ManagedProperties (  )  ;", "parent . setProperty (  \" one \"  ,     \" one \"  )  ;", "parent . setProperty (  \" two \"  ,     \" two \"  )  ;", "ManagedProperties   child    =    new   ManagedProperties (  )  ;", "child . setProperty (  \" one \"  ,     \" fork \"  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedMap . size (  )  )  ;", "assertEquals (  \" Parent   value   not   being   overridden   during   merge (  )  .  \"  ,     \" fork \"  ,    mergedMap . get (  \" one \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeChildValuesOverrideTheParents"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   parent    =    new   ManagedProperties (  )  ;", "parent . setProperty (  \" one \"  ,     \" one \"  )  ;", "parent . setProperty (  \" two \"  ,     \" two \"  )  ;", "ManagedProperties   child    =    new   ManagedProperties (  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedMap . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeEmptyChild"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   map    =    new   ManagedProperties (  )  ;", "map . merge ( null )  ;", "}", "METHOD_END"], "methodName": ["mergeNotAllowedWhenMergeNotEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   parent    =    new   ManagedProperties (  )  ;", "parent . setProperty (  \" one \"  ,     \" one \"  )  ;", "parent . setProperty (  \" two \"  ,     \" two \"  )  ;", "ManagedProperties   child    =    new   ManagedProperties (  )  ;", "child . setProperty (  \" three \"  ,     \" three \"  )  ;", "child . setMergeEnabled ( true )  ;", "Map   mergedMap    =     (  ( Map )     ( child . merge ( parent )  )  )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     3  ,    mergedMap . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSunnyDay"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   map    =    new   ManagedProperties (  )  ;", "map . setMergeEnabled ( true )  ;", "map . merge (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNonCompatibleParentType"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   child    =    new   ManagedProperties (  )  ;", "child . setMergeEnabled ( true )  ;", "assertSame ( child ,    child . merge ( null )  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNullParent"], "fileName": "org.springframework.beans.factory.support.ManagedPropertiesTests"}, {"methodBody": ["METHOD_START", "{", "return   this . elementTypeName ;", "}", "METHOD_END"], "methodName": ["getElementTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedSet"}, {"methodBody": ["METHOD_START", "{", "this . elementTypeName    =    elementTypeName ;", "}", "METHOD_END"], "methodName": ["setElementTypeName"], "fileName": "org.springframework.beans.factory.support.ManagedSet"}, {"methodBody": ["METHOD_START", "{", "this . mergeEnabled    =    mergeEnabled ;", "}", "METHOD_END"], "methodName": ["setMergeEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedSet"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.support.ManagedSet"}, {"methodBody": ["METHOD_START", "{", "ManagedSet   parent    =    new   ManagedSet (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedSet   child    =    new   ManagedSet (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "Set   mergedSet    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedSet . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeChildValuesOverrideTheParents"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "ManagedSet   parent    =    new   ManagedSet (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedSet   child    =    new   ManagedSet (  )  ;", "child . setMergeEnabled ( true )  ;", "Set   mergedSet    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     2  ,    mergedSet . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeEmptyChild"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "new   ManagedSet (  )  . merge ( null )  ;", "}", "METHOD_END"], "methodName": ["mergeNotAllowedWhenMergeNotEnabled"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "ManagedSet   parent    =    new   ManagedSet (  )  ;", "parent . add (  \" one \"  )  ;", "parent . add (  \" two \"  )  ;", "ManagedSet   child    =    new   ManagedSet (  )  ;", "child . add (  \" three \"  )  ;", "child . setMergeEnabled ( true )  ;", "Set   mergedSet    =    child . merge ( parent )  ;", "assertEquals (  \" merge (  )    obviously   did   not   work .  \"  ,     3  ,    mergedSet . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSunnyDay"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "ManagedSet   child    =    new   ManagedSet (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "child . merge (  \" hello \"  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNonCompatibleParentType"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "ManagedSet   child    =    new   ManagedSet (  )  ;", "child . add (  \" one \"  )  ;", "child . setMergeEnabled ( true )  ;", "assertSame ( child ,    child . merge ( null )  )  ;", "}", "METHOD_END"], "methodName": ["mergeWithNullParent"], "fileName": "org.springframework.beans.factory.support.ManagedSetTests"}, {"methodBody": ["METHOD_START", "{", "return   this . methodName ;", "}", "METHOD_END"], "methodName": ["getMethodName"], "fileName": "org.springframework.beans.factory.support.MethodOverride"}, {"methodBody": ["METHOD_START", "{", "return   this . overloaded ;", "}", "METHOD_END"], "methodName": ["isOverloaded"], "fileName": "org.springframework.beans.factory.support.MethodOverride"}, {"methodBody": ["METHOD_START", "{", "this . overloaded    =    overloaded ;", "}", "METHOD_END"], "methodName": ["setOverloaded"], "fileName": "org.springframework.beans.factory.support.MethodOverride"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.support.MethodOverride"}, {"methodBody": ["METHOD_START", "{", "this . modified    =    true ;", "this . o . add ( override )  ;", "}", "METHOD_END"], "methodName": ["addOverride"], "fileName": "org.springframework.beans.factory.support.MethodOverrides"}, {"methodBody": ["METHOD_START", "{", "if    ( other    !  =    null )     {", "this . modified    =    true ;", "this . o . addAll ( other . o )  ;", "}", "}", "METHOD_END"], "methodName": ["addOverrides"], "fileName": "org.springframework.beans.factory.support.MethodOverrides"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . modified )  )     {", "return   null ;", "}", "synchronized ( this . overrides )     {", "match    =    null ;", "for    (    candidate    :    this . overrides )     {", "if    ( candidate . matches ( method )  )     {", "match    =    candidate ;", "}", "}", "return   match ;", "}", "}", "METHOD_END"], "methodName": ["getOverride"], "fileName": "org.springframework.beans.factory.support.MethodOverrides"}, {"methodBody": ["METHOD_START", "{", "this . modified    =    true ;", "return   this . o ;", "}", "METHOD_END"], "methodName": ["getOverrides"], "fileName": "org.springframework.beans.factory.support.MethodOverrides"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( this . modified )  )     |  |     ( this . overrides . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.springframework.beans.factory.support.MethodOverrides"}, {"methodBody": ["METHOD_START", "{", "return   this . defaultParentBean ;", "}", "METHOD_END"], "methodName": ["getDefaultParentBean"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . propertiesPersister ;", "}", "METHOD_END"], "methodName": ["getPropertiesPersister"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   loadBeanDefinitions ( new   EncodedResource ( resource )  ,    prefix )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   loadBeanDefinitions ( encodedResource ,    null )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "try    {", "try    ( InputStream   is    =    encodedResource . getResource (  )  . getInputStream (  )  )     {", "if    (  ( encodedResource . getEncoding (  )  )     !  =    null )     {", "getPropertiesPersister (  )  . load ( props ,    new   InputStreamReader ( is ,    encodedResource . getEncoding (  )  )  )  ;", "} else    {", "getPropertiesPersister (  )  . load ( props ,    is )  ;", "}", "}", "return   registers ( props ,    prefix ,    encodedResource . getResource (  )  . getDescription (  )  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   StoreException (  (  \" Could   not   parse   properties   from    \"     +     ( encodedResource . getResource (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Object   val    =    entry . getValue (  )  ;", "if    ( val   instanceof   String )     {", "String   strVal    =     (  ( String )     ( val )  )  ;", "if    ( strVal . startsWith (  . REF _ PREFIX )  )     {", "String   targetName    =    strVal . substring (  1  )  ;", "if    ( targetName . startsWith (  . REF _ PREFIX )  )     {", "val    =    targetName ;", "} else    {", "val    =    new   RuntimeBeanReference ( targetName )  ;", "}", "}", "}", "return   val ;", "}", "METHOD_END"], "methodName": ["readValue"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "String   className    =    null ;", "String   parent    =    null ;", "String   scope    =    GenericBeanDefinition . SCOPE _ SINGLETON ;", "boolean   isAbstract    =    false ;", "boolean   lazyInit    =    false ;", "ConstructorArgumentValues   cas    =    new   ConstructorArgumentValues (  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    map . entrySet (  )  )     {", "String   key    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getKey (  )  )  )  )  ;", "if    ( key . startsWith (  ( prefix    +     ( PropertiesBeanDefinitionReader . SEPARATOR )  )  )  )     {", "String   property    =    key . substring (  (  ( prefix . length (  )  )     +     ( PropertiesBeanDefinitionReader . SEPARATOR . length (  )  )  )  )  ;", "if    ( PropertiesBeanDefinitionReader . CLASS _ KEY . equals ( property )  )     {", "className    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "} else", "if    ( PropertiesBeanDefinitionReader . PARENT _ KEY . equals ( property )  )     {", "parent    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "} else", "if    ( PropertiesBeanDefinitionReader . ABSTRACT _ KEY . equals ( property )  )     {", "String   val    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "isAbstract    =    PropertiesBeanDefinitionReader . TRUE _ VALUE . equals ( val )  ;", "} else", "if    ( PropertiesBeanDefinitionReader . SCOPE _ KEY . equals ( property )  )     {", "scope    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "} else", "if    ( PropertiesBeanDefinitionReader . SINGLETON _ KEY . equals ( property )  )     {", "String   val    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "scope    =     (  (  \"  \"  . equals ( val )  )     |  |     ( PropertiesBeanDefinitionReader . TRUE _ VALUE . equals ( val )  )  )     ?    GenericBeanDefinition . SCOPE _ SINGLETON    :    GenericBeanDefinition . SCOPE _ PROTOTYPE ;", "} else", "if    ( PropertiesBeanDefinitionReader . LAZY _ INIT _ KEY . equals ( property )  )     {", "String   val    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "lazyInit    =    PropertiesBeanDefinitionReader . TRUE _ VALUE . equals ( val )  ;", "} else", "if    ( property . startsWith ( PropertiesBeanDefinitionReader . CONSTRUCTOR _ ARG _ PREFIX )  )     {", "if    ( property . endsWith ( PropertiesBeanDefinitionReader . REF _ SUFFIX )  )     {", "int   index    =    Integer . parseInt ( property . substring (  1  ,     (  ( property . length (  )  )     -     ( PropertiesBeanDefinitionReader . REF _ SUFFIX . length (  )  )  )  )  )  ;", "cas . addIndexedArgumentValue ( index ,    new   config . RuntimeBeanReference ( entry . getValue (  )  . toString (  )  )  )  ;", "} else    {", "int   index    =    Integer . parseInt ( property . substring (  1  )  )  ;", "cas . addIndexedArgumentValue ( index ,    readValue ( entry )  )  ;", "}", "} else", "if    ( property . endsWith ( PropertiesBeanDefinitionReader . REF _ SUFFIX )  )     {", "property    =    property . substring (  0  ,     (  ( property . length (  )  )     -     ( PropertiesBeanDefinitionReader . REF _ SUFFIX . length (  )  )  )  )  ;", "String   ref    =    StringUtils . trimWhitespace (  (  ( String )     ( entry . getValue (  )  )  )  )  ;", "Object   val    =    new   config . RuntimeBeanReference ( ref )  ;", "pvs . add ( property ,    val )  ;", "} else    {", "pvs . add ( property ,    readValue ( entry )  )  ;", "}", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Registering   bean   definition   for   bean   name    '  \"     +    beanName )     +     \"  '    with    \"  )     +    pvs )  )  ;", "}", "if    (  (  ( parent    =  =    null )     &  &     ( className    =  =    null )  )     &  &     (  !  ( beanName . equals ( this . defaultParentBean )  )  )  )     {", "parent    =    this . defaultParentBean ;", "}", "try    {", "AbstractBeanDefinition   bd    =    BeanDefinitionReaderUtils . createBeanDefinition ( parent ,    className ,    getBeanClassLoader (  )  )  ;", "bd . setScope ( scope )  ;", "bd . setAbstract ( isAbstract )  ;", "bd . setLazyInit ( lazyInit )  ;", "bd . setConstructorArgumentValues ( cas )  ;", "bd . setPropertyValues ( pvs )  ;", "getRegistry (  )  . registerBeanDefinition ( beanName ,    bd )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   CannotLoadBeanClassException ( resourceDescription ,    beanName ,    className ,    ex )  ;", "}    catch    ( LinkageError   err )     {", "throw   new   CannotLoadBeanClassException ( resourceDescription ,    beanName ,    className ,    err )  ;", "}", "}", "METHOD_END"], "methodName": ["registerBeanDefinition"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   registerBeanDefinitions ( map ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   registerBeanDefinitions ( map ,    prefix ,     (  \" Map    \"     +    map )  )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    ( prefix    =  =    null )     {", "prefix    =     \"  \"  ;", "}", "int   beanCount    =     0  ;", "for    ( Object   key    :    map . keySet (  )  )     {", "if    (  !  ( key   instanceof   String )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Illegal   key    [  \"     +    key )     +     \"  ]  :    only   Strings   allowed \"  )  )  ;", "}", "String   keyString    =     (  ( String )     ( key )  )  ;", "if    ( keyString . startsWith ( prefix )  )     {", "String   nameAndProperty    =    keyString . substring ( prefix . length (  )  )  ;", "int   sepIdx    =     -  1  ;", "int   propKeyIdx    =    nameAndProperty . indexOf ( PropertyAccessor . PROPERTY _ KEY _ PREFIX )  ;", "if    ( propKeyIdx    !  =     (  -  1  )  )     {", "sepIdx    =    nameAndProperty . lastIndexOf (  . SEPARATOR ,    propKeyIdx )  ;", "} else    {", "sepIdx    =    nameAndProperty . lastIndexOf (  . SEPARATOR )  ;", "}", "if    ( sepIdx    !  =     (  -  1  )  )     {", "String   beanName    =    nameAndProperty . substring (  0  ,    sepIdx )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Found   bean   name    '  \"     +    beanName )     +     \"  '  \"  )  )  ;", "}", "if    (  !  ( getRegistry (  )  . containsBeanDefinition ( beanName )  )  )     {", "registerBeanDefinition ( beanName ,    map ,     ( prefix    +    beanName )  ,    resourceDescription )  ;", "+  + beanCount ;", "}", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" Invalid   bean   name   and   property    [  \"     +    nameAndProperty )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "}", "return   beanCount ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   registerBeanDefinitions ( rb ,    null )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "Enumeration < String >    keys    =    rb . getKeys (  )  ;", "while    ( keys . hasMoreElements (  )  )     {", "String   key    =    keys . nextElement (  )  ;", "map . put ( key ,    rb . getObject ( key )  )  ;", "}", "return   registers ( map ,    prefix )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . defaultParentBean    =    defaultParentBean ;", "}", "METHOD_END"], "methodName": ["setDefaultParentBean"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . propertiesPersister    =     ( propertiesPersister    !  =    null )     ?    propertiesPersister    :    new   DefaultPropertiesPersister (  )  ;", "}", "METHOD_END"], "methodName": ["setPropertiesPersister"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( new   ClassPathResource (  \" refConstructorArg . properties \"  ,    getClass (  )  )  )  ;", "TestBean   rob    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" rob \"  )  )  )  ;", "TestBean   sally    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" sally \"  )  )  )  ;", "assertEquals ( sally ,    rob . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["withConstructorArgRef"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( new   ClassPathResource (  \" multiConstructorArgs . properties \"  ,    getClass (  )  )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "assertEquals (  2  3  ,    bean . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["withMultipleConstructorsArgs"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "this . reader . loadBeanDefinitions ( new   ClassPathResource (  \" simpleConstructorArg . properties \"  ,    getClass (  )  )  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["withSimpleConstructorArg"], "fileName": "org.springframework.beans.factory.support.PropertiesBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    rbd )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    new   DependencyDescriptor (  . Person . class . getDeclaredField (  \" name \"  )  ,    false )  )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    new   DependencyDescriptor (  . Person . class . getDeclaredField (  \" name \"  )  ,    true )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateDefaultWithIrrelevantDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . setAutowireCandidate ( false )  ;", "person . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" qualified \"  )  ,    false )  ;", "DependencyDescriptor   nonqualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" nonqualified \"  )  ,    false )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    nonqualifiedDescriptor )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateExplicitlyFalseWithFieldDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   rbd    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "rbd . setAutowireCandidate ( false )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    rbd )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    new   DependencyDescriptor (  . Person . class . getDeclaredField (  \" name \"  )  ,    false )  )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . JUERGEN ,    new   DependencyDescriptor (  . Person . class . getDeclaredField (  \" name \"  )  ,    true )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateExplicitlyFalseWithIrrelevantDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "lbf . registerBeanDefinition (  . MARK ,    person 2  )  ;", "MethodParameter   param    =    new   MethodParameter (  . QualifiedTestBean . class . getDeclaredConstructor (  . Person . class )  ,     0  )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor ( param ,    false )  ;", "param . initParameterNameDiscovery ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "assertEquals (  \" tpb \"  ,    param . getParameterName (  )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . MARK ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateWithConstructorDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "lbf . registerBeanDefinition (  . MARK ,    person 2  )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" qualified \"  )  ,    false )  ;", "DependencyDescriptor   nonqualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" nonqualified \"  )  ,    false )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    nonqualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . MARK ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . MARK ,    nonqualifiedDescriptor )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . MARK ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateWithFieldDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "lbf . registerBeanDefinition (  . MARK ,    person 2  )  ;", "MethodParameter   qualifiedParam    =    new   MethodParameter (  . QualifiedTestBean . class . getDeclaredMethod (  \" autowireQualified \"  ,     . Person . class )  ,     0  )  ;", "MethodParameter   nonqualifiedParam    =    new   MethodParameter (  . QualifiedTestBean . class . getDeclaredMethod (  \" autowireNonqualified \"  ,     . Person . class )  ,     0  )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor ( qualifiedParam ,    false )  ;", "DependencyDescriptor   nonqualifiedDescriptor    =    new   DependencyDescriptor ( nonqualifiedParam ,    false )  ;", "qualifiedParam . initParameterNameDiscovery ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "assertEquals (  \" tpb \"  ,    qualifiedParam . getParameterName (  )  )  ;", "nonqualifiedParam . initParameterNameDiscovery ( new   LocalVariableTableParameterNameDiscoverer (  )  )  ;", "assertEquals (  \" tpb \"  ,    nonqualifiedParam . getParameterName (  )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    nonqualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . MARK ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . MARK ,    nonqualifiedDescriptor )  )  ;", "assertFalse ( lbf . isAutowireCandidate (  . MARK ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateWithMethodDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs 1     =    new   ConstructorArgumentValues (  )  ;", "cavs 1  . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person 1     =    new   RootBeanDefinition (  . Person . class ,    cavs 1  ,    null )  ;", "person 1  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person 1  )  ;", "ConstructorArgumentValues   cavs 2     =    new   ConstructorArgumentValues (  )  ;", "cavs 2  . addGenericArgumentValue (  . MARK )  ;", "RootBeanDefinition   person 2     =    new   RootBeanDefinition (  . Person . class ,    cavs 2  ,    null )  ;", "person 2  . addQualifier ( new   AutowireCandidateQualifier (  . TestQualifier . class )  )  ;", "lbf . registerBeanDefinition (  . MARK ,    person 2  )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor ( new   MethodParameter (  . QualifiedTestBean . class . getDeclaredConstructor (  . Person . class )  ,     0  )  ,    false )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . MARK ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateWithMultipleCandidatesDescriptor"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "ConstructorArgumentValues   cavs    =    new   ConstructorArgumentValues (  )  ;", "cavs . addGenericArgumentValue (  . JUERGEN )  ;", "RootBeanDefinition   person    =    new   RootBeanDefinition (  . Person . class ,    cavs ,    null )  ;", "person . addQualifier ( new   AutowireCandidateQualifier ( ClassUtils . getShortName (  . TestQualifier . class )  )  )  ;", "lbf . registerBeanDefinition (  . JUERGEN ,    person )  ;", "DependencyDescriptor   qualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" qualified \"  )  ,    false )  ;", "DependencyDescriptor   nonqualifiedDescriptor    =    new   DependencyDescriptor (  . QualifiedTestBean . class . getDeclaredField (  \" nonqualified \"  )  ,    false )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    null )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    nonqualifiedDescriptor )  )  ;", "assertTrue ( lbf . isAutowireCandidate (  . JUERGEN ,    qualifiedDescriptor )  )  ;", "}", "METHOD_END"], "methodName": ["testAutowireCandidateWithShortClassName"], "fileName": "org.springframework.beans.factory.support.QualifierAnnotationAutowireBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "this . typeIdentifiers . add ( identifier )  ;", "}", "METHOD_END"], "methodName": ["addTypeIdentifier"], "fileName": "org.springframework.beans.factory.support.ReplaceOverride"}, {"methodBody": ["METHOD_START", "{", "return   this . methodReplacerBeanName ;", "}", "METHOD_END"], "methodName": ["getMethodReplacerBeanName"], "fileName": "org.springframework.beans.factory.support.ReplaceOverride"}, {"methodBody": ["METHOD_START", "{", "return   this . decoratedDefinition ;", "}", "METHOD_END"], "methodName": ["getDecoratedDefinition"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . qualifiedElement ;", "}", "METHOD_END"], "methodName": ["getQualifiedElement"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . constructorArgumentLock )     {", "Executable   candidate    =    this . resolvedConstructorOrFMethod ;", "return   candidate   instanceof   Method    ?     (  ( Method )     ( candidate )  )     :    null ;", "}", "}", "METHOD_END"], "methodName": ["getResolvedFactoryMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resolvedTargetType )     !  =    null )     {", "return   this . resolvedTargetType ;", "}", "ResolvableType   targetType    =    this . targetType ;", "return   targetType    !  =    null    ?    targetType . resolve (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "return    (  ( this . externallyManagedConfigMembers )     !  =    null )     &  &     ( this . externallyManagedConfigMembers . contains ( configMember )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isExternallyManagedConfigMember"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "return    (  ( this . externallyManagedDestroyMethods )     !  =    null )     &  &     ( this . externallyManagedDestroyMethods . contains ( destroyMethod )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isExternallyManagedDestroyMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "return    (  ( this . externallyManagedInitMethods )     !  =    null )     &  &     ( this . externallyManagedInitMethods . contains ( Method )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isExternallyManagedInitMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   candidate . getName (  )  . equals ( getFactoryMethodName (  )  )  ;", "}", "METHOD_END"], "methodName": ["isFactoryMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "if    (  ( this . externallyManagedConfigMembers )     =  =    null )     {", "this . externallyManagedConfigMembers    =    new   HashSet <  >  (  1  )  ;", "}", "this . externallyManagedConfigMembers . add ( configMember )  ;", "}", "}", "METHOD_END"], "methodName": ["registerExternallyManagedConfigMember"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "if    (  ( this . externallyManagedDestroyMethods )     =  =    null )     {", "this . externallyManagedDestroyMethods    =    new   HashSet <  >  (  1  )  ;", "}", "this . externallyManagedDestroyMethods . add ( destroyMethod )  ;", "}", "}", "METHOD_END"], "methodName": ["registerExternallyManagedDestroyMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this . postProcessingLock )     {", "if    (  ( this . externallyManagedInitMethods )     =  =    null )     {", "this . externallyManagedInitMethods    =    new   HashSet <  >  (  1  )  ;", "}", "this . externallyManagedInitMethods . add ( Method )  ;", "}", "}", "METHOD_END"], "methodName": ["registerExternallyManagedInitMethod"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . decoratedDefinition    =    decoratedDefinition ;", "}", "METHOD_END"], "methodName": ["setDecoratedDefinition"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . qualifiedElement    =    qualifiedElement ;", "}", "METHOD_END"], "methodName": ["setQualifiedElement"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . targetType    =     ( targetType    !  =    null )     ?    ResolvableType . forClass ( targetType )     :    null ;", "}", "METHOD_END"], "methodName": ["setTargetType"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "this . targetType    =    targetType ;", "}", "METHOD_END"], "methodName": ["setTargetType"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "Assert . hasText ( name ,     \" Factory   method   name   must   not   be   empty \"  )  ;", "setFactoryMethodName ( name )  ;", "this . isFactoryMethodUnique    =    true ;", "}", "METHOD_END"], "methodName": ["setUniqueFactoryMethodName"], "fileName": "org.springframework.beans.factory.support.RootBeanDefinition"}, {"methodBody": ["METHOD_START", "{", "return   SimpleInstantiationStrategy . currentlyInvokedFactoryMethod . get (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentlyInvokedFactoryMethod"], "fileName": "org.springframework.beans.factory.support.SimpleInstantiationStrategy"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Method   Injection   not   supported   in   SimpleInstantiationStrategy \"  )  ;", "}", "METHOD_END"], "methodName": ["instantiateWithMethodInjection"], "fileName": "org.springframework.beans.factory.support.SimpleInstantiationStrategy"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Method   Injection   not   supported   in   SimpleInstantiationStrategy \"  )  ;", "}", "METHOD_END"], "methodName": ["instantiateWithMethodInjection"], "fileName": "org.springframework.beans.factory.support.SimpleInstantiationStrategy"}, {"methodBody": ["METHOD_START", "{", "assertThat ( bf . isTypeMatch (  \"  & foo \"  ,    FactoryBean . class )  ,    is ( true )  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "Map < String ,    FactoryBean >    fbBeans    =    bf . getBeansOfType ( FactoryBean . class )  ;", "assertThat (  1  ,    equalTo ( fbBeans . size (  )  )  )  ;", "assertThat (  \"  & foo \"  ,    equalTo ( fbBeans . keySet (  )  . iterator (  )  . next (  )  )  )  ;", "Map < String ,     . AnInterface >    aiBeans    =    bf . getBeansOfType (  . AnInterface . class )  ;", "assertThat ( aiBeans . size (  )  ,    is (  1  )  )  ;", "assertThat ( aiBeans . keySet (  )  ,    hasItem (  \"  & foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findsBeansByTypeIfNotInstantiated"], "fileName": "org.springframework.beans.factory.support.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    names    =    bf . getBeanNamesForType ( Spr 8  9  5  4 Tests . AnInterface . class ,    false ,    false )  ;", "assertThat ( Arrays . asList ( names )  ,    hasItem (  \"  & foo \"  )  )  ;", "Map < String ,    Spr 8  9  5  4 Tests . AnInterface >    beans    =    bf . getBeansOfType ( Spr 8  9  5  4 Tests . AnInterface . class ,    false ,    false )  ;", "assertThat ( beans . size (  )  ,    is (  1  )  )  ;", "assertThat ( beans . keySet (  )  ,    hasItem (  \"  & foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["findsFactoryBeanNameByTypeWithoutInstantiation"], "fileName": "org.springframework.beans.factory.support.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( bf . getBean (  \" foo \"  )  ,    instanceOf ( Spr 8  9  5  4 Tests . Foo . class )  )  ;", "assertThat ( bf . getBean (  \"  & foo \"  )  ,    instanceOf ( Spr 8  9  5  4 Tests . FooFactoryBean . class )  )  ;", "assertThat ( bf . isTypeMatch (  \"  & foo \"  ,    FactoryBean . class )  ,    is ( true )  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "Map < String ,    FactoryBean >    fbBeans    =    bf . getBeansOfType ( FactoryBean . class )  ;", "assertThat ( fbBeans . size (  )  ,    is (  1  )  )  ;", "assertThat ( fbBeans . keySet (  )  ,    hasItem (  \"  & foo \"  )  )  ;", "Map < String ,    Spr 8  9  5  4 Tests . AnInterface >    aiBeans    =    bf . getBeansOfType ( Spr 8  9  5  4 Tests . AnInterface . class )  ;", "assertThat ( aiBeans . size (  )  ,    is (  1  )  )  ;", "assertThat ( aiBeans . keySet (  )  ,    hasItem (  \"  & foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["repro"], "fileName": "org.springframework.beans.factory.support.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "bf    =    new   DefaultListableBeanFactory (  )  ;", "bf . registerBeanDefinition (  \" foo \"  ,    new   RootBeanDefinition (  . FooFactoryBean . class )  )  ;", "bf . addBeanPostProcessor ( new    . PredictingBPP (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.support.Spr8954Tests"}, {"methodBody": ["METHOD_START", "{", "this . beans . put ( name ,    bean )  ;", "}", "METHOD_END"], "methodName": ["addBean"], "fileName": "org.springframework.beans.factory.support.StaticListableBeanFactory"}, {"methodBody": ["METHOD_START", "{", "final   AccessControlContext   acc    =    AccessController . getContext (  )  ;", "return   AccessController . doPrivileged ( new   PrivilegedAction < St >  (  )     {", "@ Override", "public   St   run (  )     {", "Subject   subject    =    Subject . getSubject ( acc )  ;", "if    ( subject    =  =    null )     {", "return   null ;", "}", "Set < Principal >    principals    =    subject . getPrincipals (  )  ;", "if    ( principals    =  =    null )     {", "return   null ;", "}", "for    ( Principal   p    :    principals )     {", "return   p . getName (  )  ;", "}", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentSubjectName"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "final   ProtectionDomain   empty    =    new   ProtectionDomain ( null ,    new   Permissions (  )  )  ;", "provider    =    new   SecurityContextProvider (  )     {", "private   final   AccessControlContext   acc    =    new   AccessControlContext ( new   ProtectionDomain [  ]  {    empty    }  )  ;", "@ Override", "public   AccessControlContext   getAccessControlContext (  )     {", "return   acc ;", "}", "}  ;", "DefaultResourceLoader   drl    =    new   DefaultResourceLoader (  )  ;", "Resource   config    =    drl . getResource (  \"  / org /  / beans / factory / support / security / callbacks . xml \"  )  ;", "beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( beanFactory )  . loadBeanDefinitions ( config )  ;", "beanFactory . setSecurityContextProvider ( provider )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" constructor \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getMostSpecificCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testConstructor"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "AccessControlContext   acc    =    provider . getAccessControlContext (  )  ;", "AccessController . doPrivileged ( new   PrivilegedExceptionAction < Object >  (  )     {", "@ Override", "public   Object   run (  )    throws   Exception    {", "beanFgetBean (  \" working - fmethod \"  )  ;", "beanFgetBean (  \" container - execution \"  )  ;", "return   null ;", "}", "}  ,    acc )  ;", "}", "METHOD_END"], "methodName": ["testContainerPrivileges"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . getBean (  \" custom - destroy \"  )  ;", "beanFactory . destroySingletons (  )  ;", "assertNull ( System . getProperty (  \" destroy \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomDestroyBean"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" spring - factory \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomFactoryObject"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( beanFactory . getType (  \" spring -  )  )  ;", "assertNull ( System . getProperty (  \" object . type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomFactoryType"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" custom - init \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomInitBean"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" custom - factory - method \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getMostSpecificCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomInstanceFactoryMethod"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" custom - static - factory - method \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getMostSpecificCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomStaticFactoryMethod"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "final   DefaultListableBeanFactory   lbf    =    new   DefaultListableBeanFactory (  )  ;", "BeanDefinitionBuilder   bdb    =    BeanDefinitionBuilder . genericBeanDefinition (  . NonPrivilegedBean . class )  . setScope ( ConfigurableBeanFactory . SCOPE _ PROTOTYPE )  . setInitMethodName (  \" init \"  )  . setDestroyMethodName (  \" destroy \"  )  . addConstructorArgValue (  \" user 1  \"  )  ;", "lbf . registerBeanDefinition (  \" test \"  ,    bdb . getBeanDefinition (  )  )  ;", "final   Subject   subject    =    new   Subject (  )  ;", "subject . getPrincipals (  )  . add ( new    . TestPrincipal (  \" user 1  \"  )  )  ;", ". NonPrivilegedBean   bean    =    Subject . doAsPrivileged ( subject ,    new   PrivilegedAction <  . NonPrivilegedBean >  (  )     {", "@ Override", "public    . NonPrivilegedBean   run (  )     {", "return   lbf . getBean (  \" test \"  ,     . NonPrivilegedBean . class )  ;", "}", "}  ,    null )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["testInitSecurityAwarePrototypeBean"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" property - injection \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \"  \"  )  )  ;", "}", "beanFactory . getBean (  \" working - property - injection \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyInjection"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "AccessControlContext   acc    =    provider . getAccessControlContext (  )  ;", "try    {", "acc . checkPermission ( new   PropertyPermission (  \"  *  \"  ,     \" read \"  )  )  ;", "fail (  \" Acc   should   not   have   any   permissions \"  )  ;", "}    catch    ( Exception   se )     {", "}", "final   CustomCallbackBean   bean    =    new   CustomCallbackBean (  )  ;", "final   Method   method    =    bean . getClass (  )  . getMethod (  \" destroy \"  )  ;", "method . setAccessible ( true )  ;", "try    {", "AccessController . doPrivileged ( new   PrivilegedExceptionAction < Object >  (  )     {", "@ Override", "public   Object   run (  )    throws   Exception    {", "method . invoke ( bean )  ;", "return   null ;", "}", "}  ,    acc )  ;", "fail (  \" expected   security   exception \"  )  ;", "}    catch    ( Exception   ex )     {", "}", "final   Class < ConstructorBean >    cl    =    ConstructorBean . class ;", "try    {", "AccessController . doPrivileged ( new   PrivilegedExceptionAction < Object >  (  )     {", "@ Override", "public   Object   run (  )    throws   Exception    {", "return   cl . newInstance (  )  ;", "}", "}  ,    acc )  ;", "fail (  \" expected   security   exception \"  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testSecuritySanity"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . getBean (  \" spring - destroy \"  )  ;", "beanFactory . destroySingletons (  )  ;", "assertNull ( System . getProperty (  \" destroy \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpringDestroyBean"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" spring - init \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSpringInitBean"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "beanFactory . setSecurityContextProvider ( null )  ;", "Permissions   perms    =    new   Permissions (  )  ;", "perms . add ( new   AuthPermission (  \" getSubject \"  )  )  ;", "ProtectionDomain   pd    =    new   ProtectionDomain ( null ,    perms )  ;", "new   AccessControlContext ( new   ProtectionDomain [  ]  {    pd    }  )  ;", "final   Subject   subject    =    new   Subject (  )  ;", "subject . getPrincipals (  )  . add ( new    . TestPrincipal (  \" user 1  \"  )  )  ;", "Subject . doAsPrivileged ( subject ,    new   PrivilegedAction < Object >  (  )     {", "@ Override", "public   Object   run (  )     {", "assertEquals (  \" user 1  \"  ,     . getCurrentSubjectName (  )  )  ;", "assertEquals ( false ,     . NonPrivilegedBean . destroyed )  ;", "beanFactory . getBean (  \" trusted - spring - callbacks \"  )  ;", "beanFactory . getBean (  \" trusted - custom - init - destroy \"  )  ;", "beanFactory . getBean (  \" trusted - spring - factory \"  )  ;", "beanFactory . getBean (  \" trusted - spring - factory \"  )  ;", "beanFactory . getBean (  \" trusted - spring - factory \"  )  ;", "beanFactory . getBean (  \" trusted - factory - bean \"  )  ;", "beanFactory . getBean (  \" trusted - static - factory - method \"  )  ;", "beanFactory . getBean (  \" trusted - factory - method \"  )  ;", "beanFactory . getBean (  \" trusted - property - injection \"  )  ;", "beanFactory . getBean (  \" trusted - working - property - injection \"  )  ;", "beanFactory . destroySingletons (  )  ;", "assertEquals ( true ,     . NonPrivilegedBean . destroyed )  ;", "return   null ;", "}", "}  ,    provider . getAccessControlContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrustedExecution"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "beanFactory . getBean (  \" privileged - static - factory - method \"  )  ;", "fail (  \" expected      exception \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getMostSpecificCause (  )  )    instanceof   SecurityException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTrustedFactoryMethod"], "fileName": "org.springframework.beans.factory.support.security.CallbacksSecurityTests"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" security . destroy \"  ,     \" true \"  )  ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.beans.factory.support.security.support.CustomCallbackBean"}, {"methodBody": ["METHOD_START", "{", "System . getProperties (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.springframework.beans.factory.support.security.support.CustomCallbackBean"}, {"methodBody": ["METHOD_START", "{", "System . getProperties (  )  ;", "return   new   Object (  )  ;", "}", "METHOD_END"], "methodName": ["makeInstance"], "fileName": "org.springframework.beans.factory.support.security.support.FactoryBean"}, {"methodBody": ["METHOD_START", "{", "System . getProperties (  )  ;", "return   new   Object (  )  ;", "}", "METHOD_END"], "methodName": ["makeStaticInstance"], "fileName": "org.springframework.beans.factory.support.security.support.FactoryBean"}, {"methodBody": ["METHOD_START", "{", "return    \" protectedStaticInstance \"  ;", "}", "METHOD_END"], "methodName": ["protectedStaticInstance"], "fileName": "org.springframework.beans.factory.support.security.support.FactoryBean"}, {"methodBody": ["METHOD_START", "{", "System . getProperties (  )  ;", "}", "METHOD_END"], "methodName": ["setSecurityProperty"], "fileName": "org.springframework.beans.factory.support.security.support.PropertyBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . beanFactory )     =  =    null )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" BeanFactory   has   not   been   set   on    \"     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  :     \"  )     +     \" Make   sure   this   c   runs   in   a   Spring   container .    Unable   to   configure   bean   of   type    [  \"  )     +     ( ClassUtils . getDescriptiveType ( beanInstance )  )  )     +     \"  ]  .    Proceeding   without   injection .  \"  )  )  ;", "}", "return ;", "}", "BeanWiringInfoResolver   bwiResolver    =    this . beanWiringInfoResolver ;", "Assert . state (  ( bwiResolver    !  =    null )  ,     \" No   BeanWiringInfoResolver   available \"  )  ;", "BeanWiringInfo   bwi    =    bwiResolver . resolveWiringInfo ( beanInstance )  ;", "if    ( bwi    =  =    null )     {", "return ;", "}", "ConfigurableListableBeanFactory   beanFactory    =    this . beanFactory ;", "Assert . state (  ( beanFactory    !  =    null )  ,     \" No   BeanFactory   available \"  )  ;", "try    {", "String   beanName    =    bwi . getBeanName (  )  ;", "if    (  ( bwi . indicatesAutowiring (  )  )     |  |     (  (  ( bwi . isDefaultBeanName (  )  )     &  &     ( beanName    !  =    null )  )     &  &     (  !  ( beanFactory . containsBean ( beanName )  )  )  )  )     {", "beanFactory . autowireBeanProperties ( beanInstance ,    bwi . getAutowireMode (  )  ,    bwi . getDependencyCheck (  )  )  ;", "beanFactory . initializeBean ( beanInstance ,     ( beanName    !  =    null    ?    beanName    :     \"  \"  )  )  ;", "} else    {", "beanFactory . configureBean ( beanInstance ,     ( beanName    !  =    null    ?    beanName    :     \"  \"  )  )  ;", "}", "}    catch    ( BeanCreationException   ex )     {", "Throwable   rootCause    =    ex . getMostSpecificCause (  )  ;", "if    ( rootCause   instanceof   BeanCurrentlyInCreationException )     {", "BeanCreationException   bce    =     (  ( BeanCreationException )     ( rootCause )  )  ;", "String   bceBeanName    =    bce . getBeanName (  )  ;", "if    (  ( bceBeanName    !  =    null )     &  &     ( beanFactory . isCurrentlyInCreation ( bceBeanName )  )  )     {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  \" Failed   to   create   target   bean    '  \"     +     ( bce . getBeanName (  )  )  )     +     \"  '    while   configuring   object   of   type    [  \"  )     +     ( beanInstance . getClass (  )  . getName (  )  )  )     +     \"  ]     -    probably   due   to   a   circular   reference .    This   is   a   common   startup   situation    \"  )     +     \" and   usually   not   fatal .    Proceeding   without   injection .    Original   exception :     \"  )     +    ex )  )  ;", "}", "return ;", "}", "}", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["configureBean"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassNameBeanWiringInfoResolver (  )  ;", "}", "METHOD_END"], "methodName": ["createDefaultBeanWiringInfoResolver"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( beanWiringInfoResolver ,     \" BeanWiringInfoResolver   must   not   be   null \"  )  ;", "this . beanWiringInfoResolver    =    beanWiringInfoResolver ;", "}", "METHOD_END"], "methodName": ["setBeanWiringInfoResolver"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupport"}, {"methodBody": ["METHOD_START", "{", "TestBean   beanInstance    =    new   TestBean (  )  ;", "BeanWiringInfoResolver   resolver    =    mock ( BeanWiringInfoResolver . class )  ;", "BeanConfigurerSupport   configurer    =    new    . StubBeanConfigurerSupport (  )  ;", "configurer . setBeanWiringInfoResolver ( resolver )  ;", "configurer . setBeanFactory ( new   DefaultListableBeanFactory (  )  )  ;", "configurer . configureBean ( beanInstance )  ;", "verify ( resolver )  . resolveWiringInfo ( beanInstance )  ;", "assertNull ( beanInstance . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBeanDoesNothingIfBeanWiringInfoResolverResolvesToNull"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   beanInstance    =    new   TestBean (  )  ;", "BeanConfigurerSupport   configurer    =    new    . StubBeanConfigurerSupport (  )  ;", "configurer . configureBean ( beanInstance )  ;", "assertNull ( beanInstance . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBeanDoesNothingIfNoBeanFactoryHasBeenSet"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   beanInstance    =    new   TestBean (  )  ;", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  ;", "builder . addConstructorArgValue (  \" David   Gavurin \"  )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \" spouse \"  ,    builder . getBeanDefinition (  )  )  ;", "BeanWiringInfoResolver   resolver    =    mock ( BeanWiringInfoResolver . class )  ;", "given ( resolver . resolveWiringInfo ( beanInstance )  )  . willReturn ( new   BeanWiringInfo ( BeanWiringInfo . AUTOWIRE _ BY _ NAME ,    false )  )  ;", "BeanConfigurerSupport   configurer    =    new    . StubBeanConfigurerSupport (  )  ;", "configurer . setBeanFactory ( factory )  ;", "configurer . setBeanWiringInfoResolver ( resolver )  ;", "configurer . configureBean ( beanInstance )  ;", "assertEquals (  \" Bean   is   evidently   not   being   configured    ( for   some   reason )  \"  ,     \" David   Gavurin \"  ,    beanInstance . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBeanPerformsAutowiringByNameIfAppropriateBeanWiringInfoResolverIsPluggedIn"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   beanInstance    =    new   TestBean (  )  ;", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  ;", "builder . addConstructorArgValue (  \" David   Gavurin \"  )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition (  \" Mmm ,    I   fancy   a   salad !  \"  ,    builder . getBeanDefinition (  )  )  ;", "BeanWiringInfoResolver   resolver    =    mock ( BeanWiringInfoResolver . class )  ;", "given ( resolver . resolveWiringInfo ( beanInstance )  )  . willReturn ( new   BeanWiringInfo ( BeanWiringInfo . AUTOWIRE _ BY _ TYPE ,    false )  )  ;", "BeanConfigurerSupport   configurer    =    new    . StubBeanConfigurerSupport (  )  ;", "configurer . setBeanFactory ( factory )  ;", "configurer . setBeanWiringInfoResolver ( resolver )  ;", "configurer . configureBean ( beanInstance )  ;", "assertEquals (  \" Bean   is   evidently   not   being   configured    ( for   some   reason )  \"  ,     \" David   Gavurin \"  ,    beanInstance . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBeanPerformsAutowiringByTypeIfAppropriateBeanWiringInfoResolverIsPluggedIn"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   beanInstance    =    new   TestBean (  )  ;", "BeanDefinitionBuilder   builder    =    BeanDefinitionBuilder . rootBeanDefinition ( TestBean . class )  ;", "builder . addPropertyValue (  \" name \"  ,     \" Harriet   Wheeler \"  )  ;", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "factory . registerBeanDefinition ( beanInstance . getClass (  )  . getName (  )  ,    builder . getBeanDefinition (  )  )  ;", "BeanConfigurerSupport   configurer    =    new    . StubBeanConfigurerSupport (  )  ;", "configurer . setBeanFactory ( factory )  ;", "configurer . afterPropertiesSet (  )  ;", "configurer . configureBean ( beanInstance )  ;", "assertEquals (  \" Bean   is   evidently   not   being   configured    ( for   some   reason )  \"  ,     \" Harriet   Wheeler \"  ,    beanInstance . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBeanReallyDoesDefaultToUsingTheFullyQualifiedClassNameOfTheSuppliedBeanInstance"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanConfigurerSupportTests . StubBeanConfigurerSupport (  )  . setBeanFactory ( mock ( BeanFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["supplyIncompatibleBeanFactoryImplementation"], "fileName": "org.springframework.beans.factory.wiring.BeanConfigurerSupportTests"}, {"methodBody": ["METHOD_START", "{", "return   this . autowireMode ;", "}", "METHOD_END"], "methodName": ["getAutowireMode"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . dependencyCheck ;", "}", "METHOD_END"], "methodName": ["getDependencyCheck"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfo"}, {"methodBody": ["METHOD_START", "{", "return    ( this . beanName )     =  =    null ;", "}", "METHOD_END"], "methodName": ["indicatesAutowiring"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . isDefaultBeanName ;", "}", "METHOD_END"], "methodName": ["isDefaultBeanName"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfo"}, {"methodBody": ["METHOD_START", "{", "new   BeanWiringInfo (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["ctorWithEmptyBeanName"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanWiringInfo (  (  -  1  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["ctorWithNegativeIllegalAutowiringValue"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanWiringInfo ( null )  ;", "}", "METHOD_END"], "methodName": ["ctorWithNullBeanName"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanWiringInfo (  1  2  3  8  7  1  ,    true )  ;", "}", "METHOD_END"], "methodName": ["ctorWithPositiveOutOfRangeAutowiringValue"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "new   BeanWiringInfo (  \"           \\ t \"  )  ;", "}", "METHOD_END"], "methodName": ["ctorWithWhitespacedBeanName"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanWiringInfo   info    =    new   BeanWiringInfo ( BeanWiringInfo . AUTOWIRE _ BY _ TYPE ,    false )  ;", "assertFalse ( info . getDependencyCheck (  )  )  ;", "}", "METHOD_END"], "methodName": ["dependencyCheckValueIsPreserved"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanWiringInfo   info    =    new   BeanWiringInfo ( BeanWiringInfo . AUTOWIRE _ BY _ NAME ,    true )  ;", "assertTrue ( info . getDependencyCheck (  )  )  ;", "}", "METHOD_END"], "methodName": ["noDependencyCheckValueIsPreserved"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanWiringInfo   info    =    new   BeanWiringInfo ( BeanWiringInfo . AUTOWIRE _ BY _ NAME ,    true )  ;", "assertTrue ( info . indicatesAutowiring (  )  )  ;", "}", "METHOD_END"], "methodName": ["usingAutowireCtorIndicatesAutowiring"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "BeanWiringInfo   info    =    new   BeanWiringInfo (  \" fooService \"  )  ;", "assertFalse ( info . indicatesAutowiring (  )  )  ;", "}", "METHOD_END"], "methodName": ["usingBeanNameCtorDoesNotIndicateAutowiring"], "fileName": "org.springframework.beans.factory.wiring.BeanWiringInfoTests"}, {"methodBody": ["METHOD_START", "{", "ClassNameBeanWiringInfoResolver   resolver    =    new   ClassNameBeanWiringInfoResolver (  )  ;", "Long   beanInstance    =    new   Long (  1  )  ;", "BeanWiringInfo   info    =    resolver . resolveWiringInfo ( beanInstance )  ;", "assertNotNull ( info )  ;", "assertEquals (  \" Not   resolving   bean   name   to   the   class   name   of   the   supplied   bean   instance   as   per   class   contract .  \"  ,    beanInstance . getClass (  )  . getName (  )  ,    info . getBeanName (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveWiringInfo"], "fileName": "org.springframework.beans.factory.wiring.ClassNameBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   ClassNameBeanWiringInfoResolver (  )  . resolveWiringInfo ( null )  ;", "}", "METHOD_END"], "methodName": ["resolveWiringInfoWithNullBeanInstance"], "fileName": "org.springframework.beans.factory.wiring.ClassNameBeanWiringInfoResolverTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerBeanDefinition ( definition ,    registry )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "if    ( shouldGenerateId (  )  )     {", "return   parserContext . getReaderContext (  )  . generateBeanName ( definition )  ;", "} else    {", "String   id    =    element . getAttribute (  . ID _ ATTRIBUTE )  ;", "if    (  (  !  ( StringUtils . hasText ( id )  )  )     &  &     ( shouldGenerateIdAsFallback (  )  )  )     {", "id    =    parserContext . getReaderContext (  )  . generateBeanName ( definition )  ;", "}", "return   id ;", "}", "}", "METHOD_END"], "methodName": ["resolveId"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldFireEvents"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldGenerateId"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldGenerateIdAsFallback"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["shouldParseNameAsAliases"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   bf    =    getBeanFactory (  )  ;", "if    (  !  ( bf   instanceof   ConfigurableBeanFactory )  )     {", "return ;", "}", "ConfigurableBeanFactory   cbf    =     (  ( ConfigurableBeanFactory )     ( bf )  )  ;", "String   alias    =     \" rods   alias \"  ;", "try    {", "cbf . getBean ( alias )  ;", "fail (  \" Shouldn ' t   permit   factory   get   on   normal   bean \"  )  ;", "}    catch    ( NoSuchBeanDefinitionException   ex )     {", "assertTrue ( alias . equals ( ex . getBeanName (  )  )  )  ;", "}", "cbf . registerAlias (  \" rod \"  ,    alias )  ;", "Object   rod    =    getBeanFactory (  )  . getBean (  \" rod \"  )  ;", "Object   aliasRod    =    getBeanFactory (  )  . getBean ( alias )  ;", "assertTrue (  ( rod    =  =    aliasRod )  )  ;", "}", "METHOD_END"], "methodName": ["aliasing"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" singletonFactory \"  )  )  )  ;", "assertNotNull ( tb )  ;", "DummyFactory   factory    =     (  ( DummyFactory )     ( getBeanFactory (  )  . getBean (  \"  & singletonFactory \"  )  )  )  ;", "assertTrue (  \" Factory   was   initialized   because   it   implemented   InitializingBean \"  ,    factory . wasInitialized (  )  )  ;", "}", "METHOD_END"], "methodName": ["factoryIsInitialized"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( getBeanFactory (  )  . isSingleton (  \"  & prototypeFactory \"  )  )  ;", "assertFalse ( getBeanFactory (  )  . isSingleton (  \" prototypeFactory \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" prototypeFactory \"  )  )  )  ;", "assertTrue (  (  !  ( tb . getName (  )  . equals ( DummyFactory . SINGLETON _ NAME )  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" prototypeFactory \"  )  )  )  ;", "assertTrue (  \" Prototype   references    !  =  \"  ,     ( tb    !  =    tb 2  )  )  ;", "}", "METHOD_END"], "methodName": ["factoryPrototype"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( getBeanFactory (  )  . isSingleton (  \"  & singletonFactory \"  )  )  ;", "assertTrue ( getBeanFactory (  )  . isSingleton (  \" singletonFactory \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" singletonFactory \"  )  )  )  ;", "assertTrue (  (  \" Singleton   from   factory   has   correct   name ,    not    \"     +     ( tb . getName (  )  )  )  ,    tb . getName (  )  . equals ( DummyFactory . SINGLETON _ NAME )  )  ;", "DummyFactory   factory    =     (  ( DummyFactory )     ( getBeanFactory (  )  . getBean (  \"  & singletonFactory \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" singletonFactory \"  )  )  )  ;", "assertTrue (  \" Singleton   references    =  =  \"  ,     ( tb    =  =    tb 2  )  )  ;", "assertTrue (  \" FactoryBean   is   BeanFactoryAware \"  ,     (  ( factory . getBeanFactory (  )  )     !  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["factorySingleton"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" rod \"  )  ;", "assertTrue (  \" Rod   bean   is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( o )  )  ;", "assertTrue (  \" rod . name   is   Rod \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" rod . age   is    3  1  \"  ,     (  ( rod . getAge (  )  )     =  =     3  1  )  )  ;", "}", "METHOD_END"], "methodName": ["findsValidInstance"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "getBeanFactory (  )  . getBean (  (  ( String )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBeanWithNullArg"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( getBeanFactory (  )  . getBean (  \"  & singletonFactory \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getFactoryItself"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" rod \"  ,    TestBean . class )  ;", "assertTrue (  \" Rod   bean   is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["getInstanceByMatchingClass"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ge (  )  . getBean (  \" rod \"  ,    BeanFactory . class )  ;", "fail (  \" Rod   bean   is   not   of   type   BeanFactory ;    getBeanInstance ( rod ,    BeanFactory . class )    should   throw   BeanNotOfRequiredTypeException \"  )  ;", "}    catch    ( BeanNotOfRequiredTypeException   ex )     {", "assertTrue (  \" Exception   has   correct   bean   name \"  ,    ex . getBeanName (  )  . equals (  \" rod \"  )  )  ;", "assertTrue (  \" Exception   requiredType   must   be   BeanFactory . class \"  ,    ex . getRequiredType (  )  . equals ( BeanFactory . class )  )  ;", "assertTrue (  \" Exception   actualType   as   TestBean . class \"  ,    TestBean . class . isAssignableFrom ( ex . getActualType (  )  )  )  ;", "assertTrue (  \" Actual   type   is   correct \"  ,     (  ( ex . getActualType (  )  )     =  =     ( ge (  )  . getBean (  \" rod \"  )  . getClass (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getInstanceByNonmatchingClass"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" rod \"  ,    TestBean . class )  ;", "assertTrue (  \" Rod   bean   is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["getSharedInstanceByMatchingClass"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" rod \"  ,    TestBean . class )  ;", "assertTrue (  \" Rod   bean   is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["getSharedInstanceByMatchingClassNoCatch"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ge (  )  . getBean (  \" rod \"  ,    BeanFactory . class )  ;", "fail (  \" Rod   bean   is   not   of   type   BeanFactory ;    getBeanInstance ( rod ,    BeanFactory . class )    should   throw   BeanNotOfRequiredTypeException \"  )  ;", "}    catch    ( BeanNotOfRequiredTypeException   ex )     {", "assertTrue (  \" Exception   has   correct   bean   name \"  ,    ex . getBeanName (  )  . equals (  \" rod \"  )  )  ;", "assertTrue (  \" Exception   requiredType   must   be   BeanFactory . class \"  ,    ex . getRequiredType (  )  . equals ( BeanFactory . class )  )  ;", "assertTrue (  \" Exception   actualType   as   TestBean . class \"  ,    TestBean . class . isAssignableFrom ( ex . getActualType (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSharedInstanceByNonmatchingClass"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   dad    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" father \"  )  )  )  ;", "assertTrue (  \" Dad   has   correct   name \"  ,    dad . getName (  )  . equals (  \" Albert \"  )  )  ;", "}", "METHOD_END"], "methodName": ["grandparentDefinitionFoundInBeanFactory"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( getBeanFactory (  )  . containsBean (  \" rod \"  )  )  ;", "assertTrue ( getBeanFactory (  )  . containsBean (  \" roderick \"  )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" rod \"  )  )  )  ;", "TestBean   roderick    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" roderick \"  )  )  )  ;", "assertTrue (  \" not    =  =     \"  ,     ( rod    !  =    roderick )  )  ;", "assertTrue (  \" rod . name   is   Rod \"  ,    rod . getName (  )  . equals (  \" Rod \"  )  )  ;", "assertTrue (  \" rod . age   is    3  1  \"  ,     (  ( rod . getAge (  )  )     =  =     3  1  )  )  ;", "assertTrue (  \" roderick . name   is   Roderick \"  ,    roderick . getName (  )  . equals (  \" Roderick \"  )  )  ;", "assertTrue (  \" roderick . age   was   inherited \"  ,     (  ( roderick . getAge (  )  )     =  =     ( rod . getAge (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["inheritance"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "MustBeInitialized   mbi    =     (  ( MustBeInitialized )     ( getBeanFactory (  )  . getBean (  \" mustBeInitialized \"  )  )  )  ;", "mbi . businessMethod (  )  ;", "}", "METHOD_END"], "methodName": ["initializingBeanCallback"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LifecycleBean   lb    =     (  ( LifecycleBean )     ( getBeanFactory (  )  . getBean (  \" lifecycle \"  )  )  )  ;", "assertEquals (  \" lifecycle \"  ,    lb . getBeanName (  )  )  ;", "lb . businessMethod (  )  ;", "assertTrue (  \" Not   destroyed \"  ,     (  !  ( lb . isDestroyed (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["lifecycleCallbacks"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( getBeanFactory (  )  . containsBean (  \" Mr   Squiggle \"  )  )  ;", "getBeanFactory (  )  . getBean (  \" Mr   Squiggle \"  )  ;", "}", "METHOD_END"], "methodName": ["notThere"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb 1     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" kathy \"  )  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" kathy \"  )  )  )  ;", "assertTrue (  \" ref   equal   DOES   NOT   apply \"  ,     ( tb 1     !  =    tb 2  )  )  ;", "assertTrue (  \" object   equal   true \"  ,    tb 1  . equals ( tb 2  )  )  ;", "tb 1  . setAge (  1  )  ;", "tb 2  . setAge (  2  )  ;", "assertTrue (  \"  1    age   independent    =     1  \"  ,     (  ( tb 1  . getAge (  )  )     =  =     1  )  )  ;", "assertTrue (  \"  2    age   independent    =     2  \"  ,     (  ( tb 2  . getAge (  )  )     =  =     2  )  )  ;", "assertTrue (  \" object   equal   now   false \"  ,     (  !  ( tb 1  . equals ( tb 2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["prototypeInstancesAreIndependent"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "getBeanFactory (  )  . getBean (  \"  & rod \"  )  ;", "}", "METHOD_END"], "methodName": ["rejectsFactoryGetOnNormalBean"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" rod \"  )  ;", "assertTrue (  \" Rod   bean 1    is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "Object   o 1     =    getBeanFactory (  )  . getBean (  \" rod \"  )  ;", "assertTrue (  \" Rod   bean 2    is   a   TestBean \"  ,     ( o 1    instanceof   TestBean )  )  ;", "assertTrue (  \" Object   equals   applies \"  ,     ( o    =  =    o 1  )  )  ;", "}", "METHOD_END"], "methodName": ["sharedInstancesAreEqual"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "Object   o    =    getBeanFactory (  )  . getBean (  \" validEmpty \"  )  ;", "assertTrue (  \" validEmpty   bean   is   a   TestBean \"  ,     ( o   instanceof   TestBean )  )  ;", "TestBean   ve    =     (  ( TestBean )     ( o )  )  ;", "assertTrue (  \" Valid   empty   has   defaults \"  ,     (  (  (  ( ve . getName (  )  )     =  =    null )     &  &     (  ( ve . getAge (  )  )     =  =     0  )  )     &  &     (  ( ve . getSpouse (  )  )     =  =    null )  )  )  ;", "}", "METHOD_END"], "methodName": ["validEmpty"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "ge (  )  . getBean (  \" typeMismatch \"  )  ;", "fail (  \" Shouldn ' t   succeed   with   type   mismatch \"  )  ;", "}    catch    ( BeanCreationException   wex )     {", "assertEquals (  \" typeMismatch \"  ,    wex . getBeanName (  )  )  ;", "assertTrue (  (  ( wex . getCause (  )  )    instanceof   PropertyBatchUpdateException )  )  ;", "PropertyBatchUpdateException   ex    =     (  ( PropertyBatchUpdateException )     ( wex . getCause (  )  )  )  ;", "assertTrue (  \" Has   one   error    \"  ,     (  ( ex . getExceptionCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Error   is   for   field   age \"  ,     (  ( ex . getPropertyAccessException (  \" age \"  )  )     !  =    null )  )  ;", "assertTrue (  \" We   have   rejected   age   in   exception \"  ,    ex . getPropertyAccessException (  \" age \"  )  . getPropertyChangeEvent (  )  . getNewValue (  )  . equals (  \"  3  4 x \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["xtestTypeMismatch"], "fileName": "org.springframework.beans.factory.xml.AbstractBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    defnames    =    getListableBeanFactory (  )  . getBeanDefinitionNames (  )  ;", "assertTrue (  (  (  (  \" We   should   have    \"     +    count )     +     \"    beans ,    not    \"  )     +     ( defnames . length )  )  ,     (  ( defnames . length )     =  =    count )  )  ;", "}", "METHOD_END"], "methodName": ["assertCount"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    defNames    =    getListableBeanFactory (  )  . getBeanNamesForType ( TestBean . class ,    true ,    false )  ;", "assertTrue (  (  (  (  \" We   should   have    \"     +    count )     +     \"    beans   for   class   TestBean ,    not    \"  )     +     ( defNames . length )  )  ,     (  ( defNames . length )     =  =    count )  )  ;", "int   countIncludingFactoryBeans    =    count    +     2  ;", "String [  ]    names    =    getListableBeanFactory (  )  . getBeanNamesForType ( TestBean . class ,    true ,    true )  ;", "assertTrue (  (  (  (  \" We   should   have    \"     +    countIncludingFactoryBeans )     +     \"    beans   for   class   TestBean ,    not    \"  )     +     ( names . length )  )  ,     (  ( names . length )     =  =    countIncludingFactoryBeans )  )  ;", "}", "METHOD_END"], "methodName": ["assertTestBeanCount"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( getListableBeanFactory (  )  . containsBeanDefinition (  \" rod \"  )  )  ;", "assertTrue ( getListableBeanFactory (  )  . containsBeanDefinition (  \" roderick \"  )  )  ;", "}", "METHOD_END"], "methodName": ["containsBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertCount (  1  3  )  ;", "}", "METHOD_END"], "methodName": ["count"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  (  \" Should   have    2    factories ,    not    \"     +     ( getListableBeanFactory (  )  . getBeanNamesForType ( FactoryBean . class )  . length )  )  ,     (  ( getListableBeanFactory (  )  . getBeanNamesForType ( FactoryBean . class )  . length )     =  =     2  )  )  ;", "assertTrue (  (  \" Should   have    2    factories ,    not    \"     +     ( getListableBeanFactory (  )  . getBeanNamesForType ( FactoryBean . class )  . length )  )  ,     (  ( getListableBeanFactory (  )  . getBeanNamesForType ( FactoryBean . class )  . length )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["getCountForFactoryClass"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    defnames    =    getListableBeanFactory (  )  . getBeanNamesForType ( String . class )  ;", "assertTrue (  \" No   string   definitions \"  ,     (  ( defnames . length )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefinitionsForNoSuchClass"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "BeanFactory   bf    =    getBeanFactory (  )  ;", "if    (  !  ( bf   instanceof    )  )     {", "throw   new   IllegalStateException (  \"    required \"  )  ;", "}", "return    (  (  )     ( bf )  )  ;", "}", "METHOD_END"], "methodName": ["getListableBeanFactory"], "fileName": "org.springframework.beans.factory.xml.AbstractListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   Conventions . attributeNameToPropertyName ( attributeName )  ;", "}", "METHOD_END"], "methodName": ["extractPropertyName"], "fileName": "org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return    !  ( AbstractBeanDefinitionParser . ID _ ATTRIBUTE . equals ( attributeName )  )  ;", "}", "METHOD_END"], "methodName": ["isEligibleAttribute"], "fileName": "org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "String   fullName    =    attribute . getName (  )  ;", "return    (  (  !  ( fullName . equals (  \" xmlns \"  )  )  )     &  &     (  !  ( fullName . startsWith (  \" xmlns :  \"  )  )  )  )     &  &     ( isEligibleAttribute ( pContext . getDelegate (  )  . getLocalName ( attribute )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEligibleAttribute"], "fileName": "org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "doParse ( element ,    builder )  ;", "}", "METHOD_END"], "methodName": ["doParse"], "fileName": "org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getBeanClass"], "fileName": "org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getBeanClassName"], "fileName": "org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getParentName"], "fileName": "org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "TestBean   sally    =     (  ( TestBean )     ( beanFactory . getBean (  \" sally \"  )  )  )  ;", "assertEquals ( sally ,    rob . getSpouse (  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithAutoSelfExclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithExclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   parent    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "parent . preInstantiateSingletons (  )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "RootBeanDefinition   robDef    =    new   RootBeanDefinition ( TestBean . class )  ;", "robDef . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "robDef . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" sally \"  )  )  ;", "child . registerBeanDefinition (  \" rob 2  \"  ,    robDef )  ;", "TestBean   rob    =     (  ( TestBean )     ( child . getBean (  \" rob 2  \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithExclusionInParentFactory"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - with - inclusion . xml \"  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithInclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   parent    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "parent . getBeanDefinition (  \" props 1  \"  )  . setPrimary ( true )  ;", "parent . preInstantiateSingletons (  )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "RootBeanDefinition   robDef    =    new   RootBeanDefinition ( TestBean . class )  ;", "robDef . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "robDef . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" sally \"  )  )  ;", "child . registerBeanDefinition (  \" rob 2  \"  ,    robDef )  ;", "RootBeanDefinition   propsDef    =    new   RootBeanDefinition ( PropertiesFactoryBean . class )  ;", "propsDef . getPropertyValues (  )  . add (  \" properties \"  ,     \" name = props 3  \"  )  ;", "propsDef . setPrimary ( true )  ;", "child . registerBeanDefinition (  \" props 3  \"  ,    propsDef )  ;", "TestBean   rob    =     (  ( TestBean )     ( child . getBean (  \" rob 2  \"  )  )  )  ;", "assertEquals (  \" props 3  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithPrimaryInParentAndChild"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   parent    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "parent . getBeanDefinition (  \" props 1  \"  )  . setPrimary ( true )  ;", "parent . preInstantiateSingletons (  )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "RootBeanDefinition   robDef    =    new   RootBeanDefinition ( TestBean . class )  ;", "robDef . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "robDef . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" sally \"  )  )  ;", "child . registerBeanDefinition (  \" rob 2  \"  ,    robDef )  ;", "RootBeanDefinition   propsDef    =    new   RootBeanDefinition ( PropertiesFactoryBean . class )  ;", "propsDef . getPropertyValues (  )  . add (  \" properties \"  ,     \" name = props 3  \"  )  ;", "child . registerBeanDefinition (  \" props 3  \"  ,    propsDef )  ;", "TestBean   rob    =     (  ( TestBean )     ( child . getBean (  \" rob 2  \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithPrimaryInParentFactory"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   parent    =    getBeanFactory (  \" autowire - with - e . xml \"  )  ;", "parent . preInstantiateSingletons (  )  ;", "DefaultListableBeanFactory   child    =    new   DefaultListableBeanFactory ( parent )  ;", "RootBeanDefinition   robDef    =    new   RootBeanDefinition ( TestBean . class )  ;", "robDef . setAutowireMode ( RootBeanDefinition . AUTOWIRE _ BY _ TYPE )  ;", "robDef . getPropertyValues (  )  . add (  \" spouse \"  ,    new   RuntimeBeanReference (  \" sally \"  )  )  ;", "child . registerBeanDefinition (  \" rob 2  \"  ,    robDef )  ;", "RootBeanDefinition   propsDef    =    new   RootBeanDefinition ( PropertiesFactoryBean . class )  ;", "propsDef . getPropertyValues (  )  . add (  \" properties \"  ,     \" name = props 3  \"  )  ;", "propsDef . setPrimary ( true )  ;", "child . registerBeanDefinition (  \" props 3  \"  ,    propsDef )  ;", "TestBean   rob    =     (  ( TestBean )     ( child . getBean (  \" rob 2  \"  )  )  )  ;", "assertEquals (  \" props 3  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithPrimaryOverridingParentFactory"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . reset (  )  ;", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - with - selective - inclusion . xml \"  )  ;", "beanFactory . preInstantiateSingletons (  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "assertEquals (  1  ,    CountingFactory . getFactoryBeanInstanceCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["byTypeAutowireWithSelectiveInclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - constructor - with - exclusion . xml \"  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "TestBean   sally    =     (  ( TestBean )     ( beanFactory . getBean (  \" sally \"  )  )  )  ;", "assertEquals ( sally ,    rob . getSpouse (  )  )  ;", "TestBean   rob 2     =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "assertEquals ( rob ,    rob 2  )  ;", "assertNotSame ( rob ,    rob 2  )  ;", "assertEquals ( rob . getSpouse (  )  ,    rob 2  . getSpouse (  )  )  ;", "assertNotSame ( rob . getSpouse (  )  ,    rob 2  . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorAutowireWithAutoSelfExclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    getBeanFactory (  \" autowire - constructor - with - exclusion . xml \"  )  ;", "TestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "assertEquals (  \" props 1  \"  ,    rob . getSomeProperties (  )  . getProperty (  \" name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorAutowireWithExclusion"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource ( configPath ,    getClass (  )  )  )  ;", "return   bf ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.beans.factory.xml.AutowireWithExclusionTests"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    this . readerContext . getBeanClassLoader (  )  ;", "TypedStringValue   typedValue ;", "if    (  !  ( StringUtils . hasText ( targetTypeName )  )  )     {", "typedValue    =    new   TypedStringValue ( value )  ;", "} else", "if    ( classLoader    !  =    null )     {", "Class <  ?  >    targetType    =    util . ClassUtils . forName ( targetTypeName ,    classLoader )  ;", "typedValue    =    new   TypedStringValue ( value ,    targetType )  ;", "} else    {", "typedValue    =    new   TypedStringValue ( value ,    targetTypeName )  ;", "}", "return   typedValue ;", "}", "METHOD_END"], "methodName": ["buildTypedStringValue"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "try    {", "TypedStValue   typedValue    =    buildTypedStValue ( value ,    defaultTypeName )  ;", "typedValue . setSource ( extractSource ( entryEle )  )  ;", "return   typedValue ;", "}    catch    ( ClassNotFoundException   ex )     {", "error (  (  (  \" Type   class    [  \"     +    defaultTypeName )     +     \"  ]    not   found   for   Map   key / value   type \"  )  ,    entryEle ,    ex )  ;", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["buildTypedStringValueForMap"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   foundName    =    null ;", "if    (  ( StringUtils . hasText ( beanName )  )     &  &     ( this . usedNames . contains ( beanName )  )  )     {", "foundName    =    beanName ;", "}", "if    ( foundName    =  =    null )     {", "foundName    =    CollectionUtils . findFirstMatch ( this . usedNames ,    aliases )  ;", "}", "if    ( foundName    !  =    null )     {", "error (  (  (  \" Bean   name    '  \"     +    foundName )     +     \"  '    is   already   used   in   this    <  >    element \"  )  ,    beanElement )  ;", "}", "this . usedNames . add ( beanName )  ;", "this . usedNames . addAll ( aliases )  ;", "}", "METHOD_END"], "methodName": ["checkNameUniqueness"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionReaderUtils . createBeanDefinition ( parentName ,    className ,    this . readerContext . getBeanClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   decorateBeanDefinitionIfRequired ( ele ,    definitionHolder ,    null )  ;", "}", "METHOD_END"], "methodName": ["decorateBeanDefinitionIfRequired"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionHolder   finalDefinition    =    definitionHolder ;", "NamedNodeMap   attributes    =    ele . getAttributes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( attributes . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    attributes . item ( i )  ;", "finalDefinition    =    decorateIfRequired ( node ,    finalDefinition ,    containingBd )  ;", "}", "NodeList   children    =    ele . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( children . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    children . item ( i )  ;", "if    (  ( node . getNodeType (  )  )     =  =     ( Node . ELEMENT _ NODE )  )     {", "finalDefinition    =    decorateIfRequired ( node ,    finalDefinition ,    containingBd )  ;", "}", "}", "return   finalDefinition ;", "}", "METHOD_END"], "methodName": ["decorateBeanDefinitionIfRequired"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   namespaceUri    =    getNamespaceURI ( node )  ;", "if    (  ( namespaceUri    !  =    null )     &  &     (  !  ( isDefaultNamespace ( namespaceUri )  )  )  )     {", "NamespaceHandler   handler    =    this . readerContext . getNamespaceHandlerResolver (  )  . resolve ( namespaceUri )  ;", "if    ( handler    !  =    null )     {", "BeanDefinitionHolder   decorated    =    handler . decorate ( node ,    originalDef ,    new   ParserContext ( this . readerContext ,    this ,    containingBd )  )  ;", "if    ( decorated    !  =    null )     {", "return   decorated ;", "}", "} else", "if    ( namespaceUri . startsWith (  \" http :  /  / wwworg /  \"  )  )     {", "error (  (  (  \" Unable   to   locate   Spring   NamespaceHandler   for   XML   schema   namespace    [  \"     +    namespaceUri )     +     \"  ]  \"  )  ,    node )  ;", "} else    {", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  \" No   Spring   NamespaceHandler   found   for   XML   schema   namespace    [  \"     +    namespaceUri )     +     \"  ]  \"  )  )  ;", "}", "}", "}", "return   originalDef ;", "}", "METHOD_END"], "methodName": ["decorateIfRequired"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "this . readerContext . error ( message ,    source ,    this . parseState . snapshot (  )  )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "this . readerContext . error ( message ,    source ,    this . parseState . snapshot (  )  ,    cause )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "this . readerContext . error ( message ,    source ,    this . parseState . snapshot (  )  )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   this . readerContext . extractSource ( ele )  ;", "}", "METHOD_END"], "methodName": ["extractSource"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   candidatePattern    =    this . defaults . getAutowireCandidates (  )  ;", "return   candidatePattern    !  =    null    ?    StringUtils . commaDelimitedListToStringArray ( candidatePattern )     :    null ;", "}", "METHOD_END"], "methodName": ["getAutowireCandidatePatterns"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   att    =    attValue ;", "if    (  . DEFAULT _ VALUE . equals ( att )  )     {", "att    =    this . defaults . getAutowire (  )  ;", "}", "int   autowire    =    AbstractBeanDefinition . AUTOWIRE _ NO ;", "if    (  . AUTOWIRE _ BY _ NAME _ VALUE . equals ( att )  )     {", "autowire    =    AbstractBeanDefinition . AUTOWIRE _ BY _ NAME ;", "} else", "if    (  . AUTOWIRE _ BY _ TYPE _ VALUE . equals ( att )  )     {", "autowire    =    AbstractBeanDefinition . AUTOWIRE _ BY _ TYPE ;", "} else", "if    (  . AUTOWIRE _ CONSTRUCTOR _ VALUE . equals ( att )  )     {", "autowire    =    AbstractBeanDefinition . AUTOWIRE _ CONSTRUCTOR ;", "} else", "if    (  . AUTOWIRE _ AUTODETECT _ VALUE . equals ( att )  )     {", "autowire    =    AbstractBeanDefinition . AUTOWIRE _ AUTODETECT ;", "}", "return   autowire ;", "}", "METHOD_END"], "methodName": ["getAutowireMode"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionDefaults   bdd    =    new   BeanDefinitionDefaults (  )  ;", "bdd . setLazyInit (  \" TRUE \"  . equalsIgnoreCase ( this . defaults . getLazyInit (  )  )  )  ;", "bdd . setAutowireMode ( getAutowireMode (  . DEFAULT _ VALUE )  )  ;", "bdd . setInitMethodName ( this . defaults . getInitMethod (  )  )  ;", "bdd . setDestroyMethodName ( this . defaults . getDestroyMethod (  )  )  ;", "return   bdd ;", "}", "METHOD_END"], "methodName": ["getBeanDefinitionDefaults"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   this . defaults ;", "}", "METHOD_END"], "methodName": ["getDefaults"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   node . getLocalName (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalName"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   node . getNamespaceURI (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespaceURI"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   this . readerContext ;", "}", "METHOD_END"], "methodName": ["getReaderContext"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "initDefaults ( root ,    null )  ;", "}", "METHOD_END"], "methodName": ["initDefaults"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "populateDefaults ( this . defaults ,     ( parent    !  =    null    ?    parent . defaults    :    null )  ,    root )  ;", "this . readerContext . fireDefaultsRegistered ( this . defaults )  ;", "}", "METHOD_END"], "methodName": ["initDefaults"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( node   instanceof   Element )     &  &     (  ( isDefaultNamespace ( node )  )     |  |     (  !  ( isDefaultNamespace ( node . getParentNode (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCandidateElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( StringUtils . hasLength ( namespaceUri )  )  )     |  |     ( BeanDefinitionParserDelegate . BEANS _ NAMESPACE _ URI . equals ( namespaceUri )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultNamespace"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   isDefaultNamespace ( getNamespaceURI ( node )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultNamespace"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return    ( desiredName . equals ( node . getNodeName (  )  )  )     |  |     ( desiredName . equals ( getLocalName ( node )  )  )  ;", "}", "METHOD_END"], "methodName": ["nodeNameEquals"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   elementType    =    arrayEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "NodeList   nl    =    arrayEle . getChildNodes (  )  ;", "ManagedArray   target    =    new   ManagedArray ( elementType ,    nl . getLength (  )  )  ;", "target . setSource ( extractSource ( arrayEle )  )  ;", "target . setElementTypeName ( elementType )  ;", "target . setMergeEnabled ( parseMergeAttribute ( arrayEle )  )  ;", "parseCollectionElements ( nl ,    target ,    bd ,    elementType )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["parseArrayElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . SINGLETON _ ATTRIBUTE )  )     {", "error (  \" Old    1  . x    ' singleton '    attribute   in   use    -    upgrade   to    ' scope '    declaration \"  ,    ele )  ;", "} else", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . SCOPE _ ATTRIBUTE )  )     {", "bd . setScope ( ele . getAttribute ( BeanDefinitionParserDelegate . SCOPE _ ATTRIBUTE )  )  ;", "} else", "if    ( containingBean    !  =    null )     {", "bd . setScope ( containingBean . getScope (  )  )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . ABSTRACT _ ATTRIBUTE )  )     {", "bd . setAbstract ( BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( ele . getAttribute ( BeanDefinitionParserDelegate . ABSTRACT _ ATTRIBUTE )  )  )  ;", "}", "String   lazyInit    =    ele . getAttribute ( BeanDefinitionParserDelegate . LAZY _ INIT _ ATTRIBUTE )  ;", "if    ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( lazyInit )  )     {", "lazyInit    =    this . defaults . getLazyInit (  )  ;", "}", "bd . setLazyInit ( BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( lazyInit )  )  ;", "String   autowire    =    ele . getAttribute ( BeanDefinitionParserDelegate . AUTOWIRE _ ATTRIBUTE )  ;", "bd . setAutowireMode ( getAutowireMode ( autowire )  )  ;", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . DEPENDS _ ON _ ATTRIBUTE )  )     {", "String   dependsOn    =    ele . getAttribute ( BeanDefinitionParserDelegate . DEPENDS _ ON _ ATTRIBUTE )  ;", "bd . setDependsOn ( StringUtils . tokenizeToStringArray ( dependsOn ,    BeanDefinitionParserDelegate . MULTI _ VALUE _ ATTRIBUTE _ DELIMITERS )  )  ;", "}", "String   autowireCandidate    =    ele . getAttribute ( BeanDefinitionParserDelegate . AUTOWIRE _ CANDIDATE _ ATTRIBUTE )  ;", "if    (  (  \"  \"  . equals ( autowireCandidate )  )     |  |     ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( autowireCandidate )  )  )     {", "String   candidatePattern    =    this . defaults . getAutowireCandidates (  )  ;", "if    ( candidatePattern    !  =    null )     {", "String [  ]    patterns    =    StringUtils . commaDelimitedListToStringArray ( candidatePattern )  ;", "bd . setAutowireCandidate ( PatternMatchUtils . simpleMatch ( patterns ,    beanName )  )  ;", "}", "} else    {", "bd . setAutowireCandidate ( BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( autowireCandidate )  )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . PRIMARY _ ATTRIBUTE )  )     {", "bd . setPrimary ( BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( ele . getAttribute ( BeanDefinitionParserDelegate . PRIMARY _ ATTRIBUTE )  )  )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . INIT _ METHOD _ ATTRIBUTE )  )     {", "String   initMethodName    =    ele . getAttribute ( BeanDefinitionParserDelegate . INIT _ METHOD _ ATTRIBUTE )  ;", "bd . setInitMethodName ( initMethodName )  ;", "} else", "if    (  ( this . defaults . getInitMethod (  )  )     !  =    null )     {", "bd . setInitMethodName ( this . defaults . getInitMethod (  )  )  ;", "bd . setEnforceInitMethod ( false )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . DESTROY _ METHOD _ ATTRIBUTE )  )     {", "String   destroyMethodName    =    ele . getAttribute ( BeanDefinitionParserDelegate . DESTROY _ METHOD _ ATTRIBUTE )  ;", "bd . setDestroyMethodName ( destroyMethodName )  ;", "} else", "if    (  ( this . defaults . getDestroyMethod (  )  )     !  =    null )     {", "bd . setDestroyMethodName ( this . defaults . getDestroyMethod (  )  )  ;", "bd . setEnforceDestroyMethod ( false )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . FACTORY _ METHOD _ ATTRIBUTE )  )     {", "bd . setFactoryMethodName ( ele . getAttribute ( BeanDefinitionParserDelegate . FACTORY _ METHOD _ ATTRIBUTE )  )  ;", "}", "if    ( ele . hasAttribute ( BeanDefinitionParserDelegate . FACTORY _ BEAN _ ATTRIBUTE )  )     {", "bd . setFactoryBeanName ( ele . getAttribute ( BeanDefinitionParserDelegate . FACTORY _ BEAN _ ATTRIBUTE )  )  ;", "}", "return   bd ;", "}", "METHOD_END"], "methodName": ["parseBeanDefinitionAttributes"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   parseBeanDefinitionElement ( ele ,    null )  ;", "}", "METHOD_END"], "methodName": ["parseBeanDefinitionElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "this . parseState . push ( new   BeanEntry ( beanName )  )  ;", "String   className    =    null ;", "if    ( ele . hasAttribute (  . CLASS _ ATTRIBUTE )  )     {", "className    =    ele . getAttribute (  . CLASS _ ATTRIBUTE )  . trim (  )  ;", "}", "String   parent    =    null ;", "if    ( ele . hasAttribute (  . PARENT _ ATTRIBUTE )  )     {", "parent    =    ele . getAttribute (  . PARENT _ ATTRIBUTE )  ;", "}", "try    {", "AbstractBeanDefinition   bd    =    createBeanDefinition ( className ,    parent )  ;", "parseBeanDefinitionAttributes ( ele ,    beanName ,    containingBean ,    bd )  ;", "bd . setDescription ( DomUtils . getChildElementValueByTagName ( ele ,     . DESCRIPTION _ ELEMENT )  )  ;", "parseMetaElements ( ele ,    bd )  ;", "parseLookupOverrideSubElements ( ele ,    bd . getMethodOverrides (  )  )  ;", "parseReplacedMethodSubElements ( ele ,    bd . getMethodOverrides (  )  )  ;", "parseConstructorArgElements ( ele ,    bd )  ;", "parsePropertyElements ( ele ,    bd )  ;", "parseQualifierElements ( ele ,    bd )  ;", "bd . setResource ( this . readerContext . getResource (  )  )  ;", "bd . setSource ( extractSource ( ele )  )  ;", "return   bd ;", "}    catch    ( ClassNotFoundException   ex )     {", "error (  (  (  \" Bean   class    [  \"     +    className )     +     \"  ]    not   found \"  )  ,    ele ,    ex )  ;", "}    catch    ( NoClassDefFoundError   err )     {", "error (  (  (  \" Class   that   bean   class    [  \"     +    className )     +     \"  ]    depends   on   not   found \"  )  ,    ele ,    err )  ;", "}    catch    ( Throwable   ex )     {", "error (  \" Unexpected   failure   during   bean   definition   parsing \"  ,    ele ,    ex )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseBeanDefinitionElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   id    =    ele . getAttribute ( BeanDefinitionParserDelegate . ID _ ATTRIBUTE )  ;", "String   nameAttr    =    ele . getAttribute ( BeanDefinitionParserDelegate . NAME _ ATTRIBUTE )  ;", "List < String >    aliases    =    new   ArrayList <  >  (  )  ;", "if    ( StringUtils . hasLength ( nameAttr )  )     {", "String [  ]    nameArr    =    StringUtils . tokenizeToStringArray ( nameAttr ,    BeanDefinitionParserDelegate . MULTI _ VALUE _ ATTRIBUTE _ DELIMITERS )  ;", "aliases . addAll ( Arrays . asList ( nameArr )  )  ;", "}", "String   beanName    =    id ;", "if    (  (  !  ( StringUtils . hasText ( beanName )  )  )     &  &     (  !  ( aliases . isEmpty (  )  )  )  )     {", "beanName    =    aliases . remove (  0  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" No   XML    ' id '    specified    -    using    '  \"     +    beanName )     +     \"  '    as   bean   name   and    \"  )     +    aliases )     +     \"    as   aliases \"  )  )  ;", "}", "}", "if    ( containingBean    =  =    null )     {", "checkNameUniqueness ( beanName ,    aliases ,    ele )  ;", "}", "AbstractBeanDefinition   beanDefinition    =    parseBeanDefinitionElement ( ele ,    beanName ,    containingBean )  ;", "if    ( beanDefinition    !  =    null )     {", "if    (  !  ( StringUtils . hasText ( beanName )  )  )     {", "try    {", "if    ( containingBean    !  =    null )     {", "beanName    =    BeanDefinitionReaderUtils . generateBeanName ( beanDefinition ,    this . readerContext . getRegistry (  )  ,    true )  ;", "} else    {", "beanName    =    this . readerContext . generateBeanName ( beanDefinition )  ;", "String   beanClassName    =    beanDefinition . getBeanClassName (  )  ;", "if    (  (  (  ( beanClassName    !  =    null )     &  &     ( beanName . startsWith ( beanClassName )  )  )     &  &     (  ( beanName . length (  )  )     >     ( beanClassName . length (  )  )  )  )     &  &     (  !  ( this . readerContext . getRegistry (  )  . isBeanNameInUse ( beanClassName )  )  )  )     {", "aliases . add ( beanClassName )  ;", "}", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  \" Neither   XML    ' id '    nor    ' name '    specified    -     \"     +     \" using   generated   bean   name    [  \"  )     +    beanName )     +     \"  ]  \"  )  )  ;", "}", "}    catch    ( Exception   ex )     {", "error ( ex . getMessage (  )  ,    ele )  ;", "return   null ;", "}", "}", "String [  ]    aliasesArray    =    StringUtils . toStringArray ( aliases )  ;", "return   new   BeanDefinitionHolder ( beanDefinition ,    beanName ,    aliasesArray )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["parseBeanDefinitionElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( elementNodes . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    elementNodes . item ( i )  ;", "if    (  ( node   instanceof   Element )     &  &     (  !  ( nodeNameEquals ( node ,     . DESCRIPTION _ ELEMENT )  )  )  )     {", "target . add ( parsePropertySubElement (  (  ( Element )     ( node )  )  ,    bd ,    defaultElementType )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseCollectionElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   indexAttr    =    ele . getAttribute ( BeanDefinitionParserDelegate . INDEX _ ATTRIBUTE )  ;", "String   typeAttr    =    ele . getAttribute ( BeanDefinitionParserDelegate . TYPE _ ATTRIBUTE )  ;", "String   nameAttr    =    ele . getAttribute ( BeanDefinitionParserDelegate . NAME _ ATTRIBUTE )  ;", "if    ( StringUtils . hasLength ( indexAttr )  )     {", "try    {", "int   index    =    Integer . parseInt ( indexAttr )  ;", "if    ( index    <     0  )     {", "error (  \"  ' index '    cannot   be   lower   than    0  \"  ,    ele )  ;", "} else    {", "try    {", "this . parseState . push ( new   ConstructorArgumentEntry ( index )  )  ;", "Object   value    =    parsePropertyValue ( ele ,    bd ,    null )  ;", "ConstructorArgumentValues . ValueHolder   valueHolder    =    new   ConstructorArgumentValues . ValueHolder ( value )  ;", "if    ( StringUtils . hasLength ( typeAttr )  )     {", "valueHolder . setType ( typeAttr )  ;", "}", "if    ( StringUtils . hasLength ( nameAttr )  )     {", "valueHolder . setName ( nameAttr )  ;", "}", "valueHolder . setSource ( extractSource ( ele )  )  ;", "if    ( bd . getConstructorArgumentValues (  )  . hasIndexedArgumentValue ( index )  )     {", "error (  (  \" Ambiguous   constructor - arg   entries   for   index    \"     +    index )  ,    ele )  ;", "} else    {", "bd . getConstructorArgumentValues (  )  . addIndexedArgumentValue ( index ,    valueHolder )  ;", "}", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "}    catch    ( NumberFormatException   ex )     {", "error (  \" Attribute    ' index '    of   tag    ' constructor - arg '    must   be   an   integer \"  ,    ele )  ;", "}", "} else    {", "try    {", "this . parseState . push ( new   ConstructorArgumentEntry (  )  )  ;", "Object   value    =    parsePropertyValue ( ele ,    bd ,    null )  ;", "ConstructorArgumentValues . ValueHolder   valueHolder    =    new   ConstructorArgumentValues . ValueHolder ( value )  ;", "if    ( StringUtils . hasLength ( typeAttr )  )     {", "valueHolder . setType ( typeAttr )  ;", "}", "if    ( StringUtils . hasLength ( nameAttr )  )     {", "valueHolder . setName ( nameAttr )  ;", "}", "valueHolder . setSource ( extractSource ( ele )  )  ;", "bd . getConstructorArgumentValues (  )  . addGenericArgumentValue ( valueHolder )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseConstructorArgElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    beanEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . CONSTRUCTOR _ ARG _ ELEMENT )  )  )     {", "parseConstructorArgElement (  (  ( Element )     ( node )  )  ,    bd )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseConstructorArgElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   parseCustomElement ( ele ,    null )  ;", "}", "METHOD_END"], "methodName": ["parseCustomElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   namespaceUri    =    getNamespaceURI ( ele )  ;", "if    ( namespaceUri    =  =    null )     {", "return   null ;", "}", "NamespaceHandler   handler    =    this . readerContext . getNamespaceHandlerResolver (  )  . resolve ( namespaceUri )  ;", "if    ( handler    =  =    null )     {", "error (  (  (  \" Unable   to   locate   Spring   NamespaceHandler   for   XML   schema   namespace    [  \"     +    namespaceUri )     +     \"  ]  \"  )  ,    ele )  ;", "return   null ;", "}", "return   handler . parse ( ele ,    new   Context ( this . readerContext ,    this ,    containingBd )  )  ;", "}", "METHOD_END"], "methodName": ["parseCustomElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   refName    =    ele . getAttribute ( BeanDefinitionParserDelegate . BEAN _ REF _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasLength ( refName )  )  )     {", "error (  \"  ' bean '    is   required   for    < idref >    element \"  ,    ele )  ;", "return   null ;", "}", "if    (  !  ( StringUtils . hasText ( refName )  )  )     {", "error (  \"  < idref >    element   contains   empty   target   attribute \"  ,    ele )  ;", "return   null ;", "}", "RuntimeBeanNameReference   ref    =    new   RuntimeBeanNameReference ( refName )  ;", "ref . setSource ( extractSource ( ele )  )  ;", "return   ref ;", "}", "METHOD_END"], "methodName": ["parseIdRefElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    keyEle . getChildNodes (  )  ;", "Element   subElement    =    null ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    ( node   instanceof   Element )     {", "if    ( subElement    !  =    null )     {", "error (  \"  < key >    element   must   not   contain   more   than   one   value   sub - element \"  ,    keyEle )  ;", "} else    {", "subElement    =     (  ( Element )     ( node )  )  ;", "}", "}", "}", "if    ( subElement    =  =    null )     {", "return   null ;", "}", "return   pPropertySubElement ( subElement ,    bd ,    defaultKeyTypeName )  ;", "}", "METHOD_END"], "methodName": ["parseKeyElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   defaultElementType    =    collectionEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "NodeList   nl    =    collectionEle . getChildNodes (  )  ;", "ManagedList < Object >    target    =    new   ManagedList <  >  ( nl . getLength (  )  )  ;", "target . setSource ( extractSource ( collectionEle )  )  ;", "target . setElementTypeName ( defaultElementType )  ;", "target . setMergeEnabled ( parseMergeAttribute ( collectionEle )  )  ;", "parseCollectionElements ( nl ,    target ,    bd ,    defaultElementType )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["parseListElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    beanEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . LOOKUP _ METHOD _ ELEMENT )  )  )     {", "Element   ele    =     (  ( Element )     ( node )  )  ;", "String   methodName    =    ele . getAttribute (  . NAME _ ATTRIBUTE )  ;", "String   beanRef    =    ele . getAttribute (  . BEAN _ ELEMENT )  ;", "LookupOverride   override    =    new   LookupOverride ( methodName ,    beanRef )  ;", "override . setSource ( extractSource ( ele )  )  ;", "overrides . addOverride ( override )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseLookupOverrideSubElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   defaultKeyType    =    mapEle . getAttribute ( BeanDefinitionParserDelegate . KEY _ TYPE _ ATTRIBUTE )  ;", "String   defaultValueType    =    mapEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "List < Element >    entryEles    =    DomUtils . getChildElementsByTagName ( mapEle ,    BeanDefinitionParserDelegate . ENTRY _ ELEMENT )  ;", "ManagedMap < Object ,    Object >    map    =    new   ManagedMap <  >  ( entryEles . size (  )  )  ;", "map . setSource ( extractSource ( mapEle )  )  ;", "map . setKeyTypeName ( defaultKeyType )  ;", "map . setValueTypeName ( defaultValueType )  ;", "map . setMergeEnabled ( parseMergeAttribute ( mapEle )  )  ;", "for    ( Element   entryEle    :    entryEles )     {", "NodeList   entrySubNodes    =    entryEle . getChildNodes (  )  ;", "Element   keyEle    =    null ;", "Element   valueEle    =    null ;", "for    ( int   j    =     0  ;    j    <     ( entrySubNodes . getLength (  )  )  ;    j +  +  )     {", "Node   node    =    entrySubNodes . item ( j )  ;", "if    ( node   instanceof   Element )     {", "Element   candidateEle    =     (  ( Element )     ( node )  )  ;", "if    ( nodeNameEquals ( candidateEle ,    BeanDefinitionParserDelegate . KEY _ ELEMENT )  )     {", "if    ( keyEle    !  =    null )     {", "error (  \"  < entry >    element   is   only   allowed   to   contain   one    < key >    sub - element \"  ,    entryEle )  ;", "} else    {", "keyEle    =    candidateEle ;", "}", "} else    {", "if    ( nodeNameEquals ( candidateEle ,    BeanDefinitionParserDelegate . DESCRIPTION _ ELEMENT )  )     {", "} else", "if    ( valueEle    !  =    null )     {", "error (  \"  < entry >    element   must   not   contain   more   than   one   value   sub - element \"  ,    entryEle )  ;", "} else    {", "valueEle    =    candidateEle ;", "}", "}", "}", "}", "Object   key    =    null ;", "boolean   hasKeyAttribute    =    entryEle . hasAttribute ( BeanDefinitionParserDelegate . KEY _ ATTRIBUTE )  ;", "boolean   hasKeyRefAttribute    =    entryEle . hasAttribute ( BeanDefinitionParserDelegate . KEY _ REF _ ATTRIBUTE )  ;", "if    (  ( hasKeyAttribute    &  &    hasKeyRefAttribute )     |  |     (  ( hasKeyAttribute    |  |    hasKeyRefAttribute )     &  &     ( keyEle    !  =    null )  )  )     {", "error (  (  \"  < entry >    element   is   only   allowed   to   contain   either    \"     +     \" a    ' key '    attribute   OR   a    ' key - ref '    attribute   OR   a    < key >    sub - element \"  )  ,    entryEle )  ;", "}", "if    ( hasKeyAttribute )     {", "key    =    buildTypedStringValueForMap ( entryEle . getAttribute ( BeanDefinitionParserDelegate . KEY _ ATTRIBUTE )  ,    defaultKeyType ,    entryEle )  ;", "} else", "if    ( hasKeyRefAttribute )     {", "String   refName    =    entryEle . getAttribute ( BeanDefinitionParserDelegate . KEY _ REF _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( refName )  )  )     {", "error (  \"  < entry >    element   contains   empty    ' key - ref '    attribute \"  ,    entryEle )  ;", "}", "config . RuntimeBeanReference   ref    =    new   config . RuntimeBeanReference ( refName )  ;", "ref . setSource ( extractSource ( entryEle )  )  ;", "key    =    ref ;", "} else", "if    ( keyEle    !  =    null )     {", "key    =    parseKeyElement ( keyEle ,    bd ,    defaultKeyType )  ;", "} else    {", "error (  \"  < entry >    element   must   specify   a   key \"  ,    entryEle )  ;", "}", "Object   value    =    null ;", "boolean   hasValueAttribute    =    entryEle . hasAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  ;", "boolean   hasValueRefAttribute    =    entryEle . hasAttribute ( BeanDefinitionParserDelegate . VALUE _ REF _ ATTRIBUTE )  ;", "boolean   hasValueTypeAttribute    =    entryEle . hasAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "if    (  ( hasValueAttribute    &  &    hasValueRefAttribute )     |  |     (  ( hasValueAttribute    |  |    hasValueRefAttribute )     &  &     ( valueEle    !  =    null )  )  )     {", "error (  (  \"  < entry >    element   is   only   allowed   to   contain   either    \"     +     \"  ' value '    attribute   OR    ' value - ref '    attribute   OR    < value >    sub - element \"  )  ,    entryEle )  ;", "}", "if    (  (  ( hasValueTypeAttribute    &  &    hasValueRefAttribute )     |  |     ( hasValueTypeAttribute    &  &     (  ! hasValueAttribute )  )  )     |  |     ( hasValueTypeAttribute    &  &     ( valueEle    !  =    null )  )  )     {", "error (  (  \"  < entry >    element   is   only   allowed   to   contain   a    ' value - type '     \"     +     \" attribute   when   it   has   a    ' value '    attribute \"  )  ,    entryEle )  ;", "}", "if    ( hasValueAttribute )     {", "String   valueType    =    entryEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( valueType )  )  )     {", "valueType    =    defaultValueType ;", "}", "value    =    buildTypedStringValueForMap ( entryEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  ,    valueType ,    entryEle )  ;", "} else", "if    ( hasValueRefAttribute )     {", "String   refName    =    entryEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ REF _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( refName )  )  )     {", "error (  \"  < entry >    element   contains   empty    ' value - ref '    attribute \"  ,    entryEle )  ;", "}", "config . RuntimeBeanReference   ref    =    new   config . RuntimeBeanReference ( refName )  ;", "ref . setSource ( extractSource ( entryEle )  )  ;", "value    =    ref ;", "} else", "if    ( valueEle    !  =    null )     {", "value    =    parsePropertySubElement ( valueEle ,    bd ,    defaultValueType )  ;", "} else    {", "error (  \"  < entry >    element   must   specify   a   value \"  ,    entryEle )  ;", "}", "map . put ( key ,    value )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["parseMapElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   value    =    collectionElement . getAttribute ( BeanDefinitionParserDelegate . MERGE _ ATTRIBUTE )  ;", "if    ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( value )  )     {", "value    =    this . defaults . getMerge (  )  ;", "}", "return   BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( value )  ;", "}", "METHOD_END"], "methodName": ["parseMergeAttribute"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    ele . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . META _ ELEMENT )  )  )     {", "Element   metaElement    =     (  ( Element )     ( node )  )  ;", "String   key    =    metaElement . getAttribute (  . KEY _ ATTRIBUTE )  ;", "String   value    =    metaElement . getAttribute (  . VALUE _ ATTRIBUTE )  ;", "BeanMetadataAttribute   attribute    =    new   BeanMetadataAttribute ( key ,    value )  ;", "attribute . setSource ( extractSource ( metaElement )  )  ;", "attributeAccessor . addMetadataAttribute ( attribute )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseMetaElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   innerDefinition    =    parseCustomElement ( ele ,    containingBd )  ;", "if    ( innerDefinition    =  =    null )     {", "error (  (  (  (  \" Incorrect   usage   of   element    '  \"     +     ( ele . getNodeName (  )  )  )     +     \"  '    in   a   nested   manner .     \"  )     +     \" This   tag   cannot   be   used   nested   inside    < property >  .  \"  )  ,    ele )  ;", "return   null ;", "}", "String   id    =     (  ( ele . getNodeName (  )  )     +     ( BeanDefinitionReaderUtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +     ( ObjectUtils . getIdentityHexString ( innerDefinition )  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Using   generated   bean   name    [  \"     +    id )     +     \"  ]    for   nested   custom   element    '  \"  )     +     ( ele . getNodeName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "return   new   BeanDefinitionHolder ( innerDefinition ,    id )  ;", "}", "METHOD_END"], "methodName": ["parseNestedCustomElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   propertyName    =    ele . getAttribute ( BeanDefinitionParserDelegate . NAME _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasLength ( propertyName )  )  )     {", "error (  \" Tag    ' property '    must   have   a    ' name '    attribute \"  ,    ele )  ;", "return ;", "}", "this . parseState . push ( new   PropertyEntry ( propertyName )  )  ;", "try    {", "if    ( bd . getPropertyValues (  )  . contains ( propertyName )  )     {", "error (  (  (  \" Multiple    ' property '    definitions   for   property    '  \"     +    propertyName )     +     \"  '  \"  )  ,    ele )  ;", "return ;", "}", "Object   val    =    parsePropertyValue ( ele ,    bd ,    propertyName )  ;", "PropertyValue   pv    =    new   PropertyValue ( propertyName ,    val )  ;", "parseMetaElements ( ele ,    pv )  ;", "pv . setSource ( extractSource ( ele )  )  ;", "bd . getPropertyValues (  )  . addPropertyValue ( pv )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parsePropertyElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    beanEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . PROPERTY _ ELEMENT )  )  )     {", "parsePropertyElement (  (  ( Element )     ( node )  )  ,    bd )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parsePropertyElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "return   parsePropertySubElement ( ele ,    bd ,    null )  ;", "}", "METHOD_END"], "methodName": ["parsePropertySubElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isDefaultNamespace ( ele )  )  )     {", "return   parseNestedCustomElement ( ele ,    bd )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . BEAN _ ELEMENT )  )     {", "config . BeanDefinitionHolder   nestedBd    =    parseBeanDefinitionElement ( ele ,    bd )  ;", "if    ( nestedBd    !  =    null )     {", "nestedBd    =    decorateBeanDefinitionIfRequired ( ele ,    nestedBd ,    bd )  ;", "}", "return   nestedBd ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . REF _ ELEMENT )  )     {", "String   refName    =    ele . getAttribute ( BeanDefinitionParserDelegate . BEAN _ REF _ ATTRIBUTE )  ;", "boolean   toParent    =    false ;", "if    (  !  ( hasLength ( refName )  )  )     {", "refName    =    ele . getAttribute ( BeanDefinitionParserDelegate . PARENT _ REF _ ATTRIBUTE )  ;", "toParent    =    true ;", "if    (  !  ( hasLength ( refName )  )  )     {", "error (  \"  ' bean '    or    ' parent '    is   required   for    < ref >    element \"  ,    ele )  ;", "return   null ;", "}", "}", "if    (  !  ( hasText ( refName )  )  )     {", "error (  \"  < ref >    element   contains   empty   target   attribute \"  ,    ele )  ;", "return   null ;", "}", "config . RuntimeBeanReference   ref    =    new   config . RuntimeBeanReference ( refName ,    toParent )  ;", "ref . setSource ( extractSource ( ele )  )  ;", "return   ref ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . IDREF _ ELEMENT )  )     {", "return   parseIdRefElement ( ele )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . VALUE _ ELEMENT )  )     {", "return   parseValueElement ( ele ,    defaultValueType )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . NULL _ ELEMENT )  )     {", "config . TypedStringValue   nullHolder    =    new   config . TypedStringValue ( null )  ;", "nullHolder . setSource ( extractSource ( ele )  )  ;", "return   nullHolder ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . ARRAY _ ELEMENT )  )     {", "return   parseArrayElement ( ele ,    bd )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . LIST _ ELEMENT )  )     {", "return   parseListElement ( ele ,    bd )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . SET _ ELEMENT )  )     {", "return   parseSetElement ( ele ,    bd )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . MAP _ ELEMENT )  )     {", "return   parseMapElement ( ele ,    bd )  ;", "} else", "if    ( nodeNameEquals ( ele ,    BeanDefinitionParserDelegate . PROPS _ ELEMENT )  )     {", "return   parsePropsElement ( ele )  ;", "} else    {", "error (  (  (  \" Unknown   property   sub - element :     [  \"     +     ( ele . getNodeName (  )  )  )     +     \"  ]  \"  )  ,    ele )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parsePropertySubElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   elementName    =     ( propertyName    !  =    null )     ?     (  \"  < property >    element   for   property    '  \"     +    propertyName )     +     \"  '  \"     :     \"  < constructor - arg >    element \"  ;", "NodeList   nl    =    ele . getChildNodes (  )  ;", "Element   subElement    =    null ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  (  ( node   instanceof   Element )     &  &     (  !  ( nodeNameEquals ( node ,    BeanDefinitionParserDelegate . DESCRIPTION _ ELEMENT )  )  )  )     &  &     (  !  ( nodeNameEquals ( node ,    BeanDefinitionParserDelegate . META _ ELEMENT )  )  )  )     {", "if    ( subElement    !  =    null )     {", "error (  ( elementName    +     \"    must   not   contain   more   than   one   sub - element \"  )  ,    ele )  ;", "} else    {", "subElement    =     (  ( Element )     ( node )  )  ;", "}", "}", "}", "boolean   hasRefAttribute    =    ele . hasAttribute ( BeanDefinitionParserDelegate . REF _ ATTRIBUTE )  ;", "boolean   hasValueAttribute    =    ele . hasAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  ;", "if    (  ( hasRefAttribute    &  &    hasValueAttribute )     |  |     (  ( hasRefAttribute    |  |    hasValueAttribute )     &  &     ( subElement    !  =    null )  )  )     {", "error (  ( elementName    +     \"    is   only   allowed   to   contain   either    ' ref '    attribute   OR    ' value '    attribute   OR   sub - element \"  )  ,    ele )  ;", "}", "if    ( hasRefAttribute )     {", "String   refName    =    ele . getAttribute ( BeanDefinitionParserDelegate . REF _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( refName )  )  )     {", "error (  ( elementName    +     \"    contains   empty    ' ref '    attribute \"  )  ,    ele )  ;", "}", "RuntimeBeanReference   ref    =    new   RuntimeBeanReference ( refName )  ;", "ref . setSource ( extractSource ( ele )  )  ;", "return   ref ;", "} else", "if    ( hasValueAttribute )     {", "config . TypedStringValue   valueHolder    =    new   config . TypedStringValue ( ele . getAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  )  ;", "valueHolder . setSource ( extractSource ( ele )  )  ;", "return   valueHolder ;", "} else", "if    ( subElement    !  =    null )     {", "return   parsePropertySubElement ( subElement ,    bd )  ;", "} else    {", "error (  ( elementName    +     \"    must   specify   a   ref   or   value \"  )  ,    ele )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parsePropertyValue"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "ManagedProperties   props    =    new   ManagedProperties (  )  ;", "props . setSource ( extractSource ( propsEle )  )  ;", "props . setMergeEnabled ( parseMergeAttribute ( propsEle )  )  ;", "List < Element >    propEles    =    DomUtils . getChildElementsByTagName ( propsEle ,     . PROP _ ELEMENT )  ;", "for    ( Element   propEle    :    propEles )     {", "String   key    =    propEle . getAttribute (  . KEY _ ATTRIBUTE )  ;", "String   value    =    DomUtils . getTextValue ( propEle )  . trim (  )  ;", "TypedStringValue   keyHolder    =    new   TypedStringValue ( key )  ;", "keyHolder . setSource ( extractSource ( propEle )  )  ;", "TypedStringValue   valueHolder    =    new   TypedStringValue ( value )  ;", "valueHolder . setSource ( extractSource ( propEle )  )  ;", "props . put ( keyHolder ,    valueHolder )  ;", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["parsePropsElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   typeName    =    ele . getAttribute ( BeanDefinitionParserDelegate . TYPE _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasLength ( typeName )  )  )     {", "error (  \" Tag    ' qualifier '    must   have   a    ' type '    attribute \"  ,    ele )  ;", "return ;", "}", "this . parseState . push ( new   QualifierEntry ( typeName )  )  ;", "try    {", "AutowireCandidateQualifier   qualifier    =    new   AutowireCandidateQualifier ( typeName )  ;", "qualifier . setSource ( extractSource ( ele )  )  ;", "String   value    =    ele . getAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  ;", "if    ( StringUtils . hasLength ( value )  )     {", "qualifier . setAttribute ( AutowireCandidateQualifier . VALUE _ KEY ,    value )  ;", "}", "NodeList   nl    =    ele . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,    BeanDefinitionParserDelegate . QUALIFIER _ ATTRIBUTE _ ELEMENT )  )  )     {", "Element   attributeEle    =     (  ( Element )     ( node )  )  ;", "String   attributeName    =    attributeEle . getAttribute ( BeanDefinitionParserDelegate . KEY _ ATTRIBUTE )  ;", "String   attributeValue    =    attributeEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ ATTRIBUTE )  ;", "if    (  ( StringUtils . hasLength ( attributeName )  )     &  &     ( StringUtils . hasLength ( attributeValue )  )  )     {", "BeanMetadataAttribute   attribute    =    new   BeanMetadataAttribute ( attributeName ,    attributeValue )  ;", "attribute . setSource ( extractSource ( attributeEle )  )  ;", "qualifier . addMetadataAttribute ( attribute )  ;", "} else    {", "error (  \" Qualifier    ' attribute '    tag   must   have   a    ' name '    and    ' value '  \"  ,    attributeEle )  ;", "return ;", "}", "}", "}", "bd . addQualifier ( qualifier )  ;", "}    finally    {", "this . parseState . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseQualifierElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    beanEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . QUALIFIER _ ELEMENT )  )  )     {", "parseQualifierElement (  (  ( Element )     ( node )  )  ,    bd )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseQualifierElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "NodeList   nl    =    beanEle . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    (  ( isCandidateElement ( node )  )     &  &     ( nodeNameEquals ( node ,     . REPLACED _ METHOD _ ELEMENT )  )  )     {", "Element   replacedMethodEle    =     (  ( Element )     ( node )  )  ;", "String   name    =    replacedMethodEle . getAttribute (  . NAME _ ATTRIBUTE )  ;", "String   callback    =    replacedMethodEle . getAttribute (  . REPLACER _ ATTRIBUTE )  ;", "ReplaceOverride   replaceOverride    =    new   ReplaceOverride ( name ,    callback )  ;", "List < Element >    argTypeEles    =    DomUtils . getChildElementsByTagName ( replacedMethodEle ,     . ARG _ TYPE _ ELEMENT )  ;", "for    ( Element   argTypeEle    :    argTypeEles )     {", "String   match    =    argTypeEle . getAttribute (  . ARG _ TYPE _ MATCH _ ATTRIBUTE )  ;", "match    =     ( StringUtils . hasText ( match )  )     ?    match    :    DomUtils . getTextValue ( argTypeEle )  ;", "if    ( StringUtils . hasText ( match )  )     {", "replaceOverride . addTypeIdentifier ( match )  ;", "}", "}", "replaceOverride . setSource ( extractSource ( replacedMethodEle )  )  ;", "overrides . addOverride ( replaceOverride )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseReplacedMethodSubElements"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   defaultElementType    =    collectionEle . getAttribute ( BeanDefinitionParserDelegate . VALUE _ TYPE _ ATTRIBUTE )  ;", "NodeList   nl    =    collectionEle . getChildNodes (  )  ;", "ManagedSet < Object >    target    =    new   ManagedSet <  >  ( nl . getLength (  )  )  ;", "target . setSource ( extractSource ( collectionEle )  )  ;", "target . setElementTypeName ( defaultElementType )  ;", "target . setMergeEnabled ( parseMergeAttribute ( collectionEle )  )  ;", "parseCollectionElements ( nl ,    target ,    bd ,    defaultElementType )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["parseSetElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   value    =    DomUtils . getTextValue ( ele )  ;", "String   specifiedTypeName    =    ele . getAttribute (  . TYPE _ ATTRIBUTE )  ;", "String   typeName    =    specifiedTypeName ;", "if    (  !  ( StringUtils . hasText ( typeName )  )  )     {", "typeName    =    defaultTypeName ;", "}", "try    {", "TypedStringValue   typedValue    =    buildTypedStringValue ( value ,    typeName )  ;", "typedValue . setSource ( extractSource ( ele )  )  ;", "typedValue . setSpecifiedTypeName ( specifiedTypeName )  ;", "return   typedValue ;", "}    catch    ( ClassNotFoundException   ex )     {", "error (  (  (  \" Type   class    [  \"     +    typeName )     +     \"  ]    not   found   for    < value >    element \"  )  ,    ele ,    ex )  ;", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["parseValueElement"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   lazyInit    =    root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ LAZY _ INIT _ ATTRIBUTE )  ;", "if    ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( lazyInit )  )     {", "lazyInit    =     ( parentDefaults    !  =    null )     ?    parentDefaults . getLazyInit (  )     :    BeanDefinitionParserDelegate . FALSE _ VALUE ;", "}", "defaults . setLazyInit ( lazyInit )  ;", "String   merge    =    root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ MERGE _ ATTRIBUTE )  ;", "if    ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( merge )  )     {", "merge    =     ( parentDefaults    !  =    null )     ?    parentDefaults . getMerge (  )     :    BeanDefinitionParserDelegate . FALSE _ VALUE ;", "}", "defaults . setMerge ( merge )  ;", "String   autowire    =    root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ AUTOWIRE _ ATTRIBUTE )  ;", "if    ( BeanDefinitionParserDelegate . DEFAULT _ VALUE . equals ( autowire )  )     {", "autowire    =     ( parentDefaults    !  =    null )     ?    parentDefaults . getAutowire (  )     :    BeanDefinitionParserDelegate . AUTOWIRE _ NO _ VALUE ;", "}", "defaults . setAutowire ( autowire )  ;", "if    ( root . hasAttribute ( BeanDefinitionParserDelegate . DEFAULT _ AUTOWIRE _ CANDIDATES _ ATTRIBUTE )  )     {", "defaults . setAutowireCandidates ( root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ AUTOWIRE _ CANDIDATES _ ATTRIBUTE )  )  ;", "} else", "if    ( parentDefaults    !  =    null )     {", "defaults . setAutowireCandidates ( parentDefaults . getAutowireCandidates (  )  )  ;", "}", "if    ( root . hasAttribute ( BeanDefinitionParserDelegate . DEFAULT _ INIT _ METHOD _ ATTRIBUTE )  )     {", "defaults . setInitMethod ( root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ INIT _ METHOD _ ATTRIBUTE )  )  ;", "} else", "if    ( parentDefaults    !  =    null )     {", "defaults . setInitMethod ( parentDefaults . getInitMethod (  )  )  ;", "}", "if    ( root . hasAttribute ( BeanDefinitionParserDelegate . DEFAULT _ DESTROY _ METHOD _ ATTRIBUTE )  )     {", "defaults . setDestroyMethod ( root . getAttribute ( BeanDefinitionParserDelegate . DEFAULT _ DESTROY _ METHOD _ ATTRIBUTE )  )  ;", "} else", "if    ( parentDefaults    !  =    null )     {", "defaults . setDestroyMethod ( parentDefaults . getDestroyMethod (  )  )  ;", "}", "defaults . setSource ( this . readerContext . extractSource ( root )  )  ;", "}", "METHOD_END"], "methodName": ["populateDefaults"], "fileName": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate"}, {"methodBody": ["METHOD_START", "{", "String   className    =    GeneratedNameBean . class . getName (  )  ;", "String   targetName    =     ( className    +     ( BeanDefinitionReaderUtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +     \"  0  \"  ;", "GeneratedNameBean   topLevel 1     =     (  ( GeneratedNameBean )     ( beanFactory . getBean ( targetName )  )  )  ;", "assertNotNull ( topLevel 1  )  ;", "targetName    =     ( className    +     ( BeanDefinitionReaderUtils . GENERATED _ BEAN _ NAME _ SEPARATOR )  )     +     \"  1  \"  ;", "GeneratedNameBean   topLevel 2     =     (  ( GeneratedNameBean )     ( beanFactory . getBean ( targetName )  )  )  ;", "assertNotNull ( topLevel 2  )  ;", "GeneratedNameBean   child 1     =    topLevel 1  . getChild (  )  ;", "assertNotNull ( child 1  . get (  )  )  ;", "assertTrue ( child 1  . get (  )  . startsWith ( className )  )  ;", "GeneratedNameBean   child 2     =    topLevel 2  . getChild (  )  ;", "assertNotNull ( child 2  . get (  )  )  ;", "assertTrue ( child 2  . get (  )  . startsWith ( className )  )  ;", "assertFalse ( child 1  . get (  )  . equals ( child 2  . get (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["naming"], "fileName": "org.springframework.beans.factory.xml.BeanNameGenerationTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . setValidationMode ( XmlBeanDefinitionReader . VALIDATION _ NONE )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" b . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.BeanNameGenerationTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithList \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    list . size (  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" Rod   Johnson \"  ,    list . get (  1  )  )  ;", "assertEquals (  \" Juergen   Hoeller \"  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeList"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithListInConstructor \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    list . size (  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" Rod   Johnson \"  ,    list . get (  1  )  )  ;", "assertEquals (  \" Juergen   Hoeller \"  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeListInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithListOfRefs \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertNotNull ( list )  ;", "assertEquals (  3  ,    list . size (  )  )  ;", "assertNotNull ( list . get (  2  )  )  ;", "assertTrue (  (  ( list . get (  2  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["mergeListWithInnerBeanAsListElement"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithListOfRefsInConstructor \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertNotNull ( list )  ;", "assertEquals (  3  ,    list . size (  )  )  ;", "assertNotNull ( list . get (  2  )  )  ;", "assertTrue (  (  ( list . get (  2  )  )    instanceof   TestBean )  )  ;", "}", "METHOD_END"], "methodName": ["mergeListWithInnerBeanAsListElementInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithMap \"  )  )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    map . size (  )  )  ;", "assertEquals (  \" Sally \"  ,    map . get (  \" Rob \"  )  )  ;", "assertEquals (  \" Kerry \"  ,    map . get (  \" Rod \"  )  )  ;", "assertEquals (  \" Eva \"  ,    map . get (  \" Juergen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeMap"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithMapInConstructor \"  )  )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    map . size (  )  )  ;", "assertEquals (  \" Sally \"  ,    map . get (  \" Rob \"  )  )  ;", "assertEquals (  \" Kerry \"  ,    map . get (  \" Rod \"  )  )  ;", "assertEquals (  \" Eva \"  ,    map . get (  \" Juergen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeMapInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithMapOfRefs \"  )  )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertNotNull ( map )  ;", "assertEquals (  2  ,    map . size (  )  )  ;", "assertNotNull ( map . get (  \" Rob \"  )  )  ;", "assertTrue (  (  ( map . get (  \" Rob \"  )  )    instanceof   TestBean )  )  ;", "assertEquals (  \" Sally \"  ,     (  ( TestBean )     ( map . get (  \" Rob \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeMapWithInnerBeanAsMapEntryValue"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithMapOfRefsInConstructor \"  )  )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertNotNull ( map )  ;", "assertEquals (  2  ,    map . size (  )  )  ;", "assertNotNull ( map . get (  \" Rob \"  )  )  ;", "assertTrue (  (  ( map . get (  \" Rob \"  )  )    instanceof   TestBean )  )  ;", "assertEquals (  \" Sally \"  ,     (  ( TestBean )     ( map . get (  \" Rob \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeMapWithInnerBeanAsMapEntryValueInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithProps \"  )  )  )  ;", "Properties   props    =    bean . getSomeProperties (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    props . size (  )  )  ;", "assertEquals (  \" Sally \"  ,    props . getProperty (  \" Rob \"  )  )  ;", "assertEquals (  \" Kerry \"  ,    props . getProperty (  \" Rod \"  )  )  ;", "assertEquals (  \" Eva \"  ,    props . getProperty (  \" Juergen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeProperties"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithPropsInConstructor \"  )  )  )  ;", "Properties   props    =    bean . getSomeProperties (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     3  ,    props . size (  )  )  ;", "assertEquals (  \" Sally \"  ,    props . getProperty (  \" Rob \"  )  )  ;", "assertEquals (  \" Kerry \"  ,    props . getProperty (  \" Rod \"  )  )  ;", "assertEquals (  \" Eva \"  ,    props . getProperty (  \" Juergen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergePropertiesInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithSet \"  )  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     2  ,    set . size (  )  )  ;", "assertTrue ( set . contains (  \" Rob   Harrop \"  )  )  ;", "assertTrue ( set . contains (  \" Sally   Greenwood \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSet"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithSetInConstructor \"  )  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  \" Incorrect   size \"  ,     2  ,    set . size (  )  )  ;", "assertTrue ( set . contains (  \" Rob   Harrop \"  )  )  ;", "assertTrue ( set . contains (  \" Sally   Greenwood \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSetInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithSetOfRefs \"  )  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertNotNull ( set )  ;", "assertEquals (  2  ,    set . size (  )  )  ;", "Iterator   it    =    set . iterator (  )  ;", "it . next (  )  ;", "Object   o    =    it . next (  )  ;", "assertNotNull ( o )  ;", "assertTrue (  ( o   instanceof   TestBean )  )  ;", "assertEquals (  \" Sally \"  ,     (  ( TestBean )     ( o )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSetWithInnerBeanAsSetElement"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" childWithSetOfRefsInConstructor \"  )  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertNotNull ( set )  ;", "assertEquals (  2  ,    set . size (  )  )  ;", "Iterator   it    =    set . iterator (  )  ;", "it . next (  )  ;", "Object   o    =    it . next (  )  ;", "assertNotNull ( o )  ;", "assertTrue (  ( o   instanceof   TestBean )  )  ;", "assertEquals (  \" Sally \"  ,     (  ( TestBean )     ( o )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSetWithInnerBeanAsSetElementInConstructor"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" c . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.CollectionMergingTests"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entent :    map . entet (  )  )     {", "assertEquals (  \" Key   type   is   incorrect \"  ,    Integer . class ,    entgetKey (  )  . getClass (  )  )  ;", "assertEquals (  \" Value   type   is   incorrect \"  ,    Boolean . class ,    entgetValue (  )  . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertMap"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "MixedCollectionBean   jumble    =     (  ( MixedCollectionBean )     ( this . beanFactory . getBean (  \" jumble \"  )  )  )  ;", "assertTrue (  (  \" Expected    3    elements ,    not    \"     +     ( jumble . getJumble (  )  . size (  )  )  )  ,     (  ( jumble . getJumble (  )  . size (  )  )     =  =     3  )  )  ;", "List   l    =     (  ( List )     ( jumble . getJumble (  )  )  )  ;", "assertTrue ( l . get (  0  )  . equals (  \" literal \"  )  )  ;", "Integer [  ]    array 1     =     (  ( Integer [  ]  )     ( l . get (  1  )  )  )  ;", "assertTrue ( array 1  [  0  ]  . equals ( new   Integer (  2  )  )  )  ;", "assertTrue ( array 1  [  1  ]  . equals ( new   Integer (  4  )  )  )  ;", "int [  ]    array 2     =     (  ( int [  ]  )     ( l . get (  2  )  )  )  ;", "assertTrue (  (  ( array 2  [  0  ]  )     =  =     3  )  )  ;", "assertTrue (  (  ( array 2  [  1  ]  )     =  =     5  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildCollectionFromMixtureOfReferencesAndValues"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "for    ( Object   o    :    bean . getSomeList (  )  )     {", "assertEquals (  \" Value   type   is   incorrect \"  ,    Integer . class ,    o . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testListHasDefaultType"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertMap ( bean . getSomeMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapHasDefaultKeyAndValueType"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean 2  \"  )  )  )  ;", "assertMap ( bean . getSomeMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithNestedElementsHasDefaultKeyAndValueType"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "for    ( Object   o    :    bean . getSomeSet (  )  )     {", "assertEquals (  \" Value   type   is   incorrect \"  ,    Integer . class ,    o . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSetHasDefaultType"], "fileName": "org.springframework.beans.factory.xml.CollectionsWithDefaultTypesTests"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   other ;", "}", "METHOD_END"], "methodName": ["getOther"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse 1  ;", "}", "METHOD_END"], "methodName": ["getSpouse1"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse 2  ;", "}", "METHOD_END"], "methodName": ["getSpouse2"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.beans.factory.xml.ConstructorDependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   CountingFactory . factoryBeanInstanceCount ;", "}", "METHOD_END"], "methodName": ["getFactoryBeanInstanceCount"], "fileName": "org.springframework.beans.factory.xml.CountingFactory"}, {"methodBody": ["METHOD_START", "{", "CountingFactory . factoryBeanInstanceCount    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.beans.factory.xml.CountingFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tb . getSpouse (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \" TestB   needs   to   have   spouse \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setTestBean"], "fileName": "org.springframework.beans.factory.xml.CountingFactory"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionParserDelegate   delegate    =    new   BeanDefinitionParserDelegate ( readerContext )  ;", "delegate . initDefaults ( root ,    parentDelegate )  ;", "return   delegate ;", "}", "METHOD_END"], "methodName": ["createDelegate"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionParserDelegate   parent    =    this . delegate ;", "this . delegate    =    createDelegate ( getReaderContext (  )  ,    root ,    parent )  ;", "if    ( this . delegate . isDefaultNamespace ( root )  )     {", "String   profileSpec    =    root . getAttribute (  . PROFILE _ ATTRIBUTE )  ;", "if    ( StringUtils . hasText ( profileSpec )  )     {", "String [  ]    specifiedProfiles    =    StringUtils . tokenizeToStringArray ( profileSpec ,    BeanDefinitionParserDelegate . MULTI _ VALUE _ ATTRIBUTE _ DELIMITERS )  ;", "if    (  !  ( getReaderContext (  )  . getEnvironment (  )  . acceptsProfiles ( specifiedProfiles )  )  )     {", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  (  (  \" Skipped   XML   bean   definition   file   due   to   specified   profiles    [  \"     +    profileSpec )     +     \"  ]    not   matching :     \"  )     +     ( getReaderContext (  )  . getResource (  )  )  )  )  ;", "}", "return ;", "}", "}", "}", "preProcessXml ( root )  ;", "parseBeanDefinitions ( root ,    this . delegate )  ;", "postProcessXml ( root )  ;", "this . delegate    =    parent ;", "}", "METHOD_END"], "methodName": ["doRegisterBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "return   getReaderContext (  )  . extractSource ( ele )  ;", "}", "METHOD_END"], "methodName": ["extractSource"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "Assert . state (  (  ( this . readerContext )     !  =    null )  ,     \" No   XmlReaderContext   available \"  )  ;", "return   this . readerContext ;", "}", "METHOD_END"], "methodName": ["getReaderContext"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "String   location    =    ele . getAttribute ( DefaultBeanDefinitionDocumentReader . RESOURCE _ ATTRIBUTE )  ;", "if    (  !  ( StringUtils . hasText ( location )  )  )     {", "getReaderContext (  )  . error (  \" Resource   location   must   not   be   empty \"  ,    ele )  ;", "return ;", "}", "location    =    getReaderContext (  )  . getEnvironment (  )  . resolveRequiredPlaceholders ( location )  ;", "Set < Resource >    actualResources    =    new   LinkedHashSet <  >  (  4  )  ;", "boolean   absoluteLocation    =    false ;", "try    {", "absoluteLocation    =     ( ResourcePatternUtils . isUrl ( location )  )     |  |     ( ResourceUtils . toURI ( location )  . isAbsolute (  )  )  ;", "}    catch    ( URISyntaxException   ex )     {", "}", "if    ( absoluteLocation )     {", "try    {", "int   importCount    =    getReaderContext (  )  . getReader (  )  . loadBeanDefinitions ( location ,    actualResources )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Imported    \"     +    importCount )     +     \"    bean   definitions   from   URL   location    [  \"  )     +    location )     +     \"  ]  \"  )  )  ;", "}", "}    catch    ( BeanDefinitionStoreException   ex )     {", "getReaderContext (  )  . error (  (  (  \" Failed   to   import   bean   definitions   from   URL   location    [  \"     +    location )     +     \"  ]  \"  )  ,    ele ,    ex )  ;", "}", "} else    {", "try    {", "int   importCount ;", "Resource   relativeResource    =    getReaderContext (  )  . getResource (  )  . createRelative ( location )  ;", "if    ( relativeResource . exists (  )  )     {", "importCount    =    getReaderContext (  )  . getReader (  )  . loadBeanDefinitions ( relativeResource )  ;", "actualResources . add ( relativeResource )  ;", "} else    {", "String   baseLocation    =    getReaderContext (  )  . getResource (  )  . getURL (  )  . toString (  )  ;", "importCount    =    getReaderContext (  )  . getReader (  )  . loadBeanDefinitions ( StringUtils . applyRelativePath ( baseLocation ,    location )  ,    actualResources )  ;", "}", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  \" Imported    \"     +    importCount )     +     \"    bean   definitions   from   relative   location    [  \"  )     +    location )     +     \"  ]  \"  )  )  ;", "}", "}    catch    ( IOException   ex )     {", "getReaderContext (  )  . error (  \" Failed   to   resolve   current   resource   location \"  ,    ele ,    ex )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "getReaderContext (  )  . error (  (  (  \" Failed   to   import   bean   definitions   from   relative   location    [  \"     +    location )     +     \"  ]  \"  )  ,    ele ,    ex )  ;", "}", "}", "Resource [  ]    actResArray    =    actualResources . toArray ( new   Resource [  0  ]  )  ;", "getReaderContext (  )  . fireImportProcessed ( location ,    actResArray ,    extractSource ( ele )  )  ;", "}", "METHOD_END"], "methodName": ["importBeanDefinitionResource"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "if    ( delegate . isDefaultNamespace ( root )  )     {", "NodeList   nl    =    root . getChildNodes (  )  ;", "for    ( int   i    =     0  ;    i    <     ( nl . getLength (  )  )  ;    i +  +  )     {", "Node   node    =    nl . item ( i )  ;", "if    ( node   instanceof   Element )     {", "Element   ele    =     (  ( Element )     ( node )  )  ;", "if    ( delegate . isDefaultNamespace ( ele )  )     {", "parseDefaultElement ( ele ,    delegate )  ;", "} else    {", "delegate . parseCustomElement ( ele )  ;", "}", "}", "}", "} else    {", "delegate . parseCustomElement ( root )  ;", "}", "}", "METHOD_END"], "methodName": ["parseBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "if    ( delegate . nodeNameEquals ( ele ,    DefaultBeanDefinitionDocumentReader . IMPORT _ ELEMENT )  )     {", "importBeanDefinitionResource ( ele )  ;", "} else", "if    ( delegate . nodeNameEquals ( ele ,    DefaultBeanDefinitionDocumentReader . ALIAS _ ELEMENT )  )     {", "processAliasRegistration ( ele )  ;", "} else", "if    ( delegate . nodeNameEquals ( ele ,    DefaultBeanDefinitionDocumentReader . BEAN _ ELEMENT )  )     {", "processBeanDefinition ( ele ,    delegate )  ;", "} else", "if    ( delegate . nodeNameEquals ( ele ,    DefaultBeanDefinitionDocumentReader . NESTED _ BEANS _ ELEMENT )  )     {", "doRegisterBeanDefinitions ( ele )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDefaultElement"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "String   name    =    ele . getAttribute ( DefaultBeanDefinitionDocumentReader . NAME _ ATTRIBUTE )  ;", "String   alias    =    ele . getAttribute ( DefaultBeanDefinitionDocumentReader . ALIAS _ ATTRIBUTE )  ;", "boolean   valid    =    true ;", "if    (  !  ( StringUtils . hasText ( name )  )  )     {", "getReaderContext (  )  . error (  \" Name   must   not   be   empty \"  ,    ele )  ;", "valid    =    false ;", "}", "if    (  !  ( StringUtils . hasText ( alias )  )  )     {", "getReaderContext (  )  . error (  \" Alias   must   not   be   empty \"  ,    ele )  ;", "valid    =    false ;", "}", "if    ( valid )     {", "try    {", "getReaderContext (  )  . getRegistry (  )  . registerAlias ( name ,    alias )  ;", "}    catch    ( Exception   ex )     {", "getReaderContext (  )  . error (  (  (  (  (  \" Failed   to   register   alias    '  \"     +    alias )     +     \"  '    for   bean   with   name    '  \"  )     +    name )     +     \"  '  \"  )  ,    ele ,    ex )  ;", "}", "getReaderContext (  )  . fireAliasRegistered ( name ,    alias ,    extractSource ( ele )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processAliasRegistration"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionHolder   bdHolder    =    delegate . parseBeanDefinitionElement ( ele )  ;", "if    ( bdHolder    !  =    null )     {", "bdHolder    =    delegate . decorateBeanDefinitionIfRequired ( ele ,    bdHolder )  ;", "try    {", "BeanDefinitionReaderUtils . registerBeanDefinition ( bdHolder ,    getReaderContext (  )  . getRegistry (  )  )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "getReaderContext (  )  . error (  (  (  \" Failed   to   register   bean   definition   with   name    '  \"     +     ( bdHolder . getBeanName (  )  )  )     +     \"  '  \"  )  ,    ele ,    ex )  ;", "}", "getReaderContext (  )  . fireComponentRegistered ( new   BeanComponentDefinition ( bdHolder )  )  ;", "}", "}", "METHOD_END"], "methodName": ["processBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilder   docBuilder    =    factory . newDocumentBuilder (  )  ;", "if    ( entityResolver    !  =    null )     {", "docBuilder . setEntityResolver ( entityResolver )  ;", "}", "if    ( errorHandler    !  =    null )     {", "docBuilder . setErrorHandler ( errorHandler )  ;", "}", "return   docBuilder ;", "}", "METHOD_END"], "methodName": ["createDocumentBuilder"], "fileName": "org.springframework.beans.factory.xml.DefaultDocumentLoader"}, {"methodBody": ["METHOD_START", "{", "DocumentBuilderFactory   factory    =    DocumentBuilderFactory . newInstance (  )  ;", "factory . setNamespaceAware ( namespaceAware )  ;", "if    ( validationMode    !  =     ( XmlValidationModeDetector . VALIDATION _ NONE )  )     {", "factory . setValidating ( true )  ;", "if    ( validationMode    =  =     ( XmlValidationModeDetector . VALIDATION _ XSD )  )     {", "factory . setNamespaceAware ( true )  ;", "try    {", "factory . setAttribute (  . SCHEMA _ LANGUAGE _ ATTRIBUTE ,     . XSD _ SCHEMA _ LANGUAGE )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "ParserConfigurationException   pcex    =    new   ParserConfigurationException (  (  (  (  \" Unable   to   validate   using   XSD :    Your   JAXP   provider    [  \"     +    factory )     +     \"  ]    does   not   support   XML   Schema .    Are   you   running   on   Java    1  .  4    with   Apache   Crimson ?     \"  )     +     \" Upgrade   to   Apache   Xerces    ( or   Java    1  .  5  )    for   full   XSD   support .  \"  )  )  ;", "pcex . initCause ( ex )  ;", "throw   pcex ;", "}", "}", "}", "return   factory ;", "}", "METHOD_END"], "methodName": ["createDocumentBuilderFactory"], "fileName": "org.springframework.beans.factory.xml.DefaultDocumentLoader"}, {"methodBody": ["METHOD_START", "{", "DefaultLifecycleMethodsTests . LifecycleAwareBean   bean    =     (  ( DefaultLifecycleMethodsTests . LifecycleAwareBean )     ( this . beanFactory . getBean (  \" childWithDefaultLifecycleMethods \"  )  )  )  ;", "assertTrue (  \" Bean   not   initialized \"  ,    bean . isInitCalled (  )  )  ;", "assertFalse (  \" Custom   init   method   called   incorrectly \"  ,    bean . isCustomInitCalled (  )  )  ;", "assertFalse (  \" Bean   destroyed   too   early \"  ,    bean . isDestroyCalled (  )  )  ;", "this . beanFactory . destroySingletons (  )  ;", "assertTrue (  \" Bean   not   destroyed \"  ,    bean . isDestroyCalled (  )  )  ;", "assertFalse (  \" Custom   destroy   method   called   incorrectly \"  ,    bean . isCustomDestroyCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["childWithDefaultLifecycleMethods"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultLifecycleMethodsTests . LifecycleAwareBean   bean    =     (  ( DefaultLifecycleMethodsTests . LifecycleAwareBean )     ( this . beanFactory . getBean (  \" childWithLifecycleMethodsDisabled \"  )  )  )  ;", "assertFalse (  \" Bean   init   method   called   incorrectly \"  ,    bean . isInitCalled (  )  )  ;", "assertFalse (  \" Custom   init   method   called   incorrectly \"  ,    bean . isCustomInitCalled (  )  )  ;", "this . beanFactory . destroySingletons (  )  ;", "assertFalse (  \" Bean   destroy   method   called   incorrectly \"  ,    bean . isDestroyCalled (  )  )  ;", "assertFalse (  \" Custom   destroy   method   called   incorrectly \"  ,    bean . isCustomDestroyCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["childWithLifecycleMethodsDisabled"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" ignore . xml \"  ,    getClass (  )  )  )  ;", "bf . preInstantiateSingletons (  )  ;", "bf . destroySingletons (  )  ;", "}", "METHOD_END"], "methodName": ["ignoreDefaultLifecycleMethods"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultLifecycleMethodsTests . LifecycleAwareBean   bean    =     (  ( DefaultLifecycleMethodsTests . LifecycleAwareBean )     ( this . beanFactory . getBean (  \" lifecycleMethodsDisabled \"  )  )  )  ;", "assertFalse (  \" Bean   init   method   called   incorrectly \"  ,    bean . isInitCalled (  )  )  ;", "assertFalse (  \" Custom   init   method   called   incorrectly \"  ,    bean . isCustomInitCalled (  )  )  ;", "this . beanFactory . destroySingletons (  )  ;", "assertFalse (  \" Bean   destroy   method   called   incorrectly \"  ,    bean . isDestroyCalled (  )  )  ;", "assertFalse (  \" Custom   destroy   method   called   incorrectly \"  ,    bean . isCustomDestroyCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["lifecycleMethodsDisabled"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultLifecycleMethodsTests . LifecycleAwareBean   bean    =     (  ( DefaultLifecycleMethodsTests . LifecycleAwareBean )     ( this . beanFactory . getBean (  \" lifecycleAware \"  )  )  )  ;", "assertTrue (  \" Bean   not   initialized \"  ,    bean . isInitCalled (  )  )  ;", "assertFalse (  \" Custom   init   method   called   incorrectly \"  ,    bean . isCustomInitCalled (  )  )  ;", "assertFalse (  \" Bean   destroyed   too   early \"  ,    bean . isDestroyCalled (  )  )  ;", "this . beanFactory . destroySingletons (  )  ;", "assertTrue (  \" Bean   not   destroyed \"  ,    bean . isDestroyCalled (  )  )  ;", "assertFalse (  \" Custom   destroy   method   called   incorrectly \"  ,    bean . isCustomDestroyCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["lifecycleMethodsInvoked"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "DefaultLifecycleMethodsTests . LifecycleAwareBean   bean    =     (  ( DefaultLifecycleMethodsTests . LifecycleAwareBean )     ( this . beanFactory . getBean (  \" overrideLifecycleMethods \"  )  )  )  ;", "assertFalse (  \" Default   init   method   called   incorrectly \"  ,    bean . isInitCalled (  )  )  ;", "assertTrue (  \" Custom   init   method   not   called \"  ,    bean . isCustomInitCalled (  )  )  ;", "this . beanFactory . destroySingletons (  )  ;", "assertFalse (  \" Default   destroy   method   called   incorrectly \"  ,    bean . isDestroyCalled (  )  )  ;", "assertTrue (  \" Custom   destroy   method   not   called \"  ,    bean . isCustomDestroyCalled (  )  )  ;", "}", "METHOD_END"], "methodName": ["overrideDefaultLifecycleMethods"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" defaultLifecycleMethods . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    handlerMappings    =    this . handlerMappings ;", "if    ( handlerMappings    =  =    null )     {", "synchronized ( this )     {", "handlerMappings    =    this . handlerMappings ;", "if    ( handlerMappings    =  =    null )     {", "try    {", "Properties   mappings    =    PropertiesLoaderUtils . loadAllProperties ( this . handlerMappingsLocation ,    this . classLoader )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  \" Loaded      mappings :     \"     +    mappings )  )  ;", "}", "Map < String ,    Object >    mappingsToUse    =    new   ConcurrentHashMap <  >  ( mappings . size (  )  )  ;", "CollectionUtils . mergePropertiesIntoMap ( mappings ,    mappingsToUse )  ;", "handlerMappings    =    mappingsToUse ;", "this . handlerMappings    =    handlerMappings ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Unable   to   load      mappings   from   location    [  \"     +     ( this . handlerMappingsLocation )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "}", "return   handlerMappings ;", "}", "METHOD_END"], "methodName": ["getHandlerMappings"], "fileName": "org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver"}, {"methodBody": ["METHOD_START", "{", "new   DelegatingEntityResolver ( null ,    new   DelegatingEntityResolverTests . NoOpEntityResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWhereDtdEntityResolverIsNull"], "fileName": "org.springframework.beans.factory.xml.DelegatingEntityResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   DelegatingEntityResolver ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWhereEntityResolversAreBothNull"], "fileName": "org.springframework.beans.factory.xml.DelegatingEntityResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   DelegatingEntityResolver ( new   DelegatingEntityResolverTests . NoOpEntityResolver (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWhereSchemaEntityResolverIsNull"], "fileName": "org.springframework.beans.factory.xml.DelegatingEntityResolverTests"}, {"methodBody": ["METHOD_START", "{", "return   this . autowire ;", "}", "METHOD_END"], "methodName": ["getAutowire"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . autowireCandidates ;", "}", "METHOD_END"], "methodName": ["getAutowireCandidates"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . destroyMethod ;", "}", "METHOD_END"], "methodName": ["getDestroyMethod"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . initMethod ;", "}", "METHOD_END"], "methodName": ["getInitMethod"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . lazyInit ;", "}", "METHOD_END"], "methodName": ["getLazyInit"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   this . merge ;", "}", "METHOD_END"], "methodName": ["getMerge"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . autowire    =    autowire ;", "}", "METHOD_END"], "methodName": ["setAutowire"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . autowireCandidates    =    autowireCandidates ;", "}", "METHOD_END"], "methodName": ["setAutowireCandidates"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethod    =    destroyMethod ;", "}", "METHOD_END"], "methodName": ["setDestroyMethod"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . initMethod    =    initMethod ;", "}", "METHOD_END"], "methodName": ["setInitMethod"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . lazyInit    =    lazyInit ;", "}", "METHOD_END"], "methodName": ["setLazyInit"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . merge    =    merge ;", "}", "METHOD_END"], "methodName": ["setMerge"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.factory.xml.DocumentDefaultsDefinition"}, {"methodBody": ["METHOD_START", "{", "return   dummyFactory ;", "}", "METHOD_END"], "methodName": ["getDummyFactory"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "return   testBean 1  ;", "}", "METHOD_END"], "methodName": ["getTestBean1"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "return   testBean 2  ;", "}", "METHOD_END"], "methodName": ["getTestBean2"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . dummyFactory    =    dummyFactory ;", "}", "METHOD_END"], "methodName": ["setDummyFactory"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . testBean 1     =    testBean 1  ;", "}", "METHOD_END"], "methodName": ["setTestBean1"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "this . testBean 2     =    testBean 2  ;", "}", "METHOD_END"], "methodName": ["setTestBean2"], "fileName": "org.springframework.beans.factory.xml.DummyReferencer"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \"  - multiLevel - context . xml \"  ,    this . getClass (  )  )  )  ;", "TestBean   testBean    =    bf . getBean ( TestBean . class )  ;", "assertThat ( testBean . getName (  )  ,    equalTo (  \" nested \"  )  )  ;", "}", "METHOD_END"], "methodName": ["duplicateBeanIdsAcrossNestingLevels"], "fileName": "org.springframework.beans.factory.xml.DuplicateBeanIdTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "try    {", "reader . loadBeanDefinitions ( new   ClassPathResource (  \"  - sameLevel - context . xml \"  ,    this . getClass (  )  )  )  ;", "fail (  \" expected   parsing   exception   due   to   duplicate   ids   in   same   nesting   level \"  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "METHOD_END"], "methodName": ["duplicateBeanIdsWithinSameNestingLevelRaisesError"], "fileName": "org.springframework.beans.factory.xml.DuplicateBeanIdTests"}, {"methodBody": ["METHOD_START", "{", "List   aliases    =    this . eventListener . getAliases (  \" testBean \"  )  ;", "assertEquals (  2  ,    aliases . size (  )  )  ;", "AliasDefinition   aliasDefinition 1     =     (  ( AliasDefinition )     ( aliases . get (  0  )  )  )  ;", "assertEquals (  \" testBeanAlias 1  \"  ,    aliasDefinition 1  . getAlias (  )  )  ;", "assertTrue (  (  ( aliasDefinition 1  . getSource (  )  )    instanceof   Element )  )  ;", "AliasDefinition   aliasDefinition 2     =     (  ( AliasDefinition )     ( aliases . get (  1  )  )  )  ;", "assertEquals (  \" testBeanAlias 2  \"  ,    aliasDefinition 2  . getAlias (  )  )  ;", "assertTrue (  (  ( aliasDefinition 2  . getSource (  )  )    instanceof   Element )  )  ;", "}", "METHOD_END"], "methodName": ["aliasEventReceived"], "fileName": "org.springframework.beans.factory.xml.EventPublicationTests"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinition   componentDefinition 1     =    this . eventListener . getComponentDefinition (  \" testBean \"  )  ;", "assertTrue (  ( componentDefinition 1    instanceof   BeanComponentDefinition )  )  ;", "assertEquals (  1  ,    componentDefinition 1  . getBeanDefinitions (  )  . length )  ;", "BeanDefinition   beanDefinition 1     =    componentDefinition 1  . getBeanDefinitions (  )  [  0  ]  ;", "assertEquals ( new   TypedStringValue (  \" Rob   Harrop \"  )  ,    beanDefinition 1  . getConstructorArgumentValues (  )  . getGenericArgumentValue ( String . class )  . getValue (  )  )  ;", "assertEquals (  1  ,    componentDefinition 1  . getBeanReferences (  )  . length )  ;", "assertEquals (  \" testBean 2  \"  ,    componentDefinition 1  . getBeanReferences (  )  [  0  ]  . getBeanName (  )  )  ;", "assertEquals (  1  ,    componentDefinition 1  . getInnerBeanDefinitions (  )  . length )  ;", "BeanDefinition   innerBd 1     =    componentDefinition 1  . getInnerBeanDefinitions (  )  [  0  ]  ;", "assertEquals ( new   TypedStringValue (  \" ACME \"  )  ,    innerBd 1  . getConstructorArgumentValues (  )  . getGenericArgumentValue ( String . class )  . getValue (  )  )  ;", "assertTrue (  (  ( componentDefinition 1  . getSource (  )  )    instanceof   Element )  )  ;", "ComponentDefinition   componentDefinition 2     =    this . eventListener . getComponentDefinition (  \" testBean 2  \"  )  ;", "assertTrue (  ( componentDefinition 2    instanceof   BeanComponentDefinition )  )  ;", "assertEquals (  1  ,    componentDefinition 1  . getBeanDefinitions (  )  . length )  ;", "BeanDefinition   beanDefinition 2     =    componentDefinition 2  . getBeanDefinitions (  )  [  0  ]  ;", "assertEquals ( new   TypedStringValue (  \" Juergen   Hoeller \"  )  ,    beanDefinition 2  . getPropertyValues (  )  . getPropertyValue (  \" name \"  )  . getValue (  )  )  ;", "assertEquals (  0  ,    componentDefinition 2  . getBeanReferences (  )  . length )  ;", "assertEquals (  1  ,    componentDefinition 2  . getInnerBeanDefinitions (  )  . length )  ;", "BeanDefinition   innerBd 2     =    componentDefinition 2  . getInnerBeanDefinitions (  )  [  0  ]  ;", "assertEquals ( new   TypedStringValue (  \" Eva   Schallmeiner \"  )  ,    innerBd 2  . getPropertyValues (  )  . getPropertyValue (  \" name \"  )  . getValue (  )  )  ;", "assertTrue (  (  ( componentDefinition 2  . getSource (  )  )    instanceof   Element )  )  ;", "}", "METHOD_END"], "methodName": ["beanEventReceived"], "fileName": "org.springframework.beans.factory.xml.EventPublicationTests"}, {"methodBody": ["METHOD_START", "{", "List   defaultsList    =    this . eventListener . getDefaults (  )  ;", "assertTrue (  (  !  ( defaultsList . isEmpty (  )  )  )  )  ;", "assertTrue (  (  ( defaultsList . get (  0  )  )    instanceof   DocumentDefaultsDefinition )  )  ;", "DocumentDefaultsDefinition   defaults    =     (  ( DocumentDefaultsDefinition )     ( defaultsList . get (  0  )  )  )  ;", "assertEquals (  \" true \"  ,    defaults . getLazyInit (  )  )  ;", "assertEquals (  \" constructor \"  ,    defaults . getAutowire (  )  )  ;", "assertEquals (  \" myInit \"  ,    defaults . getInitMethod (  )  )  ;", "assertEquals (  \" myDestroy \"  ,    defaults . getDestroyMethod (  )  )  ;", "assertEquals (  \" true \"  ,    defaults . getMerge (  )  )  ;", "assertTrue (  (  ( defaults . getSource (  )  )    instanceof   Element )  )  ;", "}", "METHOD_END"], "methodName": ["defaultsEventReceived"], "fileName": "org.springframework.beans.factory.xml.EventPublicationTests"}, {"methodBody": ["METHOD_START", "{", "List   imports    =    this . eventListener . getImports (  )  ;", "assertEquals (  1  ,    imports . size (  )  )  ;", "ImportDefinition   importDefinition    =     (  ( ImportDefinition )     ( imports . get (  0  )  )  )  ;", "assertEquals (  \" beansImported . xml \"  ,    importDefinition . getImportedResource (  )  )  ;", "assertTrue (  (  ( importDefinition . getSource (  )  )    instanceof   Element )  )  ;", "}", "METHOD_END"], "methodName": ["importEventReceived"], "fileName": "org.springframework.beans.factory.xml.EventPublicationTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . setEventListener ( this . eventListener )  ;", "reader . setSourceExtractor ( new   PassThroughSourceExtractor (  )  )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" beanEvents . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.EventPublicationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "TestBean   tbArg    =    new   TestBean (  )  ;", "tbArg . setName (  \" arg 1  \"  )  ;", "TestBean   tbArg 2     =    new   TestBean (  )  ;", "tbArg 2  . setName (  \" arg 2  \"  )  ;", "s   fm 1     =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  ,    tbArg )  )  )  ;", "assertEquals (  0  ,    fm 1  . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm 1  . getName (  )  )  ;", "assertEquals (  \" arg 1  \"  ,    fm 1  . getTestBean (  )  . getName (  )  )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  ,    tbArg 2  )  )  )  ;", "assertEquals (  \" arg 2  \"  ,    fm 2  . getTestBean (  )  . getName (  )  )  ;", "assertEquals ( fm 1  . getNum (  )  ,    fm 2  . getNum (  )  )  ;", "assertEquals ( fm 2  . getStringValue (  )  ,     \" testBeanOnlyPrototypeDISetterString \"  )  ;", "assertEquals ( fm 2  . getStringValue (  )  ,    fm 2  . getStringValue (  )  )  ;", "assertSame ( fm 2  . getTestBean (  )  ,    fm 2  . getTestBean (  )  )  ;", "assertNotSame ( fm 1  ,    fm 2  )  ;", "s   fm 3     =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  ,    tbArg 2  ,    new   Integer (  1  )  ,     \" myName \"  )  )  )  ;", "assertEquals (  1  ,    fm 3  . getNum (  )  )  ;", "assertEquals (  \" myName \"  ,    fm 3  . getName (  )  )  ;", "assertEquals (  \" arg 2  \"  ,    fm 3  . getTestBean (  )  . getName (  )  )  ;", "s   fm 4     =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  ,    tbArg )  )  )  ;", "assertEquals (  0  ,    fm 4  . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm 4  . getName (  )  )  ;", "assertEquals (  \" arg 1  \"  ,    fm 4  . getTestBean (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanSpecifyFactoryMethodArgumentsOnFactoryMethodPrototype"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "s   fm 1     =     (  ( s )     ( xbf . getBean (  \" testBeanOnly \"  ,    tb )  )  )  ;", "assertSame ( tb ,    fm 1  . getTestBean (  )  )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" testBeanOnly \"  ,    new   TestBean (  )  )  )  )  ;", "assertSame ( fm 1  ,    fm 2  )  ;", "assertSame ( tb ,    fm 2  . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanSpecifyFactoryMethodArgumentsOnSingleton"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "s   fm 1     =     (  ( s )     ( xbf . getBean (  \" testBeanOnly \"  )  )  )  ;", "TestBean   tb    =    fm 1  . getTestBean (  )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" testBeanOnly \"  ,    new   TestBean (  )  )  )  )  ;", "assertSame ( fm 1  ,    fm 2  )  ;", "assertSame ( tb ,    fm 2  . getTestBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCannotSpecifyFactoryMethodArgumentsOnSingletonAfterCreation"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "try    {", "xbf . getBean (  \" invalidPrototype \"  ,    new   TestBean (  )  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" nonExisting ( TestBean )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFactoryMethodArgumentsForNonExistingMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "MailSession   session    =     (  ( MailSession )     ( xbf . getBean (  \" javaMailSession \"  )  )  )  ;", "assertEquals (  \" someuser \"  ,    session . getProperty (  \" mail . smtp . user \"  )  )  ;", "assertEquals (  \" somepw \"  ,    session . getProperty (  \" mail . smtp . password \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodForJavaMailSession"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "try    {", "xbf . getBean (  \" noMatchPrototype \"  )  ;", "fail (  \" No   static   method   matched \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFactoryMethodNoMatchingStaticMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "assertTrue ( List . class . isAssignableFrom ( xbf . getType (  \" listInstance \"  )  )  )  ;", "String [  ]    names    =    xbf . getBeanNamesForType ( s . class )  ;", "assertTrue (  (  !  ( Arrays . asList ( names )  . contains (  \" listInstance \"  )  )  )  )  ;", "names    =    xbf . getBeanNamesForType ( List . class )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" listInstance \"  )  )  ;", "xbf . preInstantiateSingletons (  )  ;", "assertTrue ( List . class . isAssignableFrom ( xbf . getType (  \" listInstance \"  )  )  )  ;", "names    =    xbf . getBeanNamesForType ( s . class )  ;", "assertTrue (  (  !  ( Arrays . asList ( names )  . contains (  \" listInstance \"  )  )  )  )  ;", "names    =    xbf . getBeanNamesForType ( List . class )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" listInstance \"  )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( xbf . getBean (  \" listInstance \"  )  )  )  ;", "assertEquals ( Collections . EMPTY _ LIST ,    list )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodWithDifferentReturnType"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "assertEquals ( TestBean . class ,    xbf . getType (  \" externalWithoutArgs \"  )  )  ;", "assertEquals ( TestBean . class ,    xbf . getType (  \" externalWithArgs \"  )  )  ;", "String [  ]    names    =    xbf . getBeanNamesForType ( TestBean . class )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" externalWithoutArgs \"  )  )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" externalWithArgs \"  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( xbf . getBean (  \" externalWithoutArgs \"  )  )  )  ;", "assertEquals (  2  ,    tb . getAge (  )  )  ;", "assertEquals (  \" Tristan \"  ,    tb . getName (  )  )  ;", "tb    =     (  ( TestBean )     ( xbf . getBean (  \" externalWithArgs \"  )  )  )  ;", "assertEquals (  3  3  ,    tb . getAge (  )  )  ;", "assertEquals (  \" Rod \"  ,    tb . getName (  )  )  ;", "assertEquals ( TestBean . class ,    xbf . getType (  \" externalWithoutArgs \"  )  )  ;", "assertEquals ( TestBean . class ,    xbf . getType (  \" externalWithArgs \"  )  )  ;", "names    =    xbf . getBeanNamesForType ( TestBean . class )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" externalWithoutArgs \"  )  )  ;", "assertTrue ( Arrays . asList ( names )  . contains (  \" externalWithArgs \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodsOnExternalClass"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "s   fm    =     (  ( s )     ( xbf . getBean (  \" defaultPrototype \"  )  )  )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" defaultPrototype \"  )  )  )  ;", "assertEquals (  0  ,    fm . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" defaultInstance \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "assertEquals (  \" setterString \"  ,    fm . getStringValue (  )  )  ;", "assertEquals ( fm . getNum (  )  ,    fm 2  . getNum (  )  )  ;", "assertEquals ( fm . getStringValue (  )  ,    fm 2  . getStringValue (  )  )  ;", "assertNotSame ( fm . getTestBean (  )  ,    fm 2  . getTestBean (  )  )  ;", "assertNotSame ( fm ,    fm 2  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  )  )  )  ;", "fm 2     =     (  ( s )     ( xbf . getBean (  \" testBeanOnlyPrototype \"  )  )  )  ;", "assertEquals (  0  ,    fm . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "assertEquals ( fm . getNum (  )  ,    fm 2  . getNum (  )  )  ;", "assertEquals ( fm . getStringValue (  )  ,    fm 2  . getStringValue (  )  )  ;", "assertSame ( fm . getTestBean (  )  ,    fm 2  . getTestBean (  )  )  ;", "assertNotSame ( fm ,    fm 2  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" fullPrototype \"  )  )  )  ;", "fm 2     =     (  ( s )     ( xbf . getBean (  \" fullPrototype \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals (  \" gotcha \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "assertEquals ( fm . getNum (  )  ,    fm 2  . getNum (  )  )  ;", "assertEquals ( fm . getStringValue (  )  ,    fm 2  . getStringValue (  )  )  ;", "assertSame ( fm . getTestBean (  )  ,    fm 2  . getTestBean (  )  )  ;", "assertNotSame ( fm ,    fm 2  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodsPrototypeOnTargetClass"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( xbf . getBean (  \" defaultTestBean \"  )  )  )  ;", "assertEquals (  \" defaultInstance \"  ,    tb . getName (  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "s   fm    =     (  ( s )     ( xbf . getBean (  \" default \"  )  )  )  ;", "assertEquals (  0  ,    fm . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" defaultInstance \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "assertEquals (  \" setterString \"  ,    fm . getStringValue (  )  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" testBeanOnly \"  )  )  )  ;", "assertEquals (  0  ,    fm . getNum (  )  )  ;", "assertEquals (  \" default \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" full \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals (  \" gotcha \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" full \"  )  )  )  ;", "assertSame ( fm ,    fm 2  )  ;", "xbf . destroySingletons (  )  ;", "assertTrue ( tb . wasDestroyed (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodsSingletonOnTargetClass"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "s   fm    =     (  ( s )     ( xbf . getBean (  \" fullWithAutowire \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals (  \" gotchaAutowired \"  ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodsWithAutowire"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "try    {", "xbf . getBean (  \" defaultTestBeanWithInvalidDestroyMethod \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFactoryMethodsWithInvalidDestroyMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "assertEquals (  \" null \"  ,    xbf . getBean (  \" null \"  )  . toString (  )  )  ;", "try    {", "xbf . getBean (  \" nullWithProperty \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFactoryMethodsWithNullInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "s   fm    =     (  ( s )     ( xbf . getBean (  \" fullWithNull \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals ( null ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" fullWithGenericNull \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals ( null ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "fm    =     (  ( s )     ( xbf . getBean (  \" fullWithNamedNull \"  )  )  )  ;", "assertEquals (  2  7  ,    fm . getNum (  )  )  ;", "assertEquals ( null ,    fm . getName (  )  )  ;", "assertEquals (  \" Juergen \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFactoryMethodsWithNullValue"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "InstanceFactory . count    =     0  ;", "xbf . preInstantiateSingletons (  )  ;", "assertEquals (  1  ,    InstanceFactory . count )  ;", "s   fm    =     (  ( s )     ( xbf . getBean (  \" instanceWithoutArgs \"  )  )  )  ;", "assertEquals (  \" instanceFactory \"  ,    fm . getTestBean (  )  . getName (  )  )  ;", "assertEquals (  1  ,    InstanceFactory . count )  ;", "s   fm 2     =     (  ( s )     ( xbf . getBean (  \" instanceWithoutArgs \"  )  )  )  ;", "assertEquals (  \" instanceFactory \"  ,    fm 2  . getTestBean (  )  . getName (  )  )  ;", "assertSame ( fm 2  ,    fm )  ;", "assertEquals (  1  ,    InstanceFactory . count )  ;", "}", "METHOD_END"], "methodName": ["testInstanceFactoryMethodWithoutArgs"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "try    {", "xbf . getBean (  \" invalidPrototype \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \" nonExisting ( TestBean )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNonExistingFactoryMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( xbf . getBean (  \" defaultTestBean . private \"  )  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrivateFactoryMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   xbf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( xbf )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" factory - methods . xml \"  ,    getClass (  )  )  )  ;", "TestBean   tb    =     (  ( TestBean )     ( xbf . getBean (  \" defaultTestBean . protected \"  )  )  )  ;", "assertEquals (  1  ,    tb . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["testProtectedFactoryMethod"], "fileName": "org.springframework.beans.factory.xml.FactoryMethodTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" defaultInstance \"  )  ;", "return   new    ( tb ,     \" default \"  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["defaultInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   num ;", "}", "METHOD_END"], "methodName": ["getNum"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . stringValue ;", "}", "METHOD_END"], "methodName": ["getStringValue"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["getTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   Collections . EMPTY _ LIST ;", "}", "METHOD_END"], "methodName": ["listInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   new   FactoryMethods ( tb ,     \" default \"  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( something    !  =    null )     {", "throw   new   IllegalStateException (  \" Should   never   be   called   with   non - null   value \"  )  ;", "}", "return   new    . Extended ( tb ,    null ,    num )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )     {", "throw   new   IllegalStateException (  \" Should   never   be   called   with   null   value \"  )  ;", "}", "return   new    ( tb ,    name ,    num )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["nullInstance"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["privateGetTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   this . tb ;", "}", "METHOD_END"], "methodName": ["protectedGetTestBean"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "this . stringValue    =    stringValue ;", "}", "METHOD_END"], "methodName": ["setStringValue"], "fileName": "org.springframework.beans.factory.xml.FactoryMethods"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.xml.GeneratedNameBean"}, {"methodBody": ["METHOD_START", "{", "return   child ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "org.springframework.beans.factory.xml.GeneratedNameBean"}, {"methodBody": ["METHOD_START", "{", "this . child    =    child ;", "}", "METHOD_END"], "methodName": ["setChild"], "fileName": "org.springframework.beans.factory.xml.GeneratedNameBean"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethod 1 Called    =    true ;", "}", "METHOD_END"], "methodName": ["destroyMethod1"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethod 2 Called    =    true ;", "}", "METHOD_END"], "methodName": ["destroyMethod2"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "this . destroyMethod 3 Called    =    true ;", "}", "METHOD_END"], "methodName": ["destroyMethod3"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethod 1 Called    =    true ;", "}", "METHOD_END"], "methodName": ["initMethod1"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethod 2 Called    =    true ;", "}", "METHOD_END"], "methodName": ["initMethod2"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethod 3 Called    =    true ;", "}", "METHOD_END"], "methodName": ["initMethod3"], "fileName": "org.springframework.beans.factory.xml.InitDestroyBean"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName ( thiBeanProperty )  ;", "return   FactoryMethods . newInstance ( tb )  ;", "}", "METHOD_END"], "methodName": ["defaultInstance"], "fileName": "org.springframework.beans.factory.xml.InstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   this . factoryBeanProperty ;", "}", "METHOD_END"], "methodName": ["getFactoryBeanProperty"], "fileName": "org.springframework.beans.factory.xml.InstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   FactoryMethods . newInstance ( tb )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.InstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   FactoryMethods . newInstance ( tb ,    num ,    name )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.springframework.beans.factory.xml.InstanceFactory"}, {"methodBody": ["METHOD_START", "{", "this . factoryBeanProperty    =    s ;", "}", "METHOD_END"], "methodName": ["setFactoryBeanProperty"], "fileName": "org.springframework.beans.factory.xml.InstanceFactory"}, {"methodBody": ["METHOD_START", "{", "MailSession   session    =    new   MailSession (  )  ;", "session . setProperties ( props )  ;", "return   session ;", "}", "METHOD_END"], "methodName": ["getDefaultInstance"], "fileName": "org.springframework.beans.factory.xml.MailSession"}, {"methodBody": ["METHOD_START", "{", "return   this . props . get ( key )  ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.springframework.beans.factory.xml.MailSession"}, {"methodBody": ["METHOD_START", "{", "this . props    =    props ;", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "org.springframework.beans.factory.xml.MailSession"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition 1     =    this . beanFactory . getMergedBeanDefinition (  \" testBean 1  \"  )  ;", "assertEquals (  \" bar \"  ,    beanDefinition 1  . getAttribute (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["metadataAttachment"], "fileName": "org.springframework.beans.factory.xml.MetadataAttachmentTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" testBean 2  \"  )  ;", "assertEquals (  \"    not   inherited \"  ,     \" bar \"  ,    beanDefinition . getAttribute (  \" foo \"  )  )  ;", "assertEquals (  \" Child   metdata   not   attached \"  ,     \"  1  2  3  \"  ,    beanDefinition . getAttribute (  \" abc \"  )  )  ;", "}", "METHOD_END"], "methodName": ["metadataIsInherited"], "fileName": "org.springframework.beans.factory.xml.MetadataAttachmentTests"}, {"methodBody": ["METHOD_START", "{", "BeanDefinition   beanDefinition    =    this . beanFactory . getMergedBeanDefinition (  \" testBean 3  \"  )  ;", "PropertyValue   pv    =    beanDefinition . getPropertyValues (  )  . getPropertyValue (  \" name \"  )  ;", "assertEquals (  \" Harrop \"  ,    pv . getAttribute (  \" surname \"  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyMetadata"], "fileName": "org.springframework.beans.factory.xml.MetadataAttachmentTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" withMeta . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.MetadataAttachmentTests"}, {"methodBody": ["METHOD_START", "{", "return   jumble ;", "}", "METHOD_END"], "methodName": ["getJumble"], "fileName": "org.springframework.beans.factory.xml.MixedCollectionBean"}, {"methodBody": ["METHOD_START", "{", "this . jumble    =    jumble ;", "}", "METHOD_END"], "methodName": ["setJumble"], "fileName": "org.springframework.beans.factory.xml.MixedCollectionBean"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionDecorator   decorator    =    null ;", "St   localName    =    parserContext . getDelegate (  )  . getLocalName ( node )  ;", "if    ( node   instanceof   Element )     {", "decorator    =    this . decorators . get ( localName )  ;", "} else", "if    ( node   instanceof   Attr )     {", "decorator    =    this . attributeDecorators . get ( localName )  ;", "} else    {", "parserContext . getReaderContext (  )  . fatal (  (  (  \" Cannot   decorate   based   on   Nodes   of   type    [  \"     +     ( node . getClass (  )  . getName (  )  )  )     +     \"  ]  \"  )  ,    node )  ;", "}", "if    ( decorator    =  =    null )     {", "parserContext . getReaderContext (  )  . fatal (  (  (  (  (  \" Cannot   locate   BeanDefinitionDecorator   for    \"     +     ( node   instanceof   Element    ?     \" element \"     :     \" attribute \"  )  )     +     \"     [  \"  )     +    localName )     +     \"  ]  \"  )  ,    node )  ;", "}", "return   decorator ;", "}", "METHOD_END"], "methodName": ["findDecoratorForNode"], "fileName": "org.springframework.beans.factory.xml.NamespaceHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "String   localName    =    parserContext . getDelegate (  )  . getLocalName ( element )  ;", "BeanDefinitionParser   parser    =    this . parsers . get ( localName )  ;", "if    ( parser    =  =    null )     {", "parserContext . getReaderContext (  )  . fatal (  (  (  \" Cannot   locate   BeanDefinitionParser   for   element    [  \"     +    localName )     +     \"  ]  \"  )  ,    element )  ;", "}", "return   parser ;", "}", "METHOD_END"], "methodName": ["findParserForElement"], "fileName": "org.springframework.beans.factory.xml.NamespaceHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "this . decorators . put ( elementName ,    dec )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitionDecorator"], "fileName": "org.springframework.beans.factory.xml.NamespaceHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "this . attributeDecorators . put ( attrName ,    dec )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitionDecoratorForAttribute"], "fileName": "org.springframework.beans.factory.xml.NamespaceHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "this . parsers . put ( elementName ,    parser )  ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitionParser"], "fileName": "org.springframework.beans.factory.xml.NamespaceHandlerSupport"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - autowire - candidates - context . xml \"  ,    this . getClass (  )  )  )  ;", "assertThat ( bf . getBeanDefinition (  \" fooService \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" fooRepository \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" other \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" barService \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" fooController \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" bizRepository \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" bizService \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" bazService \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" random \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" fooComponent \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" fRepository \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "assertThat ( bf . getBeanDefinition (  \" aComponent \"  )  . isAutowireCandidate (  )  ,    is ( true )  )  ;", "assertThat ( bf . getBeanDefinition (  \" someService \"  )  . isAutowireCandidate (  )  ,    is ( false )  )  ;", "}", "METHOD_END"], "methodName": ["defaultAutowireCandidates"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementAttributeRecursionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - lazy - context . xml \"  ,    this . getClass (  )  )  )  ;", "BeanDefinition   foo    =    bf . getBeanDefinition (  \" foo \"  )  ;", "BeanDefinition   bar    =    bf . getBeanDefinition (  \" bar \"  )  ;", "BeanDefinition   baz    =    bf . getBeanDefinition (  \" baz \"  )  ;", "BeanDefinition   biz    =    bf . getBeanDefinition (  \" biz \"  )  ;", "BeanDefinition   buz    =    bf . getBeanDefinition (  \" buz \"  )  ;", "assertThat ( foo . isLazyInit (  )  ,    is ( false )  )  ;", "assertThat ( bar . isLazyInit (  )  ,    is ( true )  )  ;", "assertThat ( baz . isLazyInit (  )  ,    is ( false )  )  ;", "assertThat ( biz . isLazyInit (  )  ,    is ( true )  )  ;", "assertThat ( buz . isLazyInit (  )  ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["defaultLazyInit"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementAttributeRecursionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - merge - context . xml \"  ,    this . getClass (  )  )  )  ;", "TestBean   topLevel    =    bf . getBean (  \" topLevelConcreteTestBean \"  ,    TestBean . class )  ;", "assertThat (  (  ( Iterable < String >  )     ( topLevel . getSomeList (  )  )  )  ,    hasItems (  \" charlie \"  ,     \" delta \"  )  )  ;", "assertThat (  (  ( Iterable < String >  )     ( topLevel . getSomeList (  )  )  )  ,    not ( hasItems (  \" alpha \"  ,     \" bravo \"  )  )  )  ;", "TestBean   firstLevel    =    bf . getBean (  \" firstLevelNestedTestBean \"  ,    TestBean . class )  ;", "assertThat (  (  ( Iterable < String >  )     ( firstLevel . getSomeList (  )  )  )  ,    hasItems (  \" charlie \"  ,     \" delta \"  ,     \" echo \"  ,     \" foxtrot \"  )  )  ;", "TestBean   secondLevel    =    bf . getBean (  \" secondLevelNestedTestBean \"  ,    TestBean . class )  ;", "assertThat (  (  ( Iterable < String >  )     ( secondLevel . getSomeList (  )  )  )  ,    hasItems (  \" charlie \"  ,     \" delta \"  ,     \" echo \"  ,     \" foxtrot \"  ,     \" golf \"  ,     \" hotel \"  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultMerge"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementAttributeRecursionTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \"  - init - destroy - context . xml \"  ,    this . getClass (  )  )  )  ;", "InitDestroyBean   beanA    =    bf . getBean (  \" beanA \"  ,    InitDestroyBean . class )  ;", "InitDestroyBean   beanB    =    bf . getBean (  \" beanB \"  ,    InitDestroyBean . class )  ;", "InitDestroyBean   beanC    =    bf . getBean (  \" beanC \"  ,    InitDestroyBean . class )  ;", "InitDestroyBean   beanD    =    bf . getBean (  \" beanD \"  ,    InitDestroyBean . class )  ;", "assertThat ( beanA . initMethod 1 Called ,    is ( true )  )  ;", "assertThat ( beanB . initMethod 2 Called ,    is ( true )  )  ;", "assertThat ( beanC . initMethod 3 Called ,    is ( true )  )  ;", "assertThat ( beanD . initMethod 2 Called ,    is ( true )  )  ;", "bf . destroySingletons (  )  ;", "assertThat ( beanA . destroyMethod 1 Called ,    is ( true )  )  ;", "assertThat ( beanB . destroyMethod 2 Called ,    is ( true )  )  ;", "assertThat ( beanC . destroyMethod 3 Called ,    is ( true )  )  ;", "assertThat ( beanD . destroyMethod 2 Called ,    is ( true )  )  ;", "}", "METHOD_END"], "methodName": ["initMethod"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementAttributeRecursionTests"}, {"methodBody": ["METHOD_START", "{", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setActiveProfiles (  \" dev \"  )  ;", "DefaultListableBeanF   bf    =    new   DefaultListableBeanF (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( XML )  ;", "bf . getBean (  \" devOnlyBean \"  )  ;", "Object   foo    =    bf . getBean (  \" foo \"  )  ;", "assertThat ( foo ,    instanceOf ( Integer . class )  )  ;", "bf . getBean (  \" devOnlyBean \"  )  ;", "}", "METHOD_END"], "methodName": ["getBean_withActiveProfile"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( XML )  ;", "Object   foo    =    bf . getBean (  \" foo \"  )  ;", "assertThat ( foo ,    instanceOf ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["getBean_withoutActiveProfile"], "fileName": "org.springframework.beans.factory.xml.NestedBeansElementTests"}, {"methodBody": ["METHOD_START", "{", "return   this . readerContext . extractSource ( sourceCandidate )  ;", "}", "METHOD_END"], "methodName": ["extractSource"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . containingBeanDefinition ;", "}", "METHOD_END"], "methodName": ["getContainingBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . containingComponents . peek (  )  ;", "}", "METHOD_END"], "methodName": ["getContainingComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . readerContext ;", "}", "METHOD_END"], "methodName": ["getReaderContext"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . readerContext . getRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionParserDelegate . TRUE _ VALUE . equals ( this . delegate . getDefaults (  )  . getLazyInit (  )  )  ;", "}", "METHOD_END"], "methodName": ["isDefaultLazyInit"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return    ( this . containingBeanDefinition )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isNested"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "registerComponent ( popContainingComponent (  )  )  ;", "}", "METHOD_END"], "methodName": ["popAndRegisterContainingComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "return   this . containingComponents . pop (  )  ;", "}", "METHOD_END"], "methodName": ["popContainingComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "this . containingComponents . push ( containingComponent )  ;", "}", "METHOD_END"], "methodName": ["pushContainingComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionReaderUtils . registerBeanDefinition ( component ,    getRegistry (  )  )  ;", "registmponent ( component )  ;", "}", "METHOD_END"], "methodName": ["registerBeanComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "CompositeComponentDefinition   containingComponent    =    getContainingComponent (  )  ;", "if    ( containingComponent    !  =    null )     {", "containingComponent . addNestedComponent ( component )  ;", "} else    {", "this . read . fireComponentRegistered ( component )  ;", "}", "}", "METHOD_END"], "methodName": ["registerComponent"], "fileName": "org.springframework.beans.factory.xml.ParserContext"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    schemaMappings    =    this . schemaMappings ;", "if    ( schemaMappings    =  =    null )     {", "synchronized ( this )     {", "schemaMappings    =    this . schemaMappings ;", "if    ( schemaMappings    =  =    null )     {", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  (  \" Loading   schema   mappings   from    [  \"     +     ( this . schemaMappingsLocation )  )     +     \"  ]  \"  )  )  ;", "}", "try    {", "Properties   mappings    =    PropertiesLoaderUtils . loadAllProperties ( this . schemaMappingsLocation ,    this . classLoader )  ;", "if    (  . logger . isDebugEnabled (  )  )     {", ". logger . debug (  (  \" Loaded   schema   mappings :     \"     +    mappings )  )  ;", "}", "Map < String ,    String >    mappingsToUse    =    new   ConcurrentHashMap <  >  ( mappings . size (  )  )  ;", "CollectionUtils . mergePropertiesIntoMap ( mappings ,    mappingsToUse )  ;", "schemaMappings    =    mappingsToUse ;", "this . schemaMappings    =    schemaMappings ;", "}    catch    ( IOException   ex )     {", "throw   new   IllegalStateException (  (  (  \" Unable   to   load   schema   mappings   from   location    [  \"     +     ( this . schemaMappingsLocation )  )     +     \"  ]  \"  )  ,    ex )  ;", "}", "}", "}", "}", "return   schemaMappings ;", "}", "METHOD_END"], "methodName": ["getSchemaMappings"], "fileName": "org.springframework.beans.factory.xml.PluggableSchemaResolver"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "Reader   reader    =    new   Reader ( beanFactory )  ;", "StandardEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setActiveProfiles ( activeProfiles )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource ( xmlName ,    getClass (  )  )  )  ;", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["beanFactoryFor"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeSafeMatcher < BeanDefinitionRegistry >  (  )     {", "@ Override", "public   void   describeTo ( Description   desc )     {", "desc . appendText (  \" a   BeanDefinitionRegistry   containing   bean   named    \"  )  . appendValue ( beanName )  ;", "}", "@ Override", "public   boolean   matchesSafely ( BeanDefinitionRegistry   beanFactory )     {", "return   beanFactory . containsBeanDefinition ( beanName )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["containsBeanDefinition"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "return   ProfileXmlBeanDefinitionTests . containsBeanDefinition ( ProfileXmlBeanDefinitionTests . TARGET _ BEAN )  ;", "}", "METHOD_END"], "methodName": ["containsTargetBean"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEFAULT _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEFAULT _ ELIGIBLE _ XML ,     \" other \"  )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setActiveProfiles ( ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ;", "env . setDefaultProfiles (  \" default \"  )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource ( ProfileXmlBeanDefinitionTests . DEFAULT _ AND _ DEV _ ELIGIBLE _ XML ,    getClass (  )  )  )  ;", "assertThat ( beanFactory ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "}", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setDefaultProfiles (  \" default \"  )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource ( ProfileXmlBeanDefinitionTests . DEFAULT _ AND _ DEV _ ELIGIBLE _ XML ,    getClass (  )  )  )  ;", "assertThat ( beanFactory ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "}", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource ( ProfileXmlBeanDefinitionTests . DEFAULT _ AND _ DEV _ ELIGIBLE _ XML ,    getClass (  )  )  )  ;", "assertThat ( beanFactory ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaultAndNonDefaultProfile"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setDefaultProfiles (  \" custom - default \"  )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . DEFAULT _ ELIGIBLE _ XML ,    getClass (  )  )  )  ;", "assertThat ( beanFactory ,    not (  . containsTargetBean (  )  )  )  ;", "}", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( beanFactory )  ;", "ConfigurableEnvironment   env    =    new   StandardEnvironment (  )  ;", "env . setDefaultProfiles (  \" custom - default \"  )  ;", "reader . setEnvironment ( env )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  . CUSTOM _ DEFAULT _ ELIGIBLE _ XML ,    getClass (  )  )  )  ;", "assertThat ( beanFactory ,     . containsTargetBean (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaultProfile"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . PROD _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . PROD _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . PROD _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . PROD _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . ALL _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . ALL _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . ALL _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . ALL _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . UNKNOWN _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NEGATED _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NEGATED _ XML ,    ProfileXmlBeanDefinitionTests . UNKNOWN _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NEGATED _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NEGATED _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NEGATED _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . UNKNOWN _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ NOT _ DEV _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ SPACE _ DELIMITED _ XML ,    ProfileXmlBeanDefinitionTests . NONE _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ SPACE _ DELIMITED _ XML ,    ProfileXmlBeanDefinitionTests . UNKNOWN _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ SPACE _ DELIMITED _ XML ,    ProfileXmlBeanDefinitionTests . DEV _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ SPACE _ DELIMITED _ XML ,    ProfileXmlBeanDefinitionTests . PROD _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . MULTI _ ELIGIBLE _ SPACE _ DELIMITED _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  ;", "assertThat ( beanFactoryFor ( ProfileXmlBeanDefinitionTests . UNKNOWN _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . MULTI _ ACTIVE )  ,    not ( ProfileXmlBeanDefinitionTests . containsTargetBean (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testProfilePermutations"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "beanFactoryFor ( ProfileXmlBeanDefinitionTests . PROD _ ELIGIBLE _ XML ,    ProfileXmlBeanDefinitionTests . NULL _ ACTIVE )  ;", "}", "METHOD_END"], "methodName": ["testProfileValidation"], "fileName": "org.springframework.beans.factory.xml.ProfileXmlBeanDefinitionTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( this . inited )  )     |  |     (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )  )     |  |     (  !  ( this . postProcessedAfterInit )  )  )     {", "throw   new   RuntimeException (  \" Factory   didn ' t   initialize   l   object   correctly \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["businessMethod"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" F   didn ' t   call   afterPropertiesSet   before   declared   init   method \"  )  ;", "}", "if    ( this . initedViaDeclaredInitMethod )     {", "throw   new   RuntimeException (  \" F   called   declared   init   method   twice \"  )  ;", "}", "this . initedViaDeclaredInitMethod    =    true ;", "}", "METHOD_END"], "methodName": ["declaredInitMethod"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   destroyed ;", "}", "METHOD_END"], "methodName": ["isDestroyed"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["isInitMethodDeclared"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   before   afterPropertiesSet \"  )  ;", "}", "if    (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   before   calling   declared   init   method \"  )  ;", "}", "if    ( this . postProcessedAfterInit )     {", "throw   new   RuntimeException (  \" F   called   postProcessAfterInit   twice \"  )  ;", "}", "this . postProcessedAfterInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessAfterInit"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . inited )     |  |     ( this . initedViaDeclaredInitMethod )  )     {", "throw   new   RuntimeException (  \" F   called   postProcessBeforeInit   after   afterPropertiesSet \"  )  ;", "}", "if    ( this . postProcessedBeforeInit )     {", "throw   new   RuntimeException (  \" F   called   postProcessBeforeInit   twice \"  )  ;", "}", "this . postProcessedBeforeInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessBeforeInit"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethodDeclared    =    initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["setInitMethodDeclared"], "fileName": "org.springframework.beans.factory.xml.ProtectedLifecycleBean"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . setValidationMode ( XmlBeanDefinitionReader . VALIDATION _ XSD )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" sed . xml \"  ,    getClass (  )  )  )  ;", "TestBean   foo    =     (  ( TestBean )     ( bf . getBean (  \" fooBean \"  )  )  )  ;", "assertNotNull (  \" Spouse   is   null \"  ,    foo . getSpouse (  )  )  ;", "assertEquals (  \" Incorrect   number   of   friends \"  ,     2  ,    foo . getFriends (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadDefinitions"], "fileName": "org.springframework.beans.factory.xml.SchemaValidationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "try    {", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" invalidPerSchema . xml \"  ,    getClass (  )  )  )  ;", "fail (  \" Should   not   be   able   to   parse   a   file   with   errors \"  )  ;", "}    catch    ( BeansException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   SAXParseException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withAutodetection"], "fileName": "org.springframework.beans.factory.xml.SchemaValidationTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( bf )  ;", "reader . setMode ( XmlBeanDefinitionReader . VALIDATION _ XSD )  ;", "try    {", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" invalidPerSchema . xml \"  ,    getClass (  )  )  )  ;", "fail (  \" Should   not   be   able   to   parse   a   file   with   errors \"  )  ;", "}    catch    ( BeansException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   SAXParseException )  )  ;", "}", "}", "METHOD_END"], "methodName": ["withExplicitValidationMode"], "fileName": "org.springframework.beans.factory.xml.SchemaValidationTests"}, {"methodBody": ["METHOD_START", "{", "for    ( ConstructorArgumentValues . ValueHolder   holder    :    values )     {", "if    ( name . equals ( holder . getName (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["checkName"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "return    ( checkName ( name ,    cvs . getGenericArgumentValues (  )  )  )     |  |     ( checkName ( name ,    cvs . getIndexedArgumentValues (  )  . values (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["containsArgWithName"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource (  \" sWithErrors . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["ambiguousConstructor"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "DummyBean   derivedBean    =    beanFactory . getBean (  \" beanWithRefConstructorArg \"  ,    DummyBean . class )  ;", "assertEquals (  1  0  ,    derivedBean . getAge (  )  )  ;", "assertEquals (  \" silly   name \"  ,    derivedBean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorWithNameEndingInRef"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   bf    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( bf )  . loadBeanDefinitions ( new   ClassPathResource ( resourceName ,    getClass (  )  )  )  ;", "return   bf ;", "}", "METHOD_END"], "methodName": ["createFactory"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "TestBean   nameValue    =    beanFactory . getBean (  \" name - value \"  ,    TestBean . class )  ;", "DummyBean   nameRef    =    beanFactory . getBean (  \" name - ref \"  ,    DummyBean . class )  ;", "assertEquals (  \" some - name \"  ,    nameRef . getName (  )  )  ;", "assertEquals ( nameValue ,    nameRef . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameRef"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "String   name    =     \" name - value \"  ;", "TestBean   nameValue    =    beanFactory . getBean ( name ,    TestBean . class )  ;", "assertEquals ( name ,    nameValue . getName (  )  )  ;", "assertEquals (  1  0  ,    nameValue . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["nameValue"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "String   name    =     \" simple - ref \"  ;", "DummyBean   nameValue    =    beanFactory . getBean ( name ,    DummyBean . class )  ;", "assertEquals ( beanFactory . getBean (  \" name \"  )  ,    nameValue . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleRef"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "String   name    =     \" simple \"  ;", "DummyBean   nameValue    =    beanFactory . getBean ( name ,    DummyBean . class )  ;", "assertEquals (  \" simple \"  ,    nameValue . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["simpleValue"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "DummyBean   typeRef    =    beanFactory . getBean (  \" indexed - ref \"  ,    DummyBean . class )  ;", "assertEquals (  \" some - name \"  ,    typeRef . getName (  )  )  ;", "assertEquals ( beanFactory . getBean (  \" name - value \"  )  ,    typeRef . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["typeIndexedRef"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    createFactory (  \" simpleConstructorNamespaceHandlerTests . xml \"  )  ;", "DummyBean   typeRef    =    beanFactory . getBean (  \" indexed - value \"  ,    DummyBean . class )  ;", "assertEquals (  \" at \"  ,    typeRef . getName (  )  )  ;", "assertEquals (  \" austria \"  ,    typeRef . getValue (  )  )  ;", "assertEquals (  1  0  ,    typeRef . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["typeIndexedValue"], "fileName": "org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" s . xml \"  ,    getClass (  )  )  )  ;", "TestBean   sally    =     (  ( TestBean )     ( beanFactory . getBean (  \" sally 2  \"  )  )  )  ;", "ITestBean   rob    =    sally . getSpouse (  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    rob . getName (  )  )  ;", "assertEquals (  2  4  ,    rob . getAge (  )  )  ;", "assertEquals ( rob . getSpouse (  )  ,    sally )  ;", "}", "METHOD_END"], "methodName": ["innerBeanConfigured"], "fileName": "org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" s . xml \"  ,    getClass (  )  )  )  ;", "ITestBean   sally    =     (  ( TestBean )     ( beanFactory . getBean (  \" derivedSally \"  )  )  )  ;", "assertEquals (  \" r \"  ,    sally . getSpouse (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyWithNameEndingInRef"], "fileName": "org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" s . xml \"  ,    getClass (  )  )  )  ;", "ITestBean   rob    =     (  ( TestBean )     ( beanFactory . getBean (  \" rob \"  )  )  )  ;", "ITestBean   sally    =     (  ( TestBean )     ( beanFactory . getBean (  \" sally \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    rob . getName (  )  )  ;", "assertEquals (  2  4  ,    rob . getAge (  )  )  ;", "assertEquals ( rob . getSpouse (  )  ,    sally )  ;", "}", "METHOD_END"], "methodName": ["simpleBeanConfigured"], "fileName": "org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "new   XmlBeanDefinitionReader ( beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" sWithErrors . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withPropertyDefinedTwice"], "fileName": "org.springframework.beans.factory.xml.SimplePropertyNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName (  \" Tristan \"  )  ;", "tb . setAge (  2  )  ;", "return   tb ;", "}", "METHOD_END"], "methodName": ["createTestBean"], "fileName": "org.springframework.beans.factory.xml.TestBeanCreator"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setName ( name )  ;", "tb . setAge ( age )  ;", "return   tb ;", "}", "METHOD_END"], "methodName": ["createTestBean"], "fileName": "org.springframework.beans.factory.xml.TestBeanCreator"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory    =    new   DefaultListableBeanFactory (  )  ;", "XmlBeanDefinitionReader   reader    =    new   XmlBeanDefinitionReader ( this . beanFactory )  ;", "reader . setEventListener ( this . listener )  ;", "reader . loadBeanDefinitions ( new   ClassPathResource (  \" test . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . getBean (  \" circularList \"  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" circularCollectionBeansBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertTrue ( Proxy . isProxyClass ( list . getClass (  )  )  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( bean ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertFalse ( Proxy . isProxyClass ( set . getClass (  )  )  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains ( bean )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertFalse ( Proxy . isProxyClass ( map . getClass (  )  )  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( bean ,    map . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularCollectionBeansStartingWithList"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . getBean (  \" circularMap \"  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" circularCollectionBeansBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertFalse ( Proxy . isProxyClass ( list . getClass (  )  )  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( bean ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertFalse ( Proxy . isProxyClass ( set . getClass (  )  )  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains ( bean )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertTrue ( Proxy . isProxyClass ( map . getClass (  )  )  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( bean ,    map . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularCollectionBeansStartingWithMap"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "this . beanFactory . getBean (  \" circularSet \"  )  ;", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" circularCollectionBeansBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertFalse ( Proxy . isProxyClass ( list . getClass (  )  )  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( bean ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertTrue ( Proxy . isProxyClass ( set . getClass (  )  )  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains ( bean )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertFalse ( Proxy . isProxyClass ( map . getClass (  )  )  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( bean ,    map . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularCollectionBeansStartingWithSet"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" circularCollectionsBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( bean ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains ( bean )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( bean ,    map . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCircularCollections"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Integer   min    =     (  ( Integer )     ( this . beanFactory . getBean (  \" min \"  )  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,    min . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstant"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Integer   max    =     (  ( Integer )     ( this . beanFactory . getBean (  \" MAX _ VALUE \"  )  )  )  ;", "assertEquals ( Integer . MAX _ VALUE ,    max . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstantWithDefaultName"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "ComponentDefinition   propertiesComponent    =    this . listener . getComponentDefinition (  \" myProperties \"  )  ;", "assertNotNull (  \" Event   for    ' myProperties '    not   sent \"  ,    propertiesComponent )  ;", "AbstractBeanDefinition   propertiesBean    =     (  ( AbstractBeanDefinition )     ( propertiesComponent . getBeanDefinitions (  )  [  0  ]  )  )  ;", "assertEquals (  \" Incorrect   BeanDefinition \"  ,    PropertiesFBean . class ,    propertiesBean . getBeanClass (  )  )  ;", "ComponentDefinition   constantComponent    =    this . listener . getComponentDefinition (  \" min \"  )  ;", "assertNotNull (  \" Event   for    ' min '    not   sent \"  ,    propertiesComponent )  ;", "AbstractBeanDefinition   constantBean    =     (  ( AbstractBeanDefinition )     ( constantComponent . getBeanDefinitions (  )  [  0  ]  )  )  ;", "assertEquals (  \" Incorrect   BeanDefinition \"  ,    FieldRetrievingFBean . class ,    constantBean . getBeanClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEvents"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" myProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,    null ,    props . get (  \" foo 2  \"  )  )  ;", "Properties   props 2     =     (  ( Properties )     ( this . beanFactory . getBean (  \" myProperties \"  )  )  )  ;", "assertTrue (  ( props    =  =    props 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testLoadProperties"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" defaultLocalOverrideProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" local 2  \"  ,    props . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalOverrideDefault"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" falseLocalOverrideProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" local 2  \"  ,    props . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalOverrideFalse"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" trueLocalOverrideProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" local \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" local 2  \"  ,    props . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalOverrideTrue"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" myLocalProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,    null ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar 2  \"  ,    props . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocalProperties"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" mapWithRef \"  )  )  )  ;", "assertTrue (  ( map   instanceof   TreeMap )  )  ;", "assertEquals ( this . beanFactory . getBean (  \" testBean \"  )  ,    map . get (  \" bean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithRef"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" mapWithTypes \"  )  )  )  ;", "assertTrue (  ( map   instanceof   LinkedCaseInsensitiveMap )  )  ;", "assertEquals ( this . beanFactory . getBean (  \" testBean \"  )  ,    map . get (  \" bean \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithTypes"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" myMergedProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar 2  \"  ,    props . get (  \" foo 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergedProperties"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedCollectionsBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals (  \" foo \"  ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains (  \" bar \"  )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertTrue (  (  ( map . get (  \" foo \"  )  )    instanceof   Set )  )  ;", "Set   innerSet    =     (  ( Set )     ( map . get (  \" foo \"  )  )  )  ;", "assertEquals (  1  ,    innerSet . size (  )  )  ;", "assertTrue ( innerSet . contains (  \" bar \"  )  )  ;", "TestBean   bean 2     =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedCollectionsBean \"  )  )  )  ;", "assertEquals ( list ,    bean 2  . getSomeList (  )  )  ;", "assertEquals ( set ,    bean 2  . getSomeSet (  )  )  ;", "assertEquals ( map ,    bean 2  . getSomeMap (  )  )  ;", "assertFalse (  ( list    =  =     ( bean 2  . getSomeList (  )  )  )  )  ;", "assertFalse (  ( set    =  =     ( bean 2  . getSomeSet (  )  )  )  )  ;", "assertFalse (  ( map    =  =     ( bean 2  . getSomeMap (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedCollections"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedCustomTagBean \"  )  )  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals ( Integer . MIN _ VALUE ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  2  ,    set . size (  )  )  ;", "assertTrue ( set . contains ( Thread . State . NEW )  )  ;", "assertTrue ( set . contains ( Thread . State . RUNNABLE )  )  ;", "Map   map    =    bean . getSomeMap (  )  ;", "assertEquals (  1  ,    map . size (  )  )  ;", "assertEquals ( CustomEnum . VALUE _  1  ,    map . get (  \" min \"  )  )  ;", "TestBean   bean 2     =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedCustomTagBean \"  )  )  )  ;", "assertEquals ( list ,    bean 2  . getSomeList (  )  )  ;", "assertEquals ( set ,    bean 2  . getSomeSet (  )  )  ;", "assertEquals ( map ,    bean 2  . getSomeMap (  )  )  ;", "assertFalse (  ( list    =  =     ( bean 2  . getSomeList (  )  )  )  )  ;", "assertFalse (  ( set    =  =     ( bean 2  . getSomeSet (  )  )  )  )  ;", "assertFalse (  ( map    =  =     ( bean 2  . getSomeMap (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedInCollections"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" constructedTestBean \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedInConstructor"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "Properties   props    =    bean . getSomeProperties (  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedProperties"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" testBean \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedPropertyPath"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedShortcutCollections \"  )  )  )  ;", "assertEquals (  1  ,    bean . getStringArray (  )  . length )  ;", "assertEquals (  \" fooStr \"  ,    bean . getStringArray (  )  [  0  ]  )  ;", "List   list    =    bean . getSomeList (  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "assertEquals (  \" foo \"  ,    list . get (  0  )  )  ;", "Set   set    =    bean . getSomeSet (  )  ;", "assertEquals (  1  ,    set . size (  )  )  ;", "assertTrue ( set . contains (  \" bar \"  )  )  ;", "TestBean   bean 2     =     (  ( TestBean )     ( this . beanFactory . getBean (  \" nestedShortcutCollections \"  )  )  )  ;", "assertTrue ( Arrays . equals ( bean . getStringArray (  )  ,    bean 2  . getStringArray (  )  )  )  ;", "assertFalse (  (  ( bean . getStringArray (  )  )     =  =     ( bean 2  . getStringArray (  )  )  )  )  ;", "assertEquals ( list ,    bean 2  . getSomeList (  )  )  ;", "assertEquals ( set ,    bean 2  . getSomeSet (  )  )  ;", "assertFalse (  ( list    =  =     ( bean 2  . getSomeList (  )  )  )  )  ;", "assertFalse (  ( set    =  =     ( bean 2  . getSomeSet (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedShortcutCollections"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "String   name    =     (  ( String )     ( this . beanFactory . getBean (  \" name \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["testPropertyPath"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List   list    =     (  ( List )     ( this . beanFactory . getBean (  \" scopedList \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    list . get (  0  )  )  ;", "List   list 2     =     (  ( List )     ( this . beanFactory . getBean (  \" scopedList \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    list 2  . get (  0  )  )  ;", "assertTrue (  ( list    !  =    list 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedList"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" scopedMap \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    map . get (  \" foo \"  )  )  ;", "Map   map 2     =     (  ( Map )     ( this . beanFactory . getBean (  \" scopedMap \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    map 2  . get (  \" foo \"  )  )  ;", "assertTrue (  ( map    !  =    map 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedMap"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =     (  ( Properties )     ( this . beanFactory . getBean (  \" myScopedProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,    null ,    props . get (  \" foo 2  \"  )  )  ;", "Properties   props 2     =     (  ( Properties )     ( this . beanFactory . getBean (  \" myScopedProperties \"  )  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,     \" bar \"  ,    props . get (  \" foo \"  )  )  ;", "assertEquals (  \" Incorrect   property   value \"  ,    null ,    props . get (  \" foo 2  \"  )  )  ;", "assertTrue (  ( props    !  =    props 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedProperties"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Set   set    =     (  ( Set )     ( this . beanFactory . getBean (  \" scopedSet \"  )  )  )  ;", "assertTrue ( set . contains (  \" Rob   Harrop \"  )  )  ;", "Set   set 2     =     (  ( Set )     ( this . beanFactory . getBean (  \" scopedSet \"  )  )  )  ;", "assertTrue ( set 2  . contains (  \" Rob   Harrop \"  )  )  ;", "assertTrue (  ( set    !  =    set 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testScopedSet"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "List   list    =     (  ( List )     ( this . beanFactory . getBean (  \" simpleList \"  )  )  )  ;", "assertEquals (  \" Rob   Harrop \"  ,    list . get (  0  )  )  ;", "List   list 2     =     (  ( List )     ( this . beanFactory . getBean (  \" simpleList \"  )  )  )  ;", "assertTrue (  ( list    =  =    list 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleList"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" simpleMap \"  )  )  )  ;", "assertEquals (  \" bar \"  ,    map . get (  \" foo \"  )  )  ;", "Map   map 2     =     (  ( Map )     ( this . beanFactory . getBean (  \" simpleMap \"  )  )  )  ;", "assertTrue (  ( map    =  =    map 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleMap"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "Set   set    =     (  ( Set )     ( this . beanFactory . getBean (  \" simpleSet \"  )  )  )  ;", "assertTrue ( set . contains (  \" Rob   Harrop \"  )  )  ;", "Set   set 2     =     (  ( Set )     ( this . beanFactory . getBean (  \" simpleSet \"  )  )  )  ;", "assertTrue (  ( set    =  =    set 2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleSet"], "fileName": "org.springframework.beans.factory.xml.UtilNamespaceHandlerTests"}, {"methodBody": ["METHOD_START", "{", "new   XmlBeanDefinitionReader ( this . beanFactory )  . loadBeanDefinitions ( new   ClassPathResource (  \" collections . xml \"  ,    getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeans"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "MixedCollectionBean   jumble    =     (  ( MixedCollectionBean )     ( this . beanFactory . getBean (  \" jumble \"  )  )  )  ;", "assertTrue (  (  \" Expected    5    elements ,    not    \"     +     ( jumble . getJumble (  )  . size (  )  )  )  ,     (  ( jumble . getJumble (  )  . size (  )  )     =  =     5  )  )  ;", "List   l    =     (  ( List )     ( jumble . getJumble (  )  )  )  ;", "assertTrue ( l . get (  0  )  . equals ( this . beanFactory . getBean (  \" david \"  )  )  )  ;", "assertTrue ( l . get (  1  )  . equals (  \" literal \"  )  )  ;", "assertTrue ( l . get (  2  )  . equals ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "assertTrue ( l . get (  3  )  . equals (  \" rod \"  )  )  ;", "Object [  ]    array    =     (  ( Object [  ]  )     ( l . get (  4  )  )  )  ;", "assertTrue ( array [  0  ]  . equals ( this . beanFactory . getBean (  \" david \"  )  )  )  ;", "assertTrue ( array [  1  ]  . equals (  \" literal 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildCollectionFromMixtureOfReferencesAndValues"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "XmlBeanCollectionTests . MapAndSet   sam    =     (  ( XmlBeanCollectionTests . MapAndSet )     ( this . beanFactory . getBean (  \" setAndMap \"  )  )  )  ;", "assertTrue (  \" Didn ' t   choose   constructor   with   Map   argument \"  ,     (  ( sam . getObject (  )  )    instanceof   Map )  )  ;", "Map   map    =     (  ( Map )     ( sam . getObject (  )  )  )  ;", "assertEquals (  3  ,    map . size (  )  )  ;", "assertEquals (  \" val 1  \"  ,    map . get (  \" key 1  \"  )  )  ;", "assertEquals (  \" val 2  \"  ,    map . get (  \" key 2  \"  )  )  ;", "assertEquals (  \" val 3  \"  ,    map . get (  \" key 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testChoiceBetweenSetAndMap"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" classArray \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getClassArray (  )  . length )     =  =     2  )  )  ;", "assertTrue ( hasMap . getClassArray (  )  [  0  ]  . equals ( String . class )  )  ;", "assertTrue ( hasMap . getClassArray (  )  [  1  ]  . equals ( Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArray"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" classList \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getClassList (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue ( hasMap . getClassList (  )  . get (  0  )  . equals ( String . class )  )  ;", "assertTrue ( hasMap . getClassList (  )  . get (  1  )  . equals ( Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["testClassList"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "ListFean   listF =    new   ListFean (  )  ;", "listFsetSourceList ( new   LinkedList (  )  )  ;", "listFafterPropertiesSet (  )  ;", "assertTrue (  (  ( listFgetObject (  )  )    instanceof   ArrayList )  )  ;", "SetFean   setF =    new   SetFean (  )  ;", "setFsetSourceSet ( new   TreeSet (  )  )  ;", "setFafterPropertiesSet (  )  ;", "assertTrue (  (  ( setFgetObject (  )  )    instanceof   LinkedHashSet )  )  ;", "MapFean   mapF =    new   MapFean (  )  ;", "mapFsetSourceMap ( new   TreeMap (  )  )  ;", "mapFafterPropertiesSet (  )  ;", "assertTrue (  (  ( mapFgetObject (  )  )    instanceof   LinkedHashMap )  )  ;", "}", "METHOD_END"], "methodName": ["testCollectionFactoryDefaults"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" emptyMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . size (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyMap"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" emptyProps \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getProps (  )  . size (  )  )     =  =     0  )  )  ;", "assertEquals ( hasMap . getProps (  )  . getClass (  )  ,    Properties . class )  ;", "}", "METHOD_END"], "methodName": ["testEmptyProps"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" emptySet \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getSet (  )  . size (  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptySet"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "Set   set    =     (  ( Set )     ( this . beanFactory . getBean (  \" enumSetFactory \"  )  )  )  ;", "assertTrue (  (  ( set . size (  )  )     =  =     2  )  )  ;", "assertTrue ( set . contains (  \" ONE \"  )  )  ;", "assertTrue ( set . contains (  \" TWO \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnumSetFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" integerArray \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getIntegerArray (  )  . length )     =  =     3  )  )  ;", "assertTrue (  (  ( hasMap . getIntegerArray (  )  [  0  ]  . intValue (  )  )     =  =     0  )  )  ;", "assertTrue (  (  ( hasMap . getIntegerArray (  )  [  1  ]  . intValue (  )  )     =  =     1  )  )  ;", "assertTrue (  (  ( hasMap . getIntegerArray (  )  [  2  ]  . intValue (  )  )     =  =     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIntegerArray"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . beanFgetBean (  \" jumble 2  \"  )  ;", "fail (  \" Should   have   thrown   BeanCreationException \"  )  ;", "}    catch    ( BeanCreationException   ex )     {", "assertTrue (  (  ( ex . getCause (  )  )    instanceof   BeanDefinitionStoreException )  )  ;", "assertTrue ( ex . getCause (  )  . getMessage (  )  . contains (  \" rod 2  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInvalidBeanNameReference"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "List   list    =     (  ( List )     ( this . beanFactory . getBean (  \" listFactory \"  )  )  )  ;", "assertTrue (  ( list   instanceof   LinkedList )  )  ;", "assertTrue (  (  ( list . size (  )  )     =  =     2  )  )  ;", "assertEquals (  \" bar \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" jenny \"  ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testListFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" mapFactory \"  )  )  )  ;", "assertTrue (  ( map   instanceof   TreeMap )  )  ;", "assertTrue (  (  ( map . size (  )  )     =  =     2  )  )  ;", "assertEquals (  \" bar \"  ,    map . get (  \" foo \"  )  )  ;", "assertEquals (  \" jenny \"  ,    map . get (  \" jen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   jenny    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" pJenny \"  )  )  )  ;", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" pMixedMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" jenny \"  )  . toString (  )  . equals ( jenny . toString (  )  )  )  ;", "assertTrue (  \" Not   same   instance \"  ,     (  ( hasMap . getMap (  )  . get (  \" jenny \"  )  )     !  =    jenny )  )  ;", "HasMap   hasMap 2     =     (  ( HasMap )     ( this . beanFactory . getBean (  \" pMixedMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap 2  . getMap (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue ( hasMap 2  . getMap (  )  . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue ( hasMap 2  . getMap (  )  . get (  \" jenny \"  )  . toString (  )  . equals ( jenny . toString (  )  )  )  ;", "assertTrue (  \" Not   same   instance \"  ,     (  ( hasMap 2  . getMap (  )  . get (  \" jenny \"  )  )     !  =     ( hasMap . getMap (  )  . get (  \" jenny \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithLiteralsAndPrototypeReferences"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" mixedMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . size (  )  )     =  =     5  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" foo \"  )  . equals ( new   Integer (  1  0  )  )  )  ;", "TestBean   jenny    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . get (  \" jenny \"  )  )     =  =    jenny )  )  ;", "assertTrue ( hasMap . getMap (  )  . get ( new   Integer (  5  )  )  . equals (  \" david \"  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . get (  \" bar \"  )  )    instanceof   Long )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" bar \"  )  . equals ( new   Long (  1  0  0  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . get (  \" baz \"  )  )    instanceof   Integer )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" baz \"  )  . equals ( new   Integer (  2  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithLiteralsAndReferences"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" literalMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" fi \"  )  . equals (  \" fum \"  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . get (  \" fa \"  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithLiteralsOnly"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" mixedMapWithList \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getMap (  )  . size (  )  )     =  =     4  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get ( null )  . equals (  \" bar \"  )  )  ;", "TestBean   jenny    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "assertTrue ( hasMap . getMap (  )  . get (  \" jenny \"  )  . equals ( jenny )  )  ;", "List   l    =     (  ( List )     ( hasMap . getMap (  )  . get (  \" list \"  )  )  )  ;", "assertNotNull ( l )  ;", "assertTrue (  (  ( l . size (  )  )     =  =     4  )  )  ;", "assertTrue ( l . get (  0  )  . equals (  \" zero \"  )  )  ;", "assertTrue (  (  ( l . get (  3  )  )     =  =    null )  )  ;", "Map   m    =     (  ( Map )     ( l . get (  1  )  )  )  ;", "assertNotNull ( m )  ;", "assertTrue (  (  ( m . size (  )  )     =  =     2  )  )  ;", "assertTrue ( m . get (  \" fo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  (  \" Map   element    ' jenny '    should   be   equal   to   jenny   bean ,    not    \"     +     ( m . get (  \" jen \"  )  )  )  ,    m . get (  \" jen \"  )  . equals ( jenny )  )  ;", "l    =     (  ( List )     ( l . get (  2  )  )  )  ;", "assertNotNull ( l )  ;", "assertTrue (  (  ( l . size (  )  )     =  =     2  )  )  ;", "assertTrue ( l . get (  0  )  . equals ( jenny )  )  ;", "assertTrue ( l . get (  1  )  . equals (  \" ba \"  )  )  ;", "m    =     (  ( Map )     ( hasMap . getMap (  )  . get (  \" map \"  )  )  )  ;", "assertNotNull ( m )  ;", "assertTrue (  (  ( m . size (  )  )     =  =     2  )  )  ;", "assertTrue ( m . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  (  \" Map   element    ' jenny '    should   be   equal   to   jenny   bean ,    not    \"     +     ( m . get (  \" jenny \"  )  )  )  ,    m . get (  \" jenny \"  )  . equals ( jenny )  )  ;", "}", "METHOD_END"], "methodName": ["testMapWithLiteralsReferencesAndList"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" objectArray \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getObjectArray (  )  . length )     =  =     2  )  )  ;", "assertTrue ( hasMap . getObjectArray (  )  [  0  ]  . equals (  \" one \"  )  )  ;", "assertTrue ( hasMap . getObjectArray (  )  [  1  ]  . equals ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testObjectArray"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" concurrentSet \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getConcurrentSet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue ( hasMap . getConcurrentSet (  )  . contains (  \" bar \"  )  )  ;", "TestBean   jenny    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "assertTrue ( hasMap . getConcurrentSet (  )  . contains ( jenny )  )  ;", "assertTrue ( hasMap . getConcurrentSet (  )  . contains ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedConcurrentSet"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" identityMap \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getIdentityMap (  )  . size (  )  )     =  =     2  )  )  ;", "HashSet   set    =    new   HashSet ( hasMap . getIdentityMap (  )  . keySet (  )  )  ;", "assertTrue ( set . contains (  \" foo \"  )  )  ;", "assertTrue ( set . contains (  \" jenny \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedIdentityMap"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" props \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getProps (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue ( hasMap . getProps (  )  . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue ( hasMap . getProps (  )  . get (  \"  2  \"  )  . equals (  \" TWO \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedProps"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" set \"  )  )  )  ;", "assertTrue (  (  ( hasMap . getSet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue ( hasMap . getSet (  )  . contains (  \" bar \"  )  )  ;", "TestBean   jenny    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "assertTrue ( hasMap . getSet (  )  . contains ( jenny )  )  ;", "assertTrue ( hasMap . getSet (  )  . contains ( null )  )  ;", "Iterator   it    =    hasMap . getSet (  )  . iterator (  )  ;", "assertEquals (  \" bar \"  ,    it . next (  )  )  ;", "assertEquals ( jenny ,    it . next (  )  )  ;", "assertEquals ( null ,    it . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPopulatedSet"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   verbose    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" verbose 3  \"  )  )  )  ;", "assertTrue ( verbose . getName (  )  . equals (  \" verbose \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyWithIdRefBeanAttrSubelement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   verbose    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" verbose 2  \"  )  )  )  ;", "assertTrue ( verbose . getName (  )  . equals (  \" verbose \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyWithIdRefLocalAttrSubelement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   verbose    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" verbose \"  )  )  )  ;", "assertTrue ( verbose . getName (  )  . equals (  \" verbose \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyWithLiteralValueSubelement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "HasMap   hasMap    =     (  ( HasMap )     ( this . beanFactory . getBean (  \" props \"  )  )  )  ;", "assertEquals (  2  ,    hasMap . getProps (  )  . size (  )  )  ;", "assertEquals (  \" bar \"  ,    hasMap . getProps (  )  . getProperty (  \" foo \"  )  )  ;", "assertEquals (  \" TWO \"  ,    hasMap . getProps (  )  . getProperty (  \"  2  \"  )  )  ;", "HasMap   hasMap 2     =     (  ( HasMap )     ( this . beanFactory . getBean (  \" propsViaMap \"  )  )  )  ;", "assertEquals (  2  ,    hasMap 2  . getProps (  )  . size (  )  )  ;", "assertEquals (  \" bar \"  ,    hasMap 2  . getProps (  )  . getProperty (  \" foo \"  )  )  ;", "assertEquals (  \" TWO \"  ,    hasMap 2  . getProps (  )  . getProperty (  \"  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testProps"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "List   list    =     (  ( List )     ( this . beanFactory . getBean (  \" pListFactory \"  )  )  )  ;", "assertTrue (  ( list   instanceof   LinkedList )  )  ;", "assertTrue (  (  ( list . size (  )  )     =  =     2  )  )  ;", "assertEquals (  \" bar \"  ,    list . get (  0  )  )  ;", "assertEquals (  \" jenny \"  ,    list . get (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeListFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "Map   map    =     (  ( Map )     ( this . beanFactory . getBean (  \" pMapFactory \"  )  )  )  ;", "assertTrue (  ( map   instanceof   TreeMap )  )  ;", "assertTrue (  (  ( map . size (  )  )     =  =     2  )  )  ;", "assertEquals (  \" bar \"  ,    map . get (  \" foo \"  )  )  ;", "assertEquals (  \" jenny \"  ,    map . get (  \" jen \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeMapFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "Set   set    =     (  ( Set )     ( this . beanFactory . getBean (  \" pSetFactory \"  )  )  )  ;", "assertTrue (  ( set   instanceof   TreeSet )  )  ;", "assertTrue (  (  ( set . size (  )  )     =  =     2  )  )  ;", "assertTrue ( set . contains (  \" bar \"  )  )  ;", "assertTrue ( set . contains (  \" jenny \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testPrototypeSetFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   jen    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "TestBean   dave    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" david \"  )  )  )  ;", "assertTrue (  (  ( jen . getSpouse (  )  )     =  =    dave )  )  ;", "}", "METHOD_END"], "methodName": ["testRefSubelement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   jen    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" jenny \"  )  )  )  ;", "TestBean   dave    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" david \"  )  )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" rod \"  )  )  )  ;", "Object [  ]    friends    =    rod . getFriends (  )  . toArray (  )  ;", "assertTrue (  (  ( friends . length )     =  =     2  )  )  ;", "assertTrue (  (  \" First   friend   must   be   jen ,    not    \"     +     ( friends [  0  ]  )  )  ,     (  ( friends [  0  ]  )     =  =    jen )  )  ;", "assertTrue (  (  ( friends [  1  ]  )     =  =    dave )  )  ;", "}", "METHOD_END"], "methodName": ["testRefSubelementsBuildCollection"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   loner    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" loner \"  )  )  )  ;", "TestBean   dave    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" david \"  )  )  )  ;", "assertTrue (  (  ( loner . getFriends (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue ( loner . getFriends (  )  . contains ( dave )  )  ;", "}", "METHOD_END"], "methodName": ["testRefSubelementsBuildCollectionFromSingleElement"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   jen    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" pJenny \"  )  )  )  ;", "TestBean   dave    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" pDavid \"  )  )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( this . beanFactory . getBean (  \" pRod \"  )  )  )  ;", "Object [  ]    friends    =    rod . getFriends (  )  . toArray (  )  ;", "assertTrue (  (  ( friends . length )     =  =     2  )  )  ;", "assertTrue (  (  \" First   friend   must   be   jen ,    not    \"     +     ( friends [  0  ]  )  )  ,    friends [  0  ]  . toString (  )  . equals ( jen . toString (  )  )  )  ;", "assertTrue (  \" Jen   not   same   instance \"  ,     (  ( friends [  0  ]  )     !  =    jen )  )  ;", "assertTrue ( friends [  1  ]  . toString (  )  . equals ( dave . toString (  )  )  )  ;", "assertTrue (  \" Dave   not   same   instance \"  ,     (  ( friends [  1  ]  )     !  =    dave )  )  ;", "assertEquals (  \" Jen \"  ,    dave . getSpouse (  )  . getName (  )  )  ;", "TestBean   rod 2     =     (  ( TestBean )     ( this . beanFactory . getBean (  \" pRod \"  )  )  )  ;", "Object [  ]    friends 2     =    rod 2  . getFriends (  )  . toArray (  )  ;", "assertTrue (  (  ( friends 2  . length )     =  =     2  )  )  ;", "assertTrue (  (  \" First   friend   must   be   jen ,    not    \"     +     ( friends 2  [  0  ]  )  )  ,    friends 2  [  0  ]  . toString (  )  . equals ( jen . toString (  )  )  )  ;", "assertTrue (  \" Jen   not   same   instance \"  ,     (  ( friends 2  [  0  ]  )     !  =     ( friends [  0  ]  )  )  )  ;", "assertTrue ( friends 2  [  1  ]  . toString (  )  . equals ( dave . toString (  )  )  )  ;", "assertTrue (  \" Dave   not   same   instance \"  ,     (  ( friends 2  [  1  ]  )     !  =     ( friends [  1  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRefSubelementsBuildCollectionWithPrototypes"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "Set   set    =     (  ( Set )     ( this . beanFactory . getBean (  \" setFactory \"  )  )  )  ;", "assertTrue (  ( set   instanceof   TreeSet )  )  ;", "assertTrue (  (  ( set . size (  )  )     =  =     2  )  )  ;", "assertTrue ( set . contains (  \" bar \"  )  )  ;", "assertTrue ( set . contains (  \" jenny \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetFactory"], "fileName": "org.springframework.beans.factory.xml.XmlBeanCollectionTests"}, {"methodBody": ["METHOD_START", "{", "return   BeanDefinitionDocumentReader . class . cast ( BeanUtils . instantiateClass ( this . documentReaderClass )  )  ;", "}", "METHOD_END"], "methodName": ["createBeanDefinitionDocumentReader"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   cl    =     (  ( getResourceLoader (  )  )     !  =    null )     ?    getResourceLoader (  )  . getClassLoader (  )     :    getBeanClassLoader (  )  ;", "return   new   DefaultNamespaceHandlerResolver ( cl )  ;", "}", "METHOD_END"], "methodName": ["createDefaultNamespaceHandlerResolver"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   new   XmlReaderContext ( resource ,    this . problemReporter ,    this . eventListener ,    this . sourceExtractor ,    this ,    getNamespaceHandlerResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["createReaderContext"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    ( resource . isOpen (  )  )     {", "throw   new   BeanDefinitionStoreException (  (  (  (  (  (  \" Passed - in   Resource    [  \"     +    resource )     +     \"  ]    contains   an   open   stream :     \"  )     +     \" cannot   determine   validation   mode   automatically .    Either   pass   in   a   Resource    \"  )     +     \" that   is   able   to   create   fresh   streams ,    or   explicitly   specify   the   validationMode    \"  )     +     \" on   your      instance .  \"  )  )  ;", "}", "InputStream   inputStream ;", "try    {", "inputStream    =    resource . getInputStream (  )  ;", "}    catch    ( IOException   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  (  (  \" Unable   to   determine   validation   mode   for    [  \"     +    resource )     +     \"  ]  :    cannot   open   InputStream .     \"  )     +     \" Did   you   attempt   to   load   directly   from   a   SAX   InputSource   without   specifying   the    \"  )     +     \" validationMode   on   your      instance ?  \"  )  ,    ex )  ;", "}", "try    {", "return   this . validationModeDetector . detectValidationMode ( inputStream )  ;", "}    catch    ( IOException   ex )     {", "throw   new   BeanDefinitionStoreException (  (  (  \" Unable   to   determine   validation   mode   for    [  \"     +    resource )     +     \"  ]  :    an   error   occurred   whilst   reading   from   the   InputStream .  \"  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["detectValidationMode"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "try    {", "Document   doc    =    doLoadDocument ( inputSource ,    resource )  ;", "return   registerBeanDefinitions ( doc ,    resource )  ;", "}    catch    ( BeanDefinitionStoreException   ex )     {", "throw   ex ;", "}    catch    ( SAXParseException   ex )     {", "throw   new   StoreException ( resource . getDescription (  )  ,     (  (  (  (  \" Line    \"     +     ( ex . getLineNumber (  )  )  )     +     \"    in   XML   document   from    \"  )     +    resource )     +     \"    is   invalid \"  )  ,    ex )  ;", "}    catch    ( SAXException   ex )     {", "throw   new   StoreException ( resource . getDescription (  )  ,     (  (  \" XML   document   from    \"     +    resource )     +     \"    is   invalid \"  )  ,    ex )  ;", "}    catch    ( ParserConfigurationException   ex )     {", "throw   new   BeanDefinitionStoreException ( resource . getDescription (  )  ,     (  \" Parser   configuration   exception   parsing   XML   from    \"     +    resource )  ,    ex )  ;", "}    catch    ( IOException   ex )     {", "throw   new   BeanDefinitionStoreException ( resource . getDescription (  )  ,     (  \" IOException   parsing   XML   document   from    \"     +    resource )  ,    ex )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   BeanDefinitionStoreException ( resource . getDescription (  )  ,     (  \" Unexpected   exception   parsing   XML   document   from    \"     +    resource )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["doLoadBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . documentLoader . loadDocument ( inputSource ,    getEntityResolver (  )  ,    this . errorHandler ,    getValidationModeForResource ( resource )  ,    isNamespaceAware (  )  )  ;", "}", "METHOD_END"], "methodName": ["doLoadDocument"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . entityResolver )     =  =    null )     {", "ResourceLo   resourceLo    =    getResourceLo (  )  ;", "if    ( resourceLo    !  =    null )     {", "this . entityResolver    =    new   ResourceEntityResolver ( resourceLo )  ;", "} else    {", "this . entityResolver    =    new   DelegatingEntityResolver ( getBeanClassLo (  )  )  ;", "}", "}", "return   this . entityResolver ;", "}", "METHOD_END"], "methodName": ["getEntityResolver"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . namespaceHandlerResolver )     =  =    null )     {", "this . namespaceHandlerResolver    =    createDefaultNamespaceHandlerResolver (  )  ;", "}", "return   this . namespaceHandlerResolver ;", "}", "METHOD_END"], "methodName": ["getNamespaceHandlerResolver"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . validationMode ;", "}", "METHOD_END"], "methodName": ["getValidationMode"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "int   validationModeToUse    =    getValidationMode (  )  ;", "if    ( validationModeToUse    !  =     (  . VALIDATION _ AUTO )  )     {", "return   validationModeToUse ;", "}", "int   detectedMode    =    detectValidationMode ( resource )  ;", "if    ( detectedMode    !  =     (  . VALIDATION _ AUTO )  )     {", "return   detectedMode ;", "}", "return    . VALIDATION _ XSD ;", "}", "METHOD_END"], "methodName": ["getValidationModeForResource"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   this . namespaceAware ;", "}", "METHOD_END"], "methodName": ["isNamespaceAware"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( encodedResource ,     \" EncodedResource   must   not   be   null \"  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  (  \" Loading   XML   bean   definitions   from    \"     +     ( encodedResource . getResource (  )  )  )  )  ;", "}", "Set < EncodedResource >    currentResources    =    this . resourcesCurrentlyBeingLoaded . get (  )  ;", "if    ( currentResources    =  =    null )     {", "currentResources    =    new   HashSet (  4  )  ;", "this . resourcesCurrentlyBeingLoaded . set ( currentResources )  ;", "}", "if    (  !  ( currentResources . add ( encodedResource )  )  )     {", "throw   new   StoreException (  (  (  \" Detected   cyclic   loading   of    \"     +    encodedResource )     +     \"     -    check   your   import   definitions !  \"  )  )  ;", "}", "try    {", "InputStream   inputStream    =    encodedResource . getResource (  )  . getInputStream (  )  ;", "try    {", "InputSource   inputSource    =    new   InputSource ( inputStream )  ;", "if    (  ( encodedResource . getEncoding (  )  )     !  =    null )     {", "inputSource . setEncoding ( encodedResource . getEncoding (  )  )  ;", "}", "return   doLoads ( inputSource ,    encodedResource . getResource (  )  )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "}    catch    ( IOException   ex )     {", "throw   new   StoreException (  (  \" IOException   parsing   XML   document   from    \"     +     ( encodedResource . getResource (  )  )  )  ,    ex )  ;", "}    finally    {", "currentResources . remove ( encodedResource )  ;", "if    ( currentResources . isEmpty (  )  )     {", "this . resourcesCurrentlyBeingLoaded . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   loadBeanDefinitions ( inputSource ,     \" resource   loaded   through   SAX   InputSource \"  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "return   doLoadBeanDefinitions ( inputSource ,    new   DescriptiveResource ( resourceDescription )  )  ;", "}", "METHOD_END"], "methodName": ["loadBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "BeanDefinitionDocumentReader   documentReader    =    createBeanDefinitionDocumentReader (  )  ;", "int   countBefore    =    getRegistry (  )  . getBeanDefinitionCount (  )  ;", "documentReader . registerBeanDefinitions ( doc ,    createReaderContext ( resource )  )  ;", "return    ( getRegistry (  )  . getBeanDefinitionCount (  )  )     -    countBefore ;", "}", "METHOD_END"], "methodName": ["registerBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . documentLoader    =     ( documentLoader    !  =    null )     ?    documentLoader    :    new   DefaultDocumentLoader (  )  ;", "}", "METHOD_END"], "methodName": ["setDocumentLoader"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . documentReaderClass    =    documentReaderClass ;", "}", "METHOD_END"], "methodName": ["setDocumentReaderClass"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . entityResolver    =    entityResolver ;", "}", "METHOD_END"], "methodName": ["setEntityResolver"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . errorHandler    =    errorHandler ;", "}", "METHOD_END"], "methodName": ["setErrorHandler"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . eventListener    =     ( eventListener    !  =    null )     ?    eventListener    :    new   EmptyReaderEventListener (  )  ;", "}", "METHOD_END"], "methodName": ["setEventListener"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . namespaceAware    =    namespaceAware ;", "}", "METHOD_END"], "methodName": ["setNamespaceAware"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . namespaceHandlerResolver    =    namespaceHandlerResolver ;", "}", "METHOD_END"], "methodName": ["setNamespaceHandlerResolver"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . problemReporter    =     ( problemReporter    !  =    null )     ?    problemReporter    :    new   FailFastProblemReporter (  )  ;", "}", "METHOD_END"], "methodName": ["setProblemReporter"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . sourceExtractor    =     ( sourceExtractor    !  =    null )     ?    sourceExtractor    :    new   NullSourceExtractor (  )  ;", "}", "METHOD_END"], "methodName": ["setSourceExtractor"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . validationMode    =     ( validating )     ?    XmlBeanDefinitionReader . VALIDATION _ AUTO    :    XmlBeanDefinitionReader . VALIDATION _ NONE ;", "this . namespaceAware    =     ! validating ;", "}", "METHOD_END"], "methodName": ["setValidating"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "this . validationMode    =    validationMode ;", "}", "METHOD_END"], "methodName": ["setValidationMode"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "setValidationMode ( XmlBeanDefinitionReader . constants . asNumber ( validationModeName )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["setValidationModeName"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader"}, {"methodBody": ["METHOD_START", "{", "DefaultListableBeanFactory   factory    =    new   DefaultListableBeanFactory (  )  ;", "Resource   resource    =    new   ClassPathResource ( resourceName ,    getClass (  )  )  ;", "new    ( factory )  . loadBeanDefinitions ( resource )  ;", "TestBean   bean    =     (  ( TestBean )     ( factory . getBean (  \" testBean \"  )  )  )  ;", "assertNotNull ( bean )  ;", "}", "METHOD_END"], "methodName": ["doTestValidation"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "doTestValidation (  \" validateWithDtd . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["dtdValidationAutodetect"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "new    ( registry )  . setDocumentReaderClass ( DefaultBeanDefinitionDocumentReader . class )  ;", "}", "METHOD_END"], "methodName": ["setParserClassSunnyDay"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  2  4  ,    registry . getBeanDefinitionCount (  )  )  ;", "assertEquals (  2  4  ,    registry . getBeanDefinitionNames (  )  . length )  ;", "assertTrue ( Arrays . asList ( registry . getBeanDefinitionNames (  )  )  . contains (  \" rod \"  )  )  ;", "assertTrue ( Arrays . asList ( registry . getBeanDefinitionNames (  )  )  . contains (  \" aliased \"  )  )  ;", "assertTrue ( registry . containsBeanDefinition (  \" rod \"  )  )  ;", "assertTrue ( registry . containsBeanDefinition (  \" aliased \"  )  )  ;", "assertEquals ( TestBean . class . getName (  )  ,    registry . getBeanDefinition (  \" rod \"  )  . getBeanClassName (  )  )  ;", "assertEquals ( TestBean . class . getName (  )  ,    registry . getBeanDefinition (  \" aliased \"  )  . getBeanClassName (  )  )  ;", "assertTrue ( registry . isAlias (  \" youralias \"  )  )  ;", "String [  ]    aliases    =    registry . getAliases (  \" aliased \"  )  ;", "assertEquals (  2  ,    aliases . length )  ;", "assertTrue ( ObjectUtils . containsElement ( aliases ,     \" myalias \"  )  )  ;", "assertTrue ( ObjectUtils . containsElement ( aliases ,     \" youralias \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBeanDefinitions"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "Resource   resource    =    new   ClassPathResource (  \" test . xml \"  ,    getClass (  )  )  ;", "new    ( registry )  . loadBeanDefinitions ( resource )  ;", "testBeanDefinitions ( registry )  ;", "}", "METHOD_END"], "methodName": ["withFreshInputStream"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "Resource   resource    =    new   ClassPathResource (  \" import . xml \"  ,    getClass (  )  )  ;", "new    ( registry )  . loadBeanDefinitions ( resource )  ;", "testBeanDefinitions ( registry )  ;", "}", "METHOD_END"], "methodName": ["withImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "InputSource   resource    =    new   InputSource ( getClass (  )  . getResourceAsStream (  \" test . xml \"  )  )  ;", "new    ( registry )  . loadBeanDefinitions ( resource )  ;", "}", "METHOD_END"], "methodName": ["withInputSource"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "InputSource   resource    =    new   InputSource ( getClass (  )  . getResourceAsStream (  \" test . xml \"  )  )  ;", "reader    =    new    ( registry )  ;", "reader . setValidationMode (  . VALIDATION _ DTD )  ;", "reader . loadBeanDefinitions ( resource )  ;", "testBeanDefinitions ( registry )  ;", "}", "METHOD_END"], "methodName": ["withInputSourceAndExplicitValidationMode"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "Resource   resource    =    new   InputStreamResource ( getClass (  )  . getResourceAsStream (  \" test . xml \"  )  )  ;", "new    ( registry )  . loadBeanDefinitions ( resource )  ;", "}", "METHOD_END"], "methodName": ["withOpenInputStream"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "Resource   resource    =    new   InputStreamResource ( getClass (  )  . getResourceAsStream (  \" test . xml \"  )  )  ;", "reader    =    new    ( registry )  ;", "reader . setValidationMode (  . VALIDATION _ DTD )  ;", "reader . loadBeanDefinitions ( resource )  ;", "testBeanDefinitions ( registry )  ;", "}", "METHOD_END"], "methodName": ["withOpenInputStreamAndExplicitValidationMode"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "SimpleBeanDefinitionRegistry   registry    =    new   SimpleBeanDefinitionRegistry (  )  ;", "Resource   resource    =    new   ClassPathResource (  \" importPattern . xml \"  ,    getClass (  )  )  ;", "new    ( registry )  . loadBeanDefinitions ( resource )  ;", "testBeanDefinitions ( registry )  ;", "}", "METHOD_END"], "methodName": ["withWildcardImport"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "doTestValidation (  \" validateWithXsd . xml \"  )  ;", "}", "METHOD_END"], "methodName": ["xsdValidationAutodetect"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionReaderTests"}, {"methodBody": ["METHOD_START", "{", "Throwable   cause    =    getCause (  )  ;", "if    ( cause   instanceof   SAXPars )     {", "return    (  ( SAXPars )     ( cause )  )  . getLineNumber (  )  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException"}, {"methodBody": ["METHOD_START", "{", "List   beanNames    =    Arrays . asList ( getListableBeanFactory (  )  . getBeanDefinitionNames (  )  )  ;", "TestBean   tb 1     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" aliased \"  )  )  )  ;", "TestBean   alias 1     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" myalias \"  )  )  )  ;", "assertTrue (  ( tb 1     =  =    alias 1  )  )  ;", "List   tb 1 Aliases    =    Arrays . asList ( getBeanFactory (  )  . getAliases (  \" aliased \"  )  )  ;", "assertEquals (  2  ,    tb 1 Aliases . size (  )  )  ;", "assertTrue ( tb 1 Aliases . contains (  \" myalias \"  )  )  ;", "assertTrue ( tb 1 Aliases . contains (  \" youralias \"  )  )  ;", "assertTrue ( beanNames . contains (  \" aliased \"  )  )  ;", "assertFalse ( beanNames . contains (  \" myalias \"  )  )  ;", "assertFalse ( beanNames . contains (  \" youralias \"  )  )  ;", "TestBean   tb 2     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" multiAliased \"  )  )  )  ;", "TestBean   alias 2     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" alias 1  \"  )  )  )  ;", "TestBean   alias 3     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" alias 2  \"  )  )  )  ;", "TestBean   alias 3 a    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" alias 3  \"  )  )  )  ;", "TestBean   alias 3 b    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" alias 4  \"  )  )  )  ;", "assertTrue (  ( tb 2     =  =    alias 2  )  )  ;", "assertTrue (  ( tb 2     =  =    alias 3  )  )  ;", "assertTrue (  ( tb 2     =  =    alias 3 a )  )  ;", "assertTrue (  ( tb 2     =  =    alias 3 b )  )  ;", "List   tb 2 Aliases    =    Arrays . asList ( getBeanFactory (  )  . getAliases (  \" multiAliased \"  )  )  ;", "assertEquals (  4  ,    tb 2 Aliases . size (  )  )  ;", "assertTrue ( tb 2 Aliases . contains (  \" alias 1  \"  )  )  ;", "assertTrue ( tb 2 Aliases . contains (  \" alias 2  \"  )  )  ;", "assertTrue ( tb 2 Aliases . contains (  \" alias 3  \"  )  )  ;", "assertTrue ( tb 2 Aliases . contains (  \" alias 4  \"  )  )  ;", "assertTrue ( beanNames . contains (  \" multiAliased \"  )  )  ;", "assertFalse ( beanNames . contains (  \" alias 1  \"  )  )  ;", "assertFalse ( beanNames . contains (  \" alias 2  \"  )  )  ;", "assertFalse ( beanNames . contains (  \" alias 3  \"  )  )  ;", "assertFalse ( beanNames . contains (  \" alias 4  \"  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" aliasWithoutId 1  \"  )  )  )  ;", "TestBean   alias 4     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" aliasWithoutId 2  \"  )  )  )  ;", "TestBean   alias 5     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" aliasWithoutId 3  \"  )  )  )  ;", "assertTrue (  ( tb 3     =  =    alias 4  )  )  ;", "assertTrue (  ( tb 3     =  =    alias 5  )  )  ;", "List   tb 3 Aliases    =    Arrays . asList ( getBeanFactory (  )  . getAliases (  \" aliasWithoutId 1  \"  )  )  ;", "assertEquals (  2  ,    tb 3 Aliases . size (  )  )  ;", "assertTrue ( tb 3 Aliases . contains (  \" aliasWithoutId 2  \"  )  )  ;", "assertTrue ( tb 3 Aliases . contains (  \" aliasWithoutId 3  \"  )  )  ;", "assertTrue ( beanNames . contains (  \" aliasWithoutId 1  \"  )  )  ;", "assertFalse ( beanNames . contains (  \" aliasWithoutId 2  \"  )  )  ;", "assertFalse ( beanNames . contains (  \" aliasWithoutId 3  \"  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  (  ( TestBean . class . getName (  )  )     +     \"  #  0  \"  )  )  )  )  ;", "assertEquals ( null ,    tb 4  . getName (  )  )  ;", "Map   drs    =    getListableBeanFactory (  )  . getBeansOfType ( DummyReferencer . class ,    false ,    false )  ;", "assertEquals (  5  ,    drs . size (  )  )  ;", "assertTrue ( drs . containsKey (  (  ( DummyReferencer . class . getName (  )  )     +     \"  #  0  \"  )  )  )  ;", "assertTrue ( drs . containsKey (  (  ( DummyReferencer . class . getName (  )  )     +     \"  #  1  \"  )  )  )  ;", "assertTrue ( drs . containsKey (  (  ( DummyReferencer . class . getName (  )  )     +     \"  #  2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["autoAliasing"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "assertTestBeanCount (  1  3  )  ;", "}", "METHOD_END"], "methodName": ["beanCount"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   kerry    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" kerry \"  )  )  )  ;", "TestBean   kathy    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" kathy \"  )  )  )  ;", "DummyFactory   factory    =     (  ( DummyFactory )     ( getBeanFactory (  )  . getBean (  \"  & singletonFactory \"  )  )  )  ;", "TestBean   factoryCreated    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" singletonFactory \"  )  )  )  ;", "assertTrue ( kerry . isPostProcessed (  )  )  ;", "assertTrue ( kathy . isPostProcessed (  )  )  ;", "assertTrue ( factory . isPostProcessed (  )  )  ;", "assertTrue ( factoryCreated . isPostProcessed (  )  )  ;", "}", "METHOD_END"], "methodName": ["beanPostProcessor"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   bean    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" commentsInValue \"  )  )  )  ;", "assertEquals (  \" Failed   to   handle   comments   and   CDATA   properly \"  ,     \" this   is   a    <  !  -  - comment -  -  >  \"  ,    bean . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["commentsAndCdataInValue"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   validEmpty    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" validEmptyWithDescription \"  )  )  )  ;", "assertEquals (  0  ,    validEmpty . getAge (  )  )  ;", "}", "METHOD_END"], "methodName": ["descriptionButNoProperties"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   rod    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" rod \"  )  )  )  ;", "TestBean   kerry    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" kerry \"  )  )  )  ;", "assertTrue (  \" Touchy   is   empty \"  ,     \"  \"  . equals ( rod . getTouchy (  )  )  )  ;", "assertTrue (  \" Touchy   is   empty \"  ,     \"  \"  . equals ( kerry . getTouchy (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyValues"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ITestBean   father    =     (  ( ITestBean )     ( getBeanFactory (  )  . getBean (  \" father \"  )  )  )  ;", "assertTrue (  \" Bean   from   root   context \"  ,     ( father    !  =    null )  )  ;", "TestBean   rod    =     (  ( TestBean )     ( getBeanFactory (  )  . getBean (  \" rod \"  )  )  )  ;", "assertTrue (  \" Bean   from   child   context \"  ,     \" Rod \"  . equals ( rod . getName (  )  )  )  ;", "assertTrue (  \" Bean   has   external   reference \"  ,     (  ( rod . getSpouse (  )  )     =  =    father )  )  ;", "rod    =     (  ( TestBean )     ( parent . getBean (  \" rod \"  )  )  )  ;", "assertTrue (  \" Bean   from   root   context \"  ,     \" Roderick \"  . equals ( rod . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["factoryNesting"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DummyFactory   factory    =     (  ( DummyFactory )     ( getBeanFactory (  )  . getBean (  \"  & singletonFactory \"  )  )  )  ;", "DummyReferencer   ref    =     (  ( DummyReferencer )     ( getBeanFactory (  )  . getBean (  \" factoryReferencer \"  )  )  )  ;", "assertTrue (  (  ( ref . getTestBean 1  (  )  )     =  =     ( ref . getTestBean 2  (  )  )  )  )  ;", "assertTrue (  (  ( ref . getDummyFactory (  )  )     =  =    factory )  )  ;", "DummyReferencer   ref 2     =     (  ( DummyReferencer )     ( getBeanFactory (  )  . getBean (  \" factoryReferencerWithConstructor \"  )  )  )  ;", "assertTrue (  (  ( ref 2  . getTestBean 1  (  )  )     =  =     ( ref 2  . getTestBean 2  (  )  )  )  )  ;", "assertTrue (  (  ( ref 2  . getDummyFactory (  )  )     =  =    factory )  )  ;", "}", "METHOD_END"], "methodName": ["factoryReferences"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "LifecycleBean   bean    =     (  ( LifecycleBean )     ( getBeanFactory (  )  . getBean (  \" lifecycle \"  )  )  )  ;", "bean . businessMethod (  )  ;", "}", "METHOD_END"], "methodName": ["lifecycleMethods"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "ProtectedLifecycleBean   bean    =     (  ( ProtectedLifecycleBean )     ( getBeanFactory (  )  . getBean (  \" protectedLifecycle \"  )  )  )  ;", "bean . businessMethod (  )  ;", "}", "METHOD_END"], "methodName": ["protectedLifecycleMethods"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "DummyReferencer   ref 1     =     (  ( DummyReferencer )     ( getBeanFactory (  )  . getBean (  \" prototypeReferencer \"  )  )  )  ;", "assertTrue (  \" Not   referencing   same   bean   twice \"  ,     (  ( ref 1  . getTestBean 1  (  )  )     !  =     ( ref 1  . getTestBean 2  (  )  )  )  )  ;", "DummyReferencer   ref 2     =     (  ( DummyReferencer )     ( getBeanFactory (  )  . getBean (  \" prototypeReferencer \"  )  )  )  ;", "assertTrue (  \" Not   the   same   referencer \"  ,     ( ref 1     !  =    ref 2  )  )  ;", "assertTrue (  \" Not   referencing   same   bean   twice \"  ,     (  ( ref 2  . getTestBean 1  (  )  )     !  =     ( ref 2  . getTestBean 2  (  )  )  )  )  ;", "assertTrue (  \" Not   referencing   same   bean   twice \"  ,     (  ( ref 1  . getTestBean 1  (  )  )     !  =     ( ref 2  . getTestBean 1  (  )  )  )  )  ;", "assertTrue (  \" Not   referencing   same   bean   twice \"  ,     (  ( ref 1  . getTestBean 2  (  )  )     !  =     ( ref 2  . getTestBean 2  (  )  )  )  )  ;", "assertTrue (  \" Not   referencing   same   bean   twice \"  ,     (  ( ref 1  . getTestBean 1  (  )  )     !  =     ( ref 2  . getTestBean 2  (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["prototypeReferences"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "parent    =    new   DefaultListableBeanFactory (  )  ;", "Map   m    =    new   HashMap (  )  ;", "m . put (  \" name \"  ,     \" Albert \"  )  ;", "RootBeanDefinition   bd 1     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 1  . setPropertyValues ( new   MutablePropertyValues ( m )  )  ;", "parent . registerBeanDefinition (  \" father \"  ,    bd 1  )  ;", "m    =    new   HashMap (  )  ;", "m . put (  \" name \"  ,     \" Roderick \"  )  ;", "RootBeanDefinition   bd 2     =    new   RootBeanDefinition ( TestBean . class )  ;", "bd 2  . setPropertyValues ( new   MutablePropertyValues ( m )  )  ;", "parent . registerBeanDefinition (  \" rod \"  ,    bd 2  )  ;", "this . factory    =    new   DefaultListableBeanFactory ( parent )  ;", "new   XmlBeanDefinitionReader ( this . factory )  . loadBeanDefinitions ( new   ClassPathResource (  \" test . xml \"  ,    getClass (  )  )  )  ;", "this . factory . addBeanPostProcessor ( new   BeanPostProcessor (  )     {", "@ Override", "public   Object   postProcessBeforeInitialization ( Object   bean ,    String   name )    throws   BeansException    {", "if    ( bean   instanceof   TestBean )     {", "(  ( TestBean )     ( bean )  )  . setPostProcessed ( true )  ;", "}", "if    ( bean   instanceof   DummyFactory )     {", "(  ( DummyFactory )     ( bean )  )  . setPostProcessed ( true )  ;", "}", "return   bean ;", "}", "@ Override", "public   Object   postProcessAfterInitialization ( Object   bean ,    String   name )    throws   BeansException    {", "return   bean ;", "}", "}  )  ;", "this . factory . addBeanPostProcessor ( new   LifecycleBean . PostProcessor (  )  )  ;", "this . factory . addBeanPostProcessor ( new   ProtectedLifecycleBean . PostProcessor (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.springframework.beans.factory.xml.XmlListableBeanFactoryTests"}, {"methodBody": ["METHOD_START", "{", "return   this . reader . getBeanNameGenerator (  )  . generateBeanName ( beanDefinition ,    getRegistry (  )  )  ;", "}", "METHOD_END"], "methodName": ["generateBeanName"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader . getBeanClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getBeanClassLoader"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader . getEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . namespaceHandlerResolver ;", "}", "METHOD_END"], "methodName": ["getNamespaceHandlerResolver"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader ;", "}", "METHOD_END"], "methodName": ["getReader"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader . getRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "return   this . reader . getResourceLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "InputSource   is    =    new   InputSource ( new   StringReader ( documentContent )  )  ;", "try    {", "return   this . reader . doLoadDocument ( is ,    getResource (  )  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   BeanDefinitionStoreException (  \" Failed   to   read   XML   document \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["readDocumentFromString"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "String   generatedName    =    generateBeanName ( beanDefinition )  ;", "getRegistry (  )  . registerBeanDefinition ( generatedName ,    beanDefinition )  ;", "return   generatedName ;", "}", "METHOD_END"], "methodName": ["registerWithGeneratedName"], "fileName": "org.springframework.beans.factory.xml.XmlReaderContext"}, {"methodBody": ["METHOD_START", "{", "new   DefaultNamespaceHandlerResolver ( null ,     \"  7  3  8 trbc   bobabloobop 8  7  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNonExistentMappingLocationArgument"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultNamespaceHandlerResolver ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullClassLoaderArgument"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "new   DefaultNamespaceHandlerResolver ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullClassLoaderArgumentAndNullMappingLocationArgument"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   mappingPath    =     \" org / springframework / beans / factory / xml / support / nonExistent . properties \"  ;", "try    {", "new    ( getClass (  )  . getClassLoader (  )  ,    mappingPath )  ;", "}    catch    ( Throwable   ex )     {", "fail (  (  \" Non - existent   handler   classes   must   be   ignored :     \"     +    ex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNonExistentHandlerClass"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "String   mappingPath    =     \" org / springframework / beans / factory / xml / support / invalid . properties \"  ;", "try    {", "new    ( getClass (  )  . getClassLoader (  )  ,    mappingPath )  ;", "fail (  \" Should   not   be   able   to   map   a   class   that   doesn ' t   implement   NamespaceHandler \"  )  ;", "}    catch    ( Throwable   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testResolveInvalidHandler"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "DefaultNamespaceHandlerResolver   resolver    =    new   DefaultNamespaceHandlerResolver ( getClass (  )  . getClassLoader (  )  )  ;", "NamespaceHandler   handler    =    resolver . resolve (  \" http :  /  / www . springframework . org / schema / util \"  )  ;", "assertNotNull (  \" Handler   should   not   be   null .  \"  ,    handler )  ;", "assertEquals (  \" Incorrect   handler   loaded \"  ,    UtilNamespaceHandler . class ,    handler . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolvedMappedHandler"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "DefaultNamespaceHandlerResolver   resolver    =    new   DefaultNamespaceHandlerResolver (  )  ;", "NamespaceHandler   handler    =    resolver . resolve (  \" http :  /  / www . springframework . org / schema / util \"  )  ;", "assertNotNull (  \" Handler   should   not   be   null .  \"  ,    handler )  ;", "assertEquals (  \" Incorrect   handler   loaded \"  ,    UtilNamespaceHandler . class ,    handler . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResolvedMappedHandlerWithNoArgCtor"], "fileName": "org.springframework.beans.factory.xml.support.DefaultNamespaceHandlerResolverTests"}, {"methodBody": ["METHOD_START", "{", "BeanInfoTests . ValueBean   bean    =    new   BeanInfoTests . ValueBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "Integer   value    =    new   Integer (  1  )  ;", "bw . setPropertyValue (  \" value \"  ,    value )  ;", "assertEquals (  \" value   not   set   correctly \"  ,    bean . getValue (  )  ,    value )  ;", "value    =    new   Integer (  2  )  ;", "bw . setPropertyValue (  \" value \"  ,    value . toString (  )  )  ;", "assertEquals (  \" value   not   converted \"  ,    bean . getValue (  )  ,    value )  ;", "bw . setPropertyValue (  \" value \"  ,    null )  ;", "assertNull (  \" value   not   null \"  ,    bean . getValue (  )  )  ;", "bw . setPropertyValue (  \" value \"  ,     \"  \"  )  ;", "assertNull (  \" value   not   converted   to   null \"  ,    bean . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexObject"], "fileName": "org.springframework.beans.propertyeditors.BeanInfoTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    byteEditor . getAsText (  )  )  ;", "byteEditor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    byteEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAsTextReturnsEmptyStringIfValueIsNull"], "fileName": "org.springframework.beans.propertyeditors.ByteArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =     \" Hideous   towns   make   me   throw .  .  .    up \"  ;", "byte . setAsText ( text )  ;", "Object   value    =    byte . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   byte [  ]  )  )  ;", "byte [  ]    bytes    =     (  ( byte [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;     +  + i )     {", "assertEquals (  (  (  \" cyte [  ]    differs   at   index    '  \"     +    i )     +     \"  '  \"  )  ,    text . charAt ( i )  ,    bytes [ i ]  )  ;", "}", "assertEquals ( text ,    byte . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["sunnyDaySetAsText"], "fileName": "org.springframework.beans.propertyeditors.ByteArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \"  ,    charEditor . getAsText (  )  )  ;", "charEditor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    charEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAsTextReturnsEmptyStringIfValueIsNull"], "fileName": "org.springframework.beans.propertyeditors.CharArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   text    =     \" Hideous   towns   make   me   throw .  .  .    up \"  ;", "char . setAsText ( text )  ;", "Object   value    =    char . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   char [  ]  )  )  ;", "char [  ]    chars    =     (  ( char [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( text . length (  )  )  ;     +  + i )     {", "assertEquals (  (  (  \" char [  ]    differs   at   index    '  \"     +    i )     +     \"  '  \"  )  ,    text . charAt ( i )  ,    chars [ i ]  )  ;", "}", "assertEquals ( text ,    char . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["sunnyDaySetAsText"], "fileName": "org.springframework.beans.propertyeditors.CharArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "return    ( sequence . startsWith ( CharacterEditor . UNICODE _ PREFIX )  )     &  &     (  ( sequence . length (  )  )     =  =     ( CharacterEditor . UNICODE _ LENGTH )  )  ;", "}", "METHOD_END"], "methodName": ["isUnicodeCharacterSequence"], "fileName": "org.springframework.beans.propertyeditors.CharacterEditor"}, {"methodBody": ["METHOD_START", "{", "int   code    =    Integer . parseInt ( text . substring ( CharacterEditor . UNICODE _ PREFIX . length (  )  )  ,     1  6  )  ;", "setValue ( Character . valueOf (  (  ( char )     ( code )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setAsUnicode"], "fileName": "org.springframework.beans.propertyeditors.CharacterEditor"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["alwaysCreateNewCollection"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditor"}, {"methodBody": ["METHOD_START", "{", "return   element ;", "}", "METHOD_END"], "methodName": ["convertElement"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( collectionType . isInterface (  )  )  )     {", "try    {", "return   ReflectionUtils . accessibleConstructor ( collectionType )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   instantiate   collection   class :     \"     +     ( collectionType . getName (  )  )  )  ,    ex )  ;", "}", "} else", "if    (  ( class )     =  =    collectionType )     {", "return   new   ArrayList <  >  ( initialCapacity )  ;", "} else", "if    (  ( class )     =  =    collectionType )     {", "return   new   TreeSet <  >  (  )  ;", "} else    {", "return   new   LinkedHashSet <  >  ( initialCapacity )  ;", "}", "}", "METHOD_END"], "methodName": ["createCollection"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditor"}, {"methodBody": ["METHOD_START", "{", "new   CustomCollectionEditor (  (  ( Class )     ( String . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNonCollectionType"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "new   CustomCollectionEditor ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullCollectionType"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomCollectionEditor   editor    =    new   CustomCollectionEditor ( ArrayList . class )  ;", "editor . setValue (  \"  0  ,     1  ,     2  \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   ArrayList )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  \" There   must   be    1    element   in   the   converted   collection \"  ,     1  ,    list . size (  )  )  ;", "assertEquals (  \"  0  ,     1  ,     2  \"  ,    list . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDaySetAsTextYieldsSingleValue"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomCollectionEditor   editor    =    new   CustomCollectionEditor ( ArrayList . class )  ;", "editor . setValue ( new   int [  ]  {     0  ,     1  ,     2     }  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   ArrayList )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "assertEquals (  \" There   must   be    3    elements   in   the   converted   collection \"  ,     3  ,    list . size (  )  )  ;", "assertEquals ( new   Integer (  0  )  ,    list . get (  0  )  )  ;", "assertEquals ( new   Integer (  1  )  ,    list . get (  1  )  )  ;", "assertEquals ( new   Integer (  2  )  ,    list . get (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSunnyDaySetValue"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomCollectionEditor   editor    =    new   CustomCollectionEditor ( Collection . class )  ;", "editor . setValue (  \"  0  ,     1  ,     2  \"  )  ;", "Collection <  ?  >    value    =     (  ( Collection <  ?  >  )     ( editor . getValue (  )  )  )  ;", "assertNotNull ( value )  ;", "assertEquals (  \" There   must   be    1    element   in   the   converted   collection \"  ,     1  ,    value . size (  )  )  ;", "assertEquals (  \"  0  ,     1  ,     2  \"  ,    value . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWhenTargetTypeIsExactlyTheCollectionInterfaceUsesFallbackCollectionType"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomCollectionEditor   editor    =    new   CustomCollectionEditor ( CustomCollectionEditorTests . CollectionTypeWithNoNoArgCtor . class )  ;", "editor . setValue (  \"  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithCollectionTypeThatDoesNotExposeAPublicNoArgCtor"], "fileName": "org.springframework.beans.propertyeditors.CustomCollectionEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   tb    =    new   IndexedTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( TestBean . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean ( text ,     9  9  )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" array \"  ,    new   String [  ]  {     \" a \"  ,     \" b \"     }  )  ;", "assertEquals (  2  ,    tb . getArray (  )  . length )  ;", "assertEquals (  \" a \"  ,    tb . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" b \"  ,    tb . getArray (  )  [  1  ]  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayToArrayConversion"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( String . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  (  \"  -  \"     +    text )     +     \"  -  \"  )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" name \"  ,    new   String [  ]  {     \" a \"  ,     \" b \"     }  )  ;", "assertEquals (  \"  - a , b -  \"  ,    tb . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testArrayToStringConversion"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomEditorTests . PrimitiveArrayBean   bean    =    new   CustomEditorTests . PrimitiveArrayBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . setPropertyValue (  \" byteArray \"  ,     \" myvalue \"  )  ;", "assertEquals (  \" myvalue \"  ,    new   String ( bean . getByteArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testByteArrayPropertyEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomEditorTests . PrimitiveArrayBean   bean    =    new   CustomEditorTests . PrimitiveArrayBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . setPropertyValue (  \" charArray \"  ,     \" myvalue \"  )  ;", "assertEquals (  \" myvalue \"  ,    new   String ( bean . getCharArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharArrayPropertyEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomEditorTests . CharBean   cb    =    new   CustomEditorTests . CharBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( cb )  ;", "bw . setPropertyValue (  \" myChar \"  ,    new   Character (  ' c '  )  )  ;", "assertEquals (  ' c '  ,    cb . getMyChar (  )  )  ;", "bw . setPropertyValue (  \" myChar \"  ,     \" c \"  )  ;", "assertEquals (  ' c '  ,    cb . getMyChar (  )  )  ;", "bw . setPropertyValue (  \" myChar \"  ,     \" A \"  )  ;", "assertEquals (  ' A '  ,    cb . getMyChar (  )  )  ;", "bw . setPropertyValue (  \" myChar \"  ,     \"  \\  \\ u 0  0  2  2  \"  )  ;", "assertEquals (  '  \"  '  ,    cb . getMyChar (  )  )  ;", "CharacterEditor   editor    =    new   CharacterEditor ( false )  ;", "editor . setAsText (  \" M \"  )  ;", "assertEquals (  \" M \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   charEditor    =    new   CharacterEditor ( false )  ;", "assertEquals (  \"  \"  ,    charEditor . getAsText (  )  )  ;", "charEditor    =    new   CharacterEditor ( true )  ;", "charEditor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    charEditor . getAsText (  )  )  ;", "charEditor . setAsText (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    charEditor . getAsText (  )  )  ;", "charEditor . setAsText (  \"     \"  )  ;", "assertEquals (  \"     \"  ,    charEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEditorGetAsTextReturnsEmptyStringIfValueIsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   charEditor    =    new   CharacterEditor ( false )  ;", "charEditor . setAsText ( null )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEditorSetAsTextWithNullNotAllowingEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   charEditor    =    new   CharacterEditor ( false )  ;", "charEditor . setAsText (  \" ColdWaterCanyon \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEditorSetAsTextWithStringLongerThanOneCharacter"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomEditorTests . CharBean   cb    =    new   CustomEditorTests . CharBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( cb )  ;", "bw . registerCustomEditor ( Character . class ,    new   CharacterEditor ( true )  )  ;", "bw . setPropertyValue (  \" myCharacter \"  ,    new   Character (  ' c '  )  )  ;", "assertEquals ( new   Character (  ' c '  )  ,    cb . getMyCharacter (  )  )  ;", "bw . setPropertyValue (  \" myCharacter \"  ,     \" c \"  )  ;", "assertEquals ( new   Character (  ' c '  )  ,    cb . getMyCharacter (  )  )  ;", "bw . setPropertyValue (  \" myCharacter \"  ,     \" A \"  )  ;", "assertEquals ( new   Character (  ' A '  )  ,    cb . getMyCharacter (  )  )  ;", "bw . setPropertyValue (  \" myCharacter \"  ,     \"     \"  )  ;", "assertEquals ( new   Character (  '     '  )  ,    cb . getMyCharacter (  )  )  ;", "bw . setPropertyValue (  \" myCharacter \"  ,     \"  \"  )  ;", "assertNull ( cb . getMyCharacter (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterEditorWithAllowEmpty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CharsetEditor   editor    =    new   CharsetEditor (  )  ;", "String   name    =     \" UTF -  8  \"  ;", "editor . setAsText ( name )  ;", "Charset   charset    =    Charset . forName ( name )  ;", "assertEquals (  \" Invalid   Charset   conversion \"  ,    charset ,    editor . getValue (  )  )  ;", "editor . setValue ( charset )  ;", "assertEquals (  \" Invalid   Charset   conversion \"  ,    name ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharsetEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "ClassArrayEditor   editor    =    new   ClassArrayEditor (  )  ;", "editor . setAsText (  \"  \"  )  ;", "assertNull ( editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArrayEditorSetAsTextWithEmptyString"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "ClassArrayEditor   editor    =    new   ClassArrayEditor (  )  ;", "editor . setAsText ( null )  ;", "assertNull ( editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArrayEditorSetAsTextWithNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "ClassArrayEditor   editor    =    new   ClassArrayEditor (  )  ;", "editor . setAsText (  \"  \\ n \"  )  ;", "assertNull ( editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArrayEditorSetAsTextWithWhitespaceString"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "ClassArrayEditor   classArrayEditor    =    new   ClassArrayEditor (  )  ;", "classArrayEditor . setAsText (  \" String , HashMap \"  )  ;", "Class <  ?  >  [  ]    classes    =     (  ( Class <  ?  >  [  ]  )     ( classArrayEditor . getValue (  )  )  )  ;", "assertEquals (  2  ,    classes . length )  ;", "assertEquals ( String . class ,    classes [  0  ]  )  ;", "assertEquals ( HashMap . class ,    classes [  1  ]  )  ;", "assertEquals (  \" String , HashMap \"  ,    classArrayEditor . getAsText (  )  )  ;", "classArrayEditor . setAsText ( classArrayEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArrayEditorSunnyDay"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "ClassArrayEditor   classArrayEditor    =    new   ClassArrayEditor (  )  ;", "classArrayEditor . setAsText (  \" String [  ]  , Map [  ]  , int [  ]  , float [  ]  [  ]  [  ]  \"  )  ;", "Class <  ?  >  [  ]    classes    =     (  ( Class <  ?  >  [  ]  )     ( classArrayEditor . getValue (  )  )  )  ;", "assertEquals (  4  ,    classes . length )  ;", "assertEquals ( String [  ]  . class ,    classes [  0  ]  )  ;", "assertEquals ( Map [  ]  . class ,    classes [  1  ]  )  ;", "assertEquals ( int [  ]  . class ,    classes [  2  ]  )  ;", "assertEquals ( float [  ]  [  ]  [  ]  . class ,    classes [  3  ]  )  ;", "assertEquals (  \" String [  ]  , Map [  ]  , int [  ]  , float [  ]  [  ]  [  ]  \"  ,    classArrayEditor . getAsText (  )  )  ;", "classArrayEditor . setAsText ( classArrayEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassArrayEditorSunnyDayWithArrayTypes"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   classEditor    =    new   ClassEditor (  )  ;", "classEditor . setAsText ( TestBean . class . getName (  )  )  ;", "assertEquals ( TestBean . class ,    classEditor . getValue (  )  )  ;", "assertEquals ( TestBean . class . getName (  )  ,    classEditor . getAsText (  )  )  ;", "classEditor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    classEditor . getAsText (  )  )  ;", "classEditor . setAsText (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    classEditor . getAsText (  )  )  ;", "classEditor . setAsText (  \"  \\ t       \"  )  ;", "assertEquals (  \"  \"  ,    classEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   classEditor    =    new   ClassEditor (  )  ;", "classEditor . setAsText (  \" tests . sample . beans . TestBean [  ]  \"  )  ;", "assertEquals ( TestBean [  ]  . class ,    classEditor . getValue (  )  )  ;", "assertEquals (  \" tests . sample . beans . TestBean [  ]  \"  ,    classEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassEditorWithArray"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   classEditor    =    new   ClassEditor (  )  ;", "classEditor . setAsText (  \" hairdresser . on . Fire \"  )  ;", "}", "METHOD_END"], "methodName": ["testClassEditorWithNonExistentClass"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "String   newName    =     \" Rod \"  ;", "String   tbString    =     \" Kerry _  3  4  \"  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . registerCustomEditor ( ITestBean . class ,    new    . TestBeanEditor (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,    new   Integer (  5  5  )  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,    newName )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" touchy \"  ,     \" valid \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse \"  ,    tbString )  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertTrue (  \" spouse   is   non - null \"  ,     (  ( tb . getSpouse (  )  )     !  =    null )  )  ;", "assertTrue (  \" spouse   name   is   Kerry   and   age   is    3  4  \"  ,     (  ( tb . getSpouse (  )  . getName (  )  . equals (  \" Kerry \"  )  )     &  &     (  ( tb . getSpouse (  )  . getAge (  )  )     =  =     3  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexObject"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "String   newName    =     \" Rod \"  ;", "String   tbString    =     \" Kerry _  3  4  \"  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . setExtractOldValueForEditor ( true )  ;", "bw . registerCustomEditor ( ITestBean . class ,    new    . OldValueAccessingTestBeanEditor (  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" age \"  ,    new   Integer (  5  5  )  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" name \"  ,    newName )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" touchy \"  ,     \" valid \"  )  )  ;", "pvs . addPropertyValue ( new   PropertyValue (  \" spouse \"  ,    tbString )  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertTrue (  \" spouse   is   non - null \"  ,     (  ( tb . getSpouse (  )  )     !  =    null )  )  ;", "assertTrue (  \" spouse   name   is   Kerry   and   age   is    3  4  \"  ,     (  ( tb . getSpouse (  )  . getName (  )  . equals (  \" Kerry \"  )  )     &  &     (  ( tb . getSpouse (  )  . getAge (  )  )     =  =     3  4  )  )  )  ;", "ITestBean   spouse    =    tb . getSpouse (  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertSame (  \" Should   have   remained   same   object \"  ,    spouse ,    tb . getSpouse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testComplexObjectWithOldValueAccess"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomEditorTests . OldCollectionsBean   tb    =    new   CustomEditorTests . OldCollectionsBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . registerCustomEditor ( Vector . class ,    new   CustomCollectionEditor ( Vector . class )  )  ;", "bw . registerCustomEditor ( Hashtable . class ,    new   CustomMapEditor ( Hashtable . class )  )  ;", "bw . setPropertyValue (  \" vector \"  ,    new   String [  ]  {     \" a \"  ,     \" b \"     }  )  ;", "assertEquals (  2  ,    tb . getVector (  )  . size (  )  )  ;", "assertEquals (  \" a \"  ,    tb . getVector (  )  . get (  0  )  )  ;", "assertEquals (  \" b \"  ,    tb . getVector (  )  . get (  1  )  )  ;", "bw . setPropertyValue (  \" hashtable \"  ,    Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  ;", "assertEquals (  1  ,    tb . getHashtable (  )  . size (  )  )  ;", "assertEquals (  \" bar \"  ,    tb . getHashtable (  )  . get (  \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testConversionToOldCollections"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomBooleanEditor   editor    =    new   CustomBooleanEditor ( false )  ;", "editor . setAsText (  \" true \"  )  ;", "assertEquals ( Boolean . TRUE ,    editor . getValue (  )  )  ;", "assertEquals (  \" true \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \" false \"  )  ;", "assertEquals ( Boolean . FALSE ,    editor . getValue (  )  )  ;", "assertEquals (  \" false \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "try    {", "editor . setAsText ( null )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testCustomBooleanEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "BooleanTestBean   tb    =    new   BooleanTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( Boolean . class ,    new   CustomBooleanEditor ( true )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" true \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . TRUE . equals ( bw . getPropertyValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" false \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . FALSE . equals ( bw . getPropertyValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" on \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" off \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" yes \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \" no \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \"  1  \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \"  0  \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPropertyValue (  \" bool 2  \"  ,     \"  \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  ( bw . getPropertyValue (  \" bool 2  \"  )  )     =  =    null )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  ( tb . getBool 2  (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomBooleanEditorWithAllowEmpty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomBooleanEditor   editor    =    new   CustomBooleanEditor ( true )  ;", "editor . setAsText (  \" true \"  )  ;", "assertEquals ( Boolean . TRUE ,    editor . getValue (  )  )  ;", "assertEquals (  \" true \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \" false \"  )  ;", "assertEquals ( Boolean . FALSE ,    editor . getValue (  )  )  ;", "assertEquals (  \" false \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomBooleanEditorWithEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   trueString    =     \" pechorin \"  ;", "String   falseString    =     \" nash \"  ;", "CustomBooleanEditor       =    new   CustomBooleanEditor ( trueString ,    falseString ,    false )  ;", ". setAsText ( trueString )  ;", "assertTrue (  (  ( Boolean )     (  . getValue (  )  )  )  . booleanValue (  )  )  ;", "assertEquals ( trueString ,     . getAsText (  )  )  ;", ". setAsText ( falseString )  ;", "assertFalse (  (  ( Boolean )     (  . getValue (  )  )  )  . booleanValue (  )  )  ;", "assertEquals ( falseString ,     . getAsText (  )  )  ;", ". setAsText ( trueString . toUpperCase (  )  )  ;", "assertTrue (  (  ( Boolean )     (  . getValue (  )  )  )  . booleanValue (  )  )  ;", "assertEquals ( trueString ,     . getAsText (  )  )  ;", ". setAsText ( falseString . toUpperCase (  )  )  ;", "assertFalse (  (  ( Boolean )     (  . getValue (  )  )  )  . booleanValue (  )  )  ;", "assertEquals ( falseString ,     . getAsText (  )  )  ;", "try    {", ". setAsText ( null )  ;", "fail (  \" Should   have   thrown   IllegalArgumentException \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testCustomBooleanEditorWithSpecialTrueAndFalseStrings"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomDateEditor   editor    =    new   CustomDateEditor ( null ,    false )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomDateEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomDateEditor   editor    =    new   CustomDateEditor ( null ,    true )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomDateEditorWithEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "int   maxLength    =     1  0  ;", "String   validDate    =     \"  0  1  /  0  1  /  2  0  0  5  \"  ;", "String   invalidDate    =     \"  0  1  /  0  1  /  0  5  \"  ;", "assertTrue (  (  ( validDate . length (  )  )     =  =    maxLength )  )  ;", "assertFalse (  (  ( invalidDate . length (  )  )     =  =    maxLength )  )  ;", "CustomDateEditor       =    new   CustomDateEditor ( new   SimpleDateFormat (  \" MM / dd / yyyy \"  )  ,    true ,    maxLength )  ;", "try    {", ". setAsText ( validDate )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "fail (  \" Exception   shouldn ' t   be   thrown   because   this   is   a   valid   date \"  )  ;", "}", "try    {", ". setAsText ( invalidDate )  ;", "fail (  \" Exception   should   be   thrown   because   this   is   an   invalid   date \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue ( ex . getMessage (  )  . contains (  \"  1  0  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomDateEditorWithExactDateLength"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( String . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" spouse . name \"  ,     \" value \"  )  ;", "bw . setPropertyValue (  \" touchy \"  ,     \" value \"  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" spouse . name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" touchy \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForAllNestedStringProperties"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( String . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" name \"  ,     \" value \"  )  ;", "bw . setPropertyValue (  \" touchy \"  ,     \" value \"  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" touchy \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForAllStringProperties"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "tb . setSpouse ( new   TestBean (  )  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( String . class ,     \" spouse . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" spouse . name \"  ,     \" value \"  )  ;", "bw . setPropertyValue (  \" touchy \"  ,     \" value \"  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" spouse . name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getSpouse (  )  . getName (  )  )  ;", "assertEquals (  \" value \"  ,    bw . getPropertyValue (  \" touchy \"  )  )  ;", "assertEquals (  \" value \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForSingleNestedProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb    =    new   TestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( String . class ,     \" name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" name \"  ,     \" value \"  )  ;", "bw . setPropertyValue (  \" touchy \"  ,     \" value \"  )  ;", "assertEquals (  \" prefixvalue \"  ,    bw . getPropertyValue (  \" name \"  )  )  ;", "assertEquals (  \" prefixvalue \"  ,    tb . getName (  )  )  ;", "assertEquals (  \" value \"  ,    bw . getPropertyValue (  \" touchy \"  )  )  ;", "assertEquals (  \" value \"  ,    tb . getTouchy (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEditorForSingleProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomNumberEditor   editor    =    new   CustomNumberEditor ( Integer . class ,    false )  ;", "editor . setAsText (  \"  5  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    editor . getValue (  )  )  ;", "assertEquals (  \"  5  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomNumberEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . GERMAN )  ;", "NumberTestBean   tb    =    new   NumberTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( long . class ,    new   CustomNumberEditor ( Long . class ,    nf ,    true )  )  ;", "bw . register ( Long . class ,    new   CustomNumberEditor ( Long . class ,    nf ,    true )  )  ;", "bw . setPropertyValue (  \" long 1  \"  ,     \"  5  \"  )  ;", "bw . setPropertyValue (  \" long 2  \"  ,     \"  6  \"  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,    new   Long (  \"  5  \"  )  . equals ( bw . getPropertyValue (  \" long 1  \"  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,     (  ( tb . getLong 1  (  )  )     =  =     5  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( bw . getPropertyValue (  \" long 2  \"  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( tb . getLong 2  (  )  )  )  ;", "bw . setPropertyValue (  \" long 2  \"  ,     \"  \"  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,     (  ( bw . getPropertyValue (  \" long 2  \"  )  )     =  =    null )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,     (  ( tb . getLong 2  (  )  )     =  =    null )  )  ;", "try    {", "bw . setPropertyValue (  \" long 1  \"  ,     \"  \"  )  ;", "fail (  \" Should   have   thrown   BeansException \"  )  ;", "}    catch    ( BeansException   ex )     {", "assertTrue (  \" Correct   long 1    value \"  ,    new   Long (  \"  5  \"  )  . equals ( bw . getPropertyValue (  \" long 1  \"  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,     (  ( tb . getLong 1  (  )  )     =  =     5  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustomNumberEditorWithAllowEmpty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomNumberEditor   editor    =    new   CustomNumberEditor ( Integer . class ,    true )  ;", "editor . setAsText (  \"  5  \"  )  ;", "assertEquals ( new   Integer (  5  )  ,    editor . getValue (  )  )  ;", "assertEquals (  \"  5  \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"  \"  )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomNumberEditorWithEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . FRENCH )  ;", "NumberTestBean   tb    =    new   NumberTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( BigDecimal . class ,    new   CustomNumberEditor ( BigDecimal . class ,    nf ,    true )  )  ;", "bw . setPropertyValue (  \" bigDecimal \"  ,     \"  1  0  0  0  \"  )  ;", "assertEquals (  1  0  0  0  .  0 F ,    tb . getBigDecimal (  )  . floatValue (  )  ,     0  .  0 F )  ;", "bw . setPropertyValue (  \" bigDecimal \"  ,     \"  1  0  0  0  ,  5  \"  )  ;", "assertEquals (  1  0  0  0  .  5 F ,    tb . getBigDecimal (  )  . floatValue (  )  ,     0  .  0 F )  ;", "bw . setPropertyValue (  \" bigDecimal \"  ,     \"  1     0  0  0  ,  5  \"  )  ;", "assertEquals (  1  0  0  0  .  5 F ,    tb . getBigDecimal (  )  . floatValue (  )  ,     0  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["testCustomNumberEditorWithFrenchBigDecimal"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "CustomNumberEditor   editor    =    new   CustomNumberEditor ( Integer . class ,    false )  ;", "editor . setAsText (  (  \"  0 x \"     +     ( Integer . toHexString (  6  4  )  )  )  )  ;", "assertEquals ( new   Integer (  6  4  )  ,    editor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomNumberEditorWithHex"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "NumberFormat   nf    =    NumberFormat . getNumberInstance ( Locale . GERMAN )  ;", "NumberTestBean   tb    =    new   NumberTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . register ( short . class ,    new   CustomNumberEditor ( Short . class ,    nf ,    false )  )  ;", "bw . register ( Short . class ,    new   CustomNumberEditor ( Short . class ,    nf ,    false )  )  ;", "bw . register ( int . class ,    new   CustomNumberEditor ( Integer . class ,    nf ,    false )  )  ;", "bw . register ( Integer . class ,    new   CustomNumberEditor ( Integer . class ,    nf ,    false )  )  ;", "bw . register ( long . class ,    new   CustomNumberEditor ( Long . class ,    nf ,    false )  )  ;", "bw . register ( Long . class ,    new   CustomNumberEditor ( Long . class ,    nf ,    false )  )  ;", "bw . register ( BigInteger . class ,    new   CustomNumberEditor ( BigInteger . class ,    nf ,    false )  )  ;", "bw . register ( float . class ,    new   CustomNumberEditor ( Float . class ,    nf ,    false )  )  ;", "bw . register ( Float . class ,    new   CustomNumberEditor ( Float . class ,    nf ,    false )  )  ;", "bw . register ( double . class ,    new   CustomNumberEditor ( Double . class ,    nf ,    false )  )  ;", "bw . register ( Double . class ,    new   CustomNumberEditor ( Double . class ,    nf ,    false )  )  ;", "bw . register ( BigDecimal . class ,    new   CustomNumberEditor ( BigDecimal . class ,    nf ,    false )  )  ;", "bw . setPropertyValue (  \" short 1  \"  ,     \"  1  \"  )  ;", "bw . setPropertyValue (  \" short 2  \"  ,     \"  2  \"  )  ;", "bw . setPropertyValue (  \" int 1  \"  ,     \"  7  \"  )  ;", "bw . setPropertyValue (  \" int 2  \"  ,     \"  8  \"  )  ;", "bw . setPropertyValue (  \" long 1  \"  ,     \"  5  \"  )  ;", "bw . setPropertyValue (  \" long 2  \"  ,     \"  6  \"  )  ;", "bw . setPropertyValue (  \" bigInteger \"  ,     \"  3  \"  )  ;", "bw . setPropertyValue (  \" float 1  \"  ,     \"  7  ,  1  \"  )  ;", "bw . setPropertyValue (  \" float 2  \"  ,     \"  8  ,  1  \"  )  ;", "bw . setPropertyValue (  \" double 1  \"  ,     \"  5  ,  1  \"  )  ;", "bw . setPropertyValue (  \" double 2  \"  ,     \"  6  ,  1  \"  )  ;", "bw . setPropertyValue (  \" bigDecimal \"  ,     \"  4  ,  5  \"  )  ;", "assertTrue (  \" Correct   short 1    value \"  ,    new   Short (  \"  1  \"  )  . equals ( bw . getPropertyValue (  \" short 1  \"  )  )  )  ;", "assertTrue (  \" Correct   short 1    value \"  ,     (  ( tb . getShort 1  (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( bw . getPropertyValue (  \" short 2  \"  )  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( tb . getShort 2  (  )  )  )  ;", "assertTrue (  \" Correct   int 1    value \"  ,    new   Integer (  \"  7  \"  )  . equals ( bw . getPropertyValue (  \" int 1  \"  )  )  )  ;", "assertTrue (  \" Correct   int 1    value \"  ,     (  ( tb . getInt 1  (  )  )     =  =     7  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( bw . getPropertyValue (  \" int 2  \"  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( tb . getInt 2  (  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,    new   Long (  \"  5  \"  )  . equals ( bw . getPropertyValue (  \" long 1  \"  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,     (  ( tb . getLong 1  (  )  )     =  =     5  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( bw . getPropertyValue (  \" long 2  \"  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( tb . getLong 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( bw . getPropertyValue (  \" bigInteger \"  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( tb . getBigInteger (  )  )  )  ;", "assertTrue (  \" Correct   float 1    value \"  ,    new   Float (  \"  7  .  1  \"  )  . equals ( bw . getPropertyValue (  \" float 1  \"  )  )  )  ;", "assertTrue (  \" Correct   float 1    value \"  ,    new   Float (  \"  7  .  1  \"  )  . equals ( new   Float ( tb . getFloat 1  (  )  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( bw . getPropertyValue (  \" float 2  \"  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( tb . getFloat 2  (  )  )  )  ;", "assertTrue (  \" Correct   double 1    value \"  ,    new   Double (  \"  5  .  1  \"  )  . equals ( bw . getPropertyValue (  \" double 1  \"  )  )  )  ;", "assertTrue (  \" Correct   double 1    value \"  ,     (  ( tb . getDouble 1  (  )  )     =  =     5  .  1  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( bw . getPropertyValue (  \" double 2  \"  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( tb . getDouble 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  5  \"  )  . equals ( bw . getPropertyValue (  \" bigDecimal \"  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  5  \"  )  . equals ( tb . getBigDecimal (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomNumberEditorWithoutAllowEmpty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "BooleanTestBean   tb    =    new   BooleanTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" true \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    Boolean . TRUE . equals ( bw . getPValue (  \" bool 1  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    tb . isBool 1  (  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" false \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    Boolean . FALSE . equals ( bw . getPValue (  \" bool 1  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,     (  !  ( tb . isBool 1  (  )  )  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \"       true       \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    tb . isBool 1  (  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \"       false       \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,     (  !  ( tb . isBool 1  (  )  )  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" on \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    tb . isBool 1  (  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" off \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,     (  !  ( tb . isBool 1  (  )  )  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" yes \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    tb . isBool 1  (  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \" no \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,     (  !  ( tb . isBool 1  (  )  )  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \"  1  \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,    tb . isBool 1  (  )  )  ;", "bw . setPValue (  \" bool 1  \"  ,     \"  0  \"  )  ;", "assertTrue (  \" Correct   bool 1    value \"  ,     (  !  ( tb . isBool 1  (  )  )  )  )  ;", "try    {", "bw . setPValue (  \" bool 1  \"  ,     \" argh \"  )  ;", "fail (  \" Should   have   thrown   BeansException \"  )  ;", "}    catch    ( BeansException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testDefaultBooleanEditorForPrimitiveType"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "BooleanTestBean   tb    =    new   BooleanTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" true \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . TRUE . equals ( bw . getPValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" false \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    Boolean . FALSE . equals ( bw . getPValue (  \" bool 2  \"  )  )  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" on \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" off \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" yes \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \" no \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \"  1  \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  . booleanValue (  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \"  0  \"  )  ;", "assertTrue (  \" Correct   bool 2    value \"  ,     (  !  ( tb . getBool 2  (  )  . booleanValue (  )  )  )  )  ;", "bw . setPValue (  \" bool 2  \"  ,     \"  \"  )  ;", "assertNull (  \" Correct   bool 2    value \"  ,    tb . getBool 2  (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultBooleanEditorForWrapperType"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "NumberTestBean   tb    =    new   NumberTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( tb )  ;", "bw . setPValue (  \" short 1  \"  ,     \"  1  \"  )  ;", "bw . setPValue (  \" short 2  \"  ,     \"  2  \"  )  ;", "bw . setPValue (  \" int 1  \"  ,     \"  7  \"  )  ;", "bw . setPValue (  \" int 2  \"  ,     \"  8  \"  )  ;", "bw . setPValue (  \" long 1  \"  ,     \"  5  \"  )  ;", "bw . setPValue (  \" long 2  \"  ,     \"  6  \"  )  ;", "bw . setPValue (  \" bigInteger \"  ,     \"  3  \"  )  ;", "bw . setPValue (  \" float 1  \"  ,     \"  7  .  1  \"  )  ;", "bw . setPValue (  \" float 2  \"  ,     \"  8  .  1  \"  )  ;", "bw . setPValue (  \" double 1  \"  ,     \"  5  .  1  \"  )  ;", "bw . setPValue (  \" double 2  \"  ,     \"  6  .  1  \"  )  ;", "bw . setPValue (  \" bigDecimal \"  ,     \"  4  .  5  \"  )  ;", "assertTrue (  \" Correct   short 1    value \"  ,    new   Short (  \"  1  \"  )  . equals ( bw . getPValue (  \" short 1  \"  )  )  )  ;", "assertTrue (  \" Correct   short 1    value \"  ,     (  ( tb . getShort 1  (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( bw . getPValue (  \" short 2  \"  )  )  )  ;", "assertTrue (  \" Correct   short 2    value \"  ,    new   Short (  \"  2  \"  )  . equals ( tb . getShort 2  (  )  )  )  ;", "assertTrue (  \" Correct   int 1    value \"  ,    new   Integer (  \"  7  \"  )  . equals ( bw . getPValue (  \" int 1  \"  )  )  )  ;", "assertTrue (  \" Correct   int 1    value \"  ,     (  ( tb . getInt 1  (  )  )     =  =     7  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( bw . getPValue (  \" int 2  \"  )  )  )  ;", "assertTrue (  \" Correct   int 2    value \"  ,    new   Integer (  \"  8  \"  )  . equals ( tb . getInt 2  (  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,    new   Long (  \"  5  \"  )  . equals ( bw . getPValue (  \" long 1  \"  )  )  )  ;", "assertTrue (  \" Correct   long 1    value \"  ,     (  ( tb . getLong 1  (  )  )     =  =     5  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( bw . getPValue (  \" long 2  \"  )  )  )  ;", "assertTrue (  \" Correct   long 2    value \"  ,    new   Long (  \"  6  \"  )  . equals ( tb . getLong 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( bw . getPValue (  \" bigInteger \"  )  )  )  ;", "assertTrue (  \" Correct   bigInteger   value \"  ,    new   BigInteger (  \"  3  \"  )  . equals ( tb . getBigInteger (  )  )  )  ;", "assertTrue (  \" Correct   float 1    value \"  ,    new   Float (  \"  7  .  1  \"  )  . equals ( bw . getPValue (  \" float 1  \"  )  )  )  ;", "assertTrue (  \" Correct   float 1    value \"  ,    new   Float (  \"  7  .  1  \"  )  . equals ( new   Float ( tb . getFloat 1  (  )  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( bw . getPValue (  \" float 2  \"  )  )  )  ;", "assertTrue (  \" Correct   float 2    value \"  ,    new   Float (  \"  8  .  1  \"  )  . equals ( tb . getFloat 2  (  )  )  )  ;", "assertTrue (  \" Correct   double 1    value \"  ,    new   Double (  \"  5  .  1  \"  )  . equals ( bw . getPValue (  \" double 1  \"  )  )  )  ;", "assertTrue (  \" Correct   double 1    value \"  ,     (  ( tb . getDouble 1  (  )  )     =  =     5  .  1  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( bw . getPValue (  \" double 2  \"  )  )  )  ;", "assertTrue (  \" Correct   double 2    value \"  ,    new   Double (  \"  6  .  1  \"  )  . equals ( tb . getDouble 2  (  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  5  \"  )  . equals ( bw . getPValue (  \" bigDecimal \"  )  )  )  ;", "assertTrue (  \" Correct   bigDecimal   value \"  ,    new   BigDecimal (  \"  4  .  5  \"  )  . equals ( tb . getBigDecimal (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultNumberEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "fileEditor . setAsText (  \" file : myfile . txt \"  )  ;", "assertEquals ( new   File (  \" myfile . txt \"  )  ,    fileEditor . getValue (  )  )  ;", "assertEquals ( new   File (  \" myfile . txt \"  )  . getPath (  )  ,    fileEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testFileEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "if    ( new   File (  \" C :  / myfile . txt \"  )  . isAbsolute (  )  )     {", "fileEditor . setAsText (  \" C :  / myfile . txt \"  )  ;", "assertEquals ( new   File (  \" C :  / myfile . txt \"  )  ,    fileEditor . getValue (  )  )  ;", "}", "if    ( new   File (  \"  / myfile . txt \"  )  . isAbsolute (  )  )     {", "fileEditor . setAsText (  \"  / myfile . txt \"  )  ;", "assertEquals ( new   File (  \"  / myfile . txt \"  )  ,    fileEditor . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFileEditorWithAbsolutePath"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "try    {", "fileEditor . setAsText (  \" myfile . txt \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testFileEditorWithRelativePath"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]  [  ]  [  ]  [  ]  [  ]    ridiculousChessboard    =    new   String [  8  ]  [  4  ]  [  0  ]  [  1  ]  [  3  ]  ;", "Class   editor    =    new   Class (  )  ;", "editor . setValue ( ridiculousChessboard . getClass (  )  )  ;", "assertEquals (  \" String [  ]  [  ]  [  ]  [  ]  [  ]  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAsTextWithRidiculousMultiDimensionalArray"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]  [  ]    chessboard    =    new   String [  8  ]  [  8  ]  ;", "Class   editor    =    new   Class (  )  ;", "editor . setValue ( chessboard . getClass (  )  )  ;", "assertEquals (  \" String [  ]  [  ]  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAsTextWithTwoDimensionalArray"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean ( false )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( String . class ,     \" array . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" list . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" map . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" map \"     +    text )  )  ;", "}", "}  )  ;", "bean . populate (  )  ;", "TestBean   tb 0     =    bean . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    bean . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "assertEquals (  \" name 0  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [ key 2  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 2  \\  \"  ]  . name \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  . name \"  ,     \" name 0  \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" arrayname 5  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" arrayname 4  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" listname 3  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" listname 2  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" mapname 1  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" mapname 0  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" arrayname 5  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" arrayname 4  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" listname 3  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" listname 2  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" mapname 1  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" mapname 0  \"  ,    bw . getPropertyValue (  \" map [  ' key 2  '  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithCustomEditorForProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( String . class ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" prefix \"     +    text )  )  ;", "}", "}  )  ;", "TestBean   tb 0     =    bean . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    bean . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "assertEquals (  \" name 0  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [ key 2  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 2  \\  \"  ]  . name \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  . name \"  ,     \" name 0  \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" prefixname 5  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" prefixname 4  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" prefixname 3  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" prefixname 2  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" prefixname 1  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" prefixname 0  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" prefixname 5  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" prefixname 4  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" prefixname 3  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" prefixname 2  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" prefixname 1  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" prefixname 0  \"  ,    bw . getPropertyValue (  \" map [  ' key 2  '  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithCustomEditorForType"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( TestBean . class ,     \" array \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" array \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" list \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" list \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" map \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" map \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,     \" a \"  )  ;", "pvs . add (  \" array [  1  ]  \"  ,     \" b \"  )  ;", "pvs . add (  \" list [  0  ]  \"  ,     \" c \"  )  ;", "pvs . add (  \" list [  1  ]  \"  ,     \" d \"  )  ;", "pvs . add (  \" map [ key 1  ]  \"  ,     \" e \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  \"  ,     \" f \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" arraya \"  ,    bean . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" arrayb \"  ,    bean . getArray (  )  [  1  ]  . getName (  )  )  ;", "assertEquals (  \" listc \"  ,     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" listd \"  ,     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mape \"  ,     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapf \"  ,     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithDirectAccessAndPropertyEditors"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( TestBean . class ,     \" array [  0  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" array 0  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" array [  1  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" array 1  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" list [  0  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" list 0  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" list [  1  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" list 1  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" map [ key 1  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" mapkey 1  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "bw . register ( TestBean . class ,     \" map [ key 2  ]  \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue ( new   TestBean (  (  \" mapkey 2  \"     +    text )  ,     9  9  )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( TestBean )     ( getValue (  )  )  )  . getName (  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  \"  ,     \" a \"  )  ;", "pvs . add (  \" array [  1  ]  \"  ,     \" b \"  )  ;", "pvs . add (  \" list [  0  ]  \"  ,     \" c \"  )  ;", "pvs . add (  \" list [  1  ]  \"  ,     \" d \"  )  ;", "pvs . add (  \" map [ key 1  ]  \"  ,     \" e \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  \"  ,     \" f \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" array 0 a \"  ,    bean . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" array 1 b \"  ,    bean . getArray (  )  [  1  ]  . getName (  )  )  ;", "assertEquals (  \" list 0 c \"  ,     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" list 1 d \"  ,     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapkey 1 e \"  ,     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapkey 2 f \"  ,     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithDirectAccessAndSpecificPropertyEditors"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean ( false )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( String . class ,     \" array [  0  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array 0  \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" array [  1  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array 1  \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" list [  0  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list 0  \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" list [  1  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list 1  \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" map [ key 1  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" mapkey 1  \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" map [ key 2  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" mapkey 2  \"     +    text )  )  ;", "}", "}  )  ;", "bean . populate (  )  ;", "TestBean   tb 0     =    bean . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    bean . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "assertEquals (  \" name 0  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [ key 2  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [  ' key 1  '  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 2  \\  \"  ]  . name \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  . name \"  ,     \" name 0  \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" array 0 name 5  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" array 1 name 4  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" list 0 name 3  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" list 1 name 2  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" mapkey 1 name 1  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" mapkey 2 name 0  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" array 0 name 5  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" array 1 name 4  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" list 0 name 3  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" list 1 name 2  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" mapkey 1 name 1  \"  ,    bw . getPropertyValue (  \" map [  \\  \" key 1  \\  \"  ]  . name \"  )  )  ;", "assertEquals (  \" mapkey 2 name 0  \"  ,    bw . getPropertyValue (  \" map [  ' key 2  '  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithIndividualCustomEditorForProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( List . class ,     \" list \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "List < TestBean >    result    =    new   ArrayList <  >  (  )  ;", "result . add ( new   TestBean (  (  \" list \"     +    text )  ,     9  9  )  )  ;", "setValue ( result )  ;", "}", "}  )  ;", "bw . setPropertyValue (  \" list \"  ,     \"  1  \"  )  ;", "assertEquals (  \" list 1  \"  ,     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "bw . setPropertyValue (  \" list [  0  ]  \"  ,     \" test \"  )  ;", "assertEquals (  \" test \"  ,    bean . getList (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexedPropertiesWithListPropertyEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   localeEditor    =    new   LocaleEditor (  )  ;", "localeEditor . setAsText (  \" en _ CA \"  )  ;", "assertEquals ( Locale . CANADA ,    localeEditor . getValue (  )  )  ;", "assertEquals (  \" en _ CA \"  ,    localeEditor . getAsText (  )  )  ;", "localeEditor    =    new   LocaleEditor (  )  ;", "assertEquals (  \"  \"  ,    localeEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testLocaleEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "TestBean   tb 0     =    bean . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    bean . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "tb 0  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 1  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 2  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 3  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 4  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 5  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( String . class ,     \" array . nestedIndexedBean . array . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  5  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" list . nestedIndexedBean . list . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  4  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" map . nestedIndexedBean . map . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" map \"     +    text )  )  ;", "}", "@ Override", "public   String   getAsText (  )     {", "return    (  ( String )     ( getValue (  )  )  )  . substring (  4  )  ;", "}", "}  )  ;", "assertEquals (  \" name 0  \"  ,    tb 0  . getName (  )  )  ;", "assertEquals (  \" name 1  \"  ,    tb 1  . getName (  )  )  ;", "assertEquals (  \" name 2  \"  ,    tb 2  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,    tb 3  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 4  . getName (  )  )  ;", "assertEquals (  \" name 5  \"  ,    tb 5  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . nestedIndexedBean . array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 1  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . nestedIndexedBean . array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 2  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" name 3  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" name 4  \"  ,    bw . getPropertyValue (  \" map [ key 1  ]  . nestedIndexedBean . map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" name 5  \"  ,    bw . getPropertyValue (  \" map [  \\  ' key 2  \\  '  ]  . nestedIndexedBean . map [  \\  \" key 2  \\  \"  ]  . name \"  )  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . nestedIndexedBean . array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . nestedIndexedBean . map [  \\  \" key 1  \\  \"  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  . nestedIndexedBean . map [ key 2  ]  . name \"  ,     \" name 0  \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" arrayname 5  \"  ,    tb 0  . getNestedIndexedBean (  )  . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" arrayname 4  \"  ,    tb 1  . getNestedIndexedBean (  )  . getArray (  )  [  1  ]  . getName (  )  )  ;", "assertEquals (  \" listname 3  \"  ,     (  ( TestBean )     ( tb 2  . getNestedIndexedBean (  )  . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" listname 2  \"  ,     (  ( TestBean )     ( tb 3  . getNestedIndexedBean (  )  . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapname 1  \"  ,     (  ( TestBean )     ( tb 4  . getNestedIndexedBean (  )  . getMap (  )  . get (  \" key 1  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapname 0  \"  ,     (  ( TestBean )     ( tb 5  . getNestedIndexedBean (  )  . getMap (  )  . get (  \" key 2  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" arrayname 5  \"  ,    bw . getPropertyValue (  \" array [  0  ]  . nestedIndexedBean . array [  0  ]  . name \"  )  )  ;", "assertEquals (  \" arrayname 4  \"  ,    bw . getPropertyValue (  \" array [  1  ]  . nestedIndexedBean . array [  1  ]  . name \"  )  )  ;", "assertEquals (  \" listname 3  \"  ,    bw . getPropertyValue (  \" list [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  )  )  ;", "assertEquals (  \" listname 2  \"  ,    bw . getPropertyValue (  \" list [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  )  )  ;", "assertEquals (  \" mapname 1  \"  ,    bw . getPropertyValue (  \" map [  ' key 1  '  ]  . nestedIndexedBean . map [ key 1  ]  . name \"  )  )  ;", "assertEquals (  \" mapname 0  \"  ,    bw . getPropertyValue (  \" map [ key 2  ]  . nestedIndexedBean . map [  \\  \" key 2  \\  \"  ]  . name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedIndexedPropertiesWithCustomEditorForProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean (  )  ;", "TestBean   tb 0     =    bean . getArray (  )  [  0  ]  ;", "TestBean   tb 1     =    bean . getArray (  )  [  1  ]  ;", "TestBean   tb 2     =     (  ( TestBean )     ( bean . getList (  )  . get (  0  )  )  )  ;", "TestBean   tb 3     =     (  ( TestBean )     ( bean . getList (  )  . get (  1  )  )  )  ;", "TestBean   tb 4     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 1  \"  )  )  )  ;", "TestBean   tb 5     =     (  ( TestBean )     ( bean . getMap (  )  . get (  \" key 2  \"  )  )  )  ;", "tb 0  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 1  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 2  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 3  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 4  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "tb 5  . setNestedIndexedBean ( new   IndexedTestBean (  )  )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "bw . register ( String . class ,     \" array [  0  ]  . nestedIndexedBean . array [  0  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" array \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" list . nestedIndexedBean . list [  1  ]  . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" list \"     +    text )  )  ;", "}", "}  )  ;", "bw . register ( String . class ,     \" map [ key 1  ]  . nestedIndexedBean . map . name \"  ,    new   PropertyEditorSupport (  )     {", "@ Override", "public   void   setAsText ( String   text )    throws   IllegalArgumentException    {", "setValue (  (  \" map \"     +    text )  )  ;", "}", "}  )  ;", "MutablePropertyValues   pvs    =    new   MutablePropertyValues (  )  ;", "pvs . add (  \" array [  0  ]  . nestedIndexedBean . array [  0  ]  . name \"  ,     \" name 5  \"  )  ;", "pvs . add (  \" array [  1  ]  . nestedIndexedBean . array [  1  ]  . name \"  ,     \" name 4  \"  )  ;", "pvs . add (  \" list [  0  ]  . nestedIndexedBean . list [  0  ]  . name \"  ,     \" name 3  \"  )  ;", "pvs . add (  \" list [  1  ]  . nestedIndexedBean . list [  1  ]  . name \"  ,     \" name 2  \"  )  ;", "pvs . add (  \" map [ key 1  ]  . nestedIndexedBean . map [  \\  \" key 1  \\  \"  ]  . name \"  ,     \" name 1  \"  )  ;", "pvs . add (  \" map [  ' key 2  '  ]  . nestedIndexedBean . map [ key 2  ]  . name \"  ,     \" name 0  \"  )  ;", "bw . setPropertyValues ( pvs )  ;", "assertEquals (  \" arrayname 5  \"  ,    tb 0  . getNestedIndexedBean (  )  . getArray (  )  [  0  ]  . getName (  )  )  ;", "assertEquals (  \" name 4  \"  ,    tb 1  . getNestedIndexedBean (  )  . getArray (  )  [  1  ]  . getName (  )  )  ;", "assertEquals (  \" name 3  \"  ,     (  ( TestBean )     ( tb 2  . getNestedIndexedBean (  )  . getList (  )  . get (  0  )  )  )  . getName (  )  )  ;", "assertEquals (  \" listname 2  \"  ,     (  ( TestBean )     ( tb 3  . getNestedIndexedBean (  )  . getList (  )  . get (  1  )  )  )  . getName (  )  )  ;", "assertEquals (  \" mapname 1  \"  ,     (  ( TestBean )     ( tb 4  . getNestedIndexedBean (  )  . getMap (  )  . get (  \" key 1  \"  )  )  )  . getName (  )  )  ;", "assertEquals (  \" name 0  \"  ,     (  ( TestBean )     ( tb 5  . getNestedIndexedBean (  )  . getMap (  )  . get (  \" key 2  \"  )  )  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNestedIndexedPropertiesWithIndexedCustomEditorForProperty"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "CustomNumberEditor       =    new   CustomNumberEditor ( Short . class ,    true )  ;", ". setAsText ( String . valueOf (  (  ( Short . MAX _ VALUE )     +     1  )  )  )  ;", "fail (  (  (  ( Short . MAX _ VALUE )     +     1  )     +     \"    is   greater   than   max   value \"  )  )  ;", "}    catch    ( NumberFormatException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testParseShortGreaterThanMaxValueWithoutNumberFormat"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "final   String   REGEX    =     \" a .  *  \"  ;", "PEditor   patternEditor    =    new   PatternEditor (  )  ;", "patternEditor . setAsText ( REGEX )  ;", "assertEquals ( Pattern . compile ( REGEX )  . pattern (  )  ,     (  ( Pattern )     ( patternEditor . getValue (  )  )  )  . pattern (  )  )  ;", "assertEquals ( REGEX ,    patternEditor . getAsText (  )  )  ;", "patternEditor    =    new   PatternEditor (  )  ;", "assertEquals (  \"  \"  ,    patternEditor . getAsText (  )  )  ;", "patternEditor    =    new   PatternEditor (  )  ;", "patternEditor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    patternEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringTrimmerEditor   editor    =    new   StringTrimmerEditor ( false )  ;", "editor . setAsText (  \" test \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"    test    \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringTrimmerEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringTrimmerEditor   editor    =    new   StringTrimmerEditor (  \"  \\ r \\ n \\ f \"  ,    false )  ;", "editor . setAsText (  \" te \\ ns \\ ft \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"    test    \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"  \"  )  ;", "assertEquals (  \"  \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringTrimmerEditorWithCharsToDelete"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringTrimmerEditor   editor    =    new   StringTrimmerEditor (  \"  \\ r \\ n \\ f \"  ,    true )  ;", "editor . setAsText (  \" te \\ ns \\ ft \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"    test    \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"     \\ n \\ f    \"  )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringTrimmerEditorWithCharsToDeleteAndEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringTrimmerEditor   editor    =    new   StringTrimmerEditor ( true )  ;", "editor . setAsText (  \" test \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"    test    \"  )  ;", "assertEquals (  \" test \"  ,    editor . getValue (  )  )  ;", "assertEquals (  \" test \"  ,    editor . getAsText (  )  )  ;", "editor . setAsText (  \"        \"  )  ;", "assertEquals ( null ,    editor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "editor . setValue ( null )  ;", "assertEquals (  \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringTrimmerEditorWithEmptyAsNull"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "IndexedTestBean   bean    =    new   IndexedTestBean ( false )  ;", "BeanWrapper   bw    =    new   BeanWrapperImpl ( bean )  ;", "PropertyEditor   pe    =    new   CustomNumberEditor ( Integer . class ,    true )  ;", "bw . register ( null ,     \" list . age \"  ,    pe )  ;", "TestBean   tb    =    new   TestBean (  )  ;", "bw . setPropertyValue (  \" list \"  ,    new   ArrayList <  >  (  )  )  ;", "bw . setPropertyValue (  \" list [  0  ]  \"  ,    tb )  ;", "assertEquals ( tb ,    bean . getList (  )  . get (  0  )  )  ;", "assertEquals ( pe ,    bw . find ( int . class ,     \" list . age \"  )  )  ;", "assertEquals ( pe ,    bw . find ( null ,     \" list . age \"  )  )  ;", "assertEquals ( pe ,    bw . find ( int . class ,     \" list [  0  ]  . age \"  )  )  ;", "assertEquals ( pe ,    bw . find ( null ,     \" list [  0  ]  . age \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUninitializedArrayPropertyWithCustomEditor"], "fileName": "org.springframework.beans.propertyeditors.CustomEditorTests"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["alwaysCreateNewMap"], "fileName": "org.springframework.beans.propertyeditors.CustomMapEditor"}, {"methodBody": ["METHOD_START", "{", "return   key ;", "}", "METHOD_END"], "methodName": ["convertKey"], "fileName": "org.springframework.beans.propertyeditors.CustomMapEditor"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["convertValue"], "fileName": "org.springframework.beans.propertyeditors.CustomMapEditor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mapType . isInterface (  )  )  )     {", "try    {", "return   ReflectionUtils . accessibleConstruc ( mapType )  . newInstance (  )  ;", "}    catch    ( Throwable   ex )     {", "throw   new   IllegalArgumentException (  (  \" Could   not   instantiate   map   class :     \"     +     ( mapType . getName (  )  )  )  ,    ex )  ;", "}", "} else", "if    (  ( class )     =  =    mapType )     {", "return   new   TreeMap <  >  (  )  ;", "} else    {", "return   new   LinkedHashMap <  >  ( initialCapacity )  ;", "}", "}", "METHOD_END"], "methodName": ["createMap"], "fileName": "org.springframework.beans.propertyeditors.CustomMapEditor"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "fileEditor . setAsText (  \"  / no _ way _ this _ file _ is _ found . doc \"  )  ;", "Object   value    =    fileEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   File )  )  ;", "File   file    =     (  ( File )     ( value )  )  ;", "assertTrue (  (  !  ( file . exists (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAbsoluteFileName"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "fileEditor . setAsText (  (  (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  )  )  ;", "Object   value    =    fileEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   File )  )  ;", "File   file    =     (  ( File )     ( value )  )  ;", "assertTrue ( file . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClasspathFileName"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "String   fileName    =     (  (  ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "fileEditor . setAsText ( fileName )  ;", "Object   value    =    fileEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   File )  )  ;", "File   file    =     (  ( File )     ( value )  )  ;", "assertTrue ( file . exists (  )  )  ;", "String   absolutePath    =    file . getAbsolutePath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "assertTrue ( absolutePath . endsWith ( fileName )  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualifiedFileNameFound"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "String   fileName    =     (  (  ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . clazz \"  ;", "fileEditor . setAsText ( fileName )  ;", "Object   value    =    fileEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   File )  )  ;", "File   file    =     (  ( File )     ( value )  )  ;", "assertFalse ( file . exists (  )  )  ;", "String   absolutePath    =    file . getAbsolutePath (  )  . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "assertTrue ( absolutePath . endsWith ( fileName )  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualifiedFileNameNotFound"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   fileEditor    =    new   FileEditor (  )  ;", "fileEditor . setAsText (  \" file : no _ way _ this _ file _ is _ found . doc \"  )  ;", "Object   value    =    fileEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   File )  )  ;", "File   file    =     (  ( File )     ( value )  )  ;", "assertTrue (  (  !  ( file . exists (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonExistentFile"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   propertyEditor    =    new   FileEditor (  )  ;", "propertyEditor . setAsText (  \" classpath : no _ way _ this _ file _ is _ found . doc \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonExistentResource"], "fileName": "org.springframework.beans.propertyeditors.FileEditorTests"}, {"methodBody": ["METHOD_START", "{", "new   InputStreamEditor ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullResourceEditor"], "fileName": "org.springframework.beans.propertyeditors.InputStreamEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( new   InputStreamEditor (  )  . getAsText (  )  )  ;", "String   resource    =     (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "InputStreamEditor   editor    =    new   InputStreamEditor (  )  ;", "editor . setAsText ( resource )  ;", "assertNull ( editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAsTextReturnsNullByDefault"], "fileName": "org.springframework.beans.propertyeditors.InputStreamEditorTests"}, {"methodBody": ["METHOD_START", "{", "InputStream   stream    =    null ;", "try    {", "String   resource    =     (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "editor    =    new    (  )  ;", "editor . setAsText ( resource )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   InputStream )  )  ;", "stream    =     (  ( InputStream )     ( value )  )  ;", "assertTrue (  (  ( stream . available (  )  )     >     0  )  )  ;", "}    finally    {", "if    ( stream    !  =    null )     {", "stream . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSunnyDay"], "fileName": "org.springframework.beans.propertyeditors.InputStreamEditorTests"}, {"methodBody": ["METHOD_START", "{", "InputStreamEditor   editor    =    new   InputStreamEditor (  )  ;", "editor . setAsText (  \" classpath : bingo !  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhenResourceDoesNotExist"], "fileName": "org.springframework.beans.propertyeditors.InputStreamEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   pathEditor    =    new   PathEditor (  )  ;", "pathEditor . setAsText (  \"  / no _ way _ this _ file _ is _ found . doc \"  )  ;", "Object   value    =    pathEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   Path )  )  ;", "Path   path    =     (  ( Path )     ( value )  )  ;", "assertTrue (  (  !  ( path . toFile (  )  . exists (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAbsolutePath"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   pathEditor    =    new   PathEditor (  )  ;", "pathEditor . setAsText (  (  (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  )  )  ;", "Object   value    =    pathEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   Path )  )  ;", "Path   path    =     (  ( Path )     ( value )  )  ;", "assertTrue ( path . toFile (  )  . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClasspathPathName"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   pathEditor    =    new   PathEditor (  )  ;", "String   fileName    =     (  (  ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "pathEditor . setAsText ( fileName )  ;", "Object   value    =    pathEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   Path )  )  ;", "Path   path    =     (  ( Path )     ( value )  )  ;", "File   file    =    path . toFile (  )  ;", "assertTrue ( file . exists (  )  )  ;", "String   absolutePath    =    file . getAbsolutePath (  )  ;", "if    (  ( File . separatorChar )     =  =     '  \\  \\  '  )     {", "absolutePath    =    absolutePath . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "assertTrue ( absolutePath . endsWith ( fileName )  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualifiedPathNameFound"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   pathEditor    =    new   PathEditor (  )  ;", "String   fileName    =     (  (  ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . clazz \"  ;", "pathEditor . setAsText ( fileName )  ;", "Object   value    =    pathEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   Path )  )  ;", "Path   path    =     (  ( Path )     ( value )  )  ;", "File   file    =    path . toFile (  )  ;", "assertFalse ( file . exists (  )  )  ;", "String   absolutePath    =    file . getAbsolutePath (  )  ;", "if    (  ( File . separatorChar )     =  =     '  \\  \\  '  )     {", "absolutePath    =    absolutePath . replace (  '  \\  \\  '  ,     '  /  '  )  ;", "}", "assertTrue ( absolutePath . endsWith ( fileName )  )  ;", "}", "METHOD_END"], "methodName": ["testUnqualifiedPathNameNotFound"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   pathEditor    =    new   PathEditor (  )  ;", "pathEditor . setAsText (  \" file :  / no _ way _ this _ file _ is _ found . doc \"  )  ;", "Object   value    =    pathEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   Path )  )  ;", "Path   path    =     (  ( Path )     ( value )  )  ;", "assertTrue (  (  !  ( path . toFile (  )  . exists (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonExistentPath"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   propertyEditor    =    new   PathEditor (  )  ;", "propertyEditor . setAsText (  \" classpath :  / no _ way _ this _ file _ is _ found . doc \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonExistentResource"], "fileName": "org.springframework.beans.propertyeditors.PathEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesEditor   pe    =    new   PropertiesEditor (  )  ;", "pe . setAsText (  \"  \"  )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" empty   string   means   empty   properties \"  ,    p . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyString"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo = bar \\ nme = mi \\ nx =  \"  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   two   entries \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" foo = bar \"  ,    p . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "assertTrue (  \" x =  ' y = z '  \"  ,    p . get (  \" x \"  )  . equals (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handlesEmptyProperty"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo \\ nme = mi \\ nx = x \"  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   three   entries \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" foo   is   empty \"  ,    p . get (  \" foo \"  )  . equals (  \"  \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handlesEmptyPropertyWithoutEquals"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo = bar \\ n \"     +     (  \" me = mi \\ n \"     +     \" x = y = z \"  )  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   two   entries \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" foo = bar \"  ,    p . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "assertTrue (  \" x =  ' y = z '  \"  ,    p . get (  \" x \"  )  . equals (  \" y = z \"  )  )  ;", "}", "METHOD_END"], "methodName": ["handlesEqualsInValue"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \"  # Ignore   this   comment \\ n \"     +     (  (  (  (  \" foo = bar \\ n \"     +     \"  # Another = comment   more   junk    /  \\ n \"  )     +     \" me = mi \\ n \"  )     +     \" x = x \\ n \"  )     +     \"  \\ n \"  )  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   three   entries \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" foo   is   bar \"  ,    p . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoresCommentLinesAndEmptyLines"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \"              # Ignore   this   comment \\ n \"     +     (  (  (  (  \"  \\ t \\ tfoo = bar \\ n \"     +     \"  \\ t # Another   comment   more   junk    \\ n \"  )     +     \"    me = mi \\ n \"  )     +     \" x = x \\ n \"  )     +     \"  \\ n \"  )  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  (  \" contains    3    entries ,    not    \"     +     ( p . size (  )  )  )  ,     (  ( p . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" foo   is   bar \"  ,    p . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ignoresLeadingSpacesAndTabs"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertiesEditor   pe    =    new   PropertiesEditor (  )  ;", "pe . setAsText ( null )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertEquals (  0  ,    p . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["nullValue"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo = bar \"  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   one   entry \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue (  \" foo = bar \"  ,    p . get (  \" foo \"  )  . equals (  \" bar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["oneProperty"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   s    =     \" foo = bar   with   whitespace \\ n \"     +     \" me = mi \"  ;", "pe    =    new    (  )  ;", "pe . setAsText ( s )  ;", "Properties   p    =     (  ( Properties )     ( pe . getValue (  )  )  )  ;", "assertTrue (  \" contains   two   entries \"  ,     (  ( p . entrySet (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue (  \" foo = bar   with   whitespace \"  ,    p . get (  \" foo \"  )  . equals (  \" bar   with   whitespace \"  )  )  ;", "assertTrue (  \" me = mi \"  ,    p . get (  \" me \"  )  . equals (  \" mi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["twoProperties"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "map . put (  \" one \"  ,     \"  1  \"  )  ;", "map . put (  \" two \"  ,     \"  2  \"  )  ;", "map . put (  \" three \"  ,     \"  3  \"  )  ;", "pe    =    new    (  )  ;", "pe . setValue ( map )  ;", "Object   value    =    pe . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   Properties )  )  ;", "Properties   props    =     (  ( Properties )     ( value )  )  ;", "assertEquals (  3  ,    props . size (  )  )  ;", "assertEquals (  \"  1  \"  ,    props . getProperty (  \" one \"  )  )  ;", "assertEquals (  \"  2  \"  ,    props . getProperty (  \" two \"  )  )  ;", "assertEquals (  \"  3  \"  ,    props . getProperty (  \" three \"  )  )  ;", "}", "METHOD_END"], "methodName": ["usingMapAsValueSource"], "fileName": "org.springframework.beans.propertyeditors.PropertiesEditorTests"}, {"methodBody": ["METHOD_START", "{", "new   ReaderEditor ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullResourceEditor"], "fileName": "org.springframework.beans.propertyeditors.ReaderEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertNull ( new   ReaderEditor (  )  . getAsText (  )  )  ;", "String   resource    =     (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "ReaderEditor   editor    =    new   ReaderEditor (  )  ;", "editor . setAsText ( resource )  ;", "assertNull ( editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAsTextReturnsNullByDefault"], "fileName": "org.springframework.beans.propertyeditors.ReaderEditorTests"}, {"methodBody": ["METHOD_START", "{", "Reader   reader    =    null ;", "try    {", "String   resource    =     (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  ;", "editor    =    new    (  )  ;", "editor . setAsText ( resource )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   Reader )  )  ;", "reader    =     (  ( Reader )     ( value )  )  ;", "assertTrue ( reader . ready (  )  )  ;", "}    finally    {", "if    ( reader    !  =    null )     {", "reader . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSunnyDay"], "fileName": "org.springframework.beans.propertyeditors.ReaderEditorTests"}, {"methodBody": ["METHOD_START", "{", "String   resource    =     \" classpath : bingo !  \"  ;", "editor    =    new    (  )  ;", "editor . setAsText ( resource )  ;", "}", "METHOD_END"], "methodName": ["testWhenResourceDoesNotExist"], "fileName": "org.springframework.beans.propertyeditors.ReaderEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  (  (  (  . BASE _ NAME )     +     \" Lang \"  )     +     \"  _ en \"  )  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull (  \" Returned   ResourceBundle   was   null    ( must   not   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,    value )  ;", "assertTrue (  \" Returned   object   was   not   a   ResourceBundle    ( must   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,     ( value   instanceof   ResourceBundle )  )  ;", "ResourceBundle   bundle    =     (  ( ResourceBundle )     ( value )  )  ;", "String   string    =    bundle . getString (  . MESSAGE _ KEY )  ;", "assertEquals (  \" yob \"  ,    string )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithBaseNameAndLanguageCode"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  (  (  (  . BASE _ NAME )     +     \" LangCountry \"  )     +     \"  _ en _ GB \"  )  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull (  \" Returned   ResourceBundle   was   null    ( must   not   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,    value )  ;", "assertTrue (  \" Returned   object   was   not   a   ResourceBundle    ( must   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,     ( value   instanceof   ResourceBundle )  )  ;", "ResourceBundle   bundle    =     (  ( ResourceBundle )     ( value )  )  ;", "String   string    =    bundle . getString (  . MESSAGE _ KEY )  ;", "assertEquals (  \" chav \"  ,    string )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithBaseNameLanguageAndCountryCode"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  (  (  . BASE _ NAME )     +     \"  _  \"  )  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull (  \" Returned   ResourceBundle   was   null    ( must   not   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,    value )  ;", "assertTrue (  \" Returned   object   was   not   a   ResourceBundle    ( must   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,     ( value   instanceof   ResourceBundle )  )  ;", "ResourceBundle   bundle    =     (  ( ResourceBundle )     ( value )  )  ;", "String   string    =    bundle . getString (  . MESSAGE _ KEY )  ;", "assertEquals (  . MESSAGE _ KEY ,    string )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithBaseNameThatEndsInDefaultSeparator"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithEmptyString"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  . BASE _ NAME )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull (  \" Returned   ResourceBundle   was   null    ( must   not   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,    value )  ;", "assertTrue (  \" Returned   object   was   not   a   ResourceBundle    ( must   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,     ( value   instanceof   ResourceBundle )  )  ;", "ResourceBundle   bundle    =     (  ( ResourceBundle )     ( value )  )  ;", "String   string    =    bundle . getString (  . MESSAGE _ KEY )  ;", "assertEquals (  . MESSAGE _ KEY ,    string )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithJustBaseName"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  \"  _  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithJustSeparatorString"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText ( null )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithNull"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  (  (  (  . BASE _ NAME )     +     \" LangCountryDialect \"  )     +     \"  _ en _ GB _ GLASGOW \"  )  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull (  \" Returned   ResourceBundle   was   null    ( must   not   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,    value )  ;", "assertTrue (  \" Returned   object   was   not   a   ResourceBundle    ( must   be   for   valid   setAsText (  .  .  )    call )  .  \"  ,     ( value   instanceof   ResourceBundle )  )  ;", "ResourceBundle   bundle    =     (  ( ResourceBundle )     ( value )  )  ;", "String   string    =    bundle . getString (  . MESSAGE _ KEY )  ;", "assertEquals (  \" ned \"  ,    string )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithTheKitchenSink"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "ResourceBundleEditor   editor    =    new   ResourceBundleEditor (  )  ;", "editor . setAsText (  \"           \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithWhiteSpaceString"], "fileName": "org.springframework.beans.propertyeditors.ResourceBundleEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  \"  ,  \"  ,    false ,    false )  ;", "editor . setAsText (  \"        0  ,  1        ,     2     \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "String [  ]    array    =     (  ( String [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;     +  + i )     {", "assertEquals (  3  ,    array [ i ]  . length (  )  )  ;", "assertEquals (  (  \"  \"     +    i )  ,    array [ i ]  . trim (  )  )  ;", "}", "assertEquals (  \"        0  ,  1        ,     2     \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["noTrim"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  )  ;", "editor . setAsText (  \"     0  ,  1     ,     2     \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "String [  ]    array    =     (  ( String [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;     +  + i )     {", "assertEquals (  (  \"  \"     +    i )  ,    array [ i ]  )  ;", "}", "assertEquals (  \"  0  ,  1  ,  2  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["trimByDefault"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  \"  ,  \"  ,     \"  \\ r \\ n \"  ,    false )  ;", "editor . setAsText (  \"  0  \\ r ,  1  ,  \\ n 2  \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertTrue (  ( value   instanceof   String [  ]  )  )  ;", "String [  ]    array    =     (  ( String [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;     +  + i )     {", "assertEquals (  (  \"  \"     +    i )  ,    array [ i ]  )  ;", "}", "assertEquals (  \"  0  ,  1  ,  2  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["withCharsToDelete"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  \"  :  \"  )  ;", "editor . setAsText (  \"  0  :  1  :  2  \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertTrue (  ( value   instanceof   String [  ]  )  )  ;", "String [  ]    array    =     (  ( String [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;     +  + i )     {", "assertEquals (  (  \"  \"     +    i )  ,    array [ i ]  )  ;", "}", "assertEquals (  \"  0  :  1  :  2  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["withCustomSeparator"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  )  ;", "editor . setAsText (  \"  0  ,  1  ,  2  \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertNotNull ( value )  ;", "assertTrue (  ( value   instanceof   String [  ]  )  )  ;", "String [  ]    array    =     (  ( String [  ]  )     ( value )  )  ;", "for    ( int   i    =     0  ;    i    <     ( array . length )  ;     +  + i )     {", "assertEquals (  (  \"  \"     +    i )  ,    array [ i ]  )  ;", "}", "assertEquals (  \"  0  ,  1  ,  2  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultSeparator"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  )  ;", "editor . setAsText (  \"  \"  )  ;", "Object   value    =    editor . getValue (  )  ;", "assertTrue (  ( value   instanceof   String [  ]  )  )  ;", "assertEquals (  0  ,     (  ( String [  ]  )     ( value )  )  . length )  ;", "}", "METHOD_END"], "methodName": ["withEmptyArray"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "StringArrayPropertyEditor   editor    =    new   StringArrayPropertyEditor (  \"  ,  \"  ,    true )  ;", "editor . setAsText (  \"  \"  )  ;", "assertNull ( editor . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withEmptyArrayAsNull"], "fileName": "org.springframework.beans.propertyeditors.StringArrayPropertyEditorTests"}, {"methodBody": ["METHOD_START", "{", "int   colonIndex    =    value . indexOf (  '  :  '  )  ;", "if    (  ( this . encode )     &  &     ( colonIndex    !  =     (  -  1  )  )  )     {", "int   fragmentIndex    =    value . indexOf (  '  #  '  ,     ( colonIndex    +     1  )  )  ;", "St   scheme    =    value . subst (  0  ,    colonIndex )  ;", "St   ssp    =    value . subst (  ( colonIndex    +     1  )  ,     ( fragmentIndex    >     0     ?    fragmentIndex    :    value . length (  )  )  )  ;", "St   fragment    =     ( fragmentIndex    >     0  )     ?    value . subst (  ( fragmentIndex    +     1  )  )     :    null ;", "return   new   URI ( scheme ,    ssp ,    fragment )  ;", "} else    {", "return   new   URI ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["createURI"], "fileName": "org.springframework.beans.propertyeditors.URIEditor"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor ( getClass (  )  . getClassLoader (  )  )  ;", "uriEditor . setAsText (  (  (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  )  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uri . toString (  )  ,    uriEditor . getAsText (  )  )  ;", "assertTrue (  (  !  ( uri . getScheme (  )  . startsWith (  \" classpath \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classpathURL"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "uriEditor . setAsText (  \" classpath : test . txt \"  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uri . toString (  )  ,    uriEditor . getAsText (  )  )  ;", "assertTrue ( uri . getScheme (  )  . startsWith (  \" classpath \"  )  )  ;", "}", "METHOD_END"], "methodName": ["classpathURLAsIs"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor ( getClass (  )  . getClassLoader (  )  )  ;", "uriEditor . setAsText (  (  (  (  (  \"       classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class       \"  )  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uri . toString (  )  ,    uriEditor . getAsText (  )  )  ;", "assertTrue (  (  !  ( uri . getScheme (  )  . startsWith (  \" classpath \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classpathURLWithWhitespace"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "uriEditor . setAsText ( uriSpec )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uriSpec ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["doTestURI"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor ( false )  ;", "uriEditor . setAsText (  \" http :  /  / example . com / spaces %  2  0 and %  2  0  % E 2  %  8  2  % AC \"  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uri . toString (  )  ,    uriEditor . getAsText (  )  )  ;", "assertEquals (  \" http :  /  / example . com / spaces %  2  0 and %  2  0  % E 2  %  8  2  % AC \"  ,    uri . toASCIIString (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeAlreadyEncodedURI"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "uriEditor . setAsText (  \" http :  /  / example . com / spaces   and    \\ u 2  0 ac \"  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals ( uri . toString (  )  ,    uriEditor . getAsText (  )  )  ;", "assertEquals (  \" http :  /  / example . com / spaces %  2  0 and %  2  0  % E 2  %  8  2  % AC \"  ,    uri . toASCIIString (  )  )  ;", "}", "METHOD_END"], "methodName": ["encodeURI"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "assertEquals (  \"  \"  ,    uriEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAsTextReturnsEmptyStringIfValueNotSet"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "uriEditor . setAsText ( null )  ;", "assertNull ( uriEditor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    uriEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["setAsTextWithNull"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "doTestURI (  \" mailto : juergen . hoeller @ interface 2  1  . com \"  )  ;", "}", "METHOD_END"], "methodName": ["standardURI"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "doTestURI (  \" http :  /  / www . springframework . org \"  )  ;", "}", "METHOD_END"], "methodName": ["standardURL"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "doTestURI (  \" http :  /  / www . springframework . org #  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["standardURLWithFragment"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   uriEditor    =    new   URIEditor (  )  ;", "uriEditor . setAsText (  \"       http :  /  / wwworg       \"  )  ;", "Object   value    =    uriEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URI )  )  ;", "URI   uri    =     (  ( URI )     ( value )  )  ;", "assertEquals (  \" http :  /  / wwworg \"  ,    uri . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["standardURLWithWhitespace"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "doTestURI (  \" gonna :  / freak / in / the / morning / freak / in / the . evening \"  )  ;", "}", "METHOD_END"], "methodName": ["withNonExistentResource"], "fileName": "org.springframework.beans.propertyeditors.URIEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "urlEditor . setAsText (  (  (  (  (  \" classpath :  \"     +     ( ClassUtils . classPackageAsResourcePath ( getClass (  )  )  )  )     +     \"  /  \"  )     +     ( ClassUtils . getShortName ( getClass (  )  )  )  )     +     \"  . class \"  )  )  ;", "Object   value    =    urlEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URL )  )  ;", "URL   url    =     (  ( URL )     ( value )  )  ;", "assertEquals ( url . toExternalForm (  )  ,    urlEditor . getAsText (  )  )  ;", "assertTrue (  (  !  ( url . getProtocol (  )  . startsWith (  \" classpath \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClasspathURL"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "new   URLEditor ( null )  ;", "}", "METHOD_END"], "methodName": ["testCtorWithNullResourceEditor"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "assertEquals (  \"  \"  ,    urlEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAsTextReturnsEmptyStringIfValueNotSet"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "urlEditor . setAsText ( null )  ;", "assertNull ( urlEditor . getValue (  )  )  ;", "assertEquals (  \"  \"  ,    urlEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSetAsTextWithNull"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "urlEditor . setAsText (  \" mailto : juergen . hoeller @ interface 2  1  . com \"  )  ;", "Object   value    =    urlEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URL )  )  ;", "URL   url    =     (  ( URL )     ( value )  )  ;", "assertEquals ( url . toExternalForm (  )  ,    urlEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardURI"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "urlEditor . setAsText (  \" http :  /  / wwworg \"  )  ;", "Object   value    =    urlEditor . getValue (  )  ;", "assertTrue (  ( value   instanceof   URL )  )  ;", "URL   url    =     (  ( URL )     ( value )  )  ;", "assertEquals ( url . toExternalForm (  )  ,    urlEditor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["testStandardURL"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyEditor   urlEditor    =    new   URLEditor (  )  ;", "urlEditor . setAsText (  \" gonna :  / freak / in / the / morning / freak / in / the . evening \"  )  ;", "}", "METHOD_END"], "methodName": ["testWithNonExistentResource"], "fileName": "org.springframework.beans.propertyeditors.URLEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  \" America / Chicago \"  )  ;", "ZoneId   zoneId    =     (  ( ZoneId )     ( editor . getValue (  )  )  )  ;", "assertNotNull (  \" The   zone   ID   should   not   be   null .  \"  ,    zoneId )  ;", "assertEquals (  \" The   zone   ID   is   not   correct .  \"  ,    ZoneId . of (  \" America / Chicago \"  )  ,    zoneId )  ;", "assertEquals (  \" The   text   version   is   not   correct .  \"  ,     \" America / Chicago \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["americaChicago"], "fileName": "org.springframework.beans.propertyeditors.ZoneIdEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setAsText (  \" America / Los _ Angeles \"  )  ;", "ZoneId   zoneId    =     (  ( ZoneId )     ( editor . getValue (  )  )  )  ;", "assertNotNull (  \" The   zone   ID   should   not   be   null .  \"  ,    zoneId )  ;", "assertEquals (  \" The   zone   ID   is   not   correct .  \"  ,    ZoneId . of (  \" America / Los _ Angeles \"  )  ,    zoneId )  ;", "assertEquals (  \" The   text   version   is   not   correct .  \"  ,     \" America / Los _ Angeles \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["americaLosAngeles"], "fileName": "org.springframework.beans.propertyeditors.ZoneIdEditorTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" The   returned   value   is   not   correct .  \"  ,     \"  \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNullAsText"], "fileName": "org.springframework.beans.propertyeditors.ZoneIdEditorTests"}, {"methodBody": ["METHOD_START", "{", "editor . setValue ( ZoneId . of (  \" America / New _ York \"  )  )  ;", "assertEquals (  \" The   text   version   is   not   correct .  \"  ,     \" America / New _ York \"  ,    editor . getAsText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValueAsText"], "fileName": "org.springframework.beans.propertyeditors.ZoneIdEditorTests"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   converter    =    getTypeConverter (  )  ;", "if    ( converter    !  =    null )     {", "String   targetMethod    =    getTargetMethod (  )  ;", "Method   match    =    null ;", "int   argCount    =    arguments . length ;", "Class <  ?  >    targetClass    =    getTargetClass (  )  ;", "Assert . state (  ( targetClass    !  =    null )  ,     \" No   target   class   set \"  )  ;", "Method [  ]    candidates    =    ReflectionUtils . getAllDeclaredMethods ( targetClass )  ;", "int   minTypeDiffWeight    =    Integer . MAX _ VALUE ;", "Object [  ]    argumentsToUse    =    null ;", "for    ( Method   candidate    :    candidates )     {", "if    ( candidate . getName (  )  . equals ( targetMethod )  )     {", "Class <  ?  >  [  ]    paramTypes    =    candidate . getParameterTypes (  )  ;", "if    (  ( paramTypes . length )     =  =    argCount )     {", "Object [  ]    convertedArguments    =    new   Object [ argCount ]  ;", "boolean   match    =    true ;", "for    ( int   j    =     0  ;     ( j    <    argCount )     &  &    match ;    j +  +  )     {", "try    {", "convertedArguments [ j ]     =    converter . convertIfNecessary ( arguments [ j ]  ,    paramTypes [ j ]  )  ;", "}    catch    ( TypeMismatchException   ex )     {", "match    =    false ;", "}", "}", "if    ( match )     {", "int   typeDiffWeight    =    getTypeDifferenceWeight ( paramTypes ,    convertedArguments )  ;", "if    ( typeDiffWeight    <    minTypeDiffWeight )     {", "minTypeDiffWeight    =    typeDiffWeight ;", "match    =    candidate ;", "argumentsToUse    =    convertedArguments ;", "}", "}", "}", "}", "}", "if    ( match    !  =    null )     {", "setArguments ( argumentsToUse )  ;", "return   match ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doFindMatchingMethod"], "fileName": "org.springframework.beans.support.ArgumentConvertingMethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleTypeConverter (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultTypeConverter"], "fileName": "org.springframework.beans.support.ArgumentConvertingMethodInvoker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( this . typeConverter )     =  =    null )     &  &     ( this . useDefaultConverter )  )     {", "this . typeConverter    =    getDefaultTypeConverter (  )  ;", "}", "return   this . typeConverter ;", "}", "METHOD_END"], "methodName": ["getTypeConverter"], "fileName": "org.springframework.beans.support.ArgumentConvertingMethodInvoker"}, {"methodBody": ["METHOD_START", "{", "TypeConverter   converter    =    getTypeConverter (  )  ;", "if    (  !  ( converter   instanceof   PropertyEditorRegistry )  )     {", "throw   new   IllegalStateException (  (  \" TypeConverter   does   not   implement   PropertyEditorRegistry   interface :     \"     +    converter )  )  ;", "}", "(  ( PropertyEditorRegistry )     ( converter )  )  . registerCustomEditor ( requiredType ,    propertyEditor )  ;", "}", "METHOD_END"], "methodName": ["registerCustomEditor"], "fileName": "org.springframework.beans.support.ArgumentConvertingMethodInvoker"}, {"methodBody": ["METHOD_START", "{", "this . typeConverter    =    typeConverter ;", "this . useDefauler    =    typeConverter    =  =    null ;", "}", "METHOD_END"], "methodName": ["setTypeConverter"], "fileName": "org.springframework.beans.support.ArgumentConvertingMethodInvoker"}, {"methodBody": ["METHOD_START", "{", "return   this . toggleAscendingOnProperty ;", "}", "METHOD_END"], "methodName": ["isToggleAscendingOnProperty"], "fileName": "org.springframework.beans.support.MutableSortDefinition"}, {"methodBody": ["METHOD_START", "{", "this . ascending    =    ascending ;", "}", "METHOD_END"], "methodName": ["setAscending"], "fileName": "org.springframework.beans.support.MutableSortDefinition"}, {"methodBody": ["METHOD_START", "{", "this . ignoreCase    =    ignoreCase ;", "}", "METHOD_END"], "methodName": ["setIgnoreCase"], "fileName": "org.springframework.beans.support.MutableSortDefinition"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( StringUtils . hasLength ( property )  )  )     {", "this . property    =     \"  \"  ;", "} else    {", "if    ( isToggleAscendingOnProperty (  )  )     {", "this . ascending    =     (  !  ( property . equals ( this . property )  )  )     |  |     (  !  ( this . ascending )  )  ;", "}", "this . property    =    property ;", "}", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.springframework.beans.support.MutableSortDefinition"}, {"methodBody": ["METHOD_START", "{", "this . toggleAscendingOnProperty    =    toggleAscendingOnProperty ;", "}", "METHOD_END"], "methodName": ["setToggleAscendingOnProperty"], "fileName": "org.springframework.beans.support.MutableSortDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   MutableSortDefinition ( sort )  ;", "}", "METHOD_END"], "methodName": ["copySortDefinition"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "PropertyComparator . sort ( source ,    sort )  ;", "}", "METHOD_END"], "methodName": ["doSort"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return    ( getPageSize (  )  )     *     ( getPage (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirstElementOnPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   Math . max (  0  ,     (  ( getPage (  )  )     -     (  ( getMaxLinkedPages (  )  )     /     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirstLinkedPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "int   endIndex    =     ( getPageSize (  )  )     *     (  ( getPage (  )  )     +     1  )  ;", "int   size    =    getNrOfElements (  )  ;", "return    ( endIndex    >    size    ?    size    :    endIndex )     -     1  ;", "}", "METHOD_END"], "methodName": ["getLastElementOnPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   Math . min (  (  (  ( getFirstLinkedPage (  )  )     +     ( getMaxLinkedPages (  )  )  )     -     1  )  ,     (  ( getPageCount (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getLastLinkedPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . maxLinkedPages ;", "}", "METHOD_END"], "methodName": ["getMaxLinkedPages"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   getSource (  )  . size (  )  ;", "}", "METHOD_END"], "methodName": ["getNrOfElements"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "this . newPageSet    =    false ;", "if    (  ( this . page )     >  =     ( getPageCount (  )  )  )     {", "this . page    =     ( getPageCount (  )  )     -     1  ;", "}", "return   this . page ;", "}", "METHOD_END"], "methodName": ["getPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "float   nrOfPages    =     (  ( float )     ( getNrOfElements (  )  )  )     /     ( getPageSize (  )  )  ;", "return    (  ( int )     (  ( nrOfPages    >     (  ( int )     ( nrOfPages )  )  )     |  |     ( nrOfPages    =  =     0  .  0  )     ?    nrOfPages    +     1     :    nrOfPages )  )  ;", "}", "METHOD_END"], "methodName": ["getPageCount"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   getSource (  )  . subList ( getFirstElementOnPage (  )  ,     (  ( getLastElementOnPage (  )  )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getPageList"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . pageSize ;", "}", "METHOD_END"], "methodName": ["getPageSize"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . refreshDate ;", "}", "METHOD_END"], "methodName": ["getRefreshDate"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . sort ;", "}", "METHOD_END"], "methodName": ["getSort"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return   this . source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return    ( getPage (  )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isFirstPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "return    ( getPage (  )  )     =  =     (  ( getPageCount (  )  )     -     1  )  ;", "}", "METHOD_END"], "methodName": ["isLastPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isLastPage (  )  )  )     {", "( this . page )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["nextPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isFirstPage (  )  )  )     {", "( this . page )  -  -  ;", "}", "}", "METHOD_END"], "methodName": ["previousPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "Sefinition   s =    getS )  ;", "if    (  ( s !  =    null )     &  &     (  !  ( sequals ( this . ssed )  )  )  )     {", "this . ssed    =    copySefinition ( s ;", "doSgetSource (  )  ,    s ;", "setPage (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["resort"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "this . maxLinkedPages    =    maxLinkedPages ;", "}", "METHOD_END"], "methodName": ["setMaxLinkedPages"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "this . page    =    page ;", "this . newSet    =    true ;", "}", "METHOD_END"], "methodName": ["setPage"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "if    ( pageSize    !  =     ( this . pageSize )  )     {", "this . pageSize    =    pageSize ;", "if    (  !  ( this . newSet )  )     {", "this . page    =     0  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setPageSize"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "this . sort    =    sort ;", "}", "METHOD_END"], "methodName": ["setSort"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "Assert . notNull ( source ,     \" Source   List   must   not   be   null \"  )  ;", "this . source    =    source ;", "this . refreshDate    =    new   Date (  )  ;", "this . sortUsed    =    null ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.springframework.beans.support.PagedListHolder"}, {"methodBody": ["METHOD_START", "{", "Assume . group ( LONG _ RUNNING )  ;", "TestBean   tb 1     =    new   TestBean (  )  ;", "tb 1  . setName (  \" eva \"  )  ;", "tb 1  . setAge (  2  5  )  ;", "TestBean   tb 2     =    new   TestBean (  )  ;", "tb 2  . setName (  \" juergen \"  )  ;", "tb 2  . setAge (  9  9  )  ;", "TestBean   tb 3     =    new   TestBean (  )  ;", "tb 3  . setName (  \" Rod \"  )  ;", "tb 3  . setAge (  3  2  )  ;", "List   tbs    =    new   ArrayList (  )  ;", "tbs . add ( tb 1  )  ;", "tbs . add ( tb 2  )  ;", "tbs . add ( tb 3  )  ;", "holder    =    new    ( tbs )  ;", "assertTrue (  \" Correct   source \"  ,     (  ( holder . getSource (  )  )     =  =    tbs )  )  ;", "assertTrue (  \" Correct   number   of   elements \"  ,     (  ( holder . getNrOfElements (  )  )     =  =     3  )  )  ;", "assertTrue (  \" Correct   number   of   pages \"  ,     (  ( holder . getPageCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   size \"  ,     (  ( holder . getPageSize (  )  )     =  =     (  . DEFAULT _ PAGE _ SIZE )  )  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertTrue (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   list   size \"  ,     (  ( holder . getPageList (  )  . size (  )  )     =  =     3  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 2  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  2  )  )     =  =    tb 3  )  )  ;", "holder . setPageSize (  2  )  ;", "assertTrue (  \" Correct   number   of   pages \"  ,     (  ( holder . getPageCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   size \"  ,     (  ( holder . getPageSize (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertFalse (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Correct   last   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   list   size \"  ,     (  ( holder . getPageList (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 2  )  )  ;", "holder . setPage (  1  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     1  )  )  ;", "assertFalse (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertTrue (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   last   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   list   size \"  ,     (  ( holder . getPageList (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 3  )  )  ;", "holder . setPageSize (  3  )  ;", "assertTrue (  \" Correct   number   of   pages \"  ,     (  ( holder . getPageCount (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   size \"  ,     (  ( holder . getPageSize (  )  )     =  =     3  )  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertTrue (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Correct   last   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     2  )  )  ;", "holder . setPage (  1  )  ;", "holder . setPageSize (  2  )  ;", "assertTrue (  \" Correct   number   of   pages \"  ,     (  ( holder . getPageCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   size \"  ,     (  ( holder . getPageSize (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     1  )  )  ;", "assertFalse (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertTrue (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   last   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     2  )  )  ;", "holder . setPageSize (  2  )  ;", "holder . setPage (  1  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setProperty (  \" name \"  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setIgnoreCase ( false )  ;", "holder . resort (  )  ;", "assertTrue (  \" Correct   source \"  ,     (  ( holder . getSource (  )  )     =  =    tbs )  )  ;", "assertTrue (  \" Correct   number   of   elements \"  ,     (  ( holder . getNrOfElements (  )  )     =  =     3  )  )  ;", "assertTrue (  \" Correct   number   of   pages \"  ,     (  ( holder . getPageCount (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   size \"  ,     (  ( holder . getPageSize (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   number \"  ,     (  ( holder . getPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" First   page \"  ,    holder . isFirstPage (  )  )  ;", "assertFalse (  \" Last   page \"  ,    holder . isLastPage (  )  )  ;", "assertTrue (  \" Correct   first   element \"  ,     (  ( holder . getFirstElementOnPage (  )  )     =  =     0  )  )  ;", "assertTrue (  \" Correct   last   element \"  ,     (  ( holder . getLastElementOnPage (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   list   size \"  ,     (  ( holder . getPageList (  )  . size (  )  )     =  =     2  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 3  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 1  )  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setProperty (  \" name \"  )  ;", "holder . resort (  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 2  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 1  )  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setProperty (  \" name \"  )  ;", "holder . resort (  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 3  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 1  )  )  ;", "holder . setPage (  1  )  ;", "assertTrue (  \" Correct   page   list   size \"  ,     (  ( holder . getPageList (  )  . size (  )  )     =  =     1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 2  )  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setProperty (  \" age \"  )  ;", "holder . resort (  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 3  )  )  ;", "(  ( MutableSortDefinition )     ( holder . getSort (  )  )  )  . setIgnoreCase ( true )  ;", "holder . resort (  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  0  )  )     =  =    tb 1  )  )  ;", "assertTrue (  \" Correct   page   list   contents \"  ,     (  ( holder . getPageList (  )  . get (  1  )  )     =  =    tb 3  )  )  ;", "holder . nextPage (  )  ;", "assertEquals (  1  ,    holder . getPage (  )  )  ;", "holder . previousPage (  )  ;", "assertEquals (  0  ,    holder . getPage (  )  )  ;", "holder . nextPage (  )  ;", "assertEquals (  1  ,    holder . getPage (  )  )  ;", "holder . nextPage (  )  ;", "assertEquals (  1  ,    holder . getPage (  )  )  ;", "holder . previousPage (  )  ;", "assertEquals (  0  ,    holder . getPage (  )  )  ;", "holder . previousPage (  )  ;", "assertEquals (  0  ,    holder . getPage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPagedListHolder"], "fileName": "org.springframework.beans.support.PagedListHolderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "this . beanWrapper . setWrappedInstance ( obj )  ;", "return   this . beanWrapper . getPropertyValue ( this . sortDefinition . getProperty (  )  )  ;", "}    catch    ( BeansException   ex )     {", "logger . info (  \"    could   not   access   property    -    treating   as   null   for   sorting \"  ,    ex )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyValue"], "fileName": "org.springframework.beans.support.PropertyComparator"}, {"methodBody": ["METHOD_START", "{", "return   this . sortDefinition ;", "}", "METHOD_END"], "methodName": ["getSortDefinition"], "fileName": "org.springframework.beans.support.PropertyComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( sortDefinition . getProperty (  )  )  )     {", "Arrays . sort ( source ,    new    <  >  ( sortDefinition )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.beans.support.PropertyComparator"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . hasText ( sortDefinition . getProperty (  )  )  )     {", "source . sort ( new    <  >  ( sortDefinition )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.springframework.beans.support.PropertyComparator"}, {"methodBody": ["METHOD_START", "{", "Comparator < PropertyComparatorTests . Dog >    c    =    new   PropertyComparator <  >  (  \" lastName \"  ,    false ,    true )  ;", "PropertyComparatorTests . Dog   dog 1     =    new   PropertyComparatorTests . Dog (  )  ;", "dog 1  . setFirstName (  \" macy \"  )  ;", "dog 1  . setLastName (  \" grayspots \"  )  ;", "PropertyComparatorTests . Dog   dog 2     =    new   PropertyComparatorTests . Dog (  )  ;", "dog 2  . setFirstName (  \" biscuit \"  )  ;", "dog 2  . setLastName (  \" grayspots \"  )  ;", "assertTrue (  (  ( c . compare ( dog 1  ,    dog 2  )  )     =  =     0  )  )  ;", "c    =    c . thenComparing ( new   PropertyComparator <  >  (  \" firstName \"  ,    false ,    true )  )  ;", "assertTrue (  (  ( c . compare ( dog 1  ,    dog 2  )  )     >     0  )  )  ;", "dog 2  . setLastName (  \" konikk   dog \"  )  ;", "assertTrue (  (  ( c . compare ( dog 2  ,    dog 1  )  )     >     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testChainedComparators"], "fileName": "org.springframework.beans.support.PropertyComparatorTests"}, {"methodBody": ["METHOD_START", "{", "Comparator < PropertyComparatorTests . Dog >    c    =    new   PropertyComparator < PropertyComparatorTests . Dog >  (  \" lastName \"  ,    false ,    true )  . thenComparing ( new   PropertyComparator <  >  (  \" firstName \"  ,    false ,    true )  )  ;", "PropertyComparatorTests . Dog   dog 1     =    new   PropertyComparatorTests . Dog (  )  ;", "dog 1  . setFirstName (  \" macy \"  )  ;", "dog 1  . setLastName (  \" grayspots \"  )  ;", "PropertyComparatorTests . Dog   dog 2     =    new   PropertyComparatorTests . Dog (  )  ;", "dog 2  . setFirstName (  \" biscuit \"  )  ;", "dog 2  . setLastName (  \" grayspots \"  )  ;", "assertTrue (  (  ( c . compare ( dog 1  ,    dog 2  )  )     >     0  )  )  ;", "c    =    c . reversed (  )  ;", "assertTrue (  (  ( c . compare ( dog 1  ,    dog 2  )  )     <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testChainedComparatorsReversed"], "fileName": "org.springframework.beans.support.PropertyComparatorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyComparatorTests . Dog   dog    =    new   PropertyComparatorTests . Dog (  )  ;", "dog . setNickName (  \" mace \"  )  ;", "PropertyComparatorTests . Dog   dog 2     =    new   PropertyComparatorTests . Dog (  )  ;", "dog 2  . setNickName (  \" biscy \"  )  ;", "PropertyComparator < PropertyComparatorTests . Dog >    c    =    new   PropertyComparator <  >  (  \" nickName \"  ,    false ,    true )  ;", "assertTrue (  (  ( c . compare ( dog ,    dog 2  )  )     >     0  )  )  ;", "assertTrue (  (  ( c . compare ( dog ,    dog )  )     =  =     0  )  )  ;", "assertTrue (  (  ( c . compare ( dog 2  ,    dog )  )     <     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyComparator"], "fileName": "org.springframework.beans.support.PropertyComparatorTests"}, {"methodBody": ["METHOD_START", "{", "PropertyComparatorTests . Dog   dog    =    new   PropertyComparatorTests . Dog (  )  ;", "PropertyComparatorTests . Dog   dog 2     =    new   PropertyComparatorTests . Dog (  )  ;", "PropertyComparator < PropertyComparatorTests . Dog >    c    =    new   PropertyComparator <  >  (  \" nickName \"  ,    false ,    true )  ;", "assertTrue (  (  ( c . compare ( dog ,    dog 2  )  )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyComparatorNulls"], "fileName": "org.springframework.beans.support.PropertyComparatorTests"}, {"methodBody": ["METHOD_START", "{", "return   someProperty ;", "}", "METHOD_END"], "methodName": ["getSomeProperty"], "fileName": "org.springframework.beans.support.ProtectedBaseBean"}, {"methodBody": ["METHOD_START", "{", "this . someProperty    =    someProperty ;", "}", "METHOD_END"], "methodName": ["setSomeProperty"], "fileName": "org.springframework.beans.support.ProtectedBaseBean"}, {"methodBody": ["METHOD_START", "{", "if    ( registry   instanceof   PropertyEditorRegistrySupport )     {", "(  ( PropertyEditorRegistrySupport )     ( registry )  )  . overrideDefaultEditor ( requiredType ,    editor )  ;", "} else    {", "registry . registerCustomEditor ( requiredType ,    editor )  ;", "}", "}", "METHOD_END"], "methodName": ["doRegisterEditor"], "fileName": "org.springframework.beans.support.ResourceEditorRegistrar"}, {"methodBody": ["METHOD_START", "{", "List < AliasDefinition >    aliases    =    this . aliasMap . get ( beanName )  ;", "return   aliases    !  =    null    ?    ons . unmodifiableList ( aliases )     :    null ;", "}", "METHOD_END"], "methodName": ["getAliases"], "fileName": "org.springframework.tests.beans.CollectingReaderEventListener"}, {"methodBody": ["METHOD_START", "{", "return   this . componentDefinitions . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getComponentDefinition"], "fileName": "org.springframework.tests.beans.CollectingReaderEventListener"}, {"methodBody": ["METHOD_START", "{", "Collection < ComponentDefinition >    collection    =    this . componentDefinitions . values (  )  ;", "return   collection . toArray ( new   ComponentDefinition [ collection . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getComponentDefinitions"], "fileName": "org.springframework.tests.beans.CollectingReaderEventListener"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . defaults )  ;", "}", "METHOD_END"], "methodName": ["getDefaults"], "fileName": "org.springframework.tests.beans.CollectingReaderEventListener"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( this . imports )  ;", "}", "METHOD_END"], "methodName": ["getImports"], "fileName": "org.springframework.tests.beans.CollectingReaderEventListener"}, {"methodBody": ["METHOD_START", "{", "return   getAge (  )  ;", "}", "METHOD_END"], "methodName": ["age"], "fileName": "org.springframework.tests.sample.beans.AgeHolder"}, {"methodBody": ["METHOD_START", "{", "return   bool 2  ;", "}", "METHOD_END"], "methodName": ["getBool2"], "fileName": "org.springframework.tests.sample.beans.BooleanTestBean"}, {"methodBody": ["METHOD_START", "{", "return   bool 1  ;", "}", "METHOD_END"], "methodName": ["isBool1"], "fileName": "org.springframework.tests.sample.beans.BooleanTestBean"}, {"methodBody": ["METHOD_START", "{", "this . bool 1     =    bool 1  ;", "}", "METHOD_END"], "methodName": ["setBool1"], "fileName": "org.springframework.tests.sample.beans.BooleanTestBean"}, {"methodBody": ["METHOD_START", "{", "this . bool 2     =    bool 2  ;", "}", "METHOD_END"], "methodName": ["setBool2"], "fileName": "org.springframework.tests.sample.beans.BooleanTestBean"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse ;", "}", "METHOD_END"], "methodName": ["getSpouse"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . age    =    age ;", "}", "METHOD_END"], "methodName": ["setAge"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "this . spouse    =    spouse ;", "}", "METHOD_END"], "methodName": ["setSpouse"], "fileName": "org.springframework.tests.sample.beans.DependenciesBean"}, {"methodBody": ["METHOD_START", "{", "return   new   DerivedTestBean ( names )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.springframework.tests.sample.beans.DerivedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . initialized    =    true ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.springframework.tests.sample.beans.DerivedTestBean"}, {"methodBody": ["METHOD_START", "{", "setSpouse ( spouse )  ;", "}", "METHOD_END"], "methodName": ["setActualSpouse"], "fileName": "org.springframework.tests.sample.beans.DerivedTestBean"}, {"methodBody": ["METHOD_START", "{", "setSpouse ( new   TestBean ( name )  )  ;", "}", "METHOD_END"], "methodName": ["setSpouseRef"], "fileName": "org.springframework.tests.sample.beans.DerivedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   initialized ;", "}", "METHOD_END"], "methodName": ["wasInitialized"], "fileName": "org.springframework.tests.sample.beans.DerivedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   age ;", "}", "METHOD_END"], "methodName": ["getAge"], "fileName": "org.springframework.tests.sample.beans.DummyBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.tests.sample.beans.DummyBean"}, {"methodBody": ["METHOD_START", "{", "return   spouse ;", "}", "METHOD_END"], "methodName": ["getSpouse"], "fileName": "org.springframework.tests.sample.beans.DummyBean"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.springframework.tests.sample.beans.DummyBean"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   otherTestBean ;", "}", "METHOD_END"], "methodName": ["getOtherTestBean"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   postProcessed ;", "}", "METHOD_END"], "methodName": ["isPostProcessed"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "DummyFactory . prototypeCreated    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . otherTestBean    =    otherTestBean ;", "thisBean . setSpouse ( otherTestBean )  ;", "}", "METHOD_END"], "methodName": ["setOtherTestBean"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . postProcessed    =    postProcessed ;", "}", "METHOD_END"], "methodName": ["setPostProcessed"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   initialized ;", "}", "METHOD_END"], "methodName": ["wasInitialized"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   DummyFactory . prototypeCreated ;", "}", "METHOD_END"], "methodName": ["wasPrototypeCreated"], "fileName": "org.springframework.tests.sample.beans.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( someFlag ,    collectionMap )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( longMap )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( integerSet ,    shortMap )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( map ,    shortMap )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( shortMap ,    resource )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( integerSet )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   new   GenericBean ( integerSet ,    resourceList )  ;", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   collectionMap ;", "}", "METHOD_END"], "methodName": ["getCollectionMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   customEnum ;", "}", "METHOD_END"], "methodName": ["getCustomEnum"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   customEnumArray ;", "}", "METHOD_END"], "methodName": ["getCustomEnumArray"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   customEnumSet ;", "}", "METHOD_END"], "methodName": ["getCustomEnumSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   customEnumSet ;", "}", "METHOD_END"], "methodName": ["getCustomEnumSetMismatch"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   genericListProperty ;", "}", "METHOD_END"], "methodName": ["getGenericListProperty"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   genericProperty ;", "}", "METHOD_END"], "methodName": ["getGenericProperty"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   integerSet ;", "}", "METHOD_END"], "methodName": ["getIntegerSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   listOfArrays ;", "}", "METHOD_END"], "methodName": ["getListOfArrays"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   listOfLists ;", "}", "METHOD_END"], "methodName": ["getListOfLists"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   listOfMaps ;", "}", "METHOD_END"], "methodName": ["getListOfMaps"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   longMap ;", "}", "METHOD_END"], "methodName": ["getLongMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   mapOfLists ;", "}", "METHOD_END"], "methodName": ["getMapOfLists"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   mapOfMaps ;", "}", "METHOD_END"], "methodName": ["getMapOfMaps"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   numberSet ;", "}", "METHOD_END"], "methodName": ["getNumberSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   plainMap ;", "}", "METHOD_END"], "methodName": ["getPlainMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   resourceList ;", "}", "METHOD_END"], "methodName": ["getResourceList"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   shortMap ;", "}", "METHOD_END"], "methodName": ["getShortMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   standardEnumMap ;", "}", "METHOD_END"], "methodName": ["getStandardEnumMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   standardEnumSet ;", "}", "METHOD_END"], "methodName": ["getStandardEnumSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   testBeanList ;", "}", "METHOD_END"], "methodName": ["getTestBeanList"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   testBeanSet ;", "}", "METHOD_END"], "methodName": ["getTestBeanSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . collectionMap    =    collectionMap ;", "}", "METHOD_END"], "methodName": ["setCollectionMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . customEnum    =    customEnum ;", "}", "METHOD_END"], "methodName": ["setCustomEnum"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . customEnumArray    =    customEnum ;", "}", "METHOD_END"], "methodName": ["setCustomEnumArray"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . customEnumSet    =    customEnumSet ;", "}", "METHOD_END"], "methodName": ["setCustomEnumSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . customEnumSet    =    new   HashSet <  >  ( customEnumSet . size (  )  )  ;", "for    ( Iterator < St >    iterator    =    customEnumSet . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "this . customEnumSet . add ( CustomEnum . valueOf ( iterator . next (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setCustomEnumSetMismatch"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . genericListProperty    =    genericListProperty ;", "}", "METHOD_END"], "methodName": ["setGenericListProperty"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . genericProperty    =    genericProperty ;", "}", "METHOD_END"], "methodName": ["setGenericProperty"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . integerSet    =    integerSet ;", "}", "METHOD_END"], "methodName": ["setIntegerSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . listOfArrays    =    listOfArrays ;", "}", "METHOD_END"], "methodName": ["setListOfArrays"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . listOfLists    =    listOfLists ;", "}", "METHOD_END"], "methodName": ["setListOfLists"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . listOfMaps    =    listOfMaps ;", "}", "METHOD_END"], "methodName": ["setListOfMaps"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . longMap    =    longMap ;", "}", "METHOD_END"], "methodName": ["setLongMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . mapOfLists    =    mapOfLists ;", "}", "METHOD_END"], "methodName": ["setMapOfLists"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . mapOfMaps    =    mapOfMaps ;", "}", "METHOD_END"], "methodName": ["setMapOfMaps"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . numberSet    =    numberSet ;", "}", "METHOD_END"], "methodName": ["setNumberSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . resourceList    =    resourceList ;", "}", "METHOD_END"], "methodName": ["setResourceList"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . shortMap    =    shortMap ;", "}", "METHOD_END"], "methodName": ["setShortMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . standardEnumMap    =    standardEnumMap ;", "}", "METHOD_END"], "methodName": ["setStandardEnumMap"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . standardEnumSet    =    standardEnumSet ;", "}", "METHOD_END"], "methodName": ["setStandardEnumSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . testBeanList    =    testBeanList ;", "}", "METHOD_END"], "methodName": ["setTestBeanList"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "this . testBeanSet    =    testBeanSet ;", "}", "METHOD_END"], "methodName": ["setTestBeanSet"], "fileName": "org.springframework.tests.sample.beans.GenericBean"}, {"methodBody": ["METHOD_START", "{", "return   classArray ;", "}", "METHOD_END"], "methodName": ["getClassArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   classList ;", "}", "METHOD_END"], "methodName": ["getClassList"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   concurrentSet ;", "}", "METHOD_END"], "methodName": ["getConcurrentSet"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   identityMap ;", "}", "METHOD_END"], "methodName": ["getIdentityMap"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   intArray ;", "}", "METHOD_END"], "methodName": ["getIntegerArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   objectArray ;", "}", "METHOD_END"], "methodName": ["getObjectArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   props ;", "}", "METHOD_END"], "methodName": ["getProps"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   set ;", "}", "METHOD_END"], "methodName": ["getSet"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . classArray    =    classArray ;", "}", "METHOD_END"], "methodName": ["setClassArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . classList    =    classList ;", "}", "METHOD_END"], "methodName": ["setClassList"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . concurrentSet    =    concurrentSet ;", "}", "METHOD_END"], "methodName": ["setConcurrentSet"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . identityMap    =    identityMap ;", "}", "METHOD_END"], "methodName": ["setIdentityMap"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "intArray    =    is ;", "}", "METHOD_END"], "methodName": ["setIntegerArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . map    =    map ;", "}", "METHOD_END"], "methodName": ["setMap"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . objectArray    =    objectArray ;", "}", "METHOD_END"], "methodName": ["setObjectArray"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . props    =    props ;", "}", "METHOD_END"], "methodName": ["setProps"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "this . set    =    set ;", "}", "METHOD_END"], "methodName": ["setSet"], "fileName": "org.springframework.tests.sample.beans.HasMap"}, {"methodBody": ["METHOD_START", "{", "return   array ;", "}", "METHOD_END"], "methodName": ["getArray"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   collection ;", "}", "METHOD_END"], "methodName": ["getCollection"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   list ;", "}", "METHOD_END"], "methodName": ["getList"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   map ;", "}", "METHOD_END"], "methodName": ["getMap"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   set ;", "}", "METHOD_END"], "methodName": ["getSet"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   sortedMap ;", "}", "METHOD_END"], "methodName": ["getSortedMap"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   sortedSet ;", "}", "METHOD_END"], "methodName": ["getSortedSet"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "TestBean   tb 0     =    new   TestBean (  \" name 0  \"  ,     0  )  ;", "TestBean   tb 1     =    new   TestBean (  \" name 1  \"  ,     0  )  ;", "TestBean   tb 2     =    new   TestBean (  \" name 2  \"  ,     0  )  ;", "TestBean   tb 3     =    new   TestBean (  \" name 3  \"  ,     0  )  ;", "TestBean   tb 4     =    new   TestBean (  \" name 4  \"  ,     0  )  ;", "TestBean   tb 5     =    new   TestBean (  \" name 5  \"  ,     0  )  ;", "TestBean   tb 6     =    new   TestBean (  \" name 6  \"  ,     0  )  ;", "TestBean   tb 7     =    new   TestBean (  \" name 7  \"  ,     0  )  ;", "TestBean   tbX    =    new   TestBean (  \" nameX \"  ,     0  )  ;", "TestBean   tbY    =    new   TestBean (  \" nameY \"  ,     0  )  ;", "this . array    =    new   TestBean [  ]  {    tb 0  ,    tb 1     }  ;", "this . list    =    new   ArrayList <  >  (  )  ;", "this . list . add ( tb 2  )  ;", "this . list . add ( tb 3  )  ;", "this . set    =    new   TreeSet <  >  (  )  ;", "this . set . add ( tb 6  )  ;", "this . set . add ( tb 7  )  ;", "this . map    =    new   HashMap <  >  (  )  ;", "this . map . put (  \" key 1  \"  ,    tb 4  )  ;", "this . map . put (  \" key 2  \"  ,    tb 5  )  ;", "this . map . put (  \" key .  3  \"  ,    tb 5  )  ;", "List   list    =    new   ArrayList (  )  ;", "list . add ( tbX )  ;", "list . add ( tbY )  ;", "this . map . put (  \" key 4  \"  ,    list )  ;", "}", "METHOD_END"], "methodName": ["populate"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . array    =    array ;", "}", "METHOD_END"], "methodName": ["setArray"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . collection    =    collection ;", "}", "METHOD_END"], "methodName": ["setCollection"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . list    =    list ;", "}", "METHOD_END"], "methodName": ["setList"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . map    =    map ;", "}", "METHOD_END"], "methodName": ["setMap"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . set    =    set ;", "}", "METHOD_END"], "methodName": ["setSet"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . sortedMap    =    sortedMap ;", "}", "METHOD_END"], "methodName": ["setSortedMap"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "this . sortedSet    =    sortedSet ;", "}", "METHOD_END"], "methodName": ["setSortedSet"], "fileName": "org.springframework.tests.sample.beans.IndexedTestBean"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  !  ( this . inited )  )     |  |     (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )  )     |  |     (  !  ( this . postProcessedAfterInit )  )  )     {", "throw   new   RuntimeException (  \" Factory   didn ' t   initialize   l   object   correctly \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["businessMethod"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" Factory   didn ' t   call   afterPropertiesSet   before   declared   init   method \"  )  ;", "}", "if    ( this . initedViaDeclaredInitMethod )     {", "throw   new   RuntimeException (  \" Factory   called   declared   init   method   twice \"  )  ;", "}", "this . initedViaDeclaredInitMethod    =    true ;", "}", "METHOD_END"], "methodName": ["declaredInitMethod"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   destroyed ;", "}", "METHOD_END"], "methodName": ["isDestroyed"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "return   initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["isInitMethodDeclared"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )     {", "throw   new   RuntimeException (  \" Factory   called   postProcessAfterInit   before   afterPropertiesSet \"  )  ;", "}", "if    (  ( this . initMethodDeclared )     &  &     (  !  ( this . initedViaDeclaredInitMethod )  )  )     {", "throw   new   RuntimeException (  \" Factory   called   postProcessAfterInit   before   call   declared   init   method \"  )  ;", "}", "if    ( this . postProcessedAfterInit )     {", "throw   new   RuntimeException (  \" Factory   called   postProcessAfterInit   twice \"  )  ;", "}", "this . postProcessedAfterInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessAfterInit"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . inited )     |  |     ( this . initedViaDeclaredInitMethod )  )     {", "throw   new   RuntimeException (  \" Factory   called   postProcessBeforeInit   after   afterPropertiesSet \"  )  ;", "}", "if    ( this . postProcessedBeforeInit )     {", "throw   new   RuntimeException (  \" Factory   called   postProcessBeforeInit   twice \"  )  ;", "}", "this . postProcessedBeforeInit    =    true ;", "}", "METHOD_END"], "methodName": ["postProcessBeforeInit"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "this . initMethodDeclared    =    initMethodDeclared ;", "}", "METHOD_END"], "methodName": ["setInitMethodDeclared"], "fileName": "org.springframework.tests.sample.beans.LifecycleBean"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( this . inited )  )", "throw   new   RuntimeException (  \" Factory   didn ' t   call   afterPropertiesSet (  )    on      object \"  )  ;", "}", "METHOD_END"], "methodName": ["businessMethod"], "fileName": "org.springframework.tests.sample.beans.MustBeInitialized"}, {"methodBody": ["METHOD_START", "{", "this . company    =     ( company    !  =    null )     ?    company    :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["setCompany"], "fileName": "org.springframework.tests.sample.beans.NestedTestBean"}, {"methodBody": ["METHOD_START", "{", "return   bigDecimal ;", "}", "METHOD_END"], "methodName": ["getBigDecimal"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   bigInteger ;", "}", "METHOD_END"], "methodName": ["getBigInteger"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   double 1  ;", "}", "METHOD_END"], "methodName": ["getDouble1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   double 2  ;", "}", "METHOD_END"], "methodName": ["getDouble2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   float 1  ;", "}", "METHOD_END"], "methodName": ["getFloat1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   float 2  ;", "}", "METHOD_END"], "methodName": ["getFloat2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   int 1  ;", "}", "METHOD_END"], "methodName": ["getInt1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   int 2  ;", "}", "METHOD_END"], "methodName": ["getInt2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   long 1  ;", "}", "METHOD_END"], "methodName": ["getLong1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   long 2  ;", "}", "METHOD_END"], "methodName": ["getLong2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   short 1  ;", "}", "METHOD_END"], "methodName": ["getShort1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   short 2  ;", "}", "METHOD_END"], "methodName": ["getShort2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . bigDecimal    =    bigDecimal ;", "}", "METHOD_END"], "methodName": ["setBigDecimal"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . bigInteger    =    bigInteger ;", "}", "METHOD_END"], "methodName": ["setBigInteger"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . double 1     =    double 1  ;", "}", "METHOD_END"], "methodName": ["setDouble1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . double 2     =    double 2  ;", "}", "METHOD_END"], "methodName": ["setDouble2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . float 1     =    float 1  ;", "}", "METHOD_END"], "methodName": ["setFloat1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . float 2     =    float 2  ;", "}", "METHOD_END"], "methodName": ["setFloat2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . int 1     =    int 1  ;", "}", "METHOD_END"], "methodName": ["setInt1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . int 2     =    int 2  ;", "}", "METHOD_END"], "methodName": ["setInt2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . long 1     =    long 1  ;", "}", "METHOD_END"], "methodName": ["setLong1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . long 2     =    long 2  ;", "}", "METHOD_END"], "methodName": ["setLong2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . short 1     =    short 1  ;", "}", "METHOD_END"], "methodName": ["setShort1"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "this . short 2     =    short 2  ;", "}", "METHOD_END"], "methodName": ["setShort2"], "fileName": "org.springframework.tests.sample.beans.NumberTestBean"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.springframework.tests.sample.beans.Pet"}, {"methodBody": ["METHOD_START", "{", "+  +  ( count )  ;", "}", "METHOD_END"], "methodName": ["doWork"], "fileName": "org.springframework.tests.sample.beans.SideEffectBean"}, {"methodBody": ["METHOD_START", "{", "return   this . count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.springframework.tests.sample.beans.SideEffectBean"}, {"methodBody": ["METHOD_START", "{", "this . count    =    count ;", "}", "METHOD_END"], "methodName": ["setCount"], "fileName": "org.springframework.tests.sample.beans.SideEffectBean"}, {"methodBody": ["METHOD_START", "{", "this . destroyed    =    true ;", "}", "METHOD_END"], "methodName": ["destroy"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   country ;", "}", "METHOD_END"], "methodName": ["getCountry"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   date ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   favouriteColour ;", "}", "METHOD_END"], "methodName": ["getFavouriteColour"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   friends ;", "}", "METHOD_END"], "methodName": ["getFriends"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   myFloat ;", "}", "METHOD_END"], "methodName": ["getMyFloat"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   otherColours ;", "}", "METHOD_END"], "methodName": ["getOtherColours"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   pets ;", "}", "METHOD_END"], "methodName": ["getPets"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   sex ;", "}", "METHOD_END"], "methodName": ["getSex"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someBoolean ;", "}", "METHOD_END"], "methodName": ["getSomeBoolean"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someList ;", "}", "METHOD_END"], "methodName": ["getSomeList"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someMap ;", "}", "METHOD_END"], "methodName": ["getSomeMap"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someNumber ;", "}", "METHOD_END"], "methodName": ["getSomeNumber"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someProperties ;", "}", "METHOD_END"], "methodName": ["getSomeProperties"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   someSet ;", "}", "METHOD_END"], "methodName": ["getSomeSet"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   touchy ;", "}", "METHOD_END"], "methodName": ["getTouchy"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   jedi ;", "}", "METHOD_END"], "methodName": ["isJedi"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   postProcessed ;", "}", "METHOD_END"], "methodName": ["isPostProcessed"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . country    =    country ;", "}", "METHOD_END"], "methodName": ["setCountry"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . date    =    date ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . doctor    =    doctor ;", "}", "METHOD_END"], "methodName": ["setDoctor"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . favouriteColour    =    favouriteColour ;", "}", "METHOD_END"], "methodName": ["setFavouriteColour"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . friends    =    friends ;", "}", "METHOD_END"], "methodName": ["setFriends"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . jedi    =    jedi ;", "}", "METHOD_END"], "methodName": ["setJedi"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . lawyer    =    lawyer ;", "}", "METHOD_END"], "methodName": ["setLawyer"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . myFloat    =    myFloat ;", "}", "METHOD_END"], "methodName": ["setMyFloat"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . nestedIndexedBean    =    nestedIndexedBean ;", "}", "METHOD_END"], "methodName": ["setNestedIndexedBean"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . otherColours    =    otherColours ;", "}", "METHOD_END"], "methodName": ["setOtherColours"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . pets    =    pets ;", "}", "METHOD_END"], "methodName": ["setPets"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . postProcessed    =    postProcessed ;", "}", "METHOD_END"], "methodName": ["setPostProcessed"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . sex    =    sex ;", "if    (  ( this . name )     =  =    null )     {", "this . name    =    sex ;", "}", "}", "METHOD_END"], "methodName": ["setSex"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someBoolean    =    someBoolean ;", "}", "METHOD_END"], "methodName": ["setSomeBoolean"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someList    =    someList ;", "}", "METHOD_END"], "methodName": ["setSomeList"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someMap    =    someMap ;", "}", "METHOD_END"], "methodName": ["setSomeMap"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someNumber    =    someNumber ;", "}", "METHOD_END"], "methodName": ["setSomeNumber"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someProperties    =    someProperties ;", "}", "METHOD_END"], "methodName": ["setSomeProperties"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "this . someSet    =    someSet ;", "}", "METHOD_END"], "methodName": ["setSomeSet"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "if    (  ( touchy . indexOf (  '  .  '  )  )     !  =     (  -  1  )  )     {", "throw   new   Exception (  \" Can ' t   contain   a    .  \"  )  ;", "}", "if    (  ( touchy . indexOf (  '  ,  '  )  )     !  =     (  -  1  )  )     {", "throw   new   NumberFormatException (  \" Number   format   exception :    contains   a    ,  \"  )  ;", "}", "this . touchy    =    touchy ;", "}", "METHOD_END"], "methodName": ["setTouchy"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   destroyed ;", "}", "METHOD_END"], "methodName": ["wasDestroyed"], "fileName": "org.springframework.tests.sample.beans.TestBean"}, {"methodBody": ["METHOD_START", "{", "return   beanFactory ;", "}", "METHOD_END"], "methodName": ["getBeanFactory"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   beanName ;", "}", "METHOD_END"], "methodName": ["getBeanName"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   otherTestBean ;", "}", "METHOD_END"], "methodName": ["getOtherTestBean"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   postProcessed ;", "}", "METHOD_END"], "methodName": ["isPostProcessed"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "DummyFactory . prototypeCreated    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . otherTestBean    =    otherTestBean ;", "thisBean . setSpouse ( otherTestBean )  ;", "}", "METHOD_END"], "methodName": ["setOtherTestBean"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . postProcessed    =    postProcessed ;", "}", "METHOD_END"], "methodName": ["setPostProcessed"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "this . singleton    =    singleton ;", "}", "METHOD_END"], "methodName": ["setSingleton"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   initialized ;", "}", "METHOD_END"], "methodName": ["wasInitialized"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}, {"methodBody": ["METHOD_START", "{", "return   DummyFactory . prototypeCreated ;", "}", "METHOD_END"], "methodName": ["wasPrototypeCreated"], "fileName": "org.springframework.tests.sample.beans.factory.DummyFactory"}]