[{"methodBody": ["METHOD_START", "{", "ColumnDefinitions   definitions    =    new   ColumnDefinitions ( new   ColumnDefinitions . Definition [  ]  {    new   ColumnDefinitions . Definition (  \" keyspace \"  ,     \" table \"  ,     \" column \"  ,    DataType . ascii (  )  )     }  ,    CodecRegistry . DEFAULT _ INSTANCE )  ;", "ByteBuffer       =    ByteBuffer . wrap ( value . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "return   ArrayBackedRow . fromData ( definitions ,    null ,    ProtocolVersion . fromInt ( protocolVersion )  ,    ImmutableList . of (  )  )  ;", "}", "METHOD_END"], "methodName": ["createSingleStringRow"], "fileName": "com.datastax.driver.core.RowUtil"}, {"methodBody": ["METHOD_START", "{", "return   this . allowDropTable ;", "}", "METHOD_END"], "methodName": ["getAllowDropTable"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   clientConnectTimeout ;", "}", "METHOD_END"], "methodName": ["getClientConnectTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   clientReadTimeout ;", "}", "METHOD_END"], "methodName": ["getClientReadTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   clientSoLinger ;", "}", "METHOD_END"], "methodName": ["getClientSoLinger"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   consistencyLevel ;", "}", "METHOD_END"], "methodName": ["getConsistencyLevel"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   contactPoints ;", "}", "METHOD_END"], "methodName": ["getContactPoints"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   dcAwareLocalDC ;", "}", "METHOD_END"], "methodName": ["getDcAwareLocalDC"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   dcAwareUsedHostsPerRemoteDc ;", "}", "METHOD_END"], "methodName": ["getDcAwareUsedHostsPerRemoteDc"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   fetchSize ;", "}", "METHOD_END"], "methodName": ["getFetchSize"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   nativeProtocolPort ;", "}", "METHOD_END"], "methodName": ["getNativeProtocolPort"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   noHostAvailableRetryTimeout ;", "}", "METHOD_END"], "methodName": ["getNoHostAvailableRetryTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   partitionSizeForBatchSelect ;", "}", "METHOD_END"], "methodName": ["getPartitionSizeForBatchSelect"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   retryPolicy ;", "}", "METHOD_END"], "methodName": ["getRetryPolicy"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   speculativeExecutionDelay ;", "}", "METHOD_END"], "methodName": ["getSpeculativeExecutionDelay"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   speculativeExecutionLimit ;", "}", "METHOD_END"], "methodName": ["getSpeculativeExecutionLimit"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   splitSize ;", "}", "METHOD_END"], "methodName": ["getSplitSize"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   whiteListAddresses ;", "}", "METHOD_END"], "methodName": ["getWhiteListAddresses"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . dcAwareAllowRemoteDCsForLocal ;", "}", "METHOD_END"], "methodName": ["isDcAwareAllowRemoteDCsForLocal"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . tokenAwareShuffleReplicas ;", "}", "METHOD_END"], "methodName": ["isTokenAwareShuffleReplicas"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . useDCAware ;", "}", "METHOD_END"], "methodName": ["isUseDCAware"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . useTokenAware ;", "}", "METHOD_END"], "methodName": ["isUseTokenAware"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "return   this . useWhiteList ;", "}", "METHOD_END"], "methodName": ["isUseWhiteList"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . allowDropTable    =    allowDropTable ;", "turn   this ;", "}", "METHOD_END"], "methodName": ["setAllowDropTable"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . clientConnectTimeout    =    clientConnectTimeout ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientConnectTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . clientReadTimeout    =    clientReadTimeout ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientReadTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . clientSoLinger    =    clientSoLinger ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClientSoLinger"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . consistencyLevel    =    level ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setConsistencyLevel"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . contactPoints    =    CassandraClientConfig . SPLITTER . splitToList ( commaSeparatedList )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setContactPoints"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . contactPoints    =    Arrays . asList ( contactPoints )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setContactPoints"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . dcAwareAllowRemoteDCsForLocal    =    dcAwareAllowRemoteDCsForLocal ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDcAwareAllowRemoteDCsForLocal"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . dcAwareLocalDC    =    dcAwareLocalDC ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDcAwareLocalDC"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . dcAwareUsedHostsPerRemoteDc    =    dcAwareUsedHostsPerRemoteDc ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDcAwareUsedHostsPerRemoteDc"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . fetchSize    =    fetchSize ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFetchSize"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . nativeProtocolPort    =    nativeProtocolPort ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNativeProtocolPort"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . noHostAvailableRetryTimeout    =    noHostAvailableRetryTimeout ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNoHostAvailableRetryTimeout"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . partitionSizeForBatchSelect    =    partitionSizeForBatchSelect ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPartitionSizeForBatchSelect"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . retryPolicy    =    retryPolicy ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRetryPolicy"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . speculativeExecutionDelay    =    speculativeExecutionDelay ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSpeculativeExecutionDelay"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . speculativeExecutionLimit    =    speculativeExecutionLimit ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSpeculativeExecutionLimit"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . splitSize    =    splitSize ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSplitSize"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . tokenAwareShuffleReplicas    =    tokenAwareShuffleReplicas ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTokenAwareShuffleReplicas"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . useDCAware    =    useDCAware ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseDCAware"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . useTokenAware    =    useTokenAware ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseTokenAware"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . useWhiteList    =    useWhiteList ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setUseWhiteList"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "turn   this ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "this . whiteListAddresses    =    CassandraClientConfig . SPLITTER . splitToList ( commaSeparatedList )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setWhiteListAddresses"], "fileName": "com.facebook.presto.cassandra.CassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( config ,     \" config   is   null \"  )  ;", "Objects . requireNonNull ( extraColumnMetadataCodec ,     \" extraColumnMetadataCodec   is   null \"  )  ;", "Cluster . Builder   clusterBuilder    =    Cluster . builder (  )  . withProtocolVersion ( V 3  )  ;", "List < String >    contactPoints    =    Objects . requireNonNull ( config . getContactPoints (  )  ,     \" contactPoints   is   null \"  )  ;", "checkArgument (  (  !  ( contactPoints . isEmpty (  )  )  )  ,     \" empty   contactPoints \"  )  ;", "clusterBuilder . withPort ( config . getNativeProtocolPort (  )  )  ;", "clusterBuilder . withReconnectionPolicy ( new   ExponentialReconnectionPolicy (  5  0  0  ,     1  0  0  0  0  )  )  ;", "clusterBuilder . withRetryPolicy ( config . getRetryPolicy (  )  . getPolicy (  )  )  ;", "LoadBalancingPolicy   loadPolicy    =    new   RoundRobinPolicy (  )  ;", "if    ( config . isUseDCAware (  )  )     {", "Objects . requireNonNull ( config . getDcAwareLocalDC (  )  ,     \" DCAwarePolicy   localDC   is   null \"  )  ;", "DCAwareRoundRobinPolicy . Builder   builder    =    DCAwareRoundRobinPolicy . builder (  )  . withLocalDc ( config . getDcAwareLocalDC (  )  )  ;", "if    (  ( config . getDcAwareUsedHostsPerRemoteDc (  )  )     >     0  )     {", "builder . withUsedHostsPerRemoteDc ( config . getDcAwareUsedHostsPerRemoteDc (  )  )  ;", "if    ( config . isDcAwareAllowRemoteDCsForLocal (  )  )     {", "builder . allowRemoteDCsForLocalConsistencyLevel (  )  ;", "}", "}", "loadPolicy    =    builder . build (  )  ;", "}", "if    ( config . isUseTokenAware (  )  )     {", "loadPolicy    =    new   com . datastax . driver . core . policies . TokenAwarePolicy ( loadPolicy ,    config . isTokenAwareShuffleReplicas (  )  )  ;", "}", "if    ( config . isUseWhiteList (  )  )     {", "checkArgument (  (  !  ( config . getWhiteListAddresses (  )  . isEmpty (  )  )  )  ,     \" empty   WhiteListAddresses \"  )  ;", "List < InetSocketAddress >    whiteList    =    new   ArrayList <  >  (  )  ;", "for    ( String   point    :    config . getWhiteListAddresses (  )  )     {", "whiteList . add ( new   InetSocketAddress ( point ,    config . getNativeProtocolPort (  )  )  )  ;", "}", "loadPolicy    =    new   com . datastax . driver . core . policies . WhiteListPolicy ( loadPolicy ,    whiteList )  ;", "}", "clusterBuilder . withLoadBalancingPolicy ( loadPolicy )  ;", "SocketOptions   socketOptions    =    new   SocketOptions (  )  ;", "socketOptions . setReadTimeoutMillis ( Math . toIntExact ( config . getClientReadTimeout (  )  . toMillis (  )  )  )  ;", "socketOptions . setConnectTimeoutMillis ( Math . toIntExact ( config . getClientConnectTimeout (  )  . toMillis (  )  )  )  ;", "if    (  ( config . getClientSoLinger (  )  )     !  =    null )     {", "socketOptions . setSoLinger ( config . getClientSoLinger (  )  )  ;", "}", "clusterBuilder . withSocketOptions ( socketOptions )  ;", "if    (  (  ( config . getUsername (  )  )     !  =    null )     &  &     (  ( config . getPassword (  )  )     !  =    null )  )     {", "clusterBuilder . withCredentials ( config . getUsername (  )  ,    config . getPassword (  )  )  ;", "}", "QueryOptions   options    =    new   QueryOptions (  )  ;", "options . setFetchSize ( config . getFetchSize (  )  )  ;", "options . setConsistencyLevel ( config . getConsistencyLevel (  )  )  ;", "clusterBuilder . withQueryOptions ( options )  ;", "if    (  ( config . getSpeculativeExecutionLimit (  )  )     >     1  )     {", "clusterBuilder . withSpeculativeExecutionPolicy ( new   com . datastax . driver . core . policies . ConstantSpeculativeExecutionPolicy ( config . getSpeculativeExecutionDelay (  )  . toMillis (  )  ,    config . getSpeculativeExecutionLimit (  )  )  )  ;", "}", "return   new   NativeSession ( connectorId . toString (  )  ,    extraColumnMetadataCodec ,    new   ReopeningCluster (  (  )     -  >     {", "contactPoints . forEach ( clusterBuilder :  : addContactPoint )  ;", "return   clusterBuilder . build (  )  ;", "}  )  ,    config . getNoHostAvailableRetryTimeout (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCassandraSession"], "fileName": "com.facebook.presto.cassandra.CassandraClientModule"}, {"methodBody": ["METHOD_START", "{", "return   clusteringPushDownResult . getDomainQuery (  )  ;", "}", "METHOD_END"], "methodName": ["getClusteringKeyPredicates"], "fileName": "com.facebook.presto.cassandra.CassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "Builder < ColumnHandle ,    Domain >    domainsBuilder    =    ImmutableMap . builder (  )  ;", "ImmutableList . Builder < String >    clusteringColumnSql    =    ImmutableList . builder (  )  ;", "int   currentClusteringColumn    =     0  ;", "for    ( CassandraColumnHandle   columnHandle    :    clusteringColumns )     {", "Domain   domain    =    predicates . getDomains (  )  . get (  )  . get ( columnHandle )  ;", "if    ( domain    =  =    null )     {", "break ;", "}", "if    ( domain . isNullAllowed (  )  )     {", "break ;", "}", "String   predicateString    =    null ;", "predicateString    =    domain . getValues (  )  . getValuesProcessor (  )  . transform (  (    ranges )     -  >     {", "List < Object >    singleValues    =    new   ArrayList <  >  (  )  ;", "List < String >    rangeConjuncts    =    new   ArrayList <  >  (  )  ;", "String   predicate    =    null ;", "for    ( Range   range    :    ranges . getOrderedRanges (  )  )     {", "if    ( range . isAll (  )  )     {", "return   null ;", "}", "if    ( range . isSingleValue (  )  )     {", "singleValues . add ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( range . getSingleValue (  )  )  ,    columnHandle . getCassandraType (  )  )  )  ;", "} else    {", "if    (  !  ( range . getLow (  )  . isLowerUnbounded (  )  )  )     {", "switch    ( range . getLow (  )  . getBound (  )  )     {", "case   ABOVE    :", "rangeConjuncts . add (  (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"     >     \"  )     +     ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( range . getLow (  )  . getValue (  )  )  ,    columnHandle . getCassandraType (  )  )  )  )  )  ;", "break ;", "case   EXACTLY    :", "rangeConjuncts . add (  (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"     >  =     \"  )     +     ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( range . getLow (  )  . getValue (  )  )  ,    columnHandle . getCassandraType (  )  )  )  )  )  ;", "break ;", "case   BELOW    :", "throw   new   VerifyException (  \" Low   Marker   should   never   use   BELOW   bound \"  )  ;", "default    :", "throw   new   AssertionError (  (  \" Unhandled   bound :     \"     +     ( range . getLow (  )  . getBound (  )  )  )  )  ;", "}", "}", "if    (  !  ( range . getHigh (  )  . isUpperUnbounded (  )  )  )     {", "switch    ( range . getHigh (  )  . getBound (  )  )     {", "case   ABOVE    :", "throw   new   VerifyException (  \" High   Marker   should   never   use   ABOVE   bound \"  )  ;", "case   EXACTLY    :", "rangeConjuncts . add (  (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"     <  =     \"  )     +     ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( range . getHigh (  )  . getValue (  )  )  ,    columnHandle . getCassandraType (  )  )  )  )  )  ;", "break ;", "case   BELOW    :", "rangeConjuncts . add (  (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"     <     \"  )     +     ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( range . getHigh (  )  . getValue (  )  )  ,    columnHandle . getCassandraType (  )  )  )  )  )  ;", "break ;", "default    :", "throw   new   AssertionError (  (  \" Unhandled   bound :     \"     +     ( range . getHigh (  )  . getBound (  )  )  )  )  ;", "}", "}", "}", "}", "if    (  (  !  ( singleValues . isEmpty (  )  )  )     &  &     (  !  ( rangeConjuncts . isEmpty (  )  )  )  )     {", "return   null ;", "}", "if    (  !  ( singleValues . isEmpty (  )  )  )     {", "if    (  ( singleValues . size (  )  )     =  =     1  )     {", "predicate    =     (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"     =     \"  )     +     ( singleValues . get (  0  )  )  ;", "} else    {", "predicate    =     (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"    IN    (  \"  )     +     ( Joiner . on (  \"  ,  \"  )  . join ( singleValues )  )  )     +     \"  )  \"  ;", "}", "} else", "if    (  !  ( rangeConjuncts . isEmpty (  )  )  )     {", "predicate    =    Joiner . on (  \"    AND    \"  )  . join ( rangeConjuncts )  ;", "}", "return   predicate ;", "}  ,     (    discreteValues )     -  >     {", "if    ( discreteValues . isWhiteList (  )  )     {", "ImmutableList . Builder < Object >    discreteValuesList    =    ImmutableList . builder (  )  ;", "for    ( Object   discreteValue    :    discreteValues . getValues (  )  )     {", "discreteValuesList . add ( CassandraCqlUtils . cqlValue ( toCQLCompatibleString ( discreteValue )  ,    columnHandle . getCassandraType (  )  )  )  ;", "}", "String   predicate    =     (  (  ( CassandraCqlUtils . validColumnName ( columnHandle . getName (  )  )  )     +     \"    IN    (  \"  )     +     ( Joiner . on (  \"  ,  \"  )  . join ( discreteValuesList . build (  )  )  )  )     +     \"  )  \"  ;", "return   predicate ;", "}", "return   null ;", "}  ,     (    allOrNone )     -  >    null )  ;", "if    ( predicateString    =  =    null )     {", "break ;", "}", "if    (  (  ( predicateString . contains (  \"    IN    (  \"  )  )     &  &     (  ( cassandraVersion . compareTo ( VersionNumber . parse (  \"  2  .  2  .  0  \"  )  )  )     <     0  )  )     &  &     ( currentClusteringColumn    !  =     (  ( clusteringColumns . size (  )  )     -     1  )  )  )     {", "break ;", "}", "clusteringColumnSql . add ( predicateString )  ;", "domainsBuilder . put ( columnHandle ,    domain )  ;", "if    (  ( predicateString . contains (  \"  >  \"  )  )     |  |     ( predicateString . contains (  \"  <  \"  )  )  )     {", "break ;", "}", "currentClusteringColumn +  +  ;", "}", "List < String >    clusteringColumnPredicates    =    clusteringColumnSql . build (  )  ;", "return   new    . ClusteringPushDownResult ( domainsBuilder . build (  )  ,    Joiner . on (  \"    AND    \"  )  . join ( clusteringColumnPredicates )  )  ;", "}", "METHOD_END"], "methodName": ["getClusteringKeysSet"], "fileName": "com.facebook.presto.cassandra.CassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "Map < ColumnHandle ,    Domain >    pushedDown    =    clusteringPushDownResult . getDomains (  )  ;", "Map < ColumnHandle ,    Domain >    notPushedDown    =    new   HashMap ( predicates . getDomains (  )  . get (  )  )  ;", "if    (  (  !  ( notPushedDown . isEmpty (  )  )  )     &  &     (  !  ( pushedDown . isEmpty (  )  )  )  )     {", "notPushedDown . entrySet (  )  . removeAll ( pushedDown . entrySet (  )  )  ;", "}", "return   TupleDomain . withColumnDomains ( notPushedDown )  ;", "}", "METHOD_END"], "methodName": ["getUnenforcedConstraints"], "fileName": "com.facebook.presto.cassandra.CassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "return   cassandraType ;", "}", "METHOD_END"], "methodName": ["getCassandraType"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   com . facebook . presto . spi . ColumnMetadata ( CassandraCqlUtils . cqlNameToSqlName ( name )  ,    cassandraType . getNativeType (  )  ,    null ,    hidden )  ;", "}", "METHOD_END"], "methodName": ["getColumnMetadata"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   connectorId ;", "}", "METHOD_END"], "methodName": ["getConnectorId"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cassandraType . getTypeArgumentSize (  )  )     =  =     0  )     {", "return   cassandraType ;", "}", "return   new   CassandraTypeWithTypeArguments ( cassandraType ,    typeArguments )  ;", "}", "METHOD_END"], "methodName": ["getFullType"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   ordinalPosition ;", "}", "METHOD_END"], "methodName": ["getOrdinalPosition"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   cassandraType . getNativeType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   typeArguments ;", "}", "METHOD_END"], "methodName": ["getTypeArguments"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   clusteringKey ;", "}", "METHOD_END"], "methodName": ["isClusteringKey"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   hidden ;", "}", "METHOD_END"], "methodName": ["isHidden"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   indexed ;", "}", "METHOD_END"], "methodName": ["isIndexed"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   partitionKey ;", "}", "METHOD_END"], "methodName": ["isPartitionKey"], "fileName": "com.facebook.presto.cassandra.CassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "return   columnNames ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "com.facebook.presto.cassandra.CassandraInsertTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   columnTypes ;", "}", "METHOD_END"], "methodName": ["getColumnTypes"], "fileName": "com.facebook.presto.cassandra.CassandraInsertTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   connectorId ;", "}", "METHOD_END"], "methodName": ["getConnectorId"], "fileName": "com.facebook.presto.cassandra.CassandraInsertTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   schemaName ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "com.facebook.presto.cassandra.CassandraInsertTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   tableName ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "com.facebook.presto.cassandra.CassandraInsertTableHandle"}, {"methodBody": ["METHOD_START", "{", "CassandraTable   table    =    cassandraSession . getTable ( tableName )  ;", "List < ColumnMetadata >    columns    =    table . getColumns (  )  . stream (  )  . map ( CassandraColumnHandle :  : getColumnMetadata )  . collect ( Collectors . toList (  )  )  ;", "return   new   spi . ConnectorTableMetadata ( tableName ,    columns )  ;", "}", "METHOD_END"], "methodName": ["getTableMetadata"], "fileName": "com.facebook.presto.cassandra.CassandraMetadata"}, {"methodBody": ["METHOD_START", "{", "return    (  ( CassandraTableHandle )     ( tableHandle )  )  . getSchemaTableName (  )  ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "com.facebook.presto.cassandra.CassandraMetadata"}, {"methodBody": ["METHOD_START", "{", "if    ( schemaNameOrNull    =  =    null )     {", "turn   listSchemaNames ( session )  ;", "}", "turn   ImmutableList . of ( schemaNameOrNull )  ;", "}", "METHOD_END"], "methodName": ["listSchemas"], "fileName": "com.facebook.presto.cassandra.CassandraMetadata"}, {"methodBody": ["METHOD_START", "{", "if    (  ( prefix . getTableName (  )  )     =  =    null )     {", "return   listTables ( session ,    prefix . getSchemaName (  )  )  ;", "}", "return   ImmutableList . of ( new   spi . SchemaTableName ( prefix . getSchemaName (  )  ,    prefix . getTableName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["listTables"], "fileName": "com.facebook.presto.cassandra.CassandraMetadata"}, {"methodBody": ["METHOD_START", "{", "return   columnNames ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "com.facebook.presto.cassandra.CassandraOutputTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   columnTypes ;", "}", "METHOD_END"], "methodName": ["getColumnTypes"], "fileName": "com.facebook.presto.cassandra.CassandraOutputTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   connectorId ;", "}", "METHOD_END"], "methodName": ["getConnectorId"], "fileName": "com.facebook.presto.cassandra.CassandraOutputTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   schemaName ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "com.facebook.presto.cassandra.CassandraOutputTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   tableName ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "com.facebook.presto.cassandra.CassandraOutputTableHandle"}, {"methodBody": ["METHOD_START", "{", "Block   block    =    page . getBlock ( channel )  ;", "Type   type    =    columnTypes . get ( channel )  ;", "if    ( block . isNull ( position )  )     {", "values . add ( null )  ;", "} else", "if    ( BOOLEAN . equals ( type )  )     {", "values . add ( type . getBoolean ( block ,    position )  )  ;", "} else", "if    ( BIGINT . equals ( type )  )     {", "values . add ( type . getLong ( block ,    position )  )  ;", "} else", "if    ( INTEGER . equals ( type )  )     {", "values . add ( Math . toIntExact ( type . getLong ( block ,    position )  )  )  ;", "} else", "if    ( DOUBLE . equals ( type )  )     {", "values . add ( type . getDouble ( block ,    position )  )  ;", "} else", "if    ( REAL . equals ( type )  )     {", "values . add ( Float . intBitsToFloat ( Math . toIntExact ( type . getLong ( block ,    position )  )  )  )  ;", "} else", "if    ( DATE . equals ( type )  )     {", "values . add ( CassandraPageSink . DATE _ FORMATTER . print ( toMillis ( type . getLong ( block ,    position )  )  )  )  ;", "} else", "if    ( TIMESTAMP . equals ( type )  )     {", "values . add ( new   Timestamp ( type . getLong ( block ,    position )  )  )  ;", "} else", "if    ( isVarcharType ( type )  )     {", "values . add ( type . getSlice ( block ,    position )  . toStringUtf 8  (  )  )  ;", "} else", "if    ( VARBINARY . equals ( type )  )     {", "values . add ( type . getSlice ( block ,    position )  . toByteBuffer (  )  )  ;", "} else    {", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,     (  \" Unsupported   column   type :     \"     +     ( type . getDisplayName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["appendColumn"], "fileName": "com.facebook.presto.cassandra.CassandraPageSink"}, {"methodBody": ["METHOD_START", "{", "return   key ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "return   ByteBuffer . wrap ( key )  ;", "}", "METHOD_END"], "methodName": ["getKeyAsByteBuffer"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "return   partitionId ;", "}", "METHOD_END"], "methodName": ["getPartitionId"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "return   tupleDomain ;", "}", "METHOD_END"], "methodName": ["getTupleDomain"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "return   indexedColumnPredicatePushdown ;", "}", "METHOD_END"], "methodName": ["isIndexedColumnPredicatePushdown"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "return   partitionId . equals ( CassandraPartition . UNPARTITIONED _ ID )  ;", "}", "METHOD_END"], "methodName": ["isUnpartitioned"], "fileName": "com.facebook.presto.cassandra.CassandraPartition"}, {"methodBody": ["METHOD_START", "{", "if    ( tupleDomain . isNone (  )  )     {", "return   ImmutableList . of (  )  ;", "}", "Set < List < Object >  >    partitionKeysSet    =     . getPartitionKeysSet ( table ,    tupleDomain )  ;", "if    ( partitionKeysSet . isEmpty (  )  )     {", "return   cassandraSession . getPartitions ( table ,    ImmutableList . of (  )  )  ;", "}", "ImmutableList . Builder < CassandraPartition >    partitions    =    ImmutableList . builder (  )  ;", "for    ( List < Object >    partitionKeys    :    partitionKeysSet )     {", "partitions . addAll ( cassandraSession . getPartitions ( table ,    partitionKeys )  )  ;", "}", "return   partitions . build (  )  ;", "}", "METHOD_END"], "methodName": ["getCassandraPartitions"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionManager"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Set < Object >  >    partitionColumnValues    =    ImmutableList . builder (  )  ;", "for    ( ColumnHandle   columnHandle    :    table . getPartitionKeyColumns (  )  )     {", "Domain   domain    =    tupleDomain . getDomains (  )  . get (  )  . get ( columnHandle )  ;", "if    ( domain    =  =    null )     {", "return   ImmutableSet . of (  )  ;", "}", "if    ( domain . isNullAllowed (  )  )     {", "return   ImmutableSet . of (  )  ;", "}", "Set < Object >    values    =    domain . getValues (  )  . getValuesProcessor (  )  . transform (  (    ranges )     -  >     {", "ImmutableSet . Builder < Object >    columnValues    =    ImmutableSet . builder (  )  ;", "for    ( Range   range    :    ranges . getOrderedRanges (  )  )     {", "if    (  !  ( range . isSingleValue (  )  )  )     {", "return   ImmutableSet . of (  )  ;", "}", "Object   value    =    range . getSingleValue (  )  ;", "Type   valueType    =    columnHandle . getType (  )  ;", "columnValues . add ( valueType . validatePartitionKey ( value )  )  ;", "}", "return   columnValues . build (  )  ;", "}  ,     (    discreteValues )     -  >     {", "if    ( discreteValues . isWhiteList (  )  )     {", "return   ImmutableSet . copyOf ( discreteValues . getValues (  )  )  ;", "}", "return   ImmutableSet . of (  )  ;", "}  ,     (    allOrNone )     -  >    ImmutableSet . of (  )  )  ;", "partitionColumnValues . add ( values )  ;", "}", "return   Sets . cartesianProduct ( partitionColumnValues . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPartitionKeysSet"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionManager"}, {"methodBody": ["METHOD_START", "{", "CassandraTableHandle   cassandraTableHandle    =     (  ( CassandraTableHandle )     ( tableHandle )  )  ;", "CassandraTable   table    =    cassandraSession . getTable ( cassandraTableHandle . getSchemaTableName (  )  )  ;", "List < CassandraColumnHandle >    partitionKeys    =    table . getPartitionKeyColumns (  )  ;", "List < CassandraPartition >    allPartitions    =    getCassandraPartitions ( table ,    tupleDomain )  ;", ". log . debug (  \"  % s .  % s    # partitions :     % d \"  ,    cassandraTableHandle . getSchemaName (  )  ,    cassandraTableHandle . getTableName (  )  ,    allPartitions . size (  )  )  ;", "List < CassandraPartition >    partitions    =    allPartitions . stream (  )  . filter (  (    partition )     -  >    tupleDomain . overlaps ( partition . getTupleDomain (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "TupleDomain < ColumnHandle >    remainingTupleDomain    =    TupleDomain . none (  )  ;", "if    (  !  ( tupleDomain . isNone (  )  )  )     {", "if    (  (  ( partitions . size (  )  )     =  =     1  )     &  &     ( partitions . get (  0  )  . isUnpartitioned (  )  )  )     {", "remainingTupleDomain    =    tupleDomain ;", "} else    {", "@ SuppressWarnings (  {     \" rawtypes \"  ,     \" unchecked \"     }  )", "List < ColumnHandle >    partitionColumns    =     (  ( List )     ( partitionKeys )  )  ;", "remainingTupleDomain    =    TupleDomain . withColumnDomains ( Maps . filterKeys ( tupleDomain . getDomains (  )  . get (  )  ,    not ( in ( partitionColumns )  )  )  )  ;", "}", "}", "if    (  (  ( partitions . size (  )  )     =  =     1  )     &  &     ( partitions . get (  0  )  . isUnpartitioned (  )  )  )     {", "Map < ColumnHandle ,    Domain >    domains    =    tupleDomain . getDomains (  )  . get (  )  ;", "List < ColumnHandle >    indexedColumns    =    new   ArrayList <  >  (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( Map . Entry < ColumnHandle ,    Domain >    entry    :    domains . entrySet (  )  )     {", "CassandraColumnHandle   column    =     (  ( CassandraColumnHandle )     ( entry . getKey (  )  )  )  ;", "Domain   domain    =    entry . getValue (  )  ;", "if    (  ( column . isIndexed (  )  )     &  &     ( domain . isSingleValue (  )  )  )     {", "sb . append ( CassandraCqlUtils . validColumnName ( column . getName (  )  )  )  . append (  \"     =     \"  )  . append ( CassandraCqlUtils . cqlValue ( CassandraCqlUtils . toCQLCompatibleString ( entry . getValue (  )  . getSingleValue (  )  )  ,    column . getCassandraType (  )  )  )  ;", "indexedColumns . add ( column )  ;", "break ;", "}", "}", "if    (  ( sb . length (  )  )     >     0  )     {", "CassandraPartition   partition    =    partitions . get (  0  )  ;", "TupleDomain < ColumnHandle >    filterIndexedColumn    =    TupleDomain . withColumnDomains ( Maps . filterKeys ( remainingTupleDomain . getDomains (  )  . get (  )  ,    not ( in ( indexedColumns )  )  )  )  ;", "partitions    =    new   ArrayList <  >  (  )  ;", "partitions . add ( new   CassandraPartition ( partition . getKey (  )  ,    sb . toString (  )  ,    filterIndexedColumn ,    true )  )  ;", "return   new   CassandraPartitionResult ( partitions ,    filterIndexedColumn )  ;", "}", "}", "return   new   CassandraPartitionResult ( partitions ,    remainingTupleDomain )  ;", "}", "METHOD_END"], "methodName": ["getPartitions"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionManager"}, {"methodBody": ["METHOD_START", "{", "return   partitions ;", "}", "METHOD_END"], "methodName": ["getPartitions"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionResult"}, {"methodBody": ["METHOD_START", "{", "return   unenforcedConstraint ;", "}", "METHOD_END"], "methodName": ["getUnenforcedConstraint"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionResult"}, {"methodBody": ["METHOD_START", "{", "return    (  ( partitions . size (  )  )     =  =     1  )     &  &     ( getOnlyElement ( partitions )  . isUnpartitioned (  )  )  ;", "}", "METHOD_END"], "methodName": ["isUnpartitioned"], "fileName": "com.facebook.presto.cassandra.CassandraPartitionResult"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . start (  )  ;", "DistributedQueryRunner   queryRunner    =    new   DistributedQueryRunner (  . createCassandraSession (  \" tpch \"  )  ,     4  )  ;", "queryRunner . installPlugin ( new   TpchPlugin (  )  )  ;", "queryRunner . createCatalog (  \" tpch \"  ,     \" tpch \"  )  ;", "queryRunner . installPlugin ( new   CassandraPlugin (  )  )  ;", "queryRunner . createCatalog (  \" cassandra \"  ,     \" cassandra \"  ,    ImmutableMap . of (  \" cassandra . contact - points \"  ,    EmbeddedCassandra . getHost (  )  ,     \" cassandra . native - protocol - port \"  ,    Integer . toString ( EmbeddedCassandra . getPort (  )  )  ,     \" cassandra . allow - drop - table \"  ,     \" true \"  )  )  ;", "if    (  !  (  . tpchLoaded )  )     {", "CassandraTestingUtils . createKeyspace ( EmbeddedCassandra . getSession (  )  ,     \" tpch \"  )  ;", "List < TpchTable <  ?  >  >    tables    =    TpchTable . getTables (  )  ;", "copyTpchTables ( queryRunner ,     \" tpch \"  ,    TINY _ SCHEMA _ NAME ,     . createCassandraSession (  \" tpch \"  )  ,    tables )  ;", "for    ( TpchTable   table    :    tables )     {", "EmbeddedCassandra . refreshSizeEstimates (  \" tpch \"  ,    table . getTableName (  )  )  ;", "}", ". tpchLoaded    =    true ;", "}", "return   queryRunner ;", "}", "METHOD_END"], "methodName": ["createCassandraQueryRunner"], "fileName": "com.facebook.presto.cassandra.CassandraQueryRunner"}, {"methodBody": ["METHOD_START", "{", "return   testSessionBuilder (  )  . setCatalog (  \" cassandra \"  )  . setSchema ( schema )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createCassandraSession"], "fileName": "com.facebook.presto.cassandra.CassandraQueryRunner"}, {"methodBody": ["METHOD_START", "{", "return   fullCassandraTypes . get ( i )  . getCassandraType (  )  ;", "}", "METHOD_END"], "methodName": ["getCassandraType"], "fileName": "com.facebook.presto.cassandra.CassandraRecordCursor"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . copyOf ( list . stream (  )  . map ( function )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["transformList"], "fileName": "com.facebook.presto.cassandra.CassandraRecordSet"}, {"methodBody": ["METHOD_START", "{", "return   new   CassandraTableHandle ( connectorId ,    schema ,    table )  ;", "}", "METHOD_END"], "methodName": ["getCassandraTableHandle"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return   connectorId ;", "}", "METHOD_END"], "methodName": ["getConnectorId"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return   partitionId ;", "}", "METHOD_END"], "methodName": ["getPartitionId"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return   schema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return   splitCondition ;", "}", "METHOD_END"], "methodName": ["getSplitCondition"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return   table ;", "}", "METHOD_END"], "methodName": ["getTable"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "if    ( partitionId . equals ( CassandraPartition . UNPARTITIONED _ ID )  )     {", "if    (  ( splitCondition )     !  =    null )     {", "return    \"    WHERE    \"     +     ( splitCondition )  ;", "} else    {", "return    \"  \"  ;", "}", "} else    {", "if    (  ( splitCondition )     !  =    null )     {", "return    (  (  \"    WHERE    \"     +     ( partitionId )  )     +     \"    AND    \"  )     +     ( splitCondition )  ;", "} else    {", "return    \"    WHERE    \"     +     ( partitionId )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getWhereClause"], "fileName": "com.facebook.presto.cassandra.CassandraSplit"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( tokenExpression    +     \"     >     \"  )     +    startToken )     +     \"    AND    \"  )     +    tokenExpression )     +     \"     <  =     \"  )     +    endToken ;", "}", "METHOD_END"], "methodName": ["buildTokenCondition"], "fileName": "com.facebook.presto.cassandra.CassandraSplitManager"}, {"methodBody": ["METHOD_START", "{", "String   schema    =    tableHandle . getSchemaName (  )  ;", "String   table    =    tableHandle . getTableName (  )  ;", "if    ( clusteringPredicates . isEmpty (  )  )     {", "return   new    ( connectorId ,    schema ,    table ,    partitionId ,    null ,    hosts )  ;", "}", "return   new    ( connectorId ,    schema ,    table ,    partitionId ,    clusteringPredicates ,    hosts )  ;", "}", "METHOD_END"], "methodName": ["createSplitForClusteringPredicates"], "fileName": "com.facebook.presto.cassandra.CassandraSplitManager"}, {"methodBody": ["METHOD_START", "{", "String   schema    =    table . getTableHandle (  )  . getSchemaName (  )  ;", "String   tableName    =    table . getTableHandle (  )  . getTableName (  )  ;", "String   tokenExpression    =    table . getTokenExpression (  )  ;", "ImmutableList . Builder < ConnectorSplit >    builder    =    ImmutableList . builder (  )  ;", "List < CassandraTokenSplitManager . TokenSplit >    tokenSplits    =    tokenSplitMgr . getSplits ( schema ,    tableName )  ;", "for    ( CassandraTokenSplitManager . TokenSplit   tokenSplit    :    tokenSplits )     {", "String   condition    =     . buildTokenCondition ( tokenExpression ,    tokenSplit . getStartToken (  )  ,    tokenSplit . getEndToken (  )  )  ;", "List < HostAddress >    addresses    =    new   HostAddressFactory (  )  . AddressNamesToHostAddressList ( tokenSplit . getHosts (  )  )  ;", "CassandraSplit   split    =    new   CassandraSplit ( connectorId ,    schema ,    tableName ,    partitionId ,    condition ,    addresses )  ;", "builder . add ( split )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getSplitsByTokenRange"], "fileName": "com.facebook.presto.cassandra.CassandraSplitManager"}, {"methodBody": ["METHOD_START", "{", "String   schema    =    cassTableHandle . getSchemaName (  )  ;", "HostAddressFactory   hostAddressFactory    =    new   HostAddressFactory (  )  ;", "ImmutableList . Builder < ConnectorSplit >    builder    =    ImmutableList . builder (  )  ;", "boolean   singlePartitionKeyColumn    =    true ;", "String   partitionKeyColumnName    =    null ;", "if    (  !  ( partitions . isEmpty (  )  )  )     {", "singlePartitionKeyColumn    =     ( partitions . get (  0  )  . getTupleDomain (  )  . getDomains (  )  . get (  )  . size (  )  )     =  =     1  ;", "if    ( singlePartitionKeyColumn )     {", "String   partitionId    =    partitions . get (  0  )  . getPartitionId (  )  ;", "partitionKeyColumnName    =    partitionId . substring (  0  ,     (  ( partitionId . lastIndexOf (  '  =  '  )  )     -     1  )  )  ;", "}", "}", "Map < Set < String >  ,    Set < String >  >    hostsToPartitionKeys    =    new   HashMap <  >  (  )  ;", "Map < Set < String >  ,    List < HostAddress >  >    hostMap    =    new   HashMap <  >  (  )  ;", "for    ( CassandraPartition   Partition    :    partitions )     {", "Set < Host >    hosts    =    Session . getReplicas ( schema ,    Partition . getKeyAsByteBuffer (  )  )  ;", "List < HostAddress >    addresses    =    hostAddressFactory . toHostAddressList ( hosts )  ;", "if    ( singlePartitionKeyColumn )     {", "ImmutableSet . Builder < String >    sb    =    ImmutableSet . builder (  )  ;", "for    ( HostAddress   address    :    addresses )     {", "sb . add ( address . getHostText (  )  )  ;", "}", "Set < String >    hostAddresses    =    sb . build (  )  ;", "Set < String >    values    =    hostsToPartitionKeys . get ( hostAddresses )  ;", "if    ( values    =  =    null )     {", "values    =    new   HashSet <  >  (  )  ;", "}", "String   partitionId    =    Partition . getPartitionId (  )  ;", "values . add ( partitionId . substring (  (  ( partitionId . lastIndexOf (  '  =  '  )  )     +     2  )  )  )  ;", "hostsToPartitionKeys . put ( hostAddresses ,    values )  ;", "hostMap . put ( hostAddresses ,    addresses )  ;", "} else    {", "builder . add ( createSplitForClusteringPredicates ( cassTableHandle ,    Partition . getPartitionId (  )  ,    addresses ,    clusteringPredicates )  )  ;", "}", "}", "if    ( singlePartitionKeyColumn )     {", "for    ( Map . Entry < Set < String >  ,    Set < String >  >    entry    :    hostsToPartitionKeys . entrySet (  )  )     {", "StringBuilder   sb    =    new   StringBuilder ( partitionSizeForBatchSelect )  ;", "int   size    =     0  ;", "for    ( String   value    :    entry . getValue (  )  )     {", "if    ( size    >     0  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append ( value )  ;", "size +  +  ;", "if    ( size    >     ( partitionSizeForBatchSelect )  )     {", "String   partitionId    =    String . format (  \"  % s   in    (  % s )  \"  ,    partitionKeyColumnName ,    sb . toString (  )  )  ;", "builder . add ( createSplitForClusteringPredicates ( cassTableHandle ,    partitionId ,    hostMap . get ( entry . getKey (  )  )  ,    clusteringPredicates )  )  ;", "size    =     0  ;", "sb . setLength (  0  )  ;", "sb . trimToSize (  )  ;", "}", "}", "if    ( size    >     0  )     {", "String   partitionId    =    String . format (  \"  % s   in    (  % s )  \"  ,    partitionKeyColumnName ,    sb . toString (  )  )  ;", "builder . add ( createSplitForClusteringPredicates ( cassTableHandle ,    partitionId ,    hostMap . get ( entry . getKey (  )  )  ,    clusteringPredicates )  )  ;", "}", "}", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getSplitsForPartitions"], "fileName": "com.facebook.presto.cassandra.CassandraSplitManager"}, {"methodBody": ["METHOD_START", "{", "return   columns . stream (  )  . filter ( CassandraColumnHandle :  : isClusteringKey )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getClusteringKeyColumns"], "fileName": "com.facebook.presto.cassandra.CassandraTable"}, {"methodBody": ["METHOD_START", "{", "return   columns ;", "}", "METHOD_END"], "methodName": ["getColumns"], "fileName": "com.facebook.presto.cassandra.CassandraTable"}, {"methodBody": ["METHOD_START", "{", "return   columns . stream (  )  . filter ( CassandraColumnHandle :  : isPartitionKey )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPartitionKeyColumns"], "fileName": "com.facebook.presto.cassandra.CassandraTable"}, {"methodBody": ["METHOD_START", "{", "return   tableHandle ;", "}", "METHOD_END"], "methodName": ["getTableHandle"], "fileName": "com.facebook.presto.cassandra.CassandraTable"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( ColumnHandle   column    :    getPartitionKeyColumns (  )  )     {", "if    (  ( sb . length (  )  )     =  =     0  )     {", "sb . append (  \" token (  \"  )  ;", "} else    {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append ( CqlUtils . validColumnName ( column . getName (  )  )  )  ;", "}", "sb . append (  \"  )  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getTokenExpression"], "fileName": "com.facebook.presto.cassandra.CassandraTable"}, {"methodBody": ["METHOD_START", "{", "return   connectorId ;", "}", "METHOD_END"], "methodName": ["getConnectorId"], "fileName": "com.facebook.presto.cassandra.CassandraTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   schemaName ;", "}", "METHOD_END"], "methodName": ["getSchemaName"], "fileName": "com.facebook.presto.cassandra.CassandraTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   SchemaTableName ( schemaName ,    tableName )  ;", "}", "METHOD_END"], "methodName": ["getSchemaTableName"], "fileName": "com.facebook.presto.cassandra.CassandraTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   tableName ;", "}", "METHOD_END"], "methodName": ["getTableName"], "fileName": "com.facebook.presto.cassandra.CassandraTableHandle"}, {"methodBody": ["METHOD_START", "{", "return   clusteringPredicates ;", "}", "METHOD_END"], "methodName": ["getClusteringPredicates"], "fileName": "com.facebook.presto.cassandra.CassandraTableLayoutHandle"}, {"methodBody": ["METHOD_START", "{", "return   partitions ;", "}", "METHOD_END"], "methodName": ["getPartitions"], "fileName": "com.facebook.presto.cassandra.CassandraTableLayoutHandle"}, {"methodBody": ["METHOD_START", "{", "return   table ;", "}", "METHOD_END"], "methodName": ["getTable"], "fileName": "com.facebook.presto.cassandra.CassandraTableLayoutHandle"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  (  \" CREATE   KEYSPACE    \"     +    keyspaceName )     +     \"    WITH   REPLICATION    =     {  ' class '  :  ' SimpleStrategy '  ,     ' replication _ factor '  :     1  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createKeyspace"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  \" DROP   TABLE   IF   EXISTS    \"     +    table )  )  ;", "session . execute (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" CREATE   TABLE    \"     +    table )     +     \"     (  \"  )     +     \"    key   text   PRIMARY   KEY ,     \"  )     +     \"    typeuuid   uuid ,     \"  )     +     \"    typeinteger   int ,     \"  )     +     \"    typelong   bigint ,     \"  )     +     \"    typebytes   blob ,     \"  )     +     \"    typetimestamp   timestamp ,     \"  )     +     \"    typeansi   ascii ,     \"  )     +     \"    typeboolean   boolean ,     \"  )     +     \"    typedecimal   decimal ,     \"  )     +     \"    typedouble   double ,     \"  )     +     \"    typefloat   float ,     \"  )     +     \"    typeinet   inet ,     \"  )     +     \"    typevarchar   varchar ,     \"  )     +     \"    typevarint   varint ,     \"  )     +     \"    typetimeuuid   timeuuid ,     \"  )     +     \"    typelist   list < text >  ,     \"  )     +     \"    typemap   map < int ,    bigint >  ,     \"  )     +     \"    typeset   set < boolean >  ,     \"  )     +     \"  )  \"  )  )  ;", ". insertTestData ( session ,    table ,    date ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["createTableAllTypes"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  \" DROP   TABLE   IF   EXISTS    \"     +    table )  )  ;", "session . execute (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" CREATE   TABLE    \"     +    table )     +     \"     (  \"  )     +     \"    key   text ,     \"  )     +     \"    typeuuid   uuid ,     \"  )     +     \"    typeinteger   int ,     \"  )     +     \"    typelong   bigint ,     \"  )     +     \"    typebytes   blob ,     \"  )     +     \"    typetimestamp   timestamp ,     \"  )     +     \"    typeansi   ascii ,     \"  )     +     \"    typeboolean   boolean ,     \"  )     +     \"    typedecimal   decimal ,     \"  )     +     \"    typedouble   double ,     \"  )     +     \"    typefloat   float ,     \"  )     +     \"    typeinet   inet ,     \"  )     +     \"    typevarchar   varchar ,     \"  )     +     \"    typevarint   varint ,     \"  )     +     \"    typetimeuuid   timeuuid ,     \"  )     +     \"    typelist   frozen    < list < text >  >  ,     \"  )     +     \"    typemap   frozen    < map < int ,    bigint >  >  ,     \"  )     +     \"    typeset   frozen    < set < boolean >  >  ,     \"  )     +     \"    PRIMARY   KEY    (  (  \"  )     +     \"          key ,     \"  )     +     \"          typeuuid ,     \"  )     +     \"          typeinteger ,     \"  )     +     \"          typelong ,     \"  )     +     \"          typetimestamp ,     \"  )     +     \"          typeansi ,     \"  )     +     \"          typeboolean ,     \"  )     +     \"          typedouble ,     \"  )     +     \"          typefloat ,     \"  )     +     \"          typeinet ,     \"  )     +     \"          typevarchar ,     \"  )     +     \"          typetimeuuid    \"  )     +     \"     )  )  \"  )     +     \"  )  \"  )  )  ;", ". insertTestData ( session ,    table ,    date ,     9  )  ;", "}", "METHOD_END"], "methodName": ["createTableAllTypesPartitionKey"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  \" DROP   TABLE   IF   EXISTS    \"     +    table )  )  ;", "session . execute (  (  (  (  (  (  (  (  (  (  \" CREATE   TABLE    \"     +    table )     +     \"     (  \"  )     +     \" key   text ,     \"  )     +     \" clust _ one   text ,     \"  )     +     \" clust _ two   text ,     \"  )     +     \" clust _ three   text ,     \"  )     +     \" data   text ,     \"  )     +     \" PRIMARY   KEY (  ( key )  ,    clust _ one ,    clust _ two ,    clust _ three )     \"  )     +     \"  )  \"  )  )  ;", ". insertIntoTableClusteringKeys ( session ,    table ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["createTableClusteringKeys"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  \" DROP   TABLE   IF   EXISTS    \"     +    table )  )  ;", "session . execute (  (  (  (  (  (  (  (  (  (  \" CREATE   TABLE    \"     +    table )     +     \"     (  \"  )     +     \" key   text ,     \"  )     +     \" clust _ one   text ,     \"  )     +     \" clust _ two   int ,     \"  )     +     \" clust _ three   timestamp ,     \"  )     +     \" data   text ,     \"  )     +     \" PRIMARY   KEY (  ( key )  ,    clust _ one ,    clust _ two ,    clust _ three )     \"  )     +     \"  )  \"  )  )  ;", ". insertIntoTableClusteringKeysInequality ( session ,    table ,    date ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["createTableClusteringKeysInequality"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "session . execute (  (  \" DROP   TABLE   IF   EXISTS    \"     +    table )  )  ;", "session . execute (  (  (  (  (  (  (  (  (  (  (  \" CREATE   TABLE    \"     +    table )     +     \"     (  \"  )     +     \" partition _ one   text ,     \"  )     +     \" partition _ two   text ,     \"  )     +     \" clust _ one   text ,     \"  )     +     \" clust _ two   text ,     \"  )     +     \" clust _ three   text ,     \"  )     +     \" data   text ,     \"  )     +     \" PRIMARY   KEY (  ( partition _ one ,    partition _ two )  ,    clust _ one ,    clust _ two ,    clust _ three )     \"  )     +     \"  )  \"  )  )  ;", ". insertIntoTableMultiPartitionClusteringKeys ( session ,    table )  ;", "}", "METHOD_END"], "methodName": ["createTableMultiPartitionClusteringKeys"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "CassandraTestingUtils . createKeyspace ( cassandraSession ,    keyspace )  ;", "CassandraTestingUtils . createTableAllTypes ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ ALL _ TYPES )  ,    date ,     9  )  ;", "CassandraTestingUtils . createTableAllTypes ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  ,    date ,     0  )  ;", "CassandraTestingUtils . createTableAllTypesPartitionKey ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ ALL _ TYPES _ PARTITION _ KEY )  ,    date )  ;", "CassandraTestingUtils . createTableClusteringKeys ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  ,     9  )  ;", "CassandraTestingUtils . createTableClusteringKeys ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  ,     1  0  0  0  )  ;", "CassandraTestingUtils . createTableMultiPartitionClusteringKeys ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )  ;", "CassandraTestingUtils . createTableClusteringKeysInequality ( cassandraSession ,    new   SchemaTableName ( keyspace ,    CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  ,    date ,     4  )  ;", "}", "METHOD_END"], "methodName": ["createTestTables"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Integer   rowNumber    =     1  ;    rowNumber    <  =    rowsCount ;    rowNumber +  +  )     {", "Insert   insert    =    QueryBuilder . insertInto ( table . getSchemaName (  )  ,    table . getTableName (  )  )  . value (  \" key \"  ,     (  \" key _  \"     +     ( rowNumber . toStr (  )  )  )  )  . value (  \" clust _ one \"  ,     \" clust _ one \"  )  . value (  \" clust _ two \"  ,     (  \" clust _ two _  \"     +     ( rowNumber . toStr (  )  )  )  )  . value (  \" clust _ three \"  ,     (  \" clust _ three _  \"     +     ( rowNumber . toStr (  )  )  )  )  ;", "session . execute ( insert )  ;", "}", "assertEquals ( session . execute (  (  \" SELECT   COUNT (  *  )    FROM    \"     +    table )  )  . all (  )  . get (  0  )  . getLong (  0  )  ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["insertIntoTableClusteringKeys"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Integer   rowNumber    =     1  ;    rowNumber    <  =    rowsCount ;    rowNumber +  +  )     {", "Insert   insert    =    QueryBuilder . insertInto ( table . getSchemaName (  )  ,    table . getTableName (  )  )  . value (  \" key \"  ,     \" key _  1  \"  )  . value (  \" clust _ one \"  ,     \" clust _ one \"  )  . value (  \" clust _ two \"  ,    rowNumber )  . value (  \" clust _ three \"  ,     (  ( date . getTime (  )  )     +     ( rowNumber    *     1  0  )  )  )  ;", "session . execute ( insert )  ;", "}", "ertEquals ( session . execute (  (  \" SELECT   COUNT (  *  )    FROM    \"     +    table )  )  . all (  )  . get (  0  )  . getLong (  0  )  ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["insertIntoTableClusteringKeysInequality"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Integer   rowNumber    =     1  ;    rowNumber    <     1  0  ;    rowNumber +  +  )     {", "Insert   insert    =    QueryBuilder . insertInto ( table . getSchemaName (  )  ,    table . getTableName (  )  )  . value (  \" partition _ one \"  ,     (  \" partition _ one _  \"     +     ( rowNumber . toStr (  )  )  )  )  . value (  \" partition _ two \"  ,     (  \" partition _ two _  \"     +     ( rowNumber . toStr (  )  )  )  )  . value (  \" clust _ one \"  ,     \" clust _ one \"  )  . value (  \" clust _ two \"  ,     (  \" clust _ two _  \"     +     ( rowNumber . toStr (  )  )  )  )  . value (  \" clust _ three \"  ,     (  \" clust _ three _  \"     +     ( rowNumber . toStr (  )  )  )  )  ;", "session . execute ( insert )  ;", "}", "assertEquals ( session . execute (  (  \" SELECT   COUNT (  *  )    FROM    \"     +    table )  )  . all (  )  . get (  0  )  . getLong (  0  )  ,     9  )  ;", "}", "METHOD_END"], "methodName": ["insertIntoTableMultiPartitionClusteringKeys"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Integer   rowNumber    =     1  ;    rowNumber    <  =    rowsCount ;    rowNumber +  +  )     {", "Insert   insert    =    QueryBuilder . insertInto ( table . getSchemaName (  )  ,    table . getTableName (  )  )  . value (  \" key \"  ,     (  \" key    \"     +     ( rowNumber . toString (  )  )  )  )  . value (  \" typeuuid \"  ,    UUID . fromString ( String . format (  \"  0  0  0  0  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  %  0  1  2 d \"  ,    rowNumber )  )  )  . value (  \" typeinteger \"  ,    rowNumber )  . value (  \" typelong \"  ,     (  ( rowNumber . longValue (  )  )     +     1  0  0  0  )  )  . value (  \" typebytes \"  ,    ByteBuffer . wrap ( Ints . toByteArray ( rowNumber )  )  . asReadOnlyBuffer (  )  )  . value (  \" typetimestamp \"  ,    date )  . value (  \" typeansi \"  ,     (  \" ansi    \"     +    rowNumber )  )  . value (  \" typlean \"  ,     (  ( rowNumber    %     2  )     =  =     0  )  )  . value (  \" typedecimal \"  ,    new   BigDecimal ( Math . pow (  2  ,    rowNumber )  )  )  . value (  \" typedouble \"  ,    Math . pow (  4  ,    rowNumber )  )  . value (  \" typefloat \"  ,     (  ( float )     ( Math . pow (  8  ,    rowNumber )  )  )  )  . value (  \" typeinet \"  ,    InetAddresses . forString (  \"  1  2  7  .  0  .  0  .  1  \"  )  )  . value (  \" typevarchar \"  ,     (  \" varchar    \"     +    rowNumber )  )  . value (  \" typevarint \"  ,    BigInteger . TEN . pow ( rowNumber )  )  . value (  \" typetimeuuid \"  ,    UUID . fromString ( String . format (  \" d 2  1  7  7 dd 0  - eaa 2  -  1  1 de - a 5  7  2  -  0  0  1 b 7  7  9 c 7  6 e % d \"  ,    rowNumber )  )  )  . value (  \" typelist \"  ,    ImmutableList . of (  (  \" list - value -  1  \"     +    rowNumber )  ,     (  \" list - value -  2  \"     +    rowNumber )  )  )  . value (  \" typemap \"  ,    ImmutableMap . of ( rowNumber ,     ( rowNumber    +     1 L )  ,     ( rowNumber    +     2  )  ,     ( rowNumber    +     3 L )  )  )  . value (  \" typeset \"  ,    ImmutableSet . of ( false ,    true )  )  ;", "session . execute ( insert )  ;", "}", "assertEquals ( session . execute (  (  \" SELECT   COUNT (  *  )    FROM    \"     +    table )  )  . all (  )  . get (  0  )  . getLong (  0  )  ,    rowsCount )  ;", "}", "METHOD_END"], "methodName": ["insertTestData"], "fileName": "com.facebook.presto.cassandra.CassandraTestingUtils"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( range . isEmpty (  )  )  )  ,     \" tokenRange   must   not   be   empty \"  )  ;", "String   startToken    =    range . getStart (  )  . toString (  )  ;", "String   endToken    =    range . getEnd (  )  . toString (  )  ;", "return   new    . TokenSplit ( startToken ,    endToken ,    endpoints )  ;", "}", "METHOD_END"], "methodName": ["createSplit"], "fileName": "com.facebook.presto.cassandra.CassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "Set < Host >    endpoints    =    session . getReplicas ( keyspace ,    tokenRange )  ;", "return   Collections . unmodifiableList ( endpoints . stream (  )  . map ( Host :  : toString )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getEndpoints"], "fileName": "com.facebook.presto.cassandra.CassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "Set < TokenRange >    tokenRanges    =    session . getTokenRanges (  )  ;", "if    ( tokenRanges . isEmpty (  )  )     {", "throw   new   PrestoException ( CassandraErrorCode . CASSANDRA _ METADATA _ ERROR ,     (  \" The   cluster   metadata   is   not   available .     \"     +     (  \" Please   make   sure   that   the   Cassandra   cluster   is   up   and   running ,     \"     +     \" and   that   the   contact   points   are   specified   correctly .  \"  )  )  )  ;", "}", "if    ( tokenRanges . stream (  )  . anyMatch ( TokenRange :  : isWrappedAround )  )     {", "tokenRanges    =    unwrap ( tokenRanges )  ;", "}", "Optional < TokenRing >    tokenRing    =    TokenRing . createForPartitioner ( session . getPartitioner (  )  )  ;", "long   totalPartitionsCount    =    getTotalPartitionsCount ( keyspace ,    table )  ;", "List <  . TokenSplit >    splits    =    new   ArrayList <  >  (  )  ;", "for    ( TokenRange   tokenRange    :    tokenRanges )     {", "if    ( tokenRange . isEmpty (  )  )     {", "continue ;", "}", "checkState (  (  !  ( tokenRange . isWrappedAround (  )  )  )  ,     \" all   token   ranges   must   be   unwrapped   at   this   step \"  )  ;", "List < String >    endpoints    =    getEndpoints ( keyspace ,    tokenRange )  ;", "checkState (  (  !  ( endpoints . isEmpty (  )  )  )  ,     \" endpoints   is   empty   for   token   range :     % s \"  ,    tokenRange )  ;", "if    (  !  ( tokenRing . isPresent (  )  )  )     {", "checkState (  (  !  ( tokenRange . isWrappedAround (  )  )  )  ,     \" all   token   ranges   must   be   unwrapped   at   this   step \"  )  ;", "splits . add (  . createSplit ( tokenRange ,    endpoints )  )  ;", "continue ;", "}", "double   tokenRangeRingFraction    =    tokenRing . get (  )  . getRingFraction ( tokenRange . getStart (  )  . toString (  )  ,    tokenRange . getEnd (  )  . toString (  )  )  ;", "long   partitionsCountEstimate    =    Math . round (  ( totalPartitionsCount    *    tokenRangeRingFraction )  )  ;", "checkState (  ( partitionsCountEstimate    >  =     0  )  ,     \" unexpected   partitions   count   estimate :     % d \"  ,    partitionsCountEstimate )  ;", "int   subSplitCount    =    Math . max ( StrictMath . toIntExact (  ( partitionsCountEstimate    /     ( splitSize )  )  )  ,     1  )  ;", "List < TokenRange >    subRanges    =    tokenRange . splitEvenly ( subSplitCount )  ;", "for    ( TokenRange   subRange    :    subRanges )     {", "if    ( subRange . isEmpty (  )  )     {", "continue ;", "}", "checkState (  (  !  ( subRange . isWrappedAround (  )  )  )  ,     \" all   token   ranges   must   be   unwrapped   at   this   step \"  )  ;", "splits . add (  . createSplit ( subRange ,    endpoints )  )  ;", "}", "}", "Collections . shuffle ( splits ,    ThreadLocalRandom . current (  )  )  ;", "return   Collections . unmodifiableList ( splits )  ;", "}", "METHOD_END"], "methodName": ["getSplits"], "fileName": "com.facebook.presto.cassandra.CassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "List < SizeEstimate >    estimates    =    session . getSizeEstimates ( keyspace ,    table )  ;", "return   estimates . stream (  )  . mapToLong ( SizeEstimate :  : getPartitionsCount )  . sum (  )  ;", "}", "METHOD_END"], "methodName": ["getTotalPartitionsCount"], "fileName": "com.facebook.presto.cassandra.CassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "ImmutableSet . Builder < TokenRange >    result    =    ImmutableSet . builder (  )  ;", "for    ( TokenRange   range    :    tokenRanges )     {", "result . addAll ( range . unwrap (  )  )  ;", "}", "return   result . build (  )  ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "com.facebook.presto.cassandra.CassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  [  \"  )  ;", "for    ( Object   value    :    collection )     {", "if    (  ( sb . length (  )  )     >     1  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append (  . objectToString ( value ,    elemType )  )  ;", "}", "sb . append (  \"  ]  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildArrayValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "return   CassandraType . buildArrayValue ( row . getList ( i ,    elemType . javaType )  ,    elemType )  ;", "}", "METHOD_END"], "methodName": ["buildListValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \"  {  \"  )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    row . getMap ( i ,    keyType . javaType ,    valueType . javaType )  . entrySet (  )  )     {", "if    (  ( sb . length (  )  )     >     1  )     {", "sb . append (  \"  ,  \"  )  ;", "}", "sb . append (  . objectToString ( entry . getKey (  )  ,    keyType )  )  ;", "sb . append (  \"  :  \"  )  ;", "sb . append (  . objectToString ( entry . getValue (  )  ,    valueType )  )  ;", "}", "sb . append (  \"  }  \"  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildMapValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "return   CassandraType . buildArrayValue ( row . getSet ( i ,    elemType . javaType )  ,    elemType )  ;", "}", "METHOD_END"], "methodName": ["buildSetValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( typeArguments    =  =    null )     |  |     (  ( typeArguments . size (  )  )     !  =    expectedSize )  )     {", "throw   new   IllegalArgumentException (  (  (  (  \" Wrong   number   of   type   arguments    \"     +    typeArguments )     +     \"    for    \"  )     +    type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkTypeArguments"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( name )     {", "case   ASCII    :", "return    . ASCII ;", "case   BIGINT    :", "return    . BIGINT ;", "case   BLOB    :", "return    . BLOB ;", "case   BOOLEAN    :", "return    . BOOLEAN ;", "case   COUNTER    :", "return    . COUNTER ;", "case   CUSTOM    :", "return    . CUSTOM ;", "case   DECIMAL    :", "return    . DECIMAL ;", "case   DOUBLE    :", "return    . DOUBLE ;", "case   FLOAT    :", "return    . FLOAT ;", "case   INET    :", "return    . INET ;", "case   INT    :", "return    . INT ;", "case   LIST    :", "return    . LIST ;", "case   MAP    :", "return    . MAP ;", "case   SET    :", "return    . SET ;", "case   TEXT    :", "return    . TEXT ;", "case   TIMESTAMP    :", "return    . TIMESTAMP ;", "case   TIMEUUID    :", "return    . TIMEUUID ;", "case   UUID    :", "return    . UUID ;", "case   VARCHAR    :", "return    . VARCHAR ;", "case   VARINT    :", "return    . VARINT ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getCassandraType"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "Type   nativeType    =    cassandraType . getNativeType (  )  ;", "if    ( row . isNull ( i )  )     {", "return   NullableValue . asNull ( nativeType )  ;", "} else    {", "switch    ( cassandraType )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( row . getString ( i )  )  )  ;", "case   INT    :", "return   NullableValue . of ( nativeType ,     (  ( long )     ( row . getInt ( i )  )  )  )  ;", "case   BIGINT    :", "case   COUNTER    :", "return   NullableValue . of ( nativeType ,    row . getLong ( i )  )  ;", "case   BOOLEAN    :", "return   NullableValue . of ( nativeType ,    row . getBool ( i )  )  ;", "case   DOUBLE    :", "return   NullableValue . of ( nativeType ,    row . getDouble ( i )  )  ;", "case   FLOAT    :", "return   NullableValue . of ( nativeType ,     (  ( long )     ( Float . floatToRawIntBits ( row . getFloat ( i )  )  )  )  )  ;", "case   DECIMAL    :", "return   NullableValue . of ( nativeType ,    row . getDecimal ( i )  . doubleValue (  )  )  ;", "case   UUID    :", "case   TIMEUUID    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( row . getUUID ( i )  . toString (  )  )  )  ;", "case   TIMESTAMP    :", "return   NullableValue . of ( nativeType ,    row . getTimestamp ( i )  . getTime (  )  )  ;", "case   INET    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( toAddrString ( row . getInet ( i )  )  )  )  ;", "case   VARINT    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( row . getVarint ( i )  . toString (  )  )  )  ;", "case   BLOB    :", "case   CUSTOM    :", "return   NullableValue . of ( nativeType ,    wrappedBuffer ( row . getBytesUnsafe ( i )  )  )  ;", "case   SET    :", ". checkTypeArguments ( cassandraType ,     1  ,    typeArguments )  ;", "return   NullableValue . of ( nativeType ,    utf 8 Slice (  . buildSetValue ( row ,    i ,    typeArguments . get (  0  )  )  )  )  ;", "case   LIST    :", ". checkTypeArguments ( cassandraType ,     1  ,    typeArguments )  ;", "return   NullableValue . of ( nativeType ,    utf 8 Slice (  . buildListValue ( row ,    i ,    typeArguments . get (  0  )  )  )  )  ;", "case   MAP    :", ". checkTypeArguments ( cassandraType ,     2  ,    typeArguments )  ;", "return   NullableValue . of ( nativeType ,    utf 8 Slice (  . buildMapValue ( row ,    i ,    typeArguments . get (  0  )  ,    typeArguments . get (  1  )  )  )  )  ;", "default    :", "throw   new   IllegalStateException (  (  (  \" Handling   of   type    \"     +    cassandraType )     +     \"    is   not   implemented \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "return   CassandraType . getColumnValue ( row ,    i ,    fullCassandraType . getCassandraType (  )  ,    fullCassandraType . getTypeArguments (  )  )  ;", "}", "METHOD_END"], "methodName": ["getColumnValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "if    ( row . isNull ( i )  )     {", "return   null ;", "} else    {", "switch    ( c )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "return   CassandraCqlUtils . quoteStringLiteral ( row . getString ( i )  )  ;", "case   INT    :", "return   Integer . toString ( row . getInt ( i )  )  ;", "case   BIGINT    :", "case   COUNTER    :", "return   Long . toString ( row . getLong ( i )  )  ;", "case   BOOLEAN    :", "return   Boolean . toString ( row . getBool ( i )  )  ;", "case   DOUBLE    :", "return   Double . toString ( row . getDouble ( i )  )  ;", "case   FLOAT    :", "return   Float . toString ( row . getFloat ( i )  )  ;", "case   DECIMAL    :", "return   row . getDecimal ( i )  . toString (  )  ;", "case   UUID    :", "case   TIMEUUID    :", "return   row . getUUID ( i )  . toString (  )  ;", "case   TIMESTAMP    :", "return   Long . toString ( row . getTimestamp ( i )  . getTime (  )  )  ;", "case   INET    :", "return   CassandraCqlUtils . quoteStringLiteral ( toAddrString ( row . getInet ( i )  )  )  ;", "case   VARINT    :", "return   row . getVarint ( i )  . toString (  )  ;", "case   BLOB    :", "case   CUSTOM    :", "return   Bytes . toHexString ( row . getBytesUnsafe ( i )  )  ;", "default    :", "throw   new   IllegalStateException (  (  (  \" Handling   of   type    \"     +    c )     +     \"    is   not   implemented \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getColumnValueForCql"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "Type   nativeType    =    cassandraType . getNativeType (  )  ;", "if    ( row . isNull ( i )  )     {", "return   NullableValue . asNull ( nativeType )  ;", "}", "switch    ( cassandraType )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( row . getString ( i )  )  )  ;", "case   UUID    :", "case   TIMEUUID    :", "return   NullableValue . of ( nativeType ,    utf 8 Slice ( row . getUUID ( i )  . toString (  )  )  )  ;", "default    :", "return    . getColumnValue ( row ,    i ,    cassandraType ,    typeArguments )  ;", "}", "}", "METHOD_END"], "methodName": ["getColumnValueForPartitionKey"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "e   ASCII    :", "e   TEXT    :", "e   VARCHAR    :", "return    (  ( Slice )     ( nativeValue )  )  . toStringUtf 8  (  )  ;", "e   BIGINT    :", "e   BOOLEAN    :", "e   DOUBLE    :", "e   COUNTER    :", "return   nativeValue ;", "e   INET    :", "return   InetAddresses . forString (  (  ( Slice )     ( nativeValue )  )  . toStringUtf 8  (  )  )  ;", "e   INT    :", "return    (  ( Long )     ( nativeValue )  )  . intValue (  )  ;", "e   FLOAT    :", "return   Float . intBitsToFloat (  (  ( Long )     ( nativeValue )  )  . intValue (  )  )  ;", "e   DECIMAL    :", "return   new   BigDecimal ( nativeValue . toString (  )  )  ;", "e   TIMESTAMP    :", "return   new   Date (  (  ( Long )     ( nativeValue )  )  )  ;", "e   UUID    :", "e   TIMEUUID    :", "return   UUID . fromString (  (  ( Slice )     ( nativeValue )  )  . toStringUtf 8  (  )  )  ;", "e   BLOB    :", "e   CUSTOM    :", "return    (  ( Slice )     ( nativeValue )  )  . toStringUtf 8  (  )  ;", "e   VARINT    :", "return   new   BigInteger (  (  ( Slice )     ( nativeValue )  )  . toStringUtf 8  (  )  )  ;", "e   SET    :", "e   LIST    :", "e   MAP    :", "default    :", "throw   new   IllegalStateException (  (  \" Back   conversion   not   implemented   for    \"     +     ( this )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getJavaValue"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "return   nativeType ;", "}", "METHOD_END"], "methodName": ["getNativeType"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "e   LIST    :", "e   SET    :", "return    1  ;", "e   MAP    :", "return    2  ;", "default    :", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["getTypeArgumentSize"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( elemType )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "case   UUID    :", "case   TIMEUUID    :", "case   TIMESTAMP    :", "case   INET    :", "case   VARINT    :", "return   CqlUtils . quoteStringLiteralForJson ( object . toString (  )  )  ;", "case   BLOB    :", "case   CUSTOM    :", "return   CqlUtils . quoteStringLiteralForJson ( Bytes . toHexString (  (  ( ByteBuffer )     ( object )  )  )  )  ;", "case   INT    :", "case   BIGINT    :", "case   COUNTER    :", "case   BOOLEAN    :", "case   DOUBLE    :", "case   FLOAT    :", "case   DECIMAL    :", "return   object . toString (  )  ;", "default    :", "throw   new   IllegalStateException (  (  (  \" Handling   of   type    \"     +    elemType )     +     \"    is   not   implemented \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["objectToString"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals ( BOOLEAN )  )     {", "return    . BOOLEAN ;", "} else", "if    ( type . equals ( BigintType . BIGINT )  )     {", "return    . BIGINT ;", "} else", "if    ( type . equals ( IntegerType . INTEGER )  )     {", "return    . INT ;", "} else", "if    ( type . equals ( DoubleType . DOUBLE )  )     {", "return    . DOUBLE ;", "} else", "if    ( type . equals ( RealType . REAL )  )     {", "return    . FLOAT ;", "} else", "if    ( isVarcharType ( type )  )     {", "return    . TEXT ;", "} else", "if    ( type . equals ( DateType . DATE )  )     {", "return    . TEXT ;", "} else", "if    ( type . equals ( VarbinaryType . VARBINARY )  )     {", "return    . BLOB ;", "} else", "if    ( type . equals ( TimestampType . TIMESTAMP )  )     {", "return    . TIMESTAMP ;", "}", "throw   new   IllegalArgumentException (  (  \" unsupported   type :     \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["toCassandraType"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "case   BIGINT    :", "case   BOOLEAN    :", "case   DOUBLE    :", "case   INET    :", "case   INT    :", "case   FLOAT    :", "case   DECIMAL    :", "case   TIMESTAMP    :", "case   UUID    :", "case   TIMEUUID    :", "return   value ;", "case   COUNTER    :", "case   BLOB    :", "case   CUSTOM    :", "case   VARINT    :", "case   SET    :", "case   LIST    :", "case   MAP    :", "default    :", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,     (  \" Unsupported   clustering   key   type :     \"     +     ( this )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateClusteringKey"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "switch    ( this )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "case   BIGINT    :", "case   BOOLEAN    :", "case   DOUBLE    :", "case   INET    :", "case   INT    :", "case   FLOAT    :", "case   DECIMAL    :", "case   TIMESTAMP    :", "case   UUID    :", "case   TIMEUUID    :", "return   value ;", "case   COUNTER    :", "case   BLOB    :", "case   CUSTOM    :", "case   VARINT    :", "case   SET    :", "case   LIST    :", "case   MAP    :", "default    :", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,     (  \" Unsupport   partition   key   type :     \"     +     ( this )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validatePartitionKey"], "fileName": "com.facebook.presto.cassandra.CassandraType"}, {"methodBody": ["METHOD_START", "{", "ResultSet   result    =    session . execute (  \" SELECT   release _ version   FROM   system . local \"  )  ;", "List < Row >    rows    =    result . all (  )  ;", "assertEquals ( rows . size (  )  ,     1  )  ;", "String   version    =    rows . get (  0  )  . getString (  0  )  ;", ". log . info (  \" Cassandra   version :     % s \"  ,    version )  ;", "}", "METHOD_END"], "methodName": ["checkConnectivity"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "checkState ( EmbeddedCassandra . initialized ,     \" EmbeddedCassandra   must   be   started   with    # start (  )    method   before   retrieving   the   cluster   retrieval \"  )  ;", "}", "METHOD_END"], "methodName": ["checkIsInitialized"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "ManagementFactory . getPlatformMBeanServer (  )  . invoke ( new   ObjectName (  \" db : type = StorageService \"  )  ,     \" forceKeyspaceFlush \"  ,    new   Object [  ]  {    keyspace ,    new   String [  ]  {    table    }     }  ,    new   String [  ]  {     \" String \"  ,     \"  [ LString ;  \"     }  )  ;", "}", "METHOD_END"], "methodName": ["flushTable"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . checkIsInitialized (  )  ;", "return   EmbeddedCassandra . HOST ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . checkIsInitialized (  )  ;", "return   EmbeddedCassandra . PORT ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . checkIsInitialized (  )  ;", "return   Objects . requireNonNull ( EmbeddedCassandra . session ,     \" cluster   is   null \"  )  ;", "}", "METHOD_END"], "methodName": ["getSession"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "String   original    =    Resources . toString ( getResource (  \" cu - cassandra . yaml \"  )  ,    StandardCharsets . UTF _  8  )  ;", "File   tempDirFile    =    createTempDir (  )  ;", "tempDirFile . deleteOnExit (  )  ;", "Path   tmpDirPath    =    tempDirFile . toPath (  )  ;", "Path   dataDir    =    tmpDirPath . resolve (  \" data \"  )  ;", "Files . createDirectory ( dataDir )  ;", "String   modified    =    original . replaceAll (  \"  \\  \\  $  \\  \\  { data _ directory \\  \\  }  \"  ,    dataDir . toAbsolutePath (  )  . toString (  )  )  ;", "Path   yamlLocation    =    tmpDirPath . resolve (  \" cu - cassandra . yaml \"  )  ;", "write ( modified ,    yamlLocation . toFile (  )  ,    StandardCharsets . UTF _  8  )  ;", "return   yamlLocation . toAbsolutePath (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["prepareCassandraYaml"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "ManagementFactory . getPlatformMBeanServer (  )  . invoke ( new   ObjectName (  \" db : type = StorageService \"  )  ,     \" refreshSizeEstimates \"  ,    new   Object [  ]  {        }  ,    new   String [  ]  {        }  )  ;", "}", "METHOD_END"], "methodName": ["refreshSizeEstimates"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "long   deadline    =     ( System . nanoTime (  )  )     +     ( EmbeddedCassandra . REFRESH _ SIZE _ ESTIMATES _ TIMEOUT . roundTo ( TimeUnit . NANOSECONDS )  )  ;", "while    (  (  ( System . nanoTime (  )  )     -    deadline )     <     0  )     {", "EmbeddedCassandra . flushTable ( keyspace ,    table )  ;", "EmbeddedCassandra . refreshSizeEstimates (  )  ;", "List < SizeEstimate >    sizeEstimates    =    EmbeddedCassandra . getSession (  )  . getSizeEstimates ( keyspace ,    table )  ;", "if    (  !  ( sizeEstimates . isEmpty (  )  )  )     {", "EmbeddedCassandra . log . info (  \" Size   estimates   for   the   table    % s .  % s   have   been   refreshed   successfully :     % s \"  ,    keyspace ,    table ,    sizeEstimates )  ;", "return ;", "}", "EmbeddedCassandra . log . info (  \" Size   estimates   haven ' t   been   refreshed   as   expected .    Retrying    .  .  .  \"  )  ;", "TimeUnit . SECONDS . sleep (  1  )  ;", "}", "throw   new   TimeoutException ( String . format (  \" Attempting   to   refresh   size   estimates   for   table    % s .  % s   has   timed   out   after    % s \"  ,    keyspace ,    table ,    EmbeddedCassandra . REFRESH _ SIZE _ ESTIMATES _ TIMEOUT )  )  ;", "}", "METHOD_END"], "methodName": ["refreshSizeEstimates"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "if    ( EmbeddedCassandra . initialized )     {", "return ;", "}", "EmbeddedCassandra . log . info (  \" Starting   cassandra .  .  .  \"  )  ;", "System . setProperty (  \" cassandra . config \"  ,     (  \" file :  \"     +     ( EmbeddedCassandra . prepareCassandraYaml (  )  )  )  )  ;", "System . setProperty (  \" cassandra - foreground \"  ,     \" true \"  )  ;", "System . setProperty (  \" cassandra . native . epoll . enabled \"  ,     \" false \"  )  ;", "CassandraDaemon   cassandraDaemon    =    new   CassandraDaemon (  )  ;", "cassandraDaemon . activate (  )  ;", "Cluster . Builder   clusterBuilder    =    Cluster . builder (  )  . withProtocolVersion ( ProtocolVersion . V 3  )  . withClusterName (  \" TestCluster \"  )  . addContactPointsWithPorts ( ImmutableList . of ( new   InetSocketAddress ( EmbeddedCassandra . HOST ,    EmbeddedCassandra . PORT )  )  )  . withMaxSchemaAgreementWaitSeconds (  3  0  )  ;", "ReopeningCluster   cluster    =    new   ReopeningCluster ( clusterBuilder :  : build )  ;", "CassandraSession   session    =    new   NativeCassandraSession (  \" EmbeddedCassandra \"  ,    JsonCodec . listJsonCodec ( ExtraColumnMetadata . class )  ,    cluster ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "try    {", "EmbeddedCassandra . checkConnectivity ( session )  ;", "}    catch    ( RuntimeException   e )     {", "cluster . close (  )  ;", "cassandraDaemon . deactivate (  )  ;", "throw   e ;", "}", "EmbeddedCassandra . session    =    session ;", "EmbeddedCassandra . initialized    =    true ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "com.facebook.presto.cassandra.EmbeddedCassandra"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.facebook.presto.cassandra.ExtraColumnMetadata"}, {"methodBody": ["METHOD_START", "{", "return   hidden ;", "}", "METHOD_END"], "methodName": ["isHidden"], "fileName": "com.facebook.presto.cassandra.ExtraColumnMetadata"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( filterPrefix . size (  )  )  ;    i +  +  )     {", "ColumnHandle   column    =    partitionKeyColumns . get ( i )  ;", "Object   value    =    column . getType (  )  . getJavaValue ( filterPrefix . get ( i )  )  ;", "Clause   clause    =    QueryBuilder . eq ( CqlUtils . validColumnName ( column . getName (  )  )  ,    value )  ;", "where . and ( clause )  ;", "}", "}", "METHOD_END"], "methodName": ["addWhereClause"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "CassandraType   cassandraType    =    CassandraType . getCassandraType ( columnMeta . getType (  )  . getName (  )  )  ;", "List < CassandraType >    typeArguments    =    null ;", "if    (  ( cassandraType    !  =    null )     &  &     (  ( cassandraType . getTypeArgumentSize (  )  )     >     0  )  )     {", "List < DataType >    typeArgs    =    columnMeta . getType (  )  . getTypeArguments (  )  ;", "switch    ( cassandraType . getTypeArgumentSize (  )  )     {", "case    1     :", "typeArguments    =    ImmutableList . of ( CassandraType . getCassandraType ( typeArgs . get (  0  )  . getName (  )  )  )  ;", "break ;", "case    2     :", "typeArguments    =    ImmutableList . of ( CassandraType . getCassandraType ( typeArgs . get (  0  )  . getName (  )  )  ,    CassandraType . getCassandraType ( typeArgs . get (  1  )  . getName (  )  )  )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Invalid   type   arguments :     \"     +    typeArgs )  )  ;", "}", "}", "boolean   indexed    =    false ;", "for    ( IndexMetadata   idx    :    tableMetadata . getIndexes (  )  )     {", "if    ( idx . getTarget (  )  . equals ( columnMeta . getName (  )  )  )     {", "indexed    =    true ;", "break ;", "}", "}", "return   new   CassandraColumnHandle ( connectorId ,    columnMeta . getName (  )  ,    ordinalPosition ,    cassandraType ,    typeArguments ,    partitionKey ,    clusteringKey ,    indexed ,    hidden )  ;", "}", "METHOD_END"], "methodName": ["buildColumnHandle"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ColumnMetadata >    lowercaseNameToColumnMap    =    new   HashMap <  >  (  )  ;", "for    ( ColumnMetadata   column    :    columns )     {", "String   lowercaseName    =    column . getName (  )  . toLowerCase ( Locale . ENGLISH )  ;", "if    ( lowercaseNameToColumnMap . containsKey ( lowercaseName )  )     {", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,    String . format (  \" More   than   one   column   has   been   found   for   the   case   insensitive   column   name :     % s    -  >     (  % s ,     % s )  \"  ,    lowercaseName ,    lowercaseNameToColumnMap . get ( lowercaseName )  . getName (  )  ,    column . getName (  )  )  )  ;", "}", "lowercaseNameToColumnMap . put ( lowercaseName ,    column )  ;", "}", "}", "METHOD_END"], "methodName": ["checkColumnNames"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "KeyspaceMetadata   keyspaceMetadata    =    executeWithSession (  (    session )     -  >    session . getCluster (  )  . getMetadata (  )  . getKeyspace ( NativeCassandraSession . SYSTEM )  )  ;", "checkState (  ( keyspaceMetadata    !  =    null )  ,     \" system   keyspace   metadata   must   not   be   null \"  )  ;", "TableMetadata   table    =    keyspaceMetadata . getTable ( NativeCassandraSession . SIZE _ ESTIMATES )  ;", "if    ( table    =  =    null )     {", "throw   new   com . facebook . presto . spi . PrestoException ( NOT _ SUPPORTED ,     \" Cassandra   versions   prior   to    2  .  1  .  5    are   not   supported \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkSizeEstimatesTableExist"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "ReconnectionPolicy   reconnectionPolicy    =    cluster . getConfiguration (  )  . getPolicies (  )  . getReconnectionPolicy (  )  ;", "ReconnectionSchedule   schedule    =    reconnectionPolicy . newSchedule (  )  ;", "long   deadline    =     ( System . currentTimeMillis (  )  )     +     ( noHostAvailableRetryTimeout . toMillis (  )  )  ;", "while    ( true )     {", "try    {", "return   sessionCallable . executeWithSession ( session . get (  )  )  ;", "}    catch    ( NoHostAvailableException   e )     {", "long   timeLeft    =    deadline    -     ( System . currentTimeMillis (  )  )  ;", "if    ( timeLeft    <  =     0  )     {", "throw   e ;", "} else    {", "long   delay    =    Math . min ( schedule . nextDelayMs (  )  ,    timeLeft )  ;", ". log . warn ( e . getCustomMessage (  1  0  ,    true ,    true )  )  ;", ". log . warn (  \" Reconnecting   in    % dms \"  ,    delay )  ;", "try    {", "Thread . sleep ( delay )  ;", "}    catch    ( InterruptedException   interrupted )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "throw   new   RuntimeException (  \" interrupted \"  ,    interrupted )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["executeWithSession"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "List < KeyspaceMetadata >    keyspaces    =    executeWithSession (  (    session )     -  >    session . getCluster (  )  . getMetadata (  )  . getKeyspaces (  )  )  ;", "KeyspaceMetadata   result    =    null ;", "List < KeyspaceMetadata >    sortedKeyspaces    =    Ordering . from ( Comparator . comparing ( KeyspaceMetadata :  : getName )  )  . immutableSortedCopy ( keyspaces )  ;", "for    ( KeyspaceMetadata   keyspace    :    sortedKeyspaces )     {", "if    ( keyspace . getName (  )  . equalsIgnoreCase ( caseInsensitiveSchemaName )  )     {", "if    ( result    !  =    null )     {", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,    String . format (  \" More   than   one   keyspace   has   been   found   for   the   case   insensitive   schema   name :     % s    -  >     (  % s ,     % s )  \"  ,    caseInsensitiveSchemaName ,    result . getName (  )  ,    keyspace . getName (  )  )  )  ;", "}", "result    =    keyspace ;", "}", "}", "if    ( result    =  =    null )     {", "throw   new   SchemaNotFoundException ( caseInsensitiveSchemaName )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getKeyspaceByCaseInsensitiveName"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "TableMetadata   result    =    null ;", "Collection < TableMetadata >    tables    =    keyspace . getTables (  )  ;", "List < TableMetadata >    sortedTables    =    Ordering . from ( Comparator . comparing ( TableMetadata :  : getName )  )  . immutableSortedCopy ( tables )  ;", "for    ( TableMetadata   table    :    sortedTables )     {", "if    ( table . getName (  )  . equalsIgnoreCase ( caseInsensitiveTableName )  )     {", "if    ( result    !  =    null )     {", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,    String . format (  \" More   than   one   table   has   been   found   for   the   case   insensitive   table   name :     % s    -  >     (  % s ,     % s )  \"  ,    caseInsensitiveTableName ,    result . getName (  )  ,    table . getName (  )  )  )  ;", "}", "result    =    table ;", "}", "}", "if    ( result    =  =    null )     {", "throw   new   TableNotFoundException ( new   spi . SchemaTableName ( keyspace . getName (  )  ,    caseInsensitiveTableName )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTableMetadata"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "CassandraTableHandle   tableHandle    =    table . getTableHandle (  )  ;", "List < CassandraColumnHandle >    partitionKeyColumns    =    table . getPartitionKeyColumns (  )  ;", "if    (  ( filterPrefix . size (  )  )     !  =     ( partitionKeyColumns . size (  )  )  )     {", "return   null ;", "}", "Select   partitionKeys    =    CassandraCqlUtils . selectDistinctFrom ( tableHandle ,    partitionKeyColumns )  ;", ". addWhereClause ( partitionKeys . where (  )  ,    partitionKeyColumns ,    filterPrefix )  ;", "return   execute ( partitionKeys )  . all (  )  ;", "}", "METHOD_END"], "methodName": ["queryPartitionKeys"], "fileName": "com.facebook.presto.cassandra.NativeCassandraSession"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  ( token . compareTo ( RandomPartitionerTokenRing . MIN _ TOKEN )  )     >  =     0  )  ,     \" token    [  % s ]    must   be   greater   or   equal   than    % s \"  ,    token ,    RandomPartitionerTokenRing . MIN _ TOKEN )  ;", "checkArgument (  (  ( token . compareTo ( RandomPartitionerTokenRing . MAX _ TOKEN )  )     <  =     0  )  ,     \" token    [  % s ]    must   be   less   or   equal   than    % s \"  ,    token ,    RandomPartitionerTokenRing . MAX _ TOKEN )  ;", "}", "METHOD_END"], "methodName": ["checkTokenBounds"], "fileName": "com.facebook.presto.cassandra.RandomPartitionerTokenRing"}, {"methodBody": ["METHOD_START", "{", "return   policy ;", "}", "METHOD_END"], "methodName": ["getPolicy"], "fileName": "com.facebook.presto.cassandra.RetryPolicyType"}, {"methodBody": ["METHOD_START", "{", "return   meanPartitionSize ;", "}", "METHOD_END"], "methodName": ["getMeanPartitionSize"], "fileName": "com.facebook.presto.cassandra.SizeEstimate"}, {"methodBody": ["METHOD_START", "{", "return   partitionsCount ;", "}", "METHOD_END"], "methodName": ["getPartitionsCount"], "fileName": "com.facebook.presto.cassandra.SizeEstimate"}, {"methodBody": ["METHOD_START", "{", "return   rangeEnd ;", "}", "METHOD_END"], "methodName": ["getRangeEnd"], "fileName": "com.facebook.presto.cassandra.SizeEstimate"}, {"methodBody": ["METHOD_START", "{", "return   rangeStart ;", "}", "METHOD_END"], "methodName": ["getRangeStart"], "fileName": "com.facebook.presto.cassandra.SizeEstimate"}, {"methodBody": ["METHOD_START", "{", "ConfigAssertions . assertRecordedDefaults ( ConfigAssertions . recordDefaults ( CassandraClientConfig . class )  . setFetchSize (  5  0  0  0  )  . setConsistencyLevel ( ONE )  . setContactPoints (  \"  \"  )  . setNativeProtocolPort (  9  0  4  2  )  . setPartitionSizeForBatchSelect (  1  0  0  )  . setSplitSize (  1  0  2  4  )  . setAllowDropTable ( false )  . setUsername ( null )  . setPassword ( null )  . setClientReadTimeout ( new   Duration ( SocketOptions . DEFAULT _ READ _ TIMEOUT _ MILLIS ,    TimeUnit . MILLISECONDS )  )  . setClientConnectTimeout ( new   Duration ( SocketOptions . DEFAULT _ CONNECT _ TIMEOUT _ MILLIS ,    TimeUnit . MILLISECONDS )  )  . setClientSoLinger ( null )  . setRetryPolicy ( RetryPolicyType . DEFAULT )  . setUseDCAware ( false )  . setDcAwareLocalDC ( null )  . setDcAwareUsedHostsPerRemoteDc (  0  )  . setDcAwareAllowRemoteDCsForLocal ( false )  . setUseTokenAware ( false )  . setTokenAwareShuffleReplicas ( false )  . setUseWhiteList ( false )  . setWhiteListAddresses (  \"  \"  )  . setNoHostAvailableRetryTimeout ( new   Duration (  1  ,    TimeUnit . MINUTES )  )  . setSpeculativeExecutionLimit (  1  )  . setSpeculativeExecutionDelay ( new   Duration (  5  0  0  ,    TimeUnit . MILLISECONDS )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaults"], "fileName": "com.facebook.presto.cassandra.TestCassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    properties    =    new   Builder < String ,    String >  (  )  . put (  \" cassandra . contact - points \"  ,     \" host 1  , host 2  \"  )  . put (  \" cassandra . native - protocol - port \"  ,     \"  9  9  9  9  \"  )  . put (  \" cassandra . fetch - size \"  ,     \"  1  0  0  0  0  \"  )  . put (  \" cassandra . consistency - level \"  ,     \" TWO \"  )  . put (  \" cassandra . partition - size - for - batch - select \"  ,     \"  7  7  \"  )  . put (  \" cassandra . split - size \"  ,     \"  1  0  2  5  \"  )  . put (  \" cassandra . allow - drop - table \"  ,     \" true \"  )  . put (  \" cassandra . username \"  ,     \" my _ username \"  )  . put (  \" cassandra . password \"  ,     \" my _ password \"  )  . put (  \" cassandra . client . read - timeout \"  ,     \"  1  1 ms \"  )  . put (  \" cassandra . client . connect - timeout \"  ,     \"  2  2 ms \"  )  . put (  \" cassandra . client . so - linger \"  ,     \"  3  3  \"  )  . put (  \" cassandra . retry - policy \"  ,     \" BACKOFF \"  )  . put (  \" cassandra . load - policy . use - dc - aware \"  ,     \" true \"  )  . put (  \" cassandra . load - policy . dc - aware . local - dc \"  ,     \" dc 1  \"  )  . put (  \" cassandra . load - policy . dc - aware . used - hosts - per - remote - dc \"  ,     \"  1  \"  )  . put (  \" cassandra . load - policy . dc - aware . allow - remote - dc - for - local \"  ,     \" true \"  )  . put (  \" cassandra . load - policy . use - token - aware \"  ,     \" true \"  )  . put (  \" cassandra . load - policy . token - aware . shuffle - replicas \"  ,     \" true \"  )  . put (  \" cassandra . load - policy . use - white - list \"  ,     \" true \"  )  . put (  \" cassandra . load - policy . white - list . addresses \"  ,     \" host 1  \"  )  . put (  \" cassandra . no - host - available - retry - timeout \"  ,     \"  3 m \"  )  . put (  \" cassandra . speculative - execution . limit \"  ,     \"  1  0  \"  )  . put (  \" cassandra . speculative - execution . delay \"  ,     \"  1  0  1 s \"  )  . build (  )  ;", "expected    =    new    (  )  . setContactPoints (  \" host 1  \"  ,     \" host 2  \"  )  . setNativeProtocolPort (  9  9  9  9  )  . setFetchSize (  1  0  0  0  0  )  . setConsistencyLevel ( TWO )  . setPartitionSizeForBatchSelect (  7  7  )  . setSplitSize (  1  0  2  5  )  . setAllowDropTable ( true )  . setUsername (  \" my _ username \"  )  . setPassword (  \" my _ password \"  )  . setClientReadTimeout ( new   Duration (  1  1  ,    TimeUnit . MILLISECONDS )  )  . setClientConnectTimeout ( new   Duration (  2  2  ,    TimeUnit . MILLISECONDS )  )  . setClientSoLinger (  3  3  )  . setRetryPolicy ( RetryPolicyType . BACKOFF )  . setUseDCAware ( true )  . setDcAwareLocalDC (  \" dc 1  \"  )  . setDcAwareUsedHostsPerRemoteDc (  1  )  . setDcAwareAllowRemoteDCsForLocal ( true )  . setUseTokenAware ( true )  . setTokenAwareShuffleReplicas ( true )  . setUseWhiteList ( true )  . setWhiteListAddresses (  \" host 1  \"  )  . setNoHostAvailableRetryTimeout ( new   Duration (  3  ,    TimeUnit . MINUTES )  )  . setSpeculativeExecutionLimit (  1  0  )  . setSpeculativeExecutionDelay ( new   Duration (  1  0  1  ,    TimeUnit . SECONDS )  )  ;", "ConfigAssertions . assertFullMapping ( properties ,    expected )  ;", "}", "METHOD_END"], "methodName": ["testExplicitPropertyMappings"], "fileName": "com.facebook.presto.cassandra.TestCassandraClientConfig"}, {"methodBody": ["METHOD_START", "{", "CassandraColumnHandle   expected    =    new   CassandraColumnHandle (  \" connector \"  ,     \" name \"  ,     4  2  ,    CassandraType . FLOAT ,    null ,    true ,    false ,    false ,    false )  ;", "String   json    =    codec . toJson ( expected )  ;", "CassandraColumnHandle   actual    =    codec . fromJson ( json )  ;", "assertEquals ( actual . getConnectorId (  )  ,    expected . getConnectorId (  )  )  ;", "assertEquals ( actual . getName (  )  ,    expected . getName (  )  )  ;", "assertEquals ( actual . getOrdinalPosition (  )  ,    expected . getOrdinalPosition (  )  )  ;", "assertEquals ( actual . getCassandraType (  )  ,    expected . getCassandraType (  )  )  ;", "assertEquals ( actual . isPartitionKey (  )  ,    expected . isPartitionKey (  )  )  ;", "assertEquals ( actual . isClusteringKey (  )  ,    expected . isClusteringKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRoundTrip"], "fileName": "com.facebook.presto.cassandra.TestCassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "CassandraColumnHandle   expected    =    new   CassandraColumnHandle (  \" connector \"  ,     \" name 2  \"  ,     1  ,    CassandraType . MAP ,    ImmutableList . of ( CassandraType . VARCHAR ,    CassandraType . UUID )  ,    false ,    true ,    false ,    false )  ;", "String   json    =    codec . toJson ( expected )  ;", "CassandraColumnHandle   actual    =    codec . fromJson ( json )  ;", "assertEquals ( actual . getConnectorId (  )  ,    expected . getConnectorId (  )  )  ;", "assertEquals ( actual . getName (  )  ,    expected . getName (  )  )  ;", "assertEquals ( actual . getOrdinalPosition (  )  ,    expected . getOrdinalPosition (  )  )  ;", "assertEquals ( actual . getCassandraType (  )  ,    expected . getCassandraType (  )  )  ;", "assertEquals ( actual . isPartitionKey (  )  ,    expected . isPartitionKey (  )  )  ;", "assertEquals ( actual . isClusteringKey (  )  ,    expected . isClusteringKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRoundTrip2"], "fileName": "com.facebook.presto.cassandra.TestCassandraColumnHandle"}, {"methodBody": ["METHOD_START", "{", "for    ( int   columnIndex    =     0  ;    columnIndex    <     ( schema . size (  )  )  ;    columnIndex +  +  )     {", "ColumnMetadata   column    =    schema . get ( columnIndex )  ;", "if    (  !  ( cursor . isNull ( columnIndex )  )  )     {", "Type   type    =    column . getType (  )  ;", "if    ( BOOLEAN . equals ( type )  )     {", "cursor . getBoolean ( columnIndex )  ;", "} else", "if    ( INTEGER . equals ( type )  )     {", "cursor . getLong ( columnIndex )  ;", "} else", "if    ( BIGINT . equals ( type )  )     {", "cursor . getLong ( columnIndex )  ;", "} else", "if    ( TIMESTAMP . equals ( type )  )     {", "cursor . getLong ( columnIndex )  ;", "} else", "if    ( DOUBLE . equals ( type )  )     {", "cursor . getDouble ( columnIndex )  ;", "} else", "if    ( REAL . equals ( type )  )     {", "cursor . getLong ( columnIndex )  ;", "} else", "if    (  ( isVarcharType ( type )  )     |  |     ( VARBINARY . equals ( type )  )  )     {", "try    {", "cursor . getSlice ( columnIndex )  ;", "}    catch    ( RuntimeException   e )     {", "throw   new   RuntimeException (  (  \" column    \"     +    column )  ,    e )  ;", "}", "} else    {", "fail (  (  \" Unknown   primitive   type    \"     +    columnIndex )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["assertReadFields"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < ConnectorSplit >    splits    =    ImmutableList . builder (  )  ;", "while    (  !  ( splitSource . isFinished (  )  )  )     {", "splits . addAll ( MoreFutures . getFutureValue ( splitSource . getNextBatch ( NOT _ PARTITIONED ,     1  0  0  0  )  )  . getSplits (  )  )  ;", "}", "return   splits . build (  )  ;", "}", "METHOD_END"], "methodName": ["getAllSplits"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "ConnectorTableHandle   handle    =    metadata . getTableHandle ( SESSION ,    tableName )  ;", "checkArgument (  ( handle    !  =    null )  ,     \" table   not   found :     % s \"  ,    tableName )  ;", "return   handle ;", "}", "METHOD_END"], "methodName": ["getTableHandle"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Integer >    index    =    ImmutableMap . builder (  )  ;", "int   i    =     0  ;", "for    ( ColumnHandle   columnHandle    :    columnHandles )     {", "String   name    =     (  ( lumnHandle )     ( columnHandle )  )  . getName (  )  ;", "index . put ( name ,    i )  ;", "i +  +  ;", "}", "return   index . build (  )  ;", "}", "METHOD_END"], "methodName": ["indexColumns"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . start (  )  ;", "String   keyspace    =     \" test _ connector \"  ;", "CassandraTestingUtils . createTestTables ( EmbeddedCassandra . getSession (  )  ,    keyspace ,     . DATE )  ;", "String   connectorId    =     \" cassandra - test \"  ;", "CassandraConnectorFactory   connectorFactory    =    new   CassandraConnectorFactory ( connectorId )  ;", "Connector   connector    =    connectorFactory . create ( connectorId ,    ImmutableMap . of (  \" cassandra . contact - points \"  ,    EmbeddedCassandra . getHost (  )  ,     \" cassandra . native - protocol - port \"  ,    Integer . toString ( EmbeddedCassandra . getPort (  )  )  )  ,    new   TestingConnectorContext (  )  )  ;", "metadata    =    connector . getMetadata ( CassandraTransactionHandle . INSTANCE )  ;", "Assertions . assertInstanceOf ( metadata ,    CassandraMetadata . class )  ;", "splitManager    =    connector . getSplitManager (  )  ;", "Assertions . assertInstanceOf ( splitManager ,    CassandraSplitManager . class )  ;", "recordSetProvider    =    connector . getRecordSetProvider (  )  ;", "Assertions . assertInstanceOf ( recordSetProvider ,    CassandraRecordSetProvider . class )  ;", "database    =    keyspace ;", "table    =    new   SchemaTableName ( database ,    CassandraTestingUtils . TABLE _ ALL _ TYPES . toLowerCase (  )  )  ;", "tableUnpartitioned    =    new   SchemaTableName ( database ,     \" presto _ test _ unpartitioned \"  )  ;", "invalidTable    =    new   SchemaTableName ( database ,     \" totally _ invalid _ table _ name \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "List < String >    databases    =    metadata . listSchemaNames ( SESSION )  ;", "ertTrue ( databases . contains ( database . toLowerCase ( Locale . ENGLISH )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDatabaseNames"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "ConnectorTableHandle   tableHandle    =    getTableHandle ( table )  ;", "ConnectorTableMetadata   tableMetadata    =    metadata . getTableMetadata ( SESSION ,    tableHandle )  ;", "List < ColumnHandle >    columnHandles    =    ImmutableList . copyOf ( metadata . getColumnHandles ( SESSION ,    tableHandle )  . values (  )  )  ;", "Map < String ,    Integer >    columnIndex    =     . indexColumns ( columnHandles )  ;", "ConnectorTransactionHandle   transaction    =    CassandraTransactionHandle . INSTANCE ;", "List < ConnectorTableLayoutResult >    layouts    =    metadata . getTableLayouts ( SESSION ,    tableHandle ,    Constraint . alwaysTrue (  )  ,    Optional . empty (  )  )  ;", "ConnectorTableLayoutHandle   layout    =    getOnlyElement ( layouts )  . getTableLayout (  )  . getHandle (  )  ;", "List < ConnectorSplit >    splits    =     . getAllSplits ( splitManager . getSplits ( transaction ,    SESSION ,    layout ,    UNGROUPED _ SCHEDULING )  )  ;", "long   rowNumber    =     0  ;", "for    ( ConnectorSplit   split    :    splits )     {", "CassandraSplit   cassandraSplit    =     (  ( CassandraSplit )     ( split )  )  ;", "long   completedBytes    =     0  ;", "try    ( RecordCursor   cursor    =    recordSetProvider . getRecordSet ( transaction ,    SESSION ,    cassandraSplit ,    columnHandles )  . cursor (  )  )     {", "while    ( cursor . advanceNextPosition (  )  )     {", "try    {", ". assertReadFields ( cursor ,    tableMetadata . getColumns (  )  )  ;", "}    catch    ( RuntimeException   e )     {", "throw   new   RuntimeException (  (  \" row    \"     +    rowNumber )  ,    e )  ;", "}", "rowNumber +  +  ;", "String   keyValue    =    cursor . getSlice ( columnIndex . get (  \" key \"  )  )  . toStringUtf 8  (  )  ;", "assertTrue ( keyValue . startsWith (  \" key    \"  )  )  ;", "int   rowId    =    Integer . parseInt ( keyValue . substring (  4  )  )  ;", "assertEquals ( keyValue ,    String . format (  \" key    % d \"  ,    rowId )  )  ;", "assertEquals ( Bytes . toHexString ( cursor . getSlice ( columnIndex . get (  \" typebytes \"  )  )  . getBytes (  )  )  ,    String . format (  \"  0 x %  0  8 X \"  ,    rowId )  )  ;", "assertEquals ( cursor . getSlice ( columnIndex . get (  \" typeinteger \"  )  )  . toStringUtf 8  (  )  ,    String . valueOf ( rowId )  )  ;", "assertEquals ( cursor . getLong ( columnIndex . get (  \" typelong \"  )  )  ,     (  1  0  0  0     +    rowId )  )  ;", "assertEquals ( cursor . getSlice ( columnIndex . get (  \" typeuuid \"  )  )  . toStringUtf 8  (  )  ,    String . format (  \"  0  0  0  0  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  %  0  1  2 d \"  ,    rowId )  )  ;", "assertEquals ( cursor . getSlice ( columnIndex . get (  \" typetimestamp \"  )  )  . toStringUtf 8  (  )  ,    Long . valueOf (  . DATE . getTime (  )  )  . toString (  )  )  ;", "long   newCompletedBytes    =    cursor . getCompletedBytes (  )  ;", "assertTrue (  ( newCompletedBytes    >  =    completedBytes )  )  ;", "completedBytes    =    newCompletedBytes ;", "}", "}", "}", "assertEquals ( rowNumber ,     9  )  ;", "}", "METHOD_END"], "methodName": ["testGetRecords"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "List < SchemaTableName >    tables    =    metadata . listTables ( SESSION ,    database )  ;", "ertTrue ( tables . contains ( table )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTableNames"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "metadata . listTables ( SESSION ,    TestCassandraConnector . INVALID _ DATABASE )  ;", "}", "METHOD_END"], "methodName": ["testGetTableNamesException"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "assertNull ( metadata . getTableHandle ( SESSION ,    new   SchemaTableName (  \" totally _ invalid _ database _ name \"  ,     \" dual \"  )  )  )  ;", "assertEquals ( metadata . listTables ( SESSION ,     \" totally _ invalid _ database _ name \"  )  ,    ImmutableList . of (  )  )  ;", "assertEquals ( metadata . listTableColumns ( SESSION ,    new   SchemaTablePrefix (  \" totally _ invalid _ database _ name \"  ,     \" dual \"  )  )  ,    ImmutableMap . of (  )  )  ;", "}", "METHOD_END"], "methodName": ["testListUnknownSchema"], "fileName": "com.facebook.presto.cassandra.TestCassandraConnector"}, {"methodBody": ["METHOD_START", "{", "Type   uuidType    =     ( createdByPresto )     ?    createUnboundedVarcharType (  )     :    createVarcharType (  3  6  )  ;", "Type   inetType    =     ( createdByPresto )     ?    createUnboundedVarcharType (  )     :    createVarcharType (  4  5  )  ;", "String   sql    =     (  \" SELECT    \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"    key ,     \"     +     \"    typeuuid ,     \"  )     +     \"    typeinteger ,     \"  )     +     \"    typelong ,     \"  )     +     \"    typebytes ,     \"  )     +     \"    typetimestamp ,     \"  )     +     \"    typeansi ,     \"  )     +     \"    typeboolean ,     \"  )     +     \"    typedecimal ,     \"  )     +     \"    typedouble ,     \"  )     +     \"    typefloat ,     \"  )     +     \"    typeinet ,     \"  )     +     \"    typevarchar ,     \"  )     +     \"    typevarint ,     \"  )     +     \"    typetimeuuid ,     \"  )     +     \"    typelist ,     \"  )     +     \"    typemap ,     \"  )     +     \"    typeset    \"  )     +     \"    FROM    \"  )  )     +    tableName ;", "MaterializedResult   result    =    execute ( sql )  ;", "int   rowCount    =    result . getRowCount (  )  ;", "assertEquals ( rowCount ,     9  )  ;", "assertEquals ( result . getTypes (  )  ,    ImmutableList . of ( createUnboundedVarcharType (  )  ,    uuidType ,    INTEGER ,    BIGINT ,    VARBINARY ,    TIMESTAMP ,    createUnboundedVarcharType (  )  ,    BOOLEAN ,    DOUBLE ,    DOUBLE ,    REAL ,    inetType ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    uuidType ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  )  )  ;", "List < MaterializedRow >    sortedRows    =    result . getMaterializedRows (  )  . stream (  )  . sorted (  (    o 1  ,    o 2  )     -  >    o 1  . getField (  1  )  . toString (  )  . compareTo ( o 2  . getField (  1  )  . toString (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "for    ( int   rowNumber    =     1  ;    rowNumber    <  =    rowCount ;    rowNumber +  +  )     {", "assertEquals ( sortedRows . get (  ( rowNumber    -     1  )  )  ,    new   MaterializedRow ( DEFAULT _ PRECISION ,     (  \" key    \"     +    rowNumber )  ,    String . format (  \"  0  0  0  0  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  %  0  1  2 d \"  ,    rowNumber )  ,    rowNumber ,     ( rowNumber    +     1  0  0  0 L )  ,    ByteBuffer . wrap ( toByteArray ( rowNumber )  )  ,     . TIMESTAMP _ LOCAL ,     (  \" ansi    \"     +    rowNumber )  ,     (  ( rowNumber    %     2  )     =  =     0  )  ,    Math . pow (  2  ,    rowNumber )  ,    Math . pow (  4  ,    rowNumber )  ,     (  ( float )     ( Math . pow (  8  ,    rowNumber )  )  )  ,     \"  1  2  7  .  0  .  0  .  1  \"  ,     (  \" varchar    \"     +    rowNumber )  ,    BigInteger . TEN . pow ( rowNumber )  . toString (  )  ,    String . format (  \" d 2  1  7  7 dd 0  - eaa 2  -  1  1 de - a 5  7  2  -  0  0  1 b 7  7  9 c 7  6 e % d \"  ,    rowNumber )  ,    String . format (  \"  [  \\  \" list - value -  1  %  1  $ d \\  \"  ,  \\  \" list - value -  2  %  1  $ d \\  \"  ]  \"  ,    rowNumber )  ,    String . format (  \"  {  % d :  % d ,  % d :  % d }  \"  ,    rowNumber ,     ( rowNumber    +     1 L )  ,     ( rowNumber    +     2  )  ,     ( rowNumber    +     3 L )  )  ,     \"  [ false , true ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertSelect"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "return   getQueryRunner (  )  . execute ( TestCassandraIntegrationSmokeTest . SESSION ,    sql )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session    =    EmbeddedCassandra . getSession (  )  ;", "CassandraTestingUtils . createTestTables ( session ,     . KEYSPACE ,     . DATE _ LOCAL )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     9  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two =  ' clust _ two _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two =  ' clust _ two _  2  '    AND   clust _ three =  ' clust _ three _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two =  ' clust _ two _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two =  ' clust _ two _  2  '    AND   clust _ three =  ' clust _ three _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two =  ' clust _ two _  2  '    AND   clust _ three   IN    (  ' clust _ three _  1  '  ,     ' clust _ three _  2  '  ,     ' clust _ three _  3  '  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )    AND   clust _ three   IN    (  ' clust _ three _  1  '  ,     ' clust _ three _  2  '  ,     ' clust _ three _  3  '  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two    >     ' clust _ two _  9  9  8  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two    >     ' clust _ two _  9  9  7  '    AND   clust _ two    <     ' clust _ two _  9  9  9  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )    AND   clust _ three    >     ' clust _ three _  9  9  8  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     0  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )    AND   clust _ three    <     ' clust _ three _  3  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )    AND   clust _ three    >     ' clust _ three _  1  '    AND   clust _ three    <     ' clust _ three _  3  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  ,  ' clust _ two _  3  '  )    AND   clust _ two    <     ' clust _ two _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  9  9  7  '  ,  ' clust _ two _  9  9  8  '  ,  ' clust _ two _  9  9  9  '  )    AND   clust _ two    >     ' clust _ two _  9  9  8  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ LARGE )  )     +     \"    WHERE   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  ,  ' clust _ two _  3  '  )    AND   clust _ two    =     ' clust _ two _  2  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testClusteringKeyOnlyPushdown"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     4  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two =  2  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two =  2    AND   clust _ three    =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  2  0  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two =  2    AND   clust _ three    =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  1  0  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     0  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  1  ,  2  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two    >     1    AND   clust _ two    <     3  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two =  2    AND   clust _ three    >  =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  1  0  '    AND   clust _ three    <  =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  2  0  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  1  ,  2  )    AND   clust _ three    >  =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  1  0  '    AND   clust _ three    <  =    timestamp    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  .  0  2  0  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  1  ,  2  ,  3  )    AND   clust _ two    <     2  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  1  ,  2  ,  3  )    AND   clust _ two    >     2  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS _ INEQUALITY )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  1  ,  2  ,  3  )    AND   clust _ two    =     2  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testClusteringKeyPushdownInequality"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  )    AND   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key =  ' key _  1  '    AND   clust _ one !  =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     0  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  ,  ' key _  3  '  ,  ' key _  4  '  )    AND   clust _ one =  ' clust _ one '    AND   clust _ two >  ' clust _ two _  1  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     3  )  ;", "sql    =     (  (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  )    AND   clust _ one =  ' clust _ one '    AND    \"  )     +     \"  (  ( clust _ two =  ' clust _ two _  1  '  )    OR    ( clust _ two =  ' clust _ two _  2  '  )  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  )    AND   clust _ one =  ' clust _ one '    AND    \"  )     +     \"  (  ( clust _ two =  ' clust _ two _  1  '    AND   clust _ three =  ' clust _ three _  1  '  )    OR    ( clust _ two =  ' clust _ two _  2  '    AND   clust _ three =  ' clust _ three _  2  '  )  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  )    AND   clust _ one =  ' clust _ one '    AND   clust _ three =  ' clust _ three _  1  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( CassandraTestingUtils . TABLE _ CLUSTERING _ KEYS )  )     +     \"    WHERE   key   IN    (  ' key _  1  '  ,  ' key _  2  '  )    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testClusteringPredicates"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session . execute (  \" CREATE   KEYSPACE   keyspace _  5    WITH   REPLICATION    =     {  ' class '  :  ' SimpleStrategy '  ,     ' replication _ factor '  :     1  }  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   SCHEMAS   FROM    )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" keyspace _  5  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" CREATE   TABLE   keyspace _  5  . table _  5     (  \\  \" CoLuMn _  5  \\  \"    bigint   PRIMARY   KEY ,     \\  \" cOlUmN _  5  \\  \"    bigint )  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   TABLES   FROM   keyspace _  5  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" table _  5  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertQueryFailsEventually (  \" SHOW   COLUMNS   FROM   keyspace _  5  . table _  5  \"  ,     \" More   than   one   column   has   been   found   for   the   case   insensitive   column   name :    column _  5     -  >     \\  \\  ( CoLuMn _  5  ,    cOlUmN _  5  \\  \\  )  \"  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertQueryFailsEventually (  \" SELECT    *    FROM   keyspace _  5  . table _  5  \"  ,     \" More   than   one   column   has   been   found   for   the   case   insensitive   column   name :    column _  5     -  >     \\  \\  ( CoLuMn _  5  ,    cOlUmN _  5  \\  \\  )  \"  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" DROP   KEYSPACE   keyspace _  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["testColumnNameAmbiguity"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "execute (  \" DROP   TABLE   IF   EXISTS   table _ all _ types _ copy \"  )  ;", "execute (  (  \" CREATE   TABLE   table _ all _ types _ copy   AS   SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ ALL _ TYPES )  )  )  ;", "assertSelect (  \" table _ all _ types _ copy \"  ,    true )  ;", "execute (  \" DROP   TABLE   table _ all _ types _ copy \"  )  ;", "}", "METHOD_END"], "methodName": ["testCreateTableAs"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     (  \" SELECT   key ,    typeuuid ,    typeinteger ,    typelong ,    typebytes ,    typetimestamp ,    typeansi ,    typeboolean ,    typedecimal ,     \"     +     (  \" typedouble ,    typefloat ,    typeinet ,    typevarchar ,    typevarint ,    typetimeuuid ,    typelist ,    typemap ,    typeset \"     +     \"    FROM    \"  )  )     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     0  )  ;", "execute (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" INSERT   INTO    \"     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  )     +     \"     (  \"  )     +     \" key ,  \"  )     +     \" typeuuid ,  \"  )     +     \" typeinteger ,  \"  )     +     \" typelong ,  \"  )     +     \" typebytes ,  \"  )     +     \" typetimestamp ,  \"  )     +     \" typeansi ,  \"  )     +     \" typeboolean ,  \"  )     +     \" typedecimal ,  \"  )     +     \" typedouble ,  \"  )     +     \" typefloat ,  \"  )     +     \" typeinet ,  \"  )     +     \" typevarchar ,  \"  )     +     \" typevarint ,  \"  )     +     \" typetimeuuid ,  \"  )     +     \" typelist ,  \"  )     +     \" typemap ,  \"  )     +     \" typeset \"  )     +     \"  )    VALUES    (  \"  )     +     \"  ' key 1  '  ,     \"  )     +     \" null ,     \"  )     +     \"  1  ,     \"  )     +     \"  1  0  0  0  ,     \"  )     +     \" null ,     \"  )     +     \" timestamp    '  1  9  7  0  -  0  1  -  0  1     0  8  :  3  4  :  0  5  .  0  '  ,     \"  )     +     \"  ' ansi 1  '  ,     \"  )     +     \" true ,     \"  )     +     \" null ,     \"  )     +     \"  0  .  3  ,     \"  )     +     \" cast (  '  0  .  4  '    as   real )  ,     \"  )     +     \" null ,     \"  )     +     \"  ' varchar 1  '  ,     \"  )     +     \" null ,     \"  )     +     \" null ,     \"  )     +     \" null ,     \"  )     +     \" null ,     \"  )     +     \" null    \"  )     +     \"  )  \"  )  )  ;", "MaterializedResult   result    =    execute ( sql )  ;", "int   rowCount    =    result . getRowCount (  )  ;", "assertEquals ( rowCount ,     1  )  ;", "assertEquals ( result . getMaterializedRows (  )  . get (  0  )  ,    new   testing . MaterializedRow ( DEFAULT _ PRECISION ,     \" key 1  \"  ,    null ,     1  ,     1  0  0  0 L ,    null ,    LocalDateTime . of (  1  9  7  0  ,     1  ,     1  ,     8  ,     3  4  ,     5  )  ,     \" ansi 1  \"  ,    true ,    null ,     0  .  3  ,     (  ( float )     (  0  .  4  )  )  ,    null ,     \" varchar 1  \"  ,    null ,    null ,    null ,    null ,    null )  )  ;", "execute (  (  (  (  (  (  (  (  \" INSERT   INTO    \"     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  )     +     \"     (  \"  )     +     \" key ,    typeuuid ,    typeinteger ,    typelong ,    typebytes ,    typetimestamp ,    typeansi ,    typeboolean ,    typedecimal ,  \"  )     +     \" typedouble ,    typefloat ,    typeinet ,    typevarchar ,    typevarint ,    typetimeuuid ,    typelist ,    typemap ,    typeset \"  )     +     \"  )    VALUES    (  \"  )     +     \"  ' key 2  '  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,  \"  )     +     \" null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  \"  )  )  ;", "sql    =     (  (  \" SELECT   key ,    typeuuid ,    typeinteger ,    typelong ,    typebytes ,    typetimestamp ,    typeansi ,    typeboolean ,    typedecimal ,     \"     +     (  \" typedouble ,    typefloat ,    typeinet ,    typevarchar ,    typevarint ,    typetimeuuid ,    typelist ,    typemap ,    typeset \"     +     \"    FROM    \"  )  )     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  )     +     \"    WHERE   key    =     ' key 2  '  \"  ;", "result    =    execute ( sql )  ;", "rowCount    =    result . getRowCount (  )  ;", "assertEquals ( rowCount ,     1  )  ;", "assertEquals ( result . getMaterializedRows (  )  . get (  0  )  ,    new   testing . MaterializedRow ( DEFAULT _ PRECISION ,     \" key 2  \"  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  )  ;", "execute (  (  (  (  (  \" INSERT   INTO    \"     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  )     +     \"     (  \"  )     +     \" key ,    typeinteger ,    typeansi ,    typeboolean )    VALUES    (  \"  )     +     \"  ' key 3  '  ,     9  9  9  ,     ' ansi '  ,    false )  \"  )  )  ;", "sql    =     (  (  \" SELECT   key ,    typeuuid ,    typeinteger ,    typelong ,    typebytes ,    typetimestamp ,    typeansi ,    typeboolean ,    typedecimal ,     \"     +     (  \" typedouble ,    typefloat ,    typeinet ,    typevarchar ,    typevarint ,    typetimeuuid ,    typelist ,    typemap ,    typeset \"     +     \"    FROM    \"  )  )     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ INSERT )  )     +     \"    WHERE   key    =     ' key 3  '  \"  ;", "result    =    execute ( sql )  ;", "rowCount    =    result . getRowCount (  )  ;", "assertEquals ( rowCount ,     1  )  ;", "assertEquals ( result . getMaterializedRows (  )  . get (  0  )  ,    new   testing . MaterializedRow ( DEFAULT _ PRECISION ,     \" key 3  \"  ,    null ,     9  9  9  ,    null ,    null ,    null ,     \" ansi \"  ,    false ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["testInsert"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session . execute (  \" CREATE   KEYSPACE    \\  \" KeYsPaCe _  3  \\  \"    WITH   REPLICATION    =     {  \\  ' class \\  '  :  \\  ' SimpleStrategy \\  '  ,     \\  ' replication _ factor \\  '  :     1  }  \"  )  ;", "session . execute (  \" CREATE   KEYSPACE    \\  \" kEySpAcE _  3  \\  \"    WITH   REPLICATION    =     {  \\  ' class \\  '  :  \\  ' SimpleStrategy \\  '  ,     \\  ' replication _ factor \\  '  :     1  }  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   SCHEMAS   FROM    )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" keyspace _  3  \"  )  . row (  \" keyspace _  3  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertQueryFailsEventually (  \" SHOW   TABLES   FROM   keyspace _  3  \"  ,     \" More   than   one   keyspace   has   been   found   for   the   case   insensitive   schema   name :    keyspace _  3     -  >     \\  \\  ( KeYsPaCe _  3  ,    kEySpAcE _  3  \\  \\  )  \"  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" DROP   KEYSPACE    \\  \" KeYsPaCe _  3  \\  \"  \"  )  ;", "session . execute (  \" DROP   KEYSPACE    \\  \" kEySpAcE _  3  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testKeyspaceNameAmbiguity"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   partitionInPredicates    =     \"    partition _ one   IN    (  ' partition _ one _  1  '  ,  ' partition _ one _  2  '  )    AND   partition _ two   IN    (  ' partition _ two _  1  '  ,  ' partition _ two _  2  '  )     \"  ;", "String   sql    =     (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE   partition _ one =  ' partition _ one _  1  '    AND   partition _ two =  ' partition _ two _  1  '    AND   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +    partitionInPredicates )     +     \"    AND   clust _ one =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE   partition _ one =  ' partition _ one _  1  '    AND   partition _ two =  ' partition _ two _  1  '    AND   clust _ one !  =  ' clust _ one '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     0  )  ;", "sql    =     (  (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +     \" partition _ one   IN    (  ' partition _ one _  1  '  ,  ' partition _ one _  2  '  ,  ' partition _ one _  3  '  ,  ' partition _ one _  4  '  )    AND    \"  )     +     \" partition _ two   IN    (  ' partition _ two _  1  '  ,  ' partition _ two _  2  '  ,  ' partition _ two _  3  '  ,  ' partition _ two _  4  '  )    AND    \"  )     +     \" clust _ one =  ' clust _ one '    AND   clust _ two >  ' clust _ two _  1  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     3  )  ;", "sql    =     (  (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +    partitionInPredicates )     +     \"    AND   clust _ one =  ' clust _ one '    AND    \"  )     +     \"  (  ( clust _ two =  ' clust _ two _  1  '  )    OR    ( clust _ two =  ' clust _ two _  2  '  )  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +    partitionInPredicates )     +     \"    AND   clust _ one =  ' clust _ one '    AND    \"  )     +     \"  (  ( clust _ two =  ' clust _ two _  1  '    AND   clust _ three =  ' clust _ three _  1  '  )    OR    ( clust _ two =  ' clust _ two _  2  '    AND   clust _ three =  ' clust _ three _  2  '  )  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "sql    =     (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +    partitionInPredicates )     +     \"    AND   clust _ one =  ' clust _ one '    AND   clust _ three =  ' clust _ three _  1  '  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     1  )  ;", "sql    =     (  (  (  \" SELECT    *    FROM    \"     +     ( TestingUtils . TABLE _ MULTI _ PARTITION _ CLUSTERING _ KEYS )  )     +     \"    WHERE    \"  )     +    partitionInPredicates )     +     \"    AND   clust _ one =  ' clust _ one '    AND   clust _ two   IN    (  ' clust _ two _  1  '  ,  ' clust _ two _  2  '  )  \"  ;", "assertEquals ( execute ( sql )  . getRowCount (  )  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testMultiplePartitionClusteringPredicates"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "String   sql    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" SELECT    *  \"     +     \"    FROM    \"  )     +     ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ PARTITION _ KEY )  )     +     \"    WHERE   key    =     ' key    7  '  \"  )     +     \"    AND   typeuuid    =     '  0  0  0  0  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  -  0  0  0  0  0  0  0  0  0  0  0  7  '  \"  )     +     \"    AND   typeinteger    =     7  \"  )     +     \"    AND   typelong    =     1  0  0  7  \"  )     +     \"    AND   typebytes    =    from _ hex (  '  \"  )     +     ( toRawHexString ( ByteBuffer . wrap ( toByteArray (  7  )  )  )  )  )     +     \"  '  )  \"  )     +     \"    AND   typetimestamp    =    TIMESTAMP    '  1  9  7  0  -  0  1  -  0  1     0  3  :  0  4  :  0  5  '  \"  )     +     \"    AND   typeansi    =     ' ansi    7  '  \"  )     +     \"    AND   typeboolean    =    false \"  )     +     \"    AND   typedecimal    =     1  2  8  .  0  \"  )     +     \"    AND   typedouble    =     1  6  3  8  4  .  0  \"  )     +     \"    AND   typefloat    =    REAL    '  2  0  9  7  1  5  2  .  0  '  \"  )     +     \"    AND   typeinet    =     '  1  2  7  .  0  .  0  .  1  '  \"  )     +     \"    AND   typevarchar    =     ' varchar    7  '  \"  )     +     \"    AND   typevarint    =     '  1  0  0  0  0  0  0  0  '  \"  )     +     \"    AND   typetimeuuid    =     ' d 2  1  7  7 dd 0  - eaa 2  -  1  1 de - a 5  7  2  -  0  0  1 b 7  7  9 c 7  6 e 7  '  \"  )     +     \"    AND   typelist    =     \\  '  [  \\  \" list - value -  1  7  \\  \"  ,  \\  \" list - value -  2  7  \\  \"  ]  \\  '  \"  )     +     \"    AND   typemap    =     '  {  7  :  8  ,  9  :  1  0  }  '  \"  )     +     \"    AND   typeset    =     '  [ false , true ]  '  \"  )     +     \"  \"  ;", "MaterializedResult   result    =    execute ( sql )  ;", "assertEquals ( result . getRowCount (  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testPartitionKeyPredicate"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "assertSelect ( CassandraTestingUtils . TABLE _ ALL _ TYPES ,    false )  ;", "assertSelect ( CassandraTestingUtils . TABLE _ ALL _ TYPES _ PARTITION _ KEY ,    false )  ;", "}", "METHOD_END"], "methodName": ["testSelect"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session . execute (  \" CREATE   KEYSPACE   keyspace _  4    WITH   REPLICATION    =     {  ' class '  :  ' SimpleStrategy '  ,     ' replication _ factor '  :     1  }  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   SCHEMAS   FROM    )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" keyspace _  4  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" CREATE   TABLE   keyspace _  4  .  \\  \" TaBlE _  4  \\  \"     ( column _  4    bigint   PRIMARY   KEY )  \"  )  ;", "session . execute (  \" CREATE   TABLE   keyspace _  4  .  \\  \" tAbLe _  4  \\  \"     ( column _  4    bigint   PRIMARY   KEY )  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   TABLES   FROM   keyspace _  4  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" table _  4  \"  )  . row (  \" table _  4  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertQueryFailsEventually (  \" SHOW   COLUMNS   FROM   keyspace _  4  . table _  4  \"  ,     \" More   than   one   table   has   been   found   for   the   case   insensitive   table   name :    table _  4     -  >     \\  \\  ( TaBlE _  4  ,    tAbLe _  4  \\  \\  )  \"  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertQueryFailsEventually (  \" SELECT    *    FROM   keyspace _  4  . table _  4  \"  ,     \" More   than   one   table   has   been   found   for   the   case   insensitive   table   name :    table _  4     -  >     \\  \\  ( TaBlE _  4  ,    tAbLe _  4  \\  \\  )  \"  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" DROP   KEYSPACE   keyspace _  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTableNameAmbiguity"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session . execute (  \" CREATE   KEYSPACE   KEYSPACE _  1    WITH   REPLICATION    =     {  ' class '  :  ' SimpleStrategy '  ,     ' replication _ factor '  :     1  }  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   SCHEMAS   FROM    )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" keyspace _  1  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" CREATE   TABLE   KEYSPACE _  1  . TABLE _  1     ( COLUMN _  1    bigint   PRIMARY   KEY )  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   TABLES   FROM   keyspace _  1  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" table _  1  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertContains ( execute (  \" SHOW   COLUMNS   FROM   keyspace _  1  . table _  1  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" column _  1  \"  ,     \" bigint \"  ,     \"  \"  ,     \"  \"  )  . build (  )  )  ;", "execute (  \" INSERT   INTO   keyspace _  1  . table _  1     ( column _  1  )    VALUES    (  1  )  \"  )  ;", "assertEquals ( execute (  \" SELECT   column _  1    FROM   keyspace _  1  . table _  1  \"  )  . getRowCount (  )  ,     1  )  ;", "assertUpdate (  \" DROP   TABLE   keyspace _  1  . table _  1  \"  )  ;", "session . execute (  \" DROP   KEYSPACE   keyspace _  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUpperCaseNameUnescapedInCassandra"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "session . execute (  \" CREATE   KEYSPACE    \\  \" KEYSPACE _  2  \\  \"    WITH   REPLICATION    =     {  \\  ' class \\  '  :  \\  ' SimpleStrategy \\  '  ,     \\  ' replication _ factor \\  '  :     1  }  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   SCHEMAS   FROM    )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" keyspace _  2  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "session . execute (  \" CREATE   TABLE    \\  \" KEYSPACE _  2  \\  \"  .  \\  \" TABLE _  2  \\  \"     (  \\  \" COLUMN _  2  \\  \"    bigint   PRIMARY   KEY )  \"  )  ;", "assertContainsEventually (  (  )     -  >    execute (  \" SHOW   TABLES   FROM   keyspace _  2  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" table _  2  \"  )  . build (  )  ,    new   Duration (  1  ,    TimeUnit . MINUTES )  )  ;", "assertContains ( execute (  \" SHOW   COLUMNS   FROM   keyspace _  2  . table _  2  \"  )  ,    resultBuilder ( getSession (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  ,    createUnboundedVarcharType (  )  )  . row (  \" column _  2  \"  ,     \" bigint \"  ,     \"  \"  ,     \"  \"  )  . build (  )  )  ;", "execute (  \" INSERT   INTO    \\  \" KEYSPACE _  2  \\  \"  .  \\  \" TABLE _  2  \\  \"     (  \\  \" COLUMN _  2  \\  \"  )    VALUES    (  1  )  \"  )  ;", "assertEquals ( execute (  \" SELECT   column _  2    FROM   keyspace _  2  . table _  2  \"  )  . getRowCount (  )  ,     1  )  ;", "assertUpdate (  \" DROP   TABLE   keyspace _  2  . table _  2  \"  )  ;", "session . execute (  \" DROP   KEYSPACE    \\  \" KEYSPACE _  2  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testUppercaseNameEscaped"], "fileName": "com.facebook.presto.cassandra.TestCassandraIntegrationSmokeTest"}, {"methodBody": ["METHOD_START", "{", "CassandraSplit   expected    =    new   CassandraSplit (  \" connectorId \"  ,     \" schema 1  \"  ,     \" table 1  \"  ,     \" partitionId \"  ,     \" condition \"  ,    addresses )  ;", "String   json    =    codec . toJson ( expected )  ;", "CassandraSplit   actual    =    codec . fromJson ( json )  ;", "assertEquals ( actual . getConnectorId (  )  ,    expected . getConnectorId (  )  )  ;", "assertEquals ( actual . getSchema (  )  ,    expected . getSchema (  )  )  ;", "assertEquals ( actual . getTable (  )  ,    expected . getTable (  )  )  ;", "assertEquals ( actual . getSplitCondition (  )  ,    expected . getSplitCondition (  )  )  ;", "assertEquals ( actual . getAddresses (  )  ,    expected . getAddresses (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsonRoundTrip"], "fileName": "com.facebook.presto.cassandra.TestCassandraSplit"}, {"methodBody": ["METHOD_START", "{", "CassandraSplit   split ;", "split    =    new   CassandraSplit (  \" connectorId \"  ,     \" schema 1  \"  ,     \" table 1  \"  ,    CassandraPartition . UNPARTITIONED _ ID ,     \" token ( k )     >  =     0    AND   token ( k )     <  =     2  \"  ,    addresses )  ;", "assertEquals ( split . getWhereClause (  )  ,     \"    WHERE   token ( k )     >  =     0    AND   token ( k )     <  =     2  \"  )  ;", "split    =    new   CassandraSplit (  \" connectorId \"  ,     \" schema 1  \"  ,     \" table 1  \"  ,     \" key    =     1  2  3  \"  ,    null ,    addresses )  ;", "assertEquals ( split . getWhereClause (  )  ,     \"    WHERE   key    =     1  2  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhereClause"], "fileName": "com.facebook.presto.cassandra.TestCassandraSplit"}, {"methodBody": ["METHOD_START", "{", "CassandraTableHandle   expected    =    new   CassandraTableHandle (  \" client \"  ,     \" schema \"  ,     \" table \"  )  ;", "String   json    =    codec . toJson ( expected )  ;", "CassandraTableHandle   actual    =    codec . fromJson ( json )  ;", "assertEquals ( actual . getConnectorId (  )  ,    expected . getConnectorId (  )  )  ;", "assertEquals ( actual . getSchemaTableName (  )  ,    expected . getSchemaTableName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRoundTrip"], "fileName": "com.facebook.presto.cassandra.TestCassandraTableHandle"}, {"methodBody": ["METHOD_START", "{", "EmbeddedCassandra . start (  )  ;", "session    =    EmbeddedCassandra . getSession (  )  ;", "CassandraTestingUtils . createKeyspace ( session ,     . KEYSPACE )  ;", "splitManager    =    new   CassandraTokenSplitManager ( session ,     . SPLIT _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.facebook.presto.cassandra.TestCassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "String   tableName    =     \" empty _ table \"  ;", "session . execute ( String . format (  \" CREATE   TABLE    % s .  % s    ( key   text   PRIMARY   KEY )  \"  ,     . KEYSPACE ,    tableName )  )  ;", "EmbeddedCassandra . refreshSizeEstimates (  . KEYSPACE ,    tableName )  ;", "List < CassandraTokenSplitManager . TokenSplit >    splits    =    splitManager . getSplits (  . KEYSPACE ,    tableName )  ;", "assertEquals ( splits . size (  )  ,     1  )  ;", "session . execute ( String . format (  \" DROP   TABLE    % s .  % s \"  ,     . KEYSPACE ,    tableName )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyTable"], "fileName": "com.facebook.presto.cassandra.TestCassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "String   tableName    =     \" non _ empty _ table \"  ;", "session . execute ( String . format (  \" CREATE   TABLE    % s .  % s    ( key   text   PRIMARY   KEY )  \"  ,     . KEYSPACE ,    tableName )  )  ;", "for    ( int   i    =     0  ;    i    <     (  . PARTITION _ COUNT )  ;    i +  +  )     {", "session . execute ( String . format (  \" INSERT   INTO    % s .  % s    ( key )    VALUES    (  '  % s '  )  \"  ,     . KEYSPACE ,    tableName ,     (  \" value \"     +    i )  )  )  ;", "}", "EmbeddedCassandra . refreshSizeEstimates (  . KEYSPACE ,    tableName )  ;", "List < CassandraTokenSplitManager . TokenSplit >    splits    =    splitManager . getSplits (  . KEYSPACE ,    tableName )  ;", "assertEquals ( splits . size (  )  ,     (  (  . PARTITION _ COUNT )     /     (  . SPLIT _ SIZE )  )  )  ;", "session . execute ( String . format (  \" DROP   TABLE    % s .  % s \"  ,     . KEYSPACE ,    tableName )  )  ;", "}", "METHOD_END"], "methodName": ["testNonEmptyTable"], "fileName": "com.facebook.presto.cassandra.TestCassandraTokenSplitManager"}, {"methodBody": ["METHOD_START", "{", "if    ( token    !  =    null )     {", ". continueWhileNotNull ( parser ,    parser . nextToken (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["continueWhileNotNull"], "fileName": "com.facebook.presto.cassandra.TestCassandraType"}, {"methodBody": ["METHOD_START", "{", "boolean   valid    =    false ;", "try    {", "JsonParser   parser    =    new   ObjectMapper (  )  . getFactory (  )  . createParser ( json )  ;", ". continueWhileNotNull ( parser ,    parser . nextToken (  )  )  ;", "valid    =    true ;", "}    catch    ( IOException   ignored )     {", "}", "return   valid ;", "}", "METHOD_END"], "methodName": ["isValidJson"], "fileName": "com.facebook.presto.cassandra.TestCassandraType"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( TestCassandraType . isValidJson ( CassandraType . buildArrayValue ( Lists . newArrayList (  \" one \"  ,     \" two \"  ,     \" three \\  \"  \"  )  ,    CassandraType . VARCHAR )  )  )  ;", "assertTrue ( TestCassandraType . isValidJson ( CassandraType . buildArrayValue ( Lists . newArrayList (  1  ,     2  ,     3  )  ,    CassandraType . INT )  )  )  ;", "assertTrue ( TestCassandraType . isValidJson ( CassandraType . buildArrayValue ( Lists . newArrayList (  1  0  0  0  0  0 L ,     2  0  0  0  0  0  0  0  0 L ,     3  0  0  0  0  0  0  0  0  0 L )  ,    CassandraType . BIGINT )  )  )  ;", "assertTrue ( TestCassandraType . isValidJson ( CassandraType . buildArrayValue ( Lists . newArrayList (  1  .  0  ,     2  .  0  ,     3  .  0  )  ,    CassandraType . DOUBLE )  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsonMapEncoding"], "fileName": "com.facebook.presto.cassandra.TestCassandraType"}, {"methodBody": ["METHOD_START", "{", "String   json    =    objectMapper . writeValueAsString ( TestJsonCassandraHandles . COLUMN 2  _ HANDLE _ AS _ MAP )  ;", "CassandraColumnHandle   columnHandle    =    objectMapper . readValue ( json ,    CassandraColumnHandle . class )  ;", "assertEquals ( columnHandle . getName (  )  ,     \" column 2  \"  )  ;", "assertEquals ( columnHandle . getOrdinalPosition (  )  ,     0  )  ;", "assertEquals ( columnHandle . getCassandraType (  )  ,    CassandraType . SET )  ;", "assertEquals ( columnHandle . getTypeArguments (  )  ,    ImmutableList . of ( CassandraType . INT )  )  ;", "assertEquals ( columnHandle . isPartitionKey (  )  ,    false )  ;", "assertEquals ( columnHandle . isClusteringKey (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testColumn2HandleDeserialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "CassandraColumnHandle   columnHandle    =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" column 2  \"  ,     0  ,    CassandraType . SET ,    ImmutableList . of ( CassandraType . INT )  ,    false ,    false ,    false ,    false )  ;", "assertTrue ( objectMapper . canSerialize ( CassandraColumnHandle . class )  )  ;", "String   json    =    objectMapper . writeValueAsString ( columnHandle )  ;", "testJsonEquals ( json ,     . COLUMN 2  _ HANDLE _ AS _ MAP )  ;", "}", "METHOD_END"], "methodName": ["testColumn2HandleSerialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "String   json    =    objectMapper . writeValueAsString ( TestJsonCassandraHandles . COLUMN _ HANDLE _ AS _ MAP )  ;", "CassandraColumnHandle   columnHandle    =    objectMapper . readValue ( json ,    CassandraColumnHandle . class )  ;", "assertEquals ( columnHandle . getName (  )  ,     \" column \"  )  ;", "assertEquals ( columnHandle . getOrdinalPosition (  )  ,     4  2  )  ;", "assertEquals ( columnHandle . getCassandraType (  )  ,    CassandraType . BIGINT )  ;", "assertEquals ( columnHandle . getTypeArguments (  )  ,    null )  ;", "assertEquals ( columnHandle . isPartitionKey (  )  ,    false )  ;", "assertEquals ( columnHandle . isClusteringKey (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testColumnHandleDeserialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "CassandraColumnHandle   columnHandle    =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" column \"  ,     4  2  ,    CassandraType . BIGINT ,    null ,    false ,    true ,    false ,    false )  ;", "assertTrue ( objectMapper . canSerialize ( CassandraColumnHandle . class )  )  ;", "String   json    =    objectMapper . writeValueAsString ( columnHandle )  ;", "testJsonEquals ( json ,     . COLUMN _ HANDLE _ AS _ MAP )  ;", "}", "METHOD_END"], "methodName": ["testColumnHandleSerialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    jsonMap    =    objectMapper . readValue ( json ,    new   TypeReference < Map < String ,    Object >  >  (  )     {  }  )  ;", "Assertions . assertEqualsIgnoreOrder ( jsonMap . entrySet (  )  ,    expectedMap . entrySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["testJsonEquals"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "String   json    =    objectMapper . writeValueAsString ( TestJsonCassandraHandles . TABLE _ HANDLE _ AS _ MAP )  ;", "CassandraTableHandle   tableHandle    =    objectMapper . readValue ( json ,    CassandraTableHandle . class )  ;", "assertEquals ( tableHandle . getConnectorId (  )  ,     \" cassandra \"  )  ;", "assertEquals ( tableHandle . getSchemaName (  )  ,     \" cassandra _ schema \"  )  ;", "assertEquals ( tableHandle . getTableName (  )  ,     \" cassandra _ table \"  )  ;", "assertEquals ( tableHandle . getSchemaTableName (  )  ,    new   SchemaTableName (  \" cassandra _ schema \"  ,     \" cassandra _ table \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testTableHandleDeserialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "CassandraTableHandle   tableHandle    =    new   CassandraTableHandle (  \" cassandra \"  ,     \" cassandra _ schema \"  ,     \" cassandra _ table \"  )  ;", "assertTrue ( objectMapper . canSerialize ( CassandraTableHandle . class )  )  ;", "String   json    =    objectMapper . writeValueAsString ( tableHandle )  ;", "testJsonEquals ( json ,     . TABLE _ HANDLE _ AS _ MAP )  ;", "}", "METHOD_END"], "methodName": ["testTableHandleSerialize"], "fileName": "com.facebook.presto.cassandra.TestJsonCassandraHandles"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getRingFraction (  \"  1  \"  ,     \"  1  \"  )  ,     0  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getRingFraction (  \"  1  \"  ,     \"  0  \"  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getRingFraction (  \"  0  \"  ,    Long . toString ( Long . MAX _ VALUE )  )  ,     0  .  5  ,     0  .  0  0  1  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getRingFraction ( Long . toString ( Long . MIN _ VALUE )  ,    Long . toString ( Long . MAX _ VALUE )  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getRingFraction ( Long . toString ( Long . MIN _ VALUE )  ,    Long . toString ( Long . MIN _ VALUE )  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetRingFraction"], "fileName": "com.facebook.presto.cassandra.TestMurmur3PartitionerTokenRing"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  1  \"  )  ,    BigInteger . ONE )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  -  1  \"  ,     \"  1  \"  )  ,    new   BigInteger (  \"  2  \"  )  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  -  1  0  0  \"  ,     \"  1  0  0  \"  )  ,    new   BigInteger (  \"  2  0  0  \"  )  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  1  0  \"  )  ,    new   BigInteger (  \"  1  0  \"  )  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  1  \"  ,     \"  1  1  \"  )  ,    new   BigInteger (  \"  1  0  \"  )  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  0  \"  )  ,    BigInteger . ZERO )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  1  \"  ,     \"  1  \"  )  ,    BigInteger . ZERO )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange ( Long . toString ( Long . MIN _ VALUE )  ,    Long . toString ( Long . MIN _ VALUE )  )  ,    BigInteger . valueOf (  2  )  . pow (  6  4  )  . subtract ( BigInteger . ONE )  )  ;", "assertEquals ( TestMurmur 3 PartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  1  \"  ,     \"  0  \"  )  ,    BigInteger . valueOf (  2  )  . pow (  6  4  )  . subtract ( BigInteger . valueOf (  2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetTokenCountInRange"], "fileName": "com.facebook.presto.cassandra.TestMurmur3PartitionerTokenRing"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  1  \"  )  ,    BigInteger . ONE )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  2  0  0  \"  )  ,    new   BigInteger (  \"  2  0  0  \"  )  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  1  0  \"  )  ,    new   BigInteger (  \"  1  0  \"  )  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  1  \"  ,     \"  1  1  \"  )  ,    new   BigInteger (  \"  1  0  \"  )  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  0  \"  ,     \"  0  \"  )  ,    BigInteger . ZERO )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  -  1  \"  ,     \"  -  1  \"  )  ,    BigInteger . valueOf (  2  )  . pow (  1  2  7  )  . add ( BigInteger . ONE )  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getTokenCountInRange (  \"  1  \"  ,     \"  0  \"  )  ,    BigInteger . valueOf (  2  )  . pow (  1  2  7  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetRingFraction"], "fileName": "com.facebook.presto.cassandra.TestRandomPartitionerTokenRing"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  0  \"  ,     \"  0  \"  )  ,     0  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  1  \"  ,     \"  0  \"  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  -  1  \"  ,     \"  -  1  \"  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  0  \"  ,    BigInteger . valueOf (  2  )  . pow (  1  2  6  )  . toString (  )  )  ,     0  .  5  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction ( BigInteger . valueOf (  2  )  . pow (  1  2  6  )  . toString (  )  ,    BigInteger . valueOf (  2  )  . pow (  1  2  7  )  . toString (  )  )  ,     0  .  5  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  0  \"  ,    BigInteger . valueOf (  2  )  . pow (  1  2  6  )  . toString (  )  )  ,     0  .  5  ,     0  .  0  0  1  )  ;", "assertEquals ( TestRandomPartitionerTokenRing . tokenRing . getRingFraction (  \"  0  \"  ,    BigInteger . valueOf (  2  )  . pow (  1  2  7  )  . toString (  )  )  ,     1  .  0  ,     0  .  0  0  1  )  ;", "}", "METHOD_END"], "methodName": ["testGetTokenCountInRange"], "fileName": "com.facebook.presto.cassandra.TestRandomPartitionerTokenRing"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( partitioner ,     \" partitioner   is   null \"  )  ;", "switch    ( partitioner )     {", "case    \" Murmur 3 Partitioner \"     :", "return   Optional . of ( Murmur 3 PartitionerTokenRing . INSTANCE )  ;", "case    \" RandomPartitioner \"     :", "return   Optional . of ( RandomPartitionerTokenRing . INSTANCE )  ;", "default    :", "return   Optional . empty (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createForPartitioner"], "fileName": "com.facebook.presto.cassandra.TokenRing"}, {"methodBody": ["METHOD_START", "{", "CassandraCqlUtils . appendSelectColumns ( stringBuilder ,    columns ,    true )  ;", "}", "METHOD_END"], "methodName": ["appendSelectColumns"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( ColumnHandle   column    :    columns )     {", "if    ( first )     {", "first    =    false ;", "} else    {", "stringBuilder . append (  \"  ,  \"  )  ;", "}", "stringBuilder . append (  . validColumnName (  (  ( CassandraColumnHandle )     ( column )  )  . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["appendSelectColumns"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( name . isEmpty (  )  )     {", "return    . EMPTY _ COLUMN _ NAME ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["cqlNameToSqlName"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "switch    ( cassandraType )     {", "case   ASCII    :", "case   TEXT    :", "case   VARCHAR    :", "return    . quoteStringLiteral ( value )  ;", "case   INET    :", "return    . quoteStringLiteral ( value . substring (  1  )  )  ;", "default    :", "return   value ;", "}", "}", "METHOD_END"], "methodName": ["cqlValue"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "String   schema    =    CassandraCqlUtils . validSchemaName ( tableHandle . getSchemaName (  )  )  ;", "String   table    =    CassandraCqlUtils . validTableName ( tableHandle . getTableName (  )  )  ;", "return   selection . from ( schema ,    table )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  '  \"  '     +    identifier )     +     '  \"  '  ;", "}", "METHOD_END"], "methodName": ["quoteIdentifier"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  '  \"     +     ( string . replace (  \"  '  \"  ,     \"  '  '  \"  )  )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["quoteStringLiteral"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  '  \"  '     +     ( new   String ( JsonStringEncoder . getInstance (  )  . quoteAsUTF 8  ( string )  )  )  )     +     '  \"  '  ;", "}", "METHOD_END"], "methodName": ["quoteStringLiteralForJson"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "Selection   selection    =    QueryBuilder . select (  )  ;", "for    ( CassandraColumnHandle   column    :    columns )     {", "selection . column (  . validColumnName ( column . getName (  )  )  )  ;", "}", "return   selection ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "String   schema    =    CassandraCqlUtils . validSchemaName ( tableHandle . getSchemaName (  )  )  ;", "String   table    =    CassandraCqlUtils . validTableName ( tableHandle . getTableName (  )  )  ;", "return   QueryBuilder . select (  )  . countAll (  )  . from ( schema ,    table )  ;", "}", "METHOD_END"], "methodName": ["selectCountAllFrom"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return   CassandraCqlUtils . from ( CassandraCqlUtils . select ( columns )  . distinct (  )  ,    tableHandle )  ;", "}", "METHOD_END"], "methodName": ["selectDistinctFrom"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return   CassandraCqlUtils . from ( CassandraCqlUtils . select ( columns )  ,    tableHandle )  ;", "}", "METHOD_END"], "methodName": ["selectFrom"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals ( CassandraCqlUtils . EMPTY _ COLUMN _ NAME )  )     {", "return    \"  \"  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["sqlNameToCqlName"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Slice )     {", "return    (  ( Slice )     ( value )  )  . toStringUtf 8  (  )  ;", "}", "return   value . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toCQLCompatibleString"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( identifier . isEmpty (  )  )     |  |     ( identifier . equals ( CassandraCqlUtils . EMPTY _ COLUMN _ NAME )  )  )     {", "return    \"  \\  \"  \\  \"  \"  ;", "}", "return   CassandraCqlUtils . validIdentifier ( identifier )  ;", "}", "METHOD_END"], "methodName": ["validColumnName"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( identifier . equals ( identifier . toLowerCase ( Locale . ENGLISH )  )  )  )     {", "return    . quoteIdentifier ( identifier )  ;", "}", "if    (  . keywords . contains ( identifier . toUpperCase ( Locale . ENGLISH )  )  )     {", "return    . quoteIdentifier ( identifier )  ;", "}", "return   identifier ;", "}", "METHOD_END"], "methodName": ["validIdentifier"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return   CassandraCqlUtils . validIdentifier ( identifier )  ;", "}", "METHOD_END"], "methodName": ["validSchemaName"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "return   CassandraCqlUtils . validIdentifier ( identifier )  ;", "}", "METHOD_END"], "methodName": ["validTableName"], "fileName": "com.facebook.presto.cassandra.util.CassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "ArrayList < HostAddress >    list    =    new   ArrayList <  >  ( hosts . size (  )  )  ;", "for    ( String   host    :    hosts )     {", "list . add ( toHostAddress ( host )  )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["AddressNamesToHostAddressList"], "fileName": "com.facebook.presto.cassandra.util.HostAddressFactory"}, {"methodBody": ["METHOD_START", "{", "return   toHostAddress ( host . getAddress (  )  . getHostAddress (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHostAddress"], "fileName": "com.facebook.presto.cassandra.util.HostAddressFactory"}, {"methodBody": ["METHOD_START", "{", "HostAddress   address    =    hostMap . get ( hostAddressName )  ;", "if    ( address    =  =    null )     {", "address    =    HostAddress . fromString ( hostAddressName )  ;", "hostMap . put ( hostAddressName ,    address )  ;", "}", "return   address ;", "}", "METHOD_END"], "methodName": ["toHostAddress"], "fileName": "com.facebook.presto.cassandra.util.HostAddressFactory"}, {"methodBody": ["METHOD_START", "{", "ArrayList < HostAddress >    list    =    new   ArrayList ( hosts . size (  )  )  ;", "for    ( Host   host    :    hosts )     {", "list . add ( toHostAddress ( host )  )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["toHostAddressList"], "fileName": "com.facebook.presto.cassandra.util.HostAddressFactory"}, {"methodBody": ["METHOD_START", "{", "TestCassandraClusteringPredicatesExtractor . col 1     =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" partitionKey 1  \"  ,     1  ,    CassandraType . BIGINT ,    null ,    true ,    false ,    false ,    false )  ;", "TestCassandraClusteringPredicatesExtractor . col 2     =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" clusteringKey 1  \"  ,     2  ,    CassandraType . BIGINT ,    null ,    false ,    true ,    false ,    false )  ;", "TestCassandraClusteringPredicatesExtractor . col 3     =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" clusteringKey 2  \"  ,     3  ,    CassandraType . BIGINT ,    null ,    false ,    true ,    false ,    false )  ;", "TestCassandraClusteringPredicatesExtractor . col 4     =    new   CassandraColumnHandle (  \" cassandra \"  ,     \" clusteringKe 3  \"  ,     4  ,    CassandraType . BIGINT ,    null ,    false ,    true ,    false ,    false )  ;", "TestCassandraClusteringPredicatesExtractor . cassandraTable    =    new   CassandraTable ( new   CassandraTableHandle (  \" cassandra \"  ,     \" test \"  ,     \" records \"  )  ,    ImmutableList . of ( TestCassandraClusteringPredicatesExtractor . col 1  ,    TestCassandraClusteringPredicatesExtractor . col 2  ,    TestCassandraClusteringPredicatesExtractor . col 3  ,    TestCassandraClusteringPredicatesExtractor . col 4  )  )  ;", "TestCassandraClusteringPredicatesExtractor . cassandraVersion    =    VersionNumber . parse (  \"  2  .  1  .  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "TupleDomain < ColumnHandle >    tupleDomain    =    TupleDomain . withColumnDomains ( ImmutableMap . of ( TestCassandraClusteringPredicatesExtractor . col 1  ,    Domain . singleValue ( BIGINT ,     2  3 L )  ,    TestCassandraClusteringPredicatesExtractor . col 2  ,    Domain . singleValue ( BIGINT ,     3  4 L )  ,    TestCassandraClusteringPredicatesExtractor . col 4  ,    Domain . singleValue ( BIGINT ,     2  6 L )  )  )  ;", "CassandraClusteringPredicatesExtractor   predicatesExtractor    =    new   CassandraClusteringPredicatesExtractor ( TestCassandraClusteringPredicatesExtractor . cassandraTable . getClusteringKeyColumns (  )  ,    tupleDomain ,    TestCassandraClusteringPredicatesExtractor . cassandraVersion )  ;", "String   predicate    =    predicatesExtractor . getClusteringKeyPredicates (  )  ;", "assertEquals ( predicate ,    new   StringBuilder (  \"  \\  \" clusteringKey 1  \\  \"     =     3  4  \"  )  . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildClusteringPredicate"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "TupleDomain < ColumnHandle >    tupleDomain    =    TupleDomain . withColumnDomains ( ImmutableMap . of ( TestCassandraClusteringPredicatesExtractor . col 2  ,    Domain . singleValue ( BIGINT ,     3  4 L )  ,    TestCassandraClusteringPredicatesExtractor . col 4  ,    Domain . singleValue ( BIGINT ,     2  6 L )  )  )  ;", "CassandraClusteringPredicatesExtractor   predicatesExtractor    =    new   CassandraClusteringPredicatesExtractor ( TestCassandraClusteringPredicatesExtractor . cassandraTable . getClusteringKeyColumns (  )  ,    tupleDomain ,    TestCassandraClusteringPredicatesExtractor . cassandraVersion )  ;", "TupleDomain < ColumnHandle >    unenforcedPredicates    =    TupleDomain . withColumnDomains ( ImmutableMap . of ( TestCassandraClusteringPredicatesExtractor . col 4  ,    Domain . singleValue ( BIGINT ,     2  6 L )  )  )  ;", "assertEquals ( predicatesExtractor . getUnenforcedConstraints (  )  ,    unenforcedPredicates )  ;", "}", "METHOD_END"], "methodName": ["testGetUnenforcedPredicates"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraClusteringPredicatesExtractor"}, {"methodBody": ["METHOD_START", "{", "List < CassandraColumnHandle >    columns    =    ImmutableList . of ( new   CassandraColumnHandle (  \"  \"  ,     \" foo \"  ,     0  ,    CassandraType . VARCHAR ,    null ,    false ,    false ,    false ,    false )  ,    new   CassandraColumnHandle (  \"  \"  ,     \" bar \"  ,     0  ,    CassandraType . VARCHAR ,    null ,    false ,    false ,    false ,    false )  ,    new   CassandraColumnHandle (  \"  \"  ,     \" table \"  ,     0  ,    CassandraType . VARCHAR ,    null ,    false ,    false ,    false ,    false )  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", ". appendSelectColumns ( sb ,    columns )  ;", "String   str    =    sb . toString (  )  ;", "assertEquals (  \" foo , bar ,  \\  \" table \\  \"  \"  ,    str )  ;", "}", "METHOD_END"], "methodName": ["testAppendSelectColumns"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  ' foo '  \"  ,    CassandraCqlUtils . quoteStringLiteral (  \" foo \"  )  )  ;", "assertEquals (  \"  ' Presto '  ' s '  \"  ,    CassandraCqlUtils . quoteStringLiteral (  \" Presto ' s \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuote"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  \\  \" foo \\  \"  \"  ,    CassandraCqlUtils . quoteStringLiteralForJson (  \" foo \"  )  )  ;", "assertEquals (  \"  \\  \" Presto \\  ' s \\  \"  \"  ,    CassandraCqlUtils . quoteStringLiteralForJson (  \" Presto ' s \"  )  )  ;", "assertEquals (  \"  \\  \" xx \\  \\  \\  \" xx \\  \"  \"  ,    CassandraCqlUtils . quoteStringLiteralForJson (  \" xx \\  \" xx \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testQuoteJson"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    CassandraCqlUtils . validColumnName (  \" foo \"  )  )  ;", "assertEquals (  \"  \\  \"  \\  \"  \"  ,    CassandraCqlUtils . validColumnName ( CassandraCqlUtils . EMPTY _ COLUMN _ NAME )  )  ;", "assertEquals (  \"  \\  \"  \\  \"  \"  ,    CassandraCqlUtils . validColumnName (  \"  \"  )  )  ;", "assertEquals (  \"  \\  \" select \\  \"  \"  ,    CassandraCqlUtils . validColumnName (  \" select \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidColumnName"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    CassandraCqlUtils . validSchemaName (  \" foo \"  )  )  ;", "assertEquals (  \"  \\  \" select \\  \"  \"  ,    CassandraCqlUtils . validSchemaName (  \" select \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidSchemaName"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" foo \"  ,    CassandraCqlUtils . validTableName (  \" foo \"  )  )  ;", "assertEquals (  \"  \\  \" Foo \\  \"  \"  ,    CassandraCqlUtils . validTableName (  \" Foo \"  )  )  ;", "assertEquals (  \"  \\  \" select \\  \"  \"  ,    CassandraCqlUtils . validTableName (  \" select \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testValidTableName"], "fileName": "com.facebook.presto.cassandra.util.TestCassandraCqlUtils"}, {"methodBody": ["METHOD_START", "{", "Set < Host >    hosts    =    ImmutableSet . of ( new   TestHost ( new   InetSocketAddress ( InetAddress . getByAddress ( new   byte [  ]  {     1  ,     2  ,     3  ,     4  ,     5  ,     6  ,     7  ,     8  ,     9  ,     1  0  ,     1  1  ,     1  2  ,     1  3  ,     1  4  ,     1  5  ,     1  6     }  )  ,     3  0  0  0  )  )  ,    new   TestHost ( new   InetSocketAddress ( InetAddress . getByAddress ( new   byte [  ]  {     1  ,     2  ,     3  ,     4     }  )  ,     3  0  0  0  )  )  )  ;", "hostAddressFactory    =    new    (  )  ;", "List < HostAddress >    list    =    hostAddressFactory . toHostAddressList ( hosts )  ;", "assertEquals ( list . toString (  )  ,     \"  [  [  1  0  2  :  3  0  4  :  5  0  6  :  7  0  8  :  9  0 a : b 0 c : d 0 e : f 1  0  ]  ,     1  .  2  .  3  .  4  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testToHostAddressList"], "fileName": "com.facebook.presto.cassandra.util.TestHostAddressFactory"}]