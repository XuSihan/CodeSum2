[{"methodBody": ["METHOD_START", "{", "if    ( diskRanges . isEmpty (  )  )     {", "return   ImmutableMap . of (  )  ;", "}", "Builder < K ,    FixedLengthSliceInput >    slices    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < K ,    DiskRange >    entry    :    diskRanges . entrySet (  )  )     {", "DiskRange   diskRange    =    entry . getValue (  )  ;", "slices . put ( entry . getKey (  )  ,    new   LazySliceInput ( diskRange . getLength (  )  ,    new    . LazyChunkedSliceLoader ( diskRange ,    Math . toIntExact ( streamBufferSize . toBytes (  )  )  )  )  )  ;", "}", "return   slices . build (  )  ;", "}", "METHOD_END"], "methodName": ["readLargeDiskRanges"], "fileName": "com.facebook.presto.orc.AbstractOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "if    ( diskRanges . isEmpty (  )  )     {", "return   ImmutableMap . of (  )  ;", "}", "Iterable < DiskRange >    mergedRanges    =    OrcDataSourceUtils . mergeAdjacentDiskRanges ( diskRanges . values (  )  ,    maxMergeDistance ,    maxBufferSize )  ;", "Builder < K ,    FixedLengthSliceInput >    slices    =    ImmutableMap . builder (  )  ;", "if    ( lazyReadSmallRanges )     {", "for    ( DiskRange   mergedRange    :    mergedRanges )     {", ". LazyBufferLoader   mergedRangeLazyLoader    =    new    . LazyBufferLoader ( mergedRange )  ;", "for    ( Map . Entry < K ,    DiskRange >    diskRangeEntry    :    diskRanges . entrySet (  )  )     {", "DiskRange   diskRange    =    diskRangeEntry . getValue (  )  ;", "if    ( mergedRange . contains ( diskRange )  )     {", "slices . put ( diskRangeEntry . getKey (  )  ,    new   LazySliceInput ( diskRange . getLength (  )  ,    new    . LazyMergedSliceLoader ( diskRange ,    mergedRangeLazyLoader )  )  )  ;", "}", "}", "}", "} else    {", "Map < DiskRange ,    byte [  ]  >    buffers    =    new   LinkedHashMap <  >  (  )  ;", "for    ( DiskRange   mergedRange    :    mergedRanges )     {", "byte [  ]    buffer    =    new   byte [ mergedRange . getLength (  )  ]  ;", "readFully ( mergedRange . getOffset (  )  ,    buffer )  ;", "buffers . put ( mergedRange ,    buffer )  ;", "}", "for    ( Map . Entry < K ,    DiskRange >    entry    :    diskRanges . entrySet (  )  )     {", "slices . put ( entry . getKey (  )  ,    OrcDataSourceUtils . getDiskRangeSlice ( entry . getValue (  )  ,    buffers )  . getInput (  )  )  ;", "}", "}", "Map < K ,    FixedLengthSliceInput >    sliceStreams    =    slices . build (  )  ;", "verify ( sliceStreams . keySet (  )  . equals ( diskRanges . keySet (  )  )  )  ;", "return   sliceStreams ;", "}", "METHOD_END"], "methodName": ["readSmallDiskRanges"], "fileName": "com.facebook.presto.orc.AbstractOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "BigInteger   decimalStep    =    new   BigInteger ( step )  ;", "List < SqlDecimal >    values    =    new   ArrayList <  >  (  )  ;", "BigInteger   nextValue    =    new   BigInteger ( start )  ;", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "values . add ( new   SqlDecimal ( nextValue ,    cision ,    scale )  )  ;", "nextValue    =    nextValue . add ( decimalStep )  ;", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["decimalSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "List < Double >    values    =    new   ArrayList <  >  (  )  ;", "double   nextValue    =    start ;", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "values . add ( nextValue )  ;", "nextValue    +  =    step ;", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["doubleSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "Builder < Float >    values    =    ImmutableList . builder (  )  ;", "float   nextValue    =    start ;", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "values . add ( nextValue )  ;", "nextValue    +  =    step ;", "}", "return   values . build (  )  ;", "}", "METHOD_END"], "methodName": ["floatSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "return   ContiguousSet . create ( Range . openClosed ( lowerInclusive ,    upperExclusive )  ,    DiscreteDomain . integers (  )  )  ;", "}", "METHOD_END"], "methodName": ["intsBetween"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >    new   com . google . common . collect . AbstractIterator < T >  (  )     {", "private   final   Iterator < T >    delegate    =    iterable . iterator (  )  ;", "private   int   position ;", "private   T   value ;", "@ Override", "protected   T   computeNext (  )     {", "if    (  ( position )     =  =     0  )     {", "if    (  !  ( delegate . hasNext (  )  )  )     {", "return   endOfData (  )  ;", "}", "value    =    delegate . next (  )  ;", "}", "( position )  +  +  ;", "if    (  ( position )     >  =    n )     {", "position    =     0  ;", "}", "return   value ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["repeatEach"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DateTimeZone . getDefault (  )  ,    OrcTester . HIVE _ STORAGE _ TIME _ ZONE )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "return    (  )     -  >    new   com . google . common . collect . AbstractIterator < T >  (  )     {", "private   final   Iterator < T >    delegate    =    iterable . iterator (  )  ;", "private   int   position ;", "@ Override", "protected   T   computeNext (  )     {", "while    ( true )     {", "if    (  !  ( delegate . hasNext (  )  )  )     {", "return   endOfData (  )  ;", "}", "T   next    =    delegate . next (  )  ;", "( position )  +  +  ;", "if    (  ( position )     <  =    n )     {", "return   next ;", "}", "position    =     0  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["skipEvery"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARBINARY ,    ImmutableList . copyOf ( limit ( cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ,     3  0  0  0  0  )  )  . stream (  )  . map ( Object :  : toString )  . map (  (    string )     -  >    string . getBytes ( StandardCharsets . UTF _  8  )  )  . map ( SqlVarbinary :  : new )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBinaryDictionarySequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARBINARY ,    AbstractTestOrcReader . intsBetween (  0  ,     3  0  0  0  0  )  . stream (  )  . map ( Object :  : toString )  . map (  (    string )     -  >    string . getBytes ( StandardCharsets . UTF _  8  )  )  . map ( SqlVarbinary :  : new )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBinaryDirectSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( BOOLEAN ,    newArrayList ( limit ( cycle ( ImmutableList . of ( true ,    false ,    false )  )  ,     3  0  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBooleanSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( AbstractTestOrcReader . CHAR ,    newArrayList ( limit ( cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ,     3  0  0  0  0  )  )  . stream (  )  . map ( this :  : toCharValue )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharDictionarySequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( AbstractTestOrcReader . CHAR ,    AbstractTestOrcReader . intsBetween (  0  ,     3  0  0  0  0  )  . stream (  )  . map ( this :  : toCharValue )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCharDirectSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  2  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  \"  ,     \"  1  \"  ,     6  0  ,     2  ,     1  )  )  ;", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  4  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  0  0  \"  ,     \"  1  \"  ,     6  0  0  0  ,     4  ,     2  )  )  ;", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  8  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  0  0  0  0  0  \"  ,     \"  1  0  0  \"  ,     6  0  0  0  0  ,     8  ,     4  )  )  ;", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  1  7  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  0  0  0  0  0  0  0  0  0  \"  ,     \"  1  0  0  0  0  0  0  \"  ,     6  0  0  0  0  ,     1  7  ,     8  )  )  ;", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  1  8  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  0  0  0  0  0  0  0  0  0  \"  ,     \"  1  0  0  0  0  0  0  \"  ,     6  0  0  0  0  ,     1  8  ,     8  )  )  ;", "tester . testRoundTrip ( AbstractTestOrcReader . DECIMAL _ TYPE _ PRECISION _  3  8  ,    AbstractTestOrcReader . decimalSequence (  \"  -  3  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  \"  ,     \"  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  \"  ,     6  0  0  0  0  ,     3  8  ,     1  6  )  )  ;", "}", "METHOD_END"], "methodName": ["testDecimalSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of (  1  0  0  0  .  0  ,     (  -  1  .  0  )  ,    Double . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of (  (  -  1  0  0  0  .  0  )  ,    Double . NEGATIVE _ INFINITY ,     1  .  0  )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of (  0  .  0  ,    Double . NEGATIVE _ INFINITY ,    Double . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of ( Double . NaN ,     (  -  1  .  0  )  ,     1  .  0  )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of ( Double . NaN ,     (  -  1  .  0  )  ,    Double . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of ( Double . NaN ,    Double . NEGATIVE _ INFINITY ,     1  .  0  )  )  ;", "tester . testRoundTrip ( DOUBLE ,    ImmutableList . of ( Double . NaN ,    Double . NEGATIVE _ INFINITY ,    Double . POSITIVE _ INFINITY )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleNaNInfinity"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( DOUBLE ,    AbstractTestOrcReader . doubleSequence (  0  ,     0  .  1  ,     3  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testDoubleSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    values    =    newArrayList ( limit ( cycle ( concat ( ImmutableList . of (  1  )  ,    Collections . nCopies (  9  9  9  9  ,     1  2  3  )  ,    ImmutableList . of (  2  )  ,    Collections . nCopies (  9  9  9  9  ,     1  2  3  )  ,    ImmutableList . of (  3  )  ,    Collections . nCopies (  9  9  9  9  ,     1  2  3  )  ,    Collections . nCopies (  1  0  0  0  0  0  0  ,    null )  )  )  ,     2  0  0  0  0  0  )  )  ;", "ter . assertRoundTrip ( INTEGER ,    values ,    false )  ;", "ter . assertRoundTrip ( VARCHAR ,    newArrayList ( values )  . stream (  )  . map (  (    value )     -  >    value    =  =    null    ?    null    :    String . valueOf ( value )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDwrfInvalidCheckpointsForRowGroupDictionary"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    newArrayList ( limit ( cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ,     2  0  0  0  0  0  )  )  . stream (  )  . map ( Object :  : toString )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testDwrfInvalidCheckpointsForStripeDictionary"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARBINARY ,    Collections . nCopies (  3  0  0  0  0  ,    new   SqlVarbinary ( new   byte [  0  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyBinarySequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( AbstractTestOrcReader . CHAR ,    newArrayList ( limit ( cycle (  \"                                \"  )  ,     3  0  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyCharSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    newArrayList ( limit ( cycle (  \"  \"  )  ,     3  0  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyStringSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( REAL ,    ImmutableList . of (  1  0  0  0  .  0 F ,     (  -  1  .  2  3 F )  ,    Float . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of (  (  -  1  0  0  0  .  0 F )  ,    Float . NEGATIVE _ INFINITY ,     1  .  2  3 F )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of (  0  .  0 F ,    Float . NEGATIVE _ INFINITY ,    Float . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of ( Float . NaN ,     (  -  0  .  0 F )  ,     1  .  0 F )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of ( Float . NaN ,     (  -  1  .  0 F )  ,    Float . POSITIVE _ INFINITY )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of ( Float . NaN ,    Float . NEGATIVE _ INFINITY ,     1  .  0 F )  )  ;", "tester . testRoundTrip ( REAL ,    ImmutableList . of ( Float . NaN ,    Float . NEGATIVE _ INFINITY ,    Float . POSITIVE _ INFINITY )  )  ;", "}", "METHOD_END"], "methodName": ["testFloatNaNInfinity"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( REAL ,    AbstractTestOrcReader . floatSequence (  0  .  0 F ,     0  .  1 F ,     3  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testFloatSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( limit ( cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ,     3  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongDirect"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    values    =    new   ArrayList <  >  (  3  1  2  3  4  )  ;", "for    ( int   i    =     0  ;    i    <     3  1  2  3  4  ;    i +  +  )     {", "values . add ( i )  ;", "}", "Collections . shuffle ( values ,    new   Random (  0  )  )  ;", "tRoundTripNumeric ( values )  ;", "}", "METHOD_END"], "methodName": ["testLongDirect2"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( limit ( cycle ( concat ( AbstractTestOrcReader . intsBetween (  0  ,     1  8  )  ,    AbstractTestOrcReader . intsBetween (  0  ,     1  8  )  ,    ImmutableList . of (  3  0  0  0  0  ,     2  0  0  0  0  ,     4  0  0  0  0  0  ,     3  0  0  0  0  ,     2  0  0  0  0  )  )  )  ,     3  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongPatchedBase"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( AbstractTestOrcReader . intsBetween (  0  ,     3  1  2  3  4  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( AbstractTestOrcReader . skipEvery (  5  ,    AbstractTestOrcReader . intsBetween (  0  ,     3  1  2  3  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongSequenceWithHoles"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( limit ( AbstractTestOrcReader . repeatEach (  4  ,    cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  )  ,     3  0  0  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongShortRepeat"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "testRoundTripNumeric ( concat ( ImmutableList . of (  1  )  ,    Collections . nCopies (  9  9  9  9  ,     1  2  3  )  ,    ImmutableList . of (  2  )  ,    Collections . nCopies (  9  9  9  9  ,     1  2  3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLongStrideDictionary"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "List < Long >    writeValues    =    ImmutableList . copyOf ( values )  . stream (  )  . map ( Number :  : longValue )  . collect ( Collectors . toList (  )  )  ;", "tester . testRoundTrip ( TINYINT ,    writeValues . stream (  )  . map ( Long :  : byteValue )  . collect ( Collectors . toList (  )  )  )  ;", "tester . testRoundTrip ( SMALLINT ,    writeValues . stream (  )  . map ( Long :  : shortValue )  . collect ( Collectors . toList (  )  )  )  ;", "tester . testRoundTrip ( INTEGER ,    writeValues . stream (  )  . map ( Long :  : intValue )  . collect ( Collectors . toList (  )  )  )  ;", "tester . testRoundTrip ( BIGINT ,    writeValues )  ;", "tester . testRoundTrip ( DATE ,    writeValues . stream (  )  . map ( Long :  : intValue )  . map ( SqlDate :  : new )  . collect ( Collectors . toList (  )  )  )  ;", "tester . testRoundTrip ( TIMESTAMP ,    writeValues . stream (  )  . map (  (    timestamp )     -  >    new   spi . type . SqlTimestamp ( timestamp ,    UTC _ KEY )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRoundTripNumeric"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    newArrayList ( limit ( cycle ( ImmutableList . of (  1  ,     3  ,     5  ,     7  ,     1  1  ,     1  3  ,     1  7  )  )  ,     3  0  0  0  0  )  )  . stream (  )  . map ( Object :  : toString )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringDictionarySequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    AbstractTestOrcReader . intsBetween (  0  ,     3  0  0  0  0  )  . stream (  )  . map ( Object :  : toString )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringDirectSequence"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    newArrayList ( concat ( ImmutableList . of (  \" a \"  )  ,    Collections . nCopies (  9  9  9  9  ,     \"  1  2  3  \"  )  ,    ImmutableList . of (  \" b \"  )  ,    Collections . nCopies (  9  9  9  9  ,     \"  1  2  3  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringStrideDictionary"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "tester . testRoundTrip ( VARCHAR ,    newArrayList ( limit ( cycle ( ImmutableList . of (  \" apple \"  ,     \" apple   pie \"  ,     \" apple \\ ud 8  3  5  \\ udc 0  3  \"  ,     \" apple \\ ufffd \"  )  )  ,     3  0  0  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringUnicode"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "return   Strings . padEnd ( value . toString (  )  ,    AbstractTestOrcReader . CHAR _ LENGTH ,     '     '  )  ;", "}", "METHOD_END"], "methodName": ["toCharValue"], "fileName": "com.facebook.presto.orc.AbstractTestOrcReader"}, {"methodBody": ["METHOD_START", "{", "BenchmarkOrcDecimalReader . BenchmarkData   data    =    new   BenchmarkOrcDecimalReader . BenchmarkData (  )  ;", "data . setup (  )  ;", "new   BenchmarkOrcDecimalReader (  )  . readDecimal ( data )  ;", "Options   options    =    new   OptionsBuilder (  )  . verbosity ( NORMAL )  . include (  (  (  \"  .  *  \"     +     ( BenchmarkOrcDecimalReader . class . getSimpleName (  )  )  )     +     \"  .  *  \"  )  )  . build (  )  ;", "new   Runner ( options )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.facebook.presto.orc.BenchmarkOrcDecimalReader"}, {"methodBody": ["METHOD_START", "{", "OrcRecordReader   recordReader    =    data . createRecordReader (  )  ;", "List < Block >    blocks    =    new   ArrayList <  >  (  )  ;", "while    (  ( recordReader . nextBatch (  )  )     >     0  )     {", "Block   block    =    recordReader . readBlock (  . DECIMAL _ TYPE ,     0  )  ;", "blocks . add ( block )  ;", "}", "return   blocks ;", "}", "METHOD_END"], "methodName": ["readDecimal"], "fileName": "com.facebook.presto.orc.BenchmarkOrcDecimalReader"}, {"methodBody": ["METHOD_START", "{", "BenchmarkOrcDecimalReader . BenchmarkData   data    =    new   BenchmarkOrcDecimalReader . BenchmarkData (  )  ;", "data . setup (  )  ;", "readDecimal ( data )  ;", "}", "METHOD_END"], "methodName": ["testReadDecimal"], "fileName": "com.facebook.presto.orc.BenchmarkOrcDecimalReader"}, {"methodBody": ["METHOD_START", "{", "DiskRange   newCacheRange    =    regionFinder . getRangeFor ( offset )  ;", "cachePosition    =    newCacheRange . getOffset (  )  ;", "cacheLength    =    newCacheRange . getLength (  )  ;", "if    (  ( cache . length )     <     ( cacheLength )  )     {", "cache    =    new   byte [ cacheLength ]  ;", "}", "d . readFully ( newCacheRange . getOffset (  )  ,    cache ,     0  ,    cacheLength )  ;", "}", "METHOD_END"], "methodName": ["readCacheAt"], "fileName": "com.facebook.presto.orc.CachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "closedSlices . add ( slice . slice (  0  ,    bufferPosition )  )  ;", "buffer    =    chunkSupplier . get (  )  ;", "slice    =    Slices . wrappedBuffer ( buffer )  ;", "streamOffset    +  =    bufferPosition ;", "bufferPosition    =     0  ;", "}", "METHOD_END"], "methodName": ["closeChunk"], "fileName": "com.facebook.presto.orc.ChunkedSliceOutput"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  ( minWritableBytes    <  =     ( ChunkedSliceOutput . MAX _ UNUSED _ BUFFER _ SIZE )  )  )  ;", "if    (  (  ( bufferPosition )     +    minWritableBytes )     >     ( slice . length (  )  )  )     {", "closeChunk (  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureWritableBytes"], "fileName": "com.facebook.presto.orc.ChunkedSliceOutput"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList .  < Slice > builder (  )  . addAll ( closedSlices )  . add ( Slices . copyOf ( slice ,     0  ,    bufferPosition )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getSlices"], "fileName": "com.facebook.presto.orc.ChunkedSliceOutput"}, {"methodBody": ["METHOD_START", "{", "ensureWritableBytes ( Math . min ( ChunkedSliceOutput . MAX _ UNUSED _ BUFFER _ SIZE ,    length )  )  ;", "return   Math . min ( length ,     (  ( slice . length (  )  )     -     ( bufferPosition )  )  )  ;", "}", "METHOD_END"], "methodName": ["tryEnsureBatchSize"], "fileName": "com.facebook.presto.orc.ChunkedSliceOutput"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . copyOf ( dictionaryWriters )  . stream (  )  . filter (  (    dictionaryWriter )     -  >     ( dictionaryWriter . getCompressionRatio (  )  )     <     ( DictionaryCompressionOptimizer . DICTIONARY _ MIN _ COMPRESSION _ RATIO )  )  . forEach ( this :  : convertToDirect )  ;", "}", "METHOD_END"], "methodName": ["convertLowCompressionStreams"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "dictionaryMemoryBytes    -  =    dictionaryWriter . getDictionaryBytes (  )  ;", "dictionaryWriter . convertToDirect (  )  ;", "dictionaryWriters . remove ( dictionaryWriter )  ;", "}", "METHOD_END"], "methodName": ["convertToDirect"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "long   uncompressedBytes    =    allOtherBytes ;", "long   compressedBytes    =    allOtherBytes ;", "for    (  . DictionaryColumnManager   column    :    dictionaryWriters )     {", "uncompressedBytes    +  =    column . getRawBytes (  )  ;", "compressedBytes    +  =    column . getDictionaryBytes (  )  ;", "}", "return    (  1  .  0     *    uncompressedBytes )     /    compressedBytes ;", "}", "METHOD_END"], "methodName": ["currentCompressionRatio"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "if    ( dictionaryEntries    <  =     2  5  6  )     {", "return    1  ;", "}", "if    ( dictionaryEntries    <  =     6  5  5  3  6  )     {", "return    2  ;", "}", "if    ( dictionaryEntries    <  =     1  6  7  7  7  2  1  6  )     {", "return    3  ;", "}", "return    4  ;", "}", "METHOD_END"], "methodName": ["estimateIndexBytesPerValue"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "convertLowCompressionStreams (  )  ;", "}", "METHOD_END"], "methodName": ["finalOptimize"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "return   dictionaryMemoryBytes ;", "}", "METHOD_END"], "methodName": ["getDictionaryMemoryBytes"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stripeRowCount )     >     ( stripeMinRowCount )  )     {", "return    ( dMemoryBytes )     >     ( dMemoryMaxBytesLow )  ;", "}", "return    ( dMemoryBytes )     >     ( dMemoryMaxBytesHigh )  ;", "}", "METHOD_END"], "methodName": ["isFull"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "dictionaryMemoryBytes    =    dictionaryWriters . stream (  )  . mapToInt ( DictionaryCompressionOptimizer . DictionaryColumnManager :  : getDictionaryBytes )  . sum (  )  ;", "dictionaryWriters . forEach (  (    column )     -  >    column . updateHistory ( stripeRowCount )  )  ;", "this . stripeRowCount    =    stripeRowCount ;", "if    (  ( dictionaryMemoryBytes )     <  =     ( dictionaryMemoryMaxBytesLow )  )     {", "return ;", "}", "convertLowCompressionStreams (  )  ;", "if    (  ( dictionaryMemoryBytes )     <  =     ( dictionaryMemoryMaxBytesLow )  )     {", "return ;", "}", "int   nonDictionaryBufferedBytes    =    bufferedBytes ;", "for    ( DictionaryCompressionOptimizer . DictionaryColumnManager   dictionaryWriter    :    dictionaryWriters )     {", "nonDictionaryBufferedBytes    -  =    dictionaryWriter . getBufferedBytes (  )  ;", "}", "while    (  ( dictionaryMemoryBytes )     >     ( dictionaryMemoryMaxBytesHigh )  )     {", "DictionaryCompressionOptimizer . DictionaryCompressionProjection   projection    =    selectDictionaryColumnToConvert ( nonDictionaryBufferedBytes ,    stripeRowCount )  ;", "if    (  ( projection . getColumnToConvert (  )  . getCompressionRatio (  )  )     >  =     ( DictionaryCompressionOptimizer . DICTIONARY _ ALWAYS _ KEEP _ COMPRESSION _ RATIO )  )     {", "return ;", "}", "convertToDirect ( projection . getColumnToConvert (  )  )  ;", "}", "if    ( stripeRowCount    >  =     ( stripeMinRowCount )  )     {", "double   currentCompressionRatio    =    currentCompressionRatio ( nonDictionaryBufferedBytes )  ;", "while    (  !  ( dictionaryWriters . isEmpty (  )  )  )     {", "DictionaryCompressionOptimizer . DictionaryCompressionProjection   projection    =    selectDictionaryColumnToConvert ( nonDictionaryBufferedBytes ,    stripeRowCount )  ;", "if    (  ( projection . getPredictedFileCompressionRatio (  )  )     <    currentCompressionRatio )     {", "return ;", "}", "convertToDirect ( projection . getColumnToConvert (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["optimize"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "dictionaryWriters . clear (  )  ;", "dictionaryWriters . addAll ( allWriters )  ;", "dictionaryMemoryBytes    =     0  ;", "allWriters . forEach (  . DictionaryColumnManager :  : reset )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( dictionaryWriters . isEmpty (  )  )  )  )  ;", "int   totalNonDictionaryBytesPerRow    =    totalNonDictionaryBytes    /    stripeRowCount ;", "long   totalDictionaryRawBytes    =     0  ;", "long   totalDictionaryBytes    =     0  ;", "long   totalDictionaryIndexBytes    =     0  ;", "long   totalDictionaryRawBytesPerRow    =     0  ;", "long   totalDictionaryBytesPerNewRow    =     0  ;", "long   totalDictionaryIndexBytesPerRow    =     0  ;", "for    (  . DictionaryColumnManager   column    :    dictionaryWriters )     {", "totalDictionaryRawBytes    +  =    column . getRawBytes (  )  ;", "totalDictionaryBytes    +  =    column . getDictionaryBytes (  )  ;", "totalDictionaryIndexBytes    +  =    column . getIndexBytes (  )  ;", "totalDictionaryRawBytesPerRow    +  =    column . getRawBytesPerRow (  )  ;", "totalDictionaryBytesPerNewRow    +  =    column . getDictionaryBytesPerFutureRow (  )  ;", "totalDictionaryIndexBytesPerRow    +  =    column . getIndexBytesPerRow (  )  ;", "}", "long   totalUncompressedBytesPerRow    =    totalNonDictionaryBytesPerRow    +    totalDictionaryRawBytesPerRow ;", ". DictionaryCompressionProjection   maxProjectedCompression    =    null ;", "for    (  . DictionaryColumnManager   column    :    dictionaryWriters )     {", "long   currentRawBytes    =    totalNonDictionaryBytes    +     ( column . getRawBytes (  )  )  ;", "long   currentDictionaryBytes    =    totalDictionaryBytes    -     ( column . getDictionaryBytes (  )  )  ;", "long   currentIndexBytes    =    totalDictionaryIndexBytes    -     ( column . getIndexBytes (  )  )  ;", "long   currentTotalBytes    =     ( currentRawBytes    +    currentDictionaryBytes )     +    currentIndexBytes ;", "double   rawBytesPerFutureRow    =    totalNonDictionaryBytesPerRow    +     ( column . getRawBytesPerRow (  )  )  ;", "double   dictionaryBytesPerFutureRow    =    totalDictionaryBytesPerNewRow    -     ( column . getDictionaryBytesPerFutureRow (  )  )  ;", "double   indexBytesPerFutureRow    =    totalDictionaryIndexBytesPerRow    -     ( column . getIndexBytesPerRow (  )  )  ;", "double   totalBytesPerFutureRow    =     ( rawBytesPerFutureRow    +    dictionaryBytesPerFutureRow )     +    indexBytesPerFutureRow ;", "long   rowsToDictionaryMemoryLimit    =     (  ( long )     (  (  ( dictionaryMemoryMaxBytesLow )     -    currentDictionaryBytes )     /    dictionaryBytesPerFutureRow )  )  ;", "long   rowsToStripeMemoryLimit    =     (  ( long )     (  (  ( stripeMaxBytes )     -    currentTotalBytes )     /    totalBytesPerFutureRow )  )  ;", "long   rowsToStripeRowLimit    =     ( stripeMaxRowCount )     -    stripeRowCount ;", "long   rowsToLimit    =    Longs . min ( rowsToDictionaryMemoryLimit ,    rowsToStripeMemoryLimit ,    rowsToStripeRowLimit )  ;", "long   predictedUncompressedSizeAtLimit    =     ( totalNonDictionaryBytes    +    totalDictionaryRawBytes )     +     ( totalUncompressedBytesPerRow    *    rowsToLimit )  ;", "long   predictedCompressedSizeAtLimit    =     (  ( long )     ( currentTotalBytes    +     ( totalBytesPerFutureRow    *    rowsToLimit )  )  )  ;", "double   predictedCompressionRatioAtLimit    =     (  1  .  0     *    predictedUncompressedSizeAtLimit )     /    predictedCompressedSizeAtLimit ;", "if    (  ( maxProjectedCompression    =  =    null )     |  |     (  ( maxProjectedCompression . getPredictedFileCompressionRatio (  )  )     <    predictedCompressionRatioAtLimit )  )     {", "maxProjectedCompression    =    new    . DictionaryCompressionProjection ( column ,    predictedCompressionRatioAtLimit )  ;", "}", "}", "return   maxProjectedCompression ;", "}", "METHOD_END"], "methodName": ["selectDictionaryColumnToConvert"], "fileName": "com.facebook.presto.orc.DictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "return    (  ( offset )     <  =     ( diskRange . getOffset (  )  )  )     &  &     (  ( diskRange . getEnd (  )  )     <  =     ( getEnd (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.facebook.presto.orc.DiskRange"}, {"methodBody": ["METHOD_START", "{", "return    ( offset )     +     ( length )  ;", "}", "METHOD_END"], "methodName": ["getEnd"], "fileName": "com.facebook.presto.orc.DiskRange"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.facebook.presto.orc.DiskRange"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.DiskRange"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( otherDiskRange ,     \" otherDiskRange   is   null \"  )  ;", "long   start    =    Math . min ( this . offset ,    otherDiskRange . getOffset (  )  )  ;", "long   end    =    Math . max ( getEnd (  )  ,    otherDiskRange . getEnd (  )  )  ;", "return   new   DiskRange ( start ,    Math . toIntExact (  ( end    -    start )  )  )  ;", "}", "METHOD_END"], "methodName": ["span"], "fileName": "com.facebook.presto.orc.DiskRange"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delegate )     =  =    null )     {", "delegate    =    Objects . quiNonNull ( loader . get (  )  ,     \" loader   turned   a   null   stam \"  )  ;", "verify (  (  ( delegate . length (  )  )     =  =     ( globalLength )  )  ,     \" loader   turned   stam   of   length    % s ,    but   length    % s   was   expected \"  ,    delegate . length (  )  ,    globalLength )  ;", "delegate . setPosition ( initialPosition )  ;", "}", "turn   delegate ;", "}", "METHOD_END"], "methodName": ["getDelegate"], "fileName": "com.facebook.presto.orc.LazySliceInput"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" Malformed   ORC   file .     \"     +     ( String . format ( messageFormat ,    args )  )  )     +     \"     [  \"  )     +    orcDataSourceId )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["formatMessage"], "fileName": "com.facebook.presto.orc.OrcCorruptionException"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < DiskRange ,    byte [  ]  >    bufferEntry    :    buffers . entrySet (  )  )     {", "DiskRange   bufferRange    =    bufferEntry . getKey (  )  ;", "byte [  ]    buffer    =    bufferEntry . getValue (  )  ;", "if    ( bufferRange . contains ( diskRange )  )     {", "int   offset    =    Math . toIntExact (  (  ( diskRange . getOffset (  )  )     -     ( bufferRange . getOffset (  )  )  )  )  ;", "return   Slices . wrappedBuffer ( buffer ,    offset ,    diskRange . getLength (  )  )  ;", "}", "}", "throw   new   IllegalStateException (  \" No   matching   buffer   for   disk   range \"  )  ;", "}", "METHOD_END"], "methodName": ["getDiskRangeSlice"], "fileName": "com.facebook.presto.orc.OrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < DiskRange >    ranges    =    new   ArrayList <  >  ( diskRanges )  ;", "Collections . sort ( ranges ,    new   Comparator < DiskRange >  (  )     {", "@ Override", "public   int   pare ( DiskRange   o 1  ,    DiskRange   o 2  )     {", "return   Long . pare ( o 1  . getOffset (  )  ,    o 2  . getOffset (  )  )  ;", "}", "}  )  ;", "long   maxReadSizeBytes    =    maxReadSize . toBytes (  )  ;", "long   maxMergeDistanceBytes    =    maxMergeDistance . toBytes (  )  ;", "ImmutableList . Builder < DiskRange >    result    =    ImmutableList . builder (  )  ;", "DiskRange   last    =    ranges . get (  0  )  ;", "for    ( int   i    =     1  ;    i    <     ( ranges . size (  )  )  ;    i +  +  )     {", "DiskRange   current    =    ranges . get ( i )  ;", "DiskRange   merged    =    last . span ( current )  ;", "if    (  (  ( merged . getLength (  )  )     <  =    maxReadSizeBytes )     &  &     (  (  ( last . getEnd (  )  )     +    maxMergeDistanceBytes )     >  =     ( current . getOffset (  )  )  )  )     {", "last    =    merged ;", "} else    {", "result . add ( last )  ;", "last    =    current ;", "}", "}", "result . add ( last )  ;", "return   result . build (  )  ;", "}", "METHOD_END"], "methodName": ["mergeAdjacentDiskRanges"], "fileName": "com.facebook.presto.orc.OrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compression    !  =     ( CompressionKind . NONE )  )     &  &     (  ( bufferSize    <  =     0  )     |  |     ( bufferSize    >     ( OrcDecompressor . MAX _ BUFFER _ SIZE )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     (  \" Invalid   compression   block   size :     \"     +    bufferSize )  )  ;", "}", "switch    ( compression )     {", "case   NONE    :", "return   Optional . empty (  )  ;", "case   ZLIB    :", "return   Optional . of ( new   OrcZlibDecompressor ( orcDataSourceId ,    bufferSize )  )  ;", "case   SNAPPY    :", "return   Optional . of ( new   OrcSnappyDecompressor ( orcDataSourceId ,    bufferSize )  )  ;", "case   LZ 4     :", "return   Optional . of ( new   OrcLz 4 Decompressor ( orcDataSourceId ,    bufferSize )  )  ;", "case   ZSTD    :", "return   Optional . of ( new   OrcZstdDecompressor ( orcDataSourceId ,    bufferSize )  )  ;", "default    :", "throw   new   OrcCorruptionException ( orcDataSourceId ,     (  \" Unknown   compression   type :     \"     +    compression )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createOrcDecompressor"], "fileName": "com.facebook.presto.orc.OrcDecompressor"}, {"methodBody": ["METHOD_START", "{", "ensureWritableBytes ( Math . min ( OrcOutputBuffer . DIRECT _ FLUSH _ SIZE ,    length )  )  ;", "return   Math . min ( length ,     (  ( slice . length (  )  )     -     ( bufferPosition )  )  )  ;", "}", "METHOD_END"], "methodName": ["ensureBatchSize"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "int   neededBufferSize    =     ( bufferPosition )     +    minWritableBytes ;", "if    ( neededBufferSize    <  =     ( slice . length (  )  )  )     {", "return ;", "}", "if    (  ( slice . length (  )  )     >  =     ( maxBufferSize )  )     {", "flushBufferToOutputStream (  )  ;", "return ;", "}", "int   newBufferSize    =    Math . min ( Math . max (  (  ( slice . length (  )  )     *     2  )  ,    minWritableBytes )  ,    maxBufferSize )  ;", "if    ( neededBufferSize    <  =    newBufferSize )     {", "byte [  ]    previousBuffer    =    buffer ;", "buffer    =    new   byte [ newBufferSize ]  ;", "slice    =    wrappedBuffer ( buffer )  ;", "System . arraycopy ( previousBuffer ,     0  ,    buffer ,     0  ,    bufferPosition )  ;", "} else    {", "flushBufferToOutputStream (  )  ;", "buffer    =    new   byte [ newBufferSize ]  ;", "slice    =    wrappedBuffer ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureWritableBytes"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bufferPosition )     >     0  )     {", "writeChunkToStream ( buffer ,     0  ,    bufferPosition )  ;", "bufferOffset    +  =    bufferPosition ;", "bufferPosition    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["flushBufferToOutputStream"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "return   slice . length (  )  ;", "}", "METHOD_END"], "methodName": ["getBufferCapacity"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compressor )     =  =    null )     {", "return   size (  )  ;", "}", "return   InputStreamCheckpoint . createInputStreamCheckpoint ( compressedStream . size (  )  ,    bufferPosition )  ;", "}", "METHOD_END"], "methodName": ["getCheckpoint"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compressor )     =  =    null )     {", "compressedStream . write ( chunk ,    offset ,    length )  ;", "return ;", "}", "checkArgument (  ( length    <  =     ( buffer . length )  )  ,     \" Write   chunk   length   must   be   less   than   compression   buffer   size \"  )  ;", "int   minCompressionBufferSize    =    compressor . maxCompressedLength ( length )  ;", "if    (  ( compressionBuffer . length )     <    minCompressionBufferSize )     {", "compressionBuffer    =    new   byte [ minCompressionBufferSize ]  ;", "}", "int   compressedSize    =    compressor . compress ( chunk ,    offset ,    length ,    compressionBuffer ,     0  ,    compressionBuffer . length )  ;", "if    ( compressedSize    <    length )     {", "int   chunkHeader    =    compressedSize    <  <     1  ;", "compressedStream . write (  ( chunkHeader    &     2  5  5  )  )  ;", "compressedStream . write (  (  ( chunkHeader    &     6  5  2  8  0  )     >  >     8  )  )  ;", "compressedStream . write (  (  ( chunkHeader    &     1  6  7  1  1  6  8  0  )     >  >     1  6  )  )  ;", "compressedStream . writeBytes ( compressionBuffer ,     0  ,    compressedSize )  ;", "} else    {", "int   header    =     ( length    <  <     1  )     +     1  ;", "compressedStream . write (  ( header    &     2  5  5  )  )  ;", "compressedStream . write (  (  ( header    &     6  5  2  8  0  )     >  >     8  )  )  ;", "compressedStream . write (  (  ( header    &     1  6  7  1  1  6  8  0  )     >  >     1  6  )  )  ;", "compressedStream . writeBytes ( chunk ,    offset ,    length )  ;", "}", "}", "METHOD_END"], "methodName": ["writeChunkToOutputStream"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "flushBufferToOutputStream (  )  ;", "for    ( Slice   slice    :    compressedOutputStream . getSlices (  )  )     {", "outputStream . writeBytes ( slice )  ;", "}", "return   compressedOutputStream . size (  )  ;", "}", "METHOD_END"], "methodName": ["writeDataTo"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compressor )     =  =    null )     {", "compressedStream . writeBytes ( bytes ,    bytesOffset ,    length )  ;", "return ;", "}", "while    ( length    >     0  )     {", "int   chunkSize    =    Integer . min ( length ,    buffer . length )  ;", "writeChunkToStream ( bytes ,    bytesOffset ,    chunkSize )  ;", "length    -  =    chunkSize ;", "bytesOffset    +  =    chunkSize ;", "}", "}", "METHOD_END"], "methodName": ["writeDirectlyToOutputStream"], "fileName": "com.facebook.presto.orc.OrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( version . size (  )  )     >  =     1  )     {", "int   major    =    version . get (  0  )  ;", "int   minor    =     0  ;", "if    (  ( version . size (  )  )     >     1  )     {", "minor    =    version . get (  1  )  ;", "}", "if    (  ( major    >     (  . CURRENT _ MAJOR _ VERSION )  )     |  |     (  ( major    =  =     (  . CURRENT _ MAJOR _ VERSION )  )     &  &     ( minor    >     (  . CURRENT _ MINOR _ VERSION )  )  )  )     {", ". log . warn (  \" ORC   file    % s   was   written   by   a   newer   Hive   version    % s .    This   file   may   not   be   readable   by   this   version   of   Hive    (  % s .  % s )  .  \"  ,    orcDataSource ,    Joiner . on (  '  .  '  )  . join ( version )  ,     . CURRENT _ MAJOR _ VERSION ,     . CURRENT _ MINOR _ VERSION )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkOrcVersion"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcRecordReader ( Objects . requireNonNull ( includedColumns ,     \" includedColumns   is   null \"  )  ,    Objects . requireNonNull ( predicate ,     \" predicate   is   null \"  )  ,    footer . getNumberOfRows (  )  ,    footer . getStripes (  )  ,    footer . getFileStats (  )  ,    metadata . getStripeStatsList (  )  ,    orcDataSource ,    offset ,    length ,    footer . getTypes (  )  ,    decompressor ,    footer . getRowsInRowGroup (  )  ,    Objects . requireNonNull ( hiveStorageTimeZone ,     \" hiveStorageTimeZone   is   null \"  )  ,    hiveWriterVersion ,    metadataReader ,    maxMergeDistance ,    maxReadSize ,    maxBlockSize ,    footer . getUserMetadata (  )  ,    systemMemoryUsage ,    writeValidation )  ;", "}", "METHOD_END"], "methodName": ["createRecordReader"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   createRecordReader ( includedColumns ,    predicate ,     0  ,    orcDataSource . getSize (  )  ,    hiveStorageTimeZone ,    systemMemoryUsage )  ;", "}", "METHOD_END"], "methodName": ["createRecordReader"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   bufferSize ;", "}", "METHOD_END"], "methodName": ["getBufferSize"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   footer . getTypes (  )  . get (  0  )  . getFieldNames (  )  ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   compressionKind ;", "}", "METHOD_END"], "methodName": ["getCompressionKind"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   footer ;", "}", "METHOD_END"], "methodName": ["getFooter"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "return   metadata ;", "}", "METHOD_END"], "methodName": ["getMetadata"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    headerMagic    =    new   byte [ PostScript . MAGIC . length (  )  ]  ;", "source . readFully (  0  ,    headerMagic )  ;", "return   PostScript . MAGIC . equals ( Slices . wrappedBuffer ( headerMagic )  )  ;", "}", "METHOD_END"], "methodName": ["isValidHeaderMagic"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "Builder < Integer ,    Type >    readTypes    =    ImmutableMap . builder (  )  ;", "for    ( int   columnIndex    =     0  ;    columnIndex    <     ( types . size (  )  )  ;    columnIndex +  +  )     {", "readTypes . put ( columnIndex ,    types . get ( columnIndex )  )  ;", "}", "try    {", "orcReader    =    new    ( input ,    orcEncoding ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  8  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  6  ,    Unit . MEGABYTE )  ,    Optional . of ( writeValidation )  )  ;", "try    ( OrcRecordReader   orcRecordReader    =    orcReader . createRecordReader ( readTypes . build (  )  ,    OrcPredicate . TRUE ,    hiveStorageTimeZone ,    newSimpleAggregatedMemoryContext (  )  )  )     {", "while    (  ( orcRecordReader . nextBatch (  )  )     >  =     0  )     {", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   OrcCorruptionException ( e ,    input . getId (  )  ,     \" Validation   failed \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateFile"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( writeValidation . isPresent (  )  )     &  &     (  !  ( test . test ( writeValidation . get (  )  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSource . getId (  )  ,     (  \" Write   validation   failed :     \"     +    messageFormat )  ,    args )  ;", "}", "}", "METHOD_END"], "methodName": ["validateWrite"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSource   instanceof   CachingOrcDataSource )     {", "return   dataSource ;", "}", "if    (  ( dataSource . getSize (  )  )     >     ( maxCacheSize . toBytes (  )  )  )     {", "return   dataSource ;", "}", "DiskRange   diskRange    =    new   DiskRange (  0  ,    Math . toIntExact ( dataSource . getSize (  )  )  )  ;", "return   new   CachingOrcDataSource ( dataSource ,     (    desiredOffset )     -  >    diskRange )  ;", "}", "METHOD_END"], "methodName": ["wrapWithCacheIfTiny"], "fileName": "com.facebook.presto.orc.OrcReader"}, {"methodBody": ["METHOD_START", "{", "nextRowInGroup    =     0  ;", "if    (  ( currentRowGroup )     >  =     0  )     {", "if    ( rowGroupStatisticsValidation . isPresent (  )  )     {", "OrcWriteValidation . StatisticsValidation   statisticsValidation    =    rowGroupStatisticsValidation . get (  )  ;", "long   offset    =    stripes . get ( currentStripe )  . getOffset (  )  ;", "writeValidation . get (  )  . validateRowGroupStatistics ( orcDataSource . getId (  )  ,    offset ,    currentRowGroup ,    statisticsValidation . build (  )  )  ;", "statisticsValidation . reset (  )  ;", "}", "}", "while    (  (  !  ( rowGroups . hasNext (  )  )  )     &  &     (  ( currentStripe )     <     ( stripes . size (  )  )  )  )     {", "advanceToNextStripe (  )  ;", "currentRowGroup    =     -  1  ;", "}", "if    (  !  ( rowGroups . hasNext (  )  )  )     {", "currentGroupRowCount    =     0  ;", "return   false ;", "}", "( currentRowGroup )  +  +  ;", "RowGroup   currentRowGroup    =    rowGroups . next (  )  ;", "currentGroupRowCount    =    currentRowGroup . getRowCount (  )  ;", "if    (  ( currentRowGroup . getMinAverageRowBytes (  )  )     >     0  )     {", "maxBatchSize    =    Math . toIntExact ( Math . min ( maxBatchSize ,    Math . max (  1  ,     (  ( maxBlockBytes )     /     ( currentRowGroup . getMinAverageRowBytes (  )  )  )  )  )  )  ;", "}", "currentPosition    =     ( currentStripePosition )     +     ( currentRowGroup . getRowOffset (  )  )  ;", "filePosition    =     ( stripeFilePositions . get ( currentStripe )  )     +     ( currentRowGroup . getRowOffset (  )  )  ;", "InputStreamSources   rowGroupStreamSources    =    currentRowGroup . getStreamSources (  )  ;", "for    ( Stream   column    :    streams )     {", "if    ( column    !  =    null )     {", "column . startRowGroup ( rowGroupStreamSources )  ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["advanceToNextRowGroup"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "currentStripeSystemMemoryContext . close (  )  ;", "currentStripeSystemMemoryContext    =    systemMemoryUsage . newAggregatedMemoryContext (  )  ;", "rowGroups    =    ImmutableList .  < RowGroup > of (  )  . iterator (  )  ;", "if    (  ( currentStripe )     >  =     0  )     {", "if    ( stripeStatisticsValidation . isPresent (  )  )     {", "OrcWriteValidation . StatisticsValidation   statisticsValidation    =    stripeStatisticsValidation . get (  )  ;", "long   offset    =    stripes . get ( currentStripe )  . getOffset (  )  ;", "writeValidation . get (  )  . validateStripeStatistics ( orcDataSource . getId (  )  ,    offset ,    statisticsValidation . build (  )  )  ;", "statisticsValidation . reset (  )  ;", "}", "}", "( currentStripe )  +  +  ;", "if    (  ( currentStripe )     >  =     ( stripes . size (  )  )  )     {", "return ;", "}", "if    (  ( currentStripe )     >     0  )     {", "currentStripePosition    +  =    stripes . get (  (  ( currentStripe )     -     1  )  )  . getNumberOfRows (  )  ;", "}", "StripeInformation   stripeInformation    =    stripes . get ( currentStripe )  ;", "validateWriteStripe ( stripeInformation . getNumberOfRows (  )  )  ;", "Stripe   stripe    =    stripe . readStripe ( stripeInformation ,    currentStripeSystemMemoryContext )  ;", "if    ( stripe    !  =    null )     {", "InputStreamSources   dictionaryStreamSources    =    stripe . getDictionaryStreamSources (  )  ;", "List < ColumnEncoding >    columnEncodings    =    stripe . getColumnEncodings (  )  ;", "for    ( Stream   column    :    streams )     {", "if    ( column    !  =    null )     {", "column . startStripe ( dictionaryStreamSources ,    columnEncodings )  ;", "}", "}", "rowGroups    =    stripe . getRowGroups (  )  . iterator (  )  ;", "}", "}", "METHOD_END"], "methodName": ["advanceToNextStripe"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "OrcType   type    =    types . get ( typeId )  ;", "if    (  !  ( fieldName . isEmpty (  )  )  )     {", "parentStreamName    +  =     \"  .  \"     +    fieldName ;", "}", "ImmutableList . Builder < StreamDescriptor >    nestedStreams    =    ImmutableList . builder (  )  ;", "if    (  ( type . getOrcTypeKind (  )  )     =  =     ( OrcType . OrcTypeKind . STRUCT )  )     {", "for    ( int   i    =     0  ;    i    <     ( type . getFieldCount (  )  )  ;     +  + i )     {", "nestedStreams . add (  . createStreamDescriptor ( parentStreamName ,    type . getFieldName ( i )  ,    type . getFieldTypeIndex ( i )  ,    types ,    dataSource )  )  ;", "}", "} else", "if    (  ( type . getOrcTypeKind (  )  )     =  =     ( OrcType . OrcTypeKind . LIST )  )     {", "nestedStreams . add (  . createStreamDescriptor ( parentStreamName ,     \" item \"  ,    type . getFieldTypeIndex (  0  )  ,    types ,    dataSource )  )  ;", "} else", "if    (  ( type . getOrcTypeKind (  )  )     =  =     ( OrcType . OrcTypeKind . MAP )  )     {", "nestedStreams . add (  . createStreamDescriptor ( parentStreamName ,     \" key \"  ,    type . getFieldTypeIndex (  0  )  ,    types ,    dataSource )  )  ;", "nestedStreams . add (  . createStreamDescriptor ( parentStreamName ,     \" value \"  ,    type . getFieldTypeIndex (  1  )  ,    types ,    dataSource )  )  ;", "}", "return   new   StreamDescriptor ( parentStreamName ,    typeId ,    fieldName ,    type . getOrcTypeKind (  )  ,    dataSource ,    nestedStreams . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createStreamDescriptor"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "List < StreamDescriptor >    streamDescriptors    =    OrcRecordReader . createStreamDescriptor (  \"  \"  ,     \"  \"  ,     0  ,    types ,    orcDataSource )  . getNestedStreams (  )  ;", "OrcType   rowType    =    types . get (  0  )  ;", "StreamReader [  ]    streamReaders    =    new   StreamReader [ rowType . getFieldCount (  )  ]  ;", "for    ( int   columnId    =     0  ;    columnId    <     ( rowType . getFieldCount (  )  )  ;    columnId +  +  )     {", "if    ( includedColumns . containsKey ( columnId )  )     {", "StreamDescriptor   streamDescriptor    =    streamDescriptors . get ( columnId )  ;", "streamReaders [ columnId ]     =    StreamReaders . createStreamReader ( streamDescriptor ,    hiveStorageTimeZone )  ;", "}", "}", "return   streamReaders ;", "}", "METHOD_END"], "methodName": ["createStreamReaders"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   filePosition ;", "}", "METHOD_END"], "methodName": ["getFilePosition"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   fileRowCount ;", "}", "METHOD_END"], "methodName": ["getFileRowCount"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   maxCombinedBytesPerRow ;", "}", "METHOD_END"], "methodName": ["getMaxCombinedBytesPerRow"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( float )     ( currentPosition )  )     /     ( totalRowCount )  ;", "}", "METHOD_END"], "methodName": ["getProgress"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   currentPosition ;", "}", "METHOD_END"], "methodName": ["getReaderPosition"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   totalRowCount ;", "}", "METHOD_END"], "methodName": ["getReaderRowCount"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   splitLength ;", "}", "METHOD_END"], "methodName": ["getSplitLength"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( rootStructType ,     \" rootStructType   is   null \"  )  ;", "checkArgument (  (  ( rootStructType . geTypeKind (  )  )     =  =    TypeTypeKind . STRUCT )  )  )  ;", "Objects . requireNonNull ( fileStats ,     \" fileStats   is   null \"  )  ;", "Builder < Integer ,    ColumnStatistics >    statistics    =    ImmutableMap . builder (  )  ;", "for    ( int   ordinal    =     0  ;    ordinal    <     ( rootStructType . getFieldCount (  )  )  ;    ordinal +  +  )     {", "if    (  ( fileStats . size (  )  )     >    ordinal )     {", "ColumnStatistics   element    =    fileStats . get ( rootStructType . getFieldTypeIndex ( ordinal )  )  ;", "if    ( element    !  =    null )     {", "statistics . put ( ordinal ,    element )  ;", "}", "}", "}", "return   statistics . build (  )  ;", "}", "METHOD_END"], "methodName": ["getStatisticsByColumnOrdinal"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  ( index    <     ( streamReaders . length )  )  ,     \" index   does   not   exist \"  )  ;", "return   streamReaders [ index ]  ;", "}", "METHOD_END"], "methodName": ["getStreamReader"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableMap . copyOf ( Maps . transformValues ( userMetadata ,    Slices :  : copyOf )  )  ;", "}", "METHOD_END"], "methodName": ["getUserMetadata"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   presentColumns . contains ( hiveColumnIndex )  ;", "}", "METHOD_END"], "methodName": ["isColumnPresent"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( stripeStats . isPresent (  )  )  )     {", "return   true ;", "}", "return   predicate . matches ( stripe . getNumberOfRows (  )  ,     . getStatisticsByColumnOrdinal ( rootStructType ,    stripeStats . get (  )  . getColumnStatistics (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isStripeIncluded"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "filePosition    +  =    currentBatchSize ;", "currentPosition    +  =    currentBatchSize ;", "if    (  ( nextRowInGroup )     >  =     ( currentGroupRowCount )  )     {", "if    (  !  ( advanceToNextRowGroup (  )  )  )     {", "filePosition    =    fileRowCount ;", "currentPosition    =    totalRowCount ;", "return    -  1  ;", "}", "}", "currentBatchSize    =    Math . toIntExact ( Math . min ( maxBatchSize ,     (  ( currentGroupRowCount )     -     ( nextRowInGroup )  )  )  )  ;", "for    ( Stream   column    :    streams )     {", "if    ( column    !  =    null )     {", "column . prepareNextRead ( currentBatchSize )  ;", "}", "}", "nextRowInGroup    +  =    currentBatchSize ;", "validateWritePageChecksum (  )  ;", "return   currentBatchSize ;", "}", "METHOD_END"], "methodName": ["nextBatch"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "Block   block    =    streamReaders [ columnIndex ]  . readBlock ( type )  ;", "if    (  ( block . getPositionCount (  )  )     >     0  )     {", "long   bytesPerCell    =     ( block . getSizeInBytes (  )  )     /     ( block . getPositionCount (  )  )  ;", "if    (  ( maxBytesPerCell [ columnIndex ]  )     <    bytesPerCell )     {", "maxCombinedBytesPerRow    =     (  ( maxCombinedBytesPerRow )     -     ( maxBytesPerCell [ columnIndex ]  )  )     +    bytesPerCell ;", "maxBytesPerCell [ columnIndex ]     =    bytesPerCell ;", "maxBatchSize    =    Math . toIntExact ( Math . min ( maxBatchSize ,    Math . max (  1  ,     (  ( maxBlockBytes )     /     ( maxCombinedBytesPerRow )  )  )  )  )  ;", "}", "}", "return   block ;", "}", "METHOD_END"], "methodName": ["readBlock"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "long   splitEndOffset    =    splitOffset    +    splitLength ;", "turn    ( splitOffset    <  =     ( stripe . getOffset (  )  )  )     &  &     (  ( stripe . getOffset (  )  )     <    splitEndOffset )  ;", "}", "METHOD_END"], "methodName": ["splitContainsStripe"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( writeValidation . isPresent (  )  )     &  &     (  !  ( test . apply ( writeValidation . get (  )  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSource . getId (  )  ,     (  \" Write   validation   failed :     \"     +    messageFormat )  ,    args )  ;", "}", "}", "METHOD_END"], "methodName": ["validateWrite"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "if    ( writeChecksumBuilder . isPresent (  )  )     {", "Block [  ]    blocks    =    new   Block [ streams . length ]  ;", "for    ( int   columnIndex    =     0  ;    columnIndex    <     ( streams . length )  ;    columnIndex +  +  )     {", "blocks [ columnIndex ]     =    readBlock ( includedColumns . get ( columnIndex )  ,    columnIndex )  ;", "}", "Page   page    =    new   Page ( currentBatchSize ,    blocks )  ;", "writeChecksumBuilder . get (  )  . addPage ( page )  ;", "rowGroupStatisticsValidation . get (  )  . addPage ( page )  ;", "stripeStatisticsValidation . get (  )  . addPage ( page )  ;", "fileStatisticsValidation . get (  )  . addPage ( page )  ;", "}", "}", "METHOD_END"], "methodName": ["validateWritePageChecksum"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "if    ( writeChecksumBuilder . isPresent (  )  )     {", "writeChecksumBuilder . get (  )  . addStripe ( rowCount )  ;", "}", "}", "METHOD_END"], "methodName": ["validateWriteStripe"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "if    ( dataSource   instanceof   CachingOrcDataSource )     {", "return   dataSource ;", "}", "for    ( StripeInformation   stripe    :    stripes )     {", "if    (  ( stripe . getTotalLength (  )  )     >     ( maxReadSize . toBytes (  )  )  )     {", "return   dataSource ;", "}", "}", "return   new   CachingOrcDataSource ( dataSource ,     . LinearProbeRangeFinder . createTinyStripesRangeFinder ( stripes ,    maxMergeDistance ,    maxReadSize )  )  ;", "}", "METHOD_END"], "methodName": ["wrapWithCacheIfTinyStripes"], "fileName": "com.facebook.presto.orc.OrcRecordReader"}, {"methodBody": ["METHOD_START", "{", "return   OrcTester . TYPE _ MANAGER . getParameterizedType ( ARRAY ,    ImmutableList . of ( TypeSignatureParameter . of ( elementType . getTypeSignature (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["arrayType"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( actual    =  =    null )     {", "assertNull ( expected )  ;", "return ;", "}", "String   baseType    =    type . getTypeSignature (  )  . getBase (  )  ;", "if    ( ARRAY . equals ( baseType )  )     {", "List <  ?  >    actualArray    =     (  ( List <  ?  >  )     ( actual )  )  ;", "List <  ?  >    expectedArray    =     (  ( List <  ?  >  )     ( expected )  )  ;", "assertEquals ( actualArray . size (  )  ,    expectedArray . size (  )  )  ;", "Type   elementType    =    type . getTypeParameters (  )  . get (  0  )  ;", "for    ( int   i    =     0  ;    i    <     ( actualArray . size (  )  )  ;    i +  +  )     {", "Object   actualElement    =    actualArray . get ( i )  ;", "Object   expectedElement    =    expectedArray . get ( i )  ;", ". assertColumnValueEquals ( elementType ,    actualElement ,    expectedElement )  ;", "}", "} else", "if    ( StandardTypes . MAP . equals ( baseType )  )     {", "Map <  ?  ,     ?  >    actualMap    =     (  ( Map <  ?  ,     ?  >  )     ( actual )  )  ;", "Map <  ?  ,     ?  >    expectedMap    =     (  ( Map <  ?  ,     ?  >  )     ( expected )  )  ;", "assertEquals ( actualMap . size (  )  ,    expectedMap . size (  )  )  ;", "Type   keyType    =    type . getTypeParameters (  )  . get (  0  )  ;", "Type   valueType    =    type . getTypeParameters (  )  . get (  1  )  ;", "List < Entry <  ?  ,     ?  >  >    expectedEntries    =    new   ArrayList <  >  ( expectedMap . entrySet (  )  )  ;", "for    ( Entry <  ?  ,     ?  >    actualEntry    :    actualMap . entrySet (  )  )     {", "for    ( Iterator < Entry <  ?  ,     ?  >  >    iterator    =    expectedEntries . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "Entry <  ?  ,     ?  >    expectedEntry    =    iterator . next (  )  ;", "try    {", ". assertColumnValueEquals ( keyType ,    actualEntry . getKey (  )  ,    expectedEntry . getKey (  )  )  ;", ". assertColumnValueEquals ( valueType ,    actualEntry . getValue (  )  ,    expectedEntry . getValue (  )  )  ;", "iterator . remove (  )  ;", "}    catch    ( AssertionError   ignored )     {", "}", "}", "}", "assertTrue ( expectedEntries . isEmpty (  )  ,     (  \" Unmatched   entries    \"     +    expectedEntries )  )  ;", "} else", "if    ( StandardTypes . ROW . equals ( baseType )  )     {", "List < Type >    fieldTypes    =    type . getTypeParameters (  )  ;", "List <  ?  >    actualRow    =     (  ( List <  ?  >  )     ( actual )  )  ;", "List <  ?  >    expectedRow    =     (  ( List <  ?  >  )     ( expected )  )  ;", "assertEquals ( actualRow . size (  )  ,    fieldTypes . size (  )  )  ;", "assertEquals ( actualRow . size (  )  ,    expectedRow . size (  )  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( actualRow . size (  )  )  ;    fieldId +  +  )     {", "Type   fieldType    =    fieldTypes . get ( fieldId )  ;", "Object   actualElement    =    actualRow . get ( fieldId )  ;", "Object   expectedElement    =    expectedRow . get ( fieldId )  ;", ". assertColumnValueEquals ( fieldType ,    actualElement ,    expectedElement )  ;", "}", "} else", "if    ( type . equals ( DOUBLE )  )     {", "Double   actualDouble    =     (  ( Double )     ( actual )  )  ;", "Double   expectedDouble    =     (  ( Double )     ( expected )  )  ;", "if    ( actualDouble . isNaN (  )  )     {", "assertTrue ( expectedDouble . isNaN (  )  ,     \" expected   double   to   be   NaN \"  )  ;", "} else    {", "assertEquals ( actualDouble ,    expectedDouble ,     0  .  0  0  1  )  ;", "}", "} else", "if    (  !  ( equals ( actual ,    expected )  )  )     {", "assertEquals ( actual ,    expected )  ;", "}", "}", "METHOD_END"], "methodName": ["assertColumnValueEquals"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "JobConf   configuration    =    new   JobConf ( new   Configuration ( false )  )  ;", "configuration . set ( ColumnProjectionUtils . READ _ COLUMN _ IDS _ CONF _ STR ,     \"  0  \"  )  ;", "configuration . setBoolean ( ColumnProjectionUtils . READ _ ALL _ COLUMNS ,    false )  ;", "Path   path    =    new   Path ( tempFile . getFile (  )  . getAbsolutePath (  )  )  ;", "Reader   reader    =    hive . orc . OrcFile . createReader ( path . getFileSystem ( configuration )  ,    path ,    configuration )  ;", "boolean [  ]    include    =    new   boolean [  ( reader . getTypes (  )  . size (  )  )     +     1  0  0  0  0  0  ]  ;", "Arrays . fill ( include ,    true )  ;", "RecordReader   recordReader    =    reader . rows ( include )  ;", "StructObjectInspector   rowInspector    =     (  ( StructObjectInspector )     ( reader . getObjectInspector (  )  )  )  ;", "StructField   field    =    rowInspector . getStructFieldRef (  \" test \"  )  ;", "Iterator <  ?  >    iterator    =    expectedValues . iterator (  )  ;", "Object   rowData    =    null ;", "while    ( recordReader . hasNext (  )  )     {", "rowData    =    recordReader . next ( rowData )  ;", "Object   expectedValue    =    iterator . next (  )  ;", "Object   actualValue    =    rowInspector . getStructFieldData ( rowData ,    field )  ;", "actualValue    =    OrcTester . decodeRecordReaderValue ( type ,    actualValue )  ;", "OrcTester . assertColumnValueEquals ( type ,    actualValue ,    expectedValue )  ;", "}", "assertFalse ( iterator . hasNext (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFileContentsDwrfHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( format    =  =     ( OrcTester . Format . DWRF )  )     {", "OrcTester . assertFileContentsDwrfHive ( type ,    tempFile ,    expectedValues )  ;", "} else    {", "OrcTester . assertFileContentsOrcHive ( type ,    tempFile ,    expectedValues )  ;", "}", "}", "METHOD_END"], "methodName": ["assertFileContentsHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "JobConf   configuration    =    new   JobConf ( new   Configuration ( false )  )  ;", "configuration . set ( ColumnProjectionUtils . READ _ COLUMN _ IDS _ CONF _ STR ,     \"  0  \"  )  ;", "configuration . setBoolean ( ColumnProjectionUtils . READ _ ALL _ COLUMNS ,    false )  ;", "Reader   reader    =    OrcFile . createReader ( new   Path ( tempFile . getFile (  )  . getAbsolutePath (  )  )  ,    new   ReaderOptions ( configuration )  )  ;", "RecordReader   recordReader    =    reader . rows (  )  ;", "StructObjectInspector   rowInspector    =     (  ( StructObjectInspector )     ( reader . getObjectInspector (  )  )  )  ;", "StructField   field    =    rowInspector . getStructFieldRef (  \" test \"  )  ;", "Iterator <  ?  >    iterator    =    expectedValues . iterator (  )  ;", "Object   rowData    =    null ;", "while    ( recordReader . hasNext (  )  )     {", "rowData    =    recordReader . next ( rowData )  ;", "Object   expectedValue    =    iterator . next (  )  ;", "Object   actualValue    =    rowInspector . getStructFieldData ( rowData ,    field )  ;", "actualValue    =    OrcTester . decodeRecordReaderValue ( type ,    actualValue )  ;", "OrcTester . assertColumnValueEquals ( type ,    actualValue ,    expectedValue )  ;", "}", "assertFalse ( iterator . hasNext (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertFileContentsOrcHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "try    ( OrcRecordReader   recordReader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    orcEncoding ,    TestingOrcPredicate . createOrcPredicate ( type ,    expectedValues ,    format ,    isHiveWriter )  ,    type )  )     {", "assertEquals ( recordReader . getReaderPosition (  )  ,     0  )  ;", "assertEquals ( recordReader . getFilePosition (  )  ,     0  )  ;", "boolean   isFirst    =    true ;", "int   rowsProcessed    =     0  ;", "Iterator <  ?  >    iterator    =    expectedValues . iterator (  )  ;", "for    ( int   batchSize    =    Math . toIntExact ( recordReader . nextBatch (  )  )  ;    batchSize    >  =     0  ;    batchSize    =    Math . toIntExact ( recordReader . nextBatch (  )  )  )     {", "if    ( skipStripe    &  &     ( rowsProcessed    <     1  0  0  0  0  )  )     {", "assertEquals ( advance ( iterator ,    batchSize )  ,    batchSize )  ;", "} else", "if    ( skipFirstBatch    &  &    isFirst )     {", "assertEquals ( advance ( iterator ,    batchSize )  ,    batchSize )  ;", "isFirst    =    false ;", "} else    {", "spi . block . Block   block    =    recordReader . readBlock ( type ,     0  )  ;", "List < Object >    data    =    new   ArrayList ( block . getPositionCount (  )  )  ;", "for    ( int   position    =     0  ;    position    <     ( block . getPositionCount (  )  )  ;    position +  +  )     {", "data . add ( type . getObjectValue ( SESSION ,    block ,    position )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "assertTrue ( iterator . hasNext (  )  )  ;", "Object   expected    =    iterator . next (  )  ;", "Object   actual    =    data . get ( i )  ;", "OrcTester . assertColumnValueEquals ( type ,    actual ,    expected )  ;", "}", "}", "assertEquals ( recordReader . getReaderPosition (  )  ,    rowsProcessed )  ;", "assertEquals ( recordReader . getFilePosition (  )  ,    rowsProcessed )  ;", "rowsProcessed    +  =    batchSize ;", "}", "assertFalse ( iterator . hasNext (  )  )  ;", "assertEquals ( recordReader . getReaderPosition (  )  ,    rowsProcessed )  ;", "assertEquals ( recordReader . getFilePosition (  )  ,    rowsProcessed )  ;", "}", "}", "METHOD_END"], "methodName": ["assertFileContentsPresto"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "assertRoundTrip ( type ,    readValues ,    true )  ;", "}", "METHOD_END"], "methodName": ["assertRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "OrcWriterStats   stats    =    new   OrcWriterStats (  )  ;", "for    (  . Format   format    :    formats )     {", "if    (  !  ( format . supportsType ( type )  )  )     {", "return ;", "}", "OrcEncoding   orcEncoding    =    format . getOrcEncoding (  )  ;", "for    ( CompressionKind   compression    :    compressions )     {", "boolean   hiveSupported    =    compression    !  =     ( CompressionKind . LZ 4  )  ;", "if    ( hiveSupported )     {", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", ". writeOrcColumnHive ( tempFile . getFile (  )  ,    format ,    compression ,    type ,    readValues . iterator (  )  )  ;", ". assertFileContentsPresto ( type ,    tempFile ,    readValues ,    false ,    false ,    orcEncoding ,    format ,    true )  ;", "}", "}", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", ". writeOrcColumnPresto ( tempFile . getFile (  )  ,    format ,    compression ,    type ,    readValues . iterator (  )  ,    stats )  ;", "if    ( verifyWithHiveReader    &  &    hiveSupported )     {", ". assertFileContentsHive ( type ,    tempFile ,    format ,    readValues )  ;", "}", ". assertFileContentsPresto ( type ,    tempFile ,    readValues ,    false ,    false ,    orcEncoding ,    format ,    false )  ;", "if    ( skipBatchTestsEnabled )     {", ". assertFileContentsPresto ( type ,    tempFile ,    readValues ,    true ,    false ,    orcEncoding ,    format ,    false )  ;", "}", "if    ( skipStripeTestsEnabled )     {", ". assertFileContentsPresto ( type ,    tempFile ,    readValues ,    false ,    true ,    orcEncoding ,    format ,    false )  ;", "}", "}", "}", "}", "assertEquals ( stats . getWriterSizeInBytes (  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["assertRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "OrcDataSource   orcDataSource    =    new   FileOrcDataSource ( tempFile . getFile (  )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    true )  ;", "OrcReader   orcReader    =    new   OrcReader ( orcDataSource ,    orcEncoding ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,     . MAX _ BLOCK _ SIZE )  ;", "assertEquals ( orcReader . getColumnNames (  )  ,    ImmutableList . of (  \" test \"  )  )  ;", "assertEquals ( orcReader . getFooter (  )  . getRowsInRowGroup (  )  ,     1  0  0  0  0  )  ;", "return   orcReader . createRecordReader ( ImmutableMap . of (  0  ,    type )  ,    predicate ,     . HIVE _ STORAGE _ TIME _ ZONE ,    newSimpleAggregatedMemoryContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCustomOrcRecordReader"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "JobConf   jobConf    =    new   JobConf (  )  ;", "jobConf . set (  \" hive . exec . orc . default . compress \"  ,    compressionCodec . name (  )  )  ;", "jobConf . set (  \" hive . exec . orc . compress \"  ,    compressionCodec . name (  )  )  ;", "OrcConf . setIntVar ( jobConf ,    HIVE _ ORC _ ENTROPY _ STRING _ THRESHOLD ,     1  )  ;", "OrcConf . setIntVar ( jobConf ,    HIVE _ ORC _ DICTIONARY _ ENCODING _ INTERVAL ,     2  )  ;", "OrcConf . setBoolVar ( jobConf ,    HIVE _ ORC _ BUILD _ STRIDE _ DICTIONARY ,    true )  ;", "return   new   OrcOutputFormat (  )  . getHiveRecordWriter ( jobConf ,    new   Path ( outputFile . toURI (  )  )  ,    Text . class ,     ( compressionCodec    !  =     ( CompressionKind . NONE )  )  ,     . createTableProperties (  \" test \"  ,     . getJavaObjectInspector ( type )  . getTypeName (  )  )  ,     (  )     -  >     {", "}  )  ;", "}", "METHOD_END"], "methodName": ["createDwrfRecordWriter"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "JobConf   jobConf    =    new   JobConf (  )  ;", "jobConf . set (  \" hive . exec . orc . write . format \"  ,     ( format    =  =     (  . Format . ORC _  1  2  )     ?     \"  0  .  1  2  \"     :     \"  0  .  1  1  \"  )  )  ;", "jobConf . set (  \" hive . exec . orc . default . compress \"  ,    compression . name (  )  )  ;", "return   new   OrcOutputFormat (  )  . getHiveRecordWriter ( jobConf ,    new   Path ( outputFile . toURI (  )  )  ,    Text . class ,     ( compression    !  =     ( CompressionKind . NONE )  )  ,     . createTableProperties (  \" test \"  ,     . getJavaObjectInspector ( type )  . getTypeName (  )  )  ,     (  )     -  >     {", "}  )  ;", "}", "METHOD_END"], "methodName": ["createOrcRecordWriter"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   ObjectInspectorFactory . getStandardStructObjectInspector ( ImmutableList . of ( name )  ,    ImmutableList . of ( OrcTester . getJavaObjectInspector ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["createSettableStructObjectInspector"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Properties   orderTableProperties    =    new   Properties (  )  ;", "orderTableProperties . setProperty (  \" columns \"  ,    name )  ;", "orderTableProperties . setProperty (  \" columns . types \"  ,    type )  ;", "return   orderTableProperties ;", "}", "METHOD_END"], "methodName": ["createTableProperties"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Type   elementType    =    type . getTypeParameters (  )  . get (  0  )  ;", "return   list . stream (  )  . map (  (    element )     -  >     . decodeRecordReaderValue ( elementType ,    element )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeRecordReaderList"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Type   keyType    =    type . getTypeParameters (  )  . get (  0  )  ;", "Type   valueType    =    type . getTypeParameters (  )  . get (  1  )  ;", "Map < Object ,    Object >    newMap    =    new   HashMap <  >  (  )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    map . entrySet (  )  )     {", "newMap . put (  . decodeRecordReaderValue ( keyType ,    entry . getKey (  )  )  ,     . decodeRecordReaderValue ( valueType ,    entry . getValue (  )  )  )  ;", "}", "return   newMap ;", "}", "METHOD_END"], "methodName": ["decodeRecordReaderMap"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "List < Type >    fieldTypes    =    type . getTypeParameters (  )  ;", "List < Object >    newFields    =    new   ArrayList <  >  ( fields . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( fields . size (  )  )  ;    i +  +  )     {", "Type   fieldType    =    fieldTypes . get ( i )  ;", "Object   field    =    fields . get ( i )  ;", "newFields . add (  . decodeRecordReaderValue ( fieldType ,    field )  )  ;", "}", "return   newFields ;", "}", "METHOD_END"], "methodName": ["decodeRecordReaderStruct"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( actualValue   instanceof   OrcLazyObject )     {", "try    {", "actualValue    =     (  ( OrcLazyObject )     ( actualValue )  )  . materialize (  )  ;", "}    catch    ( IOException   e )     {", "throw   Throwables . propagate ( e )  ;", "}", "}", "if    ( actualValue   instanceof   BooleanWritable )     {", "actualValue    =     (  ( BooleanWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   ByteWritable )     {", "actualValue    =     (  ( ByteWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   BytesWritable )     {", "actualValue    =    new   spi . type . SqlVarbinary (  (  ( BytesWritable )     ( actualValue )  )  . copyBytes (  )  )  ;", "} else", "if    ( actualValue   instanceof   DateWritable )     {", "actualValue    =    new   spi . type . SqlDate (  (  ( DateWritable )     ( actualValue )  )  . getDays (  )  )  ;", "} else", "if    ( actualValue   instanceof   DoubleWritable )     {", "actualValue    =     (  ( DoubleWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   FloatWritable )     {", "actualValue    =     (  ( FloatWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   IntWritable )     {", "actualValue    =     (  ( IntWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   HiveCharWritable )     {", "actualValue    =     (  ( HiveCharWritable )     ( actualValue )  )  . getPaddedValue (  )  . toString (  )  ;", "} else", "if    ( actualValue   instanceof   LongWritable )     {", "actualValue    =     (  ( LongWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   ShortWritable )     {", "actualValue    =     (  ( ShortWritable )     ( actualValue )  )  . get (  )  ;", "} else", "if    ( actualValue   instanceof   HiveDecimalWritable )     {", "spi . type . DecimalType   decimalType    =     (  ( spi . type . DecimalType )     ( type )  )  ;", "HiveDecimalWritable   writable    =     (  ( HiveDecimalWritable )     ( actualValue )  )  ;", "BigInteger   rescaledValue    =    rescale ( writable . getHiveDecimal (  )  . unscaledValue (  )  ,    writable . getScale (  )  ,    decimalType . getScale (  )  )  ;", "actualValue    =    new   spi . type . SqlDecimal ( rescaledValue ,    decimalType . getPrecision (  )  ,    decimalType . getScale (  )  )  ;", "} else", "if    ( actualValue   instanceof   Text )     {", "actualValue    =    actualValue . toString (  )  ;", "} else", "if    ( actualValue   instanceof   TimestampWritable )     {", "TimestampWritable   timestamp    =     (  ( TimestampWritable )     ( actualValue )  )  ;", "actualValue    =    new   spi . type . SqlTimestamp (  (  (  ( timestamp . getSeconds (  )  )     *     1  0  0  0  )     +     (  ( timestamp . getNanos (  )  )     /     1  0  0  0  0  0  0 L )  )  ,    spi . type . TimeZoneKey . UTC _ KEY )  ;", "} else", "if    ( actualValue   instanceof   OrcStruct )     {", "List < Object >    fields    =    new   ArrayList <  >  (  )  ;", "OrcStruct   structObject    =     (  ( OrcStruct )     ( actualValue )  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( structObject . getNumFields (  )  )  ;    fieldId +  +  )     {", "fields . add ( getFieldValue ( structObject ,    fieldId )  )  ;", "}", "actualValue    =    OrcTester . decodeRecordReaderStruct ( type ,    fields )  ;", "} else", "if    ( actualValue   instanceof   com . facebook . hive . orc . OrcStruct )     {", "List < Object >    fields    =    new   ArrayList <  >  (  )  ;", "com . facebook . hive . orc . OrcStruct   structObject    =     (  ( com . facebook . hive . orc . OrcStruct )     ( actualValue )  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( structObject . getNumFields (  )  )  ;    fieldId +  +  )     {", "fields . add ( structObject . getFieldValue ( fieldId )  )  ;", "}", "actualValue    =    OrcTester . decodeRecordReaderStruct ( type ,    fields )  ;", "} else", "if    ( actualValue   instanceof   List )     {", "actualValue    =    OrcTester . decodeRecordReaderList ( type ,     (  ( List <  ?  >  )     ( actualValue )  )  )  ;", "} else", "if    ( actualValue   instanceof   Map )     {", "actualValue    =    OrcTester . decodeRecordReaderMap ( type ,     (  ( Map <  ?  ,     ?  >  )     ( actualValue )  )  )  ;", "}", "return   actualValue ;", "}", "METHOD_END"], "methodName": ["decodeRecordReaderValue"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "OrcTester   orcTester    =    new   OrcTester (  )  ;", "orcTester . structTestsEnabled    =    true ;", "orcTester . mapTestsEnabled    =    true ;", "orcTester . listTestsEnabled    =    true ;", "orcTester . complexStructuralTestsEnabled    =    true ;", "orcTester . structuralNullTestsEnabled    =    true ;", "orcTester . reverseTestsEnabled    =    true ;", "orcTester . nullTestsEnabled    =    true ;", "orcTester . skipBatchTestsEnabled    =    true ;", "orcTester . skipStripeTestsEnabled    =    true ;", "orcTester . formats    =    ImmutableSet . copyOf ( OrcTester . Format . values (  )  )  ;", "orcTester . compressions    =    ImmutableSet . of ( CompressionKind . NONE ,    CompressionKind . SNAPPY ,    CompressionKind . ZLIB ,    CompressionKind . LZ 4  )  ;", "return   orcTester ;", "}", "METHOD_END"], "methodName": ["fullOrcTester"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   wriField    =    instance . getClass (  )  . getDeclaredField ( name )  ;", "wriField . setAccessible ( true )  ;", "return   wriField . get ( instance )  ;", "}    catch    ( Exception   e )     {", "throw   Throwables . propagate ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getFieldValue"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals ( BOOLEAN )  )     {", "return   PrimitiveObjectInspectorFactory . javaBooleanObjectInspector ;", "}", "if    ( type . equals ( BIGINT )  )     {", "return   PrimitiveObjectInspectorFactory . javaLongObjectInspector ;", "}", "if    ( type . equals ( INTEGER )  )     {", "return   PrimitiveObjectInspectorFactory . javaIntObjectInspector ;", "}", "if    ( type . equals ( SMALLINT )  )     {", "return   PrimitiveObjectInspectorFactory . javaShortObjectInspector ;", "}", "if    ( type . equals ( TINYINT )  )     {", "return   PrimitiveObjectInspectorFactory . javaByteObjectInspector ;", "}", "if    ( type . equals ( REAL )  )     {", "return   PrimitiveObjectInspectorFactory . javaFloatObjectInspector ;", "}", "if    ( type . equals ( DOUBLE )  )     {", "return   PrimitiveObjectInspectorFactory . javaDoubleObjectInspector ;", "}", "if    ( type   instanceof   VarcharType )     {", "return   PrimitiveObjectInspectorFactory . javaStringObjectInspector ;", "}", "if    ( type   instanceof   CharType )     {", "int   charLength    =     (  ( CharType )     ( type )  )  . getLength (  )  ;", "return   new   JavaHiveCharObjectInspector ( TypeInfoFactory . getCharTypeInfo ( charLength )  )  ;", "}", "if    ( type   instanceof   VarbinaryType )     {", "return   PrimitiveObjectInspectorFactory . javaByteArrayObjectInspector ;", "}", "if    ( type . equals ( DATE )  )     {", "return   PrimitiveObjectInspectorFactory . javaDateObjectInspector ;", "}", "if    ( type . equals ( TIMESTAMP )  )     {", "return   PrimitiveObjectInspectorFactory . javaTimestampObjectInspector ;", "}", "if    ( type   instanceof   DecimalType )     {", "DecimalType   decimalType    =     (  ( DecimalType )     ( type )  )  ;", "return   PrimitiveObjectInspectorFactory . getPrimitiveJavaObjectInspector ( new   DecimalTypeInfo ( decimalType . getPrecision (  )  ,    decimalType . getScale (  )  )  )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( ARRAY )  )     {", "return   ObjectInspectorFactory . getStandardListObjectInspector (  . getJavaObjectInspector ( type . getTypeParameters (  )  . get (  0  )  )  )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( MAP )  )     {", "ObjectInspector   keyObjectInspector    =     . getJavaObjectInspector ( type . getTypeParameters (  )  . get (  0  )  )  ;", "ObjectInspector   valueObjectInspector    =     . getJavaObjectInspector ( type . getTypeParameters (  )  . get (  1  )  )  ;", "return   ObjectInspectorFactory . getStandardMapObjectInspector ( keyObjectInspector ,    valueObjectInspector )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( ROW )  )     {", "return   ObjectInspectorFactory . getStandardStructObjectInspector ( type . getTypeSignature (  )  . getParameters (  )  . stream (  )  . map (  (    parameter )     -  >    parameter . getNamedTypeSignature (  )  . getName (  )  . get (  )  )  . collect ( Collectors . toList (  )  )  ,    type . getTypeParameters (  )  . stream (  )  . map (  :  : getJavaObjectInspector )  . collect ( Collectors . toList (  )  )  )  ;", "}", "throw   new   IllegalArgumentException (  (  \" unsupported   type :     \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["getJavaObjectInspector"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "String   testBaseType    =    testType . getTypeSignature (  )  . getBase (  )  ;", "if    ( ARRAY . equals ( testBaseType )  )     {", "Type   elementType    =    testType . getTypeParameters (  )  . get (  0  )  ;", "return    . hasType ( elementType ,    baseTypes )  ;", "}", "if    ( MAP . equals ( testBaseType )  )     {", "Type   keyType    =    testType . getTypeParameters (  )  . get (  0  )  ;", "Type   valueType    =    testType . getTypeParameters (  )  . get (  1  )  ;", "return    (  . hasType ( keyType ,    baseTypes )  )     |  |     (  . hasType ( valueType ,    baseTypes )  )  ;", "}", "if    ( ROW . equals ( testBaseType )  )     {", "return   testType . getTypeParameters (  )  . stream (  )  . anyMatch (  (    fieldType )     -  >    hasType ( fieldType ,    baseTypes )  )  ;", "}", "return   baseTypes . contains ( testBaseType )  ;", "}", "METHOD_END"], "methodName": ["hasType"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   newArrayList (  (  )     -  >    new   AbstractIterator < T >  (  )     {", "private   final   Iterator < T >    delegate    =    iterable . iterator (  )  ;", "private   int   position ;", "@ Override", "protected   T   computeNext (  )     {", "( position )  +  +  ;", "if    (  ( position )     >    n )     {", "position    =     0  ;", "return   null ;", "}", "if    (  !  ( delegate . hasNext (  )  )  )     {", "return   endOfData (  )  ;", "}", "return   delegate . next (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["insertNullEvery"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   OrcTester . TYPE _ MANAGER . getParameterizedType ( MAP ,    ImmutableList . of ( TypeSignatureParameter . of ( keyType . getTypeSignature (  )  )  ,    TypeSignatureParameter . of ( valueType . getTypeSignature (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mapType"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   null ;", "}", "if    ( type . equals ( BOOLEAN )  )     {", "return   value ;", "} else", "if    ( type . equals ( TINYINT )  )     {", "return    (  ( Number )     ( value )  )  . byteValue (  )  ;", "} else", "if    ( type . equals ( SMALLINT )  )     {", "return    (  ( Number )     ( value )  )  . shortValue (  )  ;", "} else", "if    ( type . equals ( INTEGER )  )     {", "return    (  ( Number )     ( value )  )  . intValue (  )  ;", "} else", "if    ( type . equals ( BIGINT )  )     {", "return    (  ( Number )     ( value )  )  . longValue (  )  ;", "} else", "if    ( type . equals ( REAL )  )     {", "return    (  ( Number )     ( value )  )  . floatValue (  )  ;", "} else", "if    ( type . equals ( DOUBLE )  )     {", "return    (  ( Number )     ( value )  )  . doubleValue (  )  ;", "} else", "if    ( type   instanceof   spi . type . VarcharType )     {", "return   value ;", "} else", "if    ( type   instanceof   spi . type . CharType )     {", "return   new   HiveChar (  (  ( String )     ( value )  )  ,     (  ( spi . type . CharType )     ( type )  )  . getLength (  )  )  ;", "} else", "if    ( type . equals ( VARBINARY )  )     {", "return    (  ( spi . type . SqlVarbinary )     ( value )  )  . getBytes (  )  ;", "} else", "if    ( type . equals ( DATE )  )     {", "int   days    =     (  ( spi . type . SqlDate )     ( value )  )  . getDays (  )  ;", "LocalDate   localDate    =    ofEpochDay ( days )  ;", "ZonedDateTime   zonedDateTime    =    localDate . atStartOfDay ( systemDefault (  )  )  ;", "long   millis    =    toMillis ( zonedDateTime . toEpochSecond (  )  )  ;", "Date   date    =    new   Date (  0  )  ;", "date . setTime ( millis )  ;", "return   date ;", "} else", "if    ( type . equals ( TIMESTAMP )  )     {", "long   millisUtc    =     (  ( int )     (  (  ( spi . type . SqlTimestamp )     ( value )  )  . getMillisUtc (  )  )  )  ;", "return   new   Timestamp ( millisUtc )  ;", "} else", "if    ( type   instanceof   spi . type . DecimalType )     {", "return   create (  (  ( spi . type . SqlDecimal )     ( value )  )  . toBigDecimal (  )  )  ;", "} else", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( StandardTypes . ARRAY )  )     {", "Type   elementType    =    type . getTypeParameters (  )  . get (  0  )  ;", "return    (  ( List <  ?  >  )     ( value )  )  . stream (  )  . map (  (    element )     -  >    OrcTester . preprocessWriteValueHive ( elementType ,    element )  )  . collect ( toList (  )  )  ;", "} else", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( StandardTypes . MAP )  )     {", "Type   keyType    =    type . getTypeParameters (  )  . get (  0  )  ;", "Type   valueType    =    type . getTypeParameters (  )  . get (  1  )  ;", "Map < Object ,    Object >    newMap    =    new   HashMap <  >  (  )  ;", "for    ( Entry <  ?  ,     ?  >    entry    :     (  ( Map <  ?  ,     ?  >  )     ( value )  )  . entrySet (  )  )     {", "newMap . put ( OrcTester . preprocessWriteValueHive ( keyType ,    entry . getKey (  )  )  ,    OrcTester . preprocessWriteValueHive ( valueType ,    entry . getValue (  )  )  )  ;", "}", "return   newMap ;", "} else", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( StandardTypes . ROW )  )     {", "List <  ?  >    fieldValues    =     (  ( List <  ?  >  )     ( value )  )  ;", "List < Type >    fieldTypes    =    type . getTypeParameters (  )  ;", "List < Object >    newStruct    =    new   ArrayList <  >  (  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( fieldValues . size (  )  )  ;    fieldId +  +  )     {", "newStruct . add ( OrcTester . preprocessWriteValueHive ( fieldTypes . get ( fieldId )  ,    fieldValues . get ( fieldId )  )  )  ;", "}", "return   newStruct ;", "}", "throw   new   IllegalArgumentException (  (  \" unsupported   type :     \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["preprocessWriteValueHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "OrcTester   orcTester    =    new   OrcTester (  )  ;", "orcTester . structTestsEnabled    =    true ;", "orcTester . mapTestsEnabled    =    true ;", "orcTester . listTestsEnabled    =    true ;", "orcTester . nullTestsEnabled    =    true ;", "orcTester . skipBatchTestsEnabled    =    true ;", "orcTester . formats    =    ImmutableSet . of ( OrcTester . Format . ORC _  1  2  ,    OrcTester . Format . ORC _  1  1  ,    OrcTester . Format . DWRF )  ;", "orcTester . compressions    =    ImmutableSet . of ( CompressionKind . ZLIB )  ;", "return   orcTester ;", "}", "METHOD_END"], "methodName": ["quickOrcTester"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   Lists . reverse ( ImmutableList . copyOf ( iterable )  )  ;", "}", "METHOD_END"], "methodName": ["reverse"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < TypeSignatureParameter >    typeSignatureParameters    =    ImmutableList . builder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( fieldTypes . length )  ;    i +  +  )     {", "String   filedName    =     \" field _  \"     +    i ;", "Type   fieldType    =    fieldTypes [ i ]  ;", "typeSignatureParameters . add ( TypeSignatureParameter . of ( new   spi . type . NamedTypeSignature ( filedName ,    fieldType . getTypeSignature (  )  )  )  )  ;", "}", "return   OrcTester . TYPE _ MANAGER . getParameterizedType ( ROW ,    typeSignatureParameters . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["rowType"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Object   writer    =    OrcTester . getFieldValue ( recordWriter ,     \" writer \"  )  ;", "Object   memoryManager    =    OrcTester . getFieldValue ( writer ,     \" memoryManager \"  )  ;", "OrcTester . setFieldValue ( memoryManager ,     \" lowMemoryMode \"  ,    true )  ;", "try    {", "writer . getClass (  )  . getMethod (  \" enterLowMemoryMode \"  )  . invoke ( writer )  ;", "}    catch    ( Exception   e )     {", "throw   Throwables . propagate ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setDwrfLowMemoryFlag"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "try    {", "Field   wriField    =    instance . getClass (  )  . getDeclaredField ( name )  ;", "wriField . setAccessible ( true )  ;", "wriField . set ( instance ,    value )  ;", "}    catch    ( Exception   e )     {", "throw   Throwables . propagate ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["setFieldValue"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Type   arrayType    =    OrcTester . arrayType ( type )  ;", "testRoundTripType ( arrayType ,    readValues . stream (  )  . map ( OrcTester :  : toHiveList )  . collect ( Collectors . toList (  )  )  )  ;", "if    ( structuralNullTestsEnabled )     {", "testRoundTripType ( arrayType ,    OrcTester . insertNullEvery (  5  ,    readValues )  . stream (  )  . map ( OrcTester :  : toHiveList )  . collect ( Collectors . toList (  )  )  )  ;", "testRoundTripType ( arrayType ,    readValues . stream (  )  . map (  (    value )     -  >    OrcTester . toHiveList ( null )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testListRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Type   mapType    =    OrcTester . mapType ( type ,    type )  ;", "Object   readNullKeyValue    =    Iterables . getLast ( readValues )  ;", "testRoundTripType ( mapType ,    readValues . stream (  )  . map (  (    value )     -  >    OrcTester . toHiveMap ( value ,    readNullKeyValue )  )  . collect ( Collectors . toList (  )  )  )  ;", "if    ( structuralNullTestsEnabled )     {", "testRoundTripType ( mapType ,    OrcTester . insertNullEvery (  5  ,    readValues )  . stream (  )  . map (  (    value )     -  >    OrcTester . toHiveMap ( value ,    readNullKeyValue )  )  . collect ( Collectors . toList (  )  )  )  ;", "testRoundTripType ( mapType ,    readValues . stream (  )  . map (  (    value )     -  >    OrcTester . toHiveMap ( null ,    readNullKeyValue )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMapRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "testRoundTripType ( type ,    readValues )  ;", "if    ( nullTestsEnabled )     {", "assertRoundTrip ( type ,    readValues . stream (  )  . map (  (    value )     -  >    null )  . collect ( Collectors . toList (  )  )  )  ;", "}", "if    ( structTestsEnabled )     {", "testStructRoundTrip ( type ,    readValues )  ;", "}", "if    ( complexStructuralTestsEnabled )     {", "testStructRoundTrip (  . rowType ( type ,    type ,    type )  ,    readValues . stream (  )  . map (  :  : toHiveStruct )  . collect ( Collectors . toList (  )  )  )  ;", "}", "if    (  ( mapTestsEnabled )     &  &     ( type . isComparable (  )  )  )     {", "testMapRoundTrip ( type ,    readValues )  ;", "}", "if    ( listTestsEnabled )     {", "testListRoundTrip ( type ,    readValues )  ;", "}", "if    ( complexStructuralTestsEnabled )     {", "testListRoundTrip (  . arrayType ( type )  ,    readValues . stream (  )  . map (  :  : toHiveList )  . collect ( Collectors . toList (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "assertRoundTrip ( type ,    readValues )  ;", "if    ( reverseTestsEnabled )     {", "assertRoundTrip ( type ,     . reverse ( readValues )  )  ;", "}", "if    ( nullTestsEnabled )     {", "assertRoundTrip ( type ,     . insertNullEvery (  5  ,    readValues )  )  ;", "if    ( reverseTestsEnabled )     {", "assertRoundTrip ( type ,     . insertNullEvery (  5  ,     . reverse ( readValues )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testRoundTripType"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Type   rowType    =    OrcTester . rowType ( type ,    type ,    type )  ;", "testRoundTripType ( rowType ,    readValues . stream (  )  . map ( OrcTester :  : toHiveStruct )  . collect ( Collectors . toList (  )  )  )  ;", "if    ( structuralNullTestsEnabled )     {", "testRoundTripType ( rowType ,    OrcTester . insertNullEvery (  5  ,    readValues )  . stream (  )  . map ( OrcTester :  : toHiveStruct )  . collect ( Collectors . toList (  )  )  )  ;", "testRoundTripType ( rowType ,    readValues . stream (  )  . map (  (    value )     -  >    OrcTester . toHiveStruct ( null )  )  . collect ( Collectors . toList (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testStructRoundTrip"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( input ,    input ,    input ,    input )  ;", "}", "METHOD_END"], "methodName": ["toHiveList"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "M < Object ,    Object >    m    =    new   HashM <  >  (  )  ;", "mut (  ( iut    !  =    null    ?    iut    :    nullKeyValue )  ,    iut )  ;", "return   m ;", "}", "METHOD_END"], "methodName": ["toHiveMap"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( input ,    input ,    input )  ;", "}", "METHOD_END"], "methodName": ["toHiveStruct"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "RecordWriter   recordWriter ;", "if    (  (  . Format . DWRF )     =  =    format )     {", "recordWriter    =     . createDwrfRecordWriter ( outputFile ,    compression ,    type )  ;", "} else    {", "recordWriter    =     . createOrcRecordWriter ( outputFile ,    format ,    compression ,    type )  ;", "}", "return    . writeOrcFileColumnHive ( outputFile ,    format ,    recordWriter ,    type ,    values )  ;", "}", "METHOD_END"], "methodName": ["writeOrcColumnHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    String >    metadata    =    ImmutableMap . builder (  )  ;", "metadata . put (  \" columns \"  ,     \" test \"  )  ;", "metadata . put (  \" columns . types \"  ,    OrcTester . createSettableStructObjectInspector (  \" test \"  ,    type )  . getTypeName (  )  )  ;", "OrcWriter   writer ;", "writer    =    new   OrcWriter ( new   FileOutputStream ( outputFile )  ,    ImmutableList . of (  \" test \"  )  ,    ImmutableList . of ( type )  ,    format . getOrcEncoding (  )  ,    compression ,    new   OrcWriterOptions (  )  ,    ImmutableMap . of (  )  ,    OrcTester . HIVE _ STORAGE _ TIME _ ZONE ,    true ,    stats )  ;", "BlockBuilder   blockBuilder    =    type . createBlockBuilder ( null ,     1  0  2  4  )  ;", "while    ( values . hasNext (  )  )     {", "Object   value    =    values . next (  )  ;", "OrcTester . writeValue ( type ,    blockBuilder ,    value )  ;", "}", "writer . write ( new   spi . Page ( blockBuilder . build (  )  )  )  ;", "writer . close (  )  ;", "writer . validate ( new   FileOrcDataSource ( outputFile ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["writeOrcColumnPresto"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "SettableStructObjectInspector   objectInspector    =    OrcTester . createSettableStructObjectInspector (  \" test \"  ,    type )  ;", "Object   row    =    objectInspector . create (  )  ;", "List < StructField >    fields    =    ImmutableList . copyOf ( objectInspector . getAllStructFieldRefs (  )  )  ;", "@ SuppressWarnings (  \" deprecation \"  )", "Serializer   serializer    =    format . createSerializer (  )  ;", "int   i    =     0  ;", "while    ( values . hasNext (  )  )     {", "Object   value    =    values . next (  )  ;", "value    =    OrcTester . preprocessWriteValueHive ( type ,    value )  ;", "objectInspector . setStructFieldData ( row ,    fields . get (  0  )  ,    value )  ;", "if    (  ( OrcTester . Format . DWRF )     =  =    format )     {", "if    ( i    =  =     1  4  2  3  4  5  )     {", "OrcTester . setDwrfLowMemoryFlag ( recordWriter )  ;", "}", "}", "Writable   record    =    serializer . serialize ( row ,    objectInspector )  ;", "recordWriter . write ( record )  ;", "i +  +  ;", "}", "recordWriter . close ( false )  ;", "return   DataSize . succinctBytes ( outputFile . length (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeOrcFileColumnHive"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "blockBuilder . appendNull (  )  ;", "} else    {", "if    ( BOOLEAN . equals ( type )  )     {", "type . writeBoolean ( blockBuilder ,     (  ( Boolean )     ( value )  )  )  ;", "} else", "if    (  (  (  ( TINYINT . equals ( type )  )     |  |     ( SMALLINT . equals ( type )  )  )     |  |     ( INTEGER . equals ( type )  )  )     |  |     ( BIGINT . equals ( type )  )  )     {", "type . writeLong ( blockBuilder ,     (  ( Number )     ( value )  )  . longValue (  )  )  ;", "} else", "if    ( spi . type . Decimals . isShortDecimal ( type )  )     {", "type . writeLong ( blockBuilder ,     (  ( spi . type . SqlDecimal )     ( value )  )  . toBigDecimal (  )  . unscaledValue (  )  . longValue (  )  )  ;", "} else", "if    ( spi . type . Decimals . isLongDecimal ( type )  )     {", "type . writeSlice ( blockBuilder ,    spi . type . Decimals . encodeUnscaledValue (  (  ( spi . type . SqlDecimal )     ( value )  )  . toBigDecimal (  )  . unscaledValue (  )  )  )  ;", "} else", "if    ( DOUBLE . equals ( type )  )     {", "type . writeDouble ( blockBuilder ,     (  ( Number )     ( value )  )  . doubleValue (  )  )  ;", "} else", "if    ( REAL . equals ( type )  )     {", "float   floatValue    =     (  ( Number )     ( value )  )  . floatValue (  )  ;", "type . writeLong ( blockBuilder ,    Float . floatToIntBits ( floatValue )  )  ;", "} else", "if    ( type   instanceof   spi . type . VarcharType )     {", "io . airlift . slice . Slice   slice    =    truncateToLength ( utf 8 Slice (  (  ( String )     ( value )  )  )  ,    type )  ;", "type . writeSlice ( blockBuilder ,    slice )  ;", "} else", "if    ( type   instanceof   spi . type . CharType )     {", "io . airlift . slice . Slice   slice    =    truncateToLengthAndTrimSpaces ( utf 8 Slice (  (  ( String )     ( value )  )  )  ,    type )  ;", "type . writeSlice ( blockBuilder ,    slice )  ;", "} else", "if    ( VARBINARY . equals ( type )  )     {", "type . writeSlice ( blockBuilder ,    io . airlift . slice . Slices . wrappedBuffer (  (  ( spi . type . SqlVarbinary )     ( value )  )  . getBytes (  )  )  )  ;", "} else", "if    ( DATE . equals ( type )  )     {", "long   days    =     (  ( spi . type . SqlDate )     ( value )  )  . getDays (  )  ;", "type . writeLong ( blockBuilder ,    days )  ;", "} else", "if    ( TIMESTAMP . equals ( type )  )     {", "long   millis    =     (  ( spi . type . SqlTimestamp )     ( value )  )  . getMillisUtc (  )  ;", "type . writeLong ( blockBuilder ,    millis )  ;", "} else    {", "String   baseType    =    type . getTypeSignature (  )  . getBase (  )  ;", "if    ( StandardTypes . ARRAY . equals ( baseType )  )     {", "List <  ?  >    array    =     (  ( List <  ?  >  )     ( value )  )  ;", "Type   elementType    =    type . getTypeParameters (  )  . get (  0  )  ;", "BlockBuilder   arrayBlockBuilder    =    blockBuilder . beginBlockEntry (  )  ;", "for    ( Object   elementValue    :    array )     {", "OrcTester . writeValue ( elementType ,    arrayBlockBuilder ,    elementValue )  ;", "}", "blockBuilder . closeEntry (  )  ;", "} else", "if    ( StandardTypes . MAP . equals ( baseType )  )     {", "Map <  ?  ,     ?  >    map    =     (  ( Map <  ?  ,     ?  >  )     ( value )  )  ;", "Type   keyType    =    type . getTypeParameters (  )  . get (  0  )  ;", "Type   valueType    =    type . getTypeParameters (  )  . get (  1  )  ;", "BlockBuilder   mapBlockBuilder    =    blockBuilder . beginBlockEntry (  )  ;", "for    ( Entry <  ?  ,     ?  >    entry    :    map . entrySet (  )  )     {", "OrcTester . writeValue ( keyType ,    mapBlockBuilder ,    entry . getKey (  )  )  ;", "OrcTester . writeValue ( valueType ,    mapBlockBuilder ,    entry . getValue (  )  )  ;", "}", "blockBuilder . closeEntry (  )  ;", "} else", "if    ( StandardTypes . ROW . equals ( baseType )  )     {", "List <  ?  >    array    =     (  ( List <  ?  >  )     ( value )  )  ;", "List < Type >    fieldTypes    =    type . getTypeParameters (  )  ;", "BlockBuilder   rowBlockBuilder    =    blockBuilder . beginBlockEntry (  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( fieldTypes . size (  )  )  ;    fieldId +  +  )     {", "Type   fieldType    =    fieldTypes . get ( fieldId )  ;", "OrcTester . writeValue ( fieldType ,    rowBlockBuilder ,    array . get ( fieldId )  )  ;", "}", "blockBuilder . closeEntry (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   type    \"     +    type )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["writeValue"], "fileName": "com.facebook.presto.orc.OrcTester"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( readColumns ,     \" readColumns   is   null \"  )  ;", "checkArgument (  (  !  ( readColumns . isEmpty (  )  )  )  ,     \" readColumns   is   empty \"  )  ;", "int   columnCount    =     ( readColumns . keySet (  )  . stream (  )  . mapToInt ( Integer :  : intValue )  . max (  )  . getAsInt (  )  )     +     1  ;", "checkArgument (  (  ( readColumns . size (  )  )     =  =    columnCount )  ,     \" statistics   validation   requires   all   columns   to   be   read \"  )  ;", "ImmutableList . Builder < Type >    types    =    ImmutableList . builder (  )  ;", "for    ( int   column    =     0  ;    column    <    columnCount ;    column +  +  )     {", "Type   type    =    readColumns . get ( column )  ;", "checkArgument (  ( type    !  =    null )  ,     \" statistics   validation   requires   all   columns   to   be   read \"  )  ;", "types . add ( type )  ;", "}", "return   new    . StatisticsValidation ( types . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createWriteStatisticsBuilder"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   checksum ;", "}", "METHOD_END"], "methodName": ["getChecksum"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   columnNames ;", "}", "METHOD_END"], "methodName": ["getColumnNames"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   compression ;", "}", "METHOD_END"], "methodName": ["getCompression"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   metadata ;", "}", "METHOD_END"], "methodName": ["getMetadata"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   rowGroupMaxRowCount ;", "}", "METHOD_END"], "methodName": ["getRowGroupMaxRowCount"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( name ,     \" name   is   null \"  )  ;", "Objects . requireNonNull ( actualColumnStatistics ,     \" actualColumnStatistics   is   null \"  )  ;", "Objects . requireNonNull ( expectedColumnStatistics ,     \" expectedColumnStatistics   is   null \"  )  ;", "if    (  ( actualColumnStatistics . getNumberOfValues (  )  )     !  =     ( expectedColumnStatistics . getNumberOfValues (  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   number   of   values   in    % s   statistics \"  ,    name )  ;", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getBooleanStatistics (  )  ,    expectedColumnStatistics . getBooleanStatistics (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   boolean   counts   in    % s   statistics \"  ,    name )  ;", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getIntegerStatistics (  )  ,    expectedColumnStatistics . getIntegerStatistics (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   integer   range   in    % s   statistics \"  ,    name )  ;", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getDoubleStatistics (  )  ,    expectedColumnStatistics . getDoubleStatistics (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   double   range   in    % s   statistics \"  ,    name )  ;", "}", "StringStatistics   expectedStringStatistics    =    expectedColumnStatistics . getStringStatistics (  )  ;", "if    ( expectedStringStatistics    !  =    null )     {", "expectedStringStatistics    =    new   StringStatistics ( OrcMetadataReader . minStringTruncateToValidRange ( expectedStringStatistics . getMin (  )  ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ,    OrcMetadataReader . maxStringTruncateToValidRange ( expectedStringStatistics . getMax (  )  ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ,    expectedStringStatistics . getSum (  )  )  ;", "}", "StringStatistics   actualStringStatistics    =    actualColumnStatistics . getStringStatistics (  )  ;", "if    (  (  !  ( Objects . equals ( actualColumnStatistics . getStringStatistics (  )  ,    expectedStringStatistics )  )  )     &  &     ( expectedStringStatistics    !  =    null )  )     {", "if    (  (  (  ( actualStringStatistics    =  =    null )     |  |     (  ( actualStringStatistics . getSum (  )  )     !  =     ( expectedStringStatistics . getSum (  )  )  )  )     |  |     (  (  ( expectedStringStatistics . getMax (  )  )     !  =    null )     &  &     (  !  ( Objects . equals ( actualStringStatistics . getMax (  )  ,    expectedStringStatistics . getMax (  )  )  )  )  )  )     |  |     (  (  ( expectedStringStatistics . getMin (  )  )     !  =    null )     &  &     (  !  ( Objects . equals ( actualStringStatistics . getMin (  )  ,    expectedStringStatistics . getMin (  )  )  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   string   range   in    % s   statistics \"  ,    name )  ;", "}", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getDateStatistics (  )  ,    expectedColumnStatistics . getDateStatistics (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   date   range   in    % s   statistics \"  ,    name )  ;", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getDecimalStatistics (  )  ,    expectedColumnStatistics . getDecimalStatistics (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   decimal   range   in    % s   statistics \"  ,    name )  ;", "}", "if    (  !  ( Objects . equals ( actualColumnStatistics . getBloomFilter (  )  ,    expectedColumnStatistics . getBloomFilter (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   bloom   filter   in    % s   statistics \"  ,    name )  ;", "}", "}", "METHOD_END"], "methodName": ["validateColumnStatisticsEquivalent"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( name ,     \" name   is   null \"  )  ;", "Objects . requireNonNull ( actualColumnStatistics ,     \" actualColumnStatistics   is   null \"  )  ;", "Objects . requireNonNull ( expectedColumnStatistics ,     \" expectedColumnStatistics   is   null \"  )  ;", "if    (  ( actualColumnStatistics . size (  )  )     !  =     ( expectedColumnStatistics . size (  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   validation   failed :    unexpected   number   of   columns   in    % s   statistics \"  ,    name )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( actualColumnStatistics . size (  )  )  ;    i +  +  )     {", "ColumnStatistics   actual    =    actualColumnStatistics . get ( i )  ;", "ColumnStatistics   expected    =    expectedColumnStatistics . get ( i )  ;", ". validateColumnStatisticsEquivalent ( orcDataSourceId ,     (  ( name    +     \"    column    \"  )     +    i )  ,    actual ,    expected )  ;", "}", "}", "METHOD_END"], "methodName": ["validateColumnStatisticsEquivalent"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "if    ( actualFileStatistics . isEmpty (  )  )     {", "return ;", "}", ". validateColumnStatisticsEquivalent ( orcDataSourceId ,     \" file \"  ,    actualFileStatistics ,    fileStatistics )  ;", "}", "METHOD_END"], "methodName": ["validateFileStatistics"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Slice >    filteredMetadata    =    actualMetadata . entrySet (  )  . stream (  )  . filter (  (    entry )     -  >     !  ( STATIC _ METADATA . containsKey ( entry . getKey (  )  )  )  )  . collect ( toImmutableMap ( Map . Entry :  : getKey ,    Map . Entry :  : getValue )  )  ;", "if    (  !  ( metadata . equals ( filteredMetadata )  )  )     {", "throw   new   OrcCorrupExcep ( orcDataSourceId ,     \" Unexpected   metadata \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateMetadata"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "List < OrcWriteValidation . RowGroupStatistics >    rowGroups    =    rowGroupStatistics . get ( stripeOffset )  ;", "if    ( rowGroups    =  =    null )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   stripe   at   offset    % s \"  ,    stripeOffset )  ;", "}", "if    (  ( rowGroups . size (  )  )     <  =    rowGroupIndex )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   row   group    % s   in   stripe   at   offset    % s \"  ,    rowGroupIndex ,    stripeOffset )  ;", "}", "Map < Integer ,    ColumnStatistics >    expectedByColumnIndex    =    rowGroups . get ( rowGroupIndex )  . getColumnStatistics (  )  ;", "List < ColumnStatistics >    expected    =    IntStream . range (  1  ,    actual . size (  )  )  . mapToObj ( expectedByColumnIndex :  : get )  . collect ( toImmutableList (  )  )  ;", "actual    =    actual . subList (  1  ,    actual . size (  )  )  ;", "OrcWriteValidation . validateColumnStatisticsEquivalent ( orcDataSourceId ,     (  (  (  \" Row   group    \"     +    rowGroupIndex )     +     \"    in   stripe   at   offset    \"  )     +    stripeOffset )  ,    actual ,    expected )  ;", "}", "METHOD_END"], "methodName": ["validateRowGroupStatistics"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( actualRowGroupStatistics ,     \" actualRowGroupStatistics   is   null \"  )  ;", "List <  . RowGroupStatistics >    expectedRowGroupStatistics    =    rowGroupStatistics . get ( stripeOffset )  ;", "if    ( expectedRowGroupStatistics    =  =    null )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   stripe   at   offset    % s \"  ,    stripeOffset )  ;", "}", "int   rowGroupCount    =    expectedRowGroupStatistics . size (  )  ;", "for    ( Map . Entry < Integer ,    List < RowGroupIndex >  >    entry    :    actualRowGroupStatistics . entrySet (  )  )     {", "if    (  ( entry . getValue (  )  . size (  )  )     !  =    rowGroupCount )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   row   group   count   stripe   in   at   offset    % s \"  ,    stripeOffset )  ;", "}", "}", "for    ( int   rowGroupIndex    =     0  ;    rowGroupIndex    <     ( expectedRowGroupStatistics . size (  )  )  ;    rowGroupIndex +  +  )     {", "Map < Integer ,    ColumnStatistics >    expectedStatistics    =    expectedRowGroupStatistics . get ( rowGroupIndex )  . getColumnStatistics (  )  ;", "if    (  !  ( expectedStatistics . keySet (  )  . equals ( actualRowGroupStatistics . keySet (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   column   in   row   group    % s   in   stripe   at   offset    % s \"  ,    stripeOffset )  ;", "}", "for    ( Map . Entry < Integer ,    ColumnStatistics >    entry    :    expectedStatistics . entrySet (  )  )     {", "int   columnIndex    =    entry . getKey (  )  ;", "ColumnStatistics   actual    =    actualRowGroupStatistics . get ( columnIndex )  . get ( rowGroupIndex )  . getColumnStatistics (  )  ;", "ColumnStatistics   expected    =    entry . getValue (  )  ;", ". validateColumnStatisticsEquivalent ( orcDataSourceId ,     (  (  (  \" Row   group    \"     +    rowGroupIndex )     +     \"    in   stripe   at   offset    \"  )     +    stripeOffset )  ,    actual ,    expected )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateRowGroupStatistics"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( actualStripes ,     \" actualStripes   is   null \"  )  ;", "Objects . requireNonNull ( actualStripeStatistics ,     \" actualStripeStatistics   is   null \"  )  ;", "if    ( actualStripeStatistics . isEmpty (  )  )     {", "return ;", "}", "if    (  ( actualStripeStatistics . size (  )  )     !  =     ( stripeStatistics . size (  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Write   v   failed :    unexpected   number   of   columns   in   stripe   statistics \"  )  ;", "}", "for    ( int   stripeIndex    =     0  ;    stripeIndex    <     ( actualStripes . size (  )  )  ;    stripeIndex +  +  )     {", "long   stripeOffset    =    actualStripes . get ( stripeIndex )  . getOffset (  )  ;", "StripeStatistics   actual    =    actualStripeStatistics . get ( stripeIndex )  ;", "validateStripeStatistics ( orcDataSourceId ,    stripeOffset ,    actual . getColumnStatistics (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateStripeStatistics"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "StripeStatistics   expected    =    stripeStatistics . get ( stripeOffset )  ;", "if    ( expected    =  =    null )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   stripe   at   offset    % s \"  ,    stripeOffset )  ;", "}", ". validateColumnStatisticsEquivalent ( orcDataSourceId ,     (  \" Stripe   at    \"     +    stripeOffset )  ,    actual ,    expected . getColumnStatistics (  )  )  ;", "}", "METHOD_END"], "methodName": ["validateStripeStatistics"], "fileName": "com.facebook.presto.orc.OrcWriteValidation"}, {"methodBody": ["METHOD_START", "{", "Map < Integer ,    ColumnStatistics >    columnStatistics    =    new   HashMap <  >  (  )  ;", "columns . forEach (  (    column )     -  >    columnStatistics . putAll ( column . finishRowGroup (  )  )  )  ;", "recordValidation (  (    validation )     -  >    validation . addRowGroupStatistics ( columnStatistics )  )  ;", "if    (  ( validationBuilder )     !  =    null )     {", "for    ( Map . Entry < Integer ,    ColumnStatistics >    statistics    :    columnStatistics . entrySet (  )  )     {", "checkState (  (  ( statistics . getValue (  )  )     !  =    null )  )  ;", "validatorRetainedBytes    +  =     ( Integer . BYTES )     +     ( statistics . getValue (  )  . getRetainedSizeInBytes (  )  )  ;", "}", "}", "rowGroupRowCount    =     0  ;", "}", "METHOD_END"], "methodName": ["finishRowGroup"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "return   bufferedBytes ;", "}", "METHOD_END"], "methodName": ["getBufferedBytes"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( OrcWriter . INSTANCE _ SIZE )     +     ( columnWritersRetainedBytes )  )     +     ( closedStripesRetainedBytes )  )     +     ( validatorRetainedBytes )  ;", "}", "METHOD_END"], "methodName": ["getRetainedBytes"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( validationBuilder )     !  =    null )     {", "task . accept ( validationBuilder )  ;", "}", "}", "METHOD_END"], "methodName": ["recordValidation"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  ( data . size (  )  )     =  =    expectedSize )  )  ;", "ArrayList < T >    list    =    new   ArrayList <  >  ( expectedSize )  ;", "for    ( int   i    =     0  ;    i    <    expectedSize ;    i +  +  )     {", "list . add ( data . get ( i )  )  ;", "}", "return   ImmutableList . copyOf ( list )  ;", "}", "METHOD_END"], "methodName": ["toDenseList"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( stripes . isEmpty (  )  )     {", "return   ImmutableList . of (  )  ;", "}", "int   columnCount    =    stripes . get (  0  )  . size (  )  ;", "checkArgument ( stripes . stream (  )  . allMatch (  (    stripe )     -  >    columnCount    =  =     ( stripe . size (  )  )  )  )  ;", "ImmutableList . Builder < ColumnStatistics >    fileStats    =    ImmutableList . builder (  )  ;", "for    ( int   i    =     0  ;    i    <    columnCount ;    i +  +  )     {", "int   column    =    i ;", "fileStats . add ( ColumnStatistics . mergeColumnStatistics ( stripes . stream (  )  . map (  (    stripe )     -  >    stripe . get ( column )  )  . collect ( Collectors . toList (  )  )  )  )  ;", "}", "return   fileStats . build (  )  ;", "}", "METHOD_END"], "methodName": ["toFileStats"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  ( validationBuilder )     !  =    null )  ,     \" validation   is   not   enabled \"  )  ;", "OrcReader . validateFile ( validationBuilder . build (  )  ,    input ,    types ,    hiveStorageTimeZone ,    Encoding )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( page ,     \" page   is   null \"  )  ;", "if    (  ( page . getPositionCount (  )  )     =  =     0  )     {", "return ;", "}", "checkArgument (  (  ( page . getChannelCount (  )  )     =  =     ( columns . size (  )  )  )  )  ;", "if    (  ( validationBuilder )     !  =    null )     {", "validationBuilder . addPage ( page )  ;", "}", "while    ( page    !  =    null )     {", "Page   chunk ;", "if    (  (  (  ( rowGroupRowCount )     +     ( page . getPositionCount (  )  )  )     >     ( rowGroupMaxRowCount )  )     |  |     (  (  ( stripeRowCount )     +     ( page . getPositionCount (  )  )  )     >     ( stripeMaxRowCount )  )  )     {", "int   chunkRows    =    Integer . min (  (  ( rowGroupMaxRowCount )     -     ( rowGroupRowCount )  )  ,     (  ( stripeMaxRowCount )     -     ( stripeRowCount )  )  )  ;", "chunk    =    page . getRegion (  0  ,    chunkRows )  ;", "page    =    page . getRegion ( chunkRows ,     (  ( page . getPositionCount (  )  )     -    chunkRows )  )  ;", "} else    {", "chunk    =    page ;", "page    =    null ;", "}", "writeChunk ( chunk )  ;", "}", "long   recordedSizeInBytes    =    getRetainedBytes (  )  ;", "stats . updateSizeInBytes (  ( recordedSizeInBytes    -     ( previouslyRecordedSizeInBytes )  )  )  ;", "previouslyRecordedSizeInBytes    =    recordedSizeInBytes ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rowGroupRowCount )     =  =     0  )     {", "columnWriters . forEach ( ColumnWriter :  : beginRowGroup )  ;", "}", "bufferedBytes    =     0  ;", "for    ( int   channel    =     0  ;    channel    <     ( chunk . getChannelCount (  )  )  ;    channel +  +  )     {", "ColumnWriter   writer    =    columnWriters . get ( channel )  ;", "writer . writeBlock ( chunk . getBlock ( channel )  )  ;", "bufferedBytes    +  =    writer . getBufferedBytes (  )  ;", "}", "rowGroupRowCount    +  =    chunk . getPositionCount (  )  ;", "checkState (  (  ( rowGroupRowCount )     <  =     ( rowGroupMaxRowCount )  )  )  ;", "stripeRowCount    +  =    chunk . getPositionCount (  )  ;", "if    (  ( rowGroupRowCount )     =  =     ( rowGroupMaxRowCount )  )     {", "finishRowGroup (  )  ;", "}", "dictionaryCompressionOptimizer . optimize ( bufferedBytes ,    stripeRowCount )  ;", "bufferedBytes    =    Math . toIntExact ( columnWriters . stream (  )  . mapToLong ( ColumnWriter :  : getBufferedBytes )  . sum (  )  )  ;", "if    (  ( stripeRowCount )     =  =     ( stripeMaxRowCount )  )     {", "writeStripe ( Stats . FlushReason . MAX _ ROWS )  ;", "} else", "if    (  (  ( bufferedBytes )     +     ( dictionaryCompressionOptimizer . getDictionaryMemoryBytes (  )  )  )     >     ( stripeMaxBytes )  )     {", "writeStripe ( Stats . FlushReason . MAX _ BYTES )  ;", "} else", "if    ( dictionaryCompressionOptimizer . isFull (  )  )     {", "writeStripe ( Stats . FlushReason . DICTIONARY _ FULL )  ;", "}", "columnWritersRetainedBytes    =    Math . toIntExact ( columnWriters . stream (  )  . mapToLong ( ColumnWriter :  : getRetainedBytes )  . sum (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeChunk"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stripeRowCount )     =  =     0  )     {", "return ;", "}", "recordValidation (  (    validation )     -  >    validation . addStripe ( stripeRowCount )  )  ;", "if    (  ( rowGroupRowCount )     >     0  )     {", "finishRowGroup (  )  ;", "}", "dictionaryCompressionOptimizer . finalOptimize (  )  ;", "columnWriters . forEach ( ColumnWriter :  : close )  ;", "List < Stream >    allStreams    =    new   ArrayList <  >  (  )  ;", "long   indexLength    =     0  ;", "for    ( ColumnWriter   columnWriter    :    columnWriters )     {", "List < Stream >    indexStreams    =    columnWriter . writeIndexStreams ( output ,    metadataWriter )  ;", "allStreams . addAll ( indexStreams )  ;", "indexLength    +  =    indexStreams . stream (  )  . mapToInt ( Stream :  : getLength )  . asLongStream (  )  . sum (  )  ;", "}", "List < OutputDataStream >    outputDataStreams    =    new   ArrayList <  >  (  (  ( columnWriters . size (  )  )     *     2  )  )  ;", "for    ( ColumnWriter   columnWriter    :    columnWriters )     {", "outputDataStreams . addAll ( columnWriter . getOutputDataStreams (  )  )  ;", "}", "Collections . sort ( outputDataStreams )  ;", "long   dataLength    =     0  ;", "for    ( OutputDataStream   outputDataStream    :    outputDataStreams )     {", "Optional < Stream >    stream    =    outputDataStream . writeData ( output )  ;", "if    (  !  ( stream . isPresent (  )  )  )     {", "continue ;", "}", "allStreams . add ( stream . get (  )  )  ;", "dataLength    +  =    stream . get (  )  . getLength (  )  ;", "}", "Map < Integer ,    ColumnEncoding >    columnEncodings    =    new   HashMap <  >  (  )  ;", "columnWriters . forEach (  (    columnWriter )     -  >    columnEncodings . putAll ( columnWriter . getColumnEncodings (  )  )  )  ;", "Map < Integer ,    ColumnStatistics >    columnStatistics    =    new   HashMap <  >  (  )  ;", "columnWriters . forEach (  (    columnWriter )     -  >    columnStatistics . putAll ( columnWriter . getColumnStripeStatistics (  )  )  )  ;", "columnEncodings . put (  0  ,    new   ColumnEncoding ( ColumnEncoding . ColumnEncodingKind . DIRECT ,     0  )  )  ;", "columnStatistics . put (  0  ,    new   ColumnStatistics (  (  ( long )     ( stripeRowCount )  )  ,     0  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  )  ;", "StripeFooter   stripeFooter    =    new   StripeFooter ( allStreams ,     . toDenseList ( columnEncodings ,    orcTypes . size (  )  )  )  ;", "int   footerLength    =    metadataWriter . writeStripeFooter ( output ,    stripeFooter )  ;", "StripeStatistics   statistics    =    new   StripeStatistics (  . toDenseList ( columnStatistics ,    orcTypes . size (  )  )  )  ;", "recordValidation (  (    validation )     -  >    validation . addStripeStatistics ( stripeStartOffset ,    statistics )  )  ;", "StripeInformation   stripeInformation    =    new   StripeInformation ( stripeRowCount ,    stripeStartOffset ,    indexLength ,    dataLength ,    footerLength )  ;", ". ClosedStripe   closedStripe    =    new    . ClosedStripe ( stripeInformation ,    statistics )  ;", "closedStripes . add ( closedStripe )  ;", "closedStripesRetainedBytes    +  =    closedStripe . getRetainedSizeInBytes (  )  ;", "stats . recordStripeWritten ( flushReason ,    stripeInformation . getTotalLength (  )  ,    stripeInformation . getNumberOfRows (  )  ,    dictionaryCompressionOptimizer . getDictionaryMemoryBytes (  )  )  ;", "columnWriters . forEach ( ColumnWriter :  : reset )  ;", "dictionaryCompressionOptimizer . reset (  )  ;", "rowGroupRowCount    =     0  ;", "stripeRowCount    =     0  ;", "stripeStartOffset    =    output . longSize (  )  ;", "bufferedBytes    =    Math . toIntExact ( columnWriters . stream (  )  . mapToLong ( ColumnWriter :  : getBufferedBytes )  . sum (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeStripe"], "fileName": "com.facebook.presto.orc.OrcWriter"}, {"methodBody": ["METHOD_START", "{", "return   dictionaryBytes ;", "}", "METHOD_END"], "methodName": ["getDictionaryBytes"], "fileName": "com.facebook.presto.orc.OrcWriterFlushStats"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.facebook.presto.orc.OrcWriterFlushStats"}, {"methodBody": ["METHOD_START", "{", "return   stripeBytes ;", "}", "METHOD_END"], "methodName": ["getStripeBytes"], "fileName": "com.facebook.presto.orc.OrcWriterFlushStats"}, {"methodBody": ["METHOD_START", "{", "return   stripeRows ;", "}", "METHOD_END"], "methodName": ["getStripeRows"], "fileName": "com.facebook.presto.orc.OrcWriterFlushStats"}, {"methodBody": ["METHOD_START", "{", "this . stripeBytes . add ( stripeBytes )  ;", "this . stripeRows . add ( stripeRows )  ;", "this . dictionaryBytes . add ( dictionaryBytes )  ;", "}", "METHOD_END"], "methodName": ["recordStripeWritten"], "fileName": "com.facebook.presto.orc.OrcWriterFlushStats"}, {"methodBody": ["METHOD_START", "{", "return   dictionaryMaxMemory ;", "}", "METHOD_END"], "methodName": ["getDictionaryMaxMemory"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   maxCompressionBufferSize ;", "}", "METHOD_END"], "methodName": ["getMaxCompressionBufferSize"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   maxStringStatisticsLimit ;", "}", "METHOD_END"], "methodName": ["getMaxStringStatisticsLimit"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   rowGroupMaxRowCount ;", "}", "METHOD_END"], "methodName": ["getRowGroupMaxRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   stripeMaxRowCount ;", "}", "METHOD_END"], "methodName": ["getStripeMaxRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   stripeMaxSize ;", "}", "METHOD_END"], "methodName": ["getStripeMaxSize"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   stripeMinRowCount ;", "}", "METHOD_END"], "methodName": ["getStripeMinRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withDictionaryMaxMemory"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withMaxCompressionBufferSize"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withMaxStringStatisticsLimit"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withRowGroupMaxRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withStripeMaxRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withStripeMaxSize"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcWriterOptions ( stripeMaxSize ,    stripeMinRowCount ,    stripeMaxRowCount ,    rowGroupMaxRowCount ,    dictionaryMaxMemory ,    maxStringStatisticsLimit ,    maxCompressionBufferSize )  ;", "}", "METHOD_END"], "methodName": ["withStripeMinRowCount"], "fileName": "com.facebook.presto.orc.OrcWriterOptions"}, {"methodBody": ["METHOD_START", "{", "return   allFlush ;", "}", "METHOD_END"], "methodName": ["getAllFlush"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   closedFlush ;", "}", "METHOD_END"], "methodName": ["getClosedFlush"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   dictionaryFullFlush ;", "}", "METHOD_END"], "methodName": ["getDictionaryFullFlush"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "switch    ( flushReason )     {", "case   MAX _ ROWS    :", "return   maxRowsFlush ;", "case   MAX _ BYTES    :", "return   maxBytesFlush ;", "case   DICTIONARY _ FULL    :", "return   dictionaryFullFlush ;", "case   CLOSED    :", "return   closedFlush ;", "default    :", "throw   new   IllegalArgumentException (  (  \" unknown   flush   reason    \"     +    flushReason )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFlushStats"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   maxBytesFlush ;", "}", "METHOD_END"], "methodName": ["getMaxBytesFlush"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   maxRowsFlush ;", "}", "METHOD_END"], "methodName": ["getMaxRowsFlush"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   writerSizeInBytes . get (  )  ;", "}", "METHOD_END"], "methodName": ["getWriterSizeInBytes"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "getFlushStats ( flushReason )  . recordStripeWritten ( stripeBytes ,    stripeRows ,    dictionaryBytes )  ;", "allFlush . recordStripeWritten ( stripeBytes ,    stripeRows ,    dictionaryBytes )  ;", "}", "METHOD_END"], "methodName": ["recordStripeWritten"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "writerSizeInBytes . addAndGet ( deltaInBytes )  ;", "}", "METHOD_END"], "methodName": ["updateSizeInBytes"], "fileName": "com.facebook.presto.orc.OrcWriterStats"}, {"methodBody": ["METHOD_START", "{", "return   groupId ;", "}", "METHOD_END"], "methodName": ["getGroupId"], "fileName": "com.facebook.presto.orc.RowGroup"}, {"methodBody": ["METHOD_START", "{", "return   minAverageRowBytes ;", "}", "METHOD_END"], "methodName": ["getMinAverageRowBytes"], "fileName": "com.facebook.presto.orc.RowGroup"}, {"methodBody": ["METHOD_START", "{", "return   rowCount ;", "}", "METHOD_END"], "methodName": ["getRowCount"], "fileName": "com.facebook.presto.orc.RowGroup"}, {"methodBody": ["METHOD_START", "{", "return   rowOffset ;", "}", "METHOD_END"], "methodName": ["getRowOffset"], "fileName": "com.facebook.presto.orc.RowGroup"}, {"methodBody": ["METHOD_START", "{", "return   streamSources ;", "}", "METHOD_END"], "methodName": ["getStreamSources"], "fileName": "com.facebook.presto.orc.RowGroup"}, {"methodBody": ["METHOD_START", "{", "return   fieldName ;", "}", "METHOD_END"], "methodName": ["getFieldName"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   nestedStreams ;", "}", "METHOD_END"], "methodName": ["getNestedStreams"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   orcDataSource ;", "}", "METHOD_END"], "methodName": ["getOrcDataSource"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   orcDataSource . getId (  )  ;", "}", "METHOD_END"], "methodName": ["getOrcDataSourceId"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   streamId ;", "}", "METHOD_END"], "methodName": ["getStreamId"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   streamName ;", "}", "METHOD_END"], "methodName": ["getStreamName"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   streamType ;", "}", "METHOD_END"], "methodName": ["getStreamType"], "fileName": "com.facebook.presto.orc.StreamDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   column ;", "}", "METHOD_END"], "methodName": ["getColumn"], "fileName": "com.facebook.presto.orc.StreamId"}, {"methodBody": ["METHOD_START", "{", "return   streamKind ;", "}", "METHOD_END"], "methodName": ["getStreamKind"], "fileName": "com.facebook.presto.orc.StreamId"}, {"methodBody": ["METHOD_START", "{", "return   columnEncodings ;", "}", "METHOD_END"], "methodName": ["getColumnEncodings"], "fileName": "com.facebook.presto.orc.Stripe"}, {"methodBody": ["METHOD_START", "{", "return   dictionaryStreamSources ;", "}", "METHOD_END"], "methodName": ["getDictionaryStreamSources"], "fileName": "com.facebook.presto.orc.Stripe"}, {"methodBody": ["METHOD_START", "{", "return   rowCount ;", "}", "METHOD_END"], "methodName": ["getRowCount"], "fileName": "com.facebook.presto.orc.Stripe"}, {"methodBody": ["METHOD_START", "{", "return   rowGroups ;", "}", "METHOD_END"], "methodName": ["getRowGroups"], "fileName": "com.facebook.presto.orc.Stripe"}, {"methodBody": ["METHOD_START", "{", "return    (  ( dividend    +    divisor )     -     1  )     /    divisor ;", "}", "METHOD_END"], "methodName": ["ceil"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    InputStreamSource <  ?  >  >    dictionaryStreamBuilder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    Stream >    entry    :    streams . entrySet (  )  )     {", "StreamId   streamId    =    entry . getKey (  )  ;", "Stream   stream    =    entry . getValue (  )  ;", "int   column    =    stream . getColumn (  )  ;", "ColumnEncoding . ColumnEncodingKind   columnEncoding    =    columnEncodings . get ( column )  . getColumnEncodingKind (  )  ;", "if    (  !  (  . isDictionary ( stream ,    columnEncoding )  )  )     {", "continue ;", "}", "ValueInputStream <  ?  >    valueStream    =    valueStreams . get ( streamId )  ;", "if    ( valueStream    =  =    null )     {", "continue ;", "}", "OrcType . OrcTypeKind   columnType    =    types . get ( stream . getColumn (  )  )  . getOrcTypeKind (  )  ;", "StreamCheckpoint   streamCheckpoint    =    Checkpoints . getDictionaryStreamCheckpoint ( streamId ,    columnType ,    columnEncoding )  ;", "InputStreamSource <  ?  >    streamSource    =    CheckpointInputStreamSource . createCheckpointStreamSource ( valueStream ,    streamCheckpoint )  ;", "dictionaryStreamBuilder . put ( streamId ,    streamSource )  ;", "}", "return   new   InputStreamSources ( dictionaryStreamBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createDictionaryStreamSources"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    InputStreamSource <  ?  >  >    builder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    StreamCheckpoint >    entry    :    checkpoints . entrySet (  )  )     {", "StreamId   streamId    =    entry . getKey (  )  ;", "StreamCheckpoint   checkpoint    =    entry . getValue (  )  ;", "ValueInputStream <  ?  >    valueStream    =    valueStreams . get ( streamId )  ;", "if    ( valueStream    =  =    null )     {", "continue ;", "}", "builder . put ( streamId ,    CheckpointInputStreamSource . createCheckpointStreamSource ( valueStream ,    checkpoint )  )  ;", "}", "InputStreamSources   rowGroupStreams    =    new   InputStreamSources ( builder . build (  )  )  ;", "return   new   RowGroup ( groupId ,    rowOffset ,    rowCount ,    minAverageRowBytes ,    rowGroupStreams )  ;", "}", "METHOD_END"], "methodName": ["createRowGroup"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < RowGroup >    rowGroupBuilder    =    ImmutableList . builder (  )  ;", "for    ( int   rowGroupId    :    selectedRowGroups )     {", "Map < StreamId ,    StreamCheckpoint >    checkpoints    =    Checkpoints . getStreamCheckpoints ( includedOrcColumns ,    types ,    decompressor . isPresent (  )  ,    rowGroupId ,    encodings ,    streams ,    columnIndexes )  ;", "int   rowOffset    =    rowGroupId    *     ( rowsInRowGroup )  ;", "int   rowsInGroup    =    Math . min (  ( rowsInStripe    -    rowOffset )  ,    rowsInRowGroup )  ;", "long   minAverageRowBytes    =    columnIndexes . entrySet (  )  . stream (  )  . mapToLong (  (    e )     -  >    e . getValue (  )  . get ( rowGroupId )  . getColumnStatistics (  )  . getMinAverageValueSizeInBytes (  )  )  . sum (  )  ;", "rowGroupBuilder . add (  . createRowGroup ( rowGroupId ,    rowOffset ,    rowsInGroup ,    minAverageRowBytes ,    valueStreams ,    checkpoints )  )  ;", "}", "return   rowGroupBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["createRowGroups"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    ValueInputStream <  ?  >  >    valueStreams    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    Stream >    entry    :    streams . entrySet (  )  )     {", "StreamId   streamId    =    entry . getKey (  )  ;", "Stream   stream    =    entry . getValue (  )  ;", "ColumnEncoding . ColumnEncodingKind   columnEncoding    =    columnEncodings . get ( stream . getColumn (  )  )  . getColumnEncodingKind (  )  ;", "if    (  (  . isIndexStream ( stream )  )     |  |     (  ( stream . getLength (  )  )     =  =     0  )  )     {", "continue ;", "}", "OrcInputStream   inputStream    =    streamsData . get ( streamId )  ;", "OrcType . OrcTypeKind   columnType    =    types . get ( stream . getColumn (  )  )  . getOrcTypeKind (  )  ;", "valueStreams . put ( streamId ,    ValueStreams . createValueStreams ( streamId ,    inputStream ,    columnType ,    columnEncoding ,    stream . isUseVInts (  )  )  )  ;", "}", "return   valueStreams . build (  )  ;", "}", "METHOD_END"], "methodName": ["createValueStreams"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    DiskRange >    streamDiskRanges    =    ImmutableMap . builder (  )  ;", "long   sOffset    =     0  ;", "for    ( Stream   stream    :    streams )     {", "int   streamLength    =    Math . toIntExact ( stream . getLength (  )  )  ;", "if    ( streamLength    >     0  )     {", "streamDiskRanges . put ( new   StreamId ( stream )  ,    new   DiskRange ( sOffset ,    streamLength )  )  ;", "}", "sOffset    +  =    streamLength ;", "}", "return   streamDiskRanges . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDiskRanges"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Set < Integer >    includes    =    new   LinkedHashSet <  >  (  )  ;", "OrcType   root    =    types . get (  0  )  ;", "for    ( int   includedColumn    :    includedColumns )     {", ". includeOrcColumnsRecursive ( types ,    includes ,    root . getFieldTypeIndex ( includedColumn )  )  ;", "}", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludedOrcColumns"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( rootStructType ,     \" rootStructType   is   null \"  )  ;", "checkArgument (  (  ( rootStructType . getOrcTypeKind (  )  )     =  =     ( OrcType . OrcTypeKind . STRUCT )  )  )  ;", "Objects . requireNonNull ( columnIndexes ,     \" columnIndexes   is   null \"  )  ;", "checkArgument (  ( rowGroup    >  =     0  )  ,     \" rowGroup   is   negative \"  )  ;", "Builder < Integer ,    ColumnStatistics >    statistics    =    ImmutableMap . builder (  )  ;", "for    ( int   ordinal    =     0  ;    ordinal    <     ( rootStructType . getFieldCount (  )  )  ;    ordinal +  +  )     {", "List < RowGroupIndex >    rowGroupIndexes    =    columnIndexes . get ( rootStructType . getFieldTypeIndex ( ordinal )  )  ;", "if    ( rowGroupIndexes    !  =    null )     {", "statistics . put ( ordinal ,    rowGroupIndexes . get ( rowGroup )  . getColumnStatistics (  )  )  ;", "}", "}", "return   statistics . build (  )  ;", "}", "METHOD_END"], "methodName": ["getRowGroupStatistics"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "result . add ( typeId )  ;", "OrcType   type    =    types . get ( typeId )  ;", "int   children    =    type . getFieldCount (  )  ;", "for    ( int   i    =     0  ;    i    <    children ;     +  + i )     {", ". includeOrcColumnsRecursive ( types ,    result ,    type . getFieldTypeIndex ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["includeOrcColumnsRecursive"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DICTIONARY _ DATA )  )     |  |     (  (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . LENGTH )  )     &  &     (  ( columnEncoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )     |  |     ( columnEncoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDictionary"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . ROW _ INDEX )  )     |  |     (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DICTIONARY _ COUNT )  )  )     |  |     (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . BLOOM _ FILTER )  )  ;", "}", "METHOD_END"], "methodName": ["isIndexStream"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < Integer ,    List < HiveBloomFilter >  >    bloomFilters    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    Stream >    entry    :    streams . entrySet (  )  )     {", "Stream   stream    =    entry . getValue (  )  ;", "if    (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . BLOOM _ FILTER )  )     {", "OrcInputStream   inputStream    =    streamsData . get ( entry . getKey (  )  )  ;", "bloomFilters . put ( stream . getColumn (  )  ,    metadata . readBloomFilterIndexes ( inputStream )  )  ;", "}", "}", "return   bloomFilters . build (  )  ;", "}", "METHOD_END"], "methodName": ["readBloomFilterIndexes"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < Integer ,    List < RowGroupIndex >  >    columnIndexes    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    Stream >    entry    :    streams . entrySet (  )  )     {", "Stream   stream    =    entry . getValue (  )  ;", "if    (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . ROW _ INDEX )  )     {", "OrcInputStream   inputStream    =    streamsData . get ( entry . getKey (  )  )  ;", "List < HiveBloomFilter >    bloomFilters    =    bloomFilterIndexes . get ( stream . getColumn (  )  )  ;", "List < RowGroupIndex >    rowGroupIndexes    =    metadata . readRowIndexes ( hiveWriterVersion ,    inputStream )  ;", "if    (  ( bloomFilters    !  =    null )     &  &     (  !  ( bloomFilters . isEmpty (  )  )  )  )     {", "ImmutableList . Builder < RowGroupIndex >    newRowGroupIndexes    =    ImmutableList . builder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( rowGroupIndexes . size (  )  )  ;    i +  +  )     {", "RowGroupIndex   rowGroupIndex    =    rowGroupIndexes . get ( i )  ;", "ColumnStatistics   columnStatistics    =    rowGroupIndex . getColumnStatistics (  )  . withBloomFilter ( bloomFilters . get ( i )  )  ;", "newRowGroupIndexes . add ( new   RowGroupIndex ( rowGroupIndex . getPositions (  )  ,    columnStatistics )  )  ;", "}", "rowGroupIndexes    =    newRowGroupIndexes . build (  )  ;", "}", "columnIndexes . put ( stream . getColumn (  )  ,    rowGroupIndexes )  ;", "}", "}", "return   columnIndexes . build (  )  ;", "}", "METHOD_END"], "methodName": ["readColumnIndexes"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    DiskRange >    diskRangesBuilder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    DiskRange >    entry    :    diskRanges . entrySet (  )  )     {", "DiskRange   diskRange    =    entry . getValue (  )  ;", "diskRangesBuilder . put ( entry . getKey (  )  ,    new   DiskRange (  ( sOffset    +     ( diskRange . getOffset (  )  )  )  ,    diskRange . getLength (  )  )  )  ;", "}", "diskRanges    =    diskRangesBuilder . build (  )  ;", "Map < StreamId ,    FixedLengthSliceInput >    streamsData    =    orcDataSource . readFully ( diskRanges )  ;", "Builder < StreamId ,    OrcInputStream >    streamsBuilder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    FixedLengthSliceInput >    entry    :    streamsData . entrySet (  )  )     {", "streamsBuilder . put ( entry . getKey (  )  ,    new   OrcInputStream ( orcDataSource . getId (  )  ,    entry . getValue (  )  ,    decompressor ,    systemMemoryUsage )  )  ;", "}", "return   streamsBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["readDiskRanges"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "StripeFooter   stripeFooter    =    readStripeFooter ( stripe ,    systemMemoryUsage )  ;", "List < ColumnEncoding >    columnEncodings    =    stripeFooter . getColumnEncodings (  )  ;", "Map < StreamId ,    Stream >    streams    =    new   HashMap <  >  (  )  ;", "boolean   hasRowGroupDictionary    =    false ;", "for    ( Stream   stream    :    stripeFooter . getStreams (  )  )     {", "if    ( includedOrcColumns . contains ( stream . getColumn (  )  )  )     {", "streams . put ( new   StreamId ( stream )  ,    stream )  ;", "ColumnEncoding . ColumnEncodingKind   columnEncoding    =    columnEncodings . get ( stream . getColumn (  )  )  . getColumnEncodingKind (  )  ;", "if    (  ( columnEncoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )     &  &     (  ( stream . getStreamKind (  )  )     =  =     ( Stream . StreamKind . IN _ DICTIONARY )  )  )     {", "hasRowGroupDictionary    =    true ;", "}", "}", "}", "boolean   invalidCheckPoint    =    false ;", "if    (  (  ( stripe . getNumberOfRows (  )  )     >     ( rowsInRowGroup )  )     |  |    hasRowGroupDictionary )     {", "Map < StreamId ,    DiskRange >    diskRanges    =     . getDiskRanges ( stripeFooter . getStreams (  )  )  ;", "diskRanges    =    Maps . filterKeys ( diskRanges ,    Predicates . in ( streams . keySet (  )  )  )  ;", "Map < StreamId ,    OrcInputStream >    streamsData    =    readDiskRanges ( stripe . getOffset (  )  ,    diskRanges ,    systemMemoryUsage )  ;", "Map < Integer ,    List < HiveBloomFilter >  >    bloomFilterIndexes    =    readBloomFilterIndexes ( streams ,    streamsData )  ;", "Map < Integer ,    List < RowGroupIndex >  >    columnIndexes    =    readColumnIndexes ( streams ,    streamsData ,    bloomFilterIndexes )  ;", "if    ( writeValidation . isPresent (  )  )     {", "writeValidation . get (  )  . validateRowGroupStatistics ( orcDataSource . getId (  )  ,    stripe . getOffset (  )  ,    columnIndexes )  ;", "}", "Set < Integer >    selectedRowGroups    =    selectRowGroups ( stripe ,    columnIndexes )  ;", "if    ( selectedRowGroups . isEmpty (  )  )     {", "systemMemoryUsage . close (  )  ;", "return   null ;", "}", "Map < StreamId ,    ValueInputStream <  ?  >  >    valueStreams    =    createValueStreams ( streams ,    streamsData ,    columnEncodings )  ;", "InputStreamSources   dictionaryStreamSources    =    createDictionaryStreamSources ( streams ,    valueStreams ,    columnEncodings )  ;", "try    {", "List < RowGroup >    rowGroups    =    createRowGroups ( stripe . getNumberOfRows (  )  ,    streams ,    valueStreams ,    columnIndexes ,    selectedRowGroups ,    columnEncodings )  ;", "return   new   Stripe ( stripe . getNumberOfRows (  )  ,    columnEncodings ,    rowGroups ,    dictionaryStreamSources )  ;", "}    catch    ( InvalidCheckpointException   e )     {", "if    ( hasRowGroupDictionary )     {", "throw   new   OrcCorruptionException ( e ,    orcDataSource . getId (  )  ,     \" Checkpoints   are   corrupt \"  )  ;", "}", "invalidCheckPoint    =    true ;", "}", "}", "Builder < StreamId ,    DiskRange >    diskRangesBuilder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    DiskRange >    entry    :     . getDiskRanges ( stripeFooter . getStreams (  )  )  . entrySet (  )  )     {", "StreamId   streamId    =    entry . getKey (  )  ;", "if    ( streams . keySet (  )  . contains ( streamId )  )     {", "diskRangesBuilder . put ( entry )  ;", "}", "}", "ImmutableMap < StreamId ,    DiskRange >    diskRanges    =    diskRangesBuilder . build (  )  ;", "Map < StreamId ,    OrcInputStream >    streamsData    =    readDiskRanges ( stripe . getOffset (  )  ,    diskRanges ,    systemMemoryUsage )  ;", "long   minAverageRowBytes    =     0  ;", "for    ( Map . Entry < StreamId ,    Stream >    entry    :    streams . entrySet (  )  )     {", "if    (  ( entry . getKey (  )  . getStreamKind (  )  )     =  =     ( Stream . StreamKind . ROW _ INDEX )  )     {", "List < RowGroupIndex >    rowGroupIndexes    =    metadataReader . readRowIndexes ( hiveWriterVersion ,    streamsData . get ( entry . getKey (  )  )  )  ;", "checkState (  (  (  ( rowGroupIndexes . size (  )  )     =  =     1  )     |  |    invalidCheckPoint )  ,     \" expect   a   single   row   group   or   an   invalid   check   point \"  )  ;", "long   totalBytes    =     0  ;", "long   totalRows    =     0  ;", "for    ( RowGroupIndex   rowGroupIndex    :    rowGroupIndexes )     {", "ColumnStatistics   columnStatistics    =    rowGroupIndex . getColumnStatistics (  )  ;", "if    ( columnStatistics . hasMinAverageValueSizeInBytes (  )  )     {", "totalBytes    +  =     ( columnStatistics . getMinAverageValueSizeInBytes (  )  )     *     ( columnStatistics . getNumberOfValues (  )  )  ;", "totalRows    +  =    columnStatistics . getNumberOfValues (  )  ;", "}", "}", "if    ( totalRows    >     0  )     {", "minAverageRowBytes    +  =    totalBytes    /    totalRows ;", "}", "}", "}", "Map < StreamId ,    ValueInputStream <  ?  >  >    valueStreams    =    createValueStreams ( streams ,    streamsData ,    columnEncodings )  ;", "InputStreamSources   dictionaryStreamSources    =    createDictionaryStreamSources ( streams ,    valueStreams ,    columnEncodings )  ;", "Builder < StreamId ,    InputStreamSource <  ?  >  >    builder    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < StreamId ,    ValueInputStream <  ?  >  >    entry    :    valueStreams . entrySet (  )  )     {", "builder . put ( entry . getKey (  )  ,    new   ValueInputStreamSource ( entry . getValue (  )  )  )  ;", "}", "RowGroup   rowGroup    =    new   RowGroup (  0  ,     0  ,    stripe . getNumberOfRows (  )  ,    minAverageRowBytes ,    new   InputStreamSources ( builder . build (  )  )  )  ;", "return   new   Stripe ( stripe . getNumberOfRows (  )  ,    columnEncodings ,    ImmutableList . of ( rowGroup )  ,    dictionaryStreamSources )  ;", "}", "METHOD_END"], "methodName": ["readStripe"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "long   offset    =     (  ( stripe . getOffset (  )  )     +     ( stripe . getIndexLength (  )  )  )     +     ( stripe . getDataLength (  )  )  ;", "int   tailLength    =    Math . toIntExact ( stripe . getFooterLength (  )  )  ;", "byte [  ]    tailBuffer    =    new   byte [ tailLength ]  ;", "orcDataSource . readFully ( offset ,    tailBuffer )  ;", "try    ( InputStream   inputStream    =    new   OrcInputStream ( orcDataSource . getId (  )  ,    Slices . wrappedBuffer ( tailBuffer )  . getInput (  )  ,    decompressor ,    systemMemoryUsage )  )     {", "return   metadataReader . readFooter ( types ,    inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["readStripeFooter"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "int   rowsInStripe    =    Math . toIntExact ( stripe . getNumberOfRows (  )  )  ;", "int   groupsInStripe    =     . ceil ( rowsInStripe ,    rowsInRowGroup )  ;", "ImmutableSet . Builder < Integer >    selectedRowGroups    =    ImmutableSet . builder (  )  ;", "int   remainingRows    =    rowsInStripe ;", "for    ( int   rowGroup    =     0  ;    rowGroup    <    groupsInStripe ;     +  + rowGroup )     {", "int   rows    =    Math . min ( remainingRows ,    rowsInRowGroup )  ;", "Map < Integer ,    ColumnStatistics >    statistics    =     . getRowGroupStatistics ( types . get (  0  )  ,    columnIndexes ,    rowGroup )  ;", "if    ( predicate . matches ( rows ,    statistics )  )     {", "selectedRowGroups . add ( rowGroup )  ;", "}", "remainingRows    -  =    rows ;", "}", "return   selectedRowGroups . build (  )  ;", "}", "METHOD_END"], "methodName": ["selectRowGroups"], "fileName": "com.facebook.presto.orc.StripeReader"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.facebook.presto.orc.TempFile"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( actual ,     \" actual   is   null \"  )  ;", "assertNotNull ( expectedType ,     \" expectedType   is   null \"  )  ;", "if    ( expectedType . isInstance ( actual )  )     {", "fail ( Str . format (  \" expected :  <  % s >    to   not   be   an   instance   of    <  % s >  \"  ,    actual ,    expectedType . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotInstanceOf"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "JobConf   jobConf    =    new   JobConf (  )  ;", "jobConf . set (  \" hive . execwrite . format \"  ,     ( format    =  =     ( OrcTester . Format . ORC _  1  2  )     ?     \"  0  .  1  2  \"     :     \"  0  .  1  1  \"  )  )  ;", "jobConf . set (  \" hive . execdefault . compress \"  ,    compression . name (  )  )  ;", "Properties   tableProperties    =    new   Properties (  )  ;", "tableProperties . setProperty (  \" columns \"  ,     \" test \"  )  ;", "tableProperties . setProperty (  \" columns . types \"  ,    columnObjectInspector . getTypeName (  )  )  ;", "tableProperties . setProperty ( stripe . size \"  ,     \"  1  2  0  0  0  0  0  \"  )  ;", "return   new   OrcOutputFormat (  )  . getHiveRecordWriter ( jobConf ,    new   Path ( outputFile . toURI (  )  )  ,    Text . class ,     ( compression    !  =     ( CompressionKind . NONE )  )  ,    tableProperties ,     (  )     -  >     {", "}  )  ;", "}", "METHOD_END"], "methodName": ["createOrcRecordWriter"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "OrcReader   orcReader    =    new   OrcReader ( orcDataSource ,    OrcEncoding . ORC ,    maxMergeDistance ,    maxReadSize ,    new   DataSize (  1  ,    Unit . MEGABYTE )  )  ;", "assertEquals ( orcDataSource . getReadCount (  )  ,     1  )  ;", "List < StripeInformation >    stripes    =    orcReader . getFooter (  )  . getStripes (  )  ;", "Assertions . assertGreaterThanOrEqual ( stripes . size (  )  ,     3  )  ;", "Assertions . assertInstanceOf ( OrcRecordReader . wrapWithCacheIfTinyStripes ( orcDataSource ,    stripes ,    maxMergeDistance ,    maxReadSize )  ,    CachingOrcDataSource . class )  ;", "OrcRecordReader   orcRecordReader    =    orcReader . createRecordReader ( ImmutableMap . of (  0  ,    VARCHAR )  ,     (    numberOfRows ,    statisticsByColumnIndex )     -  >    true ,    OrcTester . HIVE _ STORAGE _ TIME _ ZONE ,    newSimpleAggregatedMemoryContext (  )  )  ;", "int   positionCount    =     0  ;", "while    ( true )     {", "int   batchSize    =    orcRecordReader . nextBatch (  )  ;", "if    ( batchSize    <  =     0  )     {", "break ;", "}", "Block   block    =    orcRecordReader . readBlock ( VARCHAR ,     0  )  ;", "positionCount    +  =    block . getPositionCount (  )  ;", "}", "assertEquals ( positionCount ,     . POSITION _ COUNT )  ;", "}", "METHOD_END"], "methodName": ["doIntegration"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "tempFile    =    new   TempFile (  )  ;", "Random   random    =    new   Random (  )  ;", "Iterator < String >    iterator    =    Stream . generate (  (  )     -  >    Long . toHexString ( random . nextLong (  )  )  )  . limit (  . POSITION _ COUNT )  . iterator (  )  ;", "OrcTester . writeOrcFileColumnHive ( tempFile . getFile (  )  ,    OrcTester . Format . ORC _  1  2  ,     . createOrcRecordWriter ( tempFile . getFile (  )  ,    OrcTester . Format . ORC _  1  2  ,    CompressionKind . ZLIB ,    PrimitiveObjectInspectorFactory . javaStringObjectInspector )  ,    VARCHAR ,    iterator )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "tempFile . close (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "TestingOrcDataSource   orcDataSource    =    new   TestingOrcDataSource ( new   FileOrcDataSource ( tempFile . getFile (  )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    true )  )  ;", "doIntegration ( orcDataSource ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  )  ;", "assertEquals ( orcDataSource . getReadCount (  )  ,     1  )  ;", "orcDataSource    =    new   TestingOrcDataSource ( new   FileOrcDataSource ( tempFile . getFile (  )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    true )  )  ;", "doIntegration ( orcDataSource ,    new   io . airlift . units . DataSize (  4  0  0  ,    Unit . KILOBYTE )  ,    new   io . airlift . units . DataSize (  4  0  0  ,    Unit . KILOBYTE )  )  ;", "assertEquals ( orcDataSource . getReadCount (  )  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testIntegration"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "DataSize   maxMergeDistance    =    new   DataSize (  1  ,    Unit . MEGABYTE )  ;", "DataSize   maxReadSize    =    new   DataSize (  8  ,    Unit . MEGABYTE )  ;", "TestingOrcDataSource   testingOrcDataSource    =    new   TestingOrcDataSource (  . FakeOrcDataSource . INSTANCE )  ;", "CachingOrcDataSource   cachingOrcDataSource    =    new   CachingOrcDataSource ( testingOrcDataSource ,    OrcRecordReader . LinearProbeRangeFinder . createTinyStripesRangeFinder ( ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     3  3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     6  3  ,     (  (  1  0  4  8  5  7  6     *     8  )     -     2  0  )  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  )  ;", "cachingOrcDataSource . readCacheAt (  3  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  3  ,     6  0  )  )  )  ;", "cachingOrcDataSource . readCacheAt (  6  3  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  6  3  ,     (  8     *     1  0  4  8  5  7  6  )  )  )  )  ;", "testingOrcDataSource    =    new   TestingOrcDataSource (  . FakeOrcDataSource . INSTANCE )  ;", "cachingOrcDataSource    =    new   CachingOrcDataSource ( testingOrcDataSource ,    OrcRecordReader . LinearProbeRangeFinder . createTinyStripesRangeFinder ( ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     3  3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     6  3  ,     (  (  1  0  4  8  5  7  6     *     8  )     -     2  0  )  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  )  ;", "cachingOrcDataSource . readCacheAt (  6  2  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  3  ,     6  0  )  )  )  ;", "cachingOrcDataSource . readCacheAt (  6  3  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  6  3  ,     (  8     *     1  0  4  8  5  7  6  )  )  )  )  ;", "testingOrcDataSource    =    new   TestingOrcDataSource (  . FakeOrcDataSource . INSTANCE )  ;", "cachingOrcDataSource    =    new   CachingOrcDataSource ( testingOrcDataSource ,    OrcRecordReader . LinearProbeRangeFinder . createTinyStripesRangeFinder ( ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  ,     1  ,     1  )  ,    new   StripeInformation (  1  2  3  ,     4  ,     1  0  4  8  5  7  6  ,     1  0  4  8  5  7  6  ,     (  1  0  4  8  5  7  6     *     3  )  )  ,    new   StripeInformation (  1  2  3  ,     (  4     +     (  1  0  4  8  5  7  6     *     5  )  )  ,     1  0  4  8  5  7  6  ,     1  0  4  8  5  7  6  ,     1  0  4  8  5  7  6  )  )  ,    maxMergeDistance ,    maxReadSize )  )  ;", "cachingOrcDataSource . readCacheAt (  3  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  3  ,     (  1     +     (  1  0  4  8  5  7  6     *     5  )  )  )  )  )  ;", "cachingOrcDataSource . readCacheAt (  (  4     +     (  1  0  4  8  5  7  6     *     5  )  )  )  ;", "assertEquals ( testingOrcDataSource . getLastReadRanges (  )  ,    ImmutableList . of ( new   DiskRange (  (  4     +     (  1  0  4  8  5  7  6     *     5  )  )  ,     (  3     *     1  0  4  8  5  7  6  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTinyStripesReadCacheAt"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "DataSize   maxMergeDistance    =    new   DataSize (  1  ,    Unit . MEGABYTE )  ;", "DataSize   maxReadSize    =    new   DataSize (  8  ,    Unit . MEGABYTE )  ;", "OrcDataSource   actual    =    OrcRecordReader . wrapWithCacheIfTinyStripes (  . FakeOrcDataSource . INSTANCE ,    ImmutableList . of (  )  ,    maxMergeDistance ,    maxReadSize )  ;", "Assertions . assertInstanceOf ( actual ,    CachingOrcDataSource . class )  ;", "actual    =    OrcRecordReader . wrapWithCacheIfTinyStripes (  . FakeOrcDataSource . INSTANCE ,    ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  ;", "Assertions . assertInstanceOf ( actual ,    CachingOrcDataSource . class )  ;", "actual    =    OrcRecordReader . wrapWithCacheIfTinyStripes (  . FakeOrcDataSource . INSTANCE ,    ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     3  3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     6  3  ,     1  0  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  ;", "Assertions . assertInstanceOf ( actual ,    CachingOrcDataSource . class )  ;", "actual    =    OrcRecordReader . wrapWithCacheIfTinyStripes (  . FakeOrcDataSource . INSTANCE ,    ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     3  3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     6  3  ,     (  (  1  0  4  8  5  7  6     *     8  )     -     2  0  )  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  ;", "Assertions . assertInstanceOf ( actual ,    CachingOrcDataSource . class )  ;", "actual    =    OrcRecordReader . wrapWithCacheIfTinyStripes (  . FakeOrcDataSource . INSTANCE ,    ImmutableList . of ( new   StripeInformation (  1  2  3  ,     3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     3  3  ,     1  0  ,     1  0  ,     1  0  )  ,    new   StripeInformation (  1  2  3  ,     6  3  ,     (  (  (  1  0  4  8  5  7  6     *     8  )     -     2  0  )     +     1  )  ,     1  0  ,     1  0  )  )  ,    maxMergeDistance ,    maxReadSize )  ;", ". assertNotInstanceOf ( actual ,    CachingOrcDataSource . class )  ;", "}", "METHOD_END"], "methodName": ["testWrapWithCacheIfTinyStripes"], "fileName": "com.facebook.presto.orc.TestCachingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "Set < Integer >    positions    =    new   HashSet <  >  (  )  ;", "DictionaryBuilder   dictionaryBuilder    =    new   DictionaryBuilder (  6  4  )  ;", "for    ( int   i    =     0  ;    i    <     6  4  ;    i +  +  )     {", "positions . add ( dictionaryBuilder . putIfAbsent ( new    . TestHashCollisionBlock (  1  ,    wrappedBuffer ( new   byte [  ]  {     1     }  )  ,    new   int [  ]  {     0  ,     1     }  ,    new   boolean [  ]  {    false    }  )  ,     0  )  )  ;", "positions . add ( dictionaryBuilder . putIfAbsent ( new    . TestHashCollisionBlock (  1  ,    wrappedBuffer ( new   byte [  ]  {     2     }  )  ,    new   int [  ]  {     0  ,     1     }  ,    new   boolean [  ]  {    false    }  )  ,     0  )  )  ;", "}", "assertEquals ( positions ,    ImmutableSet . of (  1  ,     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testSkipReservedSlots"], "fileName": "com.facebook.presto.orc.TestDictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return   TestDictionaryCompressionOptimizer . dictionaryColumn ( bytesPerEntry ,    maxDictionaryEntries ,     0  .  5  )  ;", "}", "METHOD_END"], "methodName": ["dictionaryColumn"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "return   new   TestDictionaryCompressionOptimizer . TestDictionaryColumn ( bytesPerEntry ,    uniquePercentage ,    OptionalInt . of ( maxDictionaryEntries )  ,     1  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["dictionaryColumn"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "return   new   TestDictionaryCompressionOptimizer . TestDictionaryColumn ( bytesPerEntry ,    uniquePercentage ,    OptionalInt . empty (  )  ,     1  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["directColumn"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "return   Math . toIntExact ( new   io . airlift . units . DataSize ( size ,    Unit . MEGABYTE )  . toBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["megabytes"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4  ;", "int   dictionaryMaxMemoryBytes    =     . megabytes (  8  )  ;", "double   directUniquePercentage    =     0  .  7  5  ;", ". TestDictionaryColumn   directColumn    =     . directColumn ( bytesPerEntry ,    directUniquePercentage )  ;", ". TestDictionaryColumn   dictionaryColumn    =     . dictionaryColumn ( bytesPerEntry ,     1  0  2  4  )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  )  ;", "int   expectedRowCountAtFlip    =     (  ( int )     ( dictionaryMaxMemoryBytes    /     (  ( bytesPerEntry    *     2  )     *    directUniquePercentage )  )  )  ;", "int   expectedMaxRowCountAtFull    =    stripeMaxBytes    /     ( bytesPerEntry    *     2  )  ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,    expectedMaxRowCountAtFull ,     ( expectedMaxRowCountAtFull    *     2  )  ,    dictionaryMaxMemoryBytes ,     0  ,    directColumn ,    dictionaryColumn )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedRowCountAtFlip )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCountAtFull )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCountAtFull )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDictionaryAndDirectBytesLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   stripeMaxBytes    =    TestDictionaryCompressionOptimizer . megabytes (  1  0  0  )  ;", "int   bytesPerRow    =     1  0  2  4  ;", "int   expectedMaxRowCount    =    stripeMaxBytes    /    bytesPerRow ;", "TestDictionaryCompressionOptimizer . DataSimulator   simulator    =    new   TestDictionaryCompressionOptimizer . DataSimulator ( stripeMaxBytes ,     1  0  0  0  0  ,     ( expectedMaxRowCount    *     2  )  ,    TestDictionaryCompressionOptimizer . megabytes (  1  6  )  ,    bytesPerRow )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNoDictionariesBytesLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4  ;", "int   dictionaryEntries    =     1  0  2  4  ;", ". TestDictionaryColumn   column    =     . dictionaryColumn ( bytesPerEntry ,    dictionaryEntries )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  )  ;", "int   bytesPerRow    =    DictionaryCompressionOptimizer . estimateIndexBytesPerValue ( dictionaryEntries )  ;", "int   expectedMaxRowCount    =    stripeMaxBytes    /    bytesPerRow ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,     1  0  0  0  0  ,     ( expectedMaxRowCount    *     1  0  )  ,     . megabytes (  1  6  )  ,     0  ,    column )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertLessThan ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertLessThan ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleDictionaryColumnByteLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4  ;", "int   dictionaryMaxMemoryBytes    =     . megabytes (  3  2  )  ;", "double   uniquePercentage    =     0  .  5  ;", ". TestDictionaryColumn   column    =     . directColumn ( bytesPerEntry ,    uniquePercentage )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  )  ;", "int   dictionaryMaxMemoryBytesLow    =    dictionaryMaxMemoryBytes    -     (  ( int )     ( DictionaryCompressionOptimizer . DICTIONARY _ MEMORY _ MAX _ RANGE . toBytes (  )  )  )  ;", "int   expectedMaxRowCount    =     (  ( int )     (  ( dictionaryMaxMemoryBytesLow    /    bytesPerEntry )     /    uniquePercentage )  )  ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,     ( expectedMaxRowCount    /     2  )  ,     ( expectedMaxRowCount    *     2  )  ,    dictionaryMaxMemoryBytes ,     0  ,    column )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertTrue ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertTrue ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleDictionaryColumnMemoryLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4     *     1  0  2  4  ;", "int   dictionaryMaxMemoryBytes    =     (  . megabytes (  8  )  )     +     1  0  0  ;", "double   uniquePercentage    =     0  .  2  ;", ". TestDictionaryColumn   column    =     . dictionaryColumn ( bytesPerEntry ,     1  6  ,    uniquePercentage )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  )  ;", "int   expectedMaxRowCount    =     (  ( int )     (  ( dictionaryMaxMemoryBytes    /    bytesPerEntry )     /    uniquePercentage )  )  ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,    Integer . MAX _ VALUE ,    Integer . MAX _ VALUE ,    dictionaryMaxMemoryBytes ,     0  ,    column )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertTrue ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertTrue ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleDictionaryColumnMemoryLimitHighlyCompressed"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4  ;", ". TestDictionaryColumn   column    =     . dictionaryColumn ( bytesPerEntry ,     1  0  2  4  )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  0  )  ;", "int   expectedMaxRowCount    =     1  0  0  0  0  0  0  ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,     1  0  0  0  0  ,    expectedMaxRowCount ,     . megabytes (  1  6  )  ,     0  ,    column )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleDictionaryColumnRowLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   bytesPerEntry    =     1  0  2  4  ;", "int   dictionaryMaxMemoryBytes    =     . megabytes (  1  6  )  ;", ". TestDictionaryColumn   column    =     . directColumn ( bytesPerEntry ,     1  .  0  )  ;", "int   stripeMaxBytes    =     . megabytes (  1  0  0  )  ;", "int   expectedRowCountAtFlip    =     (  ( int )     (  ( dictionaryMaxMemoryBytes    -     ( DictionaryCompressionOptimizer . DICTIONARY _ MEMORY _ MAX _ RANGE . toBytes (  )  )  )     /    bytesPerEntry )  )  ;", "int   expectedMaxRowCountAtFull    =    stripeMaxBytes    /    bytesPerEntry ;", ". DataSimulator   simulator    =    new    . DataSimulator ( stripeMaxBytes ,     1  ,    expectedMaxRowCountAtFull ,    dictionaryMaxMemoryBytes ,     0  ,    column )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( column . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( column . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedRowCountAtFlip )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( column . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCountAtFull )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( column . isDirect (  )  )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedMaxRowCountAtFull )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSingleDirectBytesLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "int   dictionaryMaxMemoryBytes    =    TestDictionaryCompressionOptimizer . megabytes (  3  2  )  ;", "int   directBytesPerEntry    =     1  0  0  ;", "double   directUniquePercentage    =     0  .  7  5  ;", "TestDictionaryCompressionOptimizer . TestDictionaryColumn   directColumn    =    TestDictionaryCompressionOptimizer . directColumn ( directBytesPerEntry ,    directUniquePercentage )  ;", "int   dictionaryBytesPerEntry    =     1  0  2  4     *     1  0  2  4  ;", "int   dictionaryEntries    =     1  0  ;", "TestDictionaryCompressionOptimizer . TestDictionaryColumn   dictionaryColumn    =    TestDictionaryCompressionOptimizer . dictionaryColumn ( dictionaryBytesPerEntry ,    dictionaryEntries )  ;", "int   stripeMaxBytes    =    TestDictionaryCompressionOptimizer . megabytes (  2  0  0  0  )  ;", "int   dictionaryMaxMemoryBytesLow    =     (  ( int )     ( dictionaryMaxMemoryBytes    -     ( DictionaryCompressionOptimizer . DICTIONARY _ MEMORY _ MAX _ RANGE . toBytes (  )  )  )  )  ;", "int   expectedRowCountAtFlip    =     (  ( int )     (  ( dictionaryMaxMemoryBytesLow    -     ( dictionaryEntries    *    dictionaryBytesPerEntry )  )     /     ( directBytesPerEntry    *    directUniquePercentage )  )  )  ;", "int   maxRowCount    =     1  0  0  0  0  0  0  0  ;", "TestDictionaryCompressionOptimizer . DataSimulator   simulator    =    new   TestDictionaryCompressionOptimizer . DataSimulator ( stripeMaxBytes ,     1  ,    maxRowCount ,    dictionaryMaxMemoryBytes ,     0  ,    directColumn ,    dictionaryColumn )  ;", "for    ( int   loop    =     0  ;    loop    <     3  ;    loop +  +  )     {", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertFalse ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "assertEquals ( simulator . getRowCount (  )  ,     0  )  ;", "assertEquals ( simulator . getBufferedBytes (  )  ,     0  )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    expectedRowCountAtFlip )  ;", "simulator . advanceToNextStateChange (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    maxRowCount )  ;", "simulator . finalOptimize (  )  ;", "assertFalse ( simulator . isDictionaryMemoryFull (  )  )  ;", "assertTrue ( directColumn . isDirect (  )  )  ;", "assertFalse ( dictionaryColumn . isDirect (  )  )  ;", "Assertions . assertLessThan ( simulator . getBufferedBytes (  )  ,    stripeMaxBytes )  ;", "Assertions . assertGreaterThanOrEqual ( simulator . getRowCount (  )  ,    maxRowCount )  ;", "simulator . reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWideDictionaryAndNarrowDirectBytesLimit"], "fileName": "com.facebook.presto.orc.TestDictionaryCompressionOptimizer"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( bloomFilter . isInitialized (  )  )  ;", "OrcProto . Index . Builder   builder    =    bloomFilterIndex . toBuilder (  )  ;", "builder . add ( bloomFilter )  ;", "OrcProto . Index   index    =    builder . build (  )  ;", "assertTrue ( index . isInitialized (  )  )  ;", "assertEquals ( index . getCount (  )  ,     1  )  ;", "ByteArrayOutputStream   os    =    new   ByteArrayOutputStream (  )  ;", "index . writeTo ( os )  ;", "os . flush (  )  ;", "return   os . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["serializeBloomFilterToIndex"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "BloomFilter   bloomFilter    =    new   BloomFilter (  (  ( TestOrcBloomFilters . TEST _ VALUES . size (  )  )     *     1  0  )  ,     0  .  0  1  )  ;", "for    ( Object   o    :    TestOrcBloomFilters . TEST _ VALUES . keySet (  )  )     {", "if    ( o   instanceof   Long )     {", "bloomFilter . addLong (  (  ( Long )     ( o )  )  )  ;", "} else", "if    ( o   instanceof   Integer )     {", "bloomFilter . addLong (  (  ( Integer )     ( o )  )  )  ;", "} else", "if    ( o   instanceof   String )     {", "bloomFilter . addString (  (  ( String )     ( o )  )  )  ;", "} else", "if    ( o   instanceof   BigDecimal )     {", "bloomFilter . addString ( o . toString (  )  )  ;", "} else", "if    ( o   instanceof   io . airlift . slice . Slice )     {", "bloomFilter . addString (  (  ( io . airlift . slice . Slice )     ( o )  )  . toStringUtf 8  (  )  )  ;", "} else", "if    ( o   instanceof   Timestamp )     {", "bloomFilter . addLong (  (  ( Timestamp )     ( o )  )  . getTime (  )  )  ;", "} else", "if    ( o   instanceof   Double )     {", "bloomFilter . addDouble (  (  ( Double )     ( o )  )  )  ;", "} else    {", "fail (  (  \" Unsupported   type    \"     +     ( o . getClass (  )  )  )  )  ;", "}", "}", "for    ( Map . Entry < Object ,    Type >    testValue    :    TestOrcBloomFilters . TEST _ VALUES . entrySet (  )  )     {", "boolean   matched    =    TupleDomainOrcPredicate . checkInBloomFilter ( bloomFilter ,    testValue . getKey (  )  ,    testValue . getValue (  )  )  ;", "assertTrue ( matched ,     (  \" type    \"     +     ( testValue . getClass (  )  )  )  )  ;", "}", "assertTrue ( TupleDomainOrcPredicate . checkInBloomFilter ( bloomFilter ,    new   Date (  )  ,    DATE )  ,     \" unsupported   type   DATE   should   always   return   true \"  )  ;", "}", "METHOD_END"], "methodName": ["testBloomFilterPredicateValuesExisting"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "BloomFilter   bloomFilter    =    new   BloomFilter (  (  ( TestOrcBloomFilters . TEST _ VALUES . size (  )  )     *     1  0  )  ,     0  .  0  1  )  ;", "for    ( Map . Entry < Object ,    Type >    testValue    :    TestOrcBloomFilters . TEST _ VALUES . entrySet (  )  )     {", "boolean   matched    =    TupleDomainOrcPredicate . checkInBloomFilter ( bloomFilter ,    testValue . getKey (  )  ,    testValue . getValue (  )  )  ;", "assertFalse ( matched ,     (  \" type    \"     +     ( testValue . getKey (  )  . getClass (  )  )  )  )  ;", "}", "assertTrue ( TupleDomainOrcPredicate . checkInBloomFilter ( bloomFilter ,    new   Date (  )  ,    DATE )  ,     \" unsupported   type   DATE   should   always   return   true \"  )  ;", "}", "METHOD_END"], "methodName": ["testBloomFilterPredicateValuesNonExisting"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "Map < Type ,    Object >    testValues    =    ImmutableMap .  < Type ,    Object > builder (  )  . put ( BOOLEAN ,    true )  . put ( INTEGER ,     1  2  3  4 L )  . put ( BIGINT ,     4  3  2  1 L )  . put ( DOUBLE ,     0  .  1  2  3  )  . put ( VARCHAR ,    utf 8 Slice ( TestOrcBloomFilters . TEST _ STRING )  )  . build (  )  ;", "for    ( Map . Entry < Type ,    Object >    testValue    :    testValues . entrySet (  )  )     {", "Domain   predicateDomain    =    Domain . singleValue ( testValue . getKey (  )  ,    testValue . getValue (  )  )  ;", "Optional < Collection < Object >  >    discreteValues    =    TupleDomainOrcPredicate . extractDiscreteValues ( predicateDomain . getValues (  )  )  ;", "assertTrue ( discreteValues . isPresent (  )  )  ;", "Collection < Object >    objects    =    discreteValues . get (  )  ;", "assertEquals ( objects . size (  )  ,     1  )  ;", "assertEquals ( objects . iterator (  )  . next (  )  ,    testValue . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExtractValuesFromSingleDomain"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "BloomFilter   bloomFilter    =    new   BloomFilter (  1  0  0  0  0  0  0 L ,     0  .  0  5  )  ;", "bloomFilter . addString (  . TEST _ STRING )  ;", "assertTrue ( bloomFilter . testString (  . TEST _ STRING )  )  ;", "assertFalse ( bloomFilter . testString (  . TEST _ STRING _ NOT _ WRITTEN )  )  ;", "bloomFilter . addLong (  . TEST _ INTEGER )  ;", "assertTrue ( bloomFilter . testLong (  . TEST _ INTEGER )  )  ;", "assertFalse ( bloomFilter . testLong (  (  (  . TEST _ INTEGER )     +     1  )  )  )  ;", "HiveBloomFilter   hiveBloomFilter    =    new   HiveBloomFilter ( ImmutableList . copyOf ( Longs . asList ( bloomFilter . getBitSet (  )  )  )  ,    bloomFilter . getBitSize (  )  ,    bloomFilter . getNumHashFunctions (  )  )  ;", "assertTrue ( hiveBloomFilter . testString (  . TEST _ STRING )  )  ;", "assertFalse ( hiveBloomFilter . testString (  . TEST _ STRING _ NOT _ WRITTEN )  )  ;", "assertTrue ( hiveBloomFilter . testLong (  . TEST _ INTEGER )  )  ;", "assertFalse ( hiveBloomFilter . testLong (  (  (  . TEST _ INTEGER )     +     1  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHiveBloomFilterSerde"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "Domain   testingColumnHandleDomain    =    Domain . singleValue ( BIGINT ,     1  2  3  4 L )  ;", "TupleDomain . ColumnDomain < String >    column 0     =    new   TupleDomain . ColumnDomain <  >  (  . COLUMN _  0  ,    testingColumnHandleDomain )  ;", "TupleDomain < String >    effectivePredicate    =    TupleDomain . fromColumnDomains ( Optional . of ( ImmutableList . of ( column 0  )  )  )  ;", "TupleDomain < String >    emptyEffectivePredicate    =    TupleDomain . all (  )  ;", "List < TupleDomainOrcPredicate . ColumnReference < String >  >    columnReferences    =    ImmutableList .  < TupleDomainOrcPredicate . ColumnReference < String >  > builder (  )  . add ( new   TupleDomainOrcPredicate . ColumnReference (  . COLUMN _  0  ,     0  ,    BIGINT )  )  . add ( new   TupleDomainOrcPredicate . ColumnReference (  . COLUMN _  1  ,     1  ,    BIGINT )  )  . build (  )  ;", "TupleDomainOrcPredicate < String >    predicate    =    new   TupleDomainOrcPredicate ( effectivePredicate ,    columnReferences ,    true )  ;", "TupleDomainOrcPredicate < String >    emptyPredicate    =    new   TupleDomainOrcPredicate ( emptyEffectivePredicate ,    columnReferences ,    true )  ;", "HiveBloomFilter   hiveBloomFilter    =    new   HiveBloomFilter ( new   BloomFilter (  1  0  0  0  ,     0  .  0  1  )  )  ;", "OrcProto . BloomFilter   emptyOrcBloomFilter    =     . toOrcBloomFilter ( hiveBloomFilter )  ;", "hiveBloomFilter . addLong (  1  2  3  4  )  ;", "OrcProto . BloomFilter   orcBloomFilter    =     . toOrcBloomFilter ( hiveBloomFilter )  ;", "Map < Integer ,    ColumnStatistics >    matchingStatisticsByColumnIndex    =    ImmutableMap . of (  0  ,    new   ColumnStatistics ( null ,     0  ,    null ,    new   IntegerStatistics (  1  0 L ,     2  0  0  0 L ,    null )  ,    null ,    null ,    null ,    null ,    null ,     . toHiveBloomFilter ( orcBloomFilter )  )  )  ;", "Map < Integer ,    ColumnStatistics >    nonMatchingStatisticsByColumnIndex    =    ImmutableMap . of (  0  ,    new   ColumnStatistics ( null ,     0  ,    null ,    new   IntegerStatistics (  1  0 L ,     2  0  0  0 L ,    null )  ,    null ,    null ,    null ,    null ,    null ,     . toHiveBloomFilter ( emptyOrcBloomFilter )  )  )  ;", "Map < Integer ,    ColumnStatistics >    withoutBloomFilterStatisticsByColumnIndex    =    ImmutableMap . of (  0  ,    new   ColumnStatistics ( null ,     0  ,    null ,    new   IntegerStatistics (  1  0 L ,     2  0  0  0 L ,    null )  ,    null ,    null ,    null ,    null ,    null ,    null )  )  ;", "assertTrue ( predicate . matches (  1 L ,    matchingStatisticsByColumnIndex )  )  ;", "assertTrue ( predicate . matches (  1 L ,    withoutBloomFilterStatisticsByColumnIndex )  )  ;", "assertFalse ( predicate . matches (  1 L ,    nonMatchingStatisticsByColumnIndex )  )  ;", "assertTrue ( emptyPredicate . matches (  1 L ,    matchingStatisticsByColumnIndex )  )  ;", "}", "METHOD_END"], "methodName": ["testMatches"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "BloomFilter   bloomFilterWrite    =    new   BloomFilter (  1  0  0  0 L ,     0  .  0  5  )  ;", "bloomFilterWrite . addString (  . TEST _ STRING )  ;", "assertTrue ( bloomFilterWrite . testString (  . TEST _ STRING )  )  ;", "OrcProto . BloomFilter . Builder   bloomFilterBuilder    =    OrcProto . BloomFilter . newBuilder (  )  ;", "bloomFilterBuilder . addAllBitset ( Longs . asList ( bloomFilterWrite . getBitSet (  )  )  )  ;", "bloomFilterBuilder . setNumHashFunctions ( bloomFilterWrite . getNumHashFunctions (  )  )  ;", "OrcProto . BloomFilter   bloomFilter    =    bloomFilterBuilder . build (  )  ;", "OrcProto . BloomFilterIndex   bloomFilterIndex    =    BloomFilterIndex . getDefaultInstance (  )  ;", "byte [  ]    bytes    =     . serializeBloomFilterToIndex ( bloomFilter ,    bloomFilterIndex )  ;", "InputStream   inputStream    =    new   ByteArrayInputStream ( bytes )  ;", "OrcMetadataReader   metadataReader    =    new   OrcMetadataReader (  )  ;", "List < HiveBloomFilter >    bloomFilters    =    metadataReader . readBloomFilterIndexes ( inputStream )  ;", "assertEquals ( bloomFilters . size (  )  ,     1  )  ;", "assertTrue ( bloomFilters . get (  0  )  . testString (  . TEST _ STRING )  )  ;", "assertFalse ( bloomFilters . get (  0  )  . testString (  . TEST _ STRING _ NOT _ WRITTEN )  )  ;", "assertEquals ( bloomFilterWrite . getBitSize (  )  ,    bloomFilters . get (  0  )  . getBitSize (  )  )  ;", "assertEquals ( bloomFilterWrite . getNumHashFunctions (  )  ,    bloomFilters . get (  0  )  . getNumHashFunctions (  )  )  ;", "assertTrue ( Arrays . equals ( bloomFilters . get (  0  )  . getBitSet (  )  ,    bloomFilterWrite . getBitSet (  )  )  )  ;", "CodedInputStream   input    =    CodedInputStream . newInstance ( bytes )  ;", "OrcProto . BloomFilterIndex   deserializedBloomFilterIndex    =    BloomFilterIndex . parseFrom ( input )  ;", "List < OrcProto . BloomFilter >    bloomFilterList    =    deserializedBloomFilterIndex . getBloomFilterList (  )  ;", "assertEquals ( bloomFilterList . size (  )  ,     1  )  ;", "OrcProto . BloomFilter   bloomFilterRead    =    bloomFilterList . get (  0  )  ;", "assertTrue ( Arrays . equals ( Longs . toArray ( bloomFilterRead . getBitsetList (  )  )  ,    bloomFilterWrite . getBitSet (  )  )  )  ;", "assertEquals ( bloomFilterWrite . getNumHashFunctions (  )  ,    bloomFilterRead . getNumHashFunctions (  )  )  ;", "assertEquals ( bloomFilterWrite . getBitSet (  )  . length ,    bloomFilterRead . getBitsetCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOrcHiveBloomFilterSerde"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "return   new   HiveBloomFilter ( emptyOrcBloomFilter . getBitsetList (  )  ,     (  ( emptyOrcBloomFilter . getBitsetCount (  )  )     *     6  4  )  ,    emptyOrcBloomFilter . getNumHashFunctions (  )  )  ;", "}", "METHOD_END"], "methodName": ["toHiveBloomFilter"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "OrcProto . BloomFilter . Builder   builder    =    OrcProto . BloomFilter . newBuilder (  )  ;", "builder . addAllBitset ( Longs . asList ( bloomFilter . getBitSet (  )  )  )  ;", "builder . setNumHashFunctions ( bloomFilter . getNumHashFunctions (  )  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toOrcBloomFilter"], "fileName": "com.facebook.presto.orc.TestOrcBloomFilters"}, {"methodBody": ["METHOD_START", "{", "List < DiskRange >    diskRanges    =    OrcDataSourceUtils . mergeAdjacentDiskRanges ( ImmutableList . of ( new   DiskRange (  1  0  0  ,     1  0  0  )  ,    new   DiskRange (  2  0  0  ,     1  0  0  )  ,    new   DiskRange (  3  0  0  ,     1  0  0  )  )  ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ;", "assertEquals ( diskRanges ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     3  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeAdjacent"], "fileName": "com.facebook.presto.orc.TestOrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < DiskRange >    consistent 1  0 ByteGap    =    ImmutableList . of ( new   DiskRange (  1  0  0  ,     9  0  )  ,    new   DiskRange (  2  0  0  ,     9  0  )  ,    new   DiskRange (  3  0  0  ,     9  0  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    consistent 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  9  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    consistent 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     2  9  0  )  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     2  9  0  )  )  )  ;", "List < DiskRange >    middle 1  0 ByteGap    =    ImmutableList . of ( new   DiskRange (  1  0  0  ,     8  0  )  ,    new   DiskRange (  2  0  0  ,     9  0  )  ,    new   DiskRange (  3  0  0  ,     8  0  )  ,    new   DiskRange (  4  0  0  ,     9  0  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    middle 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  9  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    middle 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     8  0  )  ,    new   DiskRange (  2  0  0  ,     1  8  0  )  ,    new   DiskRange (  4  0  0  ,     9  0  )  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     3  9  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeGap"], "fileName": "com.facebook.presto.orc.TestOrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < DiskRange >    consistent 1  0 ByteGap    =    ImmutableList . of ( new   DiskRange (  1  0  0  ,     9  0  )  ,    new   DiskRange (  2  0  0  ,     9  0  )  ,    new   DiskRange (  3  0  0  ,     9  0  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  )  ,    consistent 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  0  0  ,    Unit . BYTE )  )  ,    consistent 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  9  0  ,    Unit . BYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     1  9  0  )  ,    new   DiskRange (  3  0  0  ,     9  0  )  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  2  0  0  ,    Unit . BYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     1  9  0  )  ,    new   DiskRange (  3  0  0  ,     9  0  )  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( consistent 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  2  9  0  ,    Unit . BYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     2  9  0  )  )  )  ;", "List < DiskRange >    middle 1  0 ByteGap    =    ImmutableList . of ( new   DiskRange (  1  0  0  ,     8  0  )  ,    new   DiskRange (  2  0  0  ,     9  0  )  ,    new   DiskRange (  3  0  0  ,     8  0  )  ,    new   DiskRange (  4  0  0  ,     9  0  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    middle 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  9  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    middle 1  0 ByteGap )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     8  0  )  ,    new   DiskRange (  2  0  0  ,     1  8  0  )  ,    new   DiskRange (  4  0  0  ,     9  0  )  )  )  ;", "assertEquals (  . mergeAdjacentDiskRanges ( middle 1  0 ByteGap ,    new   io . airlift . units . DataSize (  1  0  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . GIGABYTE )  )  ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     3  9  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeMaxSize"], "fileName": "com.facebook.presto.orc.TestOrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "List < DiskRange >    diskRanges    =    OrcDataSourceUtils . mergeAdjacentDiskRanges ( ImmutableList . of ( new   DiskRange (  1  0  0  ,     1  0  0  )  )  ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  ,    new   io . airlift . units . DataSize (  0  ,    Unit . BYTE )  )  ;", "assertEquals ( diskRanges ,    ImmutableList . of ( new   DiskRange (  1  0  0  ,     1  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMergeSingle"], "fileName": "com.facebook.presto.orc.TestOrcDataSourceUtils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    data    =    toByteArray ( getResource (  \" apache - lz 4  . orc \"  )  )  ;", "OrcReader   orcReader    =    new   OrcReader ( new    . InMemoryOrcDataSource ( data )  ,    OrcEncoding . ORC ,     . SIZE ,     . SIZE ,     . SIZE )  ;", "assertEquals ( orcReader . getCompressionKind (  )  ,    CompressionKind . LZ 4  )  ;", "assertEquals ( orcReader . getFooter (  )  . getNumberOfRows (  )  ,     1  0  0  0  0  )  ;", "Map < Integer ,    Type >    includedColumns    =    ImmutableMap .  < Integer ,    Type > builder (  )  . put (  0  ,    BIGINT )  . put (  1  ,    INTEGER )  . put (  2  ,    BIGINT )  . build (  )  ;", "OrcRecordReader   reader    =    orcReader . createRecordReader ( includedColumns ,    OrcPredicate . TRUE ,    UTC ,    newSimpleAggregatedMemoryContext (  )  )  ;", "int   rows    =     0  ;", "while    ( true )     {", "int   batchSize    =    reader . nextBatch (  )  ;", "if    ( batchSize    <  =     0  )     {", "break ;", "}", "rows    +  =    batchSize ;", "Block   xBlock    =    reader . readBlock ( BIGINT ,     0  )  ;", "Block   yBlock    =    reader . readBlock ( INTEGER ,     1  )  ;", "Block   zBlock    =    reader . readBlock ( BIGINT ,     2  )  ;", "for    ( int   position    =     0  ;    position    <    batchSize ;    position +  +  )     {", "BIGINT . getLong ( xBlock ,    position )  ;", "INTEGER . getLong ( yBlock ,    position )  ;", "BIGINT . getLong ( zBlock ,    position )  ;", "}", "}", "assertEquals ( rows ,    reader . getFileRowCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["testReadLz4"], "fileName": "com.facebook.presto.orc.TestOrcLz4"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    largeByteArray    =    new   byte [  4  0  9  6  ]  ;", "sliceOutput    =    new    ( CompressionKind . NONE ,     3  0  0  0  )  ;", "sliceOutput . writeBytes ( largeByteArray ,     0  ,     2  0  0  )  ;", "assertEquals ( sliceOutput . getBufferCapacity (  )  ,     2  5  6  )  ;", "sliceOutput . writeBytes ( largeByteArray ,     0  ,     2  0  0  )  ;", "assertEquals ( sliceOutput . getBufferCapacity (  )  ,     5  1  2  )  ;", "sliceOutput . writeBytes ( largeByteArray ,     0  ,     1  2  0  0  )  ;", "assertEquals ( sliceOutput . getBufferCapacity (  )  ,     1  2  0  0  )  ;", "sliceOutput . writeBytes ( largeByteArray ,     0  ,     2  0  0  0  )  ;", "assertEquals ( sliceOutput . getBufferCapacity (  )  ,     2  4  0  0  )  ;", "sliceOutput . writeBytes ( largeByteArray ,     0  ,     2  5  0  0  )  ;", "assertEquals ( sliceOutput . getBufferCapacity (  )  ,     3  0  0  0  )  ;", "DynamicSliceOutput   output    =    new   DynamicSliceOutput (  6  0  0  0  )  ;", "assertEquals ( sliceOutput . writeDataTo ( output )  ,     (  (  (  (  2  0  0     +     2  0  0  )     +     1  2  0  0  )     +     2  0  0  0  )     +     2  5  0  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testGrowCapacity"], "fileName": "com.facebook.presto.orc.TestOrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "int   size    =     1  0  2  4     *     1  0  2  4  ;", "byte [  ]    largeByteArray    =    new   byte [ size ]  ;", "Arrays . fill ( largeByteArray ,     (  ( byte )     (  1  0  )  )  )  ;", "sliceOutput    =    new    ( CompressionKind . NONE ,     (  2  5  6     *     1  0  2  4  )  )  ;", "DynamicSliceOutput   output    =    new   DynamicSliceOutput ( size )  ;", "sliceOutput . writeBytes ( largeByteArray ,     1  0  ,     ( size    -     1  0  )  )  ;", "assertEquals ( sliceOutput . writeDataTo ( output )  ,     ( size    -     1  0  )  )  ;", "assertEquals ( output . slice (  )  ,    wrappedBuffer ( largeByteArray ,     1  0  ,     ( size    -     1  0  )  )  )  ;", "sliceOutput . reset (  )  ;", "output . reset (  )  ;", "sliceOutput . writeBytes ( wrappedBuffer ( largeByteArray )  ,     1  0  0  ,     ( size    -     1  0  0  )  )  ;", "assertEquals ( sliceOutput . writeDataTo ( output )  ,     ( size    -     1  0  0  )  )  ;", "assertEquals ( output . slice (  )  ,    wrappedBuffer ( largeByteArray ,     1  0  0  ,     ( size    -     1  0  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWriteHugeByteChucks"], "fileName": "com.facebook.presto.orc.TestOrcOutputBuffer"}, {"methodBody": ["METHOD_START", "{", "Block   block    =    reader . readBlock ( BIGINT ,     0  )  ;", "for    ( int   i    =     0  ;    i    <     2  0  ;    i +  +  )     {", "assertEquals ( BIGINT . getLong ( block ,    i )  ,     (  (  ( stripe    *     2  0 L )     +    i )     *     3  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCurrentBatch"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "OrcFile . WriterOptions   writerOptions    =    new   OrcWriterOptions ( conf )  . memory ( new   iNullMemoryManager ( conf )  )  . inspector ( OrcTester . createSettableStructObjectInspector (  \" test \"  ,    BIGINT )  )  . compress ( CompressionKind . SNAPPY )  ;", "Writer   writer    =    OrcFile . createWriter ( new   Path ( file . toURI (  )  )  ,    writerOptions )  ;", "for    ( Map . Entry < String ,    String >    entry    :    metadata . entrySet (  )  )     {", "writer . addUserMetadata ( entry . getKey (  )  ,    ByteBuffer . wrap ( entry . getValue (  )  . getBytes ( StandardCharsets . UTF _  8  )  )  )  ;", "}", "writer . close (  )  ;", "}", "METHOD_END"], "methodName": ["createFileWithOnlyUserMetadata"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "FileSinkOperator . RecordWriter   writer    =    OrcTester . createOrcRecordWriter ( file ,    OrcTester . Format . ORC _  1  2  ,    CompressionKind . NONE ,    VARCHAR )  ;", "@ SuppressWarnings (  \" deprecation \"  )", "Serializer   serde    =    new   OrcSerde (  )  ;", "SettableStructObjectInspector   objectInspector    =    OrcTester . createSettableStructObjectInspector (  \" test \"  ,    VARCHAR )  ;", "Object   row    =    objectInspector . create (  )  ;", "StructField   field    =    objectInspector . getAllStructFieldRefs (  )  . get (  0  )  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <    initialLength ;    i +  +  )     {", "builder . append (  \"  0  \"  )  ;", "}", "String   seedString    =    builder . toString (  )  ;", "int   previousLength    =    initialLength ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "if    (  (  (  ( i    /    step )     +     1  )     *    initialLength )     >    previousLength )     {", "previousLength    =     (  ( i    /    step )     +     1  )     *    initialLength ;", "builder . append ( seedString )  ;", "}", "objectInspector . setStructFieldData ( row ,    field ,    builder . toString (  )  )  ;", "Writable   record    =    serde . serialize ( row ,    objectInspector )  ;", "writer . write ( record )  ;", "}", "writer . close ( false )  ;", "}", "METHOD_END"], "methodName": ["createGrowingSequentialFile"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "FileSinkOperator . RecordWriter   writer    =    OrcTester . createOrcRecordWriter ( file ,    OrcTester . Format . ORC _  1  2  ,    CompressionKind . NONE ,    BIGINT )  ;", "@ SuppressWarnings (  \" deprecation \"  )", "Serializer   serde    =    new   OrcSerde (  )  ;", "SettableStructObjectInspector   objectInspector    =    OrcTester . createSettableStructObjectInspector (  \" test \"  ,    BIGINT )  ;", "Object   row    =    objectInspector . create (  )  ;", "StructField   field    =    objectInspector . getAllStructFieldRefs (  )  . get (  0  )  ;", "for    ( int   i    =     0  ;    i    <     3  0  0  ;    i    +  =     3  )     {", "if    (  ( i    >     0  )     &  &     (  ( i    %     6  0  )     =  =     0  )  )     {", ". flushWriter ( writer )  ;", "}", "objectInspector . setStructFieldData ( row ,    field ,     (  ( long )     ( i )  )  )  ;", "Writable   record    =    serde . serialize ( row ,    objectInspector )  ;", "writer . write ( record )  ;", "}", "writer . close ( false )  ;", "}", "METHOD_END"], "methodName": ["createMultiStripeFile"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "FileSinkOperator . RecordWriter   writer    =    OrcTester . createOrcRecordWriter ( file ,    OrcTester . Format . ORC _  1  2  ,    CompressionKind . NONE ,    BIGINT )  ;", "@ SuppressWarnings (  \" deprecation \"  )", "Serializer   serde    =    new   OrcSerde (  )  ;", "SettableStructObjectInspector   objectInspector    =    OrcTester . createSettableStructObjectInspector (  \" test \"  ,    BIGINT )  ;", "Object   row    =    objectInspector . create (  )  ;", "StructField   field    =    objectInspector . getAllStructFieldRefs (  )  . get (  0  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "objectInspector . setStructFieldData ( row ,    field ,     (  ( long )     ( i )  )  )  ;", "Writable   record    =    serde . serialize ( row ,    objectInspector )  ;", "writer . write ( record )  ;", "}", "writer . close ( false )  ;", "}", "METHOD_END"], "methodName": ["createSequentialFile"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "Field   field    =    OrcOutputFormat . class . getClassLoader (  )  . loadClass (  (  ( OrcOutputFormat . class . getName (  )  )     +     \"  $ OrcRecordWriter \"  )  )  . getDeclaredField (  \" writer \"  )  ;", "field . setAccessible ( true )  ;", "(  ( Writer )     ( field . get ( writer )  )  )  . writeIntermediateFooter (  )  ;", "}", "METHOD_END"], "methodName": ["flushWriter"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", "int   rowsInRowGroup    =     1  0  0  0  0  ;", "int   rowGroupCounts    =     1  0  ;", "int   rowCount    =    rowsInRowGroup    *    rowGroupCounts ;", ". createSequentialFile ( tempFile . getFile (  )  ,    rowCount )  ;", "try    ( OrcRecordReader   reader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    OrcEncoding . ORC ,    OrcPredicate . TRUE ,    BIGINT )  )     {", "assertEquals ( reader . getFileRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getReaderRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getFilePosition (  )  ,     0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "int   rowCountsInCurrentRowGroup    =     0  ;", "while    ( true )     {", "int   batchSize    =    reader . nextBatch (  )  ;", "if    ( batchSize    =  =     (  -  1  )  )     {", "break ;", "}", "rowCountsInCurrentRowGroup    +  =    batchSize ;", "Block   block    =    reader . readBlock ( BIGINT ,     0  )  ;", "assertTrue (  (  (  ( block . getPositionCount (  )  )     =  =     ( OrcReader . MAX _ BATCH _ SIZE )  )     |  |     ( rowCountsInCurrentRowGroup    =  =    rowsInRowGroup )  )  )  ;", "if    ( rowCountsInCurrentRowGroup    =  =    rowsInRowGroup )     {", "rowCountsInCurrentRowGroup    =     0  ;", "} else", "if    ( rowCountsInCurrentRowGroup    >    rowsInRowGroup )     {", "assertTrue ( false ,     \" read   more   rows   in   the   current   row   group \"  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testBatchSizesForFixedWidth"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", "int   rowsInRowGroup    =     1  0  0  0  0  ;", "int   rowGroupCounts    =     1  0  ;", "int   baseStringBytes    =     3  0  0  ;", "int   rowCount    =    rowsInRowGroup    *    rowGroupCounts ;", ". createGrowingSequentialFile ( tempFile . getFile (  )  ,    rowCount ,    rowsInRowGroup ,    baseStringBytes )  ;", "try    ( OrcRecordReader   reader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    OrcEncoding . ORC ,    OrcPredicate . TRUE ,    VARCHAR )  )     {", "assertEquals ( reader . getFileRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getReaderRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getFilePosition (  )  ,     0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "int   currentStringBytes    =     ( baseStringBytes    +     ( Integer . BYTES )  )     +     ( Byte . BYTES )  ;", "int   rowCountsInCurrentRowGroup    =     0  ;", "while    ( true )     {", "int   batchSize    =    reader . nextBatch (  )  ;", "if    ( batchSize    =  =     (  -  1  )  )     {", "break ;", "}", "rowCountsInCurrentRowGroup    +  =    batchSize ;", "Block   block    =    reader . readBlock ( VARCHAR ,     0  )  ;", "if    (  (  ( OrcReader . MAX _ BATCH _ SIZE )     *    currentStringBytes )     <  =     ( OrcTester . MAX _ BLOCK _ SIZE . toBytes (  )  )  )     {", "assertTrue (  (  (  ( block . getPositionCount (  )  )     =  =     ( OrcReader . MAX _ BATCH _ SIZE )  )     |  |     ( rowCountsInCurrentRowGroup    =  =    rowsInRowGroup )  )  )  ;", "} else    {", "assertTrue (  (  (  ( block . getPositionCount (  )  )     =  =     (  ( OrcTester . MAX _ BLOCK _ SIZE . toBytes (  )  )     /    currentStringBytes )  )     |  |     ( rowCountsInCurrentRowGroup    =  =    rowsInRowGroup )  )  )  ;", "}", "if    ( rowCountsInCurrentRowGroup    =  =    rowsInRowGroup )     {", "rowCountsInCurrentRowGroup    =     0  ;", "currentStringBytes    +  =    baseStringBytes ;", "} else", "if    ( rowCountsInCurrentRowGroup    >    rowsInRowGroup )     {", "assertTrue ( false ,     \" read   more   rows   in   the   current   row   group \"  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testBatchSizesForVariableWidth"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", ". createMultiStripeFile ( tempFile . getFile (  )  )  ;", "try    ( OrcRecordReader   reader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    OrcEncoding . ORC ,    OrcPredicate . TRUE ,    BIGINT )  )     {", "assertEquals ( reader . getReaderRowCount (  )  ,     1  0  0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "assertEquals ( reader . getFileRowCount (  )  ,    reader . getReaderRowCount (  )  )  ;", "assertEquals ( reader . getFilePosition (  )  ,    reader . getReaderPosition (  )  )  ;", "for    ( int   i    =     0  ;    i    <     5  ;    i +  +  )     {", "assertEquals ( reader . nextBatch (  )  ,     2  0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     ( i    *     2  0 L )  )  ;", "assertEquals ( reader . getFilePosition (  )  ,    reader . getReaderPosition (  )  )  ;", ". assertCurrentBatch ( reader ,    i )  ;", "}", "assertEquals ( reader . nextBatch (  )  ,     (  -  1  )  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     1  0  0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,    reader . getReaderPosition (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testEntireFile"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", "Map < String ,    String >    metadata    =    ImmutableMap . of (  \" a \"  ,     \" ala \"  ,     \" b \"  ,     \" ma \"  ,     \" c \"  ,     \" kota \"  )  ;", ". createFileWithOnlyUserMetadata ( tempFile . getFile (  )  ,    metadata )  ;", "OrcDataSource   orcDataSource    =    new   FileOrcDataSource ( tempFile . getFile (  )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    true )  ;", "OrcReader   orcReader    =    new   OrcReader ( orcDataSource ,    OrcEncoding . ORC ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  ,    new   io . airlift . units . DataSize (  1  ,    Unit . MEGABYTE )  )  ;", "Footer   footer    =    orcReader . getFooter (  )  ;", "Map < String ,    String >    readMetadata    =    Maps . transformValues ( footer . getUserMetadata (  )  ,    Slice :  : toStringAscii )  ;", "assertEquals ( readMetadata ,    metadata )  ;", "}", "}", "METHOD_END"], "methodName": ["testReadUserMetadata"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", "int   rowCount    =     1  4  2  0  0  0  ;", ". createSequentialFile ( tempFile . getFile (  )  ,    rowCount )  ;", "OrcPredicate   predicate    =     (    numberOfRows ,    statisticsByColumnIndex )     -  >     {", "if    ( numberOfRows    =  =    rowCount )     {", "return   true ;", "}", "IntegerStatistics   stats    =    statisticsByColumnIndex . get (  0  )  . getIntegerStatistics (  )  ;", "return    (  ( stats . getMin (  )  )     =  =     5  0  0  0  0  )     |  |     (  ( stats . getMin (  )  )     =  =     6  0  0  0  0  )  ;", "}  ;", "try    ( OrcRecordReader   reader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    OrcEncoding . ORC ,    predicate ,    BIGINT )  )     {", "assertEquals ( reader . getFileRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getReaderRowCount (  )  ,    rowCount )  ;", "assertEquals ( reader . getFilePosition (  )  ,     0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "long   position    =     5  0  0  0  0  ;", "while    ( true )     {", "int   batchSize    =    reader . nextBatch (  )  ;", "if    ( batchSize    =  =     (  -  1  )  )     {", "break ;", "}", "Block   block    =    reader . readBlock ( BIGINT ,     0  )  ;", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "assertEquals ( BIGINT . getLong ( block ,    i )  ,     ( position    +    i )  )  ;", "}", "assertEquals ( reader . getFilePosition (  )  ,    position )  ;", "assertEquals ( reader . getReaderPosition (  )  ,    position )  ;", "position    +  =    batchSize ;", "}", "assertEquals ( position ,     7  0  0  0  0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,    rowCount )  ;", "assertEquals ( reader . getReaderPosition (  )  ,    rowCount )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testRowGroupSkipping"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "try    ( TempFile   tempFile    =    new   TempFile (  )  )     {", ". createMultiStripeFile ( tempFile . getFile (  )  )  ;", "OrcPredicate   predicate    =     (    numberOfRows ,    statisticsByColumnIndex )     -  >     {", "if    ( numberOfRows    =  =     1  0  0  )     {", "return   true ;", "}", "IntegerStatistics   stats    =    statisticsByColumnIndex . get (  0  )  . getIntegerStatistics (  )  ;", "return    (  (  ( stats . getMin (  )  )     =  =     6  0  )     &  &     (  ( stats . getMax (  )  )     =  =     1  1  7  )  )     |  |     (  (  ( stats . getMin (  )  )     =  =     1  8  0  )     &  &     (  ( stats . getMax (  )  )     =  =     2  3  7  )  )  ;", "}  ;", "try    ( OrcRecordReader   reader    =    OrcTester . createCustomOrcRecordReader ( tempFile ,    OrcEncoding . ORC ,    predicate ,    BIGINT )  )     {", "assertEquals ( reader . getFileRowCount (  )  ,     1  0  0  )  ;", "assertEquals ( reader . getReaderRowCount (  )  ,     4  0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,     0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "assertEquals ( reader . nextBatch (  )  ,     2  0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,     2  0  )  ;", ". assertCurrentBatch ( reader ,     1  )  ;", "assertEquals ( reader . nextBatch (  )  ,     2  0  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     2  0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,     6  0  )  ;", ". assertCurrentBatch ( reader ,     3  )  ;", "assertEquals ( reader . nextBatch (  )  ,     (  -  1  )  )  ;", "assertEquals ( reader . getReaderPosition (  )  ,     4  0  )  ;", "assertEquals ( reader . getFilePosition (  )  ,     1  0  0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testStripeSkipping"], "fileName": "com.facebook.presto.orc.TestOrcReaderPositions"}, {"methodBody": ["METHOD_START", "{", "TempFile   tempFile    =    new   TempFile (  )  ;", "OrcWriter   writer    =    new   OrcWriter ( new   FileOutputStream ( tempFile . getFile (  )  )  ,    ImmutableList . of (  \" test 1  \"  ,     \" test 2  \"  ,     \" test 3  \"  ,     \" test 4  \"  ,     \" test 5  \"  )  ,    ImmutableList . of ( VARCHAR ,    VARCHAR ,    VARCHAR ,    VARCHAR ,    VARCHAR )  ,    OrcEncoding . ORC ,    CompressionKind . NONE ,    new   OrcWriterOptions (  )  . withStripeMaxSize ( new   DataSize (  3  2  ,    Unit . MEGABYTE )  )  . withStripeMaxRowCount ( TestingOrcPredicate . ORC _ STRIPE _ SIZE )  . withStripeMinRowCount ( TestingOrcPredicate . ORC _ STRIPE _ SIZE )  . withRowGroupMaxRowCount ( TestingOrcPredicate . ORC _ ROW _ GROUP _ SIZE )  . withDictionaryMaxMemory ( new   DataSize (  3  2  ,    Unit . MEGABYTE )  )  ,    ImmutableMap . of (  )  ,    OrcTester . HIVE _ STORAGE _ TIME _ ZONE ,    true ,    new   OrcWriterStats (  )  )  ;", "String [  ]    data    =    new   String [  ]  {     \" a \"  ,     \" bbbbb \"  ,     \" ccc \"  ,     \" dd \"  ,     \" eeee \"     }  ;", "Block [  ]    blocks    =    new   Block [ data . length ]  ;", "int   entries    =     6  5  5  3  6  ;", "BlockBuilder   blockBuilder    =    VARCHAR . createBlockBuilder ( null ,    entries )  ;", "for    ( int   i    =     0  ;    i    <     ( data . length )  ;    i +  +  )     {", "byte [  ]    bytes    =    data [ i ]  . getBytes (  )  ;", "for    ( int   j    =     0  ;    j    <    entries ;    j +  +  )     {", "bytes [  0  ]     =     (  ( byte )     (  (  ( bytes [  0  ]  )     +     1  )     %     1  2  8  )  )  ;", "blockBuilder . writeBytes ( Slices . wrappedBuffer ( bytes ,     0  ,    bytes . length )  ,     0  ,    bytes . length )  ;", "blockBuilder . closeEntry (  )  ;", "}", "blocks [ i ]     =    blockBuilder . build (  )  ;", "blockBuilder    =    blockBuilder . newBlockBuilderLike ( null )  ;", "}", "writer . write ( new   spi . Page ( blocks )  )  ;", "writer . close (  )  ;", "DataSize   dataSize    =    new   DataSize (  1  ,    Unit . MEGABYTE )  ;", "OrcDataSource   orcDataSource    =    new   FileOrcDataSource ( tempFile . getFile (  )  ,    dataSize ,    dataSize ,    dataSize ,    true )  ;", "Footer   footer    =    new   OrcReader ( orcDataSource ,    OrcEncoding . ORC ,    dataSize ,    dataSize ,    dataSize )  . getFooter (  )  ;", "for    ( StripeInformation   stripe    :    footer . getStripes (  )  )     {", "byte [  ]    tailBuffer    =    new   byte [ Math . toIntExact ( stripe . getFooterLength (  )  )  ]  ;", "orcDataSource . readFully (  (  (  ( stripe . getOffset (  )  )     +     ( stripe . getIndexLength (  )  )  )     +     ( stripe . getDataLength (  )  )  )  ,    tailBuffer )  ;", "try    ( InputStream   inputStream    =    new   OrcInputStream ( orcDataSource . getId (  )  ,    Slices . wrappedBuffer ( tailBuffer )  . getInput (  )  ,    Optional . empty (  )  ,    newSimpleAggregatedMemoryContext (  )  )  )     {", "StripeFooter   stripeFooter    =    OrcEncoding . ORC . createMetadataReader (  )  . readStripeFooter ( footer . getTypes (  )  ,    inputStream )  ;", "int   size    =     0  ;", "boolean   dataStreamStarted    =    false ;", "for    ( Stream   stream    :    stripeFooter . getStreams (  )  )     {", "if    ( StripeReader . isIndexStream ( stream )  )     {", "assertFalse ( dataStreamStarted )  ;", "continue ;", "}", "dataStreamStarted    =    true ;", "Assertions . assertGreaterThanOrEqual ( stream . getLength (  )  ,    size )  ;", "size    =    stream . getLength (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testWriteOutputStreamsInOrder"], "fileName": "com.facebook.presto.orc.TestOrcWriter"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics ( numberOfValues ,     1  0 L ,    null ,    null ,    null ,    null ,    null ,    null ,    new   BinaryStatistics (  1  0  0 L )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["binaryColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "BooleanStatistics   booleanStatistics    =    null ;", "if    ( trueValueCount    !  =    null )     {", "booleanStatistics    =    new   BooleanStatistics ( trueValueCount )  ;", "}", "return   new   ColumnStatistics ( numberOfValues ,     2 L ,    booleanStatistics ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["booleanColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics ( numberOfValues ,     5 L ,    null ,    null ,    null ,    null ,    new   DateStatistics ( minimum ,    maximum )  ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["dateColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "BigDecimal   minimumDecimal    =     ( minimum    =  =    null )     ?    null    :    new   BigDecimal ( minimum )  ;", "BigDecimal   maximumDecimal    =     ( maximum    =  =    null )     ?    null    :    new   BigDecimal ( maximum )  ;", "return   new   ColumnStatistics ( numberOfValues ,     9 L ,    null ,    null ,    null ,    null ,    null ,    new   DecimalStatistics ( minimumDecimal ,    maximumDecimal ,    ShortDecimalStatisticsBuilder . SHORT _ DECIMAL _ VALUE _ BYTES )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["decimalColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics ( numberOfValues ,     9 L ,    null ,    null ,    new   DoubleStatistics ( minimum ,    maximum )  ,    null ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["doubleColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics ( numberOfValues ,     9 L ,    null ,    new   IntegerStatistics ( minimum ,    maximum ,    null )  ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["integerColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   encodeScaledValue ( new   BigDecimal ( value )  )  ;", "}", "METHOD_END"], "methodName": ["longDecimal"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   BigDecimal ( value )  . unscaledValue (  )  . longValue (  )  ;", "}", "METHOD_END"], "methodName": ["shortDecimal"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "Slice   minimumSlice    =     ( minimum    =  =    null )     ?    null    :    utf 8 Slice ( minimum )  ;", "Slice   maximumSlice    =     ( maximum    =  =    null )     ?    null    :    utf 8 Slice ( maximum )  ;", "return   new   ColumnStatistics ( numberOfValues ,     1  0 L ,    null ,    null ,    null ,    new   StringStatistics ( minimumSlice ,    maximumSlice ,     1  0  0 L )  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["stringColumnStats"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     0  ,    null )  ,    none ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,    null )  ,    all ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     0  ,     . integerColumnStats ( null ,    null ,    null )  )  ,    none ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     0  ,     . integerColumnStats (  0 L ,    null ,    null )  )  ,    none ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     0  ,     . integerColumnStats (  0 L ,     1  0  0 L ,     1  0  0 L )  )  ,    none ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( BIGINT )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  1  0 L ,     1  0  0 L ,     1  0  0 L )  )  ,    singleValue ( BIGINT ,     1  0  0 L )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  1  0 L ,     0 L ,     1  0  0 L )  )  ,    create ( ValueSet . ofRanges ( range ( BIGINT ,     0 L ,    true ,     1  0  0 L ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  1  0 L ,    null ,     1  0  0 L )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( BIGINT ,     1  0  0 L )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  1  0 L ,     0 L ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( BIGINT ,     0 L )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  5 L ,     0 L ,     1  0  0 L )  )  ,    create ( ValueSet . ofRanges ( range ( BIGINT ,     0 L ,    true ,     1  0  0 L ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  5 L ,    null ,     1  0  0 L )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( BIGINT ,     1  0  0 L )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BIGINT ,     1  0  ,     . integerColumnStats (  5 L ,     0 L ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( BIGINT ,     0 L )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testBigint"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     0  ,    null )  ,    none ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     1  0  ,    null )  ,    all ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     0  ,     . binaryColumnStats ( null )  )  ,    none ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     0  ,     . binaryColumnStats (  0 L )  )  ,    none ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     0  ,     . binaryColumnStats (  0 L )  )  ,    none ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     1  0  ,     . binaryColumnStats (  0 L )  )  ,    onlyNull ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     1  0  ,     . binaryColumnStats (  1  0 L )  )  ,    notNull ( VARBINARY )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARBINARY ,     2  0  ,     . binaryColumnStats (  1  0 L )  )  ,    all ( VARBINARY )  )  ;", "}", "METHOD_END"], "methodName": ["testBinary"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     0  ,    null )  ,    none ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     1  0  ,    null )  ,    all ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     0  ,     . booleanColumnStats ( null ,    null )  )  ,    none ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     0  ,     . booleanColumnStats (  0 L ,    null )  )  ,    none ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     0  ,     . booleanColumnStats (  0 L ,     0 L )  )  ,    none ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     1  0  ,     . booleanColumnStats (  0 L ,     0 L )  )  ,    onlyNull ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     1  0  ,     . booleanColumnStats (  1  0 L ,    null )  )  ,    notNull ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     1  0  ,     . booleanColumnStats (  1  0 L ,     1  0 L )  )  ,    singleValue ( BOOLEAN ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     1  0  ,     . booleanColumnStats (  1  0 L ,     0 L )  )  ,    singleValue ( BOOLEAN ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     2  0  ,     . booleanColumnStats (  1  0 L ,     5 L )  )  ,    all ( BOOLEAN )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     2  0  ,     . booleanColumnStats (  1  0 L ,     1  0 L )  )  ,    create ( ValueSet . ofRanges ( Range . equal ( BOOLEAN ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( BOOLEAN ,     2  0  ,     . booleanColumnStats (  1  0 L ,     0 L )  )  ,    create ( ValueSet . ofRanges ( Range . equal ( BOOLEAN ,    false )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testBoolean"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     0  ,    null )  ,    none ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    null )  ,    all ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     0  ,    TestTupleDomainOrcPredicate . stringColumnStats ( null ,    null ,    null )  )  ,    none ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  0 L ,    null ,    null )  )  ,    none ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  0 L ,     \" taco                   \"  ,     \" taco                   \"  )  )  ,    none ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  0 L ,     \" taco \"  ,     \" taco                   \"  )  )  ,    none ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( TestTupleDomainOrcPredicate . CHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" taco                   \"  ,     \" taco                   \"  )  )  ,    singleValue ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" taco \"  ,     \" taco                   \"  )  )  ,    singleValue ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" apple                \"  ,     \" taco                   \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" apple                \"  ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,    null ,     \" taco                   \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,    null ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" apple                \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \" apple \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,     \" apple                \"  ,     \" taco                   \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,     \" apple                \"  ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,    null ,     \" taco                   \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,    null ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,     \" apple                \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  5 L ,     \" apple \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . CHAR ,     1  0  ,    TestTupleDomainOrcPredicate . stringColumnStats (  1  0 L ,     \"  \\ u 0  0  0  0     \"  ,     \"     \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . CHAR ,    utf 8 Slice (  \"  \\ u 0  0  0  0  \"  )  ,    true ,    utf 8 Slice (  \"  \"  )  ,    true )  )  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["testChar"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     0  ,    null )  ,    none ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,    null )  ,    all ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     0  ,     . dateColumnStats ( null ,    null ,    null )  )  ,    none ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     0  ,     . dateColumnStats (  0 L ,    null ,    null )  )  ,    none ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     0  ,     . dateColumnStats (  0 L ,     1  0  0  ,     1  0  0  )  )  ,    none ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( DATE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  1  0 L ,     1  0  0  ,     1  0  0  )  )  ,    singleValue ( DATE ,     1  0  0 L )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  1  0 L ,     0  ,     1  0  0  )  )  ,    create ( ValueSet . ofRanges ( range ( DATE ,     0 L ,    true ,     1  0  0 L ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  1  0 L ,    null ,     1  0  0  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( DATE ,     1  0  0 L )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  1  0 L ,     0  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( DATE ,     0 L )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  5 L ,     0  ,     1  0  0  )  )  ,    create ( ValueSet . ofRanges ( range ( DATE ,     0 L ,    true ,     1  0  0 L ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  5 L ,    null ,     1  0  0  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( DATE ,     1  0  0 L )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DATE ,     1  0  ,     . dateColumnStats (  5 L ,     0  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( DATE ,     0 L )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testDate"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     0  ,    null )  ,    none ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    null )  ,    all ( TestTupleDomainOrcPredicate . LONG _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     0  ,    TestTupleDomainOrcPredicate . decimalColumnStats ( null ,    null ,    null )  )  ,    none ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  0 L ,    null ,    null )  )  ,    none ( TestTupleDomainOrcPredicate . LONG _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  0 L ,     \"  -  9  9  9  .  9  9  \"  ,     \"  9  9  9  .  9  9  \"  )  )  ,    none ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( TestTupleDomainOrcPredicate . LONG _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  9  9  9  .  9  9  \"  ,     \"  9  9  9  .  9  9  \"  )  )  ,    singleValue ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  9  \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  9  9  9  .  9  \"  ,     \"  9  9  9  .  9  \"  )  )  ,    singleValue ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  0  \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  ,    singleValue ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  -  9  9  9  .  9  9  \"  ,     \"  9  9  9  .  9  9  \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  -  9  9  9  .  9  9  \"  )  ,    true ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  9  \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  1  0  .  5  \"  ,     \"  2  0  \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  1  0  .  5  0  \"  )  ,    true ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  2  0  .  0  0  \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,    null ,     \"  9  9  9  .  9  9  \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  9  \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  -  9  9  9  .  9  9  \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  -  9  9  9  .  9  9  \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  ,    true ,    TestTupleDomainOrcPredicate . longDecimal (  \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,    null ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  1  0 L ,     \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,     \"  -  9  9  9  .  9  9  \"  ,     \"  9  9  9  .  9  9  \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  -  9  9  9  .  9  9  \"  )  ,    true ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  9  \"  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,    null ,     \"  9  9  9  .  9  9  \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  9  9  9  .  9  9  \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,     \"  -  9  9  9  .  9  9  \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . SHORT _ DECIMAL ,    TestTupleDomainOrcPredicate . shortDecimal (  \"  -  9  9  9  .  9  9  \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,     \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  ,    create ( ValueSet . ofRanges ( range ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  ,    true ,    TestTupleDomainOrcPredicate . longDecimal (  \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,    null ,     \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,     1  0  ,    TestTupleDomainOrcPredicate . decimalColumnStats (  5 L ,     \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( TestTupleDomainOrcPredicate . LONG _ DECIMAL ,    TestTupleDomainOrcPredicate . longDecimal (  \"  -  1  2  3  4  5  6  7  8  9  0  .  0  9  8  7  6  5  4  3  2  1  \"  )  )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testDecimal"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     0  ,    null )  ,    none ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,    null )  ,    all ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     0  ,     . doubleColumnStats ( null ,    null ,    null )  )  ,    none ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     0  ,     . doubleColumnStats (  0 L ,    null ,    null )  )  ,    none ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     0  ,     . doubleColumnStats (  0 L ,     4  2  .  2  4  ,     4  2  .  2  4  )  )  ,    none ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( DOUBLE )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  1  0 L ,     4  2  .  2  4  ,     4  2  .  2  4  )  )  ,    singleValue ( DOUBLE ,     4  2  .  2  4  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  1  0 L ,     3  .  3  ,     4  2  .  2  4  )  )  ,    create ( ValueSet . ofRanges ( range ( DOUBLE ,     3  .  3  ,    true ,     4  2  .  2  4  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  1  0 L ,    null ,     4  2  .  2  4  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( DOUBLE ,     4  2  .  2  4  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  1  0 L ,     3  .  3  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( DOUBLE ,     3  .  3  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  5 L ,     3  .  3  ,     4  2  .  2  4  )  )  ,    create ( ValueSet . ofRanges ( range ( DOUBLE ,     3  .  3  ,    true ,     4  2  .  2  4  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  5 L ,    null ,     4  2  .  2  4  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( DOUBLE ,     4  2  .  2  4  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( DOUBLE ,     1  0  ,     . doubleColumnStats (  5 L ,     3  .  3  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( DOUBLE ,     3  .  3  )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testDouble"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     0  ,    null )  ,    none ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,    null )  ,    all ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     0  ,     . doubleColumnStats ( null ,    null ,    null )  )  ,    none ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     0  ,     . doubleColumnStats (  0 L ,    null ,    null )  )  ,    none ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     0  ,     . doubleColumnStats (  0 L ,     (  ( double )     (  4  2  .  2  4 F )  )  ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    none ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( REAL )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  1  0 L ,     (  ( double )     (  4  2  .  2  4 F )  )  ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    singleValue ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  4  2  .  2  4 F )  )  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  1  0 L ,     3  .  3  ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    create ( ValueSet . ofRanges ( range ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  3  .  3 F )  )  )  ,    true ,     (  ( long )     ( Float . floatToRawIntBits (  4  2  .  2  4 F )  )  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  1  0 L ,    null ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  4  2  .  2  4 F )  )  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  1  0 L ,     3  .  3  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  3  .  3 F )  )  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  5 L ,     3  .  3  ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    create ( ValueSet . ofRanges ( range ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  3  .  3 F )  )  )  ,    true ,     (  ( long )     ( Float . floatToRawIntBits (  4  2  .  2  4 F )  )  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  5 L ,    null ,     (  ( double )     (  4  2  .  2  4 F )  )  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  4  2  .  2  4 F )  )  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( REAL ,     1  0  ,     . doubleColumnStats (  5 L ,     3  .  3  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( REAL ,     (  ( long )     ( Float . floatToRawIntBits (  3  .  3 F )  )  )  )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testFloat"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     0  ,    null )  ,    none ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,    null )  ,    all ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     0  ,     . stringColumnStats ( null ,    null ,    null )  )  ,    none ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     0  ,     . stringColumnStats (  0 L ,    null ,    null )  )  ,    none ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     0  ,     . stringColumnStats (  0 L ,     \" taco \"  ,     \" taco \"  )  )  ,    none ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  0 L ,    null ,    null )  )  ,    onlyNull ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  1  0 L ,    null ,    null )  )  ,    notNull ( VARCHAR )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  1  0 L ,     \" taco \"  ,     \" taco \"  )  )  ,    singleValue ( VARCHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  1  0 L ,     \" apple \"  ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( range ( VARCHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  1  0 L ,    null ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( VARCHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  1  0 L ,     \" apple \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( VARCHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    false )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  5 L ,     \" apple \"  ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( range ( VARCHAR ,    utf 8 Slice (  \" apple \"  )  ,    true ,    utf 8 Slice (  \" taco \"  )  ,    true )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  5 L ,    null ,     \" taco \"  )  )  ,    create ( ValueSet . ofRanges ( lessThanOrEqual ( VARCHAR ,    utf 8 Slice (  \" taco \"  )  )  )  ,    true )  )  ;", "assertEquals ( TupleDomainOrcPredicate . getDomain ( VARCHAR ,     1  0  ,     . stringColumnStats (  5 L ,     \" apple \"  ,    null )  )  ,    create ( ValueSet . ofRanges ( greaterThanOrEqual ( VARCHAR ,    utf 8 Slice (  \" apple \"  )  )  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testString"], "fileName": "com.facebook.presto.orc.TestTupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   lastReadRanges ;", "}", "METHOD_END"], "methodName": ["getLastReadRanges"], "fileName": "com.facebook.presto.orc.TestingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "return   readCount ;", "}", "METHOD_END"], "methodName": ["getReadCount"], "fileName": "com.facebook.presto.orc.TestingOrcDataSource"}, {"methodBody": ["METHOD_START", "{", "List < Object >    expectedValues    =    newArrayList ( values )  ;", "if    ( BOOLEAN . equals ( type )  )     {", "return   new    . BooleanOrcPredicate ( expectedValues ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    (  (  (  ( TINYINT . equals ( type )  )     |  |     ( SMALLINT . equals ( type )  )  )     |  |     ( INTEGER . equals ( type )  )  )     |  |     ( BIGINT . equals ( type )  )  )     {", "return   new    . LongOrcPredicate ( expectedValues . stream (  )  . map (  (    value )     -  >    value    =  =    null    ?    null    :     (  ( Number )     ( value )  )  . longValue (  )  )  . collect ( Collectors . toList (  )  )  ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    ( TIMESTAMP . equals ( type )  )     {", "return   new    . LongOrcPredicate ( expectedValues . stream (  )  . map (  (    value )     -  >    value    =  =    null    ?    null    :     (  ( SqlTimestamp )     ( value )  )  . getMillisUtc (  )  )  . collect ( Collectors . toList (  )  )  ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    ( DATE . equals ( type )  )     {", "return   new    . DateOrcPredicate ( expectedValues . stream (  )  . map (  (    value )     -  >    value    =  =    null    ?    null    :     (  ( long )     (  (  ( SqlDate )     ( value )  )  . getDays (  )  )  )  )  . collect ( Collectors . toList (  )  )  ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    (  ( REAL . equals ( type )  )     |  |     ( DOUBLE . equals ( type )  )  )     {", "return   new    . DoubleOrcPredicate ( expectedValues . stream (  )  . map (  (    value )     -  >    value    =  =    null    ?    null    :     (  ( Number )     ( value )  )  . doubleValue (  )  )  . collect ( Collectors . toList (  )  )  ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    ( type   instanceof   VarbinaryType )     {", "return   new    . BasicOrcPredicate <  >  ( expectedValues ,    Object . class ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    ( type   instanceof   VarcharType )     {", "return   new    . StringOrcPredicate ( expectedValues ,    format ,    isHiveWriter )  ;", "}", "if    ( type   instanceof   CharType )     {", "return   new    . CharOrcPredicate ( expectedValues ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "if    ( type   instanceof   DecimalType )     {", "return   new    . DecimalOrcPredicate ( expectedValues ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "String   baseType    =    type . getTypeSignature (  )  . getBase (  )  ;", "if    (  (  ( ARRAY . equals ( baseType )  )     |  |     ( MAP . equals ( baseType )  )  )     |  |     ( ROW . equals ( baseType )  )  )     {", "return   new    . BasicOrcPredicate <  >  ( expectedValues ,    Object . class ,     ( format    =  =     ( OrcTester . Format . DWRF )  )  )  ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   type    \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["createOrcPredicate"], "fileName": "com.facebook.presto.orc.TestingOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( sqlType    =  =     ( TINYINT )  )     |  |     ( sqlType    =  =     ( SMALLINT )  )  )     |  |     ( sqlType    =  =     ( INTEGER )  )  )     |  |     ( sqlType    =  =     ( BIGINT )  )  )     {", "return   bloomFilter . testLong (  (  ( Number )     ( pValue )  )  . longValue (  )  )  ;", "}", "if    ( sqlType    =  =     ( DOUBLE )  )     {", "return   bloomFilter . testDouble (  (  ( Double )     ( pValue )  )  )  ;", "}", "if    (  ( sqlType   instanceof   VarcharType )     |  |     ( sqlType   instanceof   VarbinaryType )  )     {", "return   bloomFilter . test (  (  ( Slice )     ( pValue )  )  . getBytes (  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["checkInBloomFilter"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "Domain   stripeDomain    =    TupleDomainOrcPredicate . getDomain ( columnReference . getType (  )  ,    numberOfRows ,    columnStatistics )  ;", "if    (  !  ( stripeDomain . overlaps ( predicateDomain )  )  )     {", "return   false ;", "}", "if    (  !  ( orcBloomFiltersEnabled )  )     {", "return   true ;", "}", "if    (  ( predicateDomain . isNullAllowed (  )  )     &  &     ( stripeDomain . isNullAllowed (  )  )  )     {", "return   true ;", "}", "Optional < Collection < Object >  >    discreteValues    =    TupleDomainOrcPredicate . extractDiscreteValues ( predicateDomain . getValues (  )  )  ;", "if    (  !  ( discreteValues . isPresent (  )  )  )     {", "return   true ;", "}", "HiveBloomFilter   bloomFilter    =    columnStatistics . getBloomFilter (  )  ;", "if    ( bloomFilter    =  =    null )     {", "return   true ;", "}", "if    ( discreteValues . get (  )  . stream (  )  . noneMatch (  (    value )     -  >    TupleDomainOrcPredicate . checkInBloomFilter ( bloomFilter ,    value ,    stripeDomain . getType (  )  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["columnOverlaps"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   TupleDomainOrcPredicate . createDomain ( type ,    hasNullValue ,    rangeStatistics ,     (    value )     -  >    value )  ;", "}", "METHOD_END"], "methodName": ["createDomain"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "F   min    =    rangeStatistics . getMin (  )  ;", "F   max    =    rangeStatistics . getMax (  )  ;", "if    (  ( min    !  =    null )     &  &     ( max    !  =    null )  )     {", "return    . create ( ValueSet . ofRanges ( Range . range ( type ,    function . apply ( min )  ,    true ,    function . apply ( max )  ,    true )  )  ,    hasNullValue )  ;", "}", "if    ( max    !  =    null )     {", "return    . create ( ValueSet . ofRanges ( Range . lessThanOrEqual ( type ,    function . apply ( max )  )  )  ,    hasNullValue )  ;", "}", "if    ( min    !  =    null )     {", "return    . create ( ValueSet . ofRanges ( Range . greaterThanOrEqual ( type ,    function . apply ( min )  )  )  ,    hasNullValue )  ;", "}", "return    . create ( ValueSet . all ( type )  ,    hasNullValue )  ;", "}", "METHOD_END"], "methodName": ["createDomain"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   valueSet . getValuesProcessor (  )  . transform (  (    ranges )     -  >     {", "ImmutableList . Builder < Object >    discreteValues    =    ImmutableList . builder (  )  ;", "for    ( Range   range    :    ranges . getOrdeRanges (  )  )     {", "if    (  !  ( range . isSingleValue (  )  )  )     {", "return   Optional . empty (  )  ;", "}", "discreteValues . add ( range . getSingleValue (  )  )  ;", "}", "return   Optional . of ( discreteValues . build (  )  )  ;", "}  ,     (    discreteValues )     -  >    Optional . of ( discreteValues . getValues (  )  )  ,     (    allOrNone )     -  >    allOrNone . isAll (  )     ?    Optional . empty (  )     :    Optional . of ( ImmutableList . of (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extractDiscreteValues"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "if    ( rowCount    =  =     0  )     {", "return   Domain . none ( type )  ;", "}", "if    ( columnStatistics    =  =    null )     {", "return   Domain . all ( type )  ;", "}", "if    (  ( columnStatistics . hasNumberOfValues (  )  )     &  &     (  ( columnStatistics . getNumberOfValues (  )  )     =  =     0  )  )     {", "return   Domain . onlyNull ( type )  ;", "}", "boolean   hasNullValue    =     ( columnStatistics . getNumberOfValues (  )  )     !  =    rowCount ;", "if    (  (  ( type . getJavaType (  )  )     =  =     ( boolean . class )  )     &  &     (  ( columnStatistics . getBooleanStatistics (  )  )     !  =    null )  )     {", "BooleanStatistics   booleanStatistics    =    columnStatistics . getBooleanStatistics (  )  ;", "boolean   hasTrueValues    =     ( booleanStatistics . getTrueValueCount (  )  )     !  =     0  ;", "boolean   hasFalseValues    =     ( columnStatistics . getNumberOfValues (  )  )     !  =     ( booleanStatistics . getTrueValueCount (  )  )  ;", "if    ( hasTrueValues    &  &    hasFalseValues )     {", "return   Domain . all ( BOOLEAN )  ;", "}", "if    ( hasTrueValues )     {", "return   Domain . create ( ValueSet . of ( BOOLEAN ,    true )  ,    hasNullValue )  ;", "}", "if    ( hasFalseValues )     {", "return   Domain . create ( ValueSet . of ( BOOLEAN ,    false )  ,    hasNullValue )  ;", "}", "} else", "if    (  ( isShortDecimal ( type )  )     &  &     (  ( columnStatistics . getDecimalStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getDecimalStatistics (  )  ,     (    value )     -  >    rescale ( value ,     (  ( com . facebook . presto . spi . type . DecimalType )     ( type )  )  )  . unscaledValue (  )  . longValue (  )  )  ;", "} else", "if    (  ( isLongDecimal ( type )  )     &  &     (  ( columnStatistics . getDecimalStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getDecimalStatistics (  )  ,     (    value )     -  >    encodeUnscaledValue ( rescale ( value ,     (  ( com . facebook . presto . spi . type . DecimalType )     ( type )  )  )  . unscaledValue (  )  )  )  ;", "} else", "if    (  ( isCharType ( type )  )     &  &     (  ( columnStatistics . getStringStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getStringStatistics (  )  ,     (    value )     -  >    truncateToLengthAndTrimSpaces ( value ,    type )  )  ;", "} else", "if    (  ( isVarcharType ( type )  )     &  &     (  ( columnStatistics . getStringStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getStringStatistics (  )  )  ;", "} else", "if    (  ( type . getTypeSignature (  )  . getBase (  )  . equals ( StandardTypes . DATE )  )     &  &     (  ( columnStatistics . getDateStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getDateStatistics (  )  ,     (    value )     -  >     (  ( long )     ( value )  )  )  ;", "} else", "if    (  (  ( type . getJavaType (  )  )     =  =     ( long . class )  )     &  &     (  ( columnStatistics . getIntegerStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getIntegerStatistics (  )  )  ;", "} else", "if    (  (  ( type . getJavaType (  )  )     =  =     ( double . class )  )     &  &     (  ( columnStatistics . getDoubleStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getDoubleStatistics (  )  )  ;", "} else", "if    (  ( REAL . equals ( type )  )     &  &     (  ( columnStatistics . getDoubleStatistics (  )  )     !  =    null )  )     {", "return    . createDomain ( type ,    hasNullValue ,    columnStatistics . getDoubleStatistics (  )  ,     (    value )     -  >     (  ( long )     ( floatToRawIntBits ( value . floatValue (  )  )  )  )  )  ;", "}", "return   Domain . create ( ValueSet . all ( type )  ,    hasNullValue )  ;", "}", "METHOD_END"], "methodName": ["getDomain"], "fileName": "com.facebook.presto.orc.TupleDomainOrcPredicate"}, {"methodBody": ["METHOD_START", "{", "return   byteStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getByteStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.BooleanStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.checkpoint.BooleanStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList .  < Integer > builder (  )  . addAll ( byteStreamCheckpoint . toPositionList ( compressed )  )  . add ( offset )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.BooleanStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.ByteArrayStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   InputStreamCheckpoint . createInputStreamPositionList ( compressed ,    inputStreamCheckpoint )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.ByteArrayStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.ByteStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.checkpoint.ByteStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList .  < Integer > builder (  )  . addAll ( InputStreamCheckpoint . createInputStreamPositionList ( compressed ,    inputStreamCheckpoint )  )  . add ( offset )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.ByteStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT _ V 2  )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )  )     {", "return   new   LongStreamV 2  ( compressed ,    positionsList )  ;", "}", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )  )     {", "return   new   LongStreamV 1  ( compressed ,    positionsList )  ;", "}", "if    ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DWRF _ DIRECT )  )     {", "return   new   LongStreamDwrf ( compressed ,    positionsList )  ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   encoding   for   long   stream :     \"     +    encoding )  )  ;", "}", "METHOD_END"], "methodName": ["createLongStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getBooleanColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   ByteStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getByteColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   DecimalStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . SECONDARY )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . SECONDARY )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDecimalColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DICTIONARY _ DATA )  )     {", "switch    ( columnType )     {", "case   SHORT    :", "case   INT    :", "case   LONG    :", "return   new   LongStreamDwrfCInputStreamCcreateInputStreamC 0  ,     0  )  )  ;", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "return   new   ByteArrayStreamCInputStreamCcreateInputStreamC 0  ,     0  )  )  ;", "}", "}", "if    (  (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . LENGTH )  )     |  |     (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DATA )  )  )     {", "if    ( columnEncoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )     {", "return   new   LongStreamV 2 C 0  ,    InputStreamCcreateInputStreamC 0  ,     0  )  )  ;", "} else", "if    ( columnEncoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )     {", "return   new   LongStreamV 1 C 0  ,    InputStreamCcreateInputStreamC 0  ,     0  )  )  ;", "}", "}", "throw   new   IllegalArgumentException (  (  (  (  \" Unsupported   column   type    \"     +    columnType )     +     \"    for   dictionary   stream    \"  )     +    streamId )  )  ;", "}", "METHOD_END"], "methodName": ["getDictionaryStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   DoubleStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDoubleColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   FloatStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getFloatColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . LENGTH )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . LENGTH )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getListOrMapColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . IN _ DICTIONARY )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . IN _ DICTIONARY )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getLongColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT _ V 2  )  )  )     {", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,    new   ByteArrayStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . LENGTH )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . LENGTH )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "} else", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )  )     {", "if    ( availableStreams . contains ( Stream . StreamKind . IN _ DICTIONARY )  )     {", "if    ( availableStreams . contains ( Stream . StreamKind . ROW _ GROUP _ DICTIONARY )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . ROW _ GROUP _ DICTIONARY )  ,    new   ByteArrayStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . ROW _ GROUP _ DICTIONARY _ LENGTH )  ,    new   RowGroupDictionaryLengthStreamCheckpoint ( compressed ,    positionsList )  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . IN _ DICTIONARY )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "} else    {", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "}", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   encoding   for   slice   column :     \"     +    encoding )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getSliceColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < Integer ,    Stream . StreamKind >    streamKindsBuilder    =    ImmutableSetMultimap . builder (  )  ;", "for    ( Stream   stream    :    streams . values (  )  )     {", "streamKindsBuilder . put ( stream . getColumn (  )  ,    stream . getStreamKind (  )  )  ;", "}", "SetMultimap < Integer ,    Stream . StreamKind >    streamKinds    =    streamKindsBuilder . build (  )  ;", "ImmutableMap . Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "for    ( int   column    :    columns )     {", "List < Integer >    positionsList    =    columnIndexes . get ( column )  . get ( rowGroupId )  . getPositions (  )  ;", "ColumnEncoding . ColumnEncodingKind   columnEncoding    =    columnEncodings . get ( column )  . getColumnEncodingKind (  )  ;", "OrcType . OrcTypeKind   columnType    =    columnTypes . get ( column )  . getOrcTypeKind (  )  ;", "Set < Stream . StreamKind >    availableStreams    =    streamKinds . get ( column )  ;", ". ColumnPositionsList   columnPositionsList    =    new    . ColumnPositionsList ( column ,    columnType ,    positionsList )  ;", "switch    ( columnType )     {", "case   BOOLEAN    :", "checkpoints . putAll (  . getBooleanColumn ( column ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   BYTE    :", "checkpoints . putAll (  . getByteColumn ( column ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   SHORT    :", "case   INT    :", "case   LONG    :", "case   DATE    :", "checkpoints . putAll (  . getLongColumn ( column ,    columnEncoding ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   FLOAT    :", "checkpoints . putAll (  . getFloatColumn ( column ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   DOUBLE    :", "checkpoints . putAll (  . getDoubleColumn ( column ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   TIMESTAMP    :", "checkpoints . putAll (  . getTimestampColumn ( column ,    columnEncoding ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   BINARY    :", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "checkpoints . putAll (  . getSliceColumn ( column ,    columnEncoding ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   LIST    :", "case   MAP    :", "checkpoints . putAll (  . getListOrMapColumn ( column ,    columnEncoding ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   STRUCT    :", "checkpoints . putAll (  . getStructColumn ( column ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   DECIMAL    :", "checkpoints . putAll (  . getDecimalColumn ( column ,    columnEncoding ,    compressed ,    availableStreams ,    columnPositionsList )  )  ;", "break ;", "case   UNION    :", "throw   new   IllegalArgumentException (  (  \" Unsupported   column   type    \"     +    columnType )  )  ;", "}", "if    (  ( columnPositionsList . hasNextPosition (  )  )     &  &     (  !  ( Iterables . all ( positionsList ,    equalTo (  0  )  )  )  )  )     {", "throw   new   InvalidCheckpointException ( String . format (  \" Column    % s ,    of   type    % s ,    contains    % s   offset   positions ,    but   only    % s   positions   were   consumed \"  ,    column ,    columnType ,    positionsList . size (  )  ,    columnPositionsList . getIndex (  )  )  )  ;", "}", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getStreamCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getStructColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "Builder < StreamId ,    StreamCheckpoint >    checkpoints    =    ImmutableMap . builder (  )  ;", "if    ( availableStreams . contains ( Stream . StreamKind . PRESENT )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . PRESENT )  ,    new   BooleanStreamCheckpoint ( compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . DATA )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . DATA )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "if    ( availableStreams . contains ( Stream . StreamKind . SECONDARY )  )     {", "checkpoints . put ( new   StreamId ( column ,    Stream . StreamKind . SECONDARY )  ,     . createLongStreamCheckpoint ( encoding ,    compressed ,    positionsList )  )  ;", "}", "return   checkpoints . build (  )  ;", "}", "METHOD_END"], "methodName": ["getTimestampColumnCheckpoints"], "fileName": "com.facebook.presto.orc.checkpoint.Checkpoints"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.DecimalStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   InputStreamCheckpoint . createInputStreamPositionList ( compressed ,    inputStreamCheckpoint )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.DecimalStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.DoubleStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   InputStreamCheckpoint . createInputStreamPositionList ( compressed ,    inputStreamCheckpoint )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.DoubleStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.FloatStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   InputStreamCheckpoint . createInputStreamPositionList ( compressed ,    inputStreamCheckpoint )  ;", "}", "METHOD_END"], "methodName": ["toPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.FloatStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "if    ( compressed )     {", "return    . create ( positionsList . nextPosition (  )  ,    positionsList . nextPosition (  )  )  ;", "} else    {", "return    . create (  0  ,    positionsList . nextPosition (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( long )     ( compressedBlockOffset )  )     <  <     3  2  )     |    decompressedOffset ;", "}", "METHOD_END"], "methodName": ["createInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "if    ( compressed )     {", "return   ImmutableList . of (  . decodeCompressedBlockOffset ( inputStreamCheckpoint )  ,     . decodeDecompressedOffset ( inputStreamCheckpoint )  )  ;", "} else    {", "return   ImmutableList . of (  . decodeDecompressedOffset ( inputStreamCheckpoint )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createInputStreamPositionList"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( inputStreamCheckpoint    >  >     3  2  )  )  ;", "}", "METHOD_END"], "methodName": ["decodeCompressedBlockOffset"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     ( inputStreamCheckpoint )  )  ;", "}", "METHOD_END"], "methodName": ["decodeDecompressedOffset"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   toStringHelper ( InputStreamCheckpoint . class )  . add (  \" decompressedOffset \"  ,    InputStreamCheckpoint . decodeDecompressedOffset ( inputStreamCheckpoint )  )  . add (  \" compressedBlockOffset \"  ,    InputStreamCheckpoint . decodeCompressedBlockOffset ( inputStreamCheckpoint )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["inputStreamCheckpointToString"], "fileName": "com.facebook.presto.orc.checkpoint.InputStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.LongStreamDwrfCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.LongStreamV1Checkpoint"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.checkpoint.LongStreamV1Checkpoint"}, {"methodBody": ["METHOD_START", "{", "return   inputStreamCheckpoint ;", "}", "METHOD_END"], "methodName": ["getInputStreamCheckpoint"], "fileName": "com.facebook.presto.orc.checkpoint.LongStreamV2Checkpoint"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.checkpoint.LongStreamV2Checkpoint"}, {"methodBody": ["METHOD_START", "{", "return   rowGroupDictionarySize ;", "}", "METHOD_END"], "methodName": ["getRowGroupDictionarySize"], "fileName": "com.facebook.presto.orc.checkpoint.RowGroupDictionaryLengthStreamCheckpoint"}, {"methodBody": ["METHOD_START", "{", "return   columnEncodingKind ;", "}", "METHOD_END"], "methodName": ["getColumnEncodingKind"], "fileName": "com.facebook.presto.orc.metadata.ColumnEncoding"}, {"methodBody": ["METHOD_START", "{", "return   dictionarySize ;", "}", "METHOD_END"], "methodName": ["getDictionarySize"], "fileName": "com.facebook.presto.orc.metadata.ColumnEncoding"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( binaryStatistics . hasSum (  )  )  )     {", "return   null ;", "}", "return   new   BinaryStatistics ( binaryStatistics . getSum (  )  )  ;", "}", "METHOD_END"], "methodName": ["toBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bucketStatistics . getCountCount (  )  )     =  =     0  )     {", "return   null ;", "}", "return   new   BooleanStatistics ( bucketStatistics . getCount (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnEncoding ( DwrfMetadataReader . toColumnEncodingKind ( type ,    columnEncoding . getKind (  )  )  ,    columnEncoding . getDictionarySize (  )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  ( types . size (  )  )     =  =     ( columnEncodings . size (  )  )  )  )  ;", "ImmutableList . Builder < ColumnEncoding >    encodings    =    ImmutableList . builder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( types . size (  )  )  ;    i +  +  )     {", "OrcType   type    =    types . get ( i )  ;", "encodings . add (  . toColumnEncoding ( type . getOrcTypeKind (  )  ,    columnEncodings . get ( i )  )  )  ;", "}", "return   encodings . build (  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( kind )     {", "case   DIRECT    :", "if    (  (  ( type    =  =     ( OType . OTypeKind . SHORT )  )     |  |     ( type    =  =     ( OType . OTypeKind . INT )  )  )     |  |     ( type    =  =     ( OType . OTypeKind . LONG )  )  )     {", "return   ColumnEncoding . ColumnEncodingKind . DWRF _ DIRECT ;", "} else    {", "return   ColumnEncoding . ColumnEncodingKind . DIRECT ;", "}", "case   DICTIONARY    :", "return   ColumnEncoding . ColumnEncodingKind . DICTIONARY ;", "default    :", "throw   new   IllegalArgumentException (  ( kind    +     \"    stream   encoding   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toColumnEncodingKind"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "long   minAverageValueBytes ;", "if    ( statistics . hasBucketStatistics (  )  )     {", "minAverageValueBytes    =    BooleanStatistics . BOOLEAN _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasIntStatistics (  )  )     {", "minAverageValueBytes    =    statistics . IntegerStatistics . INTEGER _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasDoubleStatistics (  )  )     {", "minAverageValueBytes    =    statistics . DoubleStatistics . DOUBLE _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasStringStatistics (  )  )     {", "minAverageValueBytes    =    statistics . StringStatistics . STRING _ VALUE _ BYTES _ OVERHEAD ;", "if    (  ( statistics . hasNumberOfValues (  )  )     &  &     (  ( statistics . getNumberOfValues (  )  )     >     0  )  )     {", "minAverageValueBytes    +  =     ( statistics . getStringStatistics (  )  . getSum (  )  )     /     ( statistics . getNumberOfValues (  )  )  ;", "}", "} else", "if    ( statistics . hasBinaryStatistics (  )  )     {", "minAverageValueBytes    =    statistics . BinaryStatistics . BINARY _ VALUE _ BYTES _ OVERHEAD ;", "if    (  ( statistics . hasNumberOfValues (  )  )     &  &     (  ( statistics . getNumberOfValues (  )  )     >     0  )  )     {", "minAverageValueBytes    +  =     ( statistics . getBinaryStatistics (  )  . getSum (  )  )     /     ( statistics . getNumberOfValues (  )  )  ;", "}", "} else    {", "minAverageValueBytes    =     0  ;", "}", "return   new   ColumnStatistics ( statistics . getNumberOfValues (  )  ,    minAverageValueBytes ,    DwrfMetadataReader . toBooleanStatistics ( statistics . getBucketStatistics (  )  )  ,    DwrfMetadataReader . toIntegerStatistics ( statistics . getIntStatistics (  )  )  ,    DwrfMetadataReader . toDoubleStatistics ( statistics . getDoubleStatistics (  )  )  ,    DwrfMetadataReader . toStringStatistics ( hiveWriterVersion ,    statistics . getStringStatistics (  )  ,    isRowGroup )  ,    null ,    null ,    DwrfMetadataReader . toBinaryStatistics ( statistics . getBinaryStatistics (  )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    ( columnStatistics    =  =    null )     {", "return   ImmutableList . of (  )  ;", "}", "return   ImmutableList . copyOf ( Iterables . transform ( columnStatistics ,     (    statistics )     -  >    toColumnStatistics ( hiveWriterVersion ,    statistics ,    isRowGroup )  )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( compression )     {", "case   NONE    :", "return   CompressionKind . NONE ;", "case   ZLIB    :", "return   CompressionKind . ZLIB ;", "case   SNAPPY    :", "return   CompressionKind . SNAPPY ;", "case   LZ 4     :", "return   CompressionKind . LZ 4  ;", "case   ZSTD    :", "return   CompressionKind . ZSTD ;", "default    :", "throw   new   IllegalArgumentException (  ( compression    +     \"    compression   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toCompression"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( doubleStatistics . hasMinimum (  )  )  )     &  &     (  !  ( doubleStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "if    (  (  (  ( doubleStatistics . hasMinimum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getMinimum (  )  )  )  )     |  |     (  ( doubleStatistics . hasMaximum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getMaximum (  )  )  )  )  )     |  |     (  ( doubleStatistics . hasSum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getSum (  )  )  )  )  )     {", "return   null ;", "}", "return   new   DoubleStatistics (  ( doubleStatistics . hasMinimum (  )     ?    doubleStatistics . getMinimum (  )     :    null )  ,     ( doubleStatistics . hasMaximum (  )     ?    doubleStatistics . getMaximum (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["toDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( integerStatistics . hasMinimum (  )  )  )     &  &     (  !  ( integerStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "return   new   IntegerStatistics (  ( integerStatistics . hasMinimum (  )     ?    integerStatistics . getMinimum (  )     :    null )  ,     ( integerStatistics . hasMaximum (  )     ?    integerStatistics . getMaximum (  )     :    null )  ,     ( integerStatistics . hasSum (  )     ?    integerStatistics . getSum (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["toIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "List < Long >    positionsList    =    rowIndexEntry . getPositionsList (  )  ;", "ImmutableList . Builder < Integer >    positions    =    ImmutableList . builder (  )  ;", "for    ( int   index    =     0  ;    index    <     ( positionsList . size (  )  )  ;    index +  +  )     {", "long   longPosition    =    positionsList . get ( index )  ;", "int   intPosition    =     (  ( int )     ( longPosition )  )  ;", "checkState (  ( intPosition    =  =    longPosition )  ,     \" Expected   checkpoint   position    % s ,    to   be   an   integer \"  ,    index )  ;", "positions . add ( intPosition )  ;", "}", "return   new   RowGroupIndex ( positions . build (  )  ,     . toColumnStatistics ( hiveWriterVersion ,    rowIndexEntry . getStatistics (  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["toRowGroupIndex"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   Stream ( stream . getColumn (  )  ,    DwrfMetadataReader . toStreamKind ( stream . getKind (  )  )  ,    Math . toIntExact ( stream . getLength (  )  )  ,    stream . getUseVInts (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . copyOf ( Iterables . transform ( streams ,    DwrfMetadataReader :  : toStream )  )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( kind )     {", "case   PRESENT    :", "turn   Stam . StamKind . PRESENT ;", "case   DATA    :", "turn   Stam . StamKind . DATA ;", "case   LENGTH    :", "turn   Stam . StamKind . LENGTH ;", "case   DICTIONARY _ DATA    :", "turn   Stam . StamKind . DICTIONARY _ DATA ;", "case   DICTIONARY _ COUNT    :", "turn   Stam . StamKind . DICTIONARY _ COUNT ;", "case   NANO _ DATA    :", "turn   Stam . StamKind . SECONDARY ;", "case   ROW _ INDEX    :", "turn   Stam . StamKind . ROW _ INDEX ;", "case   IN _ DICTIONARY    :", "turn   Stam . StamKind . IN _ DICTIONARY ;", "case   STRIDE _ DICTIONARY    :", "turn   Stam . StamKind . ROW _ GROUP _ DICTIONARY ;", "case   STRIDE _ DICTIONARY _ LENGTH    :", "turn   Stam . StamKind . ROW _ GROUP _ DICTIONARY _ LENGTH ;", "default    :", "throw   new   IllegalArgumentException (  ( kind    +     \"    stam   type   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toStreamKind"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hiveWriterVersion    =  =     ( PostScript . HiveWriterVersion . ORIGINAL )  )     &  &     (  ! isRowGroup )  )     {", "return   null ;", "}", "if    (  (  !  ( stringStatistics . hasMinimum (  )  )  )     &  &     (  !  ( stringStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "Slice   maximum    =     ( stringStatistics . hasMaximum (  )  )     ?    Orc . maxStringTruncateToValidRange ( Orc . byteStringToSlice ( stringStatistics . getMaximumBytes (  )  )  ,    hiveWriterVersion )     :    null ;", "Slice   minimum    =     ( stringStatistics . hasMinimum (  )  )     ?    Orc . minStringTruncateToValidRange ( Orc . byteStringToSlice ( stringStatistics . getMinimumBytes (  )  )  ,    hiveWriterVersion )     :    null ;", "long   sum    =     ( stringStatistics . hasSum (  )  )     ?    stringStatistics . getSum (  )     :     0  ;", "return   new   StringStatistics ( minimum ,    maximum ,    sum )  ;", "}", "METHOD_END"], "methodName": ["toStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   StripeInformation ( Math . toIntExact ( stripeInformation . getNumberOfRows (  )  )  ,    stripeInformation . getOffset (  )  ,    stripeInformation . getIndexLength (  )  ,    stripeInformation . getDataLength (  )  ,    stripeInformation . getFooterLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . copyOf ( Iterables . transform ( types ,    DwrfMetadataReader :  : toStripeInformation )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcType ( DwrfMetadataReader . toTypeKind ( type . getKind (  )  )  ,    type . getSubtypesList (  )  ,    type . getFieldNamesList (  )  ,    Optional . empty (  )  ,    Optional . empty (  )  ,    Optional . empty (  )  )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . copyOf ( Iterables . transform ( types ,    DwrfMetadataReader :  : toType )  )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( kind )     {", "case   BOOLEAN    :", "return   OrcType . OrcTypeKind . BOOLEAN ;", "case   BYTE    :", "return   OrcType . OrcTypeKind . BYTE ;", "case   SHORT    :", "return   OrcType . OrcTypeKind . SHORT ;", "case   INT    :", "return   OrcType . OrcTypeKind . INT ;", "case   LONG    :", "return   OrcType . OrcTypeKind . LONG ;", "case   FLOAT    :", "return   OrcType . OrcTypeKind . FLOAT ;", "case   DOUBLE    :", "return   OrcType . OrcTypeKind . DOUBLE ;", "case   STRING    :", "return   OrcType . OrcTypeKind . STRING ;", "case   BINARY    :", "return   OrcType . OrcTypeKind . BINARY ;", "case   TIMESTAMP    :", "return   OrcType . OrcTypeKind . TIMESTAMP ;", "case   LIST    :", "return   OrcType . OrcTypeKind . LIST ;", "case   MAP    :", "return   OrcType . OrcTypeKind . MAP ;", "case   STRUCT    :", "return   OrcType . OrcTypeKind . STRUCT ;", "case   UNION    :", "return   OrcType . OrcTypeKind . UNION ;", "default    :", "throw   new   IllegalArgumentException (  ( kind    +     \"       type   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toTypeKind"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Slice >    mapBuilder    =    ImmutableMap . builder (  )  ;", "for    ( DwrfProto . UserMetadataItem   item    :    metadataList )     {", "if    (  !  ( DwrfMetadataWriter . STATIC _ METADATA . containsKey ( item . getName (  )  )  )  )     {", "mapBuilder . put ( item . getName (  )  ,    Orc . byteStringToSlice ( item . getValue (  )  )  )  ;", "}", "}", "return   mapBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toUserMetadata"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( columnEncodingKind )     {", "case   DIRECT    :", "return   Kind . DIRECT ;", "case   DICTIONARY    :", "return   Kind . DICTIONARY ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   column   encoding   kind :     \"     +    columnEncodingKind )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   ColumnEncoding . newBuilder (  )  . setKind ( DwrfMetadataWriter . toColumnEncoding ( columnEncodings . getColumnEncodingKind (  )  )  )  . setDictionarySize ( columnEncodings . getDictionarySize (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "DwrfProto . ColumnStatistics . Builder   builder    =    DwrfProto . ColumnStatistics . newBuilder (  )  ;", "if    ( columnStatistics . hasNumberOfValues (  )  )     {", "builder . setNumberOfValues ( columnStatistics . getNumberOfValues (  )  )  ;", "}", "if    (  ( columnStatistics . getBooleanStatistics (  )  )     !  =    null )     {", "builder . setBucketStatistics ( BucketStatistics . newBuilder (  )  . addCount ( columnStatistics . getBooleanStatistics (  )  . getTrueValueCount (  )  )  . build (  )  )  ;", "}", "if    (  ( columnStatistics . getIntegerStatistics (  )  )     !  =    null )     {", "DwrfProto . IntegerStatistics . Builder   integerStatistics    =    DwrfProto . IntegerStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getIntegerStatistics (  )  . getMin (  )  )  . setMaximum ( columnStatistics . getIntegerStatistics (  )  . getMax (  )  )  ;", "if    (  ( columnStatistics . getIntegerStatistics (  )  . getSum (  )  )     !  =    null )     {", "integerStatistics . setSum ( columnStatistics . getIntegerStatistics (  )  . getSum (  )  )  ;", "}", "builder . setIntStatistics ( integerStatistics . build (  )  )  ;", "}", "if    (  ( columnStatistics . getDoubleStatistics (  )  )     !  =    null )     {", "builder . setDoubleStatistics ( DoubleStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getDoubleStatistics (  )  . getMin (  )  )  . setMaximum ( columnStatistics . getDoubleStatistics (  )  . getMax (  )  )  . build (  )  )  ;", "}", "if    (  ( columnStatistics . getStringStatistics (  )  )     !  =    null )     {", "DwrfProto . StringStatistics . Builder   statisticsBuilder    =    DwrfProto . StringStatistics . newBuilder (  )  ;", "if    (  ( columnStatistics . getStringStatistics (  )  . getMin (  )  )     !  =    null )     {", "statisticsBuilder . setMinimumBytes ( ByteString . copyFrom ( columnStatistics . getStringStatistics (  )  . getMin (  )  . getBytes (  )  )  )  ;", "}", "if    (  ( columnStatistics . getStringStatistics (  )  . getMax (  )  )     !  =    null )     {", "statisticsBuilder . setMaximumBytes ( ByteString . copyFrom ( columnStatistics . getStringStatistics (  )  . getMax (  )  . getBytes (  )  )  )  ;", "}", "statisticsBuilder . setSum ( columnStatistics . getStringStatistics (  )  . getSum (  )  )  ;", "builder . setStringStatistics ( statisticsBuilder . build (  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( compressionKind )     {", "case   NONE    :", "return   DwrfProto . CompressionKind . NONE ;", "case   ZLIB    :", "return   DwrfProto . CompressionKind . ZLIB ;", "case   SNAPPY    :", "return   DwrfProto . CompressionKind . SNAPPY ;", "case   LZ 4     :", "return   DwrfProto . CompressionKind . LZ 4  ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   compression   kind :     \"     +    compressionKind )  )  ;", "}", "METHOD_END"], "methodName": ["toCompression"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   RowIndexEntry . newBuilder (  )  . addAllPositions ( rowGroupIndex . getPositions (  )  . stream (  )  . map ( Integer :  : longValue )  . collect ( toImmutableList (  )  )  )  . setStatistics ( DwrfMetadataWriter . toColumnStatistics ( rowGroupIndex . getColumnStatistics (  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toRowGroupIndex"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   Stream . newBuilder (  )  . setColumn ( stream . getColumn (  )  )  . setKind ( DwrfMetadataWriter . toStreamKind ( stream . getStreamKind (  )  )  )  . setLength ( stream . getLength (  )  )  . setUseVInts ( stream . isUseVInts (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( streamKind )     {", "case   PRESENT    :", "return   Kind . PRESENT ;", "case   DATA    :", "return   Kind . DATA ;", "case   SECONDARY    :", "return   Kind . NANO _ DATA ;", "case   LENGTH    :", "return   Kind . LENGTH ;", "case   DICTIONARY _ DATA    :", "return   Kind . DICTIONARY _ DATA ;", "case   DICTIONARY _ COUNT    :", "return   Kind . DICTIONARY _ COUNT ;", "case   ROW _ INDEX    :", "return   Kind . ROW _ INDEX ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   stream   kind :     \"     +    streamKind )  )  ;", "}", "METHOD_END"], "methodName": ["toStreamKind"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   StripeInformation . newBuilder (  )  . setNumberOfRows ( stripe . getNumberOfRows (  )  )  . setOffset ( stripe . getOffset (  )  )  . setIndexLength ( stripe . getIndexLength (  )  )  . setDataLength ( stripe . getDataLength (  )  )  . setFooterLength ( stripe . getFooterLength (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "Builder   builder    =    Type . newBuilder (  )  . setKind ( DwrfMetadataWriter . toTypeKind ( type . getOrcTypeKind (  )  )  )  . addAllSubtypes ( type . getFieldTypeIndexes (  )  )  . addAllFieldNames ( type . getFieldNames (  )  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( orcTypeKind )     {", "case   BOOLEAN    :", "return   Kind . BOOLEAN ;", "case   BYTE    :", "return   Kind . BYTE ;", "case   SHORT    :", "return   Kind . SHORT ;", "case   INT    :", "return   Kind . INT ;", "case   LONG    :", "return   Kind . LONG ;", "case   FLOAT    :", "return   Kind . FLOAT ;", "case   DOUBLE    :", "return   Kind . DOUBLE ;", "case   STRING    :", "case   VARCHAR    :", "return   Kind . STRING ;", "case   BINARY    :", "return   Kind . BINARY ;", "case   TIMESTAMP    :", "return   Kind . TIMESTAMP ;", "case   LIST    :", "return   Kind . LIST ;", "case   MAP    :", "return   Kind . MAP ;", "case   STRUCT    :", "return   Kind . STRUCT ;", "case   UNION    :", "return   Kind . UNION ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   type :     \"     +    orcTypeKind )  )  ;", "}", "METHOD_END"], "methodName": ["toTypeKind"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   UserMetadataItem . newBuilder (  )  . setName ( entry . getKey (  )  )  . setValue ( ByteString . copyFrom ( entry . getValue (  )  . getBytes (  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toUserMetadata"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "CountingOutputStream   countingOutput    =    new   CountingOutputStream ( output )  ;", "object . wTo ( countingOutput )  ;", "return   Math . toIntExact ( countingOutput . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeProtobufObject"], "fileName": "com.facebook.presto.orc.metadata.DwrfMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "propagateIfPossible ( throwable ,    PrestoException . class )  ;", "return   new   OrcCorruptionException ( throwable ,    orcDataSourceId ,    message )  ;", "}", "METHOD_END"], "methodName": ["propagate"], "fileName": "com.facebook.presto.orc.metadata.ExceptionWrappingMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   fileStats ;", "}", "METHOD_END"], "methodName": ["getFileStats"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   numberOfRows ;", "}", "METHOD_END"], "methodName": ["getNumberOfRows"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   rowsInRowGroup ;", "}", "METHOD_END"], "methodName": ["getRowsInRowGroup"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   stripes ;", "}", "METHOD_END"], "methodName": ["getStripes"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   types ;", "}", "METHOD_END"], "methodName": ["getTypes"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableMap . copyOf ( transformValues ( userMetadata ,    Slices :  : copyOf )  )  ;", "}", "METHOD_END"], "methodName": ["getUserMetadata"], "fileName": "com.facebook.presto.orc.metadata.Footer"}, {"methodBody": ["METHOD_START", "{", "return   stripeStatistics ;", "}", "METHOD_END"], "methodName": ["getStripeStatsList"], "fileName": "com.facebook.presto.orc.metadata.Metadata"}, {"methodBody": ["METHOD_START", "{", "return   Slices . wrappedBuffer ( value . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["byteStringToSlice"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "int   length    =    utf 8  . length (  )  ;", "int   position    =     0  ;", "while    ( position    <    length )     {", "int   codePoint    =    tryGetCodePointAt ( utf 8  ,    position )  ;", "if    ( codePoint    <     0  )     {", "break ;", "}", "if    ( codePoint    =  =     (  . REPLACEMENT _ CHARACTER _ CODE _ POINT )  )     {", "break ;", "}", "if    ( codePoint    >  =     ( Character . MIN _ SUPPLEMENTARY _ CODE _ POINT )  )     {", "break ;", "}", "position    +  =    lengthOfCodePoint ( codePoint )  ;", "}", "return   position ;", "}", "METHOD_END"], "methodName": ["findStringStatisticTruncationPositionForOriginalOrcWriter"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   null ;", "}", "if    ( version    !  =     ( PostScript . HiveWriterVersion . ORIGINAL )  )     {", "return   value ;", "}", "int   index    =     . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  ;", "if    ( index    =  =     ( value . length (  )  )  )     {", "return   value ;", "}", "Slice   newValue    =    Slices . copyOf ( value ,     0  ,     ( index    +     1  )  )  ;", "newValue . setByte ( index ,     2  5  5  )  ;", "return   newValue ;", "}", "METHOD_END"], "methodName": ["maxStringTruncateToValidRange"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   null ;", "}", "if    ( version    !  =     ( PostScript . HiveWriterVersion . ORIGINAL )  )     {", "return   value ;", "}", "int   index    =     . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  ;", "if    ( index    =  =     ( value . length (  )  )  )     {", "return   value ;", "}", "return   Slices . copyOf ( value ,     0  ,    index )  ;", "}", "METHOD_END"], "methodName": ["minStringTruncateToValidRange"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( binaryStatistics . hasSum (  )  )  )     {", "return   null ;", "}", "return   new   BinaryStatistics ( binaryStatistics . getSum (  )  )  ;", "}", "METHOD_END"], "methodName": ["toBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bucketStatistics . getCountCount (  )  )     =  =     0  )     {", "return   null ;", "}", "return   new   BooleanStatistics ( bucketStatistics . getCount (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["toBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnEncoding ( OrcMetadataReader . toColumnEncodingKind ( columnEncoding . getKind (  )  )  ,    columnEncoding . getDictionarySize (  )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   columnEncodings . stream (  )  . map ( OrcMetadataReader :  : toColumnEncoding )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( columnEncodingKind )     {", "case   DIRECT    :", "return   ColumnEncoding . ColumnEncodingKind . DIRECT ;", "case   DIRECT _ V 2     :", "return   ColumnEncoding . ColumnEncodingKind . DIRECT _ V 2  ;", "case   DICTIONARY    :", "return   ColumnEncoding . ColumnEncodingKind . DICTIONARY ;", "case   DICTIONARY _ V 2     :", "return   ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  ;", "default    :", "throw   new   IllegalStateException (  ( columnEncodingKind    +     \"    stream   encoding   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toColumnEncodingKind"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "long   minAverageValueBytes ;", "if    ( statistics . hasBucketStatistics (  )  )     {", "minAverageValueBytes    =    BooleanStatistics . BOOLEAN _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasIntStatistics (  )  )     {", "minAverageValueBytes    =    statistics . IntegerStatistics . INTEGER _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasDoubleStatistics (  )  )     {", "minAverageValueBytes    =    statistics . DoubleStatistics . DOUBLE _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasStringStatistics (  )  )     {", "minAverageValueBytes    =    statistics . StringStatistics . STRING _ VALUE _ BYTES _ OVERHEAD ;", "if    (  ( statistics . hasNumberOfValues (  )  )     &  &     (  ( statistics . getNumberOfValues (  )  )     >     0  )  )     {", "minAverageValueBytes    +  =     ( statistics . getStringStatistics (  )  . getSum (  )  )     /     ( statistics . getNumberOfValues (  )  )  ;", "}", "} else", "if    ( statistics . hasDateStatistics (  )  )     {", "minAverageValueBytes    =    statistics . DateStatistics . DATE _ VALUE _ BYTES ;", "} else", "if    ( statistics . hasDecimalStatistics (  )  )     {", "minAverageValueBytes    =     ( statistics . DecimalStatistics . DECIMAL _ VALUE _ BYTES _ OVERHEAD )     +     ( statistics . ShortDecimalStatisticsBuilder . SHORT _ DECIMAL _ VALUE _ BYTES )  ;", "} else", "if    ( statistics . hasBinaryStatistics (  )  )     {", "minAverageValueBytes    =    statistics . BinaryStatistics . BINARY _ VALUE _ BYTES _ OVERHEAD ;", "if    (  ( statistics . hasNumberOfValues (  )  )     &  &     (  ( statistics . getNumberOfValues (  )  )     >     0  )  )     {", "minAverageValueBytes    +  =     ( statistics . getBinaryStatistics (  )  . getSum (  )  )     /     ( statistics . getNumberOfValues (  )  )  ;", "}", "} else    {", "minAverageValueBytes    =     0  ;", "}", "return   new   ColumnStatistics ( statistics . getNumberOfValues (  )  ,    minAverageValueBytes ,    OrcMetadataReader . toBooleanStatistics ( statistics . getBucketStatistics (  )  )  ,    OrcMetadataReader . toIntegerStatistics ( statistics . getIntStatistics (  )  )  ,    OrcMetadataReader . toDoubleStatistics ( statistics . getDoubleStatistics (  )  )  ,    OrcMetadataReader . toStringStatistics ( hiveWriterVersion ,    statistics . getStringStatistics (  )  ,    isRowGroup )  ,    OrcMetadataReader . toDateStatistics ( hiveWriterVersion ,    statistics . getDateStatistics (  )  ,    isRowGroup )  ,    OrcMetadataReader . toDecimalStatistics ( statistics . getDecimalStatistics (  )  )  ,    OrcMetadataReader . toBinaryStatistics ( statistics . getBinaryStatistics (  )  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    ( columnStatistics    =  =    null )     {", "return   ImmutableList . of (  )  ;", "}", "return   columnStatistics . stream (  )  . map (  (    statistics )     -  >    toColumnStatistics ( hiveWriterVersion ,    statistics ,    isRowGroup )  )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( compression )     {", "case   NONE    :", "return   CompressionKind . NONE ;", "case   ZLIB    :", "return   CompressionKind . ZLIB ;", "case   SNAPPY    :", "return   CompressionKind . SNAPPY ;", "case   LZ 4     :", "return   CompressionKind . LZ 4  ;", "case   ZSTD    :", "return   CompressionKind . ZSTD ;", "default    :", "throw   new   IllegalStateException (  ( compression    +     \"    compression   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toCompression"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hiveWriterVersion    =  =     ( PostScript . HiveWriterVersion . ORIGINAL )  )     &  &     (  ! isRowGroup )  )     {", "return   null ;", "}", "if    (  (  !  ( eStatistics . hasMinimum (  )  )  )     &  &     (  !  ( eStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "return   new   DateStatistics (  ( eStatistics . hasMinimum (  )     ?    eStatistics . getMinimum (  )     :    null )  ,     ( eStatistics . hasMaximum (  )     ?    eStatistics . getMaximum (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["toDateStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( decimalStatistics . hasMinimum (  )  )  )     &  &     (  !  ( decimalStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "BigDecimal   minimum    =     ( decimalStatistics . hasMinimum (  )  )     ?    new   BigDecimal ( decimalStatistics . getMinimum (  )  )     :    null ;", "BigDecimal   maximum    =     ( decimalStatistics . hasMaximum (  )  )     ?    new   BigDecimal ( decimalStatistics . getMaximum (  )  )     :    null ;", "return   new   DecimalStatistics ( minimum ,    maximum ,    ShortDecimalStatisticsBuil . SHORT _ DECIMAL _ VALUE _ BYTES )  ;", "}", "METHOD_END"], "methodName": ["toDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( doubleStatistics . hasMinimum (  )  )  )     &  &     (  !  ( doubleStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "if    (  (  (  ( doubleStatistics . hasMinimum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getMinimum (  )  )  )  )     |  |     (  ( doubleStatistics . hasMaximum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getMaximum (  )  )  )  )  )     |  |     (  ( doubleStatistics . hasSum (  )  )     &  &     ( Double . isNaN ( doubleStatistics . getSum (  )  )  )  )  )     {", "return   null ;", "}", "return   new   DoubleStatistics (  ( doubleStatistics . hasMinimum (  )     ?    doubleStatistics . getMinimum (  )     :    null )  ,     ( doubleStatistics . hasMaximum (  )     ?    doubleStatistics . getMaximum (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["toDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    ( writerVersion    >  =     1  )     {", "return   PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ;", "}", "return   PostScript . HiveWriterVersion . ORIGINAL ;", "}", "METHOD_END"], "methodName": ["toHiveWriterVersion"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( integerStatistics . hasMinimum (  )  )  )     &  &     (  !  ( integerStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "return   new   IntegerStatistics (  ( integerStatistics . hasMinimum (  )     ?    integerStatistics . getMinimum (  )     :    null )  ,     ( integerStatistics . hasMaximum (  )     ?    integerStatistics . getMaximum (  )     :    null )  ,     ( integerStatistics . hasSum (  )     ?    integerStatistics . getSum (  )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["toIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "List < Long >    positionsList    =    rowIndexEntry . getPositionsList (  )  ;", "ImmutableList . Builder < Integer >    positions    =    ImmutableList . builder (  )  ;", "for    ( int   index    =     0  ;    index    <     ( positionsList . size (  )  )  ;    index +  +  )     {", "long   longPosition    =    positionsList . get ( index )  ;", "int   intPosition    =     (  ( int )     ( longPosition )  )  ;", "checkState (  ( intPosition    =  =    longPosition )  ,     \" Expected   checkpoint   position    % s ,    to   be   an   integer \"  ,    index )  ;", "positions . add ( intPosition )  ;", "}", "return   new   RowGroupIndex ( positions . build (  )  ,     . toColumnStatistics ( hiveWriterVersion ,    rowIndexEntry . getStatistics (  )  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["toRowGroupIndex"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   Stream ( stream . getColumn (  )  ,    OrcMetadataReader . toStreamKind ( stream . getKind (  )  )  ,    Math . toIntExact ( stream . getLength (  )  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   streams . stream (  )  . map ( OrcMetadataReader :  : toStream )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( streamKind )     {", "case   PRESENT    :", "return   Stream . StreamKind . PRESENT ;", "case   DATA    :", "return   Stream . StreamKind . DATA ;", "case   LENGTH    :", "return   Stream . StreamKind . LENGTH ;", "case   DICTIONARY _ DATA    :", "return   Stream . StreamKind . DICTIONARY _ DATA ;", "case   DICTIONARY _ COUNT    :", "return   Stream . StreamKind . DICTIONARY _ COUNT ;", "case   SECONDARY    :", "return   Stream . StreamKind . SECONDARY ;", "case   ROW _ INDEX    :", "return   Stream . StreamKind . ROW _ INDEX ;", "case   BLOOM _ FILTER    :", "return   Stream . StreamKind . BLOOM _ FILTER ;", "default    :", "throw   new   IllegalStateException (  ( streamKind    +     \"    stream   type   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toStreamKind"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hiveWriterVersion    =  =     ( PostScript . HiveWriterVersion . ORIGINAL )  )     &  &     (  ! isRowGroup )  )     {", "return   null ;", "}", "if    (  (  !  ( stringStatistics . hasMinimum (  )  )  )     &  &     (  !  ( stringStatistics . hasMaximum (  )  )  )  )     {", "return   null ;", "}", "Slice   maximum    =     ( stringStatistics . hasMaximum (  )  )     ?     . maxStringTruncateToValidRange (  . byteStringToSlice ( stringStatistics . getMaximumBytes (  )  )  ,    hiveWriterVersion )     :    null ;", "Slice   minimum    =     ( stringStatistics . hasMinimum (  )  )     ?     . minStringTruncateToValidRange (  . byteStringToSlice ( stringStatistics . getMinimumBytes (  )  )  ,    hiveWriterVersion )     :    null ;", "long   sum    =     ( stringStatistics . hasSum (  )  )     ?    stringStatistics . getSum (  )     :     0  ;", "return   new   StringStatistics ( minimum ,    maximum ,    sum )  ;", "}", "METHOD_END"], "methodName": ["toStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   StripeInformation ( Math . toIntExact ( stripeInformation . getNumberOfRows (  )  )  ,    stripeInformation . getOffset (  )  ,    stripeInformation . getIndexLength (  )  ,    stripeInformation . getDataLength (  )  ,    stripeInformation . getFooterLength (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   types . stream (  )  . map ( OrcMetadataReader :  : toStripeInformation )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   StripeStatistics ( OrcMetadataReader . toColumnStatistics ( hiveWriterVersion ,    stripeStatistics . getColStatsList (  )  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   types . stream (  )  . map (  (    stripeStatistics )     -  >    toStripeStatistics ( hiveWriterVersion ,    stripeStatistics )  )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toStripeStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "Optional < Integer >    length    =    Optional . empty (  )  ;", "if    (  (  ( type . getKind (  )  )     =  =     ( Kind . VARCHAR )  )     |  |     (  ( type . getKind (  )  )     =  =     ( Kind . CHAR )  )  )     {", "length    =    Optional . of ( type . getMaximumLength (  )  )  ;", "}", "Optional < Integer >    precision    =    Optional . empty (  )  ;", "Optional < Integer >    scale    =    Optional . empty (  )  ;", "if    (  ( type . getKind (  )  )     =  =     ( Kind . DECIMAL )  )     {", "precision    =    Optional . of ( type . getPrecision (  )  )  ;", "scale    =    Optional . of ( type . getScale (  )  )  ;", "}", "return   new   OrcType (  . toTypeKind ( type . getKind (  )  )  ,    type . getSubtypesList (  )  ,    type . getFieldNamesList (  )  ,    length ,    precision ,    scale )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   types . stream (  )  . map ( OrcMetadataReader :  : toType )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( typeKind )     {", "case   BOOLEAN    :", "returnTypeTypeKind . BOOLEAN ;", "case   BYTE    :", "returnTypeTypeKind . BYTE ;", "case   SHORT    :", "returnTypeTypeKind . SHORT ;", "case   INT    :", "returnTypeTypeKind . INT ;", "case   LONG    :", "returnTypeTypeKind . LONG ;", "case   FLOAT    :", "returnTypeTypeKind . FLOAT ;", "case   DOUBLE    :", "returnTypeTypeKind . DOUBLE ;", "case   STRING    :", "returnTypeTypeKind . STRING ;", "case   BINARY    :", "returnTypeTypeKind . BINARY ;", "case   TIMESTAMP    :", "returnTypeTypeKind . TIMESTAMP ;", "case   LIST    :", "returnTypeTypeKind . LIST ;", "case   MAP    :", "returnTypeTypeKind . MAP ;", "case   STRUCT    :", "returnTypeTypeKind . STRUCT ;", "case   UNION    :", "returnTypeTypeKind . UNION ;", "case   DECIMAL    :", "returnTypeTypeKind . DECIMAL ;", "case   DATE    :", "returnTypeTypeKind . DATE ;", "case   VARCHAR    :", "returnTypeTypeKind . VARCHAR ;", "case   CHAR    :", "returnTypeTypeKind . CHAR ;", "default    :", "throw   new   IllegalStateException (  ( typeKind    +     \"    stream   type   not   implemented   yet \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toTypeKind"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Slice >    mapBuilder    =    ImmutableMap . builder (  )  ;", "for    ( OrcProto . UserMetadataItem   item    :    metadataList )     {", "mapBuilder . put ( item . getName (  )  ,     . byteStringToSlice ( item . getValue (  )  )  )  ;", "}", "return   mapBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toUserMetadata"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( columnEncodingKind )     {", "case   DIRECT    :", "return   Kind . DIRECT ;", "case   DICTIONARY    :", "return   Kind . DICTIONARY ;", "case   DIRECT _ V 2     :", "return   Kind . DIRECT _ V 2  ;", "case   DICTIONARY _ V 2     :", "return   Kind . DICTIONARY _ V 2  ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   column   encoding   kind :     \"     +    columnEncodingKind )  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   ColumnEncoding . newBuilder (  )  . setKind ( OrcMetadataWriter . toColumnEncoding ( columnEncodings . getColumnEncodingKind (  )  )  )  . setDictionarySize ( columnEncodings . getDictionarySize (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toColumnEncoding"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "OrcProto . ColumnStatistics . Builder   builder    =    OrcProto . ColumnStatistics . newBuilder (  )  ;", "if    ( columnStatistics . hasNumberOfValues (  )  )     {", "builder . setNumberOfValues ( columnStatistics . getNumberOfValues (  )  )  ;", "}", "if    (  ( columnStatistics . getBooleanStatistics (  )  )     !  =    null )     {", "builder . setBucketStatistics ( BucketStatistics . newBuilder (  )  . addCount ( columnStatistics . getBooleanStatistics (  )  . getTrueValueCount (  )  )  . build (  )  )  ;", "}", "if    (  ( columnStatistics . getIntegerStatistics (  )  )     !  =    null )     {", "OrcProto . IntegerStatistics . Builder   integerStatistics    =    OrcProto . IntegerStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getIntegerStatistics (  )  . getMin (  )  )  . setMaximum ( columnStatistics . getIntegerStatistics (  )  . getMax (  )  )  ;", "if    (  ( columnStatistics . getIntegerStatistics (  )  . getSum (  )  )     !  =    null )     {", "integerStatistics . setSum ( columnStatistics . getIntegerStatistics (  )  . getSum (  )  )  ;", "}", "builder . setIntStatistics ( integerStatistics . build (  )  )  ;", "}", "if    (  ( columnStatistics . getDoubleStatistics (  )  )     !  =    null )     {", "builder . setDoubleStatistics ( DoubleStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getDoubleStatistics (  )  . getMin (  )  )  . setMaximum ( columnStatistics . getDoubleStatistics (  )  . getMax (  )  )  . build (  )  )  ;", "}", "if    (  ( columnStatistics . getStringStatistics (  )  )     !  =    null )     {", "OrcProto . StringStatistics . Builder   statisticsBuilder    =    OrcProto . StringStatistics . newBuilder (  )  ;", "if    (  ( columnStatistics . getStringStatistics (  )  . getMin (  )  )     !  =    null )     {", "statisticsBuilder . setMinimumBytes ( ByteString . copyFrom ( columnStatistics . getStringStatistics (  )  . getMin (  )  . getBytes (  )  )  )  ;", "}", "if    (  ( columnStatistics . getStringStatistics (  )  . getMax (  )  )     !  =    null )     {", "statisticsBuilder . setMaximumBytes ( ByteString . copyFrom ( columnStatistics . getStringStatistics (  )  . getMax (  )  . getBytes (  )  )  )  ;", "}", "statisticsBuilder . setSum ( columnStatistics . getStringStatistics (  )  . getSum (  )  )  ;", "builder . setStringStatistics ( statisticsBuilder . build (  )  )  ;", "}", "if    (  ( columnStatistics . getDateStatistics (  )  )     !  =    null )     {", "builder . setDateStatistics ( DateStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getDateStatistics (  )  . getMin (  )  )  . setMaximum ( columnStatistics . getDateStatistics (  )  . getMax (  )  )  . build (  )  )  ;", "}", "if    (  ( columnStatistics . getDecimalStatistics (  )  )     !  =    null )     {", "builder . setDecimalStatistics ( DecimalStatistics . newBuilder (  )  . setMinimum ( columnStatistics . getDecimalStatistics (  )  . getMin (  )  . toString (  )  )  . setMaximum ( columnStatistics . getDecimalStatistics (  )  . getMax (  )  . toString (  )  )  . build (  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( compressionKind )     {", "case   NONE    :", "return   OrcProto . CompressionKind . NONE ;", "case   ZLIB    :", "return   OrcProto . CompressionKind . ZLIB ;", "case   SNAPPY    :", "return   OrcProto . CompressionKind . SNAPPY ;", "case   LZ 4     :", "return   OrcProto . CompressionKind . LZ 4  ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   compression   kind :     \"     +    compressionKind )  )  ;", "}", "METHOD_END"], "methodName": ["toCompression"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   RowIndexEntry . newBuilder (  )  . addAllPositions ( rowGroupIndex . getPositions (  )  . stream (  )  . map ( Integer :  : longValue )  . collect ( Collectors . toList (  )  )  )  . setStatistics ( OrcMetadataWriter . toColumnStatistics ( rowGroupIndex . getColumnStatistics (  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toRowGroupIndex"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   Stream . newBuilder (  )  . setColumn ( stream . getColumn (  )  )  . setKind ( OrcMetadataWriter . toStreamKind ( stream . getStreamKind (  )  )  )  . setLength ( stream . getLength (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toStream"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( streamKind )     {", "case   PRESENT    :", "return   Kind . PRESENT ;", "case   DATA    :", "return   Kind . DATA ;", "case   LENGTH    :", "return   Kind . LENGTH ;", "case   DICTIONARY _ DATA    :", "return   Kind . DICTIONARY _ DATA ;", "case   DICTIONARY _ COUNT    :", "return   Kind . DICTIONARY _ COUNT ;", "case   SECONDARY    :", "return   Kind . SECONDARY ;", "case   ROW _ INDEX    :", "return   Kind . ROW _ INDEX ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   stream   kind :     \"     +    streamKind )  )  ;", "}", "METHOD_END"], "methodName": ["toStreamKind"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   StripeInformation . newBuilder (  )  . setNumberOfRows ( stripe . getNumberOfRows (  )  )  . setOffset ( stripe . getOffset (  )  )  . setIndexLength ( stripe . getIndexLength (  )  )  . setDataLength ( stripe . getDataLength (  )  )  . setFooterLength ( stripe . getFooterLength (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toStripeInformation"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   StripeStatistics . newBuilder (  )  . addAllColStats ( stripeStatistics . getColumnStatistics (  )  . stream (  )  . map ( OrcMetadataWriter :  : toColumnStatistics )  . collect ( Collectors . toList (  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toStripeStatistics"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "Builder   builder    =    Type . newBuilder (  )  . setKind ( OrcMetadataWriter . toTypeKind ( type . getOrcTypeKind (  )  )  )  . addAllSubtypes ( type . getFieldTypeIndexes (  )  )  . addAllFieldNames ( type . getFieldNames (  )  )  ;", "if    ( type . getLength (  )  . isPresent (  )  )     {", "builder . setMaximumLength ( type . getLength (  )  . get (  )  )  ;", "}", "if    ( type . getPrecision (  )  . isPresent (  )  )     {", "builder . setPrecision ( type . getPrecision (  )  . get (  )  )  ;", "}", "if    ( type . getScale (  )  . isPresent (  )  )     {", "builder . setScale ( type . getScale (  )  . get (  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( orcTypeKind )     {", "case   BOOLEAN    :", "return   Kind . BOOLEAN ;", "case   BYTE    :", "return   Kind . BYTE ;", "case   SHORT    :", "return   Kind . SHORT ;", "case   INT    :", "return   Kind . INT ;", "case   LONG    :", "return   Kind . LONG ;", "case   DECIMAL    :", "return   Kind . DECIMAL ;", "case   FLOAT    :", "return   Kind . FLOAT ;", "case   DOUBLE    :", "return   Kind . DOUBLE ;", "case   STRING    :", "return   Kind . STRING ;", "case   VARCHAR    :", "return   Kind . VARCHAR ;", "case   CHAR    :", "return   Kind . CHAR ;", "case   BINARY    :", "return   Kind . BINARY ;", "case   DATE    :", "return   Kind . DATE ;", "case   TIMESTAMP    :", "return   Kind . TIMESTAMP ;", "case   LIST    :", "return   Kind . LIST ;", "case   MAP    :", "return   Kind . MAP ;", "case   STRUCT    :", "return   Kind . STRUCT ;", "case   UNION    :", "return   Kind . UNION ;", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   type :     \"     +    orcTypeKind )  )  ;", "}", "METHOD_END"], "methodName": ["toTypeKind"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "return   UserMetadataItem . newBuilder (  )  . setName ( entry . getKey (  )  )  . setValue ( ByteString . copyFrom ( entry . getValue (  )  . getBytes (  )  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["toUserMetadata"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "CountingOutputStream   countingOutput    =    new   CountingOutputStream ( output )  ;", "object . wTo ( countingOutput )  ;", "return   Math . toIntExact ( countingOutput . getCount (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeProtobufObject"], "fileName": "com.facebook.presto.orc.metadata.OrcMetadataWriter"}, {"methodBody": ["METHOD_START", "{", "nextFieldTypeIndex +  +  ;", "List >    itemTypes    =  . t ( nextFieldTypeIndex ,    itemType )  ;", "List >    orcTypes    =    new   ArrayList <  >  (  )  ;", "orcTypes . add ( newKind . LIST ,    ImmutableList . of ( nextFieldTypeIndex )  ,    ImmutableList . of (  \" item \"  )  )  )  ;", "orcTypes . addAll ( itemTypes )  ;", "return   orcTypes ;", "}", "METHOD_END"], "methodName": ["createOrcArrayType"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "nextFieldTypeIndex +  +  ;", "List >    keyTypes    =  . t ( nextFieldTypeIndex ,    keyType )  ;", "List >    valueTypes    =  . t (  ( nextFieldTypeIndex    +     ( keyTypes . size (  )  )  )  ,    valueType )  ;", "List >    orcTypes    =    new   ArrayList <  >  (  )  ;", "orcTypes . add ( newKind . MAP ,    ImmutableList . of ( nextFieldTypeIndex ,     ( nextFieldTypeIndex    +     ( keyTypes . size (  )  )  )  )  ,    ImmutableList . of (  \" key \"  ,     \" value \"  )  )  )  ;", "orcTypes . addAll ( keyTypes )  ;", "orcTypes . addAll ( valueTypes )  ;", "return   orcTypes ;", "}", "METHOD_END"], "methodName": ["createOrcMapType"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "nextFieldTypeIndex +  +  ;", "List < Integer >    fieldTypeIndexes    =    new   ArrayList <  >  (  )  ;", "List < List >  >    fieldTypesList    =    new   ArrayList <  >  (  )  ;", "for    ( Type   fieldType    :    fieldTypes )     {", "fieldTypeIndexes . add ( nextFieldTypeIndex )  ;", "List >    fiels    =  . t ( nextFieldTypeIndex ,    fieldType )  ;", "fieldTypesList . add ( fiels )  ;", "nextFieldTypeIndex    +  =    fiels . size (  )  ;", "}", "List >    orcTypes    =    new   ArrayList <  >  (  )  ;", "orcTypes . add ( newKind . STRUCT ,    fieldTypeIndexes ,    fieldNames )  )  ;", "fieldTypesList . forEach ( orcTypes :  : addAll )  ;", "return   orcTypes ;", "}", "METHOD_END"], "methodName": ["createOrcRowType"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   fieldTypeIndexes . size (  )  ;", "}", "METHOD_END"], "methodName": ["getFieldCount"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   fieldNames . get ( field )  ;", "}", "METHOD_END"], "methodName": ["getFieldName"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   fieldNames ;", "}", "METHOD_END"], "methodName": ["getFieldNames"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   fieldTypeIndexes . get ( field )  ;", "}", "METHOD_END"], "methodName": ["getFieldTypeIndex"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   fieldTypeIndexes ;", "}", "METHOD_END"], "methodName": ["getFieldTypeIndexes"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   orcTypeKind ;", "}", "METHOD_END"], "methodName": ["getOrcTypeKind"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   precision ;", "}", "METHOD_END"], "methodName": ["getPrecision"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   scale ;", "}", "METHOD_END"], "methodName": ["getScale"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "if    ( BOOLEAN . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . BOOLEAN )  )  ;", "}", "if    ( TINYINT . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . BYTE )  )  ;", "}", "if    ( SMALLINT . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . SHORT )  )  ;", "}", "if    ( INTEGER . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . INT )  )  ;", "}", "if    ( BIGINT . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . LONG )  )  ;", "}", "if    ( DOUBLE . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . DOUBLE )  )  ;", "}", "if    ( REAL . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . FLOAT )  )  ;", "}", "if    ( type   instanceof   VarcharType )     {", "VarcharType   varcharType    =     (  ( VarcharType )     ( type )  )  ;", "if    ( varcharType . isUnbounded (  )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . STRING )  )  ;", "}", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . VARCHAR ,    varcharType . getLengthSafe (  )  )  )  ;", "}", "if    ( type   instanceof   CharType )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . CHAR ,     (  ( CharType )     ( type )  )  . getLength (  )  )  )  ;", "}", "if    ( VARBINARY . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . BINARY )  )  ;", "}", "if    ( DATE . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . DATE )  )  ;", "}", "if    ( TIMESTAMP . equals ( type )  )     {", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . TIMESTAMP )  )  ;", "}", "if    ( type   instanceof   DecimalType )     {", "DecimalType   decimalType    =     (  ( DecimalType )     ( type )  )  ;", "return   ImmutableList . of ( new   OrcType ( OrcType . OrcTypeKind . DECIMAL ,    decimalType . getPrecision (  )  ,    decimalType . getScale (  )  )  )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( ARRAY )  )     {", "return   OrcType . createOrcArrayType ( nextFieldTypeIndex ,    type . getTypeParameters (  )  . get (  0  )  )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( MAP )  )     {", "return   OrcType . createOrcMapType ( nextFieldTypeIndex ,    type . getTypeParameters (  )  . get (  0  )  ,    type . getTypeParameters (  )  . get (  1  )  )  ;", "}", "if    ( type . getTypeSignature (  )  . getBase (  )  . equals ( ROW )  )     {", "List < String >    fieldNames    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     ( type . getTypeSignature (  )  . getParameters (  )  . size (  )  )  ;    i +  +  )     {", "TypeSignatureParameter   parameter    =    type . getTypeSignature (  )  . getParameters (  )  . get ( i )  ;", "fieldNames . add ( parameter . getNamedTypeSignature (  )  . getName (  )  . orElse (  (  \" field \"     +    i )  )  )  ;", "}", "List < Type >    fieldTypes    =    type . getTypeParameters (  )  ;", "return   OrcType . createOrcRowType ( nextFieldTypeIndex ,    fieldNames ,    fieldTypes )  ;", "}", "throw   new   spi . PrestoException ( NOT _ SUPPORTED ,    String . format (  \" Unsupported   Hive   type :     % s \"  ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["toOrcType"], "fileName": "com.facebook.presto.orc.metadata.OrcType"}, {"methodBody": ["METHOD_START", "{", "return   compression ;", "}", "METHOD_END"], "methodName": ["getCompression"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   compressionBlockSize ;", "}", "METHOD_END"], "methodName": ["getCompressionBlockSize"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   footerLength ;", "}", "METHOD_END"], "methodName": ["getFooterLength"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   hiveWriterVersion ;", "}", "METHOD_END"], "methodName": ["getHiveWriterVersion"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   metadataLength ;", "}", "METHOD_END"], "methodName": ["getMetadataLength"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "com.facebook.presto.orc.metadata.PostScript"}, {"methodBody": ["METHOD_START", "{", "return   statistics ;", "}", "METHOD_END"], "methodName": ["getColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.RowGroupIndex"}, {"methodBody": ["METHOD_START", "{", "return   positions ;", "}", "METHOD_END"], "methodName": ["getPositions"], "fileName": "com.facebook.presto.orc.metadata.RowGroupIndex"}, {"methodBody": ["METHOD_START", "{", "return   column ;", "}", "METHOD_END"], "methodName": ["getColumn"], "fileName": "com.facebook.presto.orc.metadata.Stream"}, {"methodBody": ["METHOD_START", "{", "return   length ;", "}", "METHOD_END"], "methodName": ["getLength"], "fileName": "com.facebook.presto.orc.metadata.Stream"}, {"methodBody": ["METHOD_START", "{", "return   streamKind ;", "}", "METHOD_END"], "methodName": ["getStreamKind"], "fileName": "com.facebook.presto.orc.metadata.Stream"}, {"methodBody": ["METHOD_START", "{", "return   useVInts ;", "}", "METHOD_END"], "methodName": ["isUseVInts"], "fileName": "com.facebook.presto.orc.metadata.Stream"}, {"methodBody": ["METHOD_START", "{", "return   columnEncodings ;", "}", "METHOD_END"], "methodName": ["getColumnEncodings"], "fileName": "com.facebook.presto.orc.metadata.StripeFooter"}, {"methodBody": ["METHOD_START", "{", "return   streams ;", "}", "METHOD_END"], "methodName": ["getStreams"], "fileName": "com.facebook.presto.orc.metadata.StripeFooter"}, {"methodBody": ["METHOD_START", "{", "return   dataLength ;", "}", "METHOD_END"], "methodName": ["getDataLength"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return   footerLength ;", "}", "METHOD_END"], "methodName": ["getFooterLength"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return   indexLength ;", "}", "METHOD_END"], "methodName": ["getIndexLength"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return   numberOfRows ;", "}", "METHOD_END"], "methodName": ["getNumberOfRows"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return   offset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return    (  ( indexLength )     +     ( dataLength )  )     +     ( footerLength )  ;", "}", "METHOD_END"], "methodName": ["getTotalLength"], "fileName": "com.facebook.presto.orc.metadata.StripeInformation"}, {"methodBody": ["METHOD_START", "{", "return   new   StringStatistics ( OrcMetadataReader . minStringTruncateToValidRange ( min ,    version )  ,    OrcMetadataReader . maxStringTruncateToValidRange ( max ,    version )  ,    sum )  ;", "}", "METHOD_END"], "methodName": ["createExpectedStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.TestDwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( DwrfMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMinimumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setMaximumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestDwrfMetadataReader . createExpectedStringStatistics ( version ,    testValue ,    testValue ,     7  9  )  )  ;", "assertEquals ( DwrfMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMinimumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestDwrfMetadataReader . createExpectedStringStatistics ( version ,    testValue ,    null ,     7  9  )  )  ;", "assertEquals ( DwrfMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMaximumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestDwrfMetadataReader . createExpectedStringStatistics ( version ,    null ,    testValue ,     7  9  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringStatisticsTruncation"], "fileName": "com.facebook.presto.orc.metadata.TestDwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "assertNull ( DwrfMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORIGINAL ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . setMaximum (  \" cat \"  )  . setSum (  4  4  )  . build (  )  ,    false )  )  ;", "for    ( PostScript . HiveWriterVersion   hiveWriterVersion    :    PostScript . HiveWriterVersion . values (  )  )     {", "for    ( boolean   isRowGroup    :    ImmutableList . of ( true ,    false )  )     {", "assertNull ( DwrfMetadataReader . toStringStatistics ( hiveWriterVersion ,    StringStatistics . newBuilder (  )  . setSum (  4  5  )  . build (  )  ,    isRowGroup )  )  ;", "}", "}", "assertEquals ( DwrfMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( Slices . utf 8 Slice (  \" ant \"  )  ,    null ,     0  )  )  ;", "assertEquals ( DwrfMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMaximum (  \" cat \"  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( null ,    Slices . utf 8 Slice (  \" cat \"  )  ,     0  )  )  ;", "assertEquals ( DwrfMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . setMaximum (  \" cat \"  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( Slices . utf 8 Slice (  \" ant \"  )  ,    Slices . utf 8 Slice (  \" cat \"  )  ,     7  9  )  )  ;", "for    ( Slice   prefix    :    TestOrcMetadataReader . ALL _ UTF 8  _ SEQUENCES )     {", "for    ( int   testCodePoint    :    TestOrcMetadataReader . TEST _ CODE _ POINTS )     {", "Slice   codePoint    =    codePointToUtf 8  ( testCodePoint )  ;", "for    ( Slice   suffix    :    TestOrcMetadataReader . ALL _ UTF 8  _ SEQUENCES )     {", "Slice   testValue    =    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    suffix )  ;", "TestDwrfMetadataReader . testStringStatisticsTruncation ( testValue ,    PostScript . HiveWriterVersion . ORIGINAL )  ;", "TestDwrfMetadataReader . testStringStatisticsTruncation ( testValue ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testToStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.TestDwrfMetadataReader"}, {"methodBody": ["METHOD_START", "{", "int   totalLength    =    Arrays . stream ( slices )  . mapToInt ( Slice :  : length )  . sum (  )  ;", "Slice   value    =    Slices . allocate ( totalLength )  ;", "SliceOutput   output    =    value . getOutput (  )  ;", "for    ( Slice   slice    :    slices )     {", "output . writeBytes ( slice )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["concatSlice"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "return   new   StringStatistics ( OrcMetadataReader . minStringTruncateToValidRange ( min ,    version )  ,    OrcMetadataReader . maxStringTruncateToValidRange ( max ,    version )  ,    sum )  ;", "}", "METHOD_END"], "methodName": ["createExpectedStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "int   startCodePoint    =    Character . MIN _ CODE _ POINT ;", "int   endCodePoint    =    Character . MAX _ CODE _ POINT ;", "Slice   maxByte    =    wrappedBuffer (  (  ( byte )     (  2  5  5  )  )  )  ;", "for    ( int   codePoint    =    startCodePoint ;    codePoint    <    endCodePoint ;    codePoint +  +  )     {", "if    (  (  ( Character . MIN _ SURROGATE )     <  =    codePoint )     &  &     ( codePoint    <  =     ( Character . MAX _ SURROGATE )  )  )     {", "continue ;", "}", "Slice   value    =    codePointToUtf 8  ( codePoint )  ;", "if    (  ( OrcMetadataReader . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  )     =  =     ( value . length (  )  )  )     {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    value )  ;", "} else    {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    maxByte )  ;", "}", "}", "Slice   prefix    =    utf 8 Slice (  \" apple \"  )  ;", "Slice   maxSlice    =     . concatSlice ( prefix ,    maxByte )  ;", "for    ( int   codePoint    =    startCodePoint ;    codePoint    <    endCodePoint ;    codePoint +  +  )     {", "if    (  (  ( Character . MIN _ SURROGATE )     <  =    codePoint )     &  &     ( codePoint    <  =     ( Character . MAX _ SURROGATE )  )  )     {", "continue ;", "}", "Slice   value    =     . concatSlice ( prefix ,    codePointToUtf 8  ( codePoint )  )  ;", "if    (  ( OrcMetadataReader . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  )     =  =     ( value . length (  )  )  )     {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    value )  ;", "} else    {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    maxSlice )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testGetMaxSlice"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "int   startCodePoint    =    Character . MIN _ CODE _ POINT ;", "int   endCodePoint    =    Character . MAX _ CODE _ POINT ;", "Slice   minSlice    =    utf 8 Slice (  \"  \"  )  ;", "for    ( int   codePoint    =    startCodePoint ;    codePoint    <    endCodePoint ;    codePoint +  +  )     {", "if    (  (  ( Character . MIN _ SURROGATE )     <  =    codePoint )     &  &     ( codePoint    <  =     ( Character . MAX _ SURROGATE )  )  )     {", "continue ;", "}", "Slice   value    =    codePointToUtf 8  ( codePoint )  ;", "if    (  ( OrcMetadataReader . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  )     =  =     ( value . length (  )  )  )     {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    value )  ;", "} else    {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    minSlice )  ;", "}", "}", "Slice   prefix    =    utf 8 Slice (  \" apple \"  )  ;", "for    ( int   codePoint    =    startCodePoint ;    codePoint    <    endCodePoint ;    codePoint +  +  )     {", "if    (  (  ( Character . MIN _ SURROGATE )     <  =    codePoint )     &  &     ( codePoint    <  =     ( Character . MAX _ SURROGATE )  )  )     {", "continue ;", "}", "Slice   value    =     . concatSlice ( prefix ,    codePointToUtf 8  ( codePoint )  )  ;", "if    (  ( OrcMetadataReader . findStringStatisticTruncationPositionForOriginalOrcWriter ( value )  )     =  =     ( value . length (  )  )  )     {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    value )  ;", "} else    {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    prefix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testGetMinSlice"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "for    ( Slice   prefix    :    TestOrcMetadataReader . VALID _ UTF 8  _ SEQUENCES )     {", "for    ( Slice   suffix    :    TestOrcMetadataReader . VALID _ UTF 8  _ SEQUENCES )     {", "TestOrcMetadataReader . testMaxStringTruncateAtFirstReplacementCharacter ( prefix ,    suffix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testMaxStringTruncateAtFirstReplacementCharacter"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   testCodePoint    :    TestOrcMetadataReader . TEST _ CODE _ POINTS )     {", "Slice   codePoint    =    codePointToUtf 8  ( testCodePoint )  ;", "Slice   value    =    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    suffix )  ;", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ,    value )  ;", "if    ( prefix . equals ( OrcMetadataReader . maxStringTruncateToValidRange ( prefix ,    PostScript . HiveWriterVersion . ORIGINAL )  )  )     {", "if    (  ( testCodePoint    =  =     ( TestOrcMetadataReader . REPLACEMENT _ CHARACTER _ CODE _ POINT )  )     |  |     ( testCodePoint    >  =     ( Character . MIN _ SUPPLEMENTARY _ CODE _ POINT )  )  )     {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    TestOrcMetadataReader . concatSlice ( prefix ,    wrappedBuffer (  (  ( byte )     (  2  5  5  )  )  )  )  )  ;", "} else    {", "assertEquals ( OrcMetadataReader . maxStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    OrcMetadataReader . maxStringTruncateToValidRange ( suffix ,    PostScript . HiveWriterVersion . ORIGINAL )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testMaxStringTruncateAtFirstReplacementCharacter"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "for    ( Slice   prefix    :    TestOrcMetadataReader . VALID _ UTF 8  _ SEQUENCES )     {", "for    ( Slice   suffix    :    TestOrcMetadataReader . VALID _ UTF 8  _ SEQUENCES )     {", "TestOrcMetadataReader . testMinStringTruncateAtFirstReplacementCharacter ( prefix ,    suffix )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testMinStringTruncateAtFirstReplacementCharacter"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   testCodePoint    :    TestOrcMetadataReader . TEST _ CODE _ POINTS )     {", "Slice   codePoint    =    codePointToUtf 8  ( testCodePoint )  ;", "Slice   value    =    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    suffix )  ;", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ,    value )  ;", "if    ( prefix . equals ( OrcMetadataReader . minStringTruncateToValidRange ( prefix ,    PostScript . HiveWriterVersion . ORIGINAL )  )  )     {", "if    (  ( testCodePoint    =  =     ( TestOrcMetadataReader . REPLACEMENT _ CHARACTER _ CODE _ POINT )  )     |  |     ( testCodePoint    >  =     ( Character . MIN _ SUPPLEMENTARY _ CODE _ POINT )  )  )     {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    prefix )  ;", "} else    {", "assertEquals ( OrcMetadataReader . minStringTruncateToValidRange ( value ,    PostScript . HiveWriterVersion . ORIGINAL )  ,    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    OrcMetadataReader . minStringTruncateToValidRange ( suffix ,    PostScript . HiveWriterVersion . ORIGINAL )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testMinStringTruncateAtFirstReplacementCharacter"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( OrcMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMinimumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setMaximumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestOrcMetadataReader . createExpectedStringStatistics ( version ,    testValue ,    testValue ,     7  9  )  )  ;", "assertEquals ( OrcMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMinimumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestOrcMetadataReader . createExpectedStringStatistics ( version ,    testValue ,    null ,     7  9  )  )  ;", "assertEquals ( OrcMetadataReader . toStringStatistics ( version ,    StringStatistics . newBuilder (  )  . setMaximumBytes ( ByteString . copyFrom ( testValue . getBytes (  )  )  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    TestOrcMetadataReader . createExpectedStringStatistics ( version ,    null ,    testValue ,     7  9  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringStatisticsTruncation"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "assertNull ( OrcMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORIGINAL ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . setMaximum (  \" cat \"  )  . setSum (  4  4  )  . build (  )  ,    false )  )  ;", "for    ( PostScript . HiveWriterVersion   hiveWriterVersion    :    PostScript . HiveWriterVersion . values (  )  )     {", "for    ( boolean   isRowGroup    :    ImmutableList . of ( true ,    false )  )     {", "assertNull ( OrcMetadataReader . toStringStatistics ( hiveWriterVersion ,    StringStatistics . newBuilder (  )  . setSum (  4  5  )  . build (  )  ,    isRowGroup )  )  ;", "}", "}", "assertEquals ( OrcMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( utf 8 Slice (  \" ant \"  )  ,    null ,     0  )  )  ;", "assertEquals ( OrcMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMaximum (  \" cat \"  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( null ,    utf 8 Slice (  \" cat \"  )  ,     0  )  )  ;", "assertEquals ( OrcMetadataReader . toStringStatistics ( PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  ,    StringStatistics . newBuilder (  )  . setMinimum (  \" ant \"  )  . setMaximum (  \" cat \"  )  . setSum (  7  9  )  . build (  )  ,    true )  ,    new   statistics . StringStatistics ( utf 8 Slice (  \" ant \"  )  ,    utf 8 Slice (  \" cat \"  )  ,     7  9  )  )  ;", "for    ( Slice   prefix    :    TestOrcMetadataReader . ALL _ UTF 8  _ SEQUENCES )     {", "for    ( int   testCodePoint    :    TestOrcMetadataReader . TEST _ CODE _ POINTS )     {", "Slice   codePoint    =    codePointToUtf 8  ( testCodePoint )  ;", "for    ( Slice   suffix    :    TestOrcMetadataReader . ALL _ UTF 8  _ SEQUENCES )     {", "Slice   testValue    =    TestOrcMetadataReader . concatSlice ( prefix ,    codePoint ,    suffix )  ;", "TestOrcMetadataReader . testStringStatisticsTruncation ( testValue ,    PostScript . HiveWriterVersion . ORIGINAL )  ;", "TestOrcMetadataReader . testStringStatisticsTruncation ( testValue ,    PostScript . HiveWriterVersion . ORC _ HIVE _  8  7  3  2  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testToStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.TestOrcMetadataReader"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxStatistics ( min ,    min )  ;", "assertMinMaxStatistics ( max ,    max )  ;", "assertMinMaxStatistics ( min ,    max )  ;", "assertMinMaxStatistics ( min ,    null )  ;", "assertMinMaxStatistics ( null ,    max )  ;", "if    (  !  ( min . equals ( max )  )  )     {", ". assertThrows (  (  )     -  >    getCreateStatistics ( max ,    min )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertMinMax"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractRangeStatisticsTest"}, {"methodBody": ["METHOD_START", "{", "R   statistics    =    getCreateStatistics ( min ,    max )  ;", ". assertEquals ( statistics . getMin (  )  ,    min )  ;", ". assertEquals ( statistics . getMax (  )  ,    max )  ;", ". assertEquals ( statistics ,    statistics )  ;", ". assertEquals ( statistics . hashCode (  )  ,    statistics . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMinMaxStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractRangeStatisticsTest"}, {"methodBody": ["METHOD_START", "{", "AbstractRangeStatisticsTest . assertEquals ( getCreateStatistics ( min ,    max )  . getRetainedSizeInBytes (  )  ,    expectedSizeInBytes )  ;", "}", "METHOD_END"], "methodName": ["assertRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractRangeStatisticsTest"}, {"methodBody": ["METHOD_START", "{", "AbstractStatisticsBuilderTest . assertEquals ( columnStatistics . getNumberOfValues (  )  ,    expectedNumberOfValues )  ;", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . BOOLEAN )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "AbstractStatisticsBuilderTest . assertNotNull ( columnStatistics . getBooleanStatistics (  )  )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getBooleanStatistics (  )  )  ;", "}", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . INTEGER )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "assertRangeStatistics ( columnStatistics . getIntegerStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getIntegerStatistics (  )  )  ;", "}", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . DOUBLE )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "assertRangeStatistics ( columnStatistics . getDoubleStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDoubleStatistics (  )  )  ;", "}", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . STRING )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "assertRangeStatistics ( columnStatistics . getStringStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getStringStatistics (  )  )  ;", "}", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . DATE )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "assertRangeStatistics ( columnStatistics . getDateStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDateStatistics (  )  )  ;", "}", "if    (  (  ( statisticsType )     =  =     ( AbstractStatisticsBuilderTest . StatisticsType . DECIMAL )  )     &  &     ( expectedNumberOfValues    >     0  )  )     {", "assertRangeStatistics ( columnStatistics . getDecimalStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "} else    {", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDecimalStatistics (  )  )  ;", "}", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getBloomFilter (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "assertColumnStatistics ( columnStatistics ,    expectedNumberOfValues ,    expectedMin ,    expectedMax )  ;", "int   totalCount    =    aggregateColumnStatistics . getTotalCount (  )  ;", "assertColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatistics ( Optional . empty (  )  )  ,    totalCount ,    expectedMin ,    expectedMax )  ;", "assertColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatisticsPairwise ( Optional . empty (  )  )  ,    totalCount ,    expectedMin ,    expectedMax )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "assertColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatistics ( Optional . of ( ThreadLocalRandom . current (  )  )  )  ,    totalCount ,    expectedMin ,    expectedMax )  ;", "assertColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatisticsPairwise ( Optional . of ( ThreadLocalRandom . current (  )  )  )  ,    totalCount ,    expectedMin ,    expectedMax )  ;", "}", "List < ColumnStatistics >    statisticsList    =    aggregateColumnStatistics . getStatisticsList (  )  ;", ". assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics (  . insertEmptyColumnStatisticsAt ( statisticsList ,     0  ,     1  0  )  )  ,     ( totalCount    +     1  0  )  )  ;", ". assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics (  . insertEmptyColumnStatisticsAt ( statisticsList ,    statisticsList . size (  )  ,     1  0  )  )  ,     ( totalCount    +     1  0  )  )  ;", ". assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics (  . insertEmptyColumnStatisticsAt ( statisticsList ,     (  ( statisticsList . size (  )  )     /     2  )  ,     1  0  )  )  ,     ( totalCount    +     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "B   statisticsBuilder    =    statisticsBuilderSupplier . get (  )  ;", "for    ( T   value    :    values )     {", "adder . accept ( statisticsBuilder ,    value )  ;", "}", ". assertEquals ( statisticsBuilder . buildColumnStatistics (  )  . getMinAverageValueSizeInBytes (  )  ,    expectedAverageValueBytes )  ;", "statisticsBuilder    =    statisticsBuilderSupplier . get (  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( values . size (  )  )     /     2  )  ;    i +  +  )     {", "adder . accept ( statisticsBuilder ,    values . get ( i )  )  ;", "}", "ColumnStatistics   firstStats    =    statisticsBuilder . buildColumnStatistics (  )  ;", "statisticsBuilder    =    statisticsBuilderSupplier . get (  )  ;", "for    ( int   i    =     ( values . size (  )  )     /     2  ;    i    <     ( values . size (  )  )  ;    i +  +  )     {", "adder . accept ( statisticsBuilder ,    values . get ( i )  )  ;", "}", "ColumnStatistics   secondStats    =    statisticsBuilder . buildColumnStatistics (  )  ;", "assertEquals ( ColumnStatistics . mergeColumnStatistics ( ImmutableList . of ( firstStats ,    secondStats )  )  . getMinAverageValueSizeInBytes (  )  ,    expectedAverageValueBytes )  ;", "}", "METHOD_END"], "methodName": ["assertMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "assertValues ( expectedMin ,    expectedMin ,    ImmutableList . of ( expectedMin )  )  ;", "assertValues ( expectedMax ,    expectedMax ,    ImmutableList . of ( expectedMax )  )  ;", "assertValues ( expectedMin ,    expectedMax ,    ImmutableList . of ( expectedMin ,    expectedMax )  )  ;", "}", "METHOD_END"], "methodName": ["assertMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "AbstractStatisticsBuilderTest . assertEquals ( columnStatistics . getNumberOfValues (  )  ,    expectedNumberOfValues )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getBooleanStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getIntegerStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDoubleStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getStringStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDateStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getDecimalStatistics (  )  )  ;", "AbstractStatisticsBuilderTest . assertNull ( columnStatistics . getBloomFilter (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNoColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "AbstractStatisticsBuilderTest . assertNotNull ( rangeStatistics )  ;", "AbstractStatisticsBuilderTest . assertEquals ( rangeStatistics . getMin (  )  ,    expectedMin )  ;", "AbstractStatisticsBuilderTest . assertEquals ( rangeStatistics . getMax (  )  ,    expectedMax )  ;", "}", "METHOD_END"], "methodName": ["assertRangeStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "assertValuesInternal ( expectedMin ,    expectedMax ,    values )  ;", "assertValuesInternal ( expectedMin ,    expectedMax ,    ImmutableL . copyOf ( values )  . reverse (  )  )  ;", "L < T >    randomOrder    =    new   ArrayL <  >  ( values )  ;", "Collections . shuffle ( randomOrder ,    new   Random (  4  2  )  )  ;", "assertValuesInternal ( expectedMin ,    expectedMax ,    randomOrder )  ;", "}", "METHOD_END"], "methodName": ["assertValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "B   statisticsBuilder    =    statisticsBuilderSupplier . get (  )  ;", ". AggregateColumnStatistics   aggregateColumnStatistics    =    new    . AggregateColumnStatistics (  )  ;", "aggregateColumnStatistics . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  ,    null ,    null ,    aggregateColumnStatistics )  ;", "for    ( int   loop    =     0  ;    loop    <     4  ;    loop +  +  )     {", "for    ( T   value    :    values )     {", "adder . accept ( statisticsBuilder ,    value )  ;", "aggregateColumnStatistics . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "}", "assertColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     (  ( values . size (  )  )     *     ( loop    +     1  )  )  ,    expectedMin ,    expectedMax ,    aggregateColumnStatistics )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValuesInternal"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    newStatisticsList    =    new   ArrayList <  >  ( statisticsList )  ;", "newStatisticsList . add ( index ,    new   ColumnStatistics ( numberOfValues ,     0  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  )  ;", "return   newStatisticsList ;", "}", "METHOD_END"], "methodName": ["insertEmptyColumnStatisticsAt"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "B   statisticsBuilder    =    statisticsBuilderSupplier . get (  )  ;", ". AggregateColumnStatistics   aggregateColumnStatistics    =    new    . AggregateColumnStatistics (  )  ;", ". assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  )  ;", "aggregateColumnStatistics . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertNoColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatistics ( Optional . empty (  )  )  ,     0  )  ;", ". assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  )  ;", "aggregateColumnStatistics . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertNoColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatistics ( Optional . empty (  )  )  ,     0  )  ;", ". assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  )  ;", "aggregateColumnStatistics . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertNoColumnStatistics ( aggregateColumnStatistics . getMergedColumnStatistics ( Optional . empty (  )  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["testNoValue"], "fileName": "com.facebook.presto.orc.metadata.statistics.AbstractStatisticsBuilderTest"}, {"methodBody": ["METHOD_START", "{", "return   BinaryStatistics . INSTANCE _ SIZE ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.BinaryStatistics"}, {"methodBody": ["METHOD_START", "{", "return   sum ;", "}", "METHOD_END"], "methodName": ["getSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.BinaryStatistics"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "sum    +  =    value . getSum (  )  ;", "}", "METHOD_END"], "methodName": ["addBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( sum )  )  ;", "}", "METHOD_END"], "methodName": ["buildBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "BinaryStatisticsBuilder   binaryStatisticsBuilder    =    new   BinaryStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "BinaryStatistics   partialStatistics    =    columnStatistics . getBinaryStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "binaryStatisticsBuilder . addBinaryStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   binaryStatisticsBuilder . buildBinaryStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   BooleanStatistics . INSTANCE _ SIZE ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatistics"}, {"methodBody": ["METHOD_START", "{", "return   trueValueCount ;", "}", "METHOD_END"], "methodName": ["getTrueValueCount"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatistics"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "trueValueCount    +  =    value . getTrueValueCount (  )  ;", "}", "METHOD_END"], "methodName": ["addBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "( nonNullValueCount )  +  +  ;", "if    ( value )     {", "( trueValueCount )  +  +  ;", "}", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( trueValueCount )  )  ;", "}", "METHOD_END"], "methodName": ["buildBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "BooleanStatisticsBuilder   booleanStatisticsBuilder    =    new   BooleanStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "BooleanStatistics   partialStatistics    =    columnStatistics . getBooleanStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "booleanStatisticsBuilder . addBooleanStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   booleanStatisticsBuilder . buildBooleanStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.BooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   binaryStatistics ;", "}", "METHOD_END"], "methodName": ["getBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   bloomFilter ;", "}", "METHOD_END"], "methodName": ["getBloomFilter"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   booleanStatistics ;", "}", "METHOD_END"], "methodName": ["getBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   dateStatistics ;", "}", "METHOD_END"], "methodName": ["getDateStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   decimalStatistics ;", "}", "METHOD_END"], "methodName": ["getDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   doubleStatistics ;", "}", "METHOD_END"], "methodName": ["getDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   integerStatistics ;", "}", "METHOD_END"], "methodName": ["getIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   minAverageValueSizeInBytes ;", "}", "METHOD_END"], "methodName": ["getMinAverageValueSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   hasNumberOfValues    ?    numberOfValues    :     0  ;", "}", "METHOD_END"], "methodName": ["getNumberOfValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "long   retainedSizeInBytes    =    ColumnStatistics . INSTANCE _ SIZE ;", "if    (  ( booleanStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    booleanStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( integerStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    integerStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( doubleStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    doubleStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( stringStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    stringStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( dateStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    dateStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( decimalStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    decimalStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( binaryStatistics )     !  =    null )     {", "retainedSizeInBytes    +  =    binaryStatistics . getRetainedSizeInBytes (  )  ;", "}", "if    (  ( bloomFilter )     !  =    null )     {", "retainedSizeInBytes    +  =    bloomFilter . getRetainedSizeInBytes (  )  ;", "}", "return   retainedSizeInBytes ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   stringStatistics ;", "}", "METHOD_END"], "methodName": ["getStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return    ( hasNumberOfValues (  )  )     &  &     (  ( numberOfValues )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["hasMinAverageValueSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   hasNumberOfValues ;", "}", "METHOD_END"], "methodName": ["hasNumberOfValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "long   numberOfRows    =    stats . stream (  )  . mapToLong ( ColumnStatistics :  : getNumberOfValues )  . sum (  )  ;", "long   minAverageValueBytes    =     0  ;", "if    ( numberOfRows    >     0  )     {", "minAverageValueBytes    =     ( stats . stream (  )  . mapToLong (  (    s )     -  >     ( s . getMinAverageValueSizeInBytes (  )  )     *     ( s . getNumberOfValues (  )  )  )  . sum (  )  )     /    numberOfRows ;", "}", "return   new   ColumnStatistics ( numberOfRows ,    minAverageValueBytes ,    BooleanStatisticsBuilder . mergeBooleanStatistics ( stats )  . orElse ( null )  ,    IntegerStatisticsBuilder . mergeIntegerStatistics ( stats )  . orElse ( null )  ,    DoubleStatisticsBuilder . mergeDoubleStatistics ( stats )  . orElse ( null )  ,    StringStatisticsBuilder . mergeStringStatistics ( stats )  . orElse ( null )  ,    DateStatisticsBuilder . mergeDateStatistics ( stats )  . orElse ( null )  ,    LongDecimalStatisticsBuilder . mergeDecimalStatistics ( stats )  . orElse ( null )  ,    BinaryStatisticsBuilder . mergeBinaryStatistics ( stats )  . orElse ( null )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["mergeColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics ( getNumberOfValues (  )  ,    minAverageValueSizeInBytes ,    booleanStatistics ,    integerStatistics ,    doubleStatistics ,    stringStatistics ,    dateStatistics ,    decimalStatistics ,    binaryStatistics ,    bloomFilter )  ;", "}", "METHOD_END"], "methodName": ["withBloomFilter"], "fileName": "com.facebook.presto.orc.metadata.statistics.ColumnStatistics"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "Objects . requireNonNull ( value . getMin (  )  ,     \" value . getMin (  )    is   null \"  )  ;", "Objects . requireNonNull ( value . getMax (  )  ,     \" value . getMax (  )    is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "minimum    =    Math . min ( value . getMin (  )  ,    minimum )  ;", "maximum    =    Math . max ( value . getMax (  )  ,    maximum )  ;", "}", "METHOD_END"], "methodName": ["addDateStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( minimum ,    maximum )  )  ;", "}", "METHOD_END"], "methodName": ["buildDateStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "DateStatisticsBuilder   dateStatisticsBuilder    =    new   DateStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "DateStatistics   partialStatistics    =    columnStatistics . getDateStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "dateStatisticsBuilder . addDateStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   dateStatisticsBuilder . buildDateStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeDateStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "Objects . requireNonNull ( value . getMin (  )  ,     \" value . getMin (  )    is   null \"  )  ;", "Objects . requireNonNull ( value . getMax (  )  ,     \" value . getMax (  )    is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "minimum    =    Math . min ( value . getMin (  )  ,    minimum )  ;", "maximum    =    Math . max ( value . getMax (  )  ,    maximum )  ;", "}", "METHOD_END"], "methodName": ["addDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "( nonNullValueCount )  +  +  ;", "if    (  . isNaN ( value )  )     {", "hasNan    =    true ;", "} else    {", "minimum    =    Math . min ( value ,    minimum )  ;", "maximum    =    Math . max ( value ,    maximum )  ;", "}", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "com.facebook.presto.orc.metadata.statistics.DoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( nonNullValueCount )     =  =     0  )     |  |     ( hasNan )  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( minimum ,    maximum )  )  ;", "}", "METHOD_END"], "methodName": ["buildDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "DoubleStatisticsBuilder   doubleStatisticsBuilder    =    new   DoubleStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "DoubleStatistics   partialStatistics    =    columnStatistics . getDoubleStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "doubleStatisticsBuilder . addDoubleStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   doubleStatisticsBuilder . buildDoubleStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeDoubleStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.DoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( HiveBloomFilter . INSTANCE _ SIZE )     +     ( sizeOf ( bitSet . getData (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.HiveBloomFilter"}, {"methodBody": ["METHOD_START", "{", "return   hasSum    ?    sum    :    null ;", "}", "METHOD_END"], "methodName": ["getSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.IntegerStatistics"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "Objects . requireNonNull ( value . getMin (  )  ,     \" value . getMin (  )    is   null \"  )  ;", "Objects . requireNonNull ( value . getMax (  )  ,     \" value . getMax (  )    is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "minimum    =    Math . min ( value . getMin (  )  ,    minimum )  ;", "maximum    =    Math . max ( value . getMax (  )  ,    maximum )  ;", "if    (  ( value . getSum (  )  )     =  =    null )     {", "overflow    =    true ;", "} else", "if    (  !  ( overflow )  )     {", "try    {", "sum    =    Math . addExact ( sum ,    value . getSum (  )  )  ;", "}    catch    ( ArithicException   e )     {", "overflow    =    true ;", "}", "}", "}", "METHOD_END"], "methodName": ["addIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.IntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( minimum ,    maximum ,     ( overflow    ?    null    :    sum )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.IntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "IntegerStatisticsBuilder   integerStatisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "IntegerStatistics   partialStatistics    =    columnStatistics . getIntegerStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "integerStatisticsBuilder . addIntegerStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   integerStatisticsBuilder . buildIntegerStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.IntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "Objects . requireNonNull ( value . getMin (  )  ,     \" value . getMin (  )    is   null \"  )  ;", "Objects . requireNonNull ( value . getMax (  )  ,     \" value . getMax (  )    is   null \"  )  ;", "nonNullValueCount    +  =    valueCount ;", "if    (  ( minimum )     =  =    null )     {", "minimum    =    value . getMin (  )  ;", "maximum    =    value . getMax (  )  ;", "} else    {", "minimum    =    minimum . min ( value . getMin (  )  )  ;", "maximum    =    maximum . max ( value . getMax (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.LongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "( nonNullValueCount )  +  +  ;", "if    (  ( minimum )     =  =    null )     {", "minimum    =    value ;", "maximum    =    value ;", "} else    {", "minimum    =    minimum . min ( value )  ;", "maximum    =    maximum . max ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "com.facebook.presto.orc.metadata.statistics.LongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "checkState (  (  (  ( minimum )     !  =    null )     &  &     (  ( maximum )     !  =    null )  )  )  ;", "return   Optional . of ( new   DecimalStatistics ( minimum ,    maximum ,     . LONG _ DECIMAL _ VALUE _ BYTES )  )  ;", "}", "METHOD_END"], "methodName": ["buildDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.LongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "LongDecimalStatisticsBuilder   decimalStatisticsBuilder    =    new   LongDecimalStatisticsBuilder (  )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "DecimalStatistics   partialStatistics    =    columnStatistics . getDecimalStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "decimalStatisticsBuilder . addDecimalStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   decimalStatisticsBuilder . buildDecimalStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.LongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new   DecimalStatistics ( new   BigDecimal ( BigInteger . valueOf ( minimum )  ,    scale )  ,    new   BigDecimal ( BigInteger . valueOf ( maximum )  ,    scale )  ,     . SHORT _ DECIMAL _ VALUE _ BYTES )  )  ;", "}", "METHOD_END"], "methodName": ["buildDecimalStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.ShortDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   sum ;", "}", "METHOD_END"], "methodName": ["getSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatistics"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( value ,     \" value   is   null \"  )  ;", "checkArgument (  ( valueCount    >     0  )  ,     \" valueCount   is    0  \"  )  ;", "checkArgument (  (  (  ( value . getMin (  )  )     !  =    null )     |  |     (  ( value . getMax (  )  )     !  =    null )  )  ,     \" min   and   max   cannot   both   be   null \"  )  ;", "if    (  ( nonNullValueCount )     =  =     0  )     {", "checke (  (  (  ( minimum )     =  =    null )     &  &     (  ( maximum )     =  =    null )  )  )  ;", "minimum    =    value . getMin (  )  ;", "maximum    =    value . getMax (  )  ;", "} else    {", "if    (  (  ( minimum )     !  =    null )     &  &     (  (  ( value . getMin (  )  )     =  =    null )     |  |     (  ( minimum . compareTo ( value . getMin (  )  )  )     >     0  )  )  )     {", "minimum    =    value . getMin (  )  ;", "}", "if    (  (  ( maximum )     !  =    null )     &  &     (  (  ( value . getMax (  )  )     =  =    null )     |  |     (  ( maximum . compareTo ( value . getMax (  )  )  )     <     0  )  )  )     {", "maximum    =    value . getMax (  )  ;", "}", "}", "nonNullValueCount    +  =    valueCount ;", "sum    =    Math . addExact ( sum ,    value . getSum (  )  )  ;", "}", "METHOD_END"], "methodName": ["addStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nonNullValueCount )     =  =     0  )     {", "return   Optional . empty (  )  ;", "}", "minimum    =    dropStringMinMaxIfNecessary ( minimum )  ;", "maximum    =    dropStringMinMaxIfNecessary ( maximum )  ;", "if    (  (  ( minimum )     =  =    null )     &  &     (  ( maximum )     =  =    null )  )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( new    ( minimum ,    maximum ,    sum )  )  ;", "}", "METHOD_END"], "methodName": ["buildStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( minOrMax    =  =    null )     |  |     (  ( minOrMax . length (  )  )     >     ( stringStatisticsLimitInBytes )  )  )     {", "return   null ;", "}", "if    ( minOrMax . isCompact (  )  )     {", "return   minOrMax ;", "}", "return   Slices . copyOf ( minOrMax )  ;", "}", "METHOD_END"], "methodName": ["dropStringMinMaxIfNecessary"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   nonNullValueCount ;", "}", "METHOD_END"], "methodName": ["getNonNullValueCount"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "StringStatisticsBuilder   stringStatisticsBuilder    =    new   StringStatisticsBuilder ( Integer . MAX _ VALUE )  ;", "for    ( ColumnStatistics   columnStatistics    :    stats )     {", "StringStatistics   partialStatistics    =    columnStatistics . getStringStatistics (  )  ;", "if    (  ( columnStatistics . getNumberOfValues (  )  )     >     0  )     {", "if    ( partialStatistics    =  =    null )     {", "return   Optional . empty (  )  ;", "}", "stringStatisticsBuilder . addStringStatistics ( columnStatistics . getNumberOfValues (  )  ,    partialStatistics )  ;", "}", "}", "return   stringStatisticsBuilder . buildStringStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["mergeStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  ( limitInBytes    >  =     0  )  ,     \" limitInBytes   is   less   than    0  \"  )  ;", "return   new    ( limitInBytes ,    nonNullValueCount ,    minimum ,    maximum ,    sum )  ;", "}", "METHOD_END"], "methodName": ["withStringStatisticsLimit"], "fileName": "com.facebook.presto.orc.metadata.statistics.StringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   columnStatistics ;", "}", "METHOD_END"], "methodName": ["getColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.StripeStatistics"}, {"methodBody": ["METHOD_START", "{", "return   retainedSizeInBytes ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.StripeStatistics"}, {"methodBody": ["METHOD_START", "{", "if    ( expectedNumberOfValues    >     0  )     {", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,    expectedNumberOfValues )  ;", "assertEquals ( columnStatistics . ge (  )  . getSum (  )  ,    expectedSum )  ;", "} else    {", "assertNull ( columnStatistics . ge (  )  )  ;", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertBinaryStatistics ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  ,    expectedNumberOfValues ,    expectedSum )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     0  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,    statisticsList . size (  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     (  ( statisticsList . size (  )  )     /     2  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedBinaryStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "BinaryStatisticsBuilder   statisticsBuilder    =    new   BinaryStatisticsBuilder (  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBinaryStatistics ( statisticsList ,     0  ,     0  )  ;", "statisticsBuilder . addValue ( EMPTY _ SLICE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBinaryStatistics ( statisticsList ,     1  ,     0  )  ;", "statisticsBuilder . addValue (  . FIRST _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBinaryStatistics ( statisticsList ,     3  ,     . FIRST _ VALUE . length (  )  )  ;", "statisticsBuilder . addValue (  . SECOND _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBinaryStatistics ( statisticsList ,     6  ,     (  (  (  . FIRST _ VALUE . length (  )  )     *     2  )     +     (  . SECOND _ VALUE . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMerge"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes ( BinaryStatistics . BINARY _ VALUE _ BYTES _ OVERHEAD ,    ImmutableList . of ( EMPTY _ SLICE )  )  ;", "assertMinAverageValueBytes (  (  (  . FIRST _ VALUE . length (  )  )     +     ( BinaryStatistics . BINARY _ VALUE _ BYTES _ OVERHEAD )  )  ,    ImmutableList . of (  . FIRST _ VALUE )  )  ;", "assertMinAverageValueBytes (  (  (  (  (  . FIRST _ VALUE . length (  )  )     +     (  . SECOND _ VALUE . length (  )  )  )     /     2  )     +     ( BinaryStatistics . BINARY _ VALUE _ BYTES _ OVERHEAD )  )  ,    ImmutableList . of (  . FIRST _ VALUE ,     . SECOND _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues ( EMPTY _ SLICE ,    EMPTY _ SLICE )  ;", "assertMinMaxValues (  . FIRST _ VALUE ,     . SECOND _ VALUE )  ;", "assertMinMaxValues (  . SECOND _ VALUE ,     . FIRST _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "BinaryStatisticsBuilder   binaryStatisticsBuilder    =    new   BinaryStatisticsBuilder (  )  ;", "for    ( Slice   value    :    ImmutableList . of ( EMPTY _ SLICE ,     . FIRST _ VALUE ,     . SECOND _ VALUE )  )     {", "binaryStatisticsBuilder . addValue ( value )  ;", "}", "assertBinaryStatistics ( binaryStatisticsBuilder . buildColumnStatistics (  )  ,     3  ,     (  (  ( EMPTY _ SLICE . length (  )  )     +     (  . FIRST _ VALUE . length (  )  )  )     +     (  . SECOND _ VALUE . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBinaryStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( expectedNumberOfValues    >     0  )     {", "assertColumnStatistics ( columnStatistics ,    expectedNumberOfValues ,    null ,    null )  ;", "assertEquals ( columnStatistics . ge (  )  . getTrueValueCount (  )  ,    trueValueCount )  ;", "}", "}", "METHOD_END"], "methodName": ["assertBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertBooleanStatistics ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  ,    expectedNumberOfValues ,    trueValueCount )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     0  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,    statisticsList . size (  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     (  ( statisticsList . size (  )  )     /     2  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedBooleanStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "BooleanStatisticsBuilder   statisticsBuilder    =    new   BooleanStatisticsBuilder (  )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  ,     0  )  ;", "statisticsBuilder . addValue ( false )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     1  ,     0  )  ;", "statisticsBuilder . addValue ( false )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     2  ,     0  )  ;", "statisticsBuilder . addValue ( true )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     3  ,     1  )  ;", "statisticsBuilder . addValue ( true )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     4  ,     2  )  ;", "statisticsBuilder    =    new   BooleanStatisticsBuilder (  )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     0  ,     0  )  ;", "statisticsBuilder . addValue ( true )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     1  ,     1  )  ;", "statisticsBuilder . addValue ( true )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     2  ,     2  )  ;", "statisticsBuilder . addValue ( false )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     3  ,     2  )  ;", "statisticsBuilder . addValue ( false )  ;", "assertBooleanStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     4  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["testAddValueValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "statisticsBuilder    =    new    (  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBooleanStatistics ( statisticsList ,     0  ,     0  )  ;", "statisticsBuilder . addValue ( false )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBooleanStatistics ( statisticsList ,     1  ,     0  )  ;", "statisticsBuilder . addValue ( false )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBooleanStatistics ( statisticsList ,     3  ,     0  )  ;", "statisticsBuilder . addValue ( true )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBooleanStatistics ( statisticsList ,     6  ,     1  )  ;", "statisticsBuilder . addValue ( true )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedBooleanStatistics ( statisticsList ,     1  0  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testMerge"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes (  . BOOLEAN _ VALUE _ BYTES ,    ImmutableList . of ( true )  )  ;", "assertMinAverageValueBytes (  . BOOLEAN _ VALUE _ BYTES ,    ImmutableList . of ( false )  )  ;", "assertMinAverageValueBytes (  . BOOLEAN _ VALUE _ BYTES ,    ImmutableList . of ( true ,    true ,    false ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestBooleanStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMax (  0  ,     4  2  )  ;", "assertMinMax (  4  2  ,     4  2  )  ;", "assertMinMax ( Inger . MIN _ VALUE ,     4  2  )  ;", "assertMinMax (  4  2  ,    Inger . MAX _ VALUE )  ;", "assertMinMax ( Inger . MIN _ VALUE ,    Inger . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDateStatistics"}, {"methodBody": ["METHOD_START", "{", "assertRetainedSize (  0  ,     4  2  ,    TestDateStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2  ,     4  2  ,    TestDateStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Integer . MIN _ VALUE ,     4  2  ,    TestDateStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2  ,    Integer . MAX _ VALUE ,    TestDateStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Integer . MIN _ VALUE ,    Integer . MAX _ VALUE ,    TestDateStatistics . INSTANCE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["testRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDateStatistics"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes (  . DATE _ VALUE _ BYTES ,    ImmutableList . of (  4  2  )  )  ;", "assertMinAverageValueBytes (  . DATE _ VALUE _ BYTES ,    ImmutableList . of (  0  )  )  ;", "assertMinAverageValueBytes (  . DATE _ VALUE _ BYTES ,    ImmutableList . of (  0  ,     4  2  ,     4  2  ,     4  3  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues (  0  ,     0  )  ;", "assertMinMaxValues (  4  2  ,     4  2  )  ;", "assertMinMaxValues ( Integer . MIN _ VALUE ,    Integer . MIN _ VALUE )  ;", "assertMinMaxValues ( Integer . MAX _ VALUE ,    Integer . MAX _ VALUE )  ;", "assertMinMaxValues (  0  ,     4  2  )  ;", "assertMinMaxValues (  4  2  ,     4  2  )  ;", "assertMinMaxValues ( Integer . MIN _ VALUE ,     4  2  )  ;", "assertMinMaxValues (  4  2  ,    Integer . MAX _ VALUE )  ;", "assertMinMaxValues ( Integer . MIN _ VALUE ,    Integer . MAX _ VALUE )  ;", "assertValues (  (  -  4  2  )  ,     0  ,    ContiguousSet . create ( Range . closed (  (  -  4  2  )  ,     0  )  ,    DiscreteDomain . integers (  )  )  . asL (  )  )  ;", "assertValues (  (  -  4  2  )  ,     4  2  ,    ContiguousSet . create ( Range . closed (  (  -  4  2  )  ,     4  2  )  ,    DiscreteDomain . integers (  )  )  . asL (  )  )  ;", "assertValues (  0  ,     4  2  ,    ContiguousSet . create ( Range . closed (  0  ,     4  2  )  ,    DiscreteDomain . integers (  )  )  . asL (  )  )  ;", "assertValues ( Integer . MIN _ VALUE ,     (  ( Integer . MIN _ VALUE )     +     4  2  )  ,    ContiguousSet . create ( Range . closed ( Integer . MIN _ VALUE ,     (  ( Integer . MIN _ VALUE )     +     4  2  )  )  ,    DiscreteDomain . integers (  )  )  . asL (  )  )  ;", "assertValues (  (  ( Integer . MAX _ VALUE )     -     4  2  )  ,    Integer . MAX _ VALUE ,    ContiguousSet . create ( Range . closed (  (  ( Integer . MAX _ VALUE )     -     4  2  )  ,    Integer . MAX _ VALUE )  ,    DiscreteDomain . integers (  )  )  . asL (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . addValue (  (  ( Integer . MAX _ VALUE )     +     1 L )  )  ;", "fail (  \" Expected   ArithmeticException \"  )  ;", "}    catch    ( ArithmeticException   expected )     {", "}", "try    {", "new    (  )  . addValue (  (  ( Integer . MIN _ VALUE )     -     1 L )  )  ;", "fail (  \" Expected   ArithmeticException \"  )  ;", "}    catch    ( ArithmeticException   expected )     {", "}", "}", "METHOD_END"], "methodName": ["testValueOutOfRange"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDateStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMax ( BigDecimal . ZERO ,    TestDecimalStatistics . MEDIUM _ VALUE )  ;", "assertMinMax ( TestDecimalStatistics . MEDIUM _ VALUE ,    TestDecimalStatistics . MEDIUM _ VALUE )  ;", "assertMinMax ( TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,    TestDecimalStatistics . MEDIUM _ VALUE )  ;", "assertMinMax ( TestDecimalStatistics . MEDIUM _ VALUE ,    TestDecimalStatistics . LARGE _ POSITIVE _ VALUE )  ;", "assertMinMax ( TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,    TestDecimalStatistics . LARGE _ POSITIVE _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDecimalStatistics"}, {"methodBody": ["METHOD_START", "{", "assertRetainedSize ( TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,    TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,     (  (  ( TestDecimalStatistics . INSTANCE _ SIZE )     +     ( TestDecimalStatistics . BIG _ DECIMAL _ INSTANCE _ SIZE )  )     +     ( LongDecimalStatisticsBuilder . LONG _ DECIMAL _ VALUE _ BYTES )  )  )  ;", "assertRetainedSize ( TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,    TestDecimalStatistics . LARGE _ POSITIVE _ VALUE ,     (  ( TestDecimalStatistics . INSTANCE _ SIZE )     +     (  (  ( TestDecimalStatistics . BIG _ DECIMAL _ INSTANCE _ SIZE )     +     ( LongDecimalStatisticsBuilder . LONG _ DECIMAL _ VALUE _ BYTES )  )     *     2  )  )  )  ;", "assertRetainedSize ( null ,    TestDecimalStatistics . LARGE _ POSITIVE _ VALUE ,     (  (  ( TestDecimalStatistics . INSTANCE _ SIZE )     +     ( TestDecimalStatistics . BIG _ DECIMAL _ INSTANCE _ SIZE )  )     +     ( LongDecimalStatisticsBuilder . LONG _ DECIMAL _ VALUE _ BYTES )  )  )  ;", "assertRetainedSize ( TestDecimalStatistics . LARGE _ NEGATIVE _ VALUE ,    null ,     (  (  ( TestDecimalStatistics . INSTANCE _ SIZE )     +     ( TestDecimalStatistics . BIG _ DECIMAL _ INSTANCE _ SIZE )  )     +     ( LongDecimalStatisticsBuilder . LONG _ DECIMAL _ VALUE _ BYTES )  )  )  ;", "assertRetainedSize ( null ,    null ,    TestDecimalStatistics . INSTANCE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["testRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDecimalStatistics"}, {"methodBody": ["METHOD_START", "{", "assertMinMax (  0  .  0  ,     4  2  .  4  2  )  ;", "assertMinMax (  (  -  4  2  .  4  2  )  ,     0  .  0  )  ;", "assertMinMax (  (  -  4  2  .  4  2  )  ,     4  2  .  4  2  )  ;", "assertMinMax (  0  .  0  ,     . POSITIVE _ INFINITY )  ;", "assertMinMax (  . NEGATIVE _ INFINITY ,     0  .  0  )  ;", "assertMinMax (  . NEGATIVE _ INFINITY ,     . POSITIVE _ INFINITY )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatistics"}, {"methodBody": ["METHOD_START", "{", "assertThrows (  (  )     -  >    new   DoubleStatistics (  0  .  0  ,    Double . NaN )  )  ;", "assertThrows (  (  )     -  >    new   DoubleStatistics ( Double . NaN ,     0  .  0  )  )  ;", "assertThrows (  (  )     -  >    new   DoubleStatistics ( Double . NaN ,    Double . NaN )  )  ;", "}", "METHOD_END"], "methodName": ["testNaN"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatistics"}, {"methodBody": ["METHOD_START", "{", "assertRetainedSize (  0  .  0  ,     4  2  .  0  ,    TestDoubleStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2  .  0  ,     4  2  .  0  ,    TestDoubleStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Double . NEGATIVE _ INFINITY ,     4  2  .  0  ,    TestDoubleStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2  .  0  ,    Double . POSITIVE _ INFINITY ,    TestDoubleStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Double . NEGATIVE _ INFINITY ,    Double . POSITIVE _ INFINITY ,    TestDoubleStatistics . INSTANCE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["testRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatistics"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes (  . DOUBLE _ VALUE _ BYTES ,    ImmutableList . of (  4  2  .  0  )  )  ;", "assertMinAverageValueBytes (  . DOUBLE _ VALUE _ BYTES ,    ImmutableList . of (  0  .  0  )  )  ;", "assertMinAverageValueBytes (  . DOUBLE _ VALUE _ BYTES ,    ImmutableList . of (  0  .  0  ,     4  2  .  0  ,     4  2  .  0  ,     4  3  .  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues (  0  .  0  ,     0  .  0  )  ;", "assertMinMaxValues (  4  2  .  4  2  ,     4  2  .  4  2  )  ;", "assertMinMaxValues ( Double . NEGATIVE _ INFINITY ,    Double . NEGATIVE _ INFINITY )  ;", "assertMinMaxValues ( Double . POSITIVE _ INFINITY ,    Double . POSITIVE _ INFINITY )  ;", "assertMinMaxValues (  0  .  0  ,     4  2  .  4  2  )  ;", "assertMinMaxValues (  4  2  .  4  2  ,     4  2  .  4  2  )  ;", "assertMinMaxValues ( Double . NEGATIVE _ INFINITY ,     4  2  .  4  2  )  ;", "assertMinMaxValues (  4  2  .  4  2  ,    Double . POSITIVE _ INFINITY )  ;", "assertMinMaxValues ( Double . NEGATIVE _ INFINITY ,    Double . POSITIVE _ INFINITY )  ;", "assertValues (  0  .  0  ,     8  8  .  8  8  ,     . toDoubleList (  0  .  0  ,     8  8  .  8  8  ,     . ZERO _ TO _  4  2  )  )  ;", "assertValues (  (  -  8  8  .  8  8  )  ,     0  .  0  ,     . toDoubleList (  (  -  8  8  .  8  8  )  ,     0  .  0  ,     . ZERO _ TO _  4  2  )  )  ;", "assertValues (  (  -  4  4  .  4  4  )  ,     4  4  .  4  4  ,     . toDoubleList (  (  -  4  4  .  4  4  )  ,     4  4  .  4  4  ,     . ZERO _ TO _  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "DoubleStatisticsBuilder   statisticsBuilder    =    new   DoubleStatisticsBuilder (  )  ;", "statisticsBuilder . addValue ( Double . NaN )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     1  )  ;", "statisticsBuilder . addValue ( Double . NaN )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     2  )  ;", "statisticsBuilder . addValue (  4  2  .  4  2  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     3  )  ;", "statisticsBuilder    =    new   DoubleStatisticsBuilder (  )  ;", "statisticsBuilder . addValue (  4  2  .  4  2  )  ;", "assertColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     1  ,     4  2  .  4  2  ,     4  2  .  4  2  )  ;", "statisticsBuilder . addValue ( Double . NaN )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     2  )  ;", "statisticsBuilder . addValue (  4  2  .  4  2  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( statisticsBuilder . buildColumnStatistics (  )  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testNanValue"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   values . stream (  )  . flatMap (  (    value )     -  >    Stream . of (  ( maxValue    -    value )  ,     ( minValue    +    value )  )  )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toDoubleList"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestDoubleStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMax (  0 L ,     4  2 L )  ;", "assertMinMax (  4  2 L ,     4  2 L )  ;", "assertMinMax ( Long . MIN _ VALUE ,     4  2 L )  ;", "assertMinMax (  4  2 L ,    Long . MAX _ VALUE )  ;", "assertMinMax ( Long . MIN _ VALUE ,    Long . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatistics"}, {"methodBody": ["METHOD_START", "{", "assertRetainedSize (  0 L ,     4  2 L ,    TestIntegerStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2 L ,     4  2 L ,    TestIntegerStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Long . MIN _ VALUE ,     4  2 L ,    TestIntegerStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize (  4  2 L ,    Long . MAX _ VALUE ,    TestIntegerStatistics . INSTANCE _ SIZE )  ;", "assertRetainedSize ( Long . MIN _ VALUE ,    Long . MAX _ VALUE ,    TestIntegerStatistics . INSTANCE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["testRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatistics"}, {"methodBody": ["METHOD_START", "{", "if    ( expectedNumberOfValues    >     0  )     {", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,    expectedNumberOfValues )  ;", "assertEquals ( columnStatistics . ge (  )  . getSum (  )  ,    expectedSum )  ;", "} else    {", "assertNull ( columnStatistics . ge (  )  )  ;", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "TestIntegerStatisticsBuilder . assertIntegerStatistics ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  ,    expectedNumberOfValues ,    expectedSum )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     0  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,    statisticsList . size (  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     (  ( statisticsList . size (  )  )     /     2  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "IntegerStatisticsBuilder   statisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "statisticsBuilder . addValue ( value )  ;", "return   statisticsBuilder . buildColumnStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["singleValueIntegerStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "IntegerStatisticsBuilder   statisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     0  ,     0 L )  ;", "statisticsBuilder . addValue (  0  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     1  ,     0 L )  ;", "statisticsBuilder . addValue (  (  -  4  4  )  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     3  ,     (  -  4  4 L )  )  ;", "statisticsBuilder . addValue (  1  0  0  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     6  ,     (  (  (  -  4  4 L )     *     2  )     +     1  0  0  )  )  ;", "statisticsBuilder . addValue ( Long . MAX _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     1  0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testMerge"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "statisticsList . add ( new   IntegerStatisticsBuilder (  )  . buildColumnStatistics (  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     0  ,     0 L )  ;", "statisticsList . add (  . singleValueIntegerStatistics ( Long . MAX _ VALUE )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     1  ,    Long . MAX _ VALUE )  ;", "statisticsList . add (  . singleValueIntegerStatistics (  1  )  )  ;", ". assertMergedIntegerStatistics ( statisticsList ,     2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testMergeOverflow"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes (  . INTEGER _ VALUE _ BYTES ,    ImmutableList . of (  4  2 L )  )  ;", "assertMinAverageValueBytes (  . INTEGER _ VALUE _ BYTES ,    ImmutableList . of (  0 L )  )  ;", "assertMinAverageValueBytes (  . INTEGER _ VALUE _ BYTES ,    ImmutableList . of (  0 L ,     4  2 L ,     4  2 L ,     4  3 L )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues (  0 L ,     0 L )  ;", "assertMinMaxValues (  4  2 L ,     4  2 L )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,    Long . MIN _ VALUE )  ;", "assertMinMaxValues ( Long . MAX _ VALUE ,    Long . MAX _ VALUE )  ;", "assertMinMaxValues (  0 L ,     4  2 L )  ;", "assertMinMaxValues (  4  2 L ,     4  2 L )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,     4  2 L )  ;", "assertMinMaxValues (  4  2 L ,    Long . MAX _ VALUE )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,    Long . MAX _ VALUE )  ;", "assertValues (  (  -  4  2 L )  ,     0 L ,    ContiguousSet . create ( Range . closed (  (  -  4  2 L )  ,     0 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  (  -  4  2 L )  ,     4  2 L ,    ContiguousSet . create ( Range . closed (  (  -  4  2 L )  ,     4  2 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  0 L ,     4  2 L ,    ContiguousSet . create ( Range . closed (  0 L ,     4  2 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues ( Long . MIN _ VALUE ,     (  ( Long . MIN _ VALUE )     +     4  2  )  ,    ContiguousSet . create ( Range . closed ( Long . MIN _ VALUE ,     (  ( Long . MIN _ VALUE )     +     4  2  )  )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  (  ( Long . MAX _ VALUE )     -     4  2 L )  ,    Long . MAX _ VALUE ,    ContiguousSet . create ( Range . closed (  (  ( Long . MAX _ VALUE )     -     4  2 L )  ,    Long . MAX _ VALUE )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "int   values    =     0  ;", "long   expectedSum    =     0  ;", "IntegerStatisticsBuilder   integerStatisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "for    ( int   value    =     -  1  0  0  0  0  0  ;    value    <     5  0  0  0  0  0  ;    value +  +  )     {", "values +  +  ;", "expectedSum    +  =    value ;", "integerStatisticsBuilder . addValue ( value )  ;", "}", ". assertIntegerStatistics ( integerStatisticsBuilder . buildColumnStatistics (  )  ,    values ,    expectedSum )  ;", "}", "METHOD_END"], "methodName": ["testSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "IntegerStatisticsBuilder   integerStatisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "integerStatisticsBuilder . addValue ( Long . MAX _ VALUE )  ;", ". assertIntegerStatistics ( integerStatisticsBuilder . buildColumnStatistics (  )  ,     1  ,    Long . MAX _ VALUE )  ;", "integerStatisticsBuilder . addValue (  1  0  )  ;", ". assertIntegerStatistics ( integerStatisticsBuilder . buildColumnStatistics (  )  ,     2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testSumOverflow"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "IntegerStatisticsBuilder   integerStatisticsBuilder    =    new   IntegerStatisticsBuilder (  )  ;", "integerStatisticsBuilder . addValue ( Long . MIN _ VALUE )  ;", ". assertIntegerStatistics ( integerStatisticsBuilder . buildColumnStatistics (  )  ,     1  ,    Long . MIN _ VALUE )  ;", "integerStatisticsBuilder . addValue (  (  -  1  0  )  )  ;", ". assertIntegerStatistics ( integerStatisticsBuilder . buildColumnStatistics (  )  ,     2  ,    null )  ;", "}", "METHOD_END"], "methodName": ["testSumUnderflow"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestIntegerStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "long   longDecimalBytes    =     ( DecimalStatistics . DECIMAL _ VALUE _ BYTES _ OVERHEAD )     +     ( LongDecimalStatisticsBuilder . LONG _ DECIMAL _ VALUE _ BYTES )  ;", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes ( longDecimalBytes ,    ImmutableList . of (  . LARGE _ POSITIVE _ VALUE )  )  ;", "assertMinAverageValueBytes ( longDecimalBytes ,    ImmutableList . of (  . LARGE _ NEGATIVE _ VALUE )  )  ;", "assertMinAverageValueBytes ( longDecimalBytes ,    ImmutableList . of (  . LARGE _ POSITIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . LARGE _ NEGATIVE _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestLongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues ( BigDecimal . ZERO ,    BigDecimal . ZERO )  ;", "assertMinMaxValues (  . MEDIUM _ VALUE ,     . MEDIUM _ VALUE )  ;", "assertMinMaxValues (  . LARGE _ NEGATIVE _ VALUE ,     . LARGE _ NEGATIVE _ VALUE )  ;", "assertMinMaxValues (  . LARGE _ POSITIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE )  ;", "assertMinMaxValues ( BigDecimal . ZERO ,     . MEDIUM _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ VALUE ,     . MEDIUM _ VALUE )  ;", "assertMinMaxValues (  . LARGE _ NEGATIVE _ VALUE ,     . MEDIUM _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ VALUE ,     . LARGE _ POSITIVE _ VALUE )  ;", "assertMinMaxValues (  . LARGE _ NEGATIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE )  ;", "assertValues ( BigDecimal . ZERO ,     . MEDIUM _ VALUE ,     . toBigDecimalList ( BigDecimal . ZERO ,     . MEDIUM _ VALUE ,     . ZERO _ TO _  4  2  )  )  ;", "assertValues (  . LARGE _ NEGATIVE _ VALUE ,     . MEDIUM _ VALUE ,     . toBigDecimalList (  . LARGE _ NEGATIVE _ VALUE ,     . MEDIUM _ VALUE ,     . ZERO _ TO _  4  2  )  )  ;", "assertValues (  . MEDIUM _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . toBigDecimalList (  . MEDIUM _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . ZERO _ TO _  4  2  )  )  ;", "assertValues (  . LARGE _ NEGATIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . toBigDecimalList (  . LARGE _ NEGATIVE _ VALUE ,     . LARGE _ POSITIVE _ VALUE ,     . ZERO _ TO _  4  2  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestLongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   values . stream (  )  . flatMap (  (    value )     -  >    Stream . of ( maxValue . subtract ( BigDecimal . valueOf ( value )  )  ,    minValue . add ( BigDecimal . valueOf ( value )  )  )  )  . collect ( toImmutableList (  )  )  ;", "}", "METHOD_END"], "methodName": ["toBigDecimalList"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestLongDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "long   shortDecimalBytes    =     ( DecimalStatistics . DECIMAL _ VALUE _ BYTES _ OVERHEAD )     +     ( ShortDecimalStatisticsBuilder . SHORT _ DECIMAL _ VALUE _ BYTES )  ;", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes ( shortDecimalBytes ,    ImmutableList . of (  0 L )  )  ;", "assertMinAverageValueBytes ( shortDecimalBytes ,    ImmutableList . of (  4  2 L )  )  ;", "assertMinAverageValueBytes ( shortDecimalBytes ,    ImmutableList . of (  0 L ,     1 L ,     4  2 L ,     4  4 L ,     5  2 L )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestShortDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues (  0 L ,     0 L )  ;", "assertMinMaxValues (  4  2 L ,     4  2 L )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,    Long . MIN _ VALUE )  ;", "assertMinMaxValues ( Long . MAX _ VALUE ,    Long . MAX _ VALUE )  ;", "assertMinMaxValues (  0 L ,     4  2 L )  ;", "assertMinMaxValues (  4  2 L ,     4  2 L )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,     4  2 L )  ;", "assertMinMaxValues (  4  2 L ,    Long . MAX _ VALUE )  ;", "assertMinMaxValues ( Long . MIN _ VALUE ,    Long . MAX _ VALUE )  ;", "assertValues (  (  -  4  2 L )  ,     0 L ,    ContiguousSet . create ( Range . closed (  (  -  4  2 L )  ,     0 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  (  -  4  2 L )  ,     4  2 L ,    ContiguousSet . create ( Range . closed (  (  -  4  2 L )  ,     4  2 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  0 L ,     4  2 L ,    ContiguousSet . create ( Range . closed (  0 L ,     4  2 L )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues ( Long . MIN _ VALUE ,     (  ( Long . MIN _ VALUE )     +     4  2  )  ,    ContiguousSet . create ( Range . closed ( Long . MIN _ VALUE ,     (  ( Long . MIN _ VALUE )     +     4  2  )  )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "assertValues (  (  ( Long . MAX _ VALUE )     -     4  2 L )  ,    Long . MAX _ VALUE ,    ContiguousSet . create ( Range . closed (  (  ( Long . MAX _ VALUE )     -     4  2 L )  ,    Long . MAX _ VALUE )  ,    DiscreteDomain . longs (  )  )  . asL (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestShortDecimalStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . LOW _ BOTTOM _ VALUE )  ;", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . LOW _ TOP _ VALUE )  ;", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . MEDIUM _ TOP _ VALUE )  ;", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMax ( EMPTY _ SLICE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ BOTTOM _ VALUE ,    TestStringStatistics . LOW _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ BOTTOM _ VALUE ,    TestStringStatistics . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ BOTTOM _ VALUE ,    TestStringStatistics . MEDIUM _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ BOTTOM _ VALUE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ BOTTOM _ VALUE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ TOP _ VALUE ,    TestStringStatistics . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ TOP _ VALUE ,    TestStringStatistics . MEDIUM _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ TOP _ VALUE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . LOW _ TOP _ VALUE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . MEDIUM _ BOTTOM _ VALUE ,    TestStringStatistics . MEDIUM _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . MEDIUM _ BOTTOM _ VALUE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . MEDIUM _ BOTTOM _ VALUE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . MEDIUM _ TOP _ VALUE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMax ( TestStringStatistics . MEDIUM _ TOP _ VALUE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "assertMinMax ( TestStringStatistics . HIGH _ BOTTOM _ VALUE ,    TestStringStatistics . HIGH _ TOP _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatistics"}, {"methodBody": ["METHOD_START", "{", "assertRetainedSize ( EMPTY _ SLICE ,    TestStringStatistics . LOW _ BOTTOM _ VALUE ,     (  (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( EMPTY _ SLICE . getRetainedSize (  )  )  )     +     ( TestStringStatistics . LOW _ BOTTOM _ VALUE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( TestStringStatistics . LOW _ TOP _ VALUE ,    TestStringStatistics . LOW _ TOP _ VALUE ,     (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( TestStringStatistics . LOW _ TOP _ VALUE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( EMPTY _ SLICE ,    EMPTY _ SLICE ,     (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( EMPTY _ SLICE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( TestStringStatistics . MEDIUM _ TOP _ VALUE ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE ,     (  (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( TestStringStatistics . MEDIUM _ TOP _ VALUE . getRetainedSize (  )  )  )     +     ( TestStringStatistics . HIGH _ BOTTOM _ VALUE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( null ,    TestStringStatistics . HIGH _ BOTTOM _ VALUE ,     (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( TestStringStatistics . HIGH _ BOTTOM _ VALUE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( EMPTY _ SLICE ,    null ,     (  ( TestStringStatistics . INSTANCE _ SIZE )     +     ( EMPTY _ SLICE . getRetainedSize (  )  )  )  )  ;", "assertRetainedSize ( null ,    null ,    TestStringStatistics . INSTANCE _ SIZE )  ;", "}", "METHOD_END"], "methodName": ["testRetainedSize"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatistics"}, {"methodBody": ["METHOD_START", "{", "assertStringStatistics ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  ,    expectedNumberOfValues ,    expectedSum )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     0  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,    statisticsList . size (  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "AbstractStatisticsBuilderTest . assertNoColumnStatistics ( ColumnStatistics . mergeColumnStatistics ( AbstractStatisticsBuilderTest . insertEmptyColumnStatisticsAt ( statisticsList ,     (  ( statisticsList . size (  )  )     /     2  )  ,     1  0  )  )  ,     ( expectedNumberOfValues    +     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMergedStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( expectedMax    =  =    null )     &  &     ( expectedMin    =  =    null )  )     {", "assertNull ( actual )  ;", "return ;", "}", "assertNotNull ( actual )  ;", "assertEquals ( actual . getMin (  )  ,    expectedMin )  ;", "assertEquals ( actual . getMax (  )  ,    expectedMax )  ;", "}", "METHOD_END"], "methodName": ["assertMinMax"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  ( values    !  =    null )     &  &     (  ( values . size (  )  )     >     0  )  )  )  ;", "StringStatisticsBuilder   builder    =    new   StringStatisticsBuilder ( limit )  ;", "for    ( Slice   value    :    values )     {", "builder . addValue ( value )  ;", "}", ". assertMinMax ( builder . buildColumnStatistics (  )  . getStringStatistics (  )  ,    expectedMin ,    expectedMax )  ;", "}", "METHOD_END"], "methodName": ["assertMinMaxValuesWithLimit"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( expectedNumberOfValues    >     0  )     {", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,    expectedNumberOfValues )  ;", "assertEquals ( columnStatistics . ge (  )  . getSum (  )  ,    expectedSum )  ;", "} else    {", "assertNull ( columnStatistics . ge (  )  )  ;", "assertEquals ( columnStatistics . getNumberOfValues (  )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertStringStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   ColumnStatistics (  1  0  0 L ,     1  0  0  ,    null ,    null ,    null ,     (  ( minimum    =  =    null )     &  &     ( maximum    =  =    null )     ?    null    :    new   StringStatistics ( minimum ,    maximum ,     1  0  0  )  )  ,    null ,    null ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["stringColumnStatistics"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "StringStatisticsBuilder   statisticsBuilder    =    new   StringStatisticsBuilder ( Integer . MAX _ VALUE )  ;", "Slice   shortSlice    =    Slices . wrappedBuffer (  . LONG _ BOTTOM _ VALUE . getBytes (  )  ,     0  ,     1  )  ;", "statisticsBuilder . addValue ( shortSlice )  ;", "Slice   stats    =    statisticsBuilder . buildColumnStatistics (  )  . getStringStatistics (  )  . getMax (  )  ;", "assertNotNull ( stats )  ;", "assertEquals ( stats . getRetainedSize (  )  ,    Slices . wrappedBuffer ( new   byte [  1  ]  )  . getRetainedSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCopyStatsToSaveMemory"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "StringStatisticsBuilder   statisticsBuilder    =    new   StringStatisticsBuilder ( Integer . MAX _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     0  ,     0  )  ;", "statisticsBuilder . addValue ( EMPTY _ SLICE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     1  ,     0  )  ;", "statisticsBuilder . addValue (  . LOW _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     3  ,     . LOW _ BOTTOM _ VALUE . length (  )  )  ;", "statisticsBuilder . addValue (  . LOW _ TOP _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     6  ,     (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     *     2  )     +     (  . LOW _ TOP _ VALUE . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testMerge"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "statisticsList . add (  . stringColumnStatistics (  . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsList . add (  . stringColumnStatistics ( null ,     . MEDIUM _ BOTTOM _ VALUE )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsList . add (  . stringColumnStatistics ( null ,     . MEDIUM _ TOP _ VALUE )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,     . MEDIUM _ TOP _ VALUE )  ;", "statisticsList . add (  . stringColumnStatistics (  . MEDIUM _ TOP _ VALUE ,    null )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,    null )  ;", "statisticsList . add (  . stringColumnStatistics (  . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testMergeWithLimit"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinAverageValueBytes (  0 L ,    ImmutableList . of (  )  )  ;", "assertMinAverageValueBytes ( StringStatistics . STRING _ VALUE _ BYTES _ OVERHEAD ,    ImmutableList . of ( EMPTY _ SLICE )  )  ;", "assertMinAverageValueBytes (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     +     ( StringStatistics . STRING _ VALUE _ BYTES _ OVERHEAD )  )  ,    ImmutableList . of (  . LOW _ BOTTOM _ VALUE )  )  ;", "assertMinAverageValueBytes (  (  (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     +     (  . LOW _ TOP _ VALUE . length (  )  )  )     /     2  )     +     ( StringStatistics . STRING _ VALUE _ BYTES _ OVERHEAD )  )  ,    ImmutableList . of (  . LOW _ BOTTOM _ VALUE ,     . LOW _ TOP _ VALUE )  )  ;", "}", "METHOD_END"], "methodName": ["testMinAverageValueBytes"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "assertMinMaxValues ( EMPTY _ SLICE ,    EMPTY _ SLICE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . LOW _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . LOW _ TOP _ VALUE ,     . LOW _ TOP _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ TOP _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "assertMinMaxValues (  . HIGH _ BOTTOM _ VALUE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . HIGH _ TOP _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . LOW _ BOTTOM _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . LOW _ TOP _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . MEDIUM _ TOP _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues ( EMPTY _ SLICE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . LOW _ TOP _ VALUE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . LOW _ BOTTOM _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues (  . LOW _ TOP _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . LOW _ TOP _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "assertMinMaxValues (  . LOW _ TOP _ VALUE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . LOW _ TOP _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ BOTTOM _ VALUE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ BOTTOM _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ TOP _ VALUE ,     . HIGH _ BOTTOM _ VALUE )  ;", "assertMinMaxValues (  . MEDIUM _ TOP _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "assertMinMaxValues (  . HIGH _ BOTTOM _ VALUE ,     . HIGH _ TOP _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValues"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "TestStringStatisticsBuilder . assertMinMaxValuesWithLimit ( TestStringStatisticsBuilder . MEDIUM _ TOP _ VALUE ,    null ,    ImmutableList . of ( TestStringStatisticsBuilder . MEDIUM _ TOP _ VALUE ,    TestStringStatisticsBuilder . HIGH _ BOTTOM _ VALUE )  ,     7  )  ;", "TestStringStatisticsBuilder . assertMinMaxValuesWithLimit ( null ,    TestStringStatisticsBuilder . MEDIUM _ TOP _ VALUE ,    ImmutableList . of ( TestStringStatisticsBuilder . LONG _ BOTTOM _ VALUE ,    TestStringStatisticsBuilder . MEDIUM _ TOP _ VALUE )  ,     7  )  ;", "TestStringStatisticsBuilder . assertMinMaxValuesWithLimit ( null ,    null ,    ImmutableList . of ( TestStringStatisticsBuilder . LONG _ BOTTOM _ VALUE )  ,     6  )  ;", "}", "METHOD_END"], "methodName": ["testMinMaxValuesWithLimit"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < ColumnStatistics >    statisticsList    =    new   ArrayList <  >  (  )  ;", "StringStatisticsBuilder   statisticsBuilder    =    new   StringStatisticsBuilder (  7  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     0  ,     0  )  ;", "statisticsBuilder . addValue (  . LOW _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     1  ,     . LOW _ BOTTOM _ VALUE . length (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . LOW _ BOTTOM _ VALUE ,     . LOW _ BOTTOM _ VALUE )  ;", "statisticsBuilder . addValue (  . LOW _ TOP _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     3  ,     (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     *     2  )     +     (  . LOW _ TOP _ VALUE . length (  )  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . LOW _ BOTTOM _ VALUE ,     . LOW _ TOP _ VALUE )  ;", "statisticsBuilder . addValue (  . HIGH _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     6  ,     (  (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     *     3  )     +     (  (  . LOW _ TOP _ VALUE . length (  )  )     *     2  )  )     +     (  . HIGH _ BOTTOM _ VALUE . length (  )  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . LOW _ BOTTOM _ VALUE ,    null )  ;", "statisticsBuilder . addValue (  . HIGH _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     1  0  ,     (  (  (  (  . LOW _ BOTTOM _ VALUE . length (  )  )     *     4  )     +     (  (  . LOW _ TOP _ VALUE . length (  )  )     *     3  )  )     +     (  (  . HIGH _ BOTTOM _ VALUE . length (  )  )     *     3  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . LOW _ BOTTOM _ VALUE ,    null )  ;", "statisticsList    =    new   ArrayList <  >  (  )  ;", "statisticsBuilder    =    new   StringStatisticsBuilder (  7  )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     0  ,     0  )  ;", "statisticsBuilder . addValue (  . MEDIUM _ TOP _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     1  ,     . MEDIUM _ TOP _ VALUE . length (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . MEDIUM _ TOP _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "statisticsBuilder . addValue (  . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     3  ,     (  (  (  . MEDIUM _ TOP _ VALUE . length (  )  )     *     2  )     +     (  . MEDIUM _ BOTTOM _ VALUE . length (  )  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ TOP _ VALUE )  ;", "statisticsBuilder . addValue (  . LONG _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     6  ,     (  (  (  (  . MEDIUM _ TOP _ VALUE . length (  )  )     *     3  )     +     (  (  . MEDIUM _ BOTTOM _ VALUE . length (  )  )     *     2  )  )     +     (  . LONG _ BOTTOM _ VALUE . length (  )  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,     . MEDIUM _ TOP _ VALUE )  ;", "statisticsBuilder . addValue (  . LONG _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", "assertMergedStringStatistics ( statisticsList ,     1  0  ,     (  (  (  (  . MEDIUM _ TOP _ VALUE . length (  )  )     *     4  )     +     (  (  . MEDIUM _ BOTTOM _ VALUE . length (  )  )     *     3  )  )     +     (  (  . LONG _ BOTTOM _ VALUE . length (  )  )     *     3  )  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,     . MEDIUM _ TOP _ VALUE )  ;", "statisticsList    =    new   ArrayList <  >  (  )  ;", "statisticsBuilder    =    new   StringStatisticsBuilder (  7  )  ;", "statisticsBuilder . addValue (  . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,     . MEDIUM _ BOTTOM _ VALUE ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsBuilder . addValue (  . LONG _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,     . MEDIUM _ BOTTOM _ VALUE )  ;", "statisticsBuilder . addValue (  . HIGH _ TOP _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,    null )  ;", "statisticsBuilder . addValue (  . HIGH _ BOTTOM _ VALUE )  ;", "statisticsList . add ( statisticsBuilder . buildColumnStatistics (  )  )  ;", ". assertMinMax ( ColumnStatistics . mergeColumnStatistics ( statisticsList )  . getStringStatistics (  )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["testMixingAddValueAndMergeWithLimit"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "StringStatisticsBuilder   stringStatisticsBuilder    =    new   StringStatisticsBuilder ( Integer . MAX _ VALUE )  ;", "for    ( Slice   value    :    ImmutableList . of ( EMPTY _ SLICE ,     . LOW _ BOTTOM _ VALUE ,     . LOW _ TOP _ VALUE )  )     {", "stringStatisticsBuilder . addValue ( value )  ;", "}", "assertStringStatistics ( stringStatisticsBuilder . buildColumnStatistics (  )  ,     3  ,     (  (  ( EMPTY _ SLICE . length (  )  )     +     (  . LOW _ BOTTOM _ VALUE . length (  )  )  )     +     (  . LOW _ TOP _ VALUE . length (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSum"], "fileName": "com.facebook.presto.orc.metadata.statistics.TestStringStatisticsBuilder"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.BooleanStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.ByteStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nullVector . length )     <     ( nextBatchSize )  )     {", "nullVector    =    new   lean [ nextBatchSize ]  ;", "scaleVector    =    new   long [ nextBatchSize ]  ;", "}", "}", "METHOD_END"], "methodName": ["allocateVectors"], "fileName": "com.facebook.presto.orc.reader.DecimalStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "d    =    dSource . openStream (  )  ;", "scaleStream    =    scaleStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.DecimalStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( readOffset )     >     0  )     {", "if    (  ( presentStream )     !  =    null )     {", "readOffset    =    presentStream . countBitsSet ( readOffset )  ;", "}", "if    (  ( readOffset )     >     0  )     {", "if    (  ( d )     =  =    null )     {", "throw   new   OrcCorruptionException ( streamDescriptor . getOrcDataSourceId (  )  ,     \" Value   is   not   null   but   decimal   stream   is   not   present \"  )  ;", "}", "if    (  ( scaleStream )     =  =    null )     {", "throw   new   OrcCorruptionException ( streamDescriptor . getOrcDataSourceId (  )  ,     \" Value   is   not   null   but   scale   stream   is   not   present \"  )  ;", "}", "d . skip ( readOffset )  ;", "scaleStream . skip ( readOffset )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["seekToOffset"], "fileName": "com.facebook.presto.orc.reader.DecimalStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.DoubleStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.FloatStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "lengthStream    =    lengthStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.ListStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( dictionaryOpen )  )     &  &     (  ( dictionarySize )     >     0  )  )     {", "if    (  ( dictionary . length )     <     ( dictionarySize )  )     {", "dictionary    =    new   long [ dictionarySize ]  ;", "}", "LongInputStream   dictionaryStream    =    dictionaryDataStreamSource . openStream (  )  ;", "if    ( dictionaryStream    =  =    null )     {", "throw   new   OrcCorruptionException ( streamDescriptor . getOrcDataSourceId (  )  ,     \" Dictionary   is   not   empty   but   data   stream   is   not   present \"  )  ;", "}", "dictionaryStream . nextLongVector ( dictionarySize ,    dictionary )  ;", "}", "dictionaryOpen    =    true ;", "presentStream    =    presentStreamSource . openStream (  )  ;", "in    =    inSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.LongDictionaryStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.LongDirectStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( MapStreamReader . hasNull ( keys )  )  )     {", "return   new   Block [  ]  {    keys ,    values    }  ;", "}", "IntArrayList   nonNullPositions    =    new   IntArrayList ( keys . getPositionCount (  )  )  ;", "int   position    =     0  ;", "for    ( int   mapIndex    =     0  ;    mapIndex    <    positionCount ;    mapIndex +  +  )     {", "int   length    =    lengths [ mapIndex ]  ;", "for    ( int   entryIndex    =     0  ;    entryIndex    <    length ;    entryIndex +  +  )     {", "if    ( keys . isNull ( position )  )     {", "( lengths [ mapIndex ]  )  -  -  ;", "} else    {", "nonNullPositions . add ( position )  ;", "}", "position +  +  ;", "}", "}", "Block   newKeys    =    keys . copyPositions ( nonNullPositions . elements (  )  ,     0  ,    nonNullPositions . size (  )  )  ;", "Block   newValues    =    values . copyPositions ( nonNullPositions . elements (  )  ,     0  ,    nonNullPositions . size (  )  )  ;", "return   new   Block [  ]  {    newKeys ,    newValues    }  ;", "}", "METHOD_END"], "methodName": ["createKeyValueBlock"], "fileName": "com.facebook.presto.orc.reader.MapStreamReader"}, {"methodBody": ["METHOD_START", "{", "for    ( int   position    =     0  ;    position    <     ( keys . getPositionCount (  )  )  ;    position +  +  )     {", "if    ( keys . isNull ( position )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasNull"], "fileName": "com.facebook.presto.orc.reader.MapStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "lengthStream    =    lengthStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.MapStreamReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( stripeDictionaryOpen )  )     {", "if    (  ( stripeDictionarySize )     >     0  )     {", "if    (  ( stripeDictionaryLength . length )     <     ( stripeDictionarySize )  )     {", "stripeDictionaryLength    =    new   int [ stripeDictionarySize ]  ;", "}", "LongInputStream   lengthStream    =    stripeDictionaryLengthStreamSource . openStream (  )  ;", "if    ( lengthStream    =  =    null )     {", "throw   new   OrcCorruptionException ( streamDescriptor . getOrcDataSourceId (  )  ,     \" Dictionary   is   not   empty   but   dictionary   length   stream   is   not   present \"  )  ;", "}", "lengthStream . nextIntVector ( stripeDictionarySize ,    stripeDictionaryLength )  ;", "long   dataLength    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( stripeDictionarySize )  ;    i +  +  )     {", "dataLength    +  =    stripeDictionaryLength [ i ]  ;", "}", "stripeDictionaryData    =    new   byte [ Math . toIntExact ( dataLength )  ]  ;", "stripeDictionaryOffsetVector    =    new   int [  ( stripeDictionarySize )     +     2  ]  ;", "ByteArrayInputStream   dictionaryDataStream    =    stripeDictionaryDataStreamSource . openStream (  )  ;", ". readDictionary ( dictionaryDataStream ,    stripeDictionarySize ,    stripeDictionaryLength ,     0  ,    stripeDictionaryData ,    stripeDictionaryOffsetVector ,    type )  ;", "} else    {", "stripeDictionaryData    =     . EMPTY _ DICTIONARY _ DATA ;", "stripeDictionaryOffsetVector    =     . EMPTY _ DICTIONARY _ OFFSETS ;", "}", "}", "stripeDictionaryOpen    =    true ;", "RowGroupDictionaryLengthInputStream   dictionaryLengthStream    =    rowGroupDictionaryLengthStreamSource . openStream (  )  ;", "if    ( dictionaryLengthStream    !  =    null )     {", "int   rowGroupDictionarySize    =    dictionaryLengthStream . getEntryCount (  )  ;", "if    (  ( rowGroupDictionaryLength . length )     <    rowGroupDictionarySize )     {", "rowGroupDictionaryLength    =    new   int [ rowGroupDictionarySize ]  ;", "}", "dictionaryLengthStream . nextIntVector ( rowGroupDictionarySize ,    rowGroupDictionaryLength )  ;", "long   dataLength    =     0  ;", "for    ( int   i    =     0  ;    i    <    rowGroupDictionarySize ;    i +  +  )     {", "dataLength    +  =    rowGroupDictionaryLength [ i ]  ;", "}", "byte [  ]    rowGroupDictionaryData    =    Arrays . copyOf ( stripeDictionaryData ,     (  ( stripeDictionaryOffsetVector [ stripeDictionarySize ]  )     +     ( Math . toIntExact ( dataLength )  )  )  )  ;", "int [  ]    rowGroupDictionaryOffsetVector    =    Arrays . copyOf ( stripeDictionaryOffsetVector ,     (  (  ( stripeDictionarySize )     +    rowGroupDictionarySize )     +     2  )  )  ;", "ByteArrayInputStream   dictionaryDataStream    =    rowGroupDictionaryDataStreamSource . openStream (  )  ;", ". readDictionary ( dictionaryDataStream ,    rowGroupDictionarySize ,    rowGroupDictionaryLength ,    stripeDictionarySize ,    rowGroupDictionaryData ,    rowGroupDictionaryOffsetVector ,    type )  ;", "setDictionaryBlockData ( rowGroupDictionaryData ,    rowGroupDictionaryOffsetVector ,     (  (  ( stripeDictionarySize )     +    rowGroupDictionarySize )     +     1  )  )  ;", "} else    {", "setDictionaryBlockData ( stripeDictionaryData ,    stripeDictionaryOffsetVector ,     (  ( stripeDictionarySize )     +     1  )  )  ;", "}", "presentStream    =    presentStreamSource . openStream (  )  ;", "inDictionaryStream    =    inDictionaryStreamSource . openStream (  )  ;", "dataStream    =    dataStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.SliceDictionaryStreamReader"}, {"methodBody": ["METHOD_START", "{", "Slice   slice    =    Slices . wrappedBuffer ( data )  ;", "if    ( offsetVectorOffset    =  =     0  )     {", "offsetVector [  0  ]     =     0  ;", "}", "for    ( int   i    =     0  ;    i    <    dictionarySize ;    i +  +  )     {", "int   offsetIndex    =    offsetVectorOffset    +    i ;", "int   offset    =    offsetVector [ offsetIndex ]  ;", "int   length    =    dictionaryLengthVector [ i ]  ;", "int   truncatedLength ;", "if    ( length    >     0  )     {", "dictionaryDataStream . next ( data ,    offset ,     ( offset    +    length )  )  ;", "truncatedLength    =    Slice . computeTruncatedLength ( slice ,    offset ,    length ,    type )  ;", "verify (  ( truncatedLength    >  =     0  )  )  ;", "} else    {", "truncatedLength    =     0  ;", "}", "offsetVector [  ( offsetIndex    +     1  )  ]     =     ( offsetVector [ offsetIndex ]  )     +    truncatedLength ;", "}", "}", "METHOD_END"], "methodName": ["readDictionary"], "fileName": "com.facebook.presto.orc.reader.SliceDictionaryStreamReader"}, {"methodBody": ["METHOD_START", "{", "verify (  ( positionCount    >     0  )  )  ;", "if    (  ( currentDictionaryData )     !  =    dictionaryData )     {", "boolean [  ]    isNullVector    =    new   boolean [ positionCount ]  ;", "isNullVector [  ( positionCount    -     1  )  ]     =    true ;", "dictionaryOffsets [ positionCount ]     =    dictionaryOffsets [  ( positionCount    -     1  )  ]  ;", "dictionaryBlock    =    new   spi . block . VariableWidthBlock ( positionCount ,    Slices . wrappedBuffer ( dictionaryData )  ,    dictionaryOffsets ,    isNullVector )  ;", "currentDictionaryData    =    dictionaryData ;", "}", "}", "METHOD_END"], "methodName": ["setDictionaryBlockData"], "fileName": "com.facebook.presto.orc.reader.SliceDictionaryStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "lengthStream    =    lengthStreamSource . openStream (  )  ;", "dataStream    =    dataByteSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.SliceDirectStreamReader"}, {"methodBody": ["METHOD_START", "{", "int   truncatedLength    =    length ;", "if    ( isVarcharType ( type )  )     {", "VarcharType   varcharType    =     (  ( VarcharType )     ( type )  )  ;", "int   codePointCount    =     ( varcharType . isUnbounded (  )  )     ?    length    :    varcharType . getLengthSafe (  )  ;", "truncatedLength    =    byteCount ( slice ,    offset ,    length ,    codePointCount )  ;", "} else", "if    ( isCharType ( type )  )     {", "truncatedLength    =    byteCountWithoutTrailingSpace ( slice ,    offset ,    length ,     (  ( spi . type . CharType )     ( type )  )  . getLength (  )  )  ;", "}", "return   truncatedLength ;", "}", "METHOD_END"], "methodName": ["computeTruncatedLength"], "fileName": "com.facebook.presto.orc.reader.SliceStreamReader"}, {"methodBody": ["METHOD_START", "{", "switch    ( streamDescriptor . getStreamType (  )  )     {", "case   BOOLEAN    :", "return   new   Boolean ( streamDescriptor )  ;", "case   BYTE    :", "return   new   Byte ( streamDescriptor )  ;", "case   SHORT    :", "case   INT    :", "case   LONG    :", "case   DATE    :", "return   new   Long ( streamDescriptor )  ;", "case   FLOAT    :", "return   new   Float ( streamDescriptor )  ;", "case   DOUBLE    :", "return   new   Double ( streamDescriptor )  ;", "case   BINARY    :", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "return   new   Slice ( streamDescriptor )  ;", "case   TIMESTAMP    :", "return   new   Timestamp ( streamDescriptor ,    hiveStorageTimeZone )  ;", "case   LIST    :", "return   new   List ( streamDescriptor ,    hiveStorageTimeZone )  ;", "case   STRUCT    :", "return   new   Struct ( streamDescriptor ,    hiveStorageTimeZone )  ;", "case   MAP    :", "return   new   Map ( streamDescriptor ,    hiveStorageTimeZone )  ;", "case   DECIMAL    :", "return   new   Decimal ( streamDescriptor )  ;", "case   UNION    :", "default    :", "throw   new   IllegalArgumentException (  (  \" Unsupported   type :     \"     +     ( streamDescriptor . getStreamType (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createStreamReader"], "fileName": "com.facebook.presto.orc.reader.StreamReaders"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.StructStreamReader"}, {"methodBody": ["METHOD_START", "{", "long   millis    =     ( seconds    +    baseTimestampInSeconds )     *     ( TimestampStreamReader . MILLIS _ PER _ SECOND )  ;", "long   nanos    =    TimestampStreamReader . parseNanos ( serializedNanos )  ;", "if    (  ( millis    <     0  )     &  &     ( nanos    !  =     0  )  )     {", "millis    -  =     1  0  0  0  ;", "}", "return   millis    +     ( nanos    /     1  0  0  0  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["decodeTimestamp"], "fileName": "com.facebook.presto.orc.reader.TimestampStreamReader"}, {"methodBody": ["METHOD_START", "{", "presentStream    =    presentStreamSource . openStream (  )  ;", "secondsStream    =    secondsStreamSource . openStream (  )  ;", "nanosStream    =    nanosStreamSource . openStream (  )  ;", "rowGroupOpen    =    true ;", "}", "METHOD_END"], "methodName": ["openRowGroup"], "fileName": "com.facebook.presto.orc.reader.TimestampStreamReader"}, {"methodBody": ["METHOD_START", "{", "int   zeros    =     (  ( int )     ( serialized )  )     &     7  ;", "int   ult    =     (  ( int )     ( serialized    >  >  >     3  )  )  ;", "if    ( zeros    !  =     0  )     {", "for    ( int   i    =     0  ;    i    <  =    zeros ;     +  + i )     {", "ult    *  =     1  0  ;", "}", "}", "return   ult ;", "}", "METHOD_END"], "methodName": ["parseNanos"], "fileName": "com.facebook.presto.orc.reader.TimestampStreamReader"}, {"methodBody": ["METHOD_START", "{", "W   outputStream    =    createValueOutputStream (  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "outputStream . reset (  )  ;", "long   retainedBytes    =     0  ;", "for    ( List < T >    group    :    groups )     {", "outputStream . recordCheckpoint (  )  ;", "group . forEach (  (    value )     -  >    writeValue ( outputStream ,    value )  )  ;", ". assertTrue (  (  ( outputStream . getRetainedBytes (  )  )     >  =    retainedBytes )  )  ;", "retainedBytes    =    outputStream . getRetainedBytes (  )  ;", "}", "outputStream . close (  )  ;", "DynamicSliceOutput   sliceOutput    =    new   DynamicSliceOutput (  1  0  0  0  )  ;", "Optional < Stream >    stream    =    outputStream . writeDataStreams (  3  3  ,    sliceOutput )  ;", ". assertTrue ( stream . isPresent (  )  )  ;", ". assertEquals ( stream . get (  )  . getStreamKind (  )  ,    Stream . StreamKind . DATA )  ;", ". assertEquals ( stream . get (  )  . getColumn (  )  ,     3  3  )  ;", "assertEquals ( stream . get (  )  . getLength (  )  ,    sliceOutput . size (  )  )  ;", "List < C >    checkpoints    =    outputStream . getCheckpoints (  )  ;", ". assertEquals ( checkpoints . size (  )  ,    groups . size (  )  )  ;", "R   valueStream    =    createValueStream ( sliceOutput . slice (  )  )  ;", "for    ( List < T >    group    :    groups )     {", "int   index    =     0  ;", "for    ( T   expectedValue    :    group )     {", "index +  +  ;", "T   actualValue    =    readValue ( valueStream )  ;", "if    (  !  ( actualValue . equals ( expectedValue )  )  )     {", ". assertEquals ( actualValue ,    expectedValue ,     (  \" index =  \"     +    index )  )  ;", "}", "}", "}", "for    ( int   groupIndex    =     ( groups . size (  )  )     -     1  ;    groupIndex    >  =     0  ;    groupIndex -  -  )     {", "valueStream . seekToCheckpoint ( checkpoints . get ( groupIndex )  )  ;", "for    ( T   expectedValue    :    groups . get ( groupIndex )  )     {", "T   actualValue    =    readValue ( valueStream )  ;", "if    (  !  ( actualValue . equals ( expectedValue )  )  )     {", ". assertEquals ( actualValue ,    expectedValue )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testWriteValue"], "fileName": "com.facebook.presto.orc.stream.AbstractTestValueStream"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     1  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength1"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     2  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength2"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     2  5  6  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength256"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     3  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength3"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     4  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength4"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     5  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength5"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     6  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength6"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "TestiingUtils . unpackGeneric ( data . buffer ,     0  ,     7  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["baselineLength7"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "BenchmarkLongBitPacker . BenchmarkData   data    =    new   BenchmarkLongBitPacker . BenchmarkData (  )  ;", "data . setup (  )  ;", "new   BenchmarkLongBitPacker (  )  . baselineLength 2  5  6  ( data )  ;", "Options   options    =    new   OptionsBuilder (  )  . verbosity ( NORMAL )  . include (  (  (  \"  .  *  \"     +     ( BenchmarkLongBitPacker . class . getSimpleName (  )  )  )     +     \"  .  *  \"  )  )  . build (  )  ;", "new   Runner ( options )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     1  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength1"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     2  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength2"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     2  5  6  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength256"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     3  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength3"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     4  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength4"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     5  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength5"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     6  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength6"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "data . input . setPosition (  0  )  ;", "data . p . unpack ( data . buffer ,     0  ,     7  ,    data . bits ,    data . input )  ;", "return   data . buffer ;", "}", "METHOD_END"], "methodName": ["optimizedLength7"], "fileName": "com.facebook.presto.orc.stream.BenchmarkLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "return   Integer . bitCount (  ( data    &     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["bitCount"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "if    (  ( items    >     ( bitsInData )  )     &  &     (  ( bitsInData )     >     0  )  )     {", "count    +  =     . bitCount ( data )  ;", "items    -  =    bitsInData ;", "bitsInData    =     0  ;", "}", "while    ( items    >     8  )     {", "count    +  =     . bitCount ( byteStream . next (  )  )  ;", "items    -  =     8  ;", "}", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "if    (  (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  )     {", "count +  +  ;", "}", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countBitsSet"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "type . writeBoolean ( builder ,     (  (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  )  )  ;", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "}", "METHOD_END"], "methodName": ["getSetBits"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "if    ( isNull [ i ]  )     {", "builder . appendNull (  )  ;", "} else    {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "type . writeBoolean ( builder ,     (  (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  )  )  ;", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getSetBits"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "vector [ i ]     =     (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  ;", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "}", "METHOD_END"], "methodName": ["getSetBits"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "if    (  !  ( isNull [ i ]  )  )     {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "vector [ i ]     =     (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  ;", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getSetBits"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( int   i    =     0  ;    i    <    batchSize ;    i +  +  )     {", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "vector [ i ]     =     (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     =  =     0  ;", "if    ( vector [ i ]  )     {", "count +  +  ;", "}", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["getUnsetBits"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bitsInData )     =  =     0  )     {", "readByte (  )  ;", "}", "boolean   result    =     (  ( data )     &     (  . HIGH _ BIT _ MASK )  )     !  =     0  ;", "data    <  <  =     1  ;", "( bitsInData )  -  -  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["nextBit"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  ( bitsInData )     =  =     0  )  )  ;", "data    =    byte . next (  )  ;", "bitsInData    =     8  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "com.facebook.presto.orc.stream.BooleanInputStream"}, {"methodBody": ["METHOD_START", "{", "byteOutputStream . writeByte (  (  ( byte )     ( data )  )  )  ;", "data    =     0  ;", "bitsInData    =     0  ;", "}", "METHOD_END"], "methodName": ["flushData"], "fileName": "com.facebook.presto.orc.stream.BooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "return    (  1     <  <    bits )     -     1  ;", "}", "METHOD_END"], "methodName": ["getLowBitMask"], "fileName": "com.facebook.presto.orc.stream.BooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "if    ( value )     {", "data    |  =     1     <  <     (  7     -     ( bitsInData )  )  ;", "}", "( bitsInData )  +  +  ;", "if    (  ( bitsInData )     =  =     8  )     {", "flushData (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "com.facebook.presto.orc.stream.BooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  ( count    >  =     0  )  ,     \" count   is   negative \"  )  ;", "if    ( count    =  =     0  )     {", "return ;", "}", "if    (  ( bitsInData )     !  =     0  )     {", "int   bitsToWrite    =    Math . min ( count ,     (  8     -     ( bitsInData )  )  )  ;", "if    ( value )     {", "data    |  =     (  . getLowBitMask ( bitsToWrite )  )     <  <     (  (  8     -     ( bitsInData )  )     -    bitsToWrite )  ;", "}", "bitsInData    +  =    bitsToWrite ;", "count    -  =    bitsToWrite ;", "if    (  ( bitsInData )     =  =     8  )     {", "flushData (  )  ;", "} else    {", "verify (  ( count    =  =     0  )  )  ;", "return ;", "}", "}", "verify (  (  ( bitsInData )     =  =     0  )  )  ;", "while    ( count    >  =     8  )     {", "if    ( value )     {", "byteOutputStream . writeByte (  (  ( byte )     (  2  5  5  )  )  )  ;", "} else    {", "byteOutputStream . writeByte (  (  ( byte )     (  0  )  )  )  ;", "}", "count    -  =     8  ;", "}", "if    ( count    >     0  )     {", "if    ( value )     {", "data    =     (  . getLowBitMask ( count )  )     <  <     (  8     -    count )  ;", "}", "bitsInData    =    count ;", "}", "}", "METHOD_END"], "methodName": ["writeBooleans"], "fileName": "com.facebook.presto.orc.stream.BooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "inputStream . readFully ( data ,    offset ,    length )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.facebook.presto.orc.stream.ByteArrayInputStream"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    data    =    new   byte [ length ]  ;", "next ( data ,     0  ,    length )  ;", "return   data ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.facebook.presto.orc.stream.ByteArrayInputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "buffer . writes ( value )  ;", "}", "METHOD_END"], "methodName": ["writeSlice"], "fileName": "com.facebook.presto.orc.stream.ByteArrayOutputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset )     =  =     ( length )  )     {", "dNextBlock (  )  ;", "}", "return   buffer [  (  ( offset )  +  +  )  ]  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.facebook.presto.orc.stream.ByteInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "type . writeLong ( builder ,    next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.ByteInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    ( isNull [ i ]  )     {", "builder . appendNull (  )  ;", "} else    {", "type . writeLong ( builder ,    next (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.ByteInputStream"}, {"methodBody": ["METHOD_START", "{", "lastReadInputCheckpoint    =    input . getCheckpoint (  )  ;", "int   control    =    input . read (  )  ;", "if    ( control    =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Read   past   end   of   buffer   RLE   byte \"  )  ;", "}", "offset    =     0  ;", "if    (  ( control    &     1  2  8  )     =  =     0  )     {", "length    =    control    +     (  . MIN _ REPEAT _ SIZE )  ;", "int   value    =    input . read (  )  ;", "if    ( value    =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Reading   RLE   byte   got   EOF \"  )  ;", "}", "Arrays . fill ( buffer ,     0  ,    length ,     (  ( byte )     ( value )  )  )  ;", "} else    {", "length    =     2  5  6     -    control ;", "input . readFully ( buffer ,     0  ,    length )  ;", "}", "}", "METHOD_END"], "methodName": ["readNextBlock"], "fileName": "com.facebook.presto.orc.stream.ByteInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "return ;", "}", "if    (  ( runCount )     >  =     (  . MIN _ REPEAT _ SIZE )  )     {", "buffer . writeByte (  (  ( runCount )     -     (  . MIN _ REPEAT _ SIZE )  )  )  ;", "buffer . writeByte ( lastValue )  ;", "} else    {", "buffer . writeByte (  (  -  ( size )  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( size )  ;    i +  +  )     {", "buffer . writeByte ( sequenceBuffer [ i ]  )  ;", "}", "}", "size    =     0  ;", "runCount    =     0  ;", "lastValue    =     . UNMATCHABLE _ VALUE ;", "}", "METHOD_END"], "methodName": ["flushSequence"], "fileName": "com.facebook.presto.orc.stream.ByteOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "if    (  ( size )     =  =     ( sequenceBuffer . length )  )     {", "flushSequence (  )  ;", "}", "if    ( value    =  =     ( lastValue )  )     {", "( runCount )  +  +  ;", "} else    {", "if    (  ( runCount )     >  =     (  . MIN _ REPEAT _ SIZE )  )     {", "flushSequence (  )  ;", "}", "runCount    =     1  ;", "}", "sequenceBuffer [ size ]     =    value ;", "( size )  +  +  ;", "if    (  (  ( runCount )     =  =     (  . MIN _ REPEAT _ SIZE )  )     &  &     (  ( size )     >     (  . MIN _ REPEAT _ SIZE )  )  )     {", "size    -  =     . MIN _ REPEAT _ SIZE ;", "runCount    =     0  ;", "flushSequence (  )  ;", "runCount    =     . MIN _ REPEAT _ SIZE ;", "size    =     . MIN _ REPEAT _ SIZE ;", "}", "lastValue    =    value ;", "}", "METHOD_END"], "methodName": ["writeByte"], "fileName": "com.facebook.presto.orc.stream.ByteOutputStream"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( stream ,     \" stream   is   null \"  )  ;", "Objects . requireNonNull ( checkpoint ,     \" checkpoint   is   null \"  )  ;", "C   verifiedCheckpoint    =     (  ( C )     ( checkpoint )  )  ;", "return   new    <  >  ( stream ,    verifiedCheckpoint )  ;", "}", "METHOD_END"], "methodName": ["createCheckpointStreamSource"], "fileName": "com.facebook.presto.orc.stream.CheckpointInputStreamSource"}, {"methodBody": ["METHOD_START", "{", "long   result    =     0  ;", "int   offset    =     0  ;", "long   b ;", "do    {", "b    =    input . read (  )  ;", "if    ( b    =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Reading   BigInteger   past   EOF \"  )  ;", "}", "long   work    =     1  2  7     &    b ;", "if    (  ( offset    >  =     6  3  )     &  &     (  ( offset    !  =     6  3  )     |  |     ( work    >     1  )  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \"    does   not   fit   long    ( invalid   table   schema ?  )  \"  )  ;", "}", "result    |  =    work    <  <    offset ;", "offset    +  =     7  ;", "}    while    ( b    >  =     1  2  8     )  ;", "boolean   isNegative    =     ( result    &     1  )     !  =     0  ;", "if    ( isNegative )     {", "result    +  =     1  ;", "result    =     - result ;", "result    =    result    >  >     1  ;", "result    |  =     1 L    <  <     6  3  ;", "} else    {", "result    =    result    >  >     1  ;", "result    &  =    Long . MAX _ VALUE ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["nextLong"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "long   b ;", "long   offset    =     0  ;", "long   low    =     0  ;", "long   high    =     0  ;", "do    {", "b    =    input . read (  )  ;", "if    (  ( offset    =  =     1  2  6  )     &  &     (  (  ( b    &     1  2  8  )     >     0  )     |  |     (  ( b    &     1  2  7  )     >     3  )  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \"    exceeds    1  2  8    bits \"  )  ;", "}", "if    ( offset    <     6  3  )     {", "low    |  =     ( b    &     1  2  7  )     <  <    offset ;", "} else", "if    ( offset    =  =     6  3  )     {", "low    |  =     ( b    &     1  )     <  <    offset ;", "high    |  =     ( b    &     1  2  7  )     >  >  >     1  ;", "} else    {", "high    |  =     ( b    &     1  2  7  )     <  <     ( offset    -     6  4  )  ;", "}", "offset    +  =     7  ;", "}    while    (  ( b    &     1  2  8  )     >     0     )  ;", "boolean   negative    =     ( low    &     1  )     =  =     1  ;", "low    >  >  >  =     1  ;", "low    |  =     ( high    &     1  )     <  <     6  3  ;", "high    >  >  >  =     1  ;", "if    ( negative )     {", "if    ( low    =  =     -  1 L )     {", "low    =     0  ;", "high    +  =     1  ;", "} else    {", "low    +  =     1  ;", "}", "}", "Unscaled 1  2  8 Arithmetic . pack ( low ,    high ,    negative ,    result )  ;", "}", "METHOD_END"], "methodName": ["nextLongDecimal"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "Slice   decimal    =    UnscaledDecimal 1  2  8 Arithmetic . unscaledDecimal (  )  ;", "Slice   rescaledDecimal    =    UnscaledDecimal 1  2  8 Arithmetic . unscaledDecimal (  )  ;", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "nextLongDecimal ( decimal )  ;", "rescale ( decimal ,     (  ( int )     (  ( targetType . getScale (  )  )     -     ( sourceScale [ i ]  )  )  )  ,    rescaledDecimal )  ;", "targetType . writeSlice ( builder ,    rescaledDecimal )  ;", "}", "}", "METHOD_END"], "methodName": ["nextLongDecimalVector"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "Slice   decimal    =    UnscaledDecimal 1  2  8 Arithmetic . unscaledDecimal (  )  ;", "Slice   rescaledDecimal    =    UnscaledDecimal 1  2  8 Arithmetic . unscaledDecimal (  )  ;", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    (  !  ( isNull [ i ]  )  )     {", "nextLongDecimal ( decimal )  ;", "rescale ( decimal ,     (  ( int )     (  ( targetType . getScale (  )  )     -     ( sourceScale [ i ]  )  )  )  ,    rescaledDecimal )  ;", "targetType . writeSlice ( builder ,    rescaledDecimal )  ;", "} else    {", "builder . appendNull (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["nextLongDecimalVector"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "long   value    =    nextLong (  )  ;", "long   rescaled    =    s . rescale ( value ,     (  ( int )     ( sourceScale [ i ]  )  )  ,    targetType . getScale (  )  )  ;", "targetType . writeLong ( builder ,    rescaled )  ;", "}", "}", "METHOD_END"], "methodName": ["nextShortDecimalVector"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    (  !  ( isNull [ i ]  )  )     {", "long   rescaled    =    s . rescale ( nextLong (  )  ,     (  ( int )     ( sourceScale [ i ]  )  )  ,    targetType . getScale (  )  )  ;", "targetType . writeLong ( builder ,    rescaled )  ;", "} else    {", "builder . appendNull (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["nextShortDecimalVector"], "fileName": "com.facebook.presto.orc.stream.DecimalInputStream"}, {"methodBody": ["METHOD_START", "{", "BigInteger   value    =    Decimals . decodeUnscaledValue ( slice )  ;", "value    =    value . shiftLeft (  1  )  ;", "int   sign    =    value . signum (  )  ;", "if    ( sign    <     0  )     {", "value    =    value . negate (  )  ;", "value    =    value . subtract ( BigInteger . ONE )  ;", "}", "int   length    =    value . bitLength (  )  ;", "while    ( true )     {", "long   lowBits    =     ( value . longValue (  )  )     &     9  2  2  3  3  7  2  0  3  6  8  5  4  7  7  5  8  0  7 L ;", "length    -  =     6  3  ;", "for    ( int   i    =     0  ;    i    <     9  ;     +  + i )     {", "if    (  ( length    <  =     0  )     &  &     (  ( lowBits    &     (  ~  1  2  7  )  )     =  =     0  )  )     {", "buffer . write (  (  ( byte )     ( lowBits )  )  )  ;", "return ;", "} else    {", "buffer . write (  (  ( byte )     (  1  2  8     |     ( lowBits    &     1  2  7  )  )  )  )  ;", "lowBits    >  >  >  =     7  ;", "}", "}", "value    =    value . shiftRight (  6  3  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeUnscaledValue"], "fileName": "com.facebook.presto.orc.stream.DecimalOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "Longode . writeVLong ( buffer ,    value ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeUnscaledValue"], "fileName": "com.facebook.presto.orc.stream.DecimalOutputStream"}, {"methodBody": ["METHOD_START", "{", "input . readFully ( buffer ,     0  ,    SIZE _ OF _ DOUBLE )  ;", "return   slice . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.facebook.presto.orc.stream.DoubleInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "type . write ( builder ,    next (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.DoubleInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    ( isNull [ i ]  )     {", "builder . appendNull (  )  ;", "} else    {", "type . write ( builder ,    next (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.DoubleInputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "buffer . write ( value )  ;", "}", "METHOD_END"], "methodName": ["writeDouble"], "fileName": "com.facebook.presto.orc.stream.DoubleOutputStream"}, {"methodBody": ["METHOD_START", "{", "input . readFully ( buffer ,     0  ,    SIZE _ OF _ FLOAT )  ;", "return   slice . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "com.facebook.presto.orc.stream.FloatInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "type . writeLong ( builder ,     . floatToRawIntBits ( next (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.FloatInputStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    items ;    i +  +  )     {", "if    ( isNull [ i ]  )     {", "builder . appendNull (  )  ;", "} else    {", "type . writeLong ( builder ,     . floatToRawIntBits ( next (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["nextVector"], "fileName": "com.facebook.presto.orc.stream.FloatInputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  !  ( closed )  )  )  ;", "buffer . write ( value )  ;", "}", "METHOD_END"], "methodName": ["writeFloat"], "fileName": "com.facebook.presto.orc.stream.FloatOutputStream"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( streamDescriptor ,     \" streamDescriptor   is   null \"  )  ;", "Objects . requireNonNull ( streamType ,     \" streamType   is   null \"  )  ;", "<  ?  >    streamSource    =    streamSources . get ( new   StreamId ( streamDescriptor . getStreamId (  )  ,    streamKind )  )  ;", "if    ( streamSource    =  =    null )     {", "streamSource    =    Missing . missingStreamSource ( streamType )  ;", "}", "checkArgument ( streamType . isAssignableFrom ( streamSource . getStreamType (  )  )  ,     \"  % s   must   be   of   type    % s ,    not    % s \"  ,    streamDescriptor ,    streamType . getName (  )  ,    streamSource . getStreamType (  )  . getName (  )  )  ;", "return    (  (  < S >  )     ( streamSource )  )  ;", "}", "METHOD_END"], "methodName": ["getInputStreamSource"], "fileName": "com.facebook.presto.orc.stream.InputStreamSources"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  ( len    <  =     ( LongBitPacker . MAX _ BUFFERED _ POSITIONS )  )  ,     \" Expected   ORC   files   to   have   runs   of   at   most    5  1  2    bit   packed   longs \"  )  ;", "switch    ( bitSize )     {", "case    1     :", "unpack 1  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    2     :", "unpack 2  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    4     :", "unpack 4  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    8     :", "unpack 8  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    1  6     :", "unpack 1  6  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    2  4     :", "unpack 2  4  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    3  2     :", "unpack 3  2  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    4  0     :", "unpack 4  0  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    4  8     :", "unpack 4  8  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    5  6     :", "unpack 5  6  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "case    6  4     :", "unpack 6  4  ( buffer ,    offset ,    len ,    input )  ;", "break ;", "default    :", "LongBitPacker . unpackGeneric ( buffer ,    offset ,    len ,    bitSize ,    input )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( len    !  =     0  )     &  &     ( len    <     8  )  )     {", ". unpack 1 Unaligned ( buffer ,    offset ,    len ,    input . read (  )  )  ;", "return ;", "}", "int   blockReadableBytes    =     ( len    +     7  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "int   outputIndex    =    offset ;", "int   end    =    offset    +    len ;", "int   tmpIndex    =     0  ;", "for    (  ;     ( outputIndex    +     7  )     <    end ;    outputIndex    +  =     8  )     {", "long   value ;", "value    =    tmp [ tmpIndex ]  ;", "tmpIndex +  +  ;", "buffer [ outputIndex ]     =     (  1  2  8     &    value )     >  >  >     7  ;", "buffer [  ( outputIndex    +     1  )  ]     =     (  6  4     &    value )     >  >  >     6  ;", "buffer [  ( outputIndex    +     2  )  ]     =     (  3  2     &    value )     >  >  >     5  ;", "buffer [  ( outputIndex    +     3  )  ]     =     (  1  6     &    value )     >  >  >     4  ;", "buffer [  ( outputIndex    +     4  )  ]     =     (  8     &    value )     >  >  >     3  ;", "buffer [  ( outputIndex    +     5  )  ]     =     (  4     &    value )     >  >  >     2  ;", "buffer [  ( outputIndex    +     6  )  ]     =     (  2     &    value )     >  >  >     1  ;", "buffer [  ( outputIndex    +     7  )  ]     =     1     &    value ;", "}", "if    ( outputIndex    <    end )     {", ". unpack 1 Unaligned ( buffer ,    outputIndex ,     ( end    -    outputIndex )  ,    tmp [  ( blockReadableBytes    -     1  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack1"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     1  6  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . d ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     6  5  5  3  5 L    &     ( Short . reverseBytes ( getShortUnchecked ( slice ,     (  2     *    i )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack16"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "switch    ( length )     {", "case    7     :", "buffer [  ( outputIndex    +     6  )  ]     =     (  2     &    value )     >  >  >     1  ;", "case    6     :", "buffer [  ( outputIndex    +     5  )  ]     =     (  4     &    value )     >  >  >     2  ;", "case    5     :", "buffer [  ( outputIndex    +     4  )  ]     =     (  8     &    value )     >  >  >     3  ;", "case    4     :", "buffer [  ( outputIndex    +     3  )  ]     =     (  1  6     &    value )     >  >  >     4  ;", "case    3     :", "buffer [  ( outputIndex    +     2  )  ]     =     (  3  2     &    value )     >  >  >     5  ;", "case    2     :", "buffer [  ( outputIndex    +     1  )  ]     =     (  6  4     &    value )     >  >  >     6  ;", "case    1     :", "buffer [ outputIndex ]     =     (  1  2  8     &    value )     >  >  >     7  ;", "}", "}", "METHOD_END"], "methodName": ["unpack1Unaligned"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( len    !  =     0  )     &  &     ( len    <     4  )  )     {", ". unpack 2 Unaligned ( buffer ,    offset ,    len ,    input . read (  )  )  ;", "return ;", "}", "int   blockReadableBytes    =     (  (  2     *    len )     +     7  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "int   outputIndex    =    offset ;", "int   end    =    offset    +    len ;", "int   tmpIndex    =     0  ;", "for    (  ;     ( outputIndex    +     3  )     <    end ;    outputIndex    +  =     4  )     {", "long   value ;", "value    =    tmp [ tmpIndex ]  ;", "tmpIndex +  +  ;", "buffer [ outputIndex ]     =     (  1  9  2     &    value )     >  >  >     6  ;", "buffer [  ( outputIndex    +     1  )  ]     =     (  4  8     &    value )     >  >  >     4  ;", "buffer [  ( outputIndex    +     2  )  ]     =     (  1  2     &    value )     >  >  >     2  ;", "buffer [  ( outputIndex    +     3  )  ]     =     3     &    value ;", "}", "if    ( outputIndex    <    end )     {", ". unpack 2 Unaligned ( buffer ,    outputIndex ,     ( end    -    outputIndex )  ,    tmp [  ( blockReadableBytes    -     1  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack2"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     2  4  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . d ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     1  6  7  7  7  2  1  5 L    &     (  ( Integer . reverseBytes ( getIntUnchecked ( slice ,     (  3     *    i )  )  )  )     >  >  >     8  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack24"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "switch    ( length )     {", "case    3     :", "buffer [  ( outputIndex    +     2  )  ]     =     (  1  2     &    value )     >  >  >     2  ;", "case    2     :", "buffer [  ( outputIndex    +     1  )  ]     =     (  4  8     &    value )     >  >  >     4  ;", "case    1     :", "buffer [ outputIndex ]     =     (  1  9  2     &    value )     >  >  >     6  ;", "}", "}", "METHOD_END"], "methodName": ["unpack2Unaligned"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     3  2  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . d ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     4  2  9  4  9  6  7  2  9  5 L    &     ( Integer . reverseBytes ( getIntUnchecked ( slice ,     (  4     *    i )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack32"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( len    !  =     0  )     &  &     ( len    <     3  )  )     {", "int   value    =    input . d (  )  ;", "buffer [ offset ]     =     (  2  4  0     &    value )     >  >  >     4  ;", "if    ( len    =  =     2  )     {", "buffer [  ( offset    +     1  )  ]     =     1  5     &    value ;", "}", "return ;", "}", "int   blockReadableBytes    =     (  (  4     *    len )     +     7  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . d ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "int   outputIndex    =    offset ;", "int   end    =    offset    +    len ;", "int   tmpIndex    =     0  ;", "for    (  ;     ( outputIndex    +     1  )     <    end ;    outputIndex    +  =     2  )     {", "long   value ;", "value    =    tmp [ tmpIndex ]  ;", "tmpIndex +  +  ;", "buffer [ outputIndex ]     =     (  2  4  0     &    value )     >  >  >     4  ;", "buffer [  ( outputIndex    +     1  )  ]     =     1  5     &    value ;", "}", "if    ( outputIndex    !  =    end )     {", "buffer [ outputIndex ]     =     (  2  4  0     &     ( tmp [  ( blockReadableBytes    -     1  )  ]  )  )     >  >  >     4  ;", "}", "}", "METHOD_END"], "methodName": ["unpack4"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     4  0  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     (  . reverseBytes ( getUnchecked ( slice ,     (  5     *    i )  )  )  )     >  >  >     2  4  ;", "}", "}", "METHOD_END"], "methodName": ["unpack40"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     4  8  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     (  . reverseBytes ( getUnchecked ( slice ,     (  6     *    i )  )  )  )     >  >  >     1  6  ;", "}", "}", "METHOD_END"], "methodName": ["unpack48"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     5  6  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     (  . reverseBytes ( getUnchecked ( slice ,     (  7     *    i )  )  )  )     >  >  >     8  ;", "}", "}", "METHOD_END"], "methodName": ["unpack56"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   blockReadableBytes    =     ( len    *     6  4  )     /     8  ;", "for    ( int   i    =     0  ;    i    <    blockReadableBytes ;  )     {", "i    +  =    input . read ( tmp ,    i ,     ( blockReadableBytes    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     . reverseBytes ( getUnchecked ( slice ,     (  8     *    i )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack64"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    len ;  )     {", "i    +  =    input . d ( tmp ,    i ,     ( len    -    i )  )  ;", "}", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "buffer [  ( offset    +    i )  ]     =     2  5  5 L    &     ( tmp [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack8"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "int   bitsLeft    =     0  ;", "int   current    =     0  ;", "for    ( int   i    =    offset ;    i    <     ( offset    +    len )  ;    i +  +  )     {", "l   result    =     0  ;", "int   bitsLeftToRead    =    bitSize ;", "while    ( bitsLeftToRead    >    bitsLeft )     {", "result    <  <  =    bitsLeft ;", "result    |  =    current    &     (  (  1     <  <    bitsLeft )     -     1  )  ;", "bitsLeftToRead    -  =    bitsLeft ;", "current    =    input . read (  )  ;", "bitsLeft    =     8  ;", "}", "if    ( bitsLeftToRead    >     0  )     {", "result    <  <  =    bitsLeftToRead ;", "bitsLeft    -  =    bitsLeftToRead ;", "result    |  =     ( current    >  >    bitsLeft )     &     (  (  1     <  <    bitsLeftToRead )     -     1  )  ;", "}", "buffer [ i ]     =    result ;", "}", "}", "METHOD_END"], "methodName": ["unpackGeneric"], "fileName": "com.facebook.presto.orc.stream.LongBitPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( n    >  =     ( LongDecode . FixedBitSizes . ONE . ordinal (  )  )  )     &  &     ( n    <  =     ( LongDecode . FixedBitSizes . TWENTY _ FOUR . ordinal (  )  )  )  )     {", "return   n    +     1  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . TWENTY _ SIX . ordinal (  )  )  )     {", "return    2  6  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . TWENTY _ EIGHT . ordinal (  )  )  )     {", "return    2  8  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . THIRTY . ordinal (  )  )  )     {", "return    3  0  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . THIRTY _ TWO . ordinal (  )  )  )     {", "return    3  2  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . FORTY . ordinal (  )  )  )     {", "return    4  0  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . FORTY _ EIGHT . ordinal (  )  )  )     {", "return    4  8  ;", "} else", "if    ( n    =  =     ( LongDecode . FixedBitSizes . FIFTY _ SIX . ordinal (  )  )  )     {", "return    5  6  ;", "} else    {", "return    6  4  ;", "}", "}", "METHOD_END"], "methodName": ["decodeBitWidth"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "if    ( width    =  =     0  )     {", "turn    1  ;", "}", "if    (  ( width    >  =     1  )     &  &     ( width    <  =     2  4  )  )     {", "turn   width ;", "} else", "if    (  ( width    >     2  4  )     &  &     ( width    <  =     2  6  )  )     {", "turn    2  6  ;", "} else", "if    (  ( width    >     2  6  )     &  &     ( width    <  =     2  8  )  )     {", "turn    2  8  ;", "} else", "if    (  ( width    >     2  8  )     &  &     ( width    <  =     3  0  )  )     {", "turn    3  0  ;", "} else", "if    (  ( width    >     3  0  )     &  &     ( width    <  =     3  2  )  )     {", "turn    3  2  ;", "} else", "if    (  ( width    >     3  2  )     &  &     ( width    <  =     4  0  )  )     {", "turn    4  0  ;", "} else", "if    (  ( width    >     4  0  )     &  &     ( width    <  =     4  8  )  )     {", "turn    4  8  ;", "} else", "if    (  ( width    >     4  8  )     &  &     ( width    <  =     5  6  )  )     {", "turn    5  6  ;", "} else    {", "turn    6  4  ;", "}", "}", "METHOD_END"], "methodName": ["getClosestFixedBits"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "if    ( usesVInt )     {", "return   LongDecode . readVInt ( signed ,    input )  ;", "} else", "if    ( type    =  =     ( metadata . OrcType . OrcTypeKind . SHORT )  )     {", "return    ( input . read (  )  )     |     (  ( input . read (  )  )     <  <     8  )  ;", "} else", "if    ( type    =  =     ( metadata . OrcType . OrcTypeKind . INT )  )     {", "return    (  (  ( input . read (  )  )     |     (  ( input . read (  )  )     <  <     8  )  )     |     (  ( input . read (  )  )     <  <     1  6  )  )     |     (  ( input . read (  )  )     <  <     2  4  )  ;", "} else", "if    ( type    =  =     ( metadata . OrcType . OrcTypeKind . LONG )  )     {", "return    (  (  (  (  (  (  (  ( long )     ( input . read (  )  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     8  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     1  6  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     2  4  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     3  2  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     4  0  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     4  8  )  )     |     (  (  ( long )     ( input . read (  )  )  )     <  <     5  6  )  ;", "} else    {", "throw   new   IllegalArgumentException (  ( type    +     \"    type   is   not   supported \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readDwrfLong"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "long   result    =    LongDecode . readUnsignedVInt ( inputStream )  ;", "return   LongDecode . zigzagDecode ( result )  ;", "}", "METHOD_END"], "methodName": ["readSignedVInt"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "long   result    =     0  ;", "int   offset    =     0  ;", "long   b ;", "do    {", "b    =    inputSread (  )  ;", "if    ( b    =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( inputSgetOrcDataSourceId (  )  ,     \" EOF   while   reading   unsigned   vint \"  )  ;", "}", "result    |  =     ( b    &     1  2  7  )     <  <    offset ;", "offset    +  =     7  ;", "}    while    (  ( b    &     1  2  8  )     !  =     0     )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["readUnsignedVInt"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "if    ( signed )     {", "return    . readSignedVInt ( inputStream )  ;", "} else    {", "return    . readUnsignedVInt ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["readVInt"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "if    ( signed )     {", "value    =     . zigzagEncode ( value )  ;", "}", ". writeVLongUnsigned ( buffer ,    value )  ;", "}", "METHOD_END"], "methodName": ["writeVLong"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    (  ( value    &     (  ~  1  2  7  )  )     =  =     0  )     {", "output . write (  (  ( byte )     ( value )  )  )  ;", "return ;", "} else    {", "output . write (  (  ( byte )     (  1  2  8     |     ( value    &     1  2  7  )  )  )  )  ;", "value    >  >  >  =     7  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeVLongUnsigned"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "return    ( value    >  >  >     1  )     ^     (  -  ( value    &     1  )  )  ;", "}", "METHOD_END"], "methodName": ["zigzagDecode"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "return    ( value    <  <     1  )     ^     ( value    >  >     6  3  )  ;", "}", "METHOD_END"], "methodName": ["zigzagEncode"], "fileName": "com.facebook.presto.orc.stream.LongDecode"}, {"methodBody": ["METHOD_START", "{", "lastReadInputCheckpoint    =    input . getCheckpoint (  )  ;", "int   control    =    input . read (  )  ;", "if    ( control    =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Read   past   end   of   RLE   integer \"  )  ;", "}", "if    ( control    <     1  2  8  )     {", "numLiterals    =    control    +     (  . MIN _ REPEAT _ SIZE )  ;", "used    =     0  ;", "repeat    =    true ;", "delta    =    input . read (  )  ;", "if    (  ( delta )     =  =     (  -  1  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" End   of   stream   in   RLE   Integer \"  )  ;", "}", "delta    =     (  ( byte )     ( delta )  )  ;", "literals [  0  ]     =    LongDecode . readVInt ( signed ,    input )  ;", "} else    {", "numLiterals    =     2  5  6     -    control ;", "used    =     0  ;", "repeat    =    false ;", "for    ( int   i    =     0  ;    i    <     ( numLiterals )  ;     +  + i )     {", "literals [ i ]     =    LongDecode . readVInt ( signed ,    input )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV1"}, {"methodBody": ["METHOD_START", "{", "long   out    =     0  ;", "long   val ;", "while    ( n    >     0  )     {", "n -  -  ;", "val    =    i . read (  )  ;", "out    |  =    val    <  <     ( n    *     8  )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["bytesToLongBE"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   fixedBits    =     ( firstByte    >  >  >     1  )     &     3  1  ;", "if    ( fixedBits    !  =     0  )     {", "fixedBits    =    Decode . decodeBitWidth ( fixedBits )  ;", "}", "int   length    =     ( firstByte    &     1  )     <  <     8  ;", "length    |  =    input . read (  )  ;", "long   firstVal    =    Decode . readVInt ( signed ,    input )  ;", "literals [  (  ( numLiterals )  +  +  )  ]     =    firstVal ;", "long   prevVal ;", "if    ( fixedBits    =  =     0  )     {", "long   fixedDelta    =    Decode . readSignedVInt ( input )  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "literals [  (  ( numLiterals )  +  +  )  ]     =     ( literals [  (  ( numLiterals )     -     2  )  ]  )     +    fixedDelta ;", "}", "} else    {", "long   deltaBase    =    Decode . readSignedVInt ( input )  ;", "literals [  (  ( numLiterals )  +  +  )  ]     =    firstVal    +    deltaBase ;", "prevVal    =    literals [  (  ( numLiterals )     -     1  )  ]  ;", "length    -  =     1  ;", "packer . unpack ( literals ,    numLiterals ,    length ,    fixedBits ,    input )  ;", "while    ( length    >     0  )     {", "if    ( deltaBase    <     0  )     {", "literals [ numLiterals ]     =    prevVal    -     ( literals [ numLiterals ]  )  ;", "} else    {", "literals [ numLiterals ]     =    prevVal    +     ( literals [ numLiterals ]  )  ;", "}", "prevVal    =    literals [ numLiterals ]  ;", "length -  -  ;", "( numLiterals )  +  +  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readDeltaValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   fixedBits    =    LongDecode . decodeBitWidth (  (  ( firstByte    >  >  >     1  )     &     3  1  )  )  ;", "int   length    =     ( firstByte    &     1  )     <  <     8  ;", "length    |  =    input . read (  )  ;", "length    +  =     1  ;", "packer . unpack ( literals ,    numLiterals ,    length ,    fixedBits ,    input )  ;", "if    ( signed )     {", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "literals [ numLiterals ]     =    LongDecode . zigzagDecode ( literals [ numLiterals ]  )  ;", "( numLiterals )  +  +  ;", "}", "} else    {", "numLiterals    +  =    length ;", "}", "}", "METHOD_END"], "methodName": ["readDirectValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   fb    =    LongDecode . decodeBitWidth (  (  ( firstByte    >  >  >     1  )     &     3  1  )  )  ;", "int   length    =     ( firstByte    &     1  )     <  <     8  ;", "length    |  =    input . read (  )  ;", "length    +  =     1  ;", "int   thirdByte    =    input . read (  )  ;", "int   baseWidth    =     ( thirdByte    >  >  >     5  )     &     7  ;", "baseWidth    +  =     1  ;", "int   patchWidth    =    LongDecode . decodeBitWidth (  ( thirdByte    &     3  1  )  )  ;", "int   fourthByte    =    input . read (  )  ;", "int   patchGapWidth    =     ( fourthByte    >  >  >     5  )     &     7  ;", "patchGapWidth    +  =     1  ;", "int   patchListLength    =    fourthByte    &     3  1  ;", "long   base    =     . bytesToLongBE ( input ,    baseWidth )  ;", "long   mask    =     1 L    <  <     (  ( baseWidth    *     8  )     -     1  )  ;", "if    (  ( base    &    mask )     !  =     0  )     {", "base    =    base    &     (  ~ mask )  ;", "base    =     - base ;", "}", "long [  ]    unpacked    =    new   long [ length ]  ;", "packer . unpack ( unpacked ,     0  ,    length ,    fb ,    input )  ;", "long [  ]    unpackedPatch    =    new   long [ patchListLength ]  ;", "if    (  (  ( patchWidth    +    patchGapWidth )     >     6  4  )     &  &     (  !  ( skipCorrupt )  )  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Invalid   RLEv 2    encoded   stream \"  )  ;", "}", "int   bitSize    =    LongDecode . getClosestFixedBits (  ( patchWidth    +    patchGapWidth )  )  ;", "packer . unpack ( unpackedPatch ,     0  ,    patchListLength ,    bitSize ,    input )  ;", "int   patchIndex    =     0  ;", "long   currentGap ;", "long   currentPatch ;", "long   patchMask    =     (  1 L    <  <    patchWidth )     -     1  ;", "currentGap    =     ( unpackedPatch [ patchIndex ]  )     >  >  >    patchWidth ;", "currentPatch    =     ( unpackedPatch [ patchIndex ]  )     &    patchMask ;", "long   actualGap    =     0  ;", "while    (  ( currentGap    =  =     2  5  5  )     &  &     ( currentPatch    =  =     0  )  )     {", "actualGap    +  =     2  5  5  ;", "patchIndex +  +  ;", "currentGap    =     ( unpackedPatch [ patchIndex ]  )     >  >  >    patchWidth ;", "currentPatch    =     ( unpackedPatch [ patchIndex ]  )     &    patchMask ;", "}", "actualGap    +  =    currentGap ;", "for    ( int   i    =     0  ;    i    <     ( unpacked . length )  ;    i +  +  )     {", "if    ( i    =  =    actualGap )     {", "long   patchedValue    =     ( unpacked [ i ]  )     |     ( currentPatch    <  <    fb )  ;", "literals [  (  ( numLiterals )  +  +  )  ]     =    base    +    patchedValue ;", "patchIndex +  +  ;", "if    ( patchIndex    <    patchListLength )     {", "currentGap    =     ( unpackedPatch [ patchIndex ]  )     >  >  >    patchWidth ;", "currentPatch    =     ( unpackedPatch [ patchIndex ]  )     &    patchMask ;", "actualGap    =     0  ;", "while    (  ( currentGap    =  =     2  5  5  )     &  &     ( currentPatch    =  =     0  )  )     {", "actualGap    +  =     2  5  5  ;", "patchIndex +  +  ;", "currentGap    =     ( unpackedPatch [ patchIndex ]  )     >  >  >    patchWidth ;", "currentPatch    =     ( unpackedPatch [ patchIndex ]  )     &    patchMask ;", "}", "actualGap    +  =    currentGap ;", "actualGap    +  =    i ;", "}", "} else    {", "literals [  (  ( numLiterals )  +  +  )  ]     =    base    +     ( unpacked [ i ]  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readPatchedBaseValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   size    =     ( firstByte    >  >  >     3  )     &     7  ;", "size    +  =     1  ;", "int   length    =    firstByte    &     7  ;", "length    +  =     . MIN _ REPEAT _ SIZE ;", "long   val    =     . bytesToLongBE ( input ,    size )  ;", "if    ( signed )     {", "val    =    LongDecode . zigzagDecode ( val )  ;", "}", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "literals [  (  ( numLiterals )  +  +  )  ]     =    val ;", "}", "}", "METHOD_END"], "methodName": ["readShortRepeatValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "lastReadInputCheckpoint    =    input . getCheckpoint (  )  ;", "int   firstByte    =    input . read (  )  ;", "if    ( firstByte    <     0  )     {", "throw   new   OrcCorruptionException ( input . getOrcDataSourceId (  )  ,     \" Read   past   end   of   RLE   integer \"  )  ;", "}", "int   enc    =     ( firstByte    >  >  >     6  )     &     3  ;", "if    (  (  . EncodingType . SHORT _ REPEAT . ordinal (  )  )     =  =    enc )     {", "readShortRepeatValues ( firstByte )  ;", "} else", "if    (  (  . EncodingType . DIRECT . ordinal (  )  )     =  =    enc )     {", "readDirectValues ( firstByte )  ;", "} else", "if    (  (  . EncodingType . PATCHED _ BASE . ordinal (  )  )     =  =    enc )     {", "readPatchedBaseValues ( firstByte )  ;", "} else    {", "readDeltaValues ( firstByte )  ;", "}", "}", "METHOD_END"], "methodName": ["readValues"], "fileName": "com.facebook.presto.orc.stream.LongInputStreamV2"}, {"methodBody": ["METHOD_START", "{", "if    ( orcEncoding    =  =     ( OrcEncoding . DWRF )  )     {", "return   new   V 1  ( compression ,    bufferSize ,    false ,    Stream . StreamKind . LENGTH )  ;", "} else    {", "return   new   V 2  ( compression ,    bufferSize ,    false ,    Stream . StreamKind . LENGTH )  ;", "}", "}", "METHOD_END"], "methodName": ["createLengthOutputStream"], "fileName": "com.facebook.presto.orc.stream.LongOutputStream"}, {"methodBody": ["METHOD_START", "{", "verify (  ( literalCount    >     0  )  )  ;", "buffer . writeByte (  (  - literalCount )  )  ;", "for    ( int   i    =     0  ;    i    <    literalCount ;    i +  +  )     {", "Decode . writeV ( buffer ,    sequenceBuffer [ i ]  ,    signed )  ;", "}", "}", "METHOD_END"], "methodName": ["flushLiteralSequence"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV1"}, {"methodBody": ["METHOD_START", "{", "verify (  ( runCount    >     0  )  )  ;", "buffer . writeByte (  ( runCount    -     (  . MIN _ REPEAT _ SIZE )  )  )  ;", "buffer . writeByte (  (  ( byte )     ( lastDelta )  )  )  ;", "long   totalDeltaSize    =     ( lastDelta )     *     (  ( this . runCount )     -     1  )  ;", "long   sequenceStartValue    =     ( lastValue )     -    totalDeltaSize ;", "LongDecode . writeVLong ( buffer ,    sequenceStartValue ,    signed )  ;", "}", "METHOD_END"], "methodName": ["flushRleSequence"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV1"}, {"methodBody": ["METHOD_START", "{", "if    (  ( size )     =  =     0  )     {", "return ;", "}", "if    (  ( runCount )     >  =     (  . MIN _ REPEAT _ SIZE )  )     {", "flushRleSequence ( runCount )  ;", "} else    {", "flushLiteralSequence ( size )  ;", "}", "size    =     0  ;", "runCount    =     0  ;", "lastValue    =     0  ;", "lastDelta    =     . UNMATCHABLE _ DELTA _ VALUE ;", "}", "METHOD_END"], "methodName": ["flushSequence"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV1"}, {"methodBody": ["METHOD_START", "{", "return    ( delta    >  =     ( LongOutputStreamV 1  . MIN _ DELTA )  )     &  &     ( delta    <  =     ( LongOutputStreamV 1  . MAX _ DELTA )  )  ;", "}", "METHOD_END"], "methodName": ["isValidDelta"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV1"}, {"methodBody": ["METHOD_START", "{", "numLiterals    =     0  ;", "vDelta    =     0  ;", "fixedDelta    =     0  ;", "zzBits 9  0 p    =     0  ;", "zzBits 1  0  0 p    =     0  ;", "brBits 9  5 p    =     0  ;", "brBits 1  0  0 p    =     0  ;", "bitsDeltaMax    =     0  ;", "patchGapWidth    =     0  ;", "patchLength    =     0  ;", "patchWidth    =     0  ;", "gapVsPatchList    =    null ;", "min    =     0  ;", "isFixedDelta    =    true ;", "}", "METHOD_END"], "methodName": ["clearEncoder"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "if    ( signed )     {", "for    ( int   i 1     =     0  ;    i 1     <     ( numLiterals )  ;    i 1  +  +  )     {", "zigzagLiterals [ i 1  ]     =     . SerializationUtils . zigzagEncode ( literals [ i 1  ]  )  ;", "}", "} else    {", "System . arraycopy ( literals ,     0  ,    zigzagLiterals ,     0  ,    numLiterals )  ;", "}", "zzBits 1  0  0 p    =     . SerializationUtils . percentileBits ( zigzagLiterals ,     0  ,    numLiterals ,     1  .  0  )  ;", "if    (  ( numLiterals )     <  =     (  . MIN _ REPEAT )  )     {", "return    . EncodingType . DIRECT ;", "}", "boolean   isIncreasing    =    true ;", "boolean   isDecreasing    =    true ;", "this . isFixedDelta    =    true ;", "this . min    =    literals [  0  ]  ;", "long   max    =    literals [  0  ]  ;", "final   long   initialDelta    =     ( literals [  1  ]  )     -     ( literals [  0  ]  )  ;", "long   currDelta    =    initialDelta ;", "long   deltaMax    =    initialDelta ;", "this . adjDeltas [  0  ]     =    initialDelta ;", "for    ( int   i    =     1  ;    i    <     ( numLiterals )  ;    i +  +  )     {", "final   long   l 1     =    literals [ i ]  ;", "final   long   l 0     =    literals [  ( i    -     1  )  ]  ;", "currDelta    =    l 1     -    l 0  ;", "min    =    Math . min ( min ,    l 1  )  ;", "max    =    Math . max ( max ,    l 1  )  ;", "isIncreasing    &  =    l 0     <  =    l 1  ;", "isDecreasing    &  =    l 0     >  =    l 1  ;", "isFixedDelta    &  =    currDelta    =  =    initialDelta ;", "if    ( i    >     1  )     {", "adjDeltas [  ( i    -     1  )  ]     =    Math . abs ( currDelta )  ;", "deltaMax    =    Math . max ( deltaMax ,    adjDeltas [  ( i    -     1  )  ]  )  ;", "}", "}", "if    (  !  (  . SerializationUtils . isSafeSubtract ( max ,    min )  )  )     {", "return    . EncodingType . DIRECT ;", "}", "if    ( initialDelta    !  =     0  )     {", "if    (  ( min )     =  =    max )     {", "throw   new   IllegalStateException (  \" currDelta   should   be   zero \"  )  ;", "}", "if    ( isFixedDelta )     {", "fixedDelta    =    currDelta ;", "return    . EncodingType . DELTA ;", "}", "bitsDeltaMax    =     . SerializationUtils . findClosestNumBits ( deltaMax )  ;", "if    ( isIncreasing    |  |    isDecreasing )     {", "return    . EncodingType . DELTA ;", "}", "}", "zzBits 9  0 p    =     . SerializationUtils . percentileBits ( zigzagLiterals ,     0  ,    numLiterals ,     0  .  9  )  ;", "if    (  (  ( zzBits 1  0  0 p )     -     ( zzBits 9  0 p )  )     <  =     1  )     {", "return    . EncodingType . DIRECT ;", "}", "for    ( int   i    =     0  ;    i    <     ( numLiterals )  ;    i +  +  )     {", "baseReducedLiterals [ i ]     =     ( literals [ i ]  )     -     ( min )  ;", "}", "brBits 9  5 p    =     . SerializationUtils . percentileBits ( baseReducedLiterals ,     0  ,    numLiterals ,     0  .  9  5  )  ;", "brBits 1  0  0 p    =     . SerializationUtils . percentileBits ( baseReducedLiterals ,     0  ,    numLiterals ,     1  .  0  )  ;", "if    (  ( brBits 1  0  0 p )     =  =     ( brBits 9  5 p )  )     {", "return    . EncodingType . DIRECT ;", "}", "return    . EncodingType . PATCHED _ BASE ;", "}", "METHOD_END"], "methodName": ["determineEncoding"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "if    (  ( numLiterals )     =  =     0  )     {", "return ;", "}", "if    (  ( variableRunLength )     !  =     0  )     {", "writeValues ( determineEncoding (  )  )  ;", "return ;", "}", "if    (  ( fixedRunLength )     =  =     0  )     {", "throw   new   IllegalStateException (  \" literals   does   not   agree   with   run   length   counters \"  )  ;", "}", "if    (  ( fixedRunLength )     <     (  . MIN _ REPEAT )  )     {", "variableRunLength    =    fixedRunLength ;", "fixedRunLength    =     0  ;", "writeValues ( determineEncoding (  )  )  ;", "return ;", "}", "if    (  (  ( fixedRunLength )     >  =     (  . MIN _ REPEAT )  )     &  &     (  ( fixedRunLength )     <  =     (  . MAX _ SHORT _ REPEAT _ LENGTH )  )  )     {", "writeValues (  . EncodingType . SHORT _ REPEAT )  ;", "return ;", "}", "isFixedDelta    =    true ;", "writeValues (  . EncodingType . DELTA )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "literals [  (  ( numLiterals )  +  +  )  ]     =    val ;", "fixedRunLeth    =     1  ;", "variableRunLeth    =     1  ;", "}", "METHOD_END"], "methodName": ["initializeLiterals"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "long   mask    =     (  1 L    <  <     ( brBits 9  5 p )  )     -     1  ;", "patchLength    =     (  ( int )     ( Math . ceil (  (  ( numLiterals )     *     0  .  0  5  )  )  )  )  ;", "int [  ]    gapList    =    new   int [ patchLength ]  ;", "long [  ]    patchList    =    new   long [ patchLength ]  ;", "patchWidth    =     ( brBits 1  0  0 p )     -     ( brBits 9  5 p )  ;", "patchWidth    =     . SerializationUtils . getClosestFixedBits ( patchWidth )  ;", "if    (  ( patchWidth )     =  =     6  4  )     {", "patchWidth    =     5  6  ;", "brBits 9  5 p    =     8  ;", "mask    =     (  1 L    <  <     ( brBits 9  5 p )  )     -     1  ;", "}", "int   gapIdx    =     0  ;", "int   patchIdx    =     0  ;", "int   prev    =     0  ;", "int   gap ;", "int   maxGap    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( numLiterals )  ;    i +  +  )     {", "if    (  ( baseReducedLiterals [ i ]  )     >    mask )     {", "gap    =    i    -    prev ;", "if    ( gap    >    maxGap )     {", "maxGap    =    gap ;", "}", "prev    =    i ;", "gapList [  ( gapIdx +  +  )  ]     =    gap ;", "long   patch    =     ( baseReducedLiterals [ i ]  )     >  >  >     ( brBits 9  5 p )  ;", "patchList [  ( patchIdx +  +  )  ]     =    patch ;", "baseReducedLiterals [ i ]     &  =    mask ;", "}", "}", "patchLength    =    gapIdx ;", "if    (  ( maxGap    =  =     0  )     &  &     (  ( patchLength )     !  =     0  )  )     {", "patchGapWidth    =     1  ;", "} else    {", "patchGapWidth    =     . SerializationUtils . findClosestNumBits ( maxGap )  ;", "}", "if    (  ( patchGapWidth )     >     8  )     {", "patchGapWidth    =     8  ;", "if    ( maxGap    =  =     5  1  1  )     {", "patchLength    +  =     2  ;", "} else    {", "patchLength    +  =     1  ;", "}", "}", "gapIdx    =     0  ;", "patchIdx    =     0  ;", "gapVsPatchList    =    new   long [ patchLength ]  ;", "for    ( int   i    =     0  ;    i    <     ( patchLength )  ;    i +  +  )     {", "long   g    =    gapList [  ( gapIdx +  +  )  ]  ;", "long   p    =    patchList [  ( patchIdx +  +  )  ]  ;", "while    ( g    >     2  5  5  )     {", "gapVsPatchList [  ( i +  +  )  ]     =     2  5  5 L    <  <     ( patchWidth )  ;", "g    -  =     2  5  5  ;", "}", "gapVsPatchList [ i ]     =     ( g    <  <     ( patchWidth )  )     |    p ;", "}", "}", "METHOD_END"], "methodName": ["preparePatchedBlob"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   fixedBits    =    LongOutputStreamV 2  . SerializationUtils . getClosestAlignedFixedBits ( bitsDeltaMax )  ;", "int   length ;", "int   encodeBitWidth    =     0  ;", "if    ( isFixedDelta )     {", "if    (  ( fixedRunLength )     >     ( LongOutputStreamV 2  . MIN _ REPEAT )  )     {", "length    =     ( fixedRunLength )     -     1  ;", "fixedRunLength    =     0  ;", "} else    {", "length    =     ( variableRunLength )     -     1  ;", "variableRunLength    =     0  ;", "}", "} else    {", "if    ( fixedBits    =  =     1  )     {", "fixedBits    =     2  ;", "}", "encodeBitWidth    =     ( LongOutputStreamV 2  . SerializationUtils . encodeBitWidth ( fixedBits )  )     <  <     1  ;", "length    =     ( variableRunLength )     -     1  ;", "variableRunLength    =     0  ;", "}", "final   int   tailBits    =     ( length    &     2  5  6  )     >  >  >     8  ;", "final   int   headerFirstByte    =     (  ( LongOutputStreamV 2  . EncodingType . DELTA . getOpCode (  )  )     |    encodeBitWidth )     |    tailBits ;", "final   int   headerSecondByte    =    length    &     2  5  5  ;", "buffer . write ( headerFirstByte )  ;", "buffer . write ( headerSecondByte )  ;", "if    ( signed )     {", "LongOutputStreamV 2  . SerializationUtils . writeVslong ( buffer ,    literals [  0  ]  )  ;", "} else    {", "LongOutputStreamV 2  . SerializationUtils . writeVulong ( buffer ,    literals [  0  ]  )  ;", "}", "if    ( isFixedDelta )     {", "LongOutputStreamV 2  . SerializationUtils . writeVslong ( buffer ,    fixedDelta )  ;", "} else    {", "LongOutputStreamV 2  . SerializationUtils . writeVslong ( buffer ,    adjDeltas [  0  ]  )  ;", "utils . writeInts ( adjDeltas ,     1  ,     (  ( numLiterals )     -     2  )  ,    fixedBits ,    buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDeltaValues"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "int   fixedBits    =    LongOutputStreamV 2  . SerializationUtils . getClosestAlignedFixedBits ( zzBits 1  0  0 p )  ;", "final   int   encodeBitWidth    =     ( LongOutputStreamV 2  . SerializationUtils . encodeBitWidth ( fixedBits )  )     <  <     1  ;", "variableRunLength    -  =     1  ;", "final   int   tailBits    =     (  ( variableRunLength )     &     2  5  6  )     >  >  >     8  ;", "final   int   headerFirstByte    =     (  ( LongOutputStreamV 2  . EncodingType . DIRECT . getOpCode (  )  )     |    encodeBitWidth )     |    tailBits ;", "final   int   headerSecondByte    =     ( variableRunLength )     &     2  5  5  ;", "buffer . write ( headerFirstByte )  ;", "buffer . write ( headerSecondByte )  ;", "utils . writeInts ( zigzagLiterals ,     0  ,    numLiterals ,    fixedBits ,    buffer )  ;", "variableRunLength    =     0  ;", "}", "METHOD_END"], "methodName": ["writeDirectValues"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "preparePatchedBlob (  )  ;", "final   int   fb    =    brBits 9  5 p ;", "final   int   efb    =     (  . SerializationUtils . encodeBitWidth ( fb )  )     <  <     1  ;", "variableRunLength    -  =     1  ;", "final   int   tailBits    =     (  ( variableRunLength )     &     2  5  6  )     >  >  >     8  ;", "final   int   headerFirstByte    =     (  (  . EncodingType . PATCHED _ BASE . getOpCode (  )  )     |    efb )     |    tailBits ;", "final   int   headerSecondByte    =     ( variableRunLength )     &     2  5  5  ;", "final   boolean   isNegative    =     ( min )     <     0  ;", "if    ( isNegative )     {", "min    =     -  ( min )  ;", "}", "final   int   baseWidth    =     (  . SerializationUtils . findClosestNumBits ( min )  )     +     1  ;", "final   int   baseBytes    =     (  ( baseWidth    %     8  )     =  =     0  )     ?    baseWidth    /     8     :     ( baseWidth    /     8  )     +     1  ;", "final   int   bb    =     ( baseBytes    -     1  )     <  <     5  ;", "if    ( isNegative )     {", "min    |  =     1 L    <  <     (  ( baseBytes    *     8  )     -     1  )  ;", "}", "final   int   headerThirdByte    =    bb    |     (  . SerializationUtils . encodeBitWidth ( patchWidth )  )  ;", "final   int   headerFourthByte    =     (  (  ( patchGapWidth )     -     1  )     <  <     5  )     |     ( patchLength )  ;", "buffer . write ( headerFirstByte )  ;", "buffer . write ( headerSecondByte )  ;", "buffer . write ( headerThirdByte )  ;", "buffer . write ( headerFourthByte )  ;", "for    ( int   i    =    baseBytes    -     1  ;    i    >  =     0  ;    i -  -  )     {", "byte   b    =     (  ( byte )     (  (  ( min )     >  >  >     ( i    *     8  )  )     &     2  5  5  )  )  ;", "buffer . write ( b )  ;", "}", "int   closestFixedBits    =     . SerializationUtils . getClosestFixedBits ( fb )  ;", "utils . writeInts ( baseReducedLiterals ,     0  ,    numLiterals ,    closestFixedBits ,    buffer )  ;", "closestFixedBits    =     . SerializationUtils . getClosestFixedBits (  (  ( patchGapWidth )     +     ( patchWidth )  )  )  ;", "utils . writeInts ( gapVsPatchList ,     0  ,    gapVsPatchList . length ,    closestFixedBits ,    buffer )  ;", "variableRunLength    =     0  ;", "}", "METHOD_END"], "methodName": ["writePatchedBaseValues"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "long   repeatVal ;", "if    ( signed )     {", "repeatVal    =     . SerializationUtils . zigzagEncode ( literals [  0  ]  )  ;", "} else    {", "repeatVal    =    literals [  0  ]  ;", "}", "int   numBitsRepeatVal    =     . SerializationUtils . findClosestNumBits ( repeatVal )  ;", "int   numBytesRepeatVal ;", "if    (  ( numBitsRepeatVal    %     8  )     =  =     0  )     {", "numBytesRepeatVal    =    numBitsRepeatVal    >  >  >     3  ;", "} else    {", "numBytesRepeatVal    =     ( numBitsRepeatVal    >  >  >     3  )     +     1  ;", "}", "int   header    =     . EncodingType . SHORT _ REPEAT . getOpCode (  )  ;", "header    |  =     ( numBytesRepeatVal    -     1  )     <  <     3  ;", "fixedRunLength    -  =     . MIN _ REPEAT ;", "header    |  =    fixedRunLength ;", "buffer . write ( header )  ;", "for    ( int   i    =    numBytesRepeatVal    -     1  ;    i    >  =     0  ;    i -  -  )     {", "int   b    =     (  ( int )     (  ( repeatVal    >  >  >     ( i    *     8  )  )     &     2  5  5  )  )  ;", "buffer . write ( b )  ;", "}", "fixedRunLength    =     0  ;", "}", "METHOD_END"], "methodName": ["writeShortRepeatValues"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "if    (  ( numLiterals )     =  =     0  )     {", "return ;", "}", "switch    ( encoding )     {", "case   SHORT _ REPEAT    :", "writeShortRepeatValues (  )  ;", "bk ;", "case   DIRECT    :", "writeDirectValues (  )  ;", "bk ;", "case   PATCHED _ BASE    :", "writePatchedBaseValues (  )  ;", "bk ;", "default    :", "writeDeltaValues (  )  ;", "bk ;", "}", "clearEncoder (  )  ;", "}", "METHOD_END"], "methodName": ["writeValues"], "fileName": "com.facebook.presto.orc.stream.LongOutputStreamV2"}, {"methodBody": ["METHOD_START", "{", "return   new   MissingInputStreamSource <  >  ( streamType )  ;", "}", "METHOD_END"], "methodName": ["missingStreamSource"], "fileName": "com.facebook.presto.orc.stream.MissingInputStreamSource"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( compressedSliceInput )     =  =    null )     |  |     (  ( compressedSliceInput . remaining (  )  )     =  =     0  )  )     {", "current    =    null ;", "return ;", "}", "currentCompressedBlockOffset    =    Math . toIntExact ( compressedSliceInput . position (  )  )  ;", "int   b 0     =    compressedSliceInput . readUnsignedByte (  )  ;", "int   b 1     =    compressedSliceInput . readUnsignedByte (  )  ;", "int   b 2     =    compressedSliceInput . readUnsignedByte (  )  ;", "boolean   isUncompressed    =     ( b 0     &     1  )     =  =     1  ;", "int   chunkLength    =     (  ( b 2     <  <     1  5  )     |     ( b 1     <  <     7  )  )     |     ( b 0     >  >  >     1  )  ;", "if    (  ( chunkLength    <     0  )     |  |     ( chunkLength    >     ( compressedSliceInput . remaining (  )  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" The   chunkLength    (  % s )    must   not   be   negative   or   greater   than   remaining   size    (  % s )  \"  ,    chunkLength ,    compressedSliceInput . remaining (  )  )  ;", "}", "Slice   chunk    =    compressedSliceInput . readSlice ( chunkLength )  ;", "if    ( isUncompressed )     {", "current    =    chunk . getInput (  )  ;", "} else    {", "OrcDecompressor . OutputBuffer   output    =    new   OrcDecompressor . OutputBuffer (  )     {", "@ Override", "public   byte [  ]    initialize ( int   size )     {", "if    (  (  ( buffer )     =  =    null )     |  |     ( size    >     ( buffer . length )  )  )     {", "buffer    =    new   byte [ size ]  ;", "bufferMemoryUsage . setBytes ( buffer . length )  ;", "}", "return   buffer ;", "}", "@ Override", "public   byte [  ]    grow ( int   size )     {", "if    ( size    >     ( buffer . length )  )     {", "buffer    =    Arrays . copyOfRange ( buffer ,     0  ,    size )  ;", "bufferMemoryUsage . setBytes ( buffer . length )  ;", "}", "return   buffer ;", "}", "}  ;", "int   uncompressedSize    =    decompressor . get (  )  . decompress (  (  ( byte [  ]  )     ( chunk . getBase (  )  )  )  ,     (  ( int )     (  ( chunk . getAddress (  )  )     -     ( Unsafe . ARRAY _ BYTE _ BASE _ OFFSET )  )  )  ,    chunk . length (  )  ,    output )  ;", "current    =    Slices . wrappedBuffer ( buffer ,     0  ,    uncompressedSize )  . getInput (  )  ;", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( current )     =  =    null )     |  |     (  (  ( current . position (  )  )     =  =     0  )     &  &     (  ( current . remaining (  )  )     =  =     0  )  )  )     {", "return   Checkpoint . createCheckpoint ( Math . toIntExact ( compressedSliceInput . position (  )  )  ,     0  )  ;", "}", "return   Checkpoint . createCheckpoint ( currentCompressedBlockOffset ,    Math . toIntExact ( current . position (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCheckpoint"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "return   orcDataSourceId ;", "}", "METHOD_END"], "methodName": ["getOrcDataSourceId"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "while    ( offset    <    length )     {", "int   result    =    read ( buffer ,    offset ,     ( length    -    offset )  )  ;", "if    ( result    <     0  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   end   of    \"  )  ;", "}", "offset    +  =    result ;", "}", "}", "METHOD_END"], "methodName": ["readFully"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "int   compressedBlockOffset    =    InputStreamCheckpoint . decodeCompressedBlockOffset ( checkpoint )  ;", "int   decompressedOffset    =    InputStreamCheckpoint . decodeDecompressedOffset ( checkpoint )  ;", "boolean   discardedBuffer ;", "if    ( compressedBlockOffset    !  =     ( currentCompressedBlockOffset )  )     {", "if    (  !  ( decompressor . isPresent (  )  )  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Reset   stream   has   a   compressed   block   offset   but   stream   is   not   compressed \"  )  ;", "}", "compressedSliceInput . setPosition ( compressedBlockOffset )  ;", "current    =    EMPTY _ SLICE . getInput (  )  ;", "discardedBuffer    =    true ;", "} else    {", "discardedBuffer    =    false ;", "}", "if    ( decompressedOffset    !  =     ( current . position (  )  )  )     {", "current . setPosition (  0  )  ;", "if    (  ( current . remaining (  )  )     <    decompressedOffset )     {", "decompressedOffset    -  =    current . remaining (  )  ;", "advance (  )  ;", "}", "current . setPosition ( decompressedOffset )  ;", "}", "return   discardedBuffer ;", "}", "METHOD_END"], "methodName": ["seekToCheckpoint"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "while    ( length    >     0  )     {", "long   result    =    skip ( length )  ;", "if    ( result    <     0  )     {", "throw   new   OrcCorruptionException ( orcDataSourceId ,     \" Unexpected   end   of    \"  )  ;", "}", "length    -  =    result ;", "}", "}", "METHOD_END"], "methodName": ["skipFully"], "fileName": "com.facebook.presto.orc.stream.OrcInputStream"}, {"methodBody": ["METHOD_START", "{", "return   sizeInBytes ;", "}", "METHOD_END"], "methodName": ["getSizeInBytes"], "fileName": "com.facebook.presto.orc.stream.OutputDataStream"}, {"methodBody": ["METHOD_START", "{", "return   writer . apply ( sliceOutput )  ;", "}", "METHOD_END"], "methodName": ["writeData"], "fileName": "com.facebook.presto.orc.stream.OutputDataStream"}, {"methodBody": ["METHOD_START", "{", "closed    =    true ;", "if    (  ( boolean )     !  =    null )     {", "boolean . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkState (  (  ( booleanOutputStream )     =  =    null )  )  ;", "booleanOutputStream    =    new   BooleanOutputStream ( buffer )  ;", "for    ( int   groupsCount    :    groupsCounts )     {", "booleanOutputStream . writeBooleans ( groupsCount ,    true )  ;", "booleanOutputStream . recordCheckpoint (  )  ;", "}", "booleanOutputStream . writeBooleans ( currentGroupCount ,    true )  ;", "}", "METHOD_END"], "methodName": ["createBooleanOutputStream"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( booleanOutputStream )     =  =    null )     {", "return    0  ;", "}", "return   booleanOutputStream . getBufferedBytes (  )  ;", "}", "METHOD_END"], "methodName": ["getBufferedBytes"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkArgument ( closed )  ;", "if    (  ( boolean )     =  =    null )     {", "return   Optional . empty (  )  ;", "}", "return   Optional . of ( boolean . getCheckpoints (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCheckpoints"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "if    (  ( booleanOutputStream )     =  =    null )     {", "return    (  . INSTANCE _ SIZE )     +     ( buffer . getRetainedSize (  )  )  ;", "}", "return    (  . INSTANCE _ SIZE )     +     ( booleanOutputStream . getRetainedBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRetainedBytes"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( closed )  )  )  ;", "groupsCounts . add ( currentGroupCount )  ;", "currentGroupCount    =     0  ;", "if    (  ( boolean )     !  =    null )     {", "boolean . recordCheckpoint (  )  ;", "}", "}", "METHOD_END"], "methodName": ["recordCheckpoint"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "closed    =    false ;", "boolean    =    null ;", "buffer . reset (  )  ;", "groupsCounts . clear (  )  ;", "currentGroupCount    =     0  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( closed )  )  )  ;", "if    (  (  ! value )     &  &     (  ( boolean )     =  =    null )  )     {", "createBoolean (  )  ;", "}", "if    (  ( boolean )     !  =    null )     {", "boolean . writeBoolean ( value )  ;", "}", "( currentGroupCount )  +  +  ;", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "checkArgument ( closed )  ;", "if    (  ( boolean )     =  =    null )     {", "return   Optional . empty (  )  ;", "}", "Stream   stream    =    boolean . writeDataStreams ( column ,    outputStream )  . get (  )  ;", "return   Optional . of ( new   Stream ( stream . getColumn (  )  ,    Stream . StreamKind . PRESENT ,    stream . getLength (  )  ,    stream . isUseVInts (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeDataStreams"], "fileName": "com.facebook.presto.orc.stream.PresentOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   entryCount ;", "}", "METHOD_END"], "methodName": ["getEntryCount"], "fileName": "com.facebook.presto.orc.stream.RowGroupDictionaryLengthInputStream"}, {"methodBody": ["METHOD_START", "{", "assertNotNull ( left )  ;", "assertNotNull ( right )  ;", "if    (  ( left . getOffset (  )  )     !  =     ( right . getOffset (  )  )  )     {", "return   false ;", "}", "ByteStreamCheckpoint   leftCheckpoint    =    left . getByteStreamCheckpoint (  )  ;", "ByteStreamCheckpoint   rightCheckpoint    =    right . getByteStreamCheckpoint (  )  ;", "assertNotNull ( leftCheckpoint )  ;", "assertNotNull ( rightCheckpoint )  ;", "return    (  ( leftCheckpoint . getInCheckpoint (  )  )     =  =     ( rightCheckpoint . getInCheckpoint (  )  )  )     &  &     (  ( leftCheckpoint . getOffset (  )  )     =  =     ( rightCheckpoint . getOffset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkpointsEqual"], "fileName": "com.facebook.presto.orc.stream.TestBooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Integer >  >    testGroups    =    ImmutableList . of ( ImmutableList . of (  1  4  9  ,     3  1  7  ,     2  )  ,    ImmutableList . of (  2  )  ,    ImmutableList . of (  1  ,     2  ,     4  ,     0  ,     8  )  ,    ImmutableList . of (  1  ,     4  ,     8  ,     1  0  2  4  ,     1  0  0  0  0  )  ,    ImmutableList . of (  1  4  0  0  0  ,     1  ,     2  )  )  ;", "for    ( List < Integer >    counts    :    testGroups )     {", "OrcOutputBuffer   buffer    =    new   OrcOutputBuffer ( CompressionKind . NONE ,     1  0  2  4  )  ;", "BooleanOutputStream   output    =    new   BooleanOutputStream ( buffer )  ;", "for    ( int   count    :    counts )     {", "output . writeBooleans ( count ,    true )  ;", "output . recordCheckpoint (  )  ;", "}", "output . close (  )  ;", "List < BooleanStreamCheckpoint >    batchWriteCheckpoints    =    output . getCheckpoints (  )  ;", "DynamicSliceOutput   slice    =    new   DynamicSliceOutput (  1  2  8  )  ;", "buffer . writeDataTo ( slice )  ;", "Slice   batchWriteBuffer    =    slice . slice (  )  ;", "buffer . reset (  )  ;", "output . reset (  )  ;", "for    ( int   count    :    counts )     {", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "output . writeBoolean ( true )  ;", "}", "output . recordCheckpoint (  )  ;", "}", "output . close (  )  ;", "List < BooleanStreamCheckpoint >    singleWriteCheckpoints    =    output . getCheckpoints (  )  ;", "slice    =    new   DynamicSliceOutput (  1  2  8  )  ;", "buffer . writeDataTo ( slice )  ;", "Slice   singleWriteBuffer    =    slice . slice (  )  ;", "assertEquals ( batchWriteCheckpoints . size (  )  ,    singleWriteCheckpoints . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( batchWriteCheckpoints . size (  )  )  ;    i +  +  )     {", "assertTrue (  . checkpointsEqual ( batchWriteCheckpoints . get ( i )  ,    singleWriteCheckpoints . get ( i )  )  )  ;", "}", "assertEquals ( batchWriteBuffer ,    singleWriteBuffer )  ;", "}", "}", "METHOD_END"], "methodName": ["testWriteBoolean"], "fileName": "com.facebook.presto.orc.stream.TestBooleanOutputStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Boolean >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Boolean >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( i    %     3  )     =  =     0  )  )  ;", "}", "groups . add ( group )  ;", "}", "List < Boolean >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  7  ;    i +  +  )     {", "group . add (  (  ( i    %     3  )     =  =     0  )  )  ;", "}", "groups . add ( group )  ;", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestBooleanStream"}, {"methodBody": ["METHOD_START", "{", "BooleanOutputStream   outputStream    =    createValueOutputStream (  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "outputStream . reset (  )  ;", "BooleanList   expectedValues    =    new   BooleanArrayList (  1  0  2  4  )  ;", "outputStream . writeBooleans (  3  2  ,    true )  ;", "expectedValues . addAll ( Collections . nCopies (  3  2  ,    true )  )  ;", "outputStream . writeBooleans (  3  2  ,    false )  ;", "expectedValues . addAll ( Collections . nCopies (  3  2  ,    false )  )  ;", "outputStream . writeBooleans (  1  ,    true )  ;", "expectedValues . add ( true )  ;", "outputStream . writeBooleans (  1  ,    false )  ;", "expectedValues . add ( false )  ;", "outputStream . writeBooleans (  3  4  ,    true )  ;", "expectedValues . addAll ( Collections . nCopies (  3  4  ,    true )  )  ;", "outputStream . writeBooleans (  3  4  ,    false )  ;", "expectedValues . addAll ( Collections . nCopies (  3  4  ,    false )  )  ;", "outputStream . writeBoolean ( true )  ;", "expectedValues . add ( true )  ;", "outputStream . writeBoolean ( false )  ;", "expectedValues . add ( false )  ;", "outputStream . close (  )  ;", "DynamicSliceOutput   sliceOutput    =    new   DynamicSliceOutput (  1  0  0  0  )  ;", "Optional < Stream >    stream    =    outputStream . writeDataStreams (  3  3  ,    sliceOutput )  ;", "assertTrue ( stream . isPresent (  )  )  ;", "assertEquals ( stream . get (  )  . getStreamKind (  )  ,    Stream . StreamKind . DATA )  ;", "assertEquals ( stream . get (  )  . getColumn (  )  ,     3  3  )  ;", "assertEquals ( stream . get (  )  . getLength (  )  ,    sliceOutput . size (  )  )  ;", "BooleanInputStream   valueStream    =    createValueStream ( sliceOutput . slice (  )  )  ;", "for    ( int   index    =     0  ;    index    <     ( expectedValues . size (  )  )  ;    index +  +  )     {", "boolean   expectedValue    =    expectedValues . ge ( index )  ;", "boolean   actualValue    =    readValue ( valueStream )  ;", "assertEquals ( actualValue ,    expectedValue )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testWriteMultiple"], "fileName": "com.facebook.presto.orc.stream.TestBooleanStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Slice >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Slice >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "Slice   value    =    Slices . allocate (  8  )  ;", "SliceOutput   output    =    value . getOutput (  )  ;", "output . writeInt ( groupIndex )  ;", "output . writeInt ( i )  ;", "group . add ( value )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestByteArrayStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Byte >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Byte >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( byte )     (  ( groupIndex    *     1  0  0  0  0  )     +    i )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["testLiteral"], "fileName": "com.facebook.presto.orc.stream.TestByteStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Byte >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Byte >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( byte )     (  7  7  )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["testRleLong"], "fileName": "com.facebook.presto.orc.stream.TestByteStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Byte >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Byte >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( byte )     (  (  ( groupIndex    *     1  0  0  0  0  )     +    i )     /     1  3  )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["testRleShort"], "fileName": "com.facebook.presto.orc.stream.TestByteStream"}, {"methodBody": ["METHOD_START", "{", "Slice   decimal    =    unscaledDecimal (  )  ;", "assertThrows ( OrcCorruptionException . class ,     (  )     -  >     {", "DecimalInputStream   stream    =    new   DecimalInputStream ( decimalInputStream ( value )  )  ;", "stream . nextLongDecimal ( decimal )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["assertLongValueReadFails"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "DecimalInputStream   stream    =    new   DecimalInputStream ( TestDecimalStream . decimalInputStream ( value )  )  ;", "Slice   decimal    =    unscaledDecimal (  )  ;", "stream . nextLongDecimal ( decimal )  ;", "assertEquals ( unscaledDecimalToBigInteger ( decimal )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["assertReadsLongValue"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "DecimalInputStream   stream    =    new   DecimalInputStream ( TestDecimalStream . decimalInputStream ( BigInteger . valueOf ( value )  )  )  ;", "assertEquals ( stream . nextLong (  )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["assertReadsShortValue"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "assertThrows ( OrcCorruptionException . class ,     (  )     -  >     {", "InputStream   stream    =    new   InputStream ( decimalInputStream ( value )  )  ;", "stream . nextLong (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["assertShortValueReadFails"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", ". writeBigInteger ( baos ,    value )  ;", "return    . orcInputStreamFor ( value . toString (  )  ,    baos . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["decimalInputStream"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "return   new   OrcInputStream ( new   OrcDataSourceId ( source )  ,    new   io . airlift . slice . BasicSliceInput ( Slices . wrappedBuffer ( bytes )  )  ,    Optional . empty (  )  ,    newSimpleAggregatedMemoryContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["orcInputStreamFor"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "TestDecimalStream . assertReadsLongValue ( BigInteger . valueOf (  0 L )  )  ;", "TestDecimalStream . assertReadsLongValue ( BigInteger . valueOf (  1 L )  )  ;", "TestDecimalStream . assertReadsLongValue ( BigInteger . valueOf (  (  -  1 L )  )  )  ;", "TestDecimalStream . assertReadsLongValue ( BigInteger . valueOf (  (  -  1  )  )  . shiftLeft (  1  2  6  )  )  ;", "TestDecimalStream . assertReadsLongValue ( BigInteger . valueOf (  1  )  . shiftLeft (  1  2  6  )  )  ;", "TestDecimalStream . assertReadsLongValue ( TestDecimalStream . BIG _ INTEGER _  1  2  7  _ BIT _ SET )  ;", "TestDecimalStream . assertReadsLongValue ( TestDecimalStream . BIG _ INTEGER _  1  2  7  _ BIT _ SET . negate (  )  )  ;", "TestDecimalStream . assertReadsLongValue ( MAX _ DECIMAL _ UNSCALED _ VALUE )  ;", "TestDecimalStream . assertReadsLongValue ( MIN _ DECIMAL _ UNSCALED _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testLongDecimals"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "TestDecimalStream . assertReadsShortValue (  0 L )  ;", "TestDecimalStream . assertReadsShortValue (  1 L )  ;", "TestDecimalStream . assertReadsShortValue (  (  -  1 L )  )  ;", "TestDecimalStream . assertReadsShortValue (  2  5  6 L )  ;", "TestDecimalStream . assertReadsShortValue (  (  -  2  5  6 L )  )  ;", "TestDecimalStream . assertReadsShortValue ( Long . MAX _ VALUE )  ;", "TestDecimalStream . assertReadsShortValue ( Long . MIN _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testShortDecimals"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "TestDecimalStream . assertLongValueReadFails ( BigInteger . valueOf (  1  )  . shiftLeft (  1  2  7  )  )  ;", "TestDecimalStream . assertLongValueReadFails ( BigInteger . valueOf (  (  -  2  )  )  . shiftLeft (  1  2  7  )  )  ;", "}", "METHOD_END"], "methodName": ["testShouldFailWhenExceeds128Bits"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "TestDecimalStream . assertShortValueReadFails ( BigInteger . valueOf ( Long . MAX _ VALUE )  . add ( BigInteger . ONE )  )  ;", "}", "METHOD_END"], "methodName": ["testShouldFailWhenShortDecimalDoesNotFit"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", ". writeBigInteger ( baos ,    BigInteger . valueOf ( Long . MAX _ VALUE )  )  ;", ". writeBigInteger ( baos ,    BigInteger . valueOf ( Long . MIN _ VALUE )  )  ;", "OrcInputStream   inputStream    =     . orcInputStreamFor (  \" skip   test \"  ,    baos . toByteArray (  )  )  ;", "DecimalInputStream   stream    =    new   DecimalInputStream ( inputStream )  ;", "stream . skip (  1  )  ;", "assertEquals ( stream . nextLong (  )  ,    Long . MIN _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["testSkipsValue"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "value    =    value . shiftLeft (  1  )  ;", "int   sign    =    value . signum (  )  ;", "if    ( sign    <     0  )     {", "value    =    value . negate (  )  ;", "value    =    value . subtract ( BigInteger . ONE )  ;", "}", "int   length    =    value . bitLength (  )  ;", "while    ( true )     {", "long   lowBits    =     ( value . longValue (  )  )     &     9  2  2  3  3  7  2  0  3  6  8  5  4  7  7  5  8  0  7 L ;", "length    -  =     6  3  ;", "for    ( int   i    =     0  ;    i    <     9  ;     +  + i )     {", "if    (  ( length    <  =     0  )     &  &     (  ( lowBits    &     (  ~  1  2  7  )  )     =  =     0  )  )     {", "output . write (  (  ( byte )     ( lowBits )  )  )  ;", "return ;", "} else    {", "output . write (  (  ( byte )     (  1  2  8     |     ( lowBits    &     1  2  7  )  )  )  )  ;", "lowBits    >  >  >  =     7  ;", "}", "}", "value    =    value . shiftRight (  6  3  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeBigInteger"], "fileName": "com.facebook.presto.orc.stream.TestDecimalStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Double >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Double >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( double )     (  ( groupIndex    *     1  0  0  0  0  )     +    i )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestDoubleStream"}, {"methodBody": ["METHOD_START", "{", "List < List < Float >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Float >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( float )     (  ( groupIndex    *     1  0  0  0  0  )     +    i )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestFloatStream"}, {"methodBody": ["METHOD_START", "{", "for    ( int   width    =     1  ;    width    <  =     ( TestLongBitPacker . WIDTHS )  ;    width +  +  )     {", "for    ( int   offset    =     0  ;    offset    <     ( TestLongBitPacker . OFFSETS )  ;    offset +  +  )     {", "long [  ]    expected    =    new   long [ length    +    offset ]  ;", "long [  ]    actual    =    new   long [ length    +    offset ]  ;", "TestLongBitPacker . RandomByteInputStream   expectedInput    =    new   TestLongBitPacker . RandomByteInputStream (  )  ;", "TestingBitPackingUtils . unpackGeneric ( expected ,    offset ,    length ,    width ,    expectedInput )  ;", "TestLongBitPacker . RandomByteInputStream   actualInput    =    new   TestLongBitPacker . RandomByteInputStream (  )  ;", "packer . unpack ( actual ,    offset ,    length ,    width ,    actualInput )  ;", "for    ( int   i    =    offset ;    i    <     ( length    +    offset )  ;    i +  +  )     {", "assertEquals ( actual [ i ]  ,    expected [ i ]  ,    String . format (  \" index    =     % s ,    length    =     % s ,    width    =     % s ,    offset    =     % s \"  ,    i ,    length ,    width ,    offset )  )  ;", "}", "assertEquals ( actualInput . getReadBytes (  )  ,    expectedInput . getReadBytes (  )  ,    String . format (  \" Wrong   number   of   bytes   read   for   length    =     % s ,    width    =     % s ,    offset    =     % s \"  ,    length ,    width ,    offset )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertUnpacking"], "fileName": "com.facebook.presto.orc.stream.TestLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "LongBitPacker   packer    =    new   LongBitPacker (  )  ;", "for    ( int   length    =     0  ;    length    <     (  . LENGTHS )  ;    length +  +  )     {", ". assertUnpacking ( packer ,    length )  ;", "}", "}", "METHOD_END"], "methodName": ["testBasic"], "fileName": "com.facebook.presto.orc.stream.TestLongBitPacker"}, {"methodBody": ["METHOD_START", "{", "Random   random    =    new   Random (  0  )  ;", "List < List < Slice >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Slice >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "BigInteger   value    =    new   BigInteger (  1  2  0  ,    random )  ;", "group . add ( unscaled ( value )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestLongDecimalStream"}, {"methodBody": ["METHOD_START", "{", "TestLongDecode . assertVIntRoundTrip ( output ,    value ,    true )  ;", "TestLongDecode . assertVIntRoundTrip ( output ,    value ,    false )  ;", "}", "METHOD_END"], "methodName": ["assertVIntRoundTrip"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "output . reset (  )  ;", "if    ( signed )     {", ". writeVslong ( output ,    value )  ;", "} else    {", ". writeVulong ( output ,    value )  ;", "}", "Slice   hiveBytes    =    Slices . copyOf ( output . slice (  )  )  ;", "output . reset (  )  ;", "LongDecode . writeVLong ( output ,    value ,    signed )  ;", "Slice   prestoBytes    =    Slices . copyOf ( output . slice (  )  )  ;", "if    (  !  ( prestoBytes . equals ( hiveBytes )  )  )     {", "assertEquals ( prestoBytes ,    hiveBytes )  ;", "}", "if    ( signed )     {", "long   readValueOld    =     . readVslong ( hiveBytes . getInput (  )  )  ;", "assertEquals ( readValueOld ,    value )  ;", "} else    {", "long   readValueOld    =     . readVulong ( hiveBytes . getInput (  )  )  ;", "assertEquals ( readValueOld ,    value )  ;", "}", "long   readValueNew    =    LongDecode . readVInt ( signed ,    new   OrcInputStream ( new   OrcDataSourceId (  \" test \"  )  ,    hiveBytes . getInput (  )  ,    Optional . empty (  )  ,    newSimpleAggregatedMemoryContext (  )  )  )  ;", "assertEquals ( readValueNew ,    value )  ;", "}", "METHOD_END"], "methodName": ["assertVIntRoundTrip"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "long   result    =    TestLongDecode . readVulong ( in )  ;", "return    ( result    >  >  >     1  )     ^     (  -  ( result    &     1  )  )  ;", "}", "METHOD_END"], "methodName": ["readVslong"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "long   result    =     0  ;", "long   b ;", "int   offset    =     0  ;", "do    {", "b    =    in . read (  )  ;", "if    ( b    =  =     (  -  1  )  )     {", "throw   new   EOFException (  \" Reading   Vulong   past   EOF \"  )  ;", "}", "result    |  =     (  1  2  7     &    b )     <  <    offset ;", "offset    +  =     7  ;", "}    while    ( b    >  =     1  2  8     )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["readVulong"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "Slice   slice    =    Slices . allocate (  1  0  0  )  ;", "SliceOutput   output    =    slice . getOutput (  )  ;", ". assertVIntRoundTrip ( output ,     0  )  ;", ". assertVIntRoundTrip ( output ,     1  )  ;", ". assertVIntRoundTrip ( output ,     (  -  1  )  )  ;", ". assertVIntRoundTrip ( output ,    Integer . MAX _ VALUE )  ;", ". assertVIntRoundTrip ( output ,     (  ( Integer . MAX _ VALUE )     +     1 L )  )  ;", ". assertVIntRoundTrip ( output ,     (  ( Integer . MAX _ VALUE )     -     1 L )  )  ;", ". assertVIntRoundTrip ( output ,    Integer . MIN _ VALUE )  ;", ". assertVIntRoundTrip ( output ,     (  ( Integer . MIN _ VALUE )     +     1 L )  )  ;", ". assertVIntRoundTrip ( output ,     (  ( Integer . MIN _ VALUE )     -     1 L )  )  ;", ". assertVIntRoundTrip ( output ,    Long . MAX _ VALUE )  ;", ". assertVIntRoundTrip ( output ,     (  ( Long . MAX _ VALUE )     -     1  )  )  ;", ". assertVIntRoundTrip ( output ,     (  ( Long . MIN _ VALUE )     +     1  )  )  ;", "for    ( int   value    =     -  1  0  0  0  0  0  ;    value    <     1  0  0  0  0  0  ;    value +  +  )     {", ". assertVIntRoundTrip ( output ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["testVInt"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "TestLongDecode . writeVulong ( output ,     (  ( value    <  <     1  )     ^     ( value    >  >     6  3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeVslong"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    (  ( value    &     (  ~  1  2  7  )  )     =  =     0  )     {", "output . write (  (  ( byte )     ( value )  )  )  ;", "return ;", "} else    {", "output . write (  (  ( byte )     (  1  2  8     |     ( value    &     1  2  7  )  )  )  )  ;", "value    >  >  >  =     7  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeVulong"], "fileName": "com.facebook.presto.orc.stream.TestLongDecode"}, {"methodBody": ["METHOD_START", "{", "List < List < Long >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Long >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( long )     (  ( groupIndex    *     1  0  0  0  0  )     +    i )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestLongStreamDwrf"}, {"methodBody": ["METHOD_START", "{", "List < List < Long >  >    groups    =    new   ArrayList <  >  (  )  ;", "List < Long >    group ;", "group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( long )     ( i )  )  )  ;", "}", "groups . add ( group )  ;", "group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( long )     (  1  0  0  0  0     +     ( i    *     1  7  )  )  )  )  ;", "}", "groups . add ( group )  ;", "group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( long )     (  1  0  0  0  0     -     ( i    *     1  7  )  )  )  )  ;", "}", "groups . add ( group )  ;", "group    =    new   ArrayList <  >  (  )  ;", "Random   random    =    new   Random (  2  2  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  (  -  1  0  0  0 L )     +     ( random . nextInt (  1  7  )  )  )  )  ;", "}", "groups . add ( group )  ;", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestLongStreamV1"}, {"methodBody": ["METHOD_START", "{", "List < List < Long >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Long >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "group . add (  (  ( long )     (  ( groupIndex    *     1  0  0  0  0  )     +    i )  )  )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestLongStreamV2"}, {"methodBody": ["METHOD_START", "{", "Randrand =    new   Rand 0  )  ;", "List < List < Long >  >    groups    =    new   ArrayList <  >  (  )  ;", "for    ( int   groupIndex    =     0  ;    groupIndex    <     3  ;    groupIndex +  +  )     {", "List < Long >    group    =    new   ArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "long   value    =    randnextLong (  )  ;", "group . add ( value )  ;", "}", "groups . add ( group )  ;", "}", "testWriteValue ( groups )  ;", "}", "METHOD_END"], "methodName": ["test"], "fileName": "com.facebook.presto.orc.stream.TestShortDecimalStream"}, {"methodBody": ["METHOD_START", "{", "int   bitsLeft    =     0  ;", "int   current    =     0  ;", "for    ( int   i    =    offset ;    i    <     ( offset    +    len )  ;    i +  +  )     {", "long   ult    =     0  ;", "int   bitsLeftToRead    =    bitSize ;", "while    ( bitsLeftToRead    >    bitsLeft )     {", "ult    <  <  =    bitsLeft ;", "ult    |  =    current    &     (  (  1     <  <    bitsLeft )     -     1  )  ;", "bitsLeftToRead    -  =    bitsLeft ;", "current    =    input . read (  )  ;", "bitsLeft    =     8  ;", "}", "if    ( bitsLeftToRead    >     0  )     {", "ult    <  <  =    bitsLeftToRead ;", "bitsLeft    -  =    bitsLeftToRead ;", "ult    |  =     ( current    >  >    bitsLeft )     &     (  (  1     <  <    bitsLeftToRead )     -     1  )  ;", "}", "buffer [ i ]     =    ult ;", "}", "}", "METHOD_END"], "methodName": ["unpackGeneric"], "fileName": "com.facebook.presto.orc.stream.TestingBitPackingUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT _ V 2  )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )  )     {", "return   new   LongInputV 2  ( input ,    signed ,    false )  ;", "} else", "if    (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DIRECT )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )  )     {", "return   new   LongInputV 1  ( input ,    signed )  ;", "} else", "if    ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DWRF _ DIRECT )  )     {", "return   new   LongInputDwrf ( input ,    type ,    signed ,    usesVInt )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   encoding   for   long   stream :     \"     +    encoding )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createLongStream"], "fileName": "com.facebook.presto.orc.stream.ValueStreams"}, {"methodBody": ["METHOD_START", "{", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . PRESENT )  )     {", "return   new   BooleanInputStream ( inputStream )  ;", "}", "if    (  (  ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY )  )     |  |     ( encoding    =  =     ( ColumnEncoding . ColumnEncodingKind . DICTIONARY _ V 2  )  )  )     &  &     (  (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . LENGTH )  )     |  |     (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DATA )  )  )  )     {", "return    . createLongStream ( inputStream ,    encoding ,    OrcType . OrcTypeKind . INT ,    false ,    usesVInt )  ;", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DATA )  )     {", "switch    ( type )     {", "case   BOOLEAN    :", "return   new   BooleanInputStream ( inputStream )  ;", "case   BYTE    :", "return   new   ByteInputStream ( inputStream )  ;", "case   SHORT    :", "case   INT    :", "case   LONG    :", "case   DATE    :", "return    . createLongStream ( inputStream ,    encoding ,    type ,    true ,    usesVInt )  ;", "case   FLOAT    :", "return   new   FloatInputStream ( inputStream )  ;", "case   DOUBLE    :", "return   new   DoubleInputStream ( inputStream )  ;", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "return   new   ByteArrayInputStream ( inputStream )  ;", "case   TIMESTAMP    :", "return    . createLongStream ( inputStream ,    encoding ,    type ,    true ,    usesVInt )  ;", "case   DECIMAL    :", "return   new   DecimalInputStream ( inputStream )  ;", "}", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . LENGTH )  )     {", "switch    ( type )     {", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "case   MAP    :", "case   LIST    :", "return    . createLongStream ( inputStream ,    encoding ,    type ,    false ,    usesVInt )  ;", "}", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . ROW _ GROUP _ DICTIONARY _ LENGTH )  )     {", "switch    ( type )     {", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "return   new   RowGroupDictionaryLengthInputStream ( inputStream ,    false )  ;", "}", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . ROW _ GROUP _ DICTIONARY )  )     {", "switch    ( type )     {", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "return   new   ByteArrayInputStream ( inputStream )  ;", "}", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . IN _ DICTIONARY )  )     {", "return   new   BooleanInputStream ( inputStream )  ;", "}", "if    (  ( type    =  =     ( OrcType . OrcTypeKind . TIMESTAMP )  )     &  &     (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . SECONDARY )  )  )     {", "return    . createLongStream ( inputStream ,    encoding ,    type ,    false ,    usesVInt )  ;", "}", "if    (  ( type    =  =     ( OrcType . OrcTypeKind . DECIMAL )  )     &  &     (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . SECONDARY )  )  )     {", "return    . createLongStream ( inputStream ,    encoding ,    type ,    true ,    usesVInt )  ;", "}", "if    (  ( streamId . getStreamKind (  )  )     =  =     ( Stream . StreamKind . DICTIONARY _ DATA )  )     {", "switch    ( type )     {", "case   SHORT    :", "case   INT    :", "case   LONG    :", "return    . createLongStream ( inputStream ,    ColumnEncoding . ColumnEncodingKind . DWRF _ DIRECT ,    OrcType . OrcTypeKind . INT ,    true ,    usesVInt )  ;", "case   STRING    :", "case   VARCHAR    :", "case   CHAR    :", "case   BINARY    :", "return   new   ByteArrayInputStream ( inputStream )  ;", "}", "}", "throw   new   IllegalArgumentException ( String . format (  \" Unsupported   column   type    % s   for   stream    % s   with   encoding    % s \"  ,    type ,    streamId ,    encoding )  )  ;", "}", "METHOD_END"], "methodName": ["createValueStreams"], "fileName": "com.facebook.presto.orc.stream.ValueStreams"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "presentCheckpoint . ifPresent (  (    bStreamCheckpoint )     -  >    positionList . addAll ( bStreamCheckpoint . toPositionList ( compressed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( compressed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createBooleanColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.BooleanColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createByteColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.ByteColumnWriter"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . of (  )  ;", "}", "METHOD_END"], "methodName": ["getNestedColumnWriters"], "fileName": "com.facebook.presto.orc.writer.ColumnWriter"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( type ,     \" type   is   null \"  )  ;", "OrcType   orcType    =    orcTypes . get ( columnIndex )  ;", "switch    ( orcType . getOrcTypeKind (  )  )     {", "case   BOOLEAN    :", "return   new   BooleanColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize )  ;", "case   FLOAT    :", "return   new   FloatColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize )  ;", "case   DOUBLE    :", "return   new   DoubleColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize )  ;", "case   BYTE    :", "return   new   ByteColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize )  ;", "case   DATE    :", "checkArgument (  ( orcEncoding    !  =     ( OrcEncoding . DWRF )  )  ,     \" DWRF   does   not   support    % s   type \"  ,    type )  ;", "return   new   LongColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding ,    DateStatisticsBuilder :  : new )  ;", "case   SHORT    :", "case   INT    :", "case   LONG    :", "return   new   LongColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding ,    IntegerStatisticsBuilder :  : new )  ;", "case   DECIMAL    :", "checkArgument (  ( orcEncoding    !  =     ( OrcEncoding . DWRF )  )  ,     \" DWRF   does   not   support    % s   type \"  ,    type )  ;", "return   new   DecimalColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding )  ;", "case   TIMESTAMP    :", "return   new   TimestampColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding ,    hiveStorageTimeZone )  ;", "case   BINARY    :", "return   new   SliceDirectColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding ,    BinaryStatisticsBuilder :  : new )  ;", "case   CHAR    :", "checkArgument (  ( orcEncoding    !  =     ( OrcEncoding . DWRF )  )  ,     \" DWRF   does   not   support    % s   type \"  ,    type )  ;", "case   VARCHAR    :", "case   STRING    :", "return   new   SliceDictionaryColumnWriter ( columnIndex ,    type ,    compression ,    bufferSize ,    orcEncoding ,    stringStatisticsLimit )  ;", "case   LIST    :", "{", "int   fieldColumnIndex    =    orcType . getFieldTypeIndex (  0  )  ;", "Type   fieldType    =    type . getTypeParameters (  )  . get (  0  )  ;", "ColumnWriter   elementWriter    =     . createColumnWriter ( fieldColumnIndex ,    orcTypes ,    fieldType ,    compression ,    bufferSize ,    orcEncoding ,    hiveStorageTimeZone ,    stringStatisticsLimit )  ;", "return   new   ListColumnWriter ( columnIndex ,    compression ,    bufferSize ,    orcEncoding ,    elementWriter )  ;", "}", "case   MAP    :", "{", "ColumnWriter   keyWriter    =     . createColumnWriter ( orcType . getFieldTypeIndex (  0  )  ,    orcTypes ,    type . getTypeParameters (  )  . get (  0  )  ,    compression ,    bufferSize ,    orcEncoding ,    hiveStorageTimeZone ,    stringStatisticsLimit )  ;", "ColumnWriter   valueWriter    =     . createColumnWriter ( orcType . getFieldTypeIndex (  1  )  ,    orcTypes ,    type . getTypeParameters (  )  . get (  1  )  ,    compression ,    bufferSize ,    orcEncoding ,    hiveStorageTimeZone ,    stringStatisticsLimit )  ;", "return   new   MapColumnWriter ( columnIndex ,    compression ,    bufferSize ,    orcEncoding ,    keyWriter ,    valueWriter )  ;", "}", "case   STRUCT    :", "{", "ImmutableList . Builder < ColumnWriter >    fieldWriters    =    ImmutableList . builder (  )  ;", "for    ( int   fieldId    =     0  ;    fieldId    <     ( orcType . getFieldCount (  )  )  ;    fieldId +  +  )     {", "int   fieldColumnIndex    =    orcType . getFieldTypeIndex ( fieldId )  ;", "Type   fieldType    =    type . getTypeParameters (  )  . get ( fieldId )  ;", "fieldWriters . add (  . createColumnWriter ( fieldColumnIndex ,    orcTypes ,    fieldType ,    compression ,    bufferSize ,    orcEncoding ,    hiveStorageTimeZone ,    stringStatisticsLimit )  )  ;", "}", "return   new   StructColumnWriter ( columnIndex ,    compression ,    bufferSize ,    fieldWriters . build (  )  )  ;", "}", "}", "throw   new   IllegalArgumentException (  (  \" Unsupported   type :     \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["createColumnWriter"], "fileName": "com.facebook.presto.orc.writer.ColumnWriters"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "positionList . addAll ( scaleCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createDecimalColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.DecimalColumnWriter"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( block . isNull ( position )  )  )  ,     \" position   is   null \"  )  ;", "blockBytesTo ( position ,     0  ,    block . getSliceLength ( position )  ,    elementBlock )  ;", "elementBlock . closeEntry (  )  ;", "int   newElementPositionInBlock    =     ( elementBlock . getPositionCount (  )  )     -     1  ;", "blockPositionByHash . set ( hashPosition ,    newElementPositionInBlock )  ;", "if    (  ( elementBlock . getPositionCount (  )  )     >  =     ( maxFill )  )     {", "rehash (  (  ( maxFill )     *     2  )  )  ;", "}", "return   newElementPositionInBlock ;", "}", "METHOD_END"], "methodName": ["addNewElement"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "int   maxFill    =     (  ( int )     ( Math . ceil (  ( hashSize    *     ( DictionaryBuilder . FILL _ RATIO )  )  )  )  )  ;", "if    ( maxFill    =  =    hashSize )     {", "maxFill -  -  ;", "}", "return   maxFill ;", "}", "METHOD_END"], "methodName": ["calculateMaxFill"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "containsNullElement    =    false ;", "blockPositionByHash . fill (  . EMPTY _ SLOT )  ;", "elementBlock    =    elementBlock . newBlockBuilderLike ( null )  ;", "elementBlock . appendNull (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( block ,     \" block   must   not   be   null \"  )  ;", "checkArgument (  ( position    >  =     0  )  ,     \" position   must   be    >  =     0  \"  )  ;", "if    ( block . isNull ( position )  )     {", "return   containsNullElement ;", "} else    {", "return    ( blockPositionByHash . get ( getHashPositionOfElement ( block ,    position )  )  )     !  =     (  . EMPTY _ SLOT )  ;", "}", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return   elementBlock ;", "}", "METHOD_END"], "methodName": ["getElementBlock"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return   elementBlock . getPositionCount (  )  ;", "}", "METHOD_END"], "methodName": ["getEntryCount"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( block . isNull ( position )  )  )  ,     \" position   is   null \"  )  ;", "int   length    =    block . getSliceLength ( position )  ;", "long   hashPosition    =    getMaskedHash ( block . hash ( position ,     0  ,    length )  )  ;", "while    ( true )     {", "int   blockPosition    =    blockPositionByHash . get ( hashPosition )  ;", "if    ( blockPosition    =  =     (  . EMPTY _ SLOT )  )     {", "return   hashPosition ;", "} else", "if    (  (  ( elementBlock . getSliceLength ( blockPosition )  )     =  =    length )     &  &     ( block . equals ( position ,     0  ,    elementBlock ,    blockPosition ,     0  ,    length )  )  )     {", "return   hashPosition ;", "}", "hashPosition    =    getMaskedHash (  ( hashPosition    +     1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getHashPositionOfElement"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return   rawHash    &     ( hashMask )  ;", "}", "METHOD_END"], "methodName": ["getMaskedHash"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DictionaryBuilder . INSTANCE _ SIZE )     +     ( elementBlock . getRetainedSizeInBytes (  )  )  )     +     ( blockPositionByHash . sizeOf (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRetainedSizeInBytes"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "return   elementBlock . getSizeInBytes (  )  ;", "}", "METHOD_END"], "methodName": ["getSizeInBytes"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( block ,     \" block   must   not   be   null \"  )  ;", "if    ( block . isNull ( position )  )     {", "containsNullElement    =    true ;", "return    . NULL _ POSITION ;", "}", "int   blockPosition ;", "long   hashPosition    =    getHashPositionOfElement ( block ,    position )  ;", "if    (  ( blockPositionByHash . get ( hashPosition )  )     !  =     (  . EMPTY _ SLOT )  )     {", "blockPosition    =    blockPositionByHash . get ( hashPosition )  ;", "} else    {", "blockPosition    =    addNewElement ( hashPosition ,    block ,    position )  ;", "}", "verify (  ( blockPosition    !  =     (  . NULL _ POSITION )  )  )  ;", "return   blockPosition ;", "}", "METHOD_END"], "methodName": ["putIfAbsent"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "int   newHashSize    =    HashCommon . arraySize (  ( size    +     1  )  ,    DictionaryBuilder . FILL _ RATIO )  ;", "hashMask    =    newHashSize    -     1  ;", "maxFill    =    DictionaryBuilder . calculateMaxFill ( newHashSize )  ;", "blockPositionByHash . ensureCapacity ( newHashSize )  ;", "blockPositionByHash . fill ( DictionaryBuilder . EMPTY _ SLOT )  ;", "for    ( int   blockPosition    =     1  ;    blockPosition    <     ( elementBlock . getPositionCount (  )  )  ;    blockPosition +  +  )     {", "blockPositionByHash . set ( getHashPositionOfElement ( elementBlock ,    blockPosition )  ,    blockPosition )  ;", "}", "}", "METHOD_END"], "methodName": ["rehash"], "fileName": "com.facebook.presto.orc.writer.DictionaryBuilder"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createDoubleColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.DoubleColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createFloatColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.FloatColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "presentCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( compressed )  )  )  ;", "positionList . addAll ( lengthCheckpoint . toPositionList ( compressed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createArrayColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.ListColumnWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   position    =     0  ;    position    <     ( columnarArray . getPositionCount (  )  )  ;    position +  +  )     {", "boolean   present    =     !  ( columnarArray . isNull ( position )  )  ;", "presentStreamBoolean ( present )  ;", "if    ( present )     {", "( nonNullValueCount )  +  +  ;", "lengthStreamLong ( columnarArray . getLength ( position )  )  ;", "}", "}", "Block   elementsBlock    =    columnarArray . getElementsBlock (  )  ;", "if    (  ( elementsBlock . getPositionCount (  )  )     >     0  )     {", "elementWriterBlock ( elementsBlock )  ;", "}", "}", "METHOD_END"], "methodName": ["writeColumnarArray"], "fileName": "com.facebook.presto.orc.writer.ListColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createLongColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.LongColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( lengthCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createArrayColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.MapColumnWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   position    =     0  ;    position    <     ( columnarMap . getPositionCount (  )  )  ;    position +  +  )     {", "boolean   present    =     !  ( columnarMap . isNull ( position )  )  ;", "presentStreamBoolean ( present )  ;", "if    ( present )     {", "( nonNullValueCount )  +  +  ;", "lengthStreamLong ( columnarMap . getEntryCount ( position )  )  ;", "}", "}", "Block   keysBlock    =    columnarMap . getKeysBlock (  )  ;", "if    (  ( keysBlock . getPositionCount (  )  )     >     0  )     {", "keyWriterBlock ( keysBlock )  ;", "valueWriterBlock ( columnarMap . getValuesBlock (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeColumnarMap"], "fileName": "com.facebook.presto.orc.writer.MapColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "presentCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( compressed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( compressed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createSliceColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.SliceDictionaryColumnWriter"}, {"methodBody": ["METHOD_START", "{", "int [  ]    sortedPositions    =    new   int [ elementBlock . getPositionCount (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( sortedPositions . length )  ;    i +  +  )     {", "sortedPositions [ i ]     =    i ;", "}", "IntArrays . quickSort ( sortedPositions ,     0  ,    sortedPositions . length ,    new   AbstractIntComparator (  )     {", "@ Override", "public   int   compare ( int   left ,    int   right )     {", "boolean   nullLeft    =    elementBlock . isNull ( left )  ;", "boolean   nullRight    =    elementBlock . isNull ( right )  ;", "if    ( nullLeft    &  &    nullRight )     {", "return    0  ;", "}", "if    ( nullLeft )     {", "return    1  ;", "}", "if    ( nullRight )     {", "return    -  1  ;", "}", "return   elementBlock . compareTo ( left ,     0  ,    elementBlock . getLength ( left )  ,    elementBlock ,    right ,     0  ,    elementBlock . getLength ( right )  )  ;", "}", "}  )  ;", "return   sortedPositions ;", "}", "METHOD_END"], "methodName": ["getSortedDictionaryNullsLast"], "fileName": "com.facebook.presto.orc.writer.SliceDictionaryColumnWriter"}, {"methodBody": ["METHOD_START", "{", "return   new   StringStatisticsBuilder ( stringStatisticsLimitInBytes )  ;", "}", "METHOD_END"], "methodName": ["newStringStatisticsBuilder"], "fileName": "com.facebook.presto.orc.writer.SliceDictionaryColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( dataCheckpoint . toPositionList ( comsed )  )  ;", "positionList . addAll ( lengthCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createSliceColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.SliceDirectColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createStructColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.StructColumnWriter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   position    =     0  ;    position    <     ( columnarRow . getPositionCount (  )  )  ;    position +  +  )     {", "boolean   present    =     !  ( columnarRow . isNull ( position )  )  ;", "presentStream . writeBoolean ( present )  ;", "if    ( present )     {", "( nonNullValueCount )  +  +  ;", "}", "}", "for    ( int   i    =     0  ;    i    <     ( structFields . size (  )  )  ;    i +  +  )     {", "columnWriter    =    structFields . get ( i )  ;", "Block   fieldBlock    =    columnarRow . getField ( i )  ;", "if    (  ( fieldBlock . getPositionCount (  )  )     >     0  )     {", "columnWriter . writeBlock ( fieldBlock )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeColumnarRow"], "fileName": "com.facebook.presto.orc.writer.StructColumnWriter"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Integer >    positionList    =    ImmutableList . builder (  )  ;", "entCheckpoint . ifPresent (  (    booleanStreamCheckpoint )     -  >    positionList . addAll ( booleanStreamCheckpoint . toPositionList ( comsed )  )  )  ;", "positionList . addAll ( secondsCheckpoint . toPositionList ( comsed )  )  ;", "positionList . addAll ( nanosCheckpoint . toPositionList ( comsed )  )  ;", "return   positionList . build (  )  ;", "}", "METHOD_END"], "methodName": ["createTimestampColumnPositionList"], "fileName": "com.facebook.presto.orc.writer.TimestampColumnWriter"}, {"methodBody": ["METHOD_START", "{", "return    ( startAddress    =  =    currentAddress )     &  &     ( bitsConsumed    =  =     ( Long . SIZE )  )  ;", "}", "METHOD_END"], "methodName": ["isEndOfStream"], "fileName": "com.facebook.presto.orc.zstd.BitStream"}, {"methodBody": ["METHOD_START", "{", "return    (  ( bitContainer    <  <    bitsConsumed )     >  >  >     1  )     >  >  >     (  6  3     -    numberOfBits )  ;", "}", "METHOD_END"], "methodName": ["peekBits"], "fileName": "com.facebook.presto.orc.zstd.BitStream"}, {"methodBody": ["METHOD_START", "{", "return    ( bitContainer    <  <    bitsConsumed )     >  >  >     (  6  4     -    numberOfBits )  ;", "}", "METHOD_END"], "methodName": ["peekBitsFast"], "fileName": "com.facebook.presto.orc.zstd.BitStream"}, {"methodBody": ["METHOD_START", "{", "long   bits    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    inputAddress )  )     &     2  5  5  ;", "switch    ( inputSize )     {", "case    7     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     6  )  )  )     &     2  5  5 L )     <  <     4  8  ;", "case    6     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     5  )  )  )     &     2  5  5 L )     <  <     4  0  ;", "case    5     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     4  )  )  )     &     2  5  5 L )     <  <     3  2  ;", "case    4     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     3  )  )  )     &     2  5  5 L )     <  <     2  4  ;", "case    3     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     2  )  )  )     &     2  5  5 L )     <  <     1  6  ;", "case    2     :", "bits    |  =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( inputAddress    +     1  )  )  )     &     2  5  5 L )     <  <     8  ;", "}", "return   bits ;", "}", "METHOD_END"], "methodName": ["readTail"], "fileName": "com.facebook.presto.orc.zstd.BitStream"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "input    +  =    reader . readFseTable ( table ,    inputBase ,    input ,    inputLimit ,    FseTableReader . FSE _ MAX _ SYMBOL _ VALUE ,     . MAX _ TABLE _ LOG )  ;", "final   Object   outputBase    =    weights ;", "final   long   outputAddress    =    Unsafe . ARRAY _ BYTE _ BASE _ OFFSET ;", "final   long   outputLimit    =    outputAddress    +     ( weights . length )  ;", "long   output    =    outputAddress ;", "BitStream . Initializer   initializer    =    new   BitStream . Initializer ( inputBase ,    input ,    inputLimit )  ;", "initializer . initialize (  )  ;", "int   bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   currentAddress    =    initializer . getCurrentAddress (  )  ;", "long   bits    =    initializer . getBits (  )  ;", "int   state 1     =     (  ( int )     ( BitStream . peekBits ( bitsConsumed ,    bits ,    table . log 2 Size )  )  )  ;", "bitsConsumed    +  =    table . log 2 Size ;", "BitStream . Loader   loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader . load (  )  ;", "bits    =    loader . getBits (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "int   state 2     =     (  ( int )     ( BitStream . peekBits ( bitsConsumed ,    bits ,    table . log 2 Size )  )  )  ;", "bitsConsumed    +  =    table . log 2 Size ;", "loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader . load (  )  ;", "bits    =    loader . getBits (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "byte [  ]    symbols    =    table . symbol ;", "byte [  ]    numbersOfBits    =    table . numberOfBits ;", "int [  ]    newStates    =    table . newState ;", "while    ( output    <    outputLimit )     {", "int   numberOfBits ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    output ,    symbols [ state 1  ]  )  ;", "numberOfBits    =    numbersOfBits [ state 1  ]  ;", "state 1     =     (  ( int )     (  ( newStates [ state 1  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     1  )  ,    symbols [ state 2  ]  )  ;", "numberOfBits    =    numbersOfBits [ state 2  ]  ;", "state 2     =     (  ( int )     (  ( newStates [ state 2  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     2  )  ,    symbols [ state 1  ]  )  ;", "numberOfBits    =    numbersOfBits [ state 1  ]  ;", "state 1     =     (  ( int )     (  ( newStates [ state 1  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     3  )  ,    symbols [ state 2  ]  )  ;", "numberOfBits    =    numbersOfBits [ state 2  ]  ;", "state 2     =     (  ( int )     (  ( newStates [ state 2  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "output    +  =    SIZE _ OF _ INT ;", "loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "boolean   done    =    loader . load (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "bits    =    loader . getBits (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "}", "while    ( true )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output +  +  )  ,    symbols [ state 1  ]  )  ;", "int   numberOfBits    =    numbersOfBits [ state 1  ]  ;", "state 1     =     (  ( int )     (  ( newStates [ state 1  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader . load (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "bits    =    loader . getBits (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( loader . isOverflow (  )  )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output +  +  )  ,    symbols [ state 2  ]  )  ;", "break ;", "}", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output +  +  )  ,    symbols [ state 2  ]  )  ;", "int   numberOfBits 1     =    numbersOfBits [ state 2  ]  ;", "state 2     =     (  ( int )     (  ( newStates [ state 2  ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits 1  )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits 1  ;", "loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader . load (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "bits    =    loader . getBits (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( loader . isOverflow (  )  )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output +  +  )  ,    symbols [ state 1  ]  )  ;", "break ;", "}", "}", "return    (  ( int )     ( output    -    outputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["decompress"], "fileName": "com.facebook.presto.orc.zstd.FiniteStateEntropy"}, {"methodBody": ["METHOD_START", "{", "table . log 2 Size    =     0  ;", "table . symbol [  0  ]     =    value ;", "table . newState [  0  ]     =     0  ;", "table . numberOfBits [  0  ]     =     0  ;", "}", "METHOD_END"], "methodName": ["buildRleTable"], "fileName": "com.facebook.presto.orc.zstd.FseTableReader"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "Util . verify (  (  ( inputLimit    -    inputAddress )     >  =     4  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   threshold ;", "int   symbolNumber    =     0  ;", "boolean   previousIsZero    =    false ;", "int   bitStream    =    UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  ;", "int   tableLog    =     ( bitStream    &     1  5  )     +     (  . FSE _ MIN _ TABLE _ LOG )  ;", "int   numberOfBits    =    tableLog    +     1  ;", "bitStream    >  >  >  =     4  ;", "int   bitCount    =     4  ;", "Util . verify (  ( tableLog    <  =    maxTableLog )  ,    input ,     \" FSE   table   size   exceeds   maximum   allowed   size \"  )  ;", "int   remaining    =     (  1     <  <    tableLog )     +     1  ;", "threshold    =     1     <  <    tableLog ;", "while    (  ( remaining    >     1  )     &  &     ( symbolNumber    <  =    maxSymbol )  )     {", "if    ( previousIsZero )     {", "int   n 0     =    symbolNumber ;", "while    (  ( bitStream    &     6  5  5  3  5  )     =  =     6  5  5  3  5  )     {", "n 0     +  =     2  4  ;", "if    ( input    <     ( inputLimit    -     5  )  )     {", "input    +  =     2  ;", "bitStream    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     >  >  >    bitCount ;", "} else    {", "bitStream    >  >  >  =     1  6  ;", "bitCount    +  =     1  6  ;", "}", "}", "while    (  ( bitStream    &     3  )     =  =     3  )     {", "n 0     +  =     3  ;", "bitStream    >  >  >  =     2  ;", "bitCount    +  =     2  ;", "}", "n 0     +  =    bitStream    &     3  ;", "bitCount    +  =     2  ;", "Util . verify (  ( n 0     <  =    maxSymbol )  ,    input ,     \" Symbol   larger   than   max   value \"  )  ;", "while    ( symbolNumber    <    n 0  )     {", "normalizedCounters [  ( symbolNumber +  +  )  ]     =     0  ;", "}", "if    (  ( input    <  =     ( inputLimit    -     7  )  )     |  |     (  ( input    +     ( bitCount    >  >  >     3  )  )     <  =     ( inputLimit    -     4  )  )  )     {", "input    +  =    bitCount    >  >  >     3  ;", "bitCount    &  =     7  ;", "bitStream    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     >  >  >    bitCount ;", "} else    {", "bitStream    >  >  >  =     2  ;", "}", "}", "short   max    =     (  ( short )     (  (  (  2     *    threshold )     -     1  )     -    remaining )  )  ;", "short   count ;", "if    (  ( bitStream    &     ( threshold    -     1  )  )     <    max )     {", "count    =     (  ( short )     ( bitStream    &     ( threshold    -     1  )  )  )  ;", "bitCount    +  =    numberOfBits    -     1  ;", "} else    {", "count    =     (  ( short )     ( bitStream    &     (  (  2     *    threshold )     -     1  )  )  )  ;", "if    ( count    >  =    threshold )     {", "count    -  =    max ;", "}", "bitCount    +  =    numberOfBits ;", "}", "count -  -  ;", "remaining    -  =    Math . abs ( count )  ;", "normalizedCounters [  ( symbolNumber +  +  )  ]     =    count ;", "previousIsZero    =    count    =  =     0  ;", "while    ( remaining    <    threshold )     {", "numberOfBits -  -  ;", "threshold    >  >  >  =     1  ;", "}", "if    (  ( input    <  =     ( inputLimit    -     7  )  )     |  |     (  ( input    +     ( bitCount    >  >     3  )  )     <  =     ( inputLimit    -     4  )  )  )     {", "input    +  =    bitCount    >  >  >     3  ;", "bitCount    &  =     7  ;", "} else    {", "bitCount    -  =     (  ( int )     (  8     *     (  ( inputLimit    -     4  )     -    input )  )  )  ;", "input    =    inputLimit    -     4  ;", "}", "bitStream    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     >  >  >     ( bitCount    &     3  1  )  ;", "}", "Util . verify (  (  ( remaining    =  =     1  )     &  &     ( bitCount    <  =     3  2  )  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "maxSymbol    =    symbolNumber    -     1  ;", "Util . verify (  ( maxSymbol    <  =     (  . FSE _ MAX _ SYMBOL _ VALUE )  )  ,    input ,     \" Max   symbol   value   too   large    ( too   many   symbols   for   FSE )  \"  )  ;", "input    +  =     ( bitCount    +     7  )     >  >     3  ;", "int   symbolCount    =    maxSymbol    +     1  ;", "int   tableSize    =     1     <  <    tableLog ;", "int   highThreshold    =    tableSize    -     1  ;", "table . log 2 Size    =    tableLog ;", "for    ( byte   symbol    =     0  ;    symbol    <    symbolCount ;    symbol +  +  )     {", "if    (  ( normalizedCounters [ symbol ]  )     =  =     (  -  1  )  )     {", "table . symbol [  ( highThreshold -  -  )  ]     =    symbol ;", "nextSymbol [ symbol ]     =     1  ;", "} else    {", "nextSymbol [ symbol ]     =    normalizedCounters [ symbol ]  ;", "}", "}", "int   tableMask    =    tableSize    -     1  ;", "int   step    =     (  ( tableSize    >  >  >     1  )     +     ( tableSize    >  >  >     3  )  )     +     3  ;", "int   position    =     0  ;", "for    ( byte   symbol    =     0  ;    symbol    <    symbolCount ;    symbol +  +  )     {", "for    ( int   i    =     0  ;    i    <     ( normalizedCounters [ symbol ]  )  ;    i +  +  )     {", "table . symbol [ position ]     =    symbol ;", "do    {", "position    =     ( position    +    step )     &    tableMask ;", "}    while    ( position    >    highThreshold    )  ;", "}", "}", "Util . verify (  ( position    =  =     0  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "for    ( int   i    =     0  ;    i    <    tableSize ;    i +  +  )     {", "byte   symbol    =    table . symbol [ i ]  ;", "short   nextState    =     ( nextSymbol [ symbol ]  )  +  +  ;", "table . numberOfBits [ i ]     =     (  ( byte )     ( tableLog    -     ( Util . highestBit ( nextState )  )  )  )  ;", "table . newState [ i ]     =     (  ( short )     (  ( nextState    <  <     ( table . numberOfBits [ i ]  )  )     -    tableSize )  )  ;", "}", "return    (  ( int )     ( input    -    inputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["readFseTable"], "fileName": "com.facebook.presto.orc.zstd.FseTableReader"}, {"methodBody": ["METHOD_START", "{", "Util . verify (  (  ( inputLimit    -    inputAddress )     >  =     1  0  )  ,    inputAddress ,     \" Input   is   corrupted \"  )  ;", "long   start 1     =    inputAddress    +     (  3     *     ( SIZE _ OF _ SHORT )  )  ;", "long   start 2     =    start 1     +     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    inputAddress )  )     &     6  5  5  3  5  )  ;", "long   start 3     =    start 2     +     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,     ( inputAddress    +     2  )  )  )     &     6  5  5  3  5  )  ;", "long   start 4     =    start 3     +     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,     ( inputAddress    +     4  )  )  )     &     6  5  5  3  5  )  ;", "BitStream . Initializer   initializer    =    new   BitStream . Initializer ( inputBase ,    start 1  ,    start 2  )  ;", "initializer . initialize (  )  ;", "int   stream 1 bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   stream 1 currentAddress    =    initializer . getCurrentAddress (  )  ;", "long   stream 1 bits    =    initializer . getBits (  )  ;", "initializer    =    new   BitStream . Initializer ( inputBase ,    start 2  ,    start 3  )  ;", "initializer . initialize (  )  ;", "int   stream 2 bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   stream 2 currentAddress    =    initializer . getCurrentAddress (  )  ;", "long   stream 2 bits    =    initializer . getBits (  )  ;", "initializer    =    new   BitStream . Initializer ( inputBase ,    start 3  ,    start 4  )  ;", "initializer . initialize (  )  ;", "int   stream 3 bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   stream 3 currentAddress    =    initializer . getCurrentAddress (  )  ;", "long   stream 3 bits    =    initializer . getBits (  )  ;", "initializer    =    new   BitStream . Initializer ( inputBase ,    start 4  ,    inputLimit )  ;", "initializer . initialize (  )  ;", "int   stream 4 bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   stream 4 currentAddress    =    initializer . getCurrentAddress (  )  ;", "long   stream 4 bits    =    initializer . getBits (  )  ;", "int   segmentSize    =     (  ( int )     (  (  ( outputLimit    -    outputAddress )     +     3  )     /     4  )  )  ;", "long   outputStart 2     =    outputAddress    +    segmentSize ;", "long   outputStart 3     =    outputStart 2     +    segmentSize ;", "long   outputStart 4     =    outputStart 3     +    segmentSize ;", "long   output 1     =    outputAddress ;", "long   output 2     =    outputStart 2  ;", "long   output 3     =    outputStart 3  ;", "long   output 4     =    outputStart 4  ;", "long   fastOutputLimit    =    outputLimit    -     7  ;", "int   tableLog    =    this . tableLog ;", "byte [  ]    numbersOfBits    =    this . numbersOfBits ;", "byte [  ]    symbols    =    this . symbols ;", "while    ( output 4     <    fastOutputLimit )     {", "stream 1 bitsConsumed    =     . decodeSymbol ( outputBase ,    output 1  ,    stream 1 bits ,    stream 1 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 2 bitsConsumed    =     . decodeSymbol ( outputBase ,    output 2  ,    stream 2 bits ,    stream 2 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 3 bitsConsumed    =     . decodeSymbol ( outputBase ,    output 3  ,    stream 3 bits ,    stream 3 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 4 bitsConsumed    =     . decodeSymbol ( outputBase ,    output 4  ,    stream 4 bits ,    stream 4 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 1 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 1     +     1  )  ,    stream 1 bits ,    stream 1 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 2 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 2     +     1  )  ,    stream 2 bits ,    stream 2 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 3 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 3     +     1  )  ,    stream 3 bits ,    stream 3 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 4 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 4     +     1  )  ,    stream 4 bits ,    stream 4 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 1 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 1     +     2  )  ,    stream 1 bits ,    stream 1 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 2 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 2     +     2  )  ,    stream 2 bits ,    stream 2 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 3 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 3     +     2  )  ,    stream 3 bits ,    stream 3 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 4 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 4     +     2  )  ,    stream 4 bits ,    stream 4 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 1 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 1     +     3  )  ,    stream 1 bits ,    stream 1 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 2 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 2     +     3  )  ,    stream 2 bits ,    stream 2 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 3 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 3     +     3  )  ,    stream 3 bits ,    stream 3 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "stream 4 bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output 4     +     3  )  ,    stream 4 bits ,    stream 4 bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "output 1     +  =    SIZE _ OF _ INT ;", "output 2     +  =    SIZE _ OF _ INT ;", "output 3     +  =    SIZE _ OF _ INT ;", "output 4     +  =    SIZE _ OF _ INT ;", "BitStream . Loader   loader    =    new   BitStream . Loader ( inputBase ,    start 1  ,    stream 1 currentAddress ,    stream 1 bits ,    stream 1 bitsConsumed )  ;", "boolean   done    =    loader . load (  )  ;", "stream 1 bitsConsumed    =    loader . getBitsConsumed (  )  ;", "stream 1 bits    =    loader . getBits (  )  ;", "stream 1 currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "loader    =    new   BitStream . Loader ( inputBase ,    start 2  ,    stream 2 currentAddress ,    stream 2 bits ,    stream 2 bitsConsumed )  ;", "done    =    loader . load (  )  ;", "stream 2 bitsConsumed    =    loader . getBitsConsumed (  )  ;", "stream 2 bits    =    loader . getBits (  )  ;", "stream 2 currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "loader    =    new   BitStream . Loader ( inputBase ,    start 3  ,    stream 3 currentAddress ,    stream 3 bits ,    stream 3 bitsConsumed )  ;", "done    =    loader . load (  )  ;", "stream 3 bitsConsumed    =    loader . getBitsConsumed (  )  ;", "stream 3 bits    =    loader . getBits (  )  ;", "stream 3 currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "loader    =    new   BitStream . Loader ( inputBase ,    start 4  ,    stream 4 currentAddress ,    stream 4 bits ,    stream 4 bitsConsumed )  ;", "done    =    loader . load (  )  ;", "stream 4 bitsConsumed    =    loader . getBitsConsumed (  )  ;", "stream 4 bits    =    loader . getBits (  )  ;", "stream 4 currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "}", "Util . verify (  (  (  ( output 1     <  =    outputStart 2  )     &  &     ( output 2     <  =    outputStart 3  )  )     &  &     ( output 3     <  =    outputStart 4  )  )  ,    inputAddress ,     \" Input   is   corrupted \"  )  ;", "decodeTail ( inputBase ,    start 1  ,    stream 1 currentAddress ,    stream 1 bitsConsumed ,    stream 1 bits ,    outputBase ,    output 1  ,    outputStart 2  )  ;", "decodeTail ( inputBase ,    start 2  ,    stream 2 currentAddress ,    stream 2 bitsConsumed ,    stream 2 bits ,    outputBase ,    output 2  ,    outputStart 3  )  ;", "decodeTail ( inputBase ,    start 3  ,    stream 3 currentAddress ,    stream 3 bitsConsumed ,    stream 3 bits ,    outputBase ,    output 3  ,    outputStart 4  )  ;", "decodeTail ( inputBase ,    start 4  ,    stream 4 currentAddress ,    stream 4 bitsConsumed ,    stream 4 bits ,    outputBase ,    output 4  ,    outputLimit )  ;", "}", "METHOD_END"], "methodName": ["decode4Streams"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "BitStream . Initializer   initializer    =    new   BitStream . Initializer ( inputBase ,    inputAddress ,    inputLimit )  ;", "initializer . initialize (  )  ;", "long   bits    =    initializer . getBits (  )  ;", "int   bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   currentAddress    =    initializer . getCurrentAddress (  )  ;", "int   tableLog    =    this . tableLog ;", "byte [  ]    numbersOfBits    =    this . numbersOfBits ;", "byte [  ]    symbols    =    this . symbols ;", "long   output    =    outputAddress ;", "long   fastOutputLimit    =    outputLimit    -     4  ;", "while    ( output    <    fastOutputLimit )     {", "BitStream . Loader   loader    =    new   BitStream . Loader ( inputBase ,    inputAddress ,    currentAddress ,    bits ,    bitsConsumed )  ;", "boolean   done    =    loader . load (  )  ;", "bits    =    loader . getBits (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "bitsConsumed    =     . decodeSymbol ( outputBase ,    output ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output    +     1  )  ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output    +     2  )  ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "bitsConsumed    =     . decodeSymbol ( outputBase ,     ( output    +     3  )  ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "output    +  =    SIZE _ OF _ INT ;", "}", "decodeTail ( inputBase ,    inputAddress ,    currentAddress ,    bitsConsumed ,    bits ,    outputBase ,    output ,    outputLimit )  ;", "}", "METHOD_END"], "methodName": ["decodeSingleStream"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "int   value    =     (  ( int )     ( BitStream . peekBitsFast ( bitsConsumed ,    bitContainer ,    tableLog )  )  )  ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    outputAdds ,    symbols [ value ]  )  ;", "return   bitsConsumed    +     ( numbersOfBits [ value ]  )  ;", "}", "METHOD_END"], "methodName": ["decodeSymbol"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "int   tableLog    =    this . tableLog ;", "byte [  ]    numbersOfBits    =    this . numbersOfBits ;", "byte [  ]    symbols    =    this . symbols ;", "while    ( outputAddress    <    outputLimit )     {", "BitStream . Loader   loader    =    new   BitStream . Loader ( inputBase ,    startAddress ,    currentAddress ,    bits ,    bitsConsumed )  ;", "boolean   done    =    loader . load (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "bits    =    loader . getBits (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( done )     {", "break ;", "}", "bitsConsumed    =     . decodeSymbol ( outputBase ,     ( outputAddress +  +  )  ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "}", "while    ( outputAddress    <    outputLimit )     {", "bitsConsumed    =     . decodeSymbol ( outputBase ,     ( outputAddress +  +  )  ,    bits ,    bitsConsumed ,    tableLog ,    numbersOfBits ,    symbols )  ;", "}", "Util . verify ( BitStream . isEndOfStream ( startAddress ,    currentAddress ,    bitsConsumed )  ,    startAddress ,     \" Bit   stream   is   not   fully   consumed \"  )  ;", "}", "METHOD_END"], "methodName": ["decodeTail"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "return    ( tableLog )     !  =     (  -  1  )  ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "Arrays . fill ( ranks ,     0  )  ;", "long   input    =    inputAddress ;", "Util . verify (  ( size    >     0  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   inputSize    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  )     &     2  5  5  ;", "int   outputSize ;", "if    ( inputSize    >  =     1  2  8  )     {", "outputSize    =    inputSize    -     1  2  7  ;", "inputSize    =     ( outputSize    +     1  )     /     2  ;", "Util . verify (  (  ( inputSize    +     1  )     <  =    size )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "Util . verify (  ( outputSize    <  =     (  (  . MAX _ SYMBOL )     +     1  )  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "for    ( int   i    =     0  ;    i    <    outputSize ;    i    +  =     2  )     {", "int   value    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input    +     ( i    /     2  )  )  )  )     &     2  5  5  ;", "weights [ i ]     =     (  ( byte )     ( value    >  >  >     4  )  )  ;", "weights [  ( i    +     1  )  ]     =     (  ( byte )     ( value    &     1  5  )  )  ;", "}", "} else    {", "Util . verify (  (  ( inputSize    +     1  )     <  =    size )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "outputSize    =    finiteStateEntropy . decompress ( inputBase ,    input ,     ( input    +    inputSize )  ,    weights )  ;", "}", "int   totalWeight    =     0  ;", "for    ( int   i    =     0  ;    i    <    outputSize ;    i +  +  )     {", "( ranks [ weights [ i ]  ]  )  +  +  ;", "totalWeight    +  =     (  1     <  <     ( weights [ i ]  )  )     >  >     1  ;", "}", "Util . verify (  ( totalWeight    !  =     0  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "tableLog    =     ( Util . highestBit ( totalWeight )  )     +     1  ;", "Util . verify (  (  ( tableLog )     <  =     (  . MAX _ TABLE _ LOG )  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "int   total    =     1     <  <     ( tableLog )  ;", "int   rest    =    total    -    totalWeight ;", "Util . verify ( Util . isPowerOf 2  ( rest )  ,    input ,     \" Input   is   corrupted \"  )  ;", "int   lastWeight    =     ( Util . highestBit ( rest )  )     +     1  ;", "weights [ outputSize ]     =     (  ( byte )     ( lastWeight )  )  ;", "( ranks [ lastWeight ]  )  +  +  ;", "int   numberOfSymbols    =    outputSize    +     1  ;", "int   nextRankStart    =     0  ;", "for    ( int   i    =     1  ;    i    <     (  ( tableLog )     +     1  )  ;     +  + i )     {", "int   current    =    nextRankStart ;", "nextRankStart    +  =     ( ranks [ i ]  )     <  <     ( i    -     1  )  ;", "ranks [ i ]     =    current ;", "}", "for    ( int   n    =     0  ;    n    <    numberOfSymbols ;    n +  +  )     {", "int   weight    =    weights [ n ]  ;", "int   length    =     (  1     <  <    weight )     >  >     1  ;", "byte   symbol    =     (  ( byte )     ( n )  )  ;", "byte   numberOfBits    =     (  ( byte )     (  (  ( tableLog )     +     1  )     -    weight )  )  ;", "for    ( int   i    =    ranks [ weight ]  ;    i    <     (  ( ranks [ weight ]  )     +    length )  ;    i +  +  )     {", "symbols [ i ]     =    symbol ;", "numbersOfBits [ i ]     =    numberOfBits ;", "}", "ranks [ weight ]     +  =    length ;", "}", "Util . verify (  (  (  ( ranks [  1  ]  )     >  =     2  )     &  &     (  (  ( ranks [  1  ]  )     &     1  )     =  =     0  )  )  ,    input ,     \" Input   is   corrupted \"  )  ;", "return   inputSize    +     1  ;", "}", "METHOD_END"], "methodName": ["readTable"], "fileName": "com.facebook.presto.orc.zstd.Huffman"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( long )     (  . ADDRESS _ ACCESSOR . get ( buffer )  )  )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "com.facebook.presto.orc.zstd.UnsafeUtil"}, {"methodBody": ["METHOD_START", "{", "throw   new   MalformedInputException ( offset ,    reason )  ;", "}", "METHOD_END"], "methodName": ["fail"], "fileName": "com.facebook.presto.orc.zstd.Util"}, {"methodBody": ["METHOD_START", "{", "return    3  1     -     ( Integer . numberOfLeadingZeros ( value )  )  ;", "}", "METHOD_END"], "methodName": ["highestBit"], "fileName": "com.facebook.presto.orc.zstd.Util"}, {"methodBody": ["METHOD_START", "{", "return    ( value    &     ( value    -     1  )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isPowerOf2"], "fileName": "com.facebook.presto.orc.zstd.Util"}, {"methodBody": ["METHOD_START", "{", "return    (  1     <  <    bits )     -     1  ;", "}", "METHOD_END"], "methodName": ["mask"], "fileName": "com.facebook.presto.orc.zstd.Util"}, {"methodBody": ["METHOD_START", "{", "if    (  ! condition )     {", "throw   new   MalformedInputException ( offset ,    reason )  ;", "}", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "com.facebook.presto.orc.zstd.Util"}, {"methodBody": ["METHOD_START", "{", "int   baseAddress    =     ( Unsafe . ARRAY _ BYTE _ BASE _ OFFSET )     +    offset ;", "return   ZstdFrame . getDecompressedSize ( input ,    baseAddress ,     ( baseAddress    +    length )  )  ;", "}", "METHOD_END"], "methodName": ["getDecompressedSize"], "fileName": "com.facebook.presto.orc.zstd.ZstdDecompressor"}, {"methodBody": ["METHOD_START", "{", "switch    ( literalsLengthType )     {", "case    . SET _ RLE    :", "Util . verify (  ( input    <    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "byte   value    =    UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  ;", "Util . verify (  ( value    <  =     (  . MAX _ LITERALS _ LENGTH _ SYMBOL )  )  ,    input ,     \" Value   exceeds   expected   maximum   value \"  )  ;", "FseTableReader . buildRleTable ( literalsLengthTable ,    value )  ;", "currentLiteralsLengthTable    =    literalsLengthTable ;", "break ;", "case    . SET _ BASIC    :", "currentLiteralsLengthTable    =     . DEFAULT _ LITERALS _ LENGTH _ TABLE ;", "break ;", "case    . SET _ REPEAT    :", "Util . verify (  (  ( currentLiteralsLengthTable )     !  =    null )  ,    input ,     \" Expected   match   length   table   to   be   present \"  )  ;", "break ;", "case    . SET _ COMPRESSED    :", "input    +  =    fse . readFseTable ( literalsLengthTable ,    inputBase ,    input ,    inputLimit ,     . MAX _ LITERALS _ LENGTH _ SYMBOL ,     . LITERALS _ LENGTH _ FSE _ LOG )  ;", "currentLiteralsLengthTable    =    literalsLengthTable ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   literals   length   encoding   type \"  )  ;", "}", "return   input ;", "}", "METHOD_END"], "methodName": ["computeLiteralsTable"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "switch    ( matchLengthType )     {", "case    . SET _ RLE    :", "Util . verify (  ( input    <    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "byte   value    =    UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  ;", "Util . verify (  ( value    <  =     (  . MAX _ MATCH _ LENGTH _ SYMBOL )  )  ,    input ,     \" Value   exceeds   expected   maximum   value \"  )  ;", "FseTableReader . buildRleTable ( matchLengthTable ,    value )  ;", "currentMatchLengthTable    =    matchLengthTable ;", "break ;", "case    . SET _ BASIC    :", "currentMatchLengthTable    =     . DEFAULT _ MATCH _ LENGTH _ TABLE ;", "break ;", "case    . SET _ REPEAT    :", "Util . verify (  (  ( currentMatchLengthTable )     !  =    null )  ,    input ,     \" Expected   match   length   table   to   be   present \"  )  ;", "break ;", "case    . SET _ COMPRESSED    :", "input    +  =    fse . readFseTable ( matchLengthTable ,    inputBase ,    input ,    inputLimit ,     . MAX _ MATCH _ LENGTH _ SYMBOL ,     . MATCH _ LENGTH _ FSE _ LOG )  ;", "currentMatchLengthTable    =    matchLengthTable ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   match   length   encoding   type \"  )  ;", "}", "return   input ;", "}", "METHOD_END"], "methodName": ["computeMatchLengthTable"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "switch    ( offsetCodesType )     {", "case    . SET _ RLE    :", "Util . verify (  ( input    <    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "byte   value    =    UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  ;", "Util . verify (  ( value    <  =     (  . MAX _ OFFSET _ CODE _ SYMBOL )  )  ,    input ,     \" Value   exceeds   expected   maximum   value \"  )  ;", "FseTableReader . buildRleTable ( offsetCodesTable ,    value )  ;", "currentOffsetCodesTable    =    offsetCodesTable ;", "break ;", "case    . SET _ BASIC    :", "currentOffsetCodesTable    =     . DEFAULT _ OFFSET _ CODES _ TABLE ;", "break ;", "case    . SET _ REPEAT    :", "Util . verify (  (  ( currentOffsetCodesTable )     !  =    null )  ,    input ,     \" Expected   match   length   table   to   be   present \"  )  ;", "break ;", "case    . SET _ COMPRESSED    :", "input    +  =    fse . readFseTable ( offsetCodesTable ,    inputBase ,    input ,    inputLimit ,     . MAX _ OFFSET _ CODE _ SYMBOL ,     . OFFSET _ CODES _ FSE _ LOG )  ;", "currentOffsetCodesTable    =    offsetCodesTable ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   offset   code   encoding   type \"  )  ;", "}", "return   input ;", "}", "METHOD_END"], "methodName": ["computeOffsetsTable"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   lastLiteralsSize    =    literalsLimit    -    literalsInput ;", "UnsafeUtil . UNSAFE . copyMemory ( literalsBase ,    literalsInput ,    outputBase ,    output ,    lastLiteralsSize )  ;", "output    +  =    lastLiteralsSize ;", "return   output ;", "}", "METHOD_END"], "methodName": ["copyLastLiteral"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   literalInput    =    literalsInput ;", "do    {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getLong ( literalsBase ,    literalInput )  )  ;", "output    +  =     . SIZE _ OF _ LONG ;", "literalInput    +  =     . SIZE _ OF _ LONG ;", "}    while    ( output    <    literalOutputLimit    )  ;", "output    =    literalOutputLimit ;", "return   output ;", "}", "METHOD_END"], "methodName": ["copyLiterals"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "matchAddress    =    copyMatchHead ( outputBase ,    output ,    offset ,    matchAddress )  ;", "output    +  =     . SIZE _ OF _ LONG ;", "copyMatchTail ( outputBase ,    fastOutputLimit ,    output ,    matchOutputLimit ,    matchAddress )  ;", "}", "METHOD_END"], "methodName": ["copyMatch"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "if    ( offset    <     8  )     {", "int   increment 3  2     =     . DEC _  3  2  _ TABLE [ offset ]  ;", "int   decrement 6  4     =     . DEC _  6  4  _ TABLE [ offset ]  ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,    matchAddress )  )  ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     1  )  ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,     ( matchAddress    +     1  )  )  )  ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     2  )  ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,     ( matchAddress    +     2  )  )  )  ;", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output    +     3  )  ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,     ( matchAddress    +     3  )  )  )  ;", "matchAddress    +  =    increment 3  2  ;", "UnsafeUtil . UNSAFE . putInt ( outputBase ,     ( output    +     4  )  ,    UnsafeUtil . UNSAFE . getInt ( outputBase ,    matchAddress )  )  ;", "matchAddress    -  =    decrement 6  4  ;", "} else    {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getLong ( outputBase ,    matchAddress )  )  ;", "matchAddress    +  =     . SIZE _ OF _ LONG ;", "}", "return   matchAddress ;", "}", "METHOD_END"], "methodName": ["copyMatchHead"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "if    ( matchOutputLimit    >    fastOutputLimit )     {", "while    ( output    <    fastOutputLimit )     {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getLong ( outputBase ,    matchAddress )  )  ;", "matchAddress    +  =     . SIZE _ OF _ LONG ;", "output    +  =     . SIZE _ OF _ LONG ;", "}", "while    ( output    <    matchOutputLimit )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,     ( output +  +  )  ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,     ( matchAddress +  +  )  )  )  ;", "}", "} else    {", "while    ( output    <    matchOutputLimit )     {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getLong ( outputBase ,    matchAddress )  )  ;", "matchAddress    +  =     . SIZE _ OF _ LONG ;", "output    +  =     . SIZE _ OF _ LONG ;", "}", "}", "}", "METHOD_END"], "methodName": ["copyMatchTail"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   inputLimit    =    inputAddress    +    blockSize ;", "long   input    =    inputAddress ;", "Util . verify (  ( blockSize    <  =     (  . MAX _ BLOCK _ SIZE )  )  ,    input ,     \" Expected   match   length   table   to   be   present \"  )  ;", "Util . verify (  ( blockSize    >  =     (  . MIN _ BLOCK _ SIZE )  )  ,    input ,     \" Compressed   block   size   too   small \"  )  ;", "int   literalsBlockType    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     3  ;", "switch    ( literalsBlockType )     {", "case    . RAW _ LITERALS _ BLOCK    :", "{", "input    +  =    decodeRawLiterals ( inputBase ,    input ,    inputLimit )  ;", "break ;", "}", "case    . RLE _ LITERALS _ BLOCK    :", "{", "input    +  =    decodeRleLiterals ( inputBase ,    input ,    blockSize )  ;", "break ;", "}", "case    . REPEAT _ STATS _ LITERALS _ BLOCK    :", "Util . verify ( huffman . isLoaded (  )  ,    input ,     \" Dictionary   is   corrupted \"  )  ;", "case    . COMPRESSED _ LITERALS _ BLOCK    :", "{", "input    +  =    decodeCompressedLiterals ( inputBase ,    input ,    blockSize ,    literalsBlockType )  ;", "break ;", "}", "default    :", "throw   Util . fail ( input ,     \" Invalid   literals   block   encoding   type \"  )  ;", "}", "Util . verify (  ( windowSize    <  =     (  . MAX _ WINDOW _ SIZE )  )  ,    input ,     \" Window   size   too   large    ( not   yet   supported )  \"  )  ;", "return   decompressSequences ( inputBase ,    input ,     ( inputAddress    +    blockSize )  ,    outputBase ,    outputAddress ,    outputLimit ,    literalsBase ,    literalsAddress ,    literalsLimit )  ;", "}", "METHOD_END"], "methodName": ["decodeCompressedBlock"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "Util . verify (  ( blockSize    >  =     5  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   compressedSize ;", "int   uncompressedSize ;", "boolean   singleStream    =    false ;", "int   headerSize ;", "int   type    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     >  >     2  )     &     3  ;", "switch    ( type )     {", "case    0     :", "singleStream    =    true ;", "case    1     :", "{", "int   header    =    UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  ;", "headerSize    =     3  ;", "uncompressedSize    =     ( header    >  >  >     4  )     &     ( Util . mask (  1  0  )  )  ;", "compressedSize    =     ( header    >  >  >     1  4  )     &     ( Util . mask (  1  0  )  )  ;", "break ;", "}", "case    2     :", "{", "int   header    =    UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  ;", "headerSize    =     4  ;", "uncompressedSize    =     ( header    >  >  >     4  )     &     ( Util . mask (  1  4  )  )  ;", "compressedSize    =     ( header    >  >  >     1  8  )     &     ( Util . mask (  1  4  )  )  ;", "break ;", "}", "case    3     :", "{", "long   header    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  )     |     (  (  ( UnsafeUtil . UNSAFE . getInt ( inputBase ,     ( input    +     1  )  )  )     &     4  2  9  4  9  6  7  2  9  5 L )     <  <     8  )  ;", "headerSize    =     5  ;", "uncompressedSize    =     (  ( int )     (  ( header    >  >  >     4  )     &     ( Util . mask (  1  8  )  )  )  )  ;", "compressedSize    =     (  ( int )     (  ( header    >  >  >     2  2  )     &     ( Util . mask (  1  8  )  )  )  )  ;", "break ;", "}", "default    :", "throw   Util . fail ( input ,     \" Invalid   literals   header   size   type \"  )  ;", "}", "Util . verify (  ( uncompressedSize    <  =     (  . MAX _ BLOCK _ SIZE )  )  ,    input ,     \" Block   exceeds   maximum   size \"  )  ;", "Util . verify (  (  ( headerSize    +    compressedSize )     <  =    blockSize )  ,    input ,     \" Input   is   corrupted \"  )  ;", "input    +  =    headerSize ;", "long   inputLimit    =    input    +    compressedSize ;", "if    ( literalsBlockType    !  =     (  . REPEAT _ STATS _ LITERALS _ BLOCK )  )     {", "input    +  =    huffman . readTable ( inputBase ,    input ,    compressedSize )  ;", "}", "literalsBase    =    literals ;", "literalsAddress    =    Unsafe . ARRAY _ BYTE _ BASE _ OFFSET ;", "literalsLimit    =     ( Unsafe . ARRAY _ BYTE _ BASE _ OFFSET )     +    uncompressedSize ;", "if    ( singleStream )     {", "huffman . decodeSingleStream ( inputBase ,    input ,    inputLimit ,    literals ,    literalsAddress ,    literalsLimit )  ;", "} else    {", "huffman . decode 4 Streams ( inputBase ,    input ,    inputLimit ,    literals ,    literalsAddress ,    literalsLimit )  ;", "}", "return   headerSize    +    compressedSize ;", "}", "METHOD_END"], "methodName": ["decodeCompressedLiterals"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "Util . verify (  (  ( outputAddress    +    blockSize )     <  =    outputLimit )  ,    inputAddress ,     \" Output   buffer   too   small \"  )  ;", "UnsafeUtil . UNSAFE . copyMemory ( inputBase ,    inputAddress ,    outputBase ,    outputAddress ,    blockSize )  ;", "return   blockSize ;", "}", "METHOD_END"], "methodName": ["decodeRawBlock"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "int   type    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     >  >     2  )     &     3  ;", "int   literalSize ;", "switch    ( type )     {", "case    0     :", "case    2     :", "literalSize    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  )     >  >  >     3  ;", "input +  +  ;", "break ;", "case    1     :", "literalSize    =     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    input )  )     &     6  5  5  3  5  )     >  >  >     4  ;", "input    +  =     2  ;", "break ;", "case    3     :", "int   header    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  )     |     (  (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,     ( input    +     1  )  )  )     &     6  5  5  3  5  )     <  <     8  )  ;", "literalSize    =    header    >  >  >     4  ;", "input    +  =     3  ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   raw   literals   header   encoding   type \"  )  ;", "}", "Util . verify (  (  ( input    +    literalSize )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "if    ( literalSize    >     (  ( inputLimit    -    input )     -     (  . SIZE _ OF _ LONG )  )  )     {", "literalsBase    =    literals ;", "literalsAddress    =    Unsafe . ARRAY _ BYTE _ BASE _ OFFSET ;", "literalsLimit    =     ( Unsafe . ARRAY _ BYTE _ BASE _ OFFSET )     +    literalSize ;", "UnsafeUtil . UNSAFE . copyMemory ( inputBase ,    input ,    literals ,    literalsAddress ,    literalSize )  ;", "Arrays . fill ( literals ,    literalSize ,     ( literalSize    +     (  . SIZE _ OF _ LONG )  )  ,     (  ( byte )     (  0  )  )  )  ;", "} else    {", "literalsBase    =    inputBase ;", "literalsAddress    =    input ;", "literalsLimit    =     ( literalsAddress )     +    literalSize ;", "}", "input    +  =    literalSize ;", "return    (  ( int )     ( input    -    inputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["decodeRawLiterals"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "Util . verify (  (  ( outputAddress    +    size )     <  =    outputLimit )  ,    inputAddress ,     \" Output   buffer   too   small \"  )  ;", "long   output    =    outputAddress ;", "long   value    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    inputAddress )  )     &     2  5  5 L ;", "int   remaining    =    size ;", "if    ( remaining    >  =     (  . SIZE _ OF _ LONG )  )     {", "long   packed    =     (  (  (  (  (  ( value    |     ( value    <  <     8  )  )     |     ( value    <  <     1  6  )  )     |     ( value    <  <     2  4  )  )     |     ( value    <  <     3  2  )  )     |     ( value    <  <     4  0  )  )     |     ( value    <  <     4  8  )  )     |     ( value    <  <     5  6  )  ;", "do    {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    packed )  ;", "output    +  =     . SIZE _ OF _ LONG ;", "remaining    -  =     . SIZE _ OF _ LONG ;", "}    while    ( remaining    >  =     (  . SIZE _ OF _ LONG )     )  ;", "}", "for    ( int   i    =     0  ;    i    <    remaining ;    i +  +  )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    output ,     (  ( byte )     ( value )  )  )  ;", "output +  +  ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["decodeRleBlock"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "int   outputSize ;", "int   type    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     >  >     2  )     &     3  ;", "switch    ( type )     {", "case    0     :", "case    2     :", "outputSize    =     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  )     >  >  >     3  ;", "input +  +  ;", "break ;", "case    1     :", "outputSize    =     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    input )  )     &     6  5  5  3  5  )     >  >  >     4  ;", "input    +  =     2  ;", "break ;", "case    3     :", "Util . verify (  ( blockSize    >  =     (  . SIZE _ OF _ INT )  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "outputSize    =     (  ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     &     1  6  7  7  7  2  1  5  )     >  >  >     4  ;", "input    +  =     3  ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   RLE   literals   header   encoding   type \"  )  ;", "}", "Util . verify (  ( outputSize    <  =     (  . MAX _ BLOCK _ SIZE )  )  ,    input ,     \" Output   exceeds   maximum   block   size \"  )  ;", "byte   value    =    UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  ;", "Arrays . fill ( literals ,     0  ,     ( outputSize    +     (  . SIZE _ OF _ LONG )  )  ,    value )  ;", "literalsBase    =    literals ;", "literalsAddress    =    Unsafe . ARRAY _ BYTE _ BASE _ OFFSET ;", "literalsLimit    =     ( Unsafe . ARRAY _ BYTE _ BASE _ OFFSET )     +    outputSize ;", "return    (  ( int )     ( input    -    inputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["decodeRleLiterals"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "if    ( outputAddress    =  =    outputLimit )     {", "return    0  ;", "}", "reset (  )  ;", "long   input    =    inputAddress ;", "long   output    =    outputAddress ;", "input    +  =     . verifyMagic ( inputBase ,    inputAddress ,    inputLimit )  ;", "FrameHeader   frameHeader    =     . readFrameHeader ( inputBase ,    input ,    inputLimit )  ;", "input    +  =    frameHeader . headerSize ;", "boolean   lastBlock ;", "do    {", "Util . verify (  (  ( input    +     (  . SIZE _ OF _ BLOCK _ HEADER )  )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   header    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     &     1  6  7  7  7  2  1  5  ;", "input    +  =     . SIZE _ OF _ BLOCK _ HEADER ;", "lastBlock    =     ( header    &     1  )     !  =     0  ;", "int   blockType    =     ( header    >  >  >     1  )     &     3  ;", "int   blockSize    =     ( header    >  >  >     3  )     &     2  0  9  7  1  5  1  ;", "int   decodedSize ;", "switch    ( blockType )     {", "case    . RAW _ BLOCK    :", "Util . verify (  (  ( inputAddress    +    blockSize )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "decodedSize    =     . decodeRawBlock ( inputBase ,    input ,    blockSize ,    outputBase ,    output ,    outputLimit )  ;", "input    +  =    blockSize ;", "break ;", "case    . RLE _ BLOCK    :", "Util . verify (  (  ( inputAddress    +     1  )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "decodedSize    =     . decodeRleBlock ( blockSize ,    inputBase ,    input ,    outputBase ,    output ,    outputLimit )  ;", "input    +  =     1  ;", "break ;", "case    . COMPRESSED _ BLOCK    :", "Util . verify (  (  ( inputAddress    +    blockSize )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "decodedSize    =    decodeCompressedBlock ( inputBase ,    input ,    blockSize ,    outputBase ,    output ,    outputLimit ,    frameHeader . windowSize )  ;", "input    +  =    blockSize ;", "break ;", "default    :", "throw   Util . fail ( input ,     \" Invalid   block   type \"  )  ;", "}", "output    +  =    decodedSize ;", "}    while    (  ! lastBlock    )  ;", "if    ( frameHeader . hasChecksum )     {", "Slice   outputSlice    =    UnsafeSliceFactory . getInstance (  )  . newSlice ( outputBase ,    outputAddress ,     (  ( int )     ( outputLimit    -    outputAddress )  )  )  ;", "long   hash    =    XxHash 6  4  . hash (  0  ,    outputSlice )  ;", "int   checksum    =    UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  ;", "if    ( checksum    !  =     (  ( int )     ( hash )  )  )     {", "throw   new   MalformedInputException ( input ,    String . format (  \" Bad   checksum .    Expected :     % s ,    actual :     % s \"  ,    Integer . toHexString ( checksum )  ,    Integer . toHexString (  (  ( int )     ( hash )  )  )  )  )  ;", "}", "}", "return    (  ( int )     ( output    -    outputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["decompress"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "final   long   fastOutputLimit    =    outputLimit    -     ( ZstdFrameDecompressor . SIZE _ OF _ LONG )  ;", "long   input    =    inputAddress ;", "long   output    =    outputAddress ;", "long   literalsInput    =    literalsAddress ;", "int   size    =     (  ( int )     ( inputLimit    -    inputAddress )  )  ;", "Util . verify (  ( size    >  =     ( ZstdFrameDecompressor . MIN _ SEQUENCES _ SIZE )  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   sequenceCount    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  )     &     2  5  5  ;", "if    ( sequenceCount    !  =     0  )     {", "if    ( sequenceCount    =  =     2  5  5  )     {", "Util . verify (  (  ( input    +     ( ZstdFrameDecompressor . SIZE _ OF _ SHORT )  )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "sequenceCount    =     (  ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    input )  )     &     6  5  5  3  5  )     +     ( ZstdFrameDecompressor . LONG _ NUMBER _ OF _ SEQUENCES )  ;", "input    +  =    ZstdFrameDecompressor . SIZE _ OF _ SHORT ;", "} else", "if    ( sequenceCount    >     1  2  7  )     {", "Util . verify (  ( input    <    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "sequenceCount    =     (  ( sequenceCount    -     1  2  8  )     <  <     8  )     +     (  ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  )     &     2  5  5  )  ;", "}", "Util . verify (  (  ( input    +     ( ZstdFrameDecompressor . SIZE _ OF _ INT )  )     <  =    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "byte   type    =    UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  ;", "int   literalsLengthType    =     ( type    &     2  5  5  )     >  >  >     6  ;", "int   offsetCodesType    =     ( type    >  >  >     4  )     &     3  ;", "int   matchLengthType    =     ( type    >  >  >     2  )     &     3  ;", "input    =    computeLiteralsTable ( literalsLengthType ,    inputBase ,    input ,    inputLimit )  ;", "input    =    computeOffsetsTable ( offsetCodesType ,    inputBase ,    input ,    inputLimit )  ;", "input    =    computeMatchLengthTable ( matchLengthType ,    inputBase ,    input ,    inputLimit )  ;", "BitStream . Initializer   initializer    =    new   BitStream . Initializer ( inputBase ,    input ,    inputLimit )  ;", "initializer . initialize (  )  ;", "int   bitsConsumed    =    initializer . getBitsConsumed (  )  ;", "long   bits    =    initializer . getBits (  )  ;", "long   currentAddress    =    initializer . getCurrentAddress (  )  ;", "FiniteStateEntropy . Table   currentLiteralsLengthTable    =    this . currentLiteralsLengthTable ;", "FiniteStateEntropy . Table   currentOffsetCodesTable    =    this . currentOffsetCodesTable ;", "FiniteStateEntropy . Table   currentMatchLengthTable    =    this . currentMatchLengthTable ;", "int   literalsLengthState    =     (  ( int )     ( BitStream . peekBits ( bitsConsumed ,    bits ,    currentLiteralsLengthTable . log 2 Size )  )  )  ;", "bitsConsumed    +  =    currentLiteralsLengthTable . log 2 Size ;", "int   offsetCodesState    =     (  ( int )     ( BitStream . peekBits ( bitsConsumed ,    bits ,    currentOffsetCodesTable . log 2 Size )  )  )  ;", "bitsConsumed    +  =    currentOffsetCodesTable . log 2 Size ;", "int   matchLengthState    =     (  ( int )     ( BitStream . peekBits ( bitsConsumed ,    bits ,    currentMatchLengthTable . log 2 Size )  )  )  ;", "bitsConsumed    +  =    currentMatchLengthTable . log 2 Size ;", "int [  ]    previousOffsets    =    this . previousOffsets ;", "byte [  ]    literalsLengthNumbersOfBits    =    currentLiteralsLengthTable . numberOfBits ;", "int [  ]    literalsLengthNewStates    =    currentLiteralsLengthTable . newState ;", "byte [  ]    literalsLengthSymbols    =    currentLiteralsLengthTable . symbol ;", "byte [  ]    matchLengthNumbersOfBits    =    currentMatchLengthTable . numberOfBits ;", "int [  ]    matchLengthNewStates    =    currentMatchLengthTable . newState ;", "byte [  ]    matchLengthSymbols    =    currentMatchLengthTable . symbol ;", "byte [  ]    offsetCodesNumbersOfBits    =    currentOffsetCodesTable . numberOfBits ;", "int [  ]    offsetCodesNewStates    =    currentOffsetCodesTable . newState ;", "byte [  ]    offsetCodesSymbols    =    currentOffsetCodesTable . symbol ;", "while    ( sequenceCount    >     0  )     {", "sequenceCount -  -  ;", "BitStream . Loader   loader    =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader . load (  )  ;", "bitsConsumed    =    loader . getBitsConsumed (  )  ;", "bits    =    loader . getBits (  )  ;", "currentAddress    =    loader . getCurrentAddress (  )  ;", "if    ( loader . isOverflow (  )  )     {", "Util . verify (  ( sequenceCount    =  =     0  )  ,    input ,     \" Not   all   sequences   were   consumed \"  )  ;", "break ;", "}", "int   literalsLengthCode    =    literalsLengthSymbols [ literalsLengthState ]  ;", "int   matchLengthCode    =    matchLengthSymbols [ matchLengthState ]  ;", "int   offsetCode    =    offsetCodesSymbols [ offsetCodesState ]  ;", "int   literalsLengthBits    =    ZstdFrameDecompressor . LITERALS _ LENGTH _ BITS [ literalsLengthCode ]  ;", "int   matchLengthBits    =    ZstdFrameDecompressor . MATCH _ LENGTH _ BITS [ matchLengthCode ]  ;", "int   offsetBits    =    offsetCode ;", "int   offset    =    ZstdFrameDecompressor . OFFSET _ CODES _ BASE [ offsetCode ]  ;", "if    ( offsetCode    >     0  )     {", "offset    +  =    BitStream . peekBits ( bitsConsumed ,    bits ,    offsetBits )  ;", "bitsConsumed    +  =    offsetBits ;", "}", "if    ( offsetCode    <  =     1  )     {", "if    ( literalsLengthCode    =  =     0  )     {", "offset +  +  ;", "}", "if    ( offset    !  =     0  )     {", "int   temp ;", "if    ( offset    =  =     3  )     {", "temp    =     ( previousOffsets [  0  ]  )     -     1  ;", "} else    {", "temp    =    previousOffsets [ offset ]  ;", "}", "if    ( temp    =  =     0  )     {", "temp    =     1  ;", "}", "if    ( offset    !  =     1  )     {", "previousOffsets [  2  ]     =    previousOffsets [  1  ]  ;", "}", "previousOffsets [  1  ]     =    previousOffsets [  0  ]  ;", "previousOffsets [  0  ]     =    temp ;", "offset    =    temp ;", "} else    {", "offset    =    previousOffsets [  0  ]  ;", "}", "} else    {", "previousOffsets [  2  ]     =    previousOffsets [  1  ]  ;", "previousOffsets [  1  ]     =    previousOffsets [  0  ]  ;", "previousOffsets [  0  ]     =    offset ;", "}", "int   matchLength    =    ZstdFrameDecompressor . MATCH _ LENGTH _ BASE [ matchLengthCode ]  ;", "if    ( matchLengthCode    >     3  1  )     {", "matchLength    +  =    BitStream . peekBits ( bitsConsumed ,    bits ,    matchLengthBits )  ;", "bitsConsumed    +  =    matchLengthBits ;", "}", "int   literalsLength    =    ZstdFrameDecompressor . LITERALS _ LENGTH _ BASE [ literalsLengthCode ]  ;", "if    ( literalsLengthCode    >     1  5  )     {", "literalsLength    +  =    BitStream . peekBits ( bitsConsumed ,    bits ,    literalsLengthBits )  ;", "bitsConsumed    +  =    literalsLengthBits ;", "}", "int   totalBits    =     ( literalsLengthBits    +    matchLengthBits )     +    offsetBits ;", "if    ( totalBits    >     (  (  6  4     -     7  )     -     (  (  ( ZstdFrameDecompressor . LITERALS _ LENGTH _ FSE _ LOG )     +     ( ZstdFrameDecompressor . MATCH _ LENGTH _ FSE _ LOG )  )     +     ( ZstdFrameDecompressor . OFFSET _ CODES _ FSE _ LOG )  )  )  )     {", "BitStream . Loader   loader 1     =    new   BitStream . Loader ( inputBase ,    input ,    currentAddress ,    bits ,    bitsConsumed )  ;", "loader 1  . load (  )  ;", "bitsConsumed    =    loader 1  . getBitsConsumed (  )  ;", "bits    =    loader 1  . getBits (  )  ;", "currentAddress    =    loader 1  . getCurrentAddress (  )  ;", "}", "int   numberOfBits ;", "numberOfBits    =    literalsLengthNumbersOfBits [ literalsLengthState ]  ;", "literalsLengthState    =     (  ( int )     (  ( literalsLengthNewStates [ literalsLengthState ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "numberOfBits    =    matchLengthNumbersOfBits [ matchLengthState ]  ;", "matchLengthState    =     (  ( int )     (  ( matchLengthNewStates [ matchLengthState ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "numberOfBits    =    offsetCodesNumbersOfBits [ offsetCodesState ]  ;", "offsetCodesState    =     (  ( int )     (  ( offsetCodesNewStates [ offsetCodesState ]  )     +     ( BitStream . peekBits ( bitsConsumed ,    bits ,    numberOfBits )  )  )  )  ;", "bitsConsumed    +  =    numberOfBits ;", "final   long   literalOutputLimit    =    output    +    literalsLength ;", "final   long   matchOutputLimit    =    literalOutputLimit    +    matchLength ;", "Util . verify (  ( matchOutputLimit    <  =    outputLimit )  ,    input ,     \" Output   buffer   too   small \"  )  ;", "Util . verify (  (  ( literalsInput    +    literalsLength )     <  =    literalsLimit )  ,    input ,     \" Input   is   corrupted \"  )  ;", "long   matchAddress    =    literalOutputLimit    -    offset ;", "if    ( literalOutputLimit    >    fastOutputLimit )     {", "executeLastSequence ( outputBase ,    output ,    literalOutputLimit ,    matchOutputLimit ,    fastOutputLimit ,    literalsInput ,    matchAddress )  ;", "} else    {", "output    =    copyLiterals ( outputBase ,    literalsBase ,    output ,    literalsInput ,    literalOutputLimit )  ;", "copyMatch ( outputBase ,    fastOutputLimit ,    output ,    offset ,    matchOutputLimit ,    matchAddress )  ;", "}", "output    =    matchOutputLimit ;", "literalsInput    +  =    literalsLength ;", "}", "}", "output    =    copyLastLiteral ( outputBase ,    literalsBase ,    literalsLimit ,    output ,    literalsInput )  ;", "return    (  ( int )     ( output    -    outputAddress )  )  ;", "}", "METHOD_END"], "methodName": ["decompressSequences"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "if    ( output    <    fastOutputLimit )     {", "do    {", "UnsafeUtil . UNSAFE . putLong ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getLong ( literalsBase ,    literalInput )  )  ;", "output    +  =     . SIZE _ OF _ LONG ;", "literalInput    +  =     . SIZE _ OF _ LONG ;", "}    while    ( output    <    fastOutputLimit    )  ;", "literalInput    -  =    output    -    fastOutputLimit ;", "output    =    fastOutputLimit ;", "}", "while    ( output    <    literalOutputLimit )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getByte ( literalsBase ,    literalInput )  )  ;", "output +  +  ;", "literalInput +  +  ;", "}", "while    ( output    <    matchOutputLimit )     {", "UnsafeUtil . UNSAFE . putByte ( outputBase ,    output ,    UnsafeUtil . UNSAFE . getByte ( outputBase ,    matchAddress )  )  ;", "output +  +  ;", "matchAddress +  +  ;", "}", "}", "METHOD_END"], "methodName": ["executeLastSequence"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "input    +  =     . verifyMagic ( inputBase ,    input ,    inputLimit )  ;", "return    . readFrameHeader ( inputBase ,    input ,    inputLimit )  . contentSize ;", "}", "METHOD_END"], "methodName": ["getDecompressedSize"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "long   input    =    inputAddress ;", "Util . verify (  ( input    <    inputLimit )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   frameHeaderDescriptor    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  )     &     2  5  5  ;", "boolean   singleSegment    =     ( frameHeaderDescriptor    &     3  2  )     !  =     0  ;", "int   dictionaryDescriptor    =    frameHeaderDescriptor    &     3  ;", "int   contentSizeDescriptor    =    frameHeaderDescriptor    >  >  >     6  ;", "int   headerSize    =     (  (  1     +     ( singleSegment    ?     0     :     1  )  )     +     ( dictionaryDescriptor    =  =     0     ?     0     :     1     <  <     ( dictionaryDescriptor    -     1  )  )  )     +     ( contentSizeDescriptor    =  =     0     ?    singleSegment    ?     1     :     0     :     1     <  <    contentSizeDescriptor )  ;", "Util . verify (  ( headerSize    <  =     ( inputLimit    -    inputAddress )  )  ,    input ,     \" Not   enough   input   bytes \"  )  ;", "int   windowSize    =     -  1  ;", "if    (  ! singleSegment )     {", "int   windowDescriptor    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,     ( input +  +  )  )  )     &     2  5  5  ;", "int   exponent    =    windowDescriptor    >  >  >     3  ;", "int   mantissa    =    windowDescriptor    &     7  ;", "int   base    =     1     <  <     (  (  . MIN _ WINDOW _ LOG )     +    exponent )  ;", "windowSize    =    base    +     (  ( base    /     8  )     *    mantissa )  ;", "}", "long   dictionaryId    =     -  1  ;", "switch    ( dictionaryDescriptor )     {", "case    1     :", "dictionaryId    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  ;", "input    +  =     . SIZE _ OF _ BYTE ;", "break ;", "case    2     :", "dictionaryId    =     ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    input )  )     &     6  5  5  3  5  ;", "input    +  =     . SIZE _ OF _ SHORT ;", "break ;", "case    3     :", "dictionaryId    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "input    +  =     . SIZE _ OF _ INT ;", "break ;", "}", "Util . verify (  ( dictionaryId    =  =     (  -  1  )  )  ,    input ,     \" Custom   dictionaries   not   supported \"  )  ;", "long   contentSize    =     -  1  ;", "switch    ( contentSizeDescriptor )     {", "case    0     :", "if    ( singleSegment )     {", "contentSize    =     ( UnsafeUtil . UNSAFE . getByte ( inputBase ,    input )  )     &     2  5  5  ;", "input    +  =     . SIZE _ OF _ BYTE ;", "}", "break ;", "case    1     :", "contentSize    =     ( UnsafeUtil . UNSAFE . getShort ( inputBase ,    input )  )     &     6  5  5  3  5  ;", "contentSize    +  =     2  5  6  ;", "input    +  =     . SIZE _ OF _ SHORT ;", "break ;", "case    2     :", "contentSize    =     ( UnsafeUtil . UNSAFE . getInt ( inputBase ,    input )  )     &     4  2  9  4  9  6  7  2  9  5 L ;", "input    +  =     . SIZE _ OF _ INT ;", "break ;", "case    3     :", "contentSize    =    UnsafeUtil . UNSAFE . getLong ( inputBase ,    input )  ;", "input    +  =     . SIZE _ OF _ LONG ;", "break ;", "}", "boolean   hasChecksum    =     ( frameHeaderDescriptor    &     4  )     !  =     0  ;", "return   new   FrameHeader (  ( input    -    inputAddress )  ,    windowSize ,    contentSize ,    dictionaryId ,    hasChecksum )  ;", "}", "METHOD_END"], "methodName": ["readFrameHeader"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "previousOffsets [  0  ]     =     1  ;", "previousOffsets [  1  ]     =     4  ;", "previousOffsets [  2  ]     =     8  ;", "currentLiteralsLengthTable    =    null ;", "currentOffsetCodesTable    =    null ;", "currentMatchLengthTable    =    null ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}, {"methodBody": ["METHOD_START", "{", "Util . verify (  (  ( inputLimit    -    inputAddress )     >  =     4  )  ,    inputAddress ,     \" Not   enough   input   bytes \"  )  ;", "int   magic    =    UnsafeUtil . UNSAFE . getInt ( inputBase ,    inputAddress )  ;", "if    ( magic    !  =     (  . MAGIC _ NUMBER )  )     {", "throw   new   MalformedInputException ( inputAddress ,     (  \" Invalid   magic   prefix :     \"     +     ( Integer . toHexString ( magic )  )  )  )  ;", "}", "return    . SIZE _ OF _ INT ;", "}", "METHOD_END"], "methodName": ["verifyMagic"], "fileName": "com.facebook.presto.orc.zstd.ZstdFrameDecompressor"}]