[{"methodBody": ["METHOD_START", "{", "return    ( this )     =  =     ( EnvironmentModificationResult . SUCCESS )  ;", "}", "METHOD_END"], "methodName": ["isSuccess"], "fileName": "org.gradle.internal.nativeintegration.EnvironmentModificationResult"}, {"methodBody": ["METHOD_START", "{", "try    {", "Map < String ,    String >    theUnmodifiabl    =    System . getenv (  )  ;", "Class <  ?  >    cu    =    theUnmodifiabl . getClass (  )  ;", "Field   m    =    cu . getDeclaredField (  \" m \"  )  ;", "m . setAccessible ( true )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    result    =     (  ( Map < String ,    String >  )     ( m . get ( theUnmodifiabl )  )  )  ;", "return   result ;", "}    catch    ( Exception   e )     {", "throw   new   NativeIntegrationException (  \" Unable   to   get   mutable   environment   map \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getEnv"], "fileName": "org.gradle.internal.nativeintegration.ReflectiveEnvironment"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    sc    =    Class . forName (  \" ProcessEnvironment \"  )  ;", "Field   caseinsensitive    =    sc . getDeclaredField (  \" theCaseInsensi \"  )  ;", "caseinsensitive . setAccessible ( true )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    String >    result    =     (  ( Map < String ,    String >  )     ( caseinsensitive . get ( null )  )  )  ;", "return   result ;", "}    catch    ( Exception   e )     {", "throw   new   NativeIntegrationException (  \" Unable   to   get   mutable   windows   case   insensitive   environment   map \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getWindowsEnv"], "fileName": "org.gradle.internal.nativeintegration.ReflectiveEnvironment"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    getEnv (  )  ;", "map . put ( name ,    value )  ;", "if    ( OpengSystem . current (  )  . isWindows (  )  )     {", "Map < String ,    String >    env 2     =    getWindowsEnv (  )  ;", "env 2  . put ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setenv"], "fileName": "org.gradle.internal.nativeintegration.ReflectiveEnvironment"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    getEnv (  )  ;", "map . remove ( name )  ;", "if    ( OpengSystem . current (  )  . isWindows (  )  )     {", "Map < String ,    String >    env 2     =    getWindowsEnv (  )  ;", "env 2  . remove ( name )  ;", "}", "}", "METHOD_END"], "methodName": ["unsetenv"], "fileName": "org.gradle.internal.nativeintegration.ReflectiveEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   DefaultFileMetadata . DIR ;", "}", "METHOD_END"], "methodName": ["directory"], "fileName": "org.gradle.internal.nativeintegration.filesystem.DefaultFileMetadata"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileMetadata ( FileType . RegularFile ,    lastModified ,    length )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.internal.nativeintegration.filesystem.DefaultFileMetadata"}, {"methodBody": ["METHOD_START", "{", "return   DefaultFileMetadata . MISSING ;", "}", "METHOD_END"], "methodName": ["missing"], "fileName": "org.gradle.internal.nativeintegration.filesystem.DefaultFileMetadata"}, {"methodBody": ["METHOD_START", "{", "return   FileMetadataAccessorBenchmark . ACCESSORS . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "accessor    =    getAccessor ( accessorClassName )  ;", "missing    =    new   File ( UUID . randomUUID (  )  . toString (  )  )  ;", "missingPath    =    missing . toPath (  )  ;", "directory    =    File . createTempFile (  \" jmh \"  ,     \" dir \"  )  ;", "directoryPath    =    directory . toPath (  )  ;", "directory . mkdirs (  )  ;", "realFile    =    File . createTempFile (  \" jmh \"  ,     \" tmp \"  )  ;", "realFilePath    =    realFile . toPath (  )  ;", "FileOutputStream   fos    =    new   FileOutputStream ( realFile )  ;", "fos . write ( new   byte [  1  0  2  4  ]  )  ;", "fos . close (  )  ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "bh . consume ( getAccessor ( accessorClassName )  . stat ( directoryPath )  )  ;", "}", "METHOD_END"], "methodName": ["stat_directory"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "bh . consume ( getAccessor ( accessorClassName )  . stat ( realFilePath )  )  ;", "}", "METHOD_END"], "methodName": ["stat_existing"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "bh . consume ( getAccessor ( accessorClassName )  . stat ( missingPath )  )  ;", "}", "METHOD_END"], "methodName": ["stat_missing_file"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "directory . delete (  )  ;", "real . delete (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark"}, {"methodBody": ["METHOD_START", "{", "Path   sourceFile    =    null ;", "Path   linkFile    =    null ;", "try    {", "sourceFile    =    Files . createTempFile (  \" symlink \"  ,     \" test \"  )  ;", "linkFile    =    Files . createTempFile (  \" symlink \"  ,     \" test _ link \"  )  ;", "Files . delete ( linkFile )  ;", "Files . createSymbolicLink ( linkFile ,    sourceFile )  ;", "return   true ;", "}    catch    ( InternalError   e )     {", "if    ( e . getMessage (  )  . contains (  \" Should   not   get   here \"  )  )     {", ". LOGGER . debug (  \" Unable   to   create   a   symlink .    Your   system   is   hitting   JDK   bug   id   JDK -  8  0  4  6  6  8  6  .    Symlink   support   disabled .  \"  ,    e )  ;", "} else    {", ". LOGGER . debug (  \" Unexpected   internal   error \"  ,    e )  ;", "}", "return   false ;", "}    catch    ( IOException   e )     {", "return   false ;", "}    catch    ( UnsupportedOperationException   e )     {", "return   false ;", "}    finally    {", "try    {", "if    (  ( sourceFile    !  =    null )     &  &     ( sourceFile . toFile (  )  . exists (  )  )  )     {", "Files . delete ( sourceFile )  ;", "}", "if    (  ( linkFile    !  =    null )     &  &     ( linkFile . toFile (  )  . exists (  )  )  )     {", "Files . delete ( linkFile )  ;", "}", "}    catch    ( IOException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["doesSystemSupportSymlinks"], "fileName": "org.gradle.internal.nativeintegration.filesystem.jdk7.Jdk7Symlink"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "if    ( permissions . contains (  . OWNER _ READ )  )     {", "result    =    result    |     2  5  6  ;", "}", "if    ( permissions . contains (  . OWNER _ WRITE )  )     {", "result    =    result    |     1  2  8  ;", "}", "if    ( permissions . contains (  . OWNER _ EXECUTE )  )     {", "result    =    result    |     6  4  ;", "}", "if    ( permissions . contains (  . GROUP _ READ )  )     {", "result    =    result    |     3  2  ;", "}", "if    ( permissions . contains (  . GROUP _ WRITE )  )     {", "result    =    result    |     1  6  ;", "}", "if    ( permissions . contains (  . GROUP _ EXECUTE )  )     {", "result    =    result    |     8  ;", "}", "if    ( permissions . contains (  . OTHERS _ READ )  )     {", "result    =    result    |     4  ;", "}", "if    ( permissions . contains (  . OTHERS _ WRITE )  )     {", "result    =    result    |     2  ;", "}", "if    ( permissions . contains (  . OTHERS _ EXECUTE )  )     {", "result    =    result    |     1  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertToInt"], "fileName": "org.gradle.internal.nativeintegration.filesystem.jdk7.PosixFilePermissionConverter"}, {"methodBody": ["METHOD_START", "{", "Set < PosixFilePermission >    result    =    EnumSet . noneOf ( PosixFilePermission . class )  ;", "if    (  . isSet ( mode ,     2  5  6  )  )     {", "result . add ( PosixFilePermission . OWNER _ READ )  ;", "}", "if    (  . isSet ( mode ,     1  2  8  )  )     {", "result . add ( PosixFilePermission . OWNER _ WRITE )  ;", "}", "if    (  . isSet ( mode ,     6  4  )  )     {", "result . add ( PosixFilePermission . OWNER _ EXECUTE )  ;", "}", "if    (  . isSet ( mode ,     3  2  )  )     {", "result . add ( PosixFilePermission . GROUP _ READ )  ;", "}", "if    (  . isSet ( mode ,     1  6  )  )     {", "result . add ( PosixFilePermission . GROUP _ WRITE )  ;", "}", "if    (  . isSet ( mode ,     8  )  )     {", "result . add ( PosixFilePermission . GROUP _ EXECUTE )  ;", "}", "if    (  . isSet ( mode ,     4  )  )     {", "result . add ( PosixFilePermission . OTHERS _ READ )  ;", "}", "if    (  . isSet ( mode ,     2  )  )     {", "result . add ( PosixFilePermission . OTHERS _ WRITE )  ;", "}", "if    (  . isSet ( mode ,     1  )  )     {", "result . add ( PosixFilePermission . OTHERS _ EXECUTE )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["convertToPermissionsSet"], "fileName": "org.gradle.internal.nativeintegration.filesystem.jdk7.PosixFilePermissionConverter"}, {"methodBody": ["METHOD_START", "{", "return    ( mode    &    testbit )     =  =    testbit ;", "}", "METHOD_END"], "methodName": ["isSet"], "fileName": "org.gradle.internal.nativeintegration.filesystem.jdk7.PosixFilePermissionConverter"}, {"methodBody": ["METHOD_START", "{", "return   JavaReflectionUtil . newInstanceOrFallback (  \" Jdk 7 FileCanonicalizer \"  ,    FileSystemServices . class . getClassLoader (  )  ,    FallbackFileCanonicalizer . class )  ;", "}", "METHOD_END"], "methodName": ["createFileCanonicalizer"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.FileSystemServices"}, {"methodBody": ["METHOD_START", "{", "if    ( operatingSystem . isWindows (  )  )     {", "Symlink   symlink    =    JavaReflectionUtil . newInstanceOrFallback (  \" jdk 7  . WindowsJdk 7 Symlink \"  ,    FileSystemServices . class . getClassLoader (  )  ,    WindowsSymlink . class )  ;", "return   new   GenericFileSystem ( new   EmptyChmod (  )  ,    new   FallbackStat (  )  ,    symlink ,    metadataAccessor )  ;", "}", "if    ( posixFiles   instanceof   UnavailablePosixFiles )     {", "FileSystemServices . LOGGER . debug (  \" Native - platform   file   system   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "} else    {", "Symlink   symlink    =    new   NativePlatformBackedSymlink ( posixFiles )  ;", "FileModeMutator   chmod    =    new   NativePlatformBackedChmod ( posixFiles )  ;", "FileModeAccessor   stat    =    new   NativePlatformBackedStat ( posixFiles )  ;", "return   new   GenericFileSystem ( chmod ,    stat ,    symlink ,    metadataAccessor )  ;", "}", "Symlink   symlink    =    JavaReflectionUtil . newInstanceOrFallback (  \" jdk 7  . Jdk 7 Symlink \"  ,    FileSystemServices . class . getClassLoader (  )  ,    UnsupportedSymlink . class )  ;", "FileSystemServices . LOGGER . debug (  \" Using    {  }    implementation   as   symlink .  \"  ,    symlink . getClass (  )  . getSimpleName (  )  )  ;", "Object   handler    =    JavaReflectionUtil . newInstanceOrFallback (  \" jdk 7  . PosixJdk 7 FilePermissionHandler \"  ,    FileSystemServices . class . getClassLoader (  )  ,    UnsupportedFilePermissions . class )  ;", "return   new   GenericFileSystem (  (  ( FileModeMutator )     ( handler )  )  ,     (  ( FileModeAccessor )     ( handler )  )  ,    symlink ,    metadataAccessor )  ;", "}", "METHOD_END"], "methodName": ["createFileSystem"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.FileSystemServices"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    new   File ( System . getProperty (  \" tmpdir \"  )  )  ;", "if    (  !  ( dir . exists (  )  )  )     {", "throw   new   IOException (  (  \" tmpdir   is   set   to   a   directory   that   doesn ' t   exist :     \"     +    dir )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkJavaIoTmpDirExists"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "File   file    =    File . createTempFile (  \" gradle _ fs _ probing \"  ,    null ,    null )  ;", "Files . write ( content ,    file ,    UTF _  8  )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["createFile"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "return   UUID . randomUUID (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateUniqueContent"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "return    ( file . exists (  )  )     &  &     ( Files . readFirstLine ( file ,    UTF _  8  )  . equals ( content )  )  ;", "}", "METHOD_END"], "methodName": ["hasContent"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "if    (  ( caseSensitive )     =  =    null )     {", "String   content    =    generateUniqueContent (  )  ;", "File   file    =    null ;", "try    {", "checkJavaIoTmpDirExists (  )  ;", "file    =    createFile ( content )  ;", "caseSensitive    =    probeCaseSensitive ( file ,    content )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}    finally    {", "FileUtils . deleteQuietly ( file )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initializeCaseSensitive"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   upperCased    =    new   File ( file . getPath (  )  . toUpperCase (  )  )  ;", "return    !  ( hasContent ( upperCased ,    content )  )  ;", "}    catch    ( IOException   e )     {", "boolean   result    =     !  ( new   File (  \" foo \"  )  . equals ( new   File (  \" FOO \"  )  )  )  ;", ". LOGGER . info (  \" Failed   to   determine   if   file   system   is   case   sensitive .    Best   guess   is    '  {  }  '  .  \"  ,    result )  ;", "return   result ;", "}", "}", "METHOD_END"], "methodName": ["probeCaseSensitive"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.GenericFileSystem"}, {"methodBody": ["METHOD_START", "{", "if    ( warned . compareAndSet ( false ,    true )  )     {", ". LOGGER . warn (  \" Support   for   reading   or   changing   file   permissions   is   only   available   on   this   platform   using   Java    7    or   later .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeWarn"], "fileName": "org.gradle.internal.nativeintegration.filesystem.services.UnsupportedFilePermissions"}, {"methodBody": ["METHOD_START", "{", "String   prop    =    System . getProperty (  \" sun . arch . data . model \"  )  ;", "if    ( prop    =  =    null )     {", "prop    =    System . getProperty (  \" com . ibm . vm . bitmode \"  )  ;", "}", "if    ( prop    !  =    null )     {", "return   Ier . parseInt ( prop )  ;", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getBitModel"], "fileName": "org.gradle.internal.nativeintegration.jansi.DefaultJansiRuntimeResolver"}, {"methodBody": ["METHOD_START", "{", "JansiStorage   jansiStorage    =    locator . locate ( storageDir )  ;", "if    ( jansiStorage    !  =    null )     {", "File   libFile    =    jansiStorage . getTargetLibFile (  )  ;", "libFile . getParentFile (  )  . mkdirs (  )  ;", "if    (  !  ( libFile . exists (  )  )  )     {", "InputStream   libraryInputStream    =    getClass (  )  . getResourceAsStream ( jansiStorage . getJansiLibrary (  )  . getResourcePath (  )  )  ;", "if    ( libraryInputStream    !  =    null )     {", "copyLibrary ( libraryInputStream ,    libFile )  ;", "}", "}", "System . setProperty (  . JANSI _ LIBRARY _ PATH _ SYS _ PROP ,    libFile . getParent (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiBootPathConfigurer"}, {"methodBody": ["METHOD_START", "{", "try    {", "try    {", "FileOutputStream   outputStream    =    new   FileOutputStream ( libFile )  ;", "try    {", "IOUtils . copy ( lib ,    outputStream )  ;", "}    finally    {", "outputStream . close (  )  ;", "}", "}    finally    {", "lib . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   NativeIException ( String . format (  \" Could   not   create   Jansi   native   library    '  % s '  .  \"  ,    libFile )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["copyLibrary"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiBootPathConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   filename ;", "}", "METHOD_END"], "methodName": ["getFilename"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibrary"}, {"methodBody": ["METHOD_START", "{", "return    (  ( platform )     +     \"  /  \"  )     +     ( filename )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibrary"}, {"methodBody": ["METHOD_START", "{", "return   platform ;", "}", "METHOD_END"], "methodName": ["getPlatform"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibrary"}, {"methodBody": ["METHOD_START", "{", "return    \"  / META - INF / native /  \"     +     ( getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["getResourcePath"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibrary"}, {"methodBody": ["METHOD_START", "{", "String   os    =    jansiRuntimeResolver . getOperatingSystem (  )  ;", "JansiOperatingSystemSupport   osSupport    =    JansiOperatingSystemSupport . forIdentifier ( os )  ;", "if    ( osSupport    =  =    null )     {", "return   null ;", "}", "switch    ( osSupport )     {", "case   MAC _ OS _ X    :", "return   new   JansiLibrary ( os ,     . MAC _ OSX _ LIB _ FILENAME )  ;", "case   LINUX    :", "return   new   JansiLibrary ( jansiRuntimeResolver . getPlatform (  )  ,     . LINUX _ LIB _ FILENAME )  ;", "case   WINDOWS    :", "return   new   JansiLibrary ( jansiRuntimeResolver . getPlatform (  )  ,     . WINDOWS _ LIB _ FILENAME )  ;", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibraryFactory"}, {"methodBody": ["METHOD_START", "{", "this . jansiRuntimeResolver    =    jansiRuntimeResolver ;", "}", "METHOD_END"], "methodName": ["setJansiRuntimeResolver"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiLibraryFactory"}, {"methodBody": ["METHOD_START", "{", "return   JansiOperatingSystemSupport . MAPPING . get ( identifier )  ;", "}", "METHOD_END"], "methodName": ["forIdentifier"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiOperatingSystemSupport"}, {"methodBody": ["METHOD_START", "{", "return   identifier ;", "}", "METHOD_END"], "methodName": ["getIdentifier"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiOperatingSystemSupport"}, {"methodBody": ["METHOD_START", "{", "return   jansiLibrary ;", "}", "METHOD_END"], "methodName": ["getJansiLibrary"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiStorage"}, {"methodBody": ["METHOD_START", "{", "return   targetLibFile ;", "}", "METHOD_END"], "methodName": ["getTargetLibFile"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiStorage"}, {"methodBody": ["METHOD_START", "{", "JansiLibrary   jansiLibrary    =    factory . create (  )  ;", "if    ( jansiLibrary    !  =    null )     {", "File   jansiDir    =    makeVersionSpecificDir ( storageDir )  ;", "File   targetLibFile    =    new   File ( jansiDir ,    jansiLibrary . getPath (  )  )  ;", "return   new    ( jansiLibrary ,    targetLibFile )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["locate"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiStorageLocator"}, {"methodBody": ["METHOD_START", "{", "String   jansiVersion    =    Ansi . class . getPackage (  )  . getImplementationVersion (  )  ;", "return   new   File ( sDir ,     (  \" jansi /  \"     +    jansiVersion )  )  ;", "}", "METHOD_END"], "methodName": ["makeVersionSpecificDir"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiStorageLocator"}, {"methodBody": ["METHOD_START", "{", "this . factory    =    factory ;", "}", "METHOD_END"], "methodName": ["setFactory"], "fileName": "org.gradle.internal.nativeintegration.jansi.JansiStorageLocator"}, {"methodBody": ["METHOD_START", "{", "Long   pid    =    null ;", "String   runtimeMXBeanName    =    ManagementFactory . getRuntimeMXBean (  )  . getName (  )  ;", "int   separatorPos    =    runtimeMXBeanName . indexOf (  '  @  '  )  ;", "if    ( separatorPos    >     (  -  1  )  )     {", "try    {", "pid    =    Long . parseLong ( runtimeMXBeanName . substring (  0  ,    separatorPos )  )  ;", "}    catch    ( NumberFormatException   e )     {", ". LOGGER . debug (  (  \" Native - platform   process :    failed   to   parse   PID   from   Runtime   MX   bean   name :     \"     +    runtimeMXBeanName )  )  ;", "}", "} else    {", ". LOGGER . debug (  \" Native - platform   process :    failed   to   parse   PID   from   Runtime   MX   bean   name \"  )  ;", "}", "return   pid ;", "}", "METHOD_END"], "methodName": ["extractPIDFromRuntimeMXBeanName"], "fileName": "org.gradle.internal.nativeintegration.jna.UnsupportedEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   new   NativeIntegrationUnavailableException (  (  \" We   don ' t   support   this   operating   system :     \"     +     ( OperatingSystem . current (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["notSupported"], "fileName": "org.gradle.internal.nativeintegration.jna.UnsupportedEnvironment"}, {"methodBody": ["METHOD_START", "{", "return   NativeServices . getInstance (  )  . get ( FileSystem . class )  ;", "}", "METHOD_END"], "methodName": ["getDefault"], "fileName": "org.gradle.internal.nativeintegration.services.FileSystems"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "Terminals   terminals    =    net . rubygrapefruit . platform . Native . get ( Terminals . class )  ;", "return   new   NativePlatformConsoleDetector ( terminals )  ;", "}    catch    ( NativeIntegrationUnavailableException   ex )     {", "NativeServices . LOGGER . debug (  \" Native - platform   terminal   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}    catch    ( NativeException   ex )     {", "NativeServices . LOGGER . debug (  \" Unable   to   load   from   native - platform   backed   ConsoleDetector .    Continuing   with   fallback .    Failure :     {  }  \"  ,    NativeServices . format ( ex )  )  ;", "}", "try    {", "if    ( operatingSystem . isWindows (  )  )     {", "return   new   WindowsConsoleDetector (  )  ;", "}", "}    catch    ( LinkageError   e )     {", "NativeServices . LOGGER . debug (  \" Unable   to   load   native   library .    Continuing   with   fallback .    Failure :     {  }  \"  ,    NativeServices . format ( e )  )  ;", "}", "}", "return   new   NoOpConsoleDetector (  )  ;", "}", "METHOD_END"], "methodName": ["createConsoleDetector"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( operatingSystem . isMacOsX (  )  )     &  &     ( NativeServices . useNativeIntegrations )  )     {", "try    {", "return   new   NativePlatformBackedFileMetadataAccessor ( net . rubygrapefruit . platform . Native . get ( Files . class )  )  ;", "}    catch    ( NativeIntegrationUnavailableException   e )     {", "NativeServices . LOGGER . debug (  \" Native - platform   files   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "if    ( JavaVersion . current (  )  . isJava 7 Compatible (  )  )     {", "return   JavaReflectionUtil . newInstanceOrFallback (  \" filesystem . jdk 7  . Jdk 7 FileMetadataAccessor \"  ,    NativeServices . class . getClassLoader (  )  ,    FallbackFileMetadataAccessor . class )  ;", "}", "return   new   FallbackFileMetadataAccessor (  )  ;", "}", "METHOD_END"], "methodName": ["createFileMetadataAccessor"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "return   Jvm . current (  )  ;", "}", "METHOD_END"], "methodName": ["createJvm"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "return   net . rubygrapefruit . platform . Native . get ( Memory . class )  ;", "}    catch    ( NativeIntegrationUnavailableException   e )     {", "NativeServices . LOGGER . debug (  \" Native - platform   memory   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "return   notAvailable ( Memory . class )  ;", "}", "METHOD_END"], "methodName": ["createMemory"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "return   OperatingSystem . current (  )  ;", "}", "METHOD_END"], "methodName": ["createOperatingSystem"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "return   net . rubygrapefruit . platform . Native . get ( PosixFiles . class )  ;", "}    catch    ( NativeIntegrationUnavailableException   e )     {", "NativeServices . LOGGER . debug (  \" Native - platform   posix   files   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "return   notAvailable ( UnavailablePosixFiles . class )  ;", "}", "METHOD_END"], "methodName": ["createPosixFiles"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "Process   process    =    net . rubygrapefruit . platform . Native . get ( Process . class )  ;", "return   new   NativePlatformBackedProcessEnvironment ( process )  ;", "}    catch    ( NativeIntegrationUnavailableException   ex )     {", "NativeServices . LOGGER . debug (  \" Native - platform   process   integration   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "return   new   UnsupportedEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["createProcessEnvironment"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "return   net . rubygrapefruit . platform . Native . get ( ProcessLauncher . class )  ;", "}    catch    ( NativeIntegrationUnavailableException   e )     {", "NativeServices . LOGGER . debug (  \" Native - platform   process   launcher   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "return   new   DefaultProcessLauncher (  )  ;", "}", "METHOD_END"], "methodName": ["createProcessLauncher"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( NativeServices . useNativeIntegrations )     {", "try    {", "return   net . rubygrapefruit . platform . Native . get ( SystemInfo . class )  ;", "}    catch    ( NativeIntegrationUnavailableException   e )     {", "NativeServices . LOGGER . debug (  \" Native - platform   system   info   is   not   available .    Continuing   with   fallback .  \"  )  ;", "}", "}", "return   notAvailable ( SystemInfo . class )  ;", "}", "METHOD_END"], "methodName": ["createSystemInfo"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( NativeServices . useNativeIntegrations )     &  &     ( operatingSystem . isWindows (  )  )  )     {", "return   net . rubygrapefruit . platform . Native . get ( WindowsRegistry . class )  ;", "}", "return   notAvailable ( WindowsRegistry . class )  ;", "}", "METHOD_END"], "methodName": ["createWindowsRegistry"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append ( throwabtoString (  )  )  ;", "for    ( Throwabcurrent    =    throwabgetCause (  )  ;    current    !  =    null ;    current    =    current . getCause (  )  )     {", "builder . append ( SystemProperties . getInstance (  )  . getLineSeparator (  )  )  ;", "builder . append (  \" caused   by :     \"  )  ;", "builder . append ( current . toString (  )  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( NativeServices . initialized )  )     {", "throw   new   IllegalStateException (  \" Cannot   get   an   instance   of   NativeServices   without   first   calling   initialize (  )  .  \"  )  ;", "}", "return   NativeServices . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperty ( NativeServices . NATIVE _ DIR _ OVERRIDE ,    System . getenv ( NativeServices . NATIVE _ DIR _ OVERRIDE )  )  ;", "}", "METHOD_END"], "methodName": ["getNativeDirOverride"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "String   overrideProperty    =    NativeServices . getNativeDirOverride (  )  ;", "if    ( overrideProperty    =  =    null )     {", "return   new   File ( userHomeDir ,     \" native \"  )  ;", "} else    {", "return   new   File ( overrideProperty )  ;", "}", "}", "METHOD_END"], "methodName": ["getNativeServicesDir"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "NativeServices . initialize ( userHomeDir ,    true )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( NativeServices . initialized )  )     {", "NativeServices . useNativeIntegrations    =     \" true \"  . equalsIgnoreCase ( System . getProperty (  \" native \"  ,     \" true \"  )  )  ;", "if    ( NativeServices . useNativeIntegrations )     {", "File   nativeBaseDir    =    NativeServices . getNativeServicesDir ( userHomeDir )  ;", "try    {", "Native . init ( nativeBaseDir )  ;", "}    catch    ( NativeIntegrationUnavailableException   ex )     {", "NativeServices . LOGGER . debug (  \" Native - platform   is   not   available .  \"  )  ;", "NativeServices . useNativeIntegrations    =    false ;", "}    catch    ( NativeException   ex )     {", "if    (  (  ( ex . getCause (  )  )    instanceof   UnsatisfiedLinkError )     &  &     ( ex . getCause (  )  . getMessage (  )  . toLowerCase (  )  . contains (  \" already   loaded   in   another   classloader \"  )  )  )     {", "NativeServices . LOGGER . debug (  \" Unable   to   initialize   native - platform .    Failure :     {  }  \"  ,    NativeServices . format ( ex )  )  ;", "NativeServices . useNativeIntegrations    =    false ;", "} else", "if    (  ( ex . getMessage (  )  . equals (  \" Could   not   extract   native   JNI   library .  \"  )  )     &  &     ( ex . getCause (  )  . getMessage (  )  . contains (  \" native - platform . dll    ( The   process   cannot   access   the   file   because   it   is   being   used   by   another   process )  \"  )  )  )     {", "NativeServices . LOGGER . debug (  \" Unable   to   initialize   native - platform .    Failure :     {  }  \"  ,    NativeServices . format ( ex )  )  ;", "NativeServices . useNativeIntegrations    =    false ;", "} else    {", "throw   ex ;", "}", "}", "if    ( initializeJansi )     {", "NativeServices . JANSI _ BOOT _ PATH _ CONFIGURER . configure ( nativeBaseDir )  ;", "}", "NativeServices . LOGGER . info (  (  \" Initialized   native   services   in :     \"     +    nativeBaseDir )  )  ;", "}", "NativeServices . initialized    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( Proxy . newProxyInstance ( type . getClassLoader (  )  ,    new   Class [  ]  {    type    }  ,    new   NativeServices . BrokenService ( type . getSimpleName (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["notAvailable"], "fileName": "org.gradle.internal.nativeintegration.services.NativeServices"}]