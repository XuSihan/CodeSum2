[{"methodBody": ["METHOD_START", "{", "DefaultBuildCacheConfiguration . getBuildCacheServiceFactoryType ( type ,    registrations )  ;", "return   instantiator . newInstance ( type )  ;", "}", "METHOD_END"], "methodName": ["createBuildCacheConfiguration"], "fileName": "org.gradle.caching.configuration.internal.DefaultBuildCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "T   local    =    DefaultBuildCacheConfiguration . createBuildCacheConfiguration ( instantiator ,    type ,    registrations )  ;", "local . setPush ( true )  ;", "return   local ;", "}", "METHOD_END"], "methodName": ["createLocalCacheConfiguration"], "fileName": "org.gradle.caching.configuration.internal.DefaultBuildCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "T   remote    =    DefaultBuildCacheConfiguration . createBuildCacheConfiguration ( instantiator ,    type ,    registrations )  ;", "remote . setPush ( false )  ;", "return   remote ;", "}", "METHOD_END"], "methodName": ["createRemoteCacheConfiguration"], "fileName": "org.gradle.caching.configuration.internal.DefaultBuildCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildCacheServiceRegistration   registration    :    registrations )     {", "Class <  ?    extends   BuildCache >    registeredConfigurationType    =    registration . getConfigurationType (  )  ;", "if    ( registeredConfigurationType . isAssignableFrom ( configurationType )  )     {", "Class <  ?    extends   BuildCacheServiceFactory <  ?  >  >    buildCacheServiceFactoryType    =    registration . getFactoryType (  )  ;", ". LOGGER . debug (  \" Found    {  }    registered   for    {  }  \"  ,    buildCacheServiceFactoryType ,    registeredConfigurationType )  ;", "return   Cast . uncheckedCast ( buildCacheServiceFactoryType )  ;", "}", "}", "throw   new   GradleException (  (  (  \" Build   cache   type    '  \"     +     ( configurationType . getName (  )  )  )     +     \"  '    has   not   been   registered .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildCacheServiceFactoryType"], "fileName": "org.gradle.caching.configuration.internal.DefaultBuildCacheConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   buildOperationExecutor . call ( new   CallableBuildOperation < BuildCacheController >  (  )     {", "@ Override", "public   BuildCacheController   call ( BuildOperationContext   context )     {", "if    ( buildCacheState    =  =     (  . BuildCacheMode . DISABLED )  )     {", "context . setResult (  . ResultImpl . disabled (  )  )  ;", "return   NoOpBuildCacheController . INSTANCE ;", "}", "BuildCache   local    =    buildCacheConfiguration . getLocal (  )  ;", "BuildCache   remote    =    buildCacheConfiguration . getRemote (  )  ;", "boolean   localEnabled    =     ( local    !  =    null )     &  &     ( local . isEnabled (  )  )  ;", "boolean   remoteEnabled    =     ( remote    !  =    null )     &  &     ( remote . isEnabled (  )  )  ;", "if    ( remoteEnabled    &  &     ( remoteAccessMode    =  =     (  . RemoteAccessMode . OFFLINE )  )  )     {", "remoteEnabled    =    false ;", ". LOGGER . warn (  \" Remote   build   cache   is   disabled   when   running   with    -  - offline .  \"  )  ;", "}", ". DescribedBuildCacheService   localDescribedService    =     ( localEnabled )     ?     . createBuildCacheService ( local ,    BuildCacheServiceRole . LOCAL ,    buildIdentityPath ,    buildCacheConfiguration ,    instantiator )     :    null ;", ". DescribedBuildCacheService   remoteDescribedService    =     ( remoteEnabled )     ?     . createBuildCacheService ( remote ,    BuildCacheServiceRole . REMOTE ,    buildIdentityPath ,    buildCacheConfiguration ,    instantiator )     :    null ;", "context . setResult ( new    . ResultImpl ( true ,     (  ( local    !  =    null )     &  &     ( local . isEnabled (  )  )  )  ,     (  (  ( remote    !  =    null )     &  &     ( remote . isEnabled (  )  )  )     &  &     ( remoteAccessMode    =  =     (  . RemoteAccessMode . ONLINE )  )  )  ,     ( localDescribedService    =  =    null    ?    null    :    localDescribedService . description )  ,     ( remoteDescribedService    =  =    null    ?    null    :    remoteDescribedService . description )  )  )  ;", "if    (  (  ! localEnabled )     &  &     (  ! remoteEnabled )  )     {", ". LOGGER . warn (  \" Task   output   caching   is   enabled ,    but   no   build   caches   are   configured   or   enabled .  \"  )  ;", "return   NoOpBuildCacheController . INSTANCE ;", "} else    {", "BuildCacheServicesConfiguration   config    =     . toConfiguration ( local ,     ( localDescribedService    =  =    null    ?    null    :    localDescribedService . service )  ,    remote ,     ( remoteDescribedService    =  =    null    ?    null    :    remoteDescribedService . service )  )  ;", "return   new   DefaultBuildCacheController ( config ,    buildOperationExecutor ,    gradleUserHomeDir ,    logStackTraces ,    emitDebugLogging )  ;", "}", "}", "@ Override", "public   Builder   description (  )     {", "return   BuildOperationDescriptor . displayName (  \" Finalize   build   cache   configuration \"  )  . details ( new    . DetailsImpl ( buildIdentityPath . getPath (  )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.caching.internal.controller.BuildCacheControllerFactory"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   BuildCacheServiceFactory < T >  >    castFactoryType    =    Cast . uncheckedCast ( buildCacheConfiguration . getBuildCacheServiceFactoryType ( configuration . getClass (  )  )  )  ;", "BuildCacheServiceFactory < T >    factory    =    instantiator . newInstance ( castFactoryType )  ;", ". Describer   describer    =    new    . Describer (  )  ;", "BuildCacheService   service    =    factory . createBuildCacheService ( configuration ,    describer )  ;", "ImmutableSortedMap < String ,    String >    config    =    ImmutableSortedMap . copyOf ( describer . configParams )  ;", ". BuildCacheDescription   description    =    new    . BuildCacheDescription ( configuration ,    describer . type ,    config )  ;", ". logConfig ( buildIdentityPath ,    role ,    description )  ;", "return   new    . DescribedBuildCacheService ( service ,    description )  ;", "}", "METHOD_END"], "methodName": ["createBuildCacheService"], "fileName": "org.gradle.caching.internal.controller.BuildCacheControllerFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( BuildCacheControllerFactory . LOGGER . isInfoEnabled (  )  )     {", "StringBuilder   config    =    new   StringBuilder (  )  ;", "boolean   pullOnly    =     !  ( description . isPush (  )  )  ;", "if    (  (  !  ( description . config . isEmpty (  )  )  )     |  |    pullOnly )     {", "Map < String ,    String >    configMap ;", "if    ( pullOnly )     {", "configMap    =    new   LinkedHashMap < String ,    String >  (  )  ;", "configMap . put (  \" pull - only \"  ,    null )  ;", "configMap . putAll ( description . config )  ;", "} else    {", "configMap    =    description . config ;", "}", "config . append (  \"     (  \"  )  ;", "Joiner . on (  \"  ,     \"  )  . appendTo ( config ,    Iterables . transform ( configMap . entrySet (  )  ,    new   com . google . common . base . Function < Map . Entry < String ,    String >  ,    String >  (  )     {", "@ Override", "public   String   apply ( Map . Entry < String ,    String >    input )     {", "if    (  ( input . getValue (  )  )     =  =    null )     {", "return   input . getKey (  )  ;", "} else    {", "return    (  ( input . getKey (  )  )     +     \"     =     \"  )     +     ( input . getValue (  )  )  ;", "}", "}", "}  )  )  ;", "config . append (  \"  )  \"  )  ;", "}", "String   buildDescription ;", "if    ( buildIdentityPath . equals ( ROOT )  )     {", "buildDescription    =     \" the   root   build \"  ;", "} else    {", "buildDescription    =     (  \" build    '  \"     +    buildIdentityPath )     +     \"  '  \"  ;", "}", "BuildCacheControllerFactory . LOGGER . info (  \" Using    {  }     {  }    build   cache   for    {  }  {  }  .  \"  ,    role . getDisplayName (  )  ,     (  ( description . type )     =  =    null    ?    description . className    :    description . type )  ,    buildDescription ,    config )  ;", "}", "}", "METHOD_END"], "methodName": ["logConfig"], "fileName": "org.gradle.caching.internal.controller.BuildCacheControllerFactory"}, {"methodBody": ["METHOD_START", "{", "boolean   remotePush    =     ( remote    !  =    null )     &  &     ( remote . isPush (  )  )  ;", "boolean   localPush    =     ( local    !  =    null )     &  &     ( local . isPush (  )  )  ;", "return   new   ServicesConfiguration ( localService ,    localPush ,    remoteService ,    remotePush )  ;", "}", "METHOD_END"], "methodName": ["toConfiguration"], "fileName": "org.gradle.caching.internal.controller.BuildCacheControllerFactory"}, {"methodBody": ["METHOD_START", "{", "return   service    =  =    null    ?    NullBuildCacheServiceHandle . INSTANCE    :    DefaultBuildCacheController . toNonNullHandle ( service ,    push ,    role ,    buildOperationExecutor ,    logStackTraces )  ;", "}", "METHOD_END"], "methodName": ["toHandle"], "fileName": "org.gradle.caching.internal.controller.DefaultBuildCacheController"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultLocalBuildCacheServiceHandle ( local ,    localPush )  ;", "}", "METHOD_END"], "methodName": ["toHandle"], "fileName": "org.gradle.caching.internal.controller.DefaultBuildCacheController"}, {"methodBody": ["METHOD_START", "{", "if    ( role    =  =     ( BuildCacheServiceRole . LOCAL )  )     {", "return   new   BaseBuildCacheServiceHandle ( service ,    push ,    role ,    logStackTraces )  ;", "} else    {", "return   new   OpFiringBuildCacheServiceHandle ( service ,    push ,    role ,    buildOperationExecutor ,    logStackTraces )  ;", "}", "}", "METHOD_END"], "methodName": ["toNonNullHandle"], "fileName": "org.gradle.caching.internal.controller.DefaultBuildCacheController"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isSet (  )  )  )     {", "throw   new   IllegalStateException (  \" Root   build   cache   controller   not   yet   assigned \"  )  ;", "}", "return   b ;", "}", "METHOD_END"], "methodName": ["getForNonRootBuild"], "fileName": "org.gradle.caching.internal.controller.RootBuildCacheControllerRef"}, {"methodBody": ["METHOD_START", "{", "return    ( buildCacheController )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSet"], "fileName": "org.gradle.caching.internal.controller.RootBuildCacheControllerRef"}, {"methodBody": ["METHOD_START", "{", "this . buildCacheController    =    new   RootBuildCacheControllerRef . CloseShieldBuildCacheController ( buildCacheController )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.caching.internal.controller.RootBuildCacheControllerRef"}, {"methodBody": ["METHOD_START", "{", "disabled    =    true ;", "String   description    =     (  (  (  (  (  (  (  \" Could   not    \"     +    verb )     +     \"    entry    \"  )     +     ( key . getDisplayName (  )  )  )     +     \"     \"  )     +    preposition )     +     \"     \"  )     +     ( role . getDisplayName (  )  )  )     +     \"    build   cache \"  ;", "if    (  . LOGGER . isWarnEnabled (  )  )     {", "if    ( logStackTraces )     {", ". LOGGER . warn ( description ,    e )  ;", "} else    {", ". LOGGER . warn (  (  ( description    +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["failure"], "fileName": "org.gradle.caching.internal.controller.service.BaseBuildCacheServiceHandle"}, {"methodBody": ["METHOD_START", "{", "service . load ( key ,    loadTarget )  ;", "}", "METHOD_END"], "methodName": ["loadInner"], "fileName": "org.gradle.caching.internal.controller.service.BaseBuildCacheServiceHandle"}, {"methodBody": ["METHOD_START", "{", "service . load ( key ,    entryReader )  ;", "}", "METHOD_END"], "methodName": ["loadInner"], "fileName": "org.gradle.caching.internal.controller.service.BaseBuildCacheServiceHandle"}, {"methodBody": ["METHOD_START", "{", "service . store ( key ,    storeTarget )  ;", "}", "METHOD_END"], "methodName": ["storeInner"], "fileName": "org.gradle.caching.internal.controller.service.BaseBuildCacheServiceHandle"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.caching.internal.controller.service.BuildCacheServiceRole"}, {"methodBody": ["METHOD_START", "{", "if    ( loaded )     {", "return   file . length (  )  ;", "} else    {", "return    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["getLoadedSize"], "fileName": "org.gradle.caching.internal.controller.service.LoadTarget"}, {"methodBody": ["METHOD_START", "{", "return   loaded ;", "}", "METHOD_END"], "methodName": ["isLoaded"], "fileName": "org.gradle.caching.internal.controller.service.LoadTarget"}, {"methodBody": ["METHOD_START", "{", "return   stored ;", "}", "METHOD_END"], "methodName": ["isStored"], "fileName": "org.gradle.caching.internal.controller.service.StoreTarget"}, {"methodBody": ["METHOD_START", "{", "return   directoryProvider . getRoot ( level )  . resolve ( name )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.caching.internal.tasks.AbstractFileAccessor"}, {"methodBody": ["METHOD_START", "{", "Random   random    =    new   Random (  1  2  3  4 L )  ;", "ImmutableList . Builder < DataSource >    ins    =    ImmutableList . builder (  )  ;", "for    ( int   idx    =     0  ;    idx    <    fileCount ;    idx +  +  )     {", "String   name    =     (  \" in -  \"     +    idx )     +     \"  . bin \"  ;", "int   fileSize    =    minFileSize    +     ( random . nextInt (  ( maxFileSize    -    minFileSize )  )  )  ;", "byte [  ]    buffer    =    new   byte [ fileSize ]  ;", "random . nextBytes ( buffer )  ;", "DataSource   in    =    accessor . createSource ( name ,    buffer ,    Trial )  ;", "ins . add ( in )  ;", "}", "return   ins . build (  )  ;", "}", "METHOD_END"], "methodName": ["createInputFiles"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "String   packerName    =    getPackerName (  )  ;", "String   accessorName    =    getAccessorName (  )  ;", "Packer   packer    =     . PACKERS . get ( packerName )  ;", "DataAccessor   accessor    =     . ACCESSORS . get ( accessorName )  ;", "packer . pack ( inputs ,    accessor . createTarget (  (  \" pack -  \"     +    packerName )  ,    Iteration )  )  ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "long   sumLength    =     0  ;", "for    ( DataSource   in    :    ins )     {", "sumLength    +  =    in . getLength (  )  ;", "}", "DataTarget   target    =    accessor . createTarget ( name ,    Trial )  ;", "packer . pack ( ins ,    target )  ;", "DataSource   source    =    target . toSource (  )  ;", "System . out . printf (  \"  >  >  >     % s   is    % d   bytes   long    ( uncompressed   length :     % d ,    compression   ratio :     %  ,  .  2 f %  %  )  % n \"  ,    name ,    source . getLength (  )  ,    sumLength ,     (  (  ( double )     ( source . getLength (  )  )  )     /    sumLength )  )  ;", "return   source ;", "}", "METHOD_END"], "methodName": ["packSample"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "AbstractTaskOutputPackagingBenchmark . DIRECTORY _ PROVIDER . setupIteration (  )  ;", "}", "METHOD_END"], "methodName": ["setupIteration"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "AbstractTaskOutputPackagingBenchmark . DIRECTORY _ PROVIDER . setupTrial (  )  ;", "String   packerName    =    getPackerName (  )  ;", "String   accessorName    =    getAccessorName (  )  ;", "System . out . println (  (  (  (  \"  >  >  >    Measuring   format :     \"     +    packerName )     +     \"    with   accessor    \"  )     +    accessorName )  )  ;", "Packer   packer    =    AbstractTaskOutputPackagingBenchmark . PACKERS . get ( packerName )  ;", "DataAccessor   accessor    =    AbstractTaskOutputPackagingBenchmark . ACCESSORS . get ( accessorName )  ;", "this . inputs    =    AbstractTaskOutputPackagingBenchmark . createInputFiles ( fileCount ,    minFileSize ,    maxFileSize ,    accessor )  ;", "this . sample    =    AbstractTaskOutputPackagingBenchmark . packSample (  (  \" sample .  \"     +    packerName )  ,    inputs ,    packer ,    accessor )  ;", "}", "METHOD_END"], "methodName": ["setupTrial"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "AbstractTaskOutputPackagingBenchmark . DIRECTORY _ PROVIDER . tearDownIteration (  )  ;", "}", "METHOD_END"], "methodName": ["tearDownIteration"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "AbstractTaskOutputPackagingBenchmark . DIRECTORY _ PROVIDER . tearDownTrial (  )  ;", "}", "METHOD_END"], "methodName": ["tearDownTrial"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "String   packerName    =    getPackerName (  )  ;", "String   accessorName    =    getAccessorName (  )  ;", "Packer   packer    =     . PACKERS . get ( packerName )  ;", "DataAccessor   accessor    =     . ACCESSORS . get ( accessorName )  ;", "packer . unpack ( sample ,    accessor . createTargetFactory (  (  \" unpack -  \"     +    accessorName )  ,    Iteration )  )  ;", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "org.gradle.caching.internal.tasks.AbstractTaskOutputPackagingBenchmark"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( tempDirFile ,     (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  ;", "boolean   created    =    file . createNewFile (  )  ;", "blackhole . consume ( created )  ;", "}", "METHOD_END"], "methodName": ["createFileJava6"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( tempDirFile ,     (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  ;", "boolean   created    =    file . createNewFile (  )  ;", "fileSystem . chmod ( file ,     4  2  0  )  ;", "blackhole . consume ( created )  ;", "}", "METHOD_END"], "methodName": ["createFileJava6SetDefaultPermission"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "int   incrementAndGet    =    counter . incrementAndGet (  )  ;", "File   file    =    new   File ( tempDirFile ,     (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  ;", "boolean   created    =    file . createNewFile (  )  ;", "blackhole . consume ( created )  ;", "int   permissionsToSet ;", "if    (  ( incrementAndGet    %     2  )     =  =     0  )     {", "permissionsToSet    =     . DEFAULT _ JAVA 6  _ FILE _ PERMISSIONS ;", "} else    {", "permissionsToSet    =     . WEIRD _ JAVA 6  _ FILE _ PERMISSIONS ;", "}", "fileSystem . chmod ( file ,    permissionsToSet )  ;", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava6SetMixedPermission"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "int   incrementAndGet    =    counter . incrementAndGet (  )  ;", "File   file    =    new   File ( tempDirFile ,     (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  ;", "boolean   created    =    file . createNewFile (  )  ;", "blackhole . consume ( created )  ;", "int   originalPermissions    =    fileSystem . getUnixMode ( file )  ;", "int   permissionsToSet ;", "if    (  ( incrementAndGet    %     2  )     =  =     0  )     {", "permissionsToSet    =     . DEFAULT _ JAVA 6  _ FILE _ PERMISSIONS ;", "} else    {", "permissionsToSet    =     . WEIRD _ JAVA 6  _ FILE _ PERMISSIONS ;", "}", "if    ( originalPermissions    !  =    permissionsToSet )     {", "fileSystem . chmod ( file ,    permissionsToSet )  ;", "}", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava6SetPermissionsWhenNeeded"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "Path   file    =    Files . createFile ( tempDirPath . resolve (  (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  )  ;", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava7"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "Path   file    =    Files . createFile ( tempDirPath . resolve (  (  \" file -  \"     +     ( counter . incrementAndGet (  )  )  )  )  )  ;", "Files . setPosixFilePermissions ( file ,     . DEFAULT _ JAVA 7  _ FILE _ PERMISSIONS )  ;", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava7SetDefaultPermission"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "int   incrementAndGet    =    counter . incrementAndGet (  )  ;", "Path   file    =    Files . createFile ( tempDirPath . resolve (  (  \" file -  \"     +    incrementAndGet )  )  )  ;", "Set < PosixFilePermission >    permissionsToSet ;", "if    (  ( incrementAndGet    %     2  )     =  =     0  )     {", "permissionsToSet    =     . DEFAULT _ JAVA 7  _ FILE _ PERMISSIONS ;", "} else    {", "permissionsToSet    =     . WEIRD _ JAVA 7  _ FILE _ PERMISSIONS ;", "}", "Files . setPosixFilePermissions ( file ,    permissionsToSet )  ;", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava7SetMixedPermission"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "int   incrementAndGet    =    counter . incrementAndGet (  )  ;", "Path   file    =    Files . createFile ( tempDirPath . resolve (  (  \" file -  \"     +    incrementAndGet )  )  )  ;", "Set < PosixFilePermission >    originalPermissions    =    Files . getPosixFilePermissions ( file )  ;", "Set < PosixFilePermission >    permissionsToSet ;", "if    (  ( incrementAndGet    %     2  )     =  =     0  )     {", "permissionsToSet    =     . DEFAULT _ JAVA 7  _ FILE _ PERMISSIONS ;", "} else    {", "permissionsToSet    =     . WEIRD _ JAVA 7  _ FILE _ PERMISSIONS ;", "}", "if    (  !  ( originalPermissions . equals ( permissionsToSet )  )  )     {", "Files . setPosixFilePermissions ( file ,    permissionsToSet )  ;", "}", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["createFileJava7SetPermissionsWhenNeeded"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "this . tempDirPath    =    Files . createTempDirectory ( tempRootDir ,     \" iteration \"  )  ;", "this . tempDirFile    =    tempDirPath . toFile (  )  ;", "this . cou    =    new   AtomicInteger (  0  )  ;", "}", "METHOD_END"], "methodName": ["setupIteration"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "this . tempRootDir    =    Files . createTempDirectory (  \" chmod - benchmark \"  )  ;", "NativeServices . initialize ( tempRootDir . toFile (  )  )  ;", "this . fileSystem    =    FileSystems . getDefault (  )  ;", "}", "METHOD_END"], "methodName": ["setupTrial"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "FileUtils . forceDelete ( tempDirFile )  ;", "}", "METHOD_END"], "methodName": ["tearDownIteration"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "FileUtils . forceDelete ( tempRootDir . toFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["tearDownTrial"], "fileName": "org.gradle.caching.internal.tasks.ChmodBenchmark"}, {"methodBody": ["METHOD_START", "{", "File   file    =     ( missing )     ?    missingFile    :    existingFile ;", "blackhole . consume ( file . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["java6exists"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "File   file    =     ( missing )     ?    missingFile    :    existingFile ;", "while    (  !  ( file . equals ( tempDirFile )  )  )     {", "file    =    file . getParentFile (  )  ;", "blackhole . consume ( file . exists (  )  )  ;", "}", "blackhole . consume ( file )  ;", "}", "METHOD_END"], "methodName": ["java6walk"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "Path   path    =     ( missing )     ?    missingPath    :    existingPath ;", "blackhoonsume ( Files . exists ( path )  )  ;", "}", "METHOD_END"], "methodName": ["java7exists"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "Path   path    =     ( missing )     ?    missingPath    :    existingPath ;", "while    (  !  ( path . equals ( tempDirPath )  )  )     {", "path    =    path . getParent (  )  ;", "blackhoonsume ( Files . exists ( path )  )  ;", "}", "blackhoonsume ( path )  ;", "}", "METHOD_END"], "methodName": ["java7walk"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "if    (  ( path    =  =    null )     |  |     ( Files . isDirectory ( path )  )  )     {", "return ;", "}", ". mkdirs ( path . getParent (  )  )  ;", "Files . createDirectory ( path )  ;", "}", "METHOD_END"], "methodName": ["mkdirs"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "this . tempDirPath    =    Files . createTempDirectory (  \" file - walking \"  )  ;", "this . tempDirFile    =    tempDirPath . toFile (  )  ;", "this . missingPath    =    tempDirPath . resolve (  \" aaa - missing / bbb - missing / ccc - missing / ddd - missing / missing . txt \"  )  ;", "this . missingFile    =    missingPath . toFile (  )  ;", ". mkdirs ( missingPath . getParent (  )  )  ;", "this . existingPath    =    tempDirPath . resolve (  \" aaa / bbb / ccc / ddd / missing . txt \"  )  ;", "this . existingFile    =    existingPath . toFile (  )  ;", ". mkdirs ( existingPath . getParent (  )  )  ;", "Files . createFile ( existingPath )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "FileUtils . forceDelete ( tempDirFile )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.gradle.caching.internal.tasks.FileWalkingBenchmark"}, {"methodBody": ["METHOD_START", "{", "InputStream   inputStream    =    entry . openInput (  )  ;", "try    {", "IO . copyLarge ( inputStream ,    outputStream ,    buffer )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["packEntry"], "fileName": "org.gradle.caching.internal.tasks.PackerUtils"}, {"methodBody": ["METHOD_START", "{", "DataTarget   target    =    targetFactory . createDataTarget ( name )  ;", "OutputStream   outputStream    =    target . openOutput (  )  ;", "try    {", "IO . copyLarge ( inputStream ,    outputStream ,    buffer )  ;", "}    finally    {", "outputStream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unpackEntry"], "fileName": "org.gradle.caching.internal.tasks.PackerUtils"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "return   removeUnusedEntriesAfterDays ;", "}", "METHOD_END"], "methodName": ["getRemoveUnusedEntriesAfterDays"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . nagUserOfReplacedMethod (  \" DirectoryBuildCache . getTargetSizeInMB (  )  \"  ,     \" getRemoveUnusedEntriesAfterDays (  )  \"  )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["getTargetSizeInMB"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "this . directory    =    directory ;", "}", "METHOD_END"], "methodName": ["setDirectory"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "if    ( removeUnusedEntriesAfterDays    <     1  )     {", "throw   new   IllegalArgumentException (  \"    build   cache   needs   to   retain   entries   for   at   least   a   day .  \"  )  ;", "}", "this . removeUnusedEntriesAfterDays    =    removeUnusedEntriesAfterDays ;", "}", "METHOD_END"], "methodName": ["setRemoveUnusedEntriesAfterDays"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . nagUserOfReplacedMethod (  \" DirectoryBuildCache . setTargetSizeInMB (  )  \"  ,     \" setRemoveUnusedEntriesAfterDays (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setTargetSizeInMB"], "fileName": "org.gradle.caching.local.DirectoryBuildCache"}, {"methodBody": ["METHOD_START", "{", "LocallyAvailableResource   resource    =    fileStore . get ( key . getHashCode (  )  )  ;", "if    ( resource    =  =    null )     {", "return ;", "}", "File   file    =    resource . getFile (  )  ;", ". touch ( file )  ;", "try    {", "reader . execute ( file )  ;", "}    catch    ( Exception   e )     {", "File   failedFile    =    new   File (  (  ( file . getAbsolutePath (  )  )     +     ( failedFileSuffix )  )  )  ;", "GFileUtils . deleteQuietly ( failedFile )  ;", "file . renameTo ( failedFile )  ;", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["loadInsideLock"], "fileName": "org.gradle.caching.local.internal.DirectoryBuildCacheService"}, {"methodBody": ["METHOD_START", "{", "fileStore . move ( key . getHashCode (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["storeInsideLock"], "fileName": "org.gradle.caching.local.internal.DirectoryBuildCacheService"}, {"methodBody": ["METHOD_START", "{", "try    {", "Fi . setLastModifiedTime ( fitoPath (  )  ,    Fiime . fromMillis ( System . currentTimeMillis (  )  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["touch"], "fileName": "org.gradle.caching.local.internal.DirectoryBuildCacheService"}, {"methodBody": ["METHOD_START", "{", "if    ( directory . exists (  )  )     {", "if    (  !  ( directory . is (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cache   directory    % s   must   be   a   directory \"  ,    directory )  )  ;", "}", "if    (  !  ( directory . canRead (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cache   directory    % s   must   be   readable \"  ,    directory )  )  ;", "}", "if    (  !  ( directory . canWrite (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cache   directory    % s   must   be   writable \"  ,    directory )  )  ;", "}", "} else    {", "if    (  !  ( directory . mkdirs (  )  )  )     {", "throw   new   UncheckedIOException ( String . format (  \" Could   not   create   cache   directory :     % s \"  ,    directory )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkDirectory"], "fileName": "org.gradle.caching.local.internal.DirectoryBuildCacheServiceFactory"}]