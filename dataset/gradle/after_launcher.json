[{"methodBody": ["METHOD_START", "{", "new   ProcessBootstrap (  )  . run (  \" Main \"  ,    args )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.gradle.launcher.GradleMain"}, {"methodBody": ["METHOD_START", "{", "return   new   CommandLineActionFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createActionFactory"], "fileName": "org.gradle.launcher.Main"}, {"methodBody": ["METHOD_START", "{", "UnsupportedJavaRuntimeException . assertUsingVersion (  \" Gradle \"  ,    VERSION _  1  _  7  )  ;", "createActionFactory (  )  . convert ( Arrays . asList ( args )  )  . execute ( listener )  ;", "}", "METHOD_END"], "methodName": ["doAction"], "fileName": "org.gradle.launcher.Main"}, {"methodBody": ["METHOD_START", "{", "new   Main (  )  . run ( args )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.gradle.launcher.Main"}, {"methodBody": ["METHOD_START", "{", "return   new   ProcessCompleter (  )  ;", "}", "METHOD_END"], "methodName": ["createCompleter"], "fileName": "org.gradle.launcher.bootstrap.EntryPoint"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildExceptionReporter ( new   StreamingStyledTextOutputFactory ( System . err )  ,    new   DefaultLoggingConfiguration (  )  ,    new   GradleLauncherMetaData (  )  )  ;", "}", "METHOD_END"], "methodName": ["createErrorHandler"], "fileName": "org.gradle.launcher.bootstrap.EntryPoint"}, {"methodBody": ["METHOD_START", "{", "EntryPoint . RecordingExecutionListener   listener    =    new   EntryPoint . RecordingExecutionListener (  )  ;", "try    {", "doAction ( args ,    listener )  ;", "}    catch    ( Throwable   e )     {", "createErrorHandler (  )  . execute ( e )  ;", "listener . onFailure ( e )  ;", "}", "Throwable   failure    =    listener . getFailure (  )  ;", "ExecutionCompleter   completer    =    createCompleter (  )  ;", "if    ( failure    =  =    null )     {", "completer . complete (  )  ;", "} else    {", "completer . completeWithFailure ( failure )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.launcher.bootstrap.EntryPoint"}, {"methodBody": ["METHOD_START", "{", "try    {", "runNoExit ( mainClassName ,    args )  ;", "System . exit (  0  )  ;", "}    catch    ( Throwabthrowab    {", "throwabprintStackTrace (  )  ;", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.launcher.bootstrap.ProcessBootstrap"}, {"methodBody": ["METHOD_START", "{", "ClassPathRegistry   classPathRegistry    =    new   DefaultClassPathRegistry ( new   DefaultClassPathProvider ( new   DefaultModuleRegistry ( CurrentGradleInstallation . get (  )  )  )  )  ;", "ClassLoaderFactory   classLoaderFactory    =    new   DefaultClassLoaderFactory (  )  ;", "ClassPath   antClasspath    =    classPathRegistry . getClassPath (  \" ANT \"  )  ;", "ClassPath   runtimeClasspath    =    classPathRegistry . getClassPath (  \" GRADLE _ RUNTIME \"  )  ;", "ClassLoader   antClassLoader    =    classLoaderFactory . createIsolatedClassLoader ( antClasspath )  ;", "ClassLoader   runtimeClassLoader    =    new   VisitableURLClassLoader ( antClassLoader ,    runtimeClasspath )  ;", "ClassLoader   oldClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( runtimeClassLoader )  ;", "try    {", "Class <  ?  >    mainClass    =    runtimeClassLoader . loadClass ( mainClassName )  ;", "Object   entryPoint    =    mainClass . newInstance (  )  ;", "Method   mainMethod    =    mainClass . getMethod (  \" run \"  ,    String [  ]  . class )  ;", "mainMethod . invoke ( entryPoint ,    new   Object [  ]  {    args    }  )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( oldClassLoader )  ;", "ClassLoaderUtils . tryClose ( runtimeClassLoader )  ;", "ClassLoaderUtils . tryClose ( antClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["runNoExit"], "fileName": "org.gradle.launcher.bootstrap.ProcessBootstrap"}, {"methodBody": ["METHOD_START", "{", "System . exit (  0  )  ;", "}", "METHOD_END"], "methodName": ["complete"], "fileName": "org.gradle.launcher.bootstrap.ProcessCompleter"}, {"methodBody": ["METHOD_START", "{", "System . exit (  1  )  ;", "}", "METHOD_END"], "methodName": ["completeWithFailure"], "fileName": "org.gradle.launcher.bootstrap.ProcessCompleter"}, {"methodBody": ["METHOD_START", "{", "BuildProcess   currentProcess    =    new   BuildProcess (  )  ;", "return   currentProcess . configureForBuild ( requiredBuildParameters )  ;", "}", "METHOD_END"], "methodName": ["canUseCurrentProcess"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   GradleLauncherMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["clientMetaData"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "parametersConverter . configure ( parser )  ;", "}", "METHOD_END"], "methodName": ["configureCommandLineParser"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "Parameters   parameters    =    parametersConverter . convert ( commandLine ,    new   Parameters (  )  )  ;", "parameters . getStartParameter (  )  . setInteractive ( ConsoleStateUtil . isInteractive (  )  )  ;", "parameters . getDaemonParameters (  )  . applyDefaultsFor ( jvmVersionDetector . getJavaVersion ( parameters . getDaemonParameters (  )  . getEffectiveJvm (  )  )  )  ;", "if    ( parameters . getDaemonParameters (  )  . isStop (  )  )     {", "return   stopAllDaemons ( parameters . getDaemonParameters (  )  ,    loggingServices )  ;", "}", "if    ( parameters . getDaemonParameters (  )  . isStatus (  )  )     {", "return   showDaemonStatus ( parameters . getDaemonParameters (  )  ,    loggingServices )  ;", "}", "if    ( parameters . getDaemonParameters (  )  . isForeground (  )  )     {", "DaemonParameters   daemonParameters    =    parameters . getDaemonParameters (  )  ;", "ForegroundDaemonConfiguration   conf    =    new   ForegroundDaemonConfiguration ( UUID . randomUUID (  )  . toString (  )  ,    daemonParameters . getBaseDir (  )  ,    daemonParameters . getIdleTimeout (  )  ,    daemonParameters . getPeriodicCheckInterval (  )  )  ;", "return   new   ForegroundDaemon ( loggingServices ,    conf )  ;", "}", "if    ( parameters . getDaemonParameters (  )  . isEnabled (  )  )     {", "return   runBuildWithDaemon ( parameters . getStartParameter (  )  ,    parameters . getDaemonParameters (  )  ,    loggingServices )  ;", "}", "if    ( canUseCurrentProcess ( parameters . getDaemonParameters (  )  )  )     {", "return   runBuildInProcess ( parameters . getStartParameter (  )  ,    parameters . getDaemonParameters (  )  ,    loggingServices )  ;", "}", "return   runBuildInSingleUseDaemon ( parameters . getStartParameter (  )  ,    parameters . getDaemonParameters (  )  ,    loggingServices )  ;", "}", "METHOD_END"], "methodName": ["createAction"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildActionParameters ( daemonParameters . getEffectiveSystemProperties (  )  ,    daemonParameters . getEnvironmentVariables (  )  ,    SystemProperties . getInstance (  )  . getCurrentDir (  )  ,    startParameter . getLogLevel (  )  ,    daemonParameters . isEnabled (  )  ,    startParameter . isContinuous (  )  ,    daemonParameters . isInteractive (  )  ,    ClassPath . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["createBuildActionParameters"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistryBuilder   builder    =    ServiceRegistryBuilder . builder (  )  . displayName (  \" Daemon   client   global   services \"  )  . parent ( NativeServices . getInstance (  )  )  ;", "if    ( usingDaemon )     {", "builder . provider ( new   BasicGlobalScopeServices (  )  )  ;", "} else    {", "builder . provider ( new   GlobalScopeServices ( false )  )  ;", "}", "return   builder . provider ( new   DaemonClientGlobalServices (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createGlobalClientServices"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "return   ManagementFactory . getRuntimeMXBean (  )  . getStartTime (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildStartTime"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "BuildActionParameters   parameters    =    createBuildActionParameters ( startParameter ,    daemonParameters )  ;", "Stoppable   stoppable    =    new   CompositeStoppable (  )  . add ( stopBeforeSharedServices )  . add ( sharedServices )  ;", "return   new   RunBuildAction ( executer ,    startParameter ,    clientMetaData (  )  ,    getBuildStartTime (  )  ,    parameters ,    sharedServices ,    stoppable )  ;", "}", "METHOD_END"], "methodName": ["runBuildAndCloseServices"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   globalServices    =    ServiceRegistryBuilder . builder (  )  . displayName (  \" Global   services \"  )  . parent ( loggingServices )  . parent ( NativeServices . getInstance (  )  )  . provider ( new   GlobalScopeServices ( startParameter . isContinuous (  )  )  )  . build (  )  ;", "return   runBuildAndCloseServices ( startParameter ,    daemonParameters ,    globalServices . get ( BuildExecuter . class )  ,    globalServices ,    globalServices . get ( GradleUserHomeScopeServiceRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["runBuildInProcess"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "int   maxTimeout    =     (  2     *     6  0  )     *     1  0  0  0  ;", "if    (  ( daemonParameters . getIdleTimeout (  )  )     >    maxTimeout )     {", "daemonParameters . setIdleTimeout ( maxTimeout )  ;", "}", "ServiceRegistry   clientSharedServices    =    createGlobalClientServices ( true )  ;", "ServiceRegistry   clientServices    =    clientSharedServices . get ( DaemonClient . class )  . createSingleUseDaemonClientServices ( loggingServices . get ( OutputEventListener . class )  ,    daemonParameters ,    System . in )  ;", "DaemonClient   client    =    clientServices . get ( DaemonClient . class )  ;", "return   runBuildAndCloseServices ( startParameter ,    daemonParameters ,    client ,    clientSharedServices ,    clientServices )  ;", "}", "METHOD_END"], "methodName": ["runBuildInSingleUseDaemon"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   clientSharedServices    =    createGlobalClientServices ( true )  ;", "ServiceRegistry   clientServices    =    clientSharedServices . get ( DaemonClient . class )  . createBuildClientServices ( loggingServices . get ( OutputEventListener . class )  ,    daemonParameters ,    System . in )  ;", "DaemonClient   client    =    clientServices . get ( DaemonClient . class )  ;", "return   runBuildAndCloseServices ( startParameter ,    daemonParameters ,    client ,    clientSharedServices ,    clientServices )  ;", "}", "METHOD_END"], "methodName": ["runBuildWithDaemon"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   clientSharedServices    =    createGlobalClientServices ( false )  ;", "ServiceRegistry   clientServices    =    clientSharedServices . get ( DaemonClient . class )  . createStopDaemonServices ( loggingServices . get ( OutputEventListener . class )  ,    daemonParameters )  ;", "ReportDaemonStatusClient   statusClient    =    clientServices . get ( ReportDaemonStatusClient . class )  ;", "return   new   ReportDaemonStatusAction ( statusClient )  ;", "}", "METHOD_END"], "methodName": ["showDaemonStatus"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   clientSharedServices    =    createGlobalClientServices ( false )  ;", "ServiceRegistry   clientServices    =    clientSharedServices . get ( DaemonClient . class )  . createStopDaemonServices ( loggingServices . get ( OutputEventListener . class )  ,    daemonParameters )  ;", "DaemonStopClient   stopClient    =    clientServices . get ( DaemonStopClient . class )  ;", "return   new   StopDaemonAction ( stopClient )  ;", "}", "METHOD_END"], "methodName": ["stopAllDaemons"], "fileName": "org.gradle.launcher.cli.BuildActionsFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   GradleLauncherMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["clientMetaData"], "fileName": "org.gradle.launcher.cli.CommandLineActionFactory"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   loggingServices    =    createLoggingServices (  )  ;", "LoggingConfiguration   loggingConfiguration    =    new   DefaultLoggingConfiguration (  )  ;", "return   new    . WithLogging ( loggingServices ,    buildLayoutFactory ,    args ,    loggingConfiguration ,    new    . ParseAndBuildAction ( loggingServices ,    args )  ,    new   BuildExceptionReporter ( loggingServices . get ( StyledTextOutputFactory . class )  ,    loggingConfiguration ,     . clientMetaData (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.CommandLineActionFactory"}, {"methodBody": ["METHOD_START", "{", "actions . add ( new   BuildActionsFactory ( loggingServices ,    new   ParametersConverter ( buildLayoutFactory )  ,    new   CachingJvmVersionDetector ( new   DefaultJvmVersionDetector ( new   DefaultExecActionFactory ( new   IdentityFileResolver (  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createActionFactories"], "fileName": "org.gradle.launcher.cli.CommandLineActionFactory"}, {"methodBody": ["METHOD_START", "{", "return   LoggingServiceRegistry . newCommandLineProcessLogging (  )  ;", "}", "METHOD_END"], "methodName": ["createLoggingServices"], "fileName": "org.gradle.launcher.cli.CommandLineActionFactory"}, {"methodBody": ["METHOD_START", "{", "out . println (  )  ;", "out . print (  \" USAGE :     \"  )  ;", ". clientMetaData (  )  . describeCommand ( out ,     \"  [ option .  .  .  ]  \"  ,     \"  [ task .  .  .  ]  \"  )  ;", "out . println (  )  ;", "out . println (  )  ;", "parser . printUsage ( out )  ;", "out . println (  )  ;", "}", "METHOD_END"], "methodName": ["showUsage"], "fileName": "org.gradle.launcher.cli.CommandLineActionFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "try    {", "action . execute ( executionListener )  ;", "}    finally    {", "loggingOutput . flush (  )  ;", "}", "}    catch    ( Reported   e )     {", "executionListener . onFailure ( e . getCause (  )  )  ;", "}    catch    ( Throwable   t )     {", "reporter . execute ( t )  ;", "executionListener . onFailure ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.cli.ExceptionReportingAction"}, {"methodBody": ["METHOD_START", "{", "return   daemonParameters ;", "}", "METHOD_END"], "methodName": ["getDaemonParameters"], "fileName": "org.gradle.launcher.cli.Parameters"}, {"methodBody": ["METHOD_START", "{", "return   layout ;", "}", "METHOD_END"], "methodName": ["getLayout"], "fileName": "org.gradle.launcher.cli.Parameters"}, {"methodBody": ["METHOD_START", "{", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["getStartParameter"], "fileName": "org.gradle.launcher.cli.Parameters"}, {"methodBody": ["METHOD_START", "{", "this . daemonParameters    =    daemonParameters ;", "}", "METHOD_END"], "methodName": ["setDaemonParameters"], "fileName": "org.gradle.launcher.cli.Parameters"}, {"methodBody": ["METHOD_START", "{", "try    {", "executer . execute ( new   ExecuteBuildAction ( startParameter )  ,    new   initialization . DefaultBuildRequestContext ( new   initialization . DefaultBuildRequestMetaData ( clientMetaData ,    startTime )  ,    new   DefaultBuildCancellationToken (  )  ,    new   NoOpBuildEventConsumer (  )  )  ,    buildActionParameters ,    sharedServices )  ;", "}    finally    {", "if    (  ( stoppable )     !  =    null )     {", "stoppable . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.launcher.cli.RunBuildAction"}, {"methodBody": ["METHOD_START", "{", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.launcher.cli.StopDaemonAction"}, {"methodBody": ["METHOD_START", "{", "DefaultSerializerRegistry   registry    =    new   DefaultSerializerRegistry (  )  ;", "registry . register ( ExecuteBuildAction . class ,    new    . Execute (  )  )  ;", "registry . useJavaSerialization ( BuildAction . class )  ;", "return   registry . build ( BuildAction . class )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.launcher.cli.action.BuildActionSerializer"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < DaemonParameters >    option    :    buildOptions )     {", "option . configure ( parser )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.launcher.cli.converter.DaemonCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < DaemonParameters >    option    :    buildOptions )     {", "option . applyFrom ( args ,    target )  ;", "}", "return   target ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.DaemonCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "BuildLayout   layout    =    buildLayoutFactory . getLayoutFor ( currentDir ,    searchUpwards )  ;", "maybeConfigureFrom ( new   File ( layout . getRootDirectory (  )  ,    Project . GRADLE _ PROPERTIES )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["configureFromBuildDir"], "fileName": "org.gradle.launcher.cli.converter.LayoutToPropertiesConverter"}, {"methodBody": ["METHOD_START", "{", "maybeConfigureFrom ( new   File ( gradleUserHomeDir ,    Project . GRADLE _ PROPERTIES )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["configureFromGradleUserHome"], "fileName": "org.gradle.launcher.cli.converter.LayoutToPropertiesConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < Object ,    Object >    entry    :    System . getProperties (  )  . entrySet (  )  )     {", "Object   key    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "if    (  ( key   instanceof   Serializable )     &  &     (  ( value   instanceof   Serializable )     |  |     ( value    =  =    null )  )  )     {", "properties . put ( key ,    value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["configureFromSystemproperties"], "fileName": "org.gradle.launcher.cli.converter.LayoutToPropertiesConverter"}, {"methodBody": ["METHOD_START", "{", "configureFromBuildDir ( layout . getSearchDir (  )  ,    layout . getSearchUpwards (  )  ,    properties )  ;", "configureFromGradleUserHome ( layout . getGradleUserHomeDir (  )  ,    properties )  ;", "configureFromSystemproperties ( properties )  ;", "return   properties ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.LayoutToPropertiesConverter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( propertiesFile . isFile (  )  )  )     {", "return ;", "}", "Properties   properties    =    new   Properties (  )  ;", "try    {", "FileInputStream   inputStream    =    new   FileInputStream ( propertiesFile )  ;", "try    {", "properties . load ( inputStream )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "for    ( final   Object   key    :    properties . keySet (  )  )     {", "BuildOption <  ?  >    validOption    =    CollectionUtils . findFirst ( allBuildOptions ,    new   api . specs . Spec < BuildOption <  ?  >  >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( BuildOption <  ?  >    option )     {", "return    ( option . getGradleProperty (  )  )     !  =    null    ?    option . getGradleProperty (  )  . equals ( key . toString (  )  )     :    false ;", "}", "}  )  ;", "if    ( validOption    !  =    null )     {", "result . put ( key . toString (  )  ,    properties . get ( key )  . toString (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["maybeConfigureFrom"], "fileName": "org.gradle.launcher.cli.converter.LayoutToPropertiesConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < DaemonParameters >    option    :    buildOptions )     {", "option . applyFromProperty ( properties ,    target )  ;", "}", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.PropertiesToDaemonParametersConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < LoggingConfiguration >    option    :    buildOptions )     {", "option . applyFromProperty ( properties ,    loggingConfiguration )  ;", "}", "return   loggingConfiguration ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.PropertiesToLogLevelConfigurationConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < ParallelismConfiguration >    option    :    buildOptions )     {", "option . applyFromProperty ( properties ,    parallelismConfiguration )  ;", "}", "return   parallelismConfiguration ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.PropertiesToParallelismConfigurationConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < StartParameterInternal >    option    :    buildOptions )     {", "option . applyFromProperty ( properties ,    startParameter )  ;", "}", "propertiesToParallelismConfigurationConverter . convert ( properties ,    startParameter )  ;", "propertiesToLogLevelConfigurationConverter . convert ( properties ,    startParameter )  ;", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.launcher.cli.converter.PropertiesToStartParameterConverter"}, {"methodBody": ["METHOD_START", "{", "builder . commandLine ( args )  ;", "builder . setWorkingDir ( workingDir )  ;", "builder . setStandardInput ( inputStream )  ;", "builder . redirectErrorStream (  )  ;", "builder . setTimeout (  3  0  0  0  0  )  ;", "builder . setDaemon ( true )  ;", "builder . setDisplayName (  \" Gradle   build   daemon \"  )  ;", "builder . streamsHandler ( outputConsumer )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.launcher.daemon.DaemonExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "new   DaemonStartupCommunication (  )  . printDaemonStarted ( originalOut ,    pid ,    uid ,    address ,    daemonLog )  ;", "try    {", "originalOut . close (  )  ;", "originalErr . close (  )  ;", "}    finally    {", "originalOut    =    null ;", "originalErr    =    null ;", "}", "}", "METHOD_END"], "methodName": ["daemonStarted"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonMain"}, {"methodBody": ["METHOD_START", "{", "PrintStream   result ;", "try    {", "Files . createParentDirs ( daemonLog )  ;", "result    =    new   PrintStream ( new   FileOutputStream ( daemonLog )  ,    true )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Unable   to   create   daemon   log   file \"  ,    e )  ;", "}", "final   PrintStream   log    =    result ;", "ShutdownHookActionRegister . addAction ( new   Runnable (  )     {", "public   void   run (  )     {", "log . println ( essages . DAEMON _ VM _ SHUTTING _ DOWN )  ;", "}", "}  )  ;", "redirectOutputsAndInput ( log )  ;", "loggingManager . attachSystemOutAndErr (  )  ;", "loggingManager . setLevelInternal ( DEBUG )  ;", "loggingManager . start (  )  ;", "}", "METHOD_END"], "methodName": ["initialiseLogging"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonMain"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  \" USAGE :     < gradle   version >  \"  )  ;", "System . out . println ( message )  ;", "System . exit (  1  )  ;", "}", "METHOD_END"], "methodName": ["invalidArgs"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonMain"}, {"methodBody": ["METHOD_START", "{", "this . originalOut    =    System . out ;", "this . originalErr    =    System . err ;", "System . setOut ( printStream )  ;", "System . setErr ( printStream )  ;", "System . setIn ( new   ByteArrayInputStream ( new   byte [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["redirectOutputsAndInput"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonMain"}, {"methodBody": ["METHOD_START", "{", "if    (  ( processOutput )     =  =    null )     {", "throw   new   IllegalStateException (  \" Unable   to   get   process   output   as   consuming   has   not   finished   yet .  \"  )  ;", "}", "return   processOutput ;", "}", "METHOD_END"], "methodName": ["getProcessOutput"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonOutputConsumer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( processStdOutput )     =  =    null )     {", "throw   new   IllegalStateException (  \" Cannot   start   consuming   daemon   output   because   streams   have   not   been   connected   first .  \"  )  ;", "}", ". LOGGER . debug (  \" Starting   consuming   the   daemon   process   output .  \"  )  ;", "StringWriter   output    =    new   StringWriter (  )  ;", "Scanner   scanner    =    new   Scanner ( processStdOutput )  ;", "PrintWriter   printer    =    new   PrintWriter ( output )  ;", "try    {", "while    ( scanner . hasNext (  )  )     {", "String   line    =    scanner . nextLine (  )  ;", ". LOGGER . debug (  \" daemon   out :     {  }  \"  ,    line )  ;", "printer . println ( line )  ;", "if    ( startupCommunication . containsGreeting ( line )  )     {", "break ;", "}", "}", "}    finally    {", "scanner . close (  )  ;", "}", "processOutput    =    output . toString (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonOutputConsumer"}, {"methodBody": ["METHOD_START", "{", "if    ( message    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Unable   to   detect   the   daemon   greeting   because   the   input   message   is   null !  \"  )  ;", "}", "return   message . contains (  . daemonGreeting (  )  )  ;", "}", "METHOD_END"], "methodName": ["containsGreeting"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonStartupCommunication"}, {"methodBody": ["METHOD_START", "{", "return   DaemonMessages . ABOUT _ TO _ CLOSE _ STREAMS ;", "}", "METHOD_END"], "methodName": ["daemonGreeting"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonStartupCommunication"}, {"methodBody": ["METHOD_START", "{", "target . print ( DaemonStartupCommunication . daemonGreeting (  )  )  ;", "try    {", "OutputStream   outputStream    =    new   EncodedStream . EncodedOutput ( target )  ;", "FlushableEncoder   encoder    =    new   OutputStreamBackedEncoder ( outputStream )  ;", "encoder . writeNullableString (  ( pid    =  =    null    ?    null    :    pid . toString (  )  )  )  ;", "encoder . writeString ( uid )  ;", "MultiChoiceAddress   multiChoiceAddress    =     (  ( MultiChoiceAddress )     ( address )  )  ;", "new   MultiChoiceAddressSerializer (  )  . write ( encoder ,    multiChoiceAddress )  ;", "encoder . writeString ( daemonLog . getPath (  )  )  ;", "encoder . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "target . println (  )  ;", "DaemonStartupCommunication . LOGGER . debug (  \" Completed   writing   the   daemon   greeting .    Closing   streams .  .  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["printDaemonStarted"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonStartupCommunication"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( message . startsWith ( DaemonStartupCommunication . daemonGreeting (  )  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Unexpected   daemon   startup   message :     % s \"  ,    message )  )  ;", "}", "try    {", "String   encoded    =    message . substring ( DaemonStartupCommunication . daemonGreeting (  )  . length (  )  )  . trim (  )  ;", "InputStream   inputStream    =    new   EncodedStream . EncodedInput ( new   ByteArrayInputStream ( encoded . getBytes (  )  )  )  ;", "Decoder   decoder    =    new   InputStreamBackedDecoder ( inputStream )  ;", "String   pidString    =    decoder . readNullableString (  )  ;", "String   uid    =    decoder . readString (  )  ;", "Long   pid    =     ( pidString    =  =    null )     ?    null    :    Long . valueOf ( pidString )  ;", "Address   address    =    new   MultiChoiceAddressSerializer (  )  . read ( decoder )  ;", "File   daemonLog    =    new   File ( decoder . readString (  )  )  ;", "return   new   DaemonStartupInfo ( uid ,    address ,    new   DaemonDiagnostics ( daemonLog ,    pid )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readDiagnostics"], "fileName": "org.gradle.launcher.daemon.bootstrap.DaemonStartupCommunication"}, {"methodBody": ["METHOD_START", "{", "LoggingManagerInternal   loggingManager    =    loggingRegistry . newInstance ( LoggingManagerInternal . class )  ;", "loggingManager . start (  )  ;", "DaemonServices   ervices    =    new   DaemonServices ( configuration ,    loggingRegistry ,    loggingManager ,    new   DefaultClassPath (  )  )  ;", "Daemon    =    ervices . get ( Daemon . class )  ;", "DaemonRegistry   egistry    =    ervices . get ( DaemonRegistry . class )  ;", "DaemonExpirationStrategy   expirationStrategy    =    ervices . get ( MasterExpirationStrategy . class )  ;", "start (  )  ;", "try    {", "egistry . markState ( getAddress (  )  ,    DaemonStateControl . State . Idle )  ;", "stopOnExpiration ( expirationStrategy ,    configuration . getPeriodicCheckIntervalMs (  )  )  ;", "}    finally    {", "stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.launcher.daemon.bootstrap.ForegroundDaemonAction"}, {"methodBody": ["METHOD_START", "{", "new   ProcessBootstrap (  )  . run (  \" DaemonMain \"  ,    args )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.gradle.launcher.daemon.bootstrap.GradleDaemon"}, {"methodBody": ["METHOD_START", "{", "cancellationToken . addCallback ( cancellationCallback )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.client.DaemonCancelForwarder"}, {"methodBody": ["METHOD_START", "{", "cancellationToken . removeCallback ( cancellationCallback )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.client.DaemonCancelForwarder"}, {"methodBody": ["METHOD_START", "{", "UUID   buildId    =    idGenerator . generateId (  )  ;", "List < DaemonInitialConnectException >    accumulatedExceptions    =    Lists . newArrayList (  )  ;", ". LOGGER . debug (  (  (  (  (  \" Executing   build    \"     +    buildId )     +     \"    in   daemon   client    { pid =  \"  )     +     ( processEnvironment . maybeGetPid (  )  )  )     +     \"  }  \"  )  )  ;", "int   saneNumberOfAttempts    =     1  0  0  ;", "for    ( int   i    =     1  ;    i    <    saneNumberOfAttempts ;    i +  +  )     {", "final   Connection   connection    =    connector . connect ( compatibilitySpec )  ;", "try    {", "Build   build    =    new   Build ( buildId ,    connection . getDaemon (  )  . getToken (  )  ,    action ,    requestContext . getClient (  )  ,    requestContext . getStartTime (  )  ,    parameters )  ;", "return   executeBuild ( build ,    connection ,    requestContext . getCancellationToken (  )  ,    requestContext . getEventConsumer (  )  )  ;", "}    catch    ( DaemonInitialConnectException   e )     {", ". LOGGER . debug (  \"  {  }  ,    Trying   a   different   daemon .  .  .  \"  ,    e . getMessage (  )  )  ;", "accumulatedExceptions . add ( e )  ;", "}    finally    {", "connection . stop (  )  ;", "}", "}", "throw   new   NoUsableDaemonFoundException (  (  (  (  (  \" Unable   to   find   a   usable   idle   daemon .    I   have   connected   to    \"     +    saneNumberOfAttempts )     +     \"    different   daemons   but   I   could   not   use   any   of   them   to   run   the   build .    BuildActionParameters   were    \"  )     +    parameters )     +     \"  .  \"  )  ,    accumulatedExceptions )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "Object   result ;", "try    {", "DaemonClient . LOGGER . debug (  \" Connected   to   daemon    {  }  .    Dispatching   request    {  }  .  \"  ,    connection . getDaemon (  )  ,    build )  ;", "connection . dispatch ( build )  ;", "result    =    connection . receive (  )  ;", "}    catch    ( StaleDaemonAddressException   e )     {", "DaemonClient . LOGGER . debug (  \" Connected   to   a   stale   daemon   address .  \"  ,    e )  ;", "throw   new   DaemonInitialConnectException (  \" Connected   to   a   stale   daemon   address .  \"  ,    e )  ;", "}", "if    ( result    =  =    null )     {", "throw   new   DaemonInitialConnectException (  \" The   first   result   from   the   daemon   was   empty .    Most   likely   the   process   died   immediately   after   connection .  \"  )  ;", "}", "DaemonClient . LOGGER . debug (  \" Received   result    {  }    from   daemon    {  }     ( build   should   be   starting )  .  \"  ,    result ,    connection . getDaemon (  )  )  ;", "DaemonDiagnostics   diagnostics    =    null ;", "if    ( result   instanceof   BuildStarted )     {", "diagnostics    =     (  ( BuildStarted )     ( result )  )  . getDiagnostics (  )  ;", "result    =    monitorBuild ( build ,    diagnostics ,    connection ,    cancellationToken ,    buildEventConsumer )  ;", "}", "DaemonClient . LOGGER . debug (  \" Received   result    {  }    from   daemon    {  }     ( build   should   be   done )  .  \"  ,    result ,    connection . getDaemon (  )  )  ;", "connection . dispatch ( new   Finished (  )  )  ;", "if    ( result   instanceof   Failure )     {", "Throwable   failure    =     (  ( Failure )     ( result )  )  . getValue (  )  ;", "if    (  ( failure   instanceof   DaemonStoppedException )     &  &     ( cancellationToken . isCancellationRequested (  )  )  )     {", "DaemonClient . LOGGER . error (  \" Daemon   was   stopped   to   handle   build   cancel   request .  \"  )  ;", "throw   new   BuildCancelledException (  )  ;", "}", "throw   UncheckedException . throwAsUncheckedException ( failure )  ;", "} else", "if    ( result   instanceof   protocol . DaemonUnavailable )     {", "throw   new   DaemonInitialConnectException (  (  \" The   daemon   we   connected   to   was   unavailable :     \"     +     (  (  ( protocol . DaemonUnavailable )     ( result )  )  . getReason (  )  )  )  )  ;", "} else", "if    ( result   instanceof   protocol . Result )     {", "return    (  ( protocol . Result )     ( result )  )  . getValue (  )  ;", "} else    {", "throw   invalidResponse ( result ,    build ,    diagnostics )  ;", "}", "}", "METHOD_END"], "methodName": ["executeBuild"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "return   connector ;", "}", "METHOD_END"], "methodName": ["getConnector"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "return   idGenerator ;", "}", "METHOD_END"], "methodName": ["getIdGenerator"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "DaemonClient . LOGGER . error (  (  \" The   message   received   from   the   daemon   indicates   that   the   daemon   has   disappeared .  \"     +     (  \"  \\ nBuild   request   sent :     {  }  \"     +     \"  \\ nAttempting   to   read   last   messages   from   the   daemon   log .  .  .  \"  )  )  ,    build )  ;", "DaemonClient . LOGGER . error ( diagnostics . describe (  )  )  ;", "throw   new   DaemonDisappearedException (  )  ;", "}", "METHOD_END"], "methodName": ["handleDaemonDisappearance"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "String   diagnosticsMessage    =     ( diagnostics    =  =    null )     ?     \" No   diagnostics   available .  \"     :    diagnostics . describe (  )  ;", "return   new   IllegalStateException ( String . format (  (  \" Received   invalid   response   from   the       '  % s '    is   a   result   of   a   type   we   don ' t   have   a   strategy   to   handle .     \"     +     \" Earlier ,     \\  '  % s \\  '    request   was   sent   to   the      Diagnostics :  \\ n % s \"  )  ,    response ,    command ,    diagnosticsMessage )  )  ;", "}", "METHOD_END"], "methodName": ["invalidResponse"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "DaemonClientInputForwarder   inputForwarder    =    new   DaemonClientInputForwarder ( buildStandardInput ,    connection ,    executorFactory )  ;", "DaemonCancelForwarder   cancelForwarder    =    new   DaemonCancelForwarder ( connection ,    cancellationToken )  ;", "try    {", "cancelForwarder . start (  )  ;", "inputForwarder . start (  )  ;", "int   objectsReceived    =     0  ;", "while    ( true )     {", "Message   object    =    connection . receive (  )  ;", "objectsReceived +  +  ;", "if    ( DaemonClient . LOGGER . isTraceEnabled (  )  )     {", "DaemonClient . LOGGER . trace (  \" Received   object    #  {  }  ,    type :     {  }  \"  ,     ( objectsReceived +  +  )  ,     ( object    =  =    null    ?    null    :    object . getClass (  )  . getName (  )  )  )  ;", "}", "if    ( object    =  =    null )     {", "return   handleDaemonDisappearance ( build ,    diagnostics )  ;", "} else", "if    ( object   instanceof   protocol . OutputMessage )     {", "outputEventListener . onOutput (  (  ( protocol . OutputMessage )     ( object )  )  . getEvent (  )  )  ;", "} else", "if    ( object   instanceof   protocol . BuildEvent )     {", "buildEventConsumer . dispatch (  (  ( protocol . BuildEvent )     ( object )  )  . getPayload (  )  )  ;", "} else    {", "return   object ;", "}", "}", "}    finally    {", "CompositeStoppable . stoppable ( cancelForwarder ,    inputForwarder )  . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["monitorBuild"], "fileName": "org.gradle.launcher.daemon.client.DaemonClient"}, {"methodBody": ["METHOD_START", "{", "DaemonClientConnection . LOG . debug (  \" thread    {  }  :    dispatching    {  }  \"  ,    Thread . currentThread (  )  . getId (  )  ,    message . getClass (  )  )  ;", "try    {", "dispatchLock . lock (  )  ;", "try    {", "connection . dispatch ( message )  ;", "connection . flush (  )  ;", "}    finally    {", "dispatchLock . unlock (  )  ;", "}", "}    catch    ( MessageIOException   e )     {", "DaemonClientConnection . LOG . debug (  \" Problem   dispatching   message   to   the   daemon .    Performing    ' on   failure '    operation .  .  .  \"  )  ;", "if    (  (  !  ( hasReceived )  )     &  &     ( staleAddressDetector . maybeStaleAddress ( e )  )  )     {", "throw   new   StaleDaemonAddressException (  \" Could   not   dispatch   a   message   to   the   daemon .  \"  ,    e )  ;", "}", "throw   new   DaemonConnectionException (  \" Could   not   dispatch   a   message   to   the   daemon .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientConnection"}, {"methodBody": ["METHOD_START", "{", "return   daemon ;", "}", "METHOD_END"], "methodName": ["getDaemon"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientConnection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   connection . receive (  )  ;", "}    catch    ( MessageIOException   e )     {", ". LOG . debug (  \" Problem   receiving   message   to   the   daemon .    Performing    ' on   failure '    operation .  .  .  \"  )  ;", "if    (  (  !  ( hasReceived )  )     &  &     ( staleAddressDetector . maybeStaleAddress ( e )  )  )     {", "throw   new   StaleDaemonAddressException (  \" Could   not   receive   a   message   from   the   daemon .  \"  ,    e )  ;", "}", "throw   new   DaemonConnectionException (  \" Could   not   receive   a   message   from   the   daemon .  \"  ,    e )  ;", "}    finally    {", "hasReceived    =    true ;", "}", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientConnection"}, {"methodBody": ["METHOD_START", "{", "DaemonClientConnection . LOG . debug (  \" thread    {  }  :    connection   stop \"  ,    Thread . currentThread (  )  . getId (  )  )  ;", "connection . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientConnection"}, {"methodBody": ["METHOD_START", "{", "DefaultServiceRegistry   loggingServices    =    new   DefaultServiceRegistry ( sharedServices )  ;", "loggingServices . add ( OutputEventListener . class ,    loggingReceiver )  ;", "return   new   Services ( loggingServices ,    daemonParameters ,    stdin )  ;", "}", "METHOD_END"], "methodName": ["createBuildClientServices"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultServiceRegistry   loggingServices    =    new   DefaultServiceRegistry ( sharedServices )  ;", "loggingServices . add ( OutputEventListener . class ,    loggingReceiver )  ;", "return   new   SingleUseServices ( loggingServices ,    daemonParameters ,    stdin )  ;", "}", "METHOD_END"], "methodName": ["createSingleUseDaemonClientServices"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultServiceRegistry   loggingServices    =    new   DefaultServiceRegistry ( sharedServices )  ;", "loggingServices . add ( OutputEventListener . class ,    loggingReceiver )  ;", "return   new   Services ( loggingServices ,    daemonParameters ,    new   ByteArrayInputStream ( new   byte [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["createStopDaemonServices"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientFactory"}, {"methodBody": ["METHOD_START", "{", "return   BuildActionSerializer . create (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildActionSerializer"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientGlobalServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonClientFactory ( sharedServices )  ;", "}", "METHOD_END"], "methodName": ["createClientFactory"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientGlobalServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonGreeter ( documentationRegistry )  ;", "}", "METHOD_END"], "methodName": ["createDaemonGreeter"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientGlobalServices"}, {"methodBody": ["METHOD_START", "{", "return   new   JvmVersionValidator ( jvmVersionDetector )  ;", "}", "METHOD_END"], "methodName": ["createJvmVersionValidator"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientGlobalServices"}, {"methodBody": ["METHOD_START", "{", "forwarder . start (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientInputForwarder"}, {"methodBody": ["METHOD_START", "{", "forwarder . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientInputForwarder"}, {"methodBody": ["METHOD_START", "{", "builder . setDaemonRegistryDir ( get ( DaemonDir . class )  . getBaseDir (  )  )  ;", "builder . useDaemonParameters ( daemonParameters )  ;", "}", "METHOD_END"], "methodName": ["configureDaemonContextBuilder"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServices"}, {"methodBody": ["METHOD_START", "{", "return   daemonParameters ;", "}", "METHOD_END"], "methodName": ["createDaemonParameters"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDaemonStarter ( daemonDir ,    daemonParameters ,    daemonGreeter ,    jvmVersionValidator )  ;", "}", "METHOD_END"], "methodName": ["createDaemonStarter"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServices"}, {"methodBody": ["METHOD_START", "{", "return   Time . clock (  )  ;", "}", "METHOD_END"], "methodName": ["createClock"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "DaemonCompatibilitySpec   matchingContextSpec    =    new   DaemonCompatibilitySpec ( get ( DaemonContext . class )  )  ;", "return   new    ( get ( DaemonConnector . class )  ,    get ( OutputEventListener . class )  ,    matchingContextSpec ,    buildStandardInput ,    get ( ExecutorFactory . class )  ,    idGenerator ,    get ( ProcessEnvironment . class )  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonClient"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDaemonConnector ( daemonRegistry ,    outgoingConnector ,    daemonStarter ,    listenerManager . getBroadcaster ( DaemonStartListener . class )  ,    progressLoggerFactory ,    DaemonMessageSerializer . create ( buildActionSerializer )  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonConnector"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "DaemonContextBuilder   builder    =    new   DaemonContextBuilder ( processEnvironment )  ;", "configureDaemonContextBuilder ( builder )  ;", "return   builder . create (  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonContext"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonStopClient ( connector ,    idGenerator )  ;", "}", "METHOD_END"], "methodName": ["createDaemonStopClient"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   UUIDGenerator (  )  ;", "}", "METHOD_END"], "methodName": ["createIdGenerator"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   TcpOutgoingConnector (  )  ;", "}", "METHOD_END"], "methodName": ["createOutgoingConnector"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProgressLoggerFactory ( new   ProgressLoggingBridge ( get ( OutputEventListener . class )  )  ,    clock )  ;", "}", "METHOD_END"], "methodName": ["createProgressLoggerFactory"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   ReportDaemonStatusClient ( registry ,    connector ,    idGenerator ,    documentationRegistry )  ;", "}", "METHOD_END"], "methodName": ["createReportDaemonStatusClient"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "return   buildStandardInput ;", "}", "METHOD_END"], "methodName": ["getBuildStandardInput"], "fileName": "org.gradle.launcher.daemon.client.DaemonClientServicesSupport"}, {"methodBody": ["METHOD_START", "{", "DaemonStartupCommunication   startupCommunication    =    new   DaemonStartupCommunication (  )  ;", "if    (  !  ( startupCommunication . containsGreeting ( output )  )  )     {", "throw   new   GradleException ( prepareMessage ( output )  )  ;", "}", "String [  ]    lines    =    output . split (  \"  \\ n \"  )  ;", "String   lastLine    =    lines [  (  ( lines . length )     -     1  )  ]  ;", "return   startupCommunication . readDiagnostics ( lastLine )  ;", "}", "METHOD_END"], "methodName": ["parseDaemonOutput"], "fileName": "org.gradle.launcher.daemon.client.DaemonGreeter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append ( DaemonMessages . UNABLE _ TO _ START _ DAEMON )  ;", "sb . append (  \"  \\ nThis   problem   might   be   caused   by   incorrect   configuration   of   the    \"  )  ;", "sb . append (  \"  \\ nFor   example ,    an   unrecognized   jvm   option   is   used .  \"  )  ;", "sb . append (  \"  \\ nPlease   refer   to   the   user   guide   chapter   on   the   at    \"  )  ;", "sb . append ( documentationRegistry . getDocumentationFor (  \" gradle _  )  )  ;", "sb . append (  \"  \\ nPlease   read   the   following   process   output   to   find   out   more :  \"  )  ;", "sb . append (  \"  \\ n -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \\ n \"  )  ;", "sb . append ( output )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["prepareMessage"], "fileName": "org.gradle.launcher.daemon.client.DaemonGreeter"}, {"methodBody": ["METHOD_START", "{", "final   int   totalUnavailableDaemons    =     ( numBusy    +    numIncompatible )     +    numStopped ;", "if    ( totalUnavailableDaemons    >     0  )     {", "final   List < String >    reasons    =    Lists . newArrayList (  )  ;", "if    ( numBusy    >     0  )     {", "reasons . add (  ( numBusy    +     \"    busy \"  )  )  ;", "}", "if    ( numIncompatible    >     0  )     {", "reasons . add (  ( numIncompatible    +     \"    incompatible \"  )  )  ;", "}", "if    ( numStopped    >     0  )     {", "reasons . add (  ( numStopped    +     \"    stopped \"  )  )  ;", "}", "return    (  (  (  (  (  . STARTING _ DAEMON _ MESSAGE )     +     \"  ,     \"  )     +     ( Joiner . on (  \"    and    \"  )  . join ( reasons )  )  )     +     \"    Daemon \"  )     +     ( totalUnavailableDaemons    >     1     ?     \" s \"     :     \"  \"  )  )     +     (  . NOT _ REUSED _ MESSAGE )  ;", "} else    {", "return    (  (  . STARTING _ DAEMON _ MESSAGE )     +     \"     \"  )     +     (  . SUBSEQUENT _ BUILDS _ WILL _ BE _ FASTER )  ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.launcher.daemon.client.DaemonStartupMessage"}, {"methodBody": ["METHOD_START", "{", "for    ( DaemonConnectDetails   daemon    :    daemons )     {", "DaemonClientConnection   connection    =    connector . maybeConnect ( daemon )  ;", "if    ( connection    =  =    null )     {", "continue ;", "}", "try    {", ". LOGGER . debug (  \" Requesting   daemon    {  }    stop   when   idle \"  ,    daemon )  ;", "stopDispatcher . dispatch ( connection ,    new   StopWhenIdle ( idGenerator . generateId (  )  ,    connection . getDaemon (  )  . getToken (  )  )  )  ;", ". LOGGER . lifecycle (  \" Gradle   daemon   stopped .  \"  )  ;", "}    finally    {", "connection . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["gracefulStop"], "fileName": "org.gradle.launcher.daemon.client.DaemonStopClient"}, {"methodBody": ["METHOD_START", "{", "CountdownTimer   timer    =    Time . startCountdownTimer ( DaemonStopClient . STOP _ TIMEOUT _ SECONDS ,    TimeUnit . SECONDS )  ;", "final   Set < String >    seen    =    new   HashSet < String >  (  )  ;", "ExplainingSpec < DaemonContext >    spec    =    new   ExplainingSpec < DaemonContext >  (  )     {", "@ Override", "public   String   whyUnsatisfied ( DaemonContext   element )     {", "return    \" already   seen \"  ;", "}", "@ Override", "public   boolean   isSatisfiedBy ( DaemonContext   element )     {", "return    !  ( seen . contains ( element . getUid (  )  )  )  ;", "}", "}  ;", "DaemonClientConnection   connection    =    connector . maybeConnect ( spec )  ;", "if    ( connection    =  =    null )     {", "DaemonStopClient . LOGGER . lifecycle ( DaemonMessages . NO _ DAEMONS _ RUNNING )  ;", "return ;", "}", "DaemonStopClient . LOGGER . lifecycle (  \" Stopping   Daemon ( s )  \"  )  ;", "int   numStopped    =     0  ;", "while    (  ( connection    !  =    null )     &  &     (  !  ( timer . hasExpired (  )  )  )  )     {", "try    {", "seen . add ( connection . getDaemon (  )  . getUid (  )  )  ;", "DaemonStopClient . LOGGER . debug (  \" Requesting   daemon    {  }    stop   now \"  ,    connection . getDaemon (  )  )  ;", "boolean   stopped    =    stopDispatcher . dispatch ( connection ,    new   Stop ( idGenerator . generateId (  )  ,    connection . getDaemon (  )  . getToken (  )  )  )  ;", "if    ( stopped )     {", "numStopped +  +  ;", "}", "}    finally    {", "connection . stop (  )  ;", "}", "connection    =    connector . maybeConnect ( spec )  ;", "}", "if    ( numStopped    >     0  )     {", "DaemonStopClient . LOGGER . lifecycle (  (  (  ( numStopped    +     \"    Daemon \"  )     +     ( numStopped    >     1     ?     \" s \"     :     \"  \"  )  )     +     \"    stopped \"  )  )  ;", "}", "if    ( connection    !  =    null )     {", "throw   new   GradleException ( String . format (  \" Timeout   waiting   for   all   daemons   to   stop .    Waited    % s .  \"  ,    timer . getElapsed (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.client.DaemonStopClient"}, {"methodBody": ["METHOD_START", "{", "final   Pair < Collection < DaemonInfo >  ,    Collection < DaemonInfo >  >    idleBusy    =    partitionByState ( daemonRegistry . getAll (  )  ,    DaemonStateControl . State . Idle )  ;", "final   Collection < DaemonInfo >    idleDaemons    =    idleBusy . getLeft (  )  ;", "final   Collection < DaemonInfo >    busyDaemons    =    idleBusy . getRight (  )  ;", "lientConnection   connection    =    connectToIdleDaemon ( idleDaemons ,    constraint )  ;", "if    ( connection    !  =    null )     {", "return   connection ;", "}", "connection    =    connectToCanceledDaemon ( busyDaemons ,    constraint )  ;", "if    ( connection    !  =    null )     {", "return   connection ;", "}", "handleStopEvents ( idleDaemons ,    busyDaemons )  ;", "return   startDaemon ( constraint )  ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "DaemonClientConnection   connection    =    null ;", "final   Pair < Collection < DaemonInfo >  ,    Collection < DaemonInfo >  >    canceledBusy    =    partitionByState ( busyDaemons ,    DaemonStateControl . State . Canceled )  ;", "final   Collection < DaemonInfo >    compatibleCanceledDaemons    =    getCompatibleDaemons ( canceledBusy . getLeft (  )  ,    constraint )  ;", "if    (  !  ( compatibleCanceledDaemons . isEmpty (  )  )  )     {", ". LOGGER . info ( DaemonMessages . WAITING _ ON _ CANCELED )  ;", "CountdownTimer   timer    =    Time . startCountdownTimer (  . CANCELED _ WAIT _ TIMEOUT )  ;", "while    (  ( connection    =  =    null )     &  &     (  !  ( timer . hasExpired (  )  )  )  )     {", "try    {", "Thread . sleep (  2  0  0  )  ;", "connection    =    connectToIdleDaemon ( daemonRegistry . getIdle (  )  ,    constraint )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}", "return   connection ;", "}", "METHOD_END"], "methodName": ["connectToCanceledDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "ProgressLogger   progressLogger    =    progressLoggerFactory . newOperation ( DefaultDaemonConnector . class )  . start (  \" Connecting   to   Gradle   Daemon \"  ,     \" Connecting   to   Daemon \"  )  ;", "RemoteConnection < Message >    connection ;", "try    {", "connection    =    connector . connect ( daemon . getAddress (  )  )  . create ( Serializers . stateful ( serializer )  )  ;", "}    catch    ( ConnectException   e )     {", "staleAddressDetector . maybeStaleAddress ( e )  ;", "throw   e ;", "}    finally    {", "progressLogger . completed (  )  ;", "}", "return   new   DaemonClientConnection ( connection ,    daemon ,    staleAddressDetector )  ;", "}", "METHOD_END"], "methodName": ["connectToDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "for    ( DaemonInfo   daemonInfo    :    daemonRegistry . getNotIdle (  )  )     {", "if    ( daemonInfo . getUid (  )  . equals ( daemon . getUid (  )  )  )     {", "try    {", "if    (  !  ( constraint . isSatisfiedBy ( daemonInfo . getContext (  )  )  )  )     {", "throw   new   DaemonConnectionException (  (  (  \" The   newly   created   daemon   process   has   a   different   context   than   expected .  \"     +     (  \"  \\ nIt   won \\  ' t   be   possible   to   reconnect   to   this   daemon .    Context   mismatch :     \"     +     \"  \\ n \"  )  )     +     ( constraint . whyUnsatisfied ( daemonInfo . getContext (  )  )  )  )  )  ;", "}", "return   connectToDaemon ( daemonInfo ,    new    . CleanupOnStaleAddress ( daemonInfo ,    false )  )  ;", "}    catch    ( ConnectException   e )     {", "throw   new   DaemonConnectionException (  (  \" Could   not   connect   to   the   Gradle   daemon .  \\ n \"     +     ( daemon . describe (  )  )  )  ,    e )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["connectToDaemonWithId"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "final   List < DaemonInfo >    compatibleIdleDaemons    =    getCompatibleDaemons ( idleDaemons ,    constraint )  ;", "return   findion ( compatibleIdleDaemons )  ;", "}", "METHOD_END"], "methodName": ["connectToIdleDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "ProgressLogger   progressLogger    =    progressLoggerFactory . newOperation ( DefaultDaemonConnector . class )  . start (  \" Starting   Gradle   Daemon \"  ,     \" Starting   Daemon \"  )  ;", "final   DaemonStartupInfo   startupInfo    =    daemonStarter . startDaemon ( singleRun )  ;", "DefaultDaemonConnector . LOGGER . debug (  \" Started   Gradle   daemon    {  }  \"  ,    startupInfo )  ;", "CountdownTimer   timer    =    Time . startCountdownTimer ( connectTimeout )  ;", "try    {", "do    {", "DaemonClientConnection   daemonConnection    =    connectToDaemonWithId ( startupInfo ,    constraint )  ;", "if    ( daemonConnection    !  =    null )     {", "startListener . daemonStarted ( daemonConnection . getDaemon (  )  )  ;", "return   daemonConnection ;", "}", "try    {", "Thread . sleep (  2  0  0 L )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}    while    (  !  ( timer . hasExpired (  )  )     )  ;", "}    finally    {", "progressLogger . completed (  )  ;", "}", "throw   new   DaemonConnectionException (  (  \" Timeout   waiting   to   connect   to   the   Gradle   daemon .  \\ n \"     +     ( startupInfo . describe (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doStartDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "for    ( DaemonInfo   daemon    :    compatibleDaemons )     {", "try    {", "return   connectToDaemon ( daemon ,    new    . CleanupOnStaleAddress ( daemon ,    true )  )  ;", "}    catch    ( ConnectException   e )     {", ". LOGGER . debug (  \" Cannot   connect   to   daemon    {  }    due   to    {  }  .    Trying   a   different   daemon .  .  .  \"  ,    daemon ,    e )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findConnection"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "List < DaemonInfo >    compatibleDaemons    =    new   LinkedList < DaemonInfo >  (  )  ;", "for    ( DaemonInfo   daemon    :    daemons )     {", "if    ( constraint . isSatisfiedBy ( daemon . getContext (  )  )  )     {", "compatibleDaemons . add ( daemon )  ;", "} else    {", ". LOGGER . info (  (  (  (  \" Found   daemon    {  }    however   its   context   does   not   match   the   desired   criteria .  \\ n \"     +     ( constraint . whyUnsatisfied ( daemon . getContext (  )  )  )  )     +     \"  \\ n \"  )     +     \"       Looking   for   a   different   daemon .  .  .  \"  )  ,    daemon )  ;", "}", "}", "return   compatibleDaemons ;", "}", "METHOD_END"], "methodName": ["getCompatibleDaemons"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "return   connectTimeout ;", "}", "METHOD_END"], "methodName": ["getConnectTimeout"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "return   daemonRegistry ;", "}", "METHOD_END"], "methodName": ["getDaemonRegistry"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "final   List < DaemonStopEvent >    stopEvents    =    daemonRegistry . getStopEvents (  )  ;", "daemonRegistry . removeStopEvents ( DaemonStopEvents . oldStopEvents ( stopEvents )  )  ;", "final   List < DaemonStopEvent >    recentStopEvents    =    DaemonStopEvents . uniqueRecentDaemonStopEvents ( stopEvents )  ;", "for    ( DaemonStopEvent   stopEvent    :    recentStopEvents )     {", "Long   pid    =    stopEvent . getPid (  )  ;", ". LOGGER . info (  (  (  (  (  (  \" Previous   Daemon    (  \"     +     ( pid    =  =    null    ?     \" PID   unknown \"     :    pid )  )     +     \"  )    stopped   at    \"  )     +     ( stopEvent . getTimestamp (  )  )  )     +     \"     \"  )     +     ( stopEvent . getReason (  )  )  )  )  ;", "}", ". LOGGER . lifecycle ( DaemonStartupMessage . generate ( busyDaemons . size (  )  ,    idleDaemons . size (  )  ,    recentStopEvents . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["handleStopEvents"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "return   findConnection ( getCompatibleDaemons ( daemonRegistry . getAll (  )  ,    constraint )  )  ;", "}", "METHOD_END"], "methodName": ["maybeConnect"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   connectToDaemon ( daemon ,    new    . CleanupOnStaleAddress ( daemon ,    true )  )  ;", "}    catch    ( ConnectException   e )     {", ". LOGGER . debug (  \" Cannot   connect   to   daemon    {  }    due   to    {  }  .    Ignoring .  \"  ,    daemon ,    e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["maybeConnect"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . partition ( daemons ,    new   Spec < DaemonInfo >  (  )     {", "public   boolean   isSatisfiedBy ( DaemonInfo   daemonInfo )     {", "return    ( daemonInfo . getState (  )  )     =  =    state ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["partitionByState"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeout    =    connectTimeout ;", "}", "METHOD_END"], "methodName": ["setConnectTimeout"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "return   doStartDaemon ( constraint ,    false )  ;", "}", "METHOD_END"], "methodName": ["startDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonConnector"}, {"methodBody": ["METHOD_START", "{", "String   daemonUid    =    UUID . randomUUID (  )  . toString (  )  ;", "GradleInstallation   gradleInstallation    =    CurrentGradleInstallation . get (  )  ;", "ModuleRegistry   registry    =    new   DefaultModuleRegistry ( gradleInstallation )  ;", "ClassPath   classpath ;", "List < File >    searchClassPath ;", "if    ( gradleInstallation    =  =    null )     {", "classpath    =    ClassPath . EMPTY ;", "for    ( Module   module    :    registry . getModule (  \" gradle - launcher \"  )  . getAllRequiredModules (  )  )     {", "classpath    =    classpath . plus ( module . getClasspath (  )  )  ;", "}", "searchClassPath    =    registry . getAdditionalClassPath (  )  . getAsFiles (  )  ;", "} else    {", "classpath    =    registry . getModule (  \" gradle - launcher \"  )  . getImplementationClasspath (  )  ;", "searchClassPath    =    Collections . emptyList (  )  ;", "}", "if    ( classpath . isEmpty (  )  )     {", "throw   new   IllegalStateException (  \" Unable   to   construct   a   bootstrap   classpath   when   starting   the   daemon \"  )  ;", "}", "versionValidator . validate ( daemonParameters )  ;", "List < String >    daemonArgs    =    new   ArrayList < String >  (  )  ;", "daemonArgs . add ( daemonParameters . getEffectiveJvm (  )  . getJavaExecutable (  )  . getAbsolutePath (  )  )  ;", "List < String >    daemonOpts    =    daemonParameters . getEffectiveJvmArgs (  )  ;", "daemonArgs . addAll ( daemonOpts )  ;", "daemonArgs . add (  \"  - cp \"  )  ;", "daemonArgs . add ( CollectionUtils . join ( File . pathSeparator ,    classpath . getAsFiles (  )  )  )  ;", "if    ( Boolean . getBoolean (  \" debug \"  )  )     {", "daemonArgs . add (  \"  - agentlib : jdwp = transport = dt _ socket , server = y , suspend = y , address =  5  0  0  5  \"  )  ;", "}", ". LOGGER . debug (  \" Using   daemon   args :     {  }  \"  ,    daemonArgs )  ;", "daemonArgs . add ( GradleDaemon . class . getName (  )  )  ;", "daemonArgs . add ( GradleVersion . current (  )  . getVersion (  )  )  ;", "StreamByteBuffer   buffer    =    new   StreamByteBuffer (  )  ;", "FlushableEncoder   encoder    =    new   KryoBackedEncoder ( new   EncodedOutput ( buffer . getOutputStream (  )  )  )  ;", "try    {", "encoder . writeString ( daemonParameters . getGradleUserHomeDir (  )  . getAbsolutePath (  )  )  ;", "encoder . writeString ( daemonDir . getBaseDir (  )  . getAbsolutePath (  )  )  ;", "encoder . writeSmallInt ( daemonParameters . getIdleTimeout (  )  )  ;", "encoder . writeSmallInt ( daemonParameters . getPeriodicCheckInterval (  )  )  ;", "encoder . writeBoolean ( singleUse )  ;", "encoder . writeString ( daemonUid )  ;", "encoder . writeSmallInt ( daemonOpts . size (  )  )  ;", "for    ( String   daemonOpt    :    daemonOpts )     {", "encoder . writeString ( daemonOpt )  ;", "}", "encoder . writeSmallInt ( searchClassPath . size (  )  )  ;", "for    ( File   file    :    searchClassPath )     {", "encoder . writeString ( file . getAbsolutePath (  )  )  ;", "}", "encoder . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "InputStream   stdInput    =    buffer . getInputStream (  )  ;", "return   startProcess ( daemonArgs ,    daemonDir . getVersionedDir (  )  ,    stdInput )  ;", "}", "METHOD_END"], "methodName": ["startDaemon"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonStarter"}, {"methodBody": ["METHOD_START", "{", "DefaultDaemonStarter . LOGGER . debug (  \" Starting   daemon   process :    workingDir    =     {  }  ,    daemonArgs :     {  }  \"  ,    workingDir ,    args )  ;", "Timer   clock    =    Time . startTimer (  )  ;", "try    {", "GFileUtils . mkdirs ( workingDir )  ;", "DaemonOutputConsumer   outputConsumer    =    new   DaemonOutputConsumer (  )  ;", "DefaultExecActionFactory   execActionFactory    =    new   DefaultExecActionFactory ( new   IdentityFileResolver (  )  )  ;", "try    {", "ExecHandle   handle    =    new   DaemonExecHandleBuilder (  )  . build ( args ,    workingDir ,    outputConsumer ,    stdInput ,    execActionFactory . newExec (  )  )  ;", "handle . start (  )  ;", "DefaultDaemonStarter . LOGGER . debug (  \" Gradle   daemon   process   is   starting .    Waiting   for   the   daemon   to   detach .  .  .  \"  )  ;", "handle . waitForFinish (  )  ;", "DefaultDaemonStarter . LOGGER . debug (  \" Gradle   daemon   process   is   now   detached .  \"  )  ;", "}    finally    {", "execActionFactory . stop (  )  ;", "}", "return   daemonGreeter . parseDaemonOutput ( outputConsumer . getProcessOutput (  )  )  ;", "}    catch    ( GradleException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException (  \" Could   not   start   Gradle   daemon .  \"  ,    e )  ;", "}    finally    {", "DefaultDaemonStarter . LOGGER . info (  \" An   attempt   to   start   the   daemon   took    {  }  .  \"  ,    clock . getElapsed (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["startProcess"], "fileName": "org.gradle.launcher.daemon.client.DefaultDaemonStarter"}, {"methodBody": ["METHOD_START", "{", "lifecycleLock . lock (  )  ;", "try    {", "if    ( started )     {", "throw   new   IllegalStateException (  \" input   forwarder   has   already   been   started \"  )  ;", "}", "disconnectableInput    =    new   DisconnectableInputStream ( input ,    bufferSize )  ;", "outputBuffer    =    new   internal . io . LineBufferingOutputStream ( handler ,    bufferSize )  ;", "forwardingExecuter    =    executorFactory . create (  \" Forward   input \"  )  ;", "forwardingExecuter . execute ( new   Runnable (  )     {", "public   void   run (  )     {", "byte [  ]    buffer    =    new   byte [ bufferSize ]  ;", "int   readCount ;", "Throwable   readFailure    =    null ;", "try    {", "while    ( true )     {", "try    {", "readCount    =    disconnectableInput . read ( buffer ,     0  ,    bufferSize )  ;", "if    ( readCount    <     0  )     {", "break ;", "}", "}    catch    ( AsynchronousCloseException   e )     {", "break ;", "}    catch    ( IOException   e )     {", "readFailure    =    e ;", "break ;", "}", "outputBuffer . write ( buffer ,     0  ,    readCount )  ;", "}", "outputBuffer . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    finally    {", "handler . endOfStream ( readFailure )  ;", "}", "}", "}  )  ;", "started    =    true ;", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.client.InputForwarder"}, {"methodBody": ["METHOD_START", "{", "lifecycleLock . lock (  )  ;", "try    {", "if    (  !  ( stopped )  )     {", "try    {", "disconnectableInput . close (  )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "fingExecuter . stop (  )  ;", "stopped    =    true ;", "}", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.client.InputForwarder"}, {"methodBody": ["METHOD_START", "{", "if    ( parameters . getEffectiveJvm (  )  . equals ( Jvm . current (  )  )  )     {", "return ;", "}", "Java   java    =    versionDetector . getJava ( parameters . getEffectiveJvm (  )  )  ;", "UnsupportedJavaRuntimeException . assertUsing (  \" Gradle \"  ,    VERSION _  1  _  7  ,    java )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.launcher.daemon.client.JvmVersionValidator"}, {"methodBody": ["METHOD_START", "{", "final   List < DaemonInfo >    daemons    =    daemonRegistry . getAll (  )  ;", "final   List < Status >    statuses    =    Lists . newArrayList (  )  ;", "for    ( DaemonInfo   daemon    :    daemons )     {", "DaemonClientConnection   connection    =    connector . maybeConnect ( daemon )  ;", "if    ( connection    !  =    null )     {", "try    {", "final   ReportStatus   statusCommand    =    new   ReportStatus ( idGenerator . generateId (  )  ,    daemon . getToken (  )  )  ;", "final   Status   status    =    reportStatusDispatcher . dispatch ( connection ,    statusCommand )  ;", "if    ( status    !  =    null )     {", "statuses . add ( status )  ;", "} else    {", "statuses . add ( new   Status ( connection . getDaemon (  )  . getPid (  )  ,     \" UNKNOWN \"  ,     \" UNKNOWN \"  )  )  ;", "}", "}    finally    {", "connection . stop (  )  ;", "}", "}", "}", "final   List < DaemonStopEvent >    stopEvents    =    DaemonStopEvents . uniqueRecentDaemonStopEvents ( daemonRegistry . getStopEvents (  )  )  ;", "if    ( statuses . isEmpty (  )  )     {", ". LOGGER . quiet ( DaemonMessages . NO _ DAEMONS _ RUNNING )  ;", "}", "if    (  !  (  ( statuses . isEmpty (  )  )     &  &     ( stopEvents . isEmpty (  )  )  )  )     {", ". LOGGER . quiet ( String . format (  . STATUS _ FORMAT ,     \" PID \"  ,     \" STATUS \"  ,     \" INFO \"  )  )  ;", "}", "printRunningDaemons ( statuses )  ;", "printStoppedDaemons ( stopEvents )  ;", ". LOGGER . quiet (  \"  \"  )  ;", ". LOGGER . quiet (  (  (  (  . STATUS _ FOOTER )     +     \"    See    \"  )     +     ( documentationRegistry . getDocumentationFor (  \" gradle _ daemon \"  ,     \" sec : status \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["listAll"], "fileName": "org.gradle.launcher.daemon.client.ReportDaemonStatusClient"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( statuses . isEmpty (  )  )  )     {", "for    ( Status   status    :    statuses )     {", "Long   pid    =    status . getPid (  )  ;", ". LOGGER . quiet ( String . format (  . STATUS _ FORMAT ,     ( pid    =  =    null    ?     \" PID   unknown \"     :    pid )  ,    status . getStatus (  )  ,    status . getVersion (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printRunningDaemons"], "fileName": "org.gradle.launcher.daemon.client.ReportDaemonStatusClient"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( stopEvents . isEmpty (  )  )  )     {", "for    ( DaemonStopEvent   event    :    stopEvents )     {", "Long   pid    =    event . getPid (  )  ;", ". LOGGER . quiet ( String . format (  . STATUS _ FORMAT ,     ( pid    =  =    null    ?     \" PID   unknown \"     :    pid )  ,     \" STOPPED \"  ,     (  (  \"  (  \"     +     ( event . getReason (  )  )  )     +     \"  )  \"  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printStoppedDaemons"], "fileName": "org.gradle.launcher.daemon.client.ReportDaemonStatusClient"}, {"methodBody": ["METHOD_START", "{", "Status   returnedStatus    =    null ;", "Throwable   failure    =    null ;", "try    {", "connection . dispatch ( statusCommand )  ;", "Result   result    =     (  ( Result )     ( connection . receive (  )  )  )  ;", "if    ( result   instanceof   Failure )     {", "failure    =     (  ( Failure )     ( result )  )  . getValue (  )  ;", "} else", "if    ( result   instanceof   protocol . Success )     {", "returnedStatus    =     (  ( Status )     ( result . getValue (  )  )  )  ;", "}", "connection . dispatch ( new   Finished (  )  )  ;", "}    catch    ( Throwable   e )     {", "failure    =    e ;", "}", "if    ( failure    !  =    null )     {", "ReportStatusDispatcher . LOGGER . debug ( String . format (  \" Unable   to   get   status   of    % s .  \"  ,    connection )  ,    failure )  ;", "}", "return   returnedStatus ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.launcher.daemon.client.ReportStatusDispatcher"}, {"methodBody": ["METHOD_START", "{", "Throwable   failure    =    null ;", "try    {", "connection . dispatch ( stopCommand )  ;", "Result   result    =     (  ( Result )     ( connection . receive (  )  )  )  ;", "if    ( result   instanceof   Failure )     {", "failure    =     (  ( Failure )     ( result )  )  . getValue (  )  ;", "}", "connection . dispatch ( new   Finished (  )  )  ;", "}    catch    ( Throwable   e )     {", "failure    =    e ;", "}", "if    ( failure    !  =    null )     {", ". LOGGER . lifecycle ( DaemonMessages . UNABLE _ TO _ STOP _ DAEMON )  ;", ". LOGGER . debug ( String . format (  \" Unable   to   complete   stop   daemon   using    % s .  \"  ,    connection )  ,    failure )  ;", "}", "return   failure    =  =    null ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.launcher.daemon.client.StopDispatcher"}, {"methodBody": ["METHOD_START", "{", "boolean   javaHomeMatch    =    getJvm (  )  . equals ( requiredBuildParameters . getEffectiveJvm (  )  )  ;", "boolean   immutableJvmArgsMatch    =    true ;", "if    ( requiredBuildParameters . hasUserDefinedImmutableJvmArgs (  )  )     {", "immutableJvmArgsMatch    =    getJvmOptions (  )  . getAllImmutableJvmArgs (  )  . equals ( requiredBuildParameters . getEffectiveSingleUseJvmArgs (  )  )  ;", "}", "if    ( javaHomeMatch    &  &    immutableJvmArgsMatch )     {", "Properties   properties    =    new   Properties (  )  ;", "properties . putAll ( requiredBuildParameters . getEffectiveSystemProperties (  )  )  ;", "System . setProperties ( properties )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["configureForBuild"], "fileName": "org.gradle.launcher.daemon.configuration.BuildProcess"}, {"methodBody": ["METHOD_START", "{", "return   DaemonBuildOptions . options ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonBuildOptions"}, {"methodBody": ["METHOD_START", "{", "List < String >    immutableDaemonParameters    =    new   ArrayList < String >  (  )  ;", "formatSystemProperties ( getImmutableDaemonProperties (  )  ,    immutableDaemonParameters )  ;", "final   List < String >    jvmArgs    =    getAllImmutableJvmArgs (  )  ;", "jvmArgs . removeAll ( immutableDaemonParameters )  ;", "return   jvmArgs ;", "}", "METHOD_END"], "methodName": ["getAllSingleUseImmutableJvmArgs"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonJvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . filter ( immutableSystemProperties ,    new   Spec < Map . Entry < String ,    Object >  >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( Map . Entry < String ,    Object >    element )     {", "return    . IMMUTABLE _ DAEMON _ SYSTEM _ PROPERTIES . contains ( element . getKey (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getImmutableDaemonProperties"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonJvmOptions"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,     ?  >    entry    :    systemProperties . entrySet (  )  )     {", "if    (  . IMMUTABLE _ DAEMON _ SYSTEM _ PROPERTIES . contains ( entry . getKey (  )  )  )     {", "immutableSystemProperties . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["handleDaemonImmutableProperties"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonJvmOptions"}, {"methodBody": ["METHOD_START", "{", "if    ( DaemonJvmOptions . IMMUTABLE _ DAEMON _ SYSTEM _ PROPERTIES . contains ( name )  )     {", "immutableSystemProperties . put ( name ,    value )  ;", "} else    {", "super . systemProperty ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["systemProperty"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonJvmOptions"}, {"methodBody": ["METHOD_START", "{", "if    ( hasJvmArgs )     {", "return ;", "}", "if    (  ( compareTo ( VERSION _  1  _  8  )  )     >  =     0  )     {", "jvmOptions . jvmArgs (  . DEFAULT _ JVM _  8  _ ARGS )  ;", "} else    {", "jvmOptions . jvmArgs (  . DEFAULT _ JVM _ ARGS )  ;", "}", "}", "METHOD_END"], "methodName": ["applyDefaultsFor"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   jvmOptions . getDebug (  )  ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   jvm ;", "}", "METHOD_END"], "methodName": ["getEffectiveJvm"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   jvmOptions . getAllImmutableJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getEffectiveJvmArgs"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   jvmOptions . getAllSingleUseImmutableJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getEffectiveSingleUseJvmArgs"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    systemProperties    =    new   HashMap < String ,    String >  (  )  ;", "GUtil . addToMap ( systemProperties ,    jvmOptions . getMutableSystemProperties (  )  )  ;", "GUtil . addToMap ( systemProperties ,    jvmOptions . getImmutableroperties (  )  )  ;", "GUtil . addToMap ( systemProperties ,    System . getProperties (  )  )  ;", "return   systemProperties ;", "}", "METHOD_END"], "methodName": ["getEffectiveSystemProperties"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   envVariables ;", "}", "METHOD_END"], "methodName": ["getEnvironmentVariables"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   gradleUserHomeDir ;", "}", "METHOD_END"], "methodName": ["getGradleUserHomeDir"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   idleTimeout ;", "}", "METHOD_END"], "methodName": ["getIdleTimeout"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   periodicCheckInterval ;", "}", "METHOD_END"], "methodName": ["getPeriodicCheckInterval"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    systemProperties    =    new   HashMap < String ,    String >  (  )  ;", "GUtil . addToMap ( systemProperties ,    jvmOps . getMutableSystemProperties (  )  )  ;", "return   systemProperties ;", "}", "METHOD_END"], "methodName": ["getSystemProperties"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   userDefinedImmutableJvmArgs ;", "}", "METHOD_END"], "methodName": ["hasUserDefinedImmutableJvmArgs"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   foreground ;", "}", "METHOD_END"], "methodName": ["isForeground"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   interactive ;", "}", "METHOD_END"], "methodName": ["isInteractive"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["isStatus"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return   stop ;", "}", "METHOD_END"], "methodName": ["isStop"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . baseDir    =    baseDir ;", "rurn   this ;", "}", "METHOD_END"], "methodName": ["setBaseDir"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "userDefinedImmutableJvmArgs    =     ( userDefinedImmutableJvmArgs )     |  |    debug ;", "jvmOps . setDebug ( debug )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . enabled    =    enabled ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . envVariables    =     ( envVariables    =  =    null )     ?    new   HashMap < String ,    String >  ( System . getenv (  )  )     :    envVariables ;", "}", "METHOD_END"], "methodName": ["setEnvironmentVariables"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . foreground    =    foreground ;", "}", "METHOD_END"], "methodName": ["setForeground"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . idleTimeout    =    idleTimeout ;", "}", "METHOD_END"], "methodName": ["setIdleTimeout"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . jvm    =     ( jvm    =  =    null )     ?    Jvm . current (  )     :    jvm ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJvm"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "hasJvmArgs    =    true ;", "List < String >    immutableBefore    =    jvmOps . getAllImmutableJvmArgs (  )  ;", "jvmOps . setAllJvmArgs ( jvmArgs )  ;", "List < String >    immutableAfter    =    jvmOps . getAllImmutableJvmArgs (  )  ;", "userDefinedImmutableJvmArgs    =     ( userDefinedImmutableJvmArgs )     |  |     (  !  ( immutableBefore . equals ( immutableAfter )  )  )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . periodicCheckInterval    =    periodicCheckInterval ;", "}", "METHOD_END"], "methodName": ["setPeriodicCheckInterval"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . status    =    status ;", "}", "METHOD_END"], "methodName": ["setStatus"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "this . stop    =    stop ;", "}", "METHOD_END"], "methodName": ["setStop"], "fileName": "org.gradle.launcher.daemon.configuration.DaemonParameters"}, {"methodBody": ["METHOD_START", "{", "return    ( potentialContext . getDaemonOpts (  )  . containsAll ( desiredContext . getDaemonOpts (  )  )  )     &  &     (  ( potentialContext . getDaemonOpts (  )  . size (  )  )     =  =     ( desiredContext . getDaemonOpts (  )  . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["daemonOptsMatch"], "fileName": "org.gradle.launcher.daemon.context.DaemonCompatibilitySpec"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  \" Wanted :     \"     +     ( this )  )     +     \"  \\ n \"  )     +     \" Actual :     \"  )     +    context )     +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["description"], "fileName": "org.gradle.launcher.daemon.context.DaemonCompatibilitySpec"}, {"methodBody": ["METHOD_START", "{", "return    ( whyUnsatisfied ( potentialContext )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isSatisfiedBy"], "fileName": "org.gradle.launcher.daemon.context.DaemonCompatibilitySpec"}, {"methodBody": ["METHOD_START", "{", "return   canonicalize ( potentialContext . getJavaHome (  )  )  . equals ( canonicalize ( desiredContext . getJavaHome (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["javaHomeMatches"], "fileName": "org.gradle.launcher.daemon.context.DaemonCompatibilitySpec"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( javaHomeMatches ( context )  )  )     {", "return    \" Java   home   is   different .  \\ n \"     +     ( description ( context )  )  ;", "} else", "if    (  !  ( daemonOptsMatch ( context )  )  )     {", "return    \" At   least   one   daemon   option   is   different .  \\ n \"     +     ( description ( context )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["whyUnsatisfied"], "fileName": "org.gradle.launcher.daemon.context.DaemonCompatibilitySpec"}, {"methodBody": ["METHOD_START", "{", "if    (  ( daemonRegistryDir )     =  =    null )     {", "throw   new   IllegalStateException (  \" Registry   dir   must   be   specified .  \"  )  ;", "}", "return   new   Default ( uid ,    javaHome ,    daemonRegistryDir ,    pid ,    idleTimeout ,    daemonOpts )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   daemonOpts ;", "}", "METHOD_END"], "methodName": ["getDaemonOpts"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . daemonRegistryDir ;", "}", "METHOD_END"], "methodName": ["getDaemonRegistryDir"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   idleTimeout ;", "}", "METHOD_END"], "methodName": ["getIdleTimeout"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   javaHome ;", "}", "METHOD_END"], "methodName": ["getJavaHome"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   locale ;", "}", "METHOD_END"], "methodName": ["getLocale"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   pid ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   uid ;", "}", "METHOD_END"], "methodName": ["getUid"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . daemonOpts    =    daemonOpts ;", "}", "METHOD_END"], "methodName": ["setDaemonOpts"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . daemonRegistryDir    =    daemonRegistryDir ;", "}", "METHOD_END"], "methodName": ["setDaemonRegistryDir"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . idleTimeout    =    idleTimeout ;", "}", "METHOD_END"], "methodName": ["setIdleTimeout"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . javaHome    =    javaHome ;", "}", "METHOD_END"], "methodName": ["setJavaHome"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . locale    =    locale ;", "}", "METHOD_END"], "methodName": ["setLocale"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . pid    =    pid ;", "}", "METHOD_END"], "methodName": ["setPid"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "this . uid    =    uid ;", "}", "METHOD_END"], "methodName": ["setUid"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "setJavaHome ( daemonParameters . getEffectiveJvm (  )  . getJavaHome (  )  )  ;", "setDaemonOpts ( daemonParameters . getEffectiveJvmArgs (  )  )  ;", "}", "METHOD_END"], "methodName": ["useDaemonParameters"], "fileName": "org.gradle.launcher.daemon.context.DaemonContextBuilder"}, {"methodBody": ["METHOD_START", "{", "return   daemonOpts ;", "}", "METHOD_END"], "methodName": ["getDaemonOpts"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   daemonRegistryDir ;", "}", "METHOD_END"], "methodName": ["getDaemonRegistryDir"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   idleTimeout ;", "}", "METHOD_END"], "methodName": ["getIdleTimeout"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   javaHome ;", "}", "METHOD_END"], "methodName": ["getJavaHome"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   pid ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   uid ;", "}", "METHOD_END"], "methodName": ["getUid"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" DefaultDaemonContext [ uid =  % s , javaHome =  % s , daemonRegistryDir =  % s , pid =  % s , idleTimeout =  % s , daemonOpts =  % s ]  \"  ,    uid ,    javaHome ,    daemonRegistryDir ,    pid ,    idleTimeout ,    Joiner . on (  '  ,  '  )  . join ( daemonOpts )  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.launcher.daemon.context.DefaultDaemonContext"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \" Daemon   pid :     \"     +     ( pid )  )     +     \"  \\ n \"  )     +     \"       log   file :     \"  )     +     ( daemonLog )  )     +     \"  \\ n \"  )     +     ( tailDaemonLog (  )  )  ;", "}", "METHOD_END"], "methodName": ["describe"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonDiagnostics"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \"  -  -  -  -  -    Last       \"     +     ( DaemonDiagnostics . TAIL _ SIZE )  )     +     \"    lines   from   daemon   log   file    -     \"  )     +     ( getDaemonLog (  )  . getName (  )  )  )     +     \"     -  -  -  -  -  \\ n \"  )     +    tail )     +     \"  -  -  -  -  -    End   of   the   daemon   log    -  -  -  -  -  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["formatTail"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonDiagnostics"}, {"methodBody": ["METHOD_START", "{", "return   daemonLog ;", "}", "METHOD_END"], "methodName": ["getDaemonLog"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonDiagnostics"}, {"methodBody": ["METHOD_START", "{", "return   pid ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonDiagnostics"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   tail    =    GFileUtils . tail ( getDaemonLog (  )  ,     . TAIL _ SIZE )  ;", "return   formatTail ( tail )  ;", "}    catch    ( GFileUtils   e )     {", "return    (  (  \" Unable   to   read   from   the   daemon   log   file :     \"     +     ( getDaemonLog (  )  . getAbsolutePath (  )  )  )     +     \"  ,    because   of :     \"  )     +     ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["tailDaemonLog"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonDiagnostics"}, {"methodBody": ["METHOD_START", "{", "if    (  (     =  =    null )     {", "return    (  \" Daemon   uid :     \"     +     ( uid )  )     +     \"    without    \"  ;", "} else    {", "return    (  (  \" Daemon   uid :     \"     +     ( uid )  )     +     \"    with    \\ n \"  )     +     ( describe (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["describe"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonStartupInfo"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonStartupInfo"}, {"methodBody": ["METHOD_START", "{", "return   diagnostics ;", "}", "METHOD_END"], "methodName": ["getDiagnostics"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonStartupInfo"}, {"methodBody": ["METHOD_START", "{", "return   diagnostics . getPid (  )  ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonStartupInfo"}, {"methodBody": ["METHOD_START", "{", "return   uid ;", "}", "METHOD_END"], "methodName": ["getUid"], "fileName": "org.gradle.launcher.daemon.diagnostics.DaemonStartupInfo"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "org.gradle.launcher.daemon.protocol.Build"}, {"methodBody": ["METHOD_START", "{", "return   buildClientMetaData ;", "}", "METHOD_END"], "methodName": ["getBuildClientMetaData"], "fileName": "org.gradle.launcher.daemon.protocol.Build"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildRequestMetaData ( buildClientMetaData ,    startTime )  ;", "}", "METHOD_END"], "methodName": ["getBuildRequestMetaData"], "fileName": "org.gradle.launcher.daemon.protocol.Build"}, {"methodBody": ["METHOD_START", "{", "return   parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.gradle.launcher.daemon.protocol.Build"}, {"methodBody": ["METHOD_START", "{", "return   startTime ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.launcher.daemon.protocol.Build"}, {"methodBody": ["METHOD_START", "{", "return   payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.gradle.launcher.daemon.protocol.BuildEvent"}, {"methodBody": ["METHOD_START", "{", "return   diagnostics ;", "}", "METHOD_END"], "methodName": ["getDiagnostics"], "fileName": "org.gradle.launcher.daemon.protocol.BuildStarted"}, {"methodBody": ["METHOD_START", "{", "return   identifier ;", "}", "METHOD_END"], "methodName": ["getIdentifier"], "fileName": "org.gradle.launcher.daemon.protocol.Command"}, {"methodBody": ["METHOD_START", "{", "return   token ;", "}", "METHOD_END"], "methodName": ["getToken"], "fileName": "org.gradle.launcher.daemon.protocol.Command"}, {"methodBody": ["METHOD_START", "{", "BaseSerializerFactory   factory    =    new   BaseSerializerFactory (  )  ;", "Serializer < LogLevel >    logLevelSerializer    =    factory . getSerializerFor ( LogLevel . class )  ;", "Serializer < Throwable >    throwableSerializer    =    factory . getSerializerFor ( Throwable . class )  ;", "DefaultSerializerRegistry   registry    =    new   DefaultSerializerRegistry (  )  ;", "registry . register ( Build . class ,    new    . BuildSerializer ( buildActionSerializer )  )  ;", "registry . register ( Cancel . class ,    new    . CancelSerializer (  )  )  ;", "registry . register ( DaemonUnavailable . class ,    new    . DaemonUnavailableSerializer (  )  )  ;", "registry . register ( BuildStarted . class ,    new    . BuildStartedSerializer (  )  )  ;", "registry . register ( Failure . class ,    new    . FailureSerializer ( throwableSerializer )  )  ;", "registry . register ( Success . class ,    new    . SuccessSerializer (  )  )  ;", "registry . register ( Finished . class ,    new    . FinishedSerializer (  )  )  ;", "registry . register ( BuildEvent . class ,    new    . BuildEventSerializer (  )  )  ;", "registry . register ( ForwardInput . class ,    new    . ForwardInputSerializer (  )  )  ;", "registry . register ( CloseInput . class ,    new    . CloseInputSerializer (  )  )  ;", "registry . register ( LogEvent . class ,    new   LogEventSerializer ( logLevelSerializer ,    throwableSerializer )  )  ;", "registry . register ( UserInputRequestEvent . class ,    new   UserInputRequestEventSerializer (  )  )  ;", "registry . register ( UserInputResumeEvent . class ,    new   UserInputResumeEventSerializer (  )  )  ;", "registry . register ( StyledTextOutputEvent . class ,    new   StyledTextOutputEventSerializer ( logLevelSerializer ,    new   ListSerializer < StyledTextOutputEvent . Span >  ( new   SpanSerializer ( factory . getSerializerFor ( Style . class )  )  )  )  )  ;", "registry . register ( ProgressStartEvent . class ,    new   ProgressStartEventSerializer (  )  )  ;", "registry . register ( ProgressCompleteEvent . class ,    new   ProgressCompleteEventSerializer (  )  )  ;", "registry . register ( ProgressEvent . class ,    new   ProgressEventSerializer (  )  )  ;", "registry . register ( LogLevelChangeEvent . class ,    new   LogLevelChangeEventSerializer ( logLevelSerializer )  )  ;", "registry . register ( OutputMessage . class ,    new    . OutputMessageSerializer ( registry . build ( OutputEvent . class )  )  )  ;", "registry . useJavaSerialization ( Message . class )  ;", "return   registry . build ( Message . class )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.launcher.daemon.protocol.DaemonMessageSerializer"}, {"methodBody": ["METHOD_START", "{", "return   reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.gradle.launcher.daemon.protocol.DaemonUnavailable"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" The   value   parameter   of   a   f   cannot   be   null \"  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["assertNotNull"], "fileName": "org.gradle.launcher.daemon.protocol.Failure"}, {"methodBody": ["METHOD_START", "{", "return   bytes ;", "}", "METHOD_END"], "methodName": ["getBytes"], "fileName": "org.gradle.launcher.daemon.protocol.ForwardInput"}, {"methodBody": ["METHOD_START", "{", "return   event ;", "}", "METHOD_END"], "methodName": ["getEvent"], "fileName": "org.gradle.launcher.daemon.protocol.OutputMessage"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.launcher.daemon.protocol.Result"}, {"methodBody": ["METHOD_START", "{", "return   pid ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.protocol.Status"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.launcher.daemon.protocol.Status"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.launcher.daemon.protocol.Status"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.launcher.daemon.registry.DaemonDir"}, {"methodBody": ["METHOD_START", "{", "return   registryFile ;", "}", "METHOD_END"], "methodName": ["getRegistry"], "fileName": "org.gradle.launcher.daemon.registry.DaemonDir"}, {"methodBody": ["METHOD_START", "{", "return   versionedDir ;", "}", "METHOD_END"], "methodName": ["getVersionedDir"], "fileName": "org.gradle.launcher.daemon.registry.DaemonDir"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   context ;", "}", "METHOD_END"], "methodName": ["getContext"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   new   Date ( lastBusy )  ;", "}", "METHOD_END"], "methodName": ["getLastBusy"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   context . getPid (  )  ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   state ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   token ;", "}", "METHOD_END"], "methodName": ["getToken"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "return   context . getUid (  )  ;", "}", "METHOD_END"], "methodName": ["getUid"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( this . state )     =  =     ( DaemonStateControl . State . Idle )  )     |  |     (  ( this . state )     =  =    null )  )     &  &     ( state    =  =     ( DaemonStateControl . State . Busy )  )  )     {", "lastBusy    =    clock . getCurrentTime (  )  ;", "}", "this . state    =    state ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.launcher.daemon.registry.DaemonInfo"}, {"methodBody": ["METHOD_START", "{", "stopEvents . add ( stopEvent )  ;", "}", "METHOD_END"], "methodName": ["addStopEvent"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "return   infosMap . get ( address )  ;", "}", "METHOD_END"], "methodName": ["getInfo"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedList < DaemonInfo >  ( infosMap . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getInfos"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "return   stopEvents ;", "}", "METHOD_END"], "methodName": ["getStopEvents"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "infosMap . remove ( address )  ;", "}", "METHOD_END"], "methodName": ["removeInfo"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "stopEvents . removeAll ( events )  ;", "}", "METHOD_END"], "methodName": ["removeStopEvents"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "infosMap . put ( address ,    daemonInfo )  ;", "}", "METHOD_END"], "methodName": ["setStatus"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryContent"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonDir ( daemonBaseDir )  ;", "}", "METHOD_END"], "methodName": ["createDaemonDir"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryServices"}, {"methodBody": ["METHOD_START", "{", "final   File   daemonRegistryFile    =    daemonDir . getRegistry (  )  ;", "return   daemonRegistryCache . get ( daemonRegistryFile ,    new   Factory <  >  (  )     {", "public      create (  )     {", "return   new   Persistent ( daemonRegistryFile ,    fileLockManager ,    chmod )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonRegistry"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryServices"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperties (  )  ;", "}", "METHOD_END"], "methodName": ["createProperties"], "fileName": "org.gradle.launcher.daemon.registry.DaemonRegistryServices"}, {"methodBody": ["METHOD_START", "{", "return   pid ;", "}", "METHOD_END"], "methodName": ["getPid"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reason )     =  =    null )     {", "return    \"  \"  ;", "}", "return   reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvent"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvent"}, {"methodBody": ["METHOD_START", "{", "return   timestamp ;", "}", "METHOD_END"], "methodName": ["getTimestamp"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvent"}, {"methodBody": ["METHOD_START", "{", "Calendar   cal    =    Calendar . getInstance (  )  ;", "cal . setTime ( new   Date ( System . currTimeMillis (  )  )  )  ;", "cal . add ( Calendar . HOUR _ OF _ DAY ,     (  (  -  1  )     *    numHours )  )  ;", "return   timestamp . after ( cal . getTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["occurredInLastHours"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvent"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . filter ( stopEvents ,    new   Spec < DaemonStopEvent >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DaemonStopEvent   event )     {", "return    !  ( event . occurredInLastHours (  . RECENTLY )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["oldStopEvents"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvents"}, {"methodBody": ["METHOD_START", "{", "final   Set < Long >    uniqueStoppedPids    =    new   HashSet < Long >  ( stopEvents . size (  )  )  ;", "final   List < DaemonStopEvent >    recentStopEvents    =    new   ArrayList < DaemonStopEvent >  ( stopEvents . size (  )  )  ;", "final   List < DaemonStopEvent >    sortedEvents    =    CollectionUtils . sort ( stopEvents ,    new   Comparator < DaemonStopEvent >  (  )     {", "@ Override", "public   int   compare ( DaemonStopEvent   event 1  ,    DaemonStopEvent   event 2  )     {", "if    (  (  ( event 1  . getStatus (  )  )     !  =    null )     &  &     (  ( event 2  . getStatus (  )  )     =  =    null )  )     {", "return    -  1  ;", "} else", "if    (  (  ( event 1  . getStatus (  )  )     =  =    null )     &  &     (  ( event 2  . getStatus (  )  )     !  =    null )  )     {", "return    1  ;", "} else", "if    (  (  ( event 1  . getStatus (  )  )     !  =    null )     &  &     (  ( event 2  . getStatus (  )  )     !  =    null )  )     {", "return   event 2  . getStatus (  )  . compareTo ( event 1  . getStatus (  )  )  ;", "}", "return    0  ;", "}", "}  )  ;", "for    ( DaemonStopEvent   event    :    sortedEvents )     {", "Long   pid    =    event . getPid (  )  ;", "if    (  ( event . occurredInLastHours (  . RECENTLY )  )     &  &     (  !  ( uniqueStoppedPids . contains ( pid )  )  )  )     {", "if    ( pid    !  =    null )     {", "uniqueStoppedPids . add ( pid )  ;", "}", "recentStopEvents . add ( event )  ;", "}", "}", "return   recentStopEvents ;", "}", "METHOD_END"], "methodName": ["uniqueRecentDaemonStopEvents"], "fileName": "org.gradle.launcher.daemon.registry.DaemonStopEvents"}, {"methodBody": ["METHOD_START", "{", "List < DaemonInfo >    matches    =    new   ArrayList < DaemonInfo >  (  )  ;", "for    ( DaemonInfo   daemonInfo    :    daemonInfos . values (  )  )     {", "if    ( spec . isSatisfiedBy ( daemonInfo )  )     {", "matches . add ( daemonInfo )  ;", "}", "}", "return   matches ;", "}", "METHOD_END"], "methodName": ["daemonInfosOfEntriesMatching"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   daemonInfosOfEntriesMatching ( allSpec )  ;", "}", "METHOD_END"], "methodName": ["getAll"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   daemonInfosOfEntriesMatching ( canceledSpec )  ;", "}", "METHOD_END"], "methodName": ["getCanceled"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   daemonInfosOfEntriesMatching ( idleSpec )  ;", "}", "METHOD_END"], "methodName": ["getIdle"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   daemonInfosOfEntriesMatching ( busySpec )  ;", "}", "METHOD_END"], "methodName": ["getNotIdle"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "synchronized ( daemonInfos )     {", "daemonInfos . get ( address )  . setState ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["markState"], "fileName": "org.gradle.launcher.daemon.registry.EmbeddedDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "Content   content    =    cache . get (  )  ;", "if    ( content    =  =    null )     {", "return   new   LinkedList < DaemonInfo >  (  )  ;", "}", "return   content . getInfos (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAll"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   getDaemonsMatching ( new   Spec < DaemonInfo >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DaemonInfo   daemonInfo )     {", "return    ( daemonInfo . getState (  )  )     =  =     ( DaemonStateControl . State . Canceled )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getCanceled"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "List < Info >    out    =    new   LinkedList < Info >  (  )  ;", "List < Info >    all    =    getAll (  )  ;", "for    ( Info   d    :    all )     {", "if    ( spec . isSatisfiedBy ( d )  )     {", "out . add ( d )  ;", "}", "}", "return   out ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDaemonsMatching"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   getDaemonsMatching ( new   Spec < DaemonInfo >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DaemonInfo   daemonInfo )     {", "return    ( daemonInfo . getState (  )  )     =  =     ( DaemonStateControl . State . Idle )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getIdle"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   getDaemonsMatching ( new   Spec < DaemonInfo >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DaemonInfo   daemonInfo )     {", "return    ( daemonInfo . getState (  )  )     !  =     ( DaemonStateControl . State . Idle )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getNotIdle"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", ". LOGGER . debug (  \" Marking   busy   by   address :     {  }  \"  ,    address )  ;", "try    {", "cache . update ( new   PersistentStateCache . UpdateAction < DaemonRegistryContent >  (  )     {", "public   DaemonRegistryContent   update ( DaemonRegistryContent   oldValue )     {", "DaemonInfo   daemonInfo    =     ( oldValue    !  =    null )     ?    oldValue . getInfo ( address )     :    null ;", "if    ( daemonInfo    !  =    null )     {", "daemonInfo . setState ( state )  ;", "}", "return   oldValue ;", "}", "}  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["markState"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", ". LOGGER . debug (  \" Removing   daemon   address :     {  }  \"  ,    address )  ;", "try    {", "cache . update ( new   PersistentStateCache . UpdateAction < DaemonRegistryContent >  (  )     {", "public   DaemonRegistryContent   update ( DaemonRegistryContent   oldValue )     {", "if    ( oldValue    =  =    null )     {", "return   oldValue ;", "}", "oldValue . removeInfo ( address )  ;", "return   oldValue ;", "}", "}  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "final   Address   address    =    info . getAddress (  )  ;", "final   DaemonContext   daemonContext    =    info . getContext (  )  ;", "final   byte [  ]    token    =    info . getToken (  )  ;", "final   DaemonStateControl . State   state    =    info . getState (  )  ;", "lock . lock (  )  ;", ". LOGGER . debug (  \" Storing   daemon   address :     {  }  ,    context :     {  }  \"  ,    address ,    daemonContext )  ;", "try    {", "cache . update ( new   PersistentStateCache . UpdateAction < DaemonRegistryContent >  (  )     {", "public   DaemonRegistryContent   update ( DaemonRegistryContent   oldValue )     {", "if    ( oldValue    =  =    null )     {", "oldValue    =    new   DaemonRegistryContent (  )  ;", "}", "DaemonInfo   daemonInfo    =    new   DaemonInfo ( address ,    daemonContext ,    token ,    state )  ;", "oldValue . setStatus ( address ,    daemonInfo )  ;", "return   oldValue ;", "}", "}  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["store"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" PersistentDaemonRegistry [ file =  % s ]  \"  ,    registryFile )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.launcher.daemon.registry.PersistentDaemonRegistry"}, {"methodBody": ["METHOD_START", "{", "Daemon . LOGGER . debug (  \" awaitExpiration (  )    called   on   daemon \"  )  ;", "DaemonStateCoordinator   stateCoordinator ;", "lifecycleLock . lock (  )  ;", "try    {", "if    (  ( this . stateCoordinator )     =  =    null )     {", "throw   new   IllegalStateException (  \" cannot   await   stop   on   daemon   as   it   has   not   been   started .  \"  )  ;", "}", "stateCoordinator    =    this . stateCoordinator ;", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "stateCoordinator . awaitStop (  )  ;", "}", "METHOD_END"], "methodName": ["awaitExpiration"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "return   connectorAddress ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "return   daemonContext ;", "}", "METHOD_END"], "methodName": ["getDaemonContext"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "return   this . daemonRegistry ;", "}", "METHOD_END"], "methodName": ["getDaemonRegistry"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "return   stateCoordinator ;", "}", "METHOD_END"], "methodName": ["getStateCoordinator"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "return   daemonContext . getUid (  )  ;", "}", "METHOD_END"], "methodName": ["getUid"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "Daemon . DaemonExpirationPeriodicCheck   periodicCheck    =    new   Daemon . DaemonExpirationPeriodicCheck ( expirationStrategy ,    listenerManager )  ;", "listenerManager . addListener ( new   Daemon . DefaultDaemonExpirationListener ( stateCoordinator ,    registryUpdater )  )  ;", "scheduledExecutorService . scheduleAtFixedRate ( periodicCheck ,    checkIntervalMills ,    checkIntervalMills ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["scheduleExpirationChecks"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "Daemon . LOGGER . info (  \" start (  )    called   on   daemon    -     {  }  \"  ,    daemonContext )  ;", "lifecycleLock . lock (  )  ;", "try    {", "if    (  ( stateCoordinator )     !  =    null )     {", "throw   new   IllegalStateException (  \" cannot   start   daemon   as   it   is   already   running \"  )  ;", "}", "SecureRandom   secureRandom    =    new   SecureRandom (  )  ;", "byte [  ]    token    =    new   byte [  1  6  ]  ;", "secureRandom . nextBytes ( token )  ;", "registryUpdater    =    new   DaemonRegistryUpdater ( daemonRegistry ,    daemonContext ,    token )  ;", "ShutdownHookActionRegister . addAction ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "daemonRegistry . remove ( connectorAddress )  ;", "}    catch    ( Exception   e )     {", "Daemon . LOGGER . debug (  \" VM   shutdown   hook   was   unable   to   remove   the   daemon   address   from   the   registry .    It   will   be   cleaned   up   later .  \"  ,    e )  ;", "}", "}", "}  )  ;", "Runnable   onStartCommand    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "registryUpdater . onStartActivity (  )  ;", "}", "}  ;", "Runnable   onFinishCommand    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "registryUpdater . onCompleteActivity (  )  ;", "}", "}  ;", "Runnable   onCancelCommand    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "registryUpdater . onCancel (  )  ;", "}", "}  ;", "stateCoordinator    =    new   DaemonStateCoordinator ( executorFactory ,    onStartCommand ,    onFinishCommand ,    onCancelCommand )  ;", "connectionHandler    =    new   DefaultIncomingConnectionHandler ( commandExecuter ,    daemonContext ,    stateCoordinator ,    executorFactory ,    token )  ;", "Runnable   connectionErrorHandler    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "stateCoordinator . stop (  )  ;", "}", "}  ;", "connectorAddress    =    connector . start ( connectionHandler ,    connectionErrorHandler )  ;", "Daemon . LOGGER . debug (  \" Daemon   starting   at :     {  }  ,    with   address :     {  }  \"  ,    new   Date (  )  ,    connectorAddress )  ;", "registryUpdater . onStart ( connectorAddress )  ;", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "Daemon . LOGGER . lifecycle ( DaemonMessages . PROCESS _ STARTED )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "Daemon . LOGGER . debug (  \" stopOnExpiration (  )    called   on   daemon \"  )  ;", "scheduleExpirationChecks ( expirationStrategy ,    checkIntervalMills )  ;", "awaitExpiration (  )  ;", "}", "METHOD_END"], "methodName": ["stopOnExpiration"], "fileName": "org.gradle.launcher.daemon.server.Daemon"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . info (  \" Marking   the   daemon   as   canceled ,    address :     {  }  \"  ,    connectorAddress )  ;", "try    {", "daemonRegistry . markState ( connectorAddress ,    DaemonStateControl . State . Canceled )  ;", "}    catch    ( DaemonRegistry . EmptyRegistryException   e )     {", "DaemonRegistryUpdater . LOGGER . warn (  \" Cannot   mark   daemon   as   canceled   because   the   registry   is   empty .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["onCancel"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . info (  \" Marking   the   daemon   as   idle ,    address :     {  }  \"  ,    connectorAddress )  ;", "try    {", "daemonRegistry . markState ( connectorAddress ,    DaemonStateControl . State . Idle )  ;", "}    catch    ( DaemonRegistry . EmptyRegistryException   e )     {", "DaemonRegistryUpdater . LOGGER . warn (  \" Cannot   mark   daemon   as   idle   because   the   registry   is   empty .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["onCompleteActivity"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . debug (  \" Storing   daemon   stop   event :     {  }  \"  ,    reason )  ;", "final   Date   timestamp    =    new   Date ( System . currentTimeMillis (  )  )  ;", "daemonRegistry . storeStopEvent ( new   DaemonStopEvent ( timestamp ,    daemonContext . getPid (  )  ,    status ,    reason )  )  ;", "}", "METHOD_END"], "methodName": ["onExpire"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . info (  \"  {  }  {  }  \"  ,    DaemonMessages . ADVERTISING _ DAEMON ,    connectorAddress )  ;", "DaemonRegistryUpdater . LOGGER . debug (  \" Advertised   daemon   context :     {  }  \"  ,    daemonContext )  ;", "this . connectorAddress    =    connectorAddress ;", "daemonRegistry . store ( new   DaemonInfo ( connectorAddress ,    daemonContext ,    token ,    DaemonStateControl . State . Busy )  )  ;", "}", "METHOD_END"], "methodName": ["onStart"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . info (  \" Marking   the   daemon   as   busy ,    address :     {  }  \"  ,    connectorAddress )  ;", "try    {", "daemonRegistry . markState ( connectorAddress ,    DaemonStateControl . State . Busy )  ;", "}    catch    ( DaemonRegistry . EmptyRegistryException   e )     {", "DaemonRegistryUpdater . LOGGER . warn (  \" Cannot   mark   daemon   as   busy   because   the   registry   is   empty .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["onStartActivity"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "DaemonRegistryUpdater . LOGGER . debug (  \" Removing   our   presence   to   clients ,    eg .    removing   this   address   from   the   registry :     {  }  \"  ,    connectorAddress )  ;", "try    {", "daemonRegistry . remove ( connectorAddress )  ;", "}    catch    ( DaemonRegistry . EmptyRegistryException   e )     {", "DaemonRegistryUpdater . LOGGER . warn (  \" Cannot   remove   daemon   from   the   registry   because   the   registry   is   empty .  \"  )  ;", "}", "DaemonRegistryUpdater . LOGGER . debug (  \" Address   removed   from   registry .  \"  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.DaemonRegistryUpdater"}, {"methodBody": ["METHOD_START", "{", "return   BuildActionSerializer . create (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildActionSerializer"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   Daemon ( new   DaemonTcpServerConnector ( get ( ExecutorFactory . class )  ,    get ( InetAddressFactory . class )  ,    DaemonMessageSerializer . create ( buildActionSerializer )  )  ,    get ( DaemonRegistry . class )  ,    get ( DaemonContext . class )  ,    new   DaemonCommandExecuter ( configuration ,    actions )  ,    get ( ExecutorFactory . class )  ,    get ( ListenerManager . class )  )  ;", "}", "METHOD_END"], "methodName": ["createDaemon"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "File   daemonLog    =    getDaemonLogFile (  )  ;", "DaemonDiagnostics   daemonDiagnostics    =    new   DaemonDiagnostics ( daemonLog ,    daemonContext . getPid (  )  )  ;", "return   ImmutableList . of ( new   HandleStop ( get ( ListenerManager . class )  )  ,    new   HandleCancel (  )  ,    new   HandleReportStatus (  )  ,    new   ReturnResult (  )  ,    new   StartBuildOrRespondWithBusy ( daemonDiagnostics )  ,    new   EstablishBuildEnvironment ( processEnvironment )  ,    new   LogToClient ( loggingManager ,    daemonDiagnostics )  ,    new   LogAndCheckHealth ( healthStats ,    healthCheck )  ,    new   ForwardClientInput (  )  ,    new   RequestStopIfSingleUsedDaemon (  )  ,    new   ResetDeprecationLogger (  )  ,    new   WatchForDisconnection (  )  ,    new   ExecuteBuild ( buildActionExecuter ,    runningStats ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonCommandActions"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "DaemonContextBuilder   builder    =    new   DaemonContextBuilder ( get ( ProcessEnvironment . class )  )  ;", "builder . setDaemonRegistryDir ( configuration . getBaseDir (  )  )  ;", "builder . setIdleTimeout ( configuration . getIdleTimeout (  )  )  ;", "builder . setUid ( configuration . getUid (  )  )  ;", ". LOGGER . debug (  \" Creating   daemon   context   with   opts :     {  }  \"  ,    configuration . getJvmOptions (  )  )  ;", "builder . setDaemonOpts ( configuration . getJvmOptions (  )  )  ;", "return   builder . create (  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonContext"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonHealthCheck ( healthExpirationStrategy ,    listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createDaemonHealthCheck"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonHealthStats ( runningStats ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createDaemonHealthStats"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonMemoryStatus ( healthStats )  ;", "}", "METHOD_END"], "methodName": ["createDaemonMemoryStatus"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DaemonRunningStats (  )  ;", "}", "METHOD_END"], "methodName": ["createDaemonRunningStats"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDaemonScanInfo ( runningStats ,    configuration . getIdleTimeout (  )  ,    configuration . isSingleUse (  )  ,    get ( DaemonRegistry . class )  ,    listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createDaemonScanInfo"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   HealthExpirationStrategy ( memoryStatus )  ;", "}", "METHOD_END"], "methodName": ["createHealthExpirationStrategy"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "return   new   MasterExpirationStrategy ( daemon ,    configuration ,    healthExpirationStrategy ,    listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createMasterExpirationStrategy"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "final   DaemonContext   daemonContext    =    get ( DaemonContext . class )  ;", "final   Long   pid    =    daemonContext . getPid (  )  ;", "String   fileName    =     (  \" daemon -  \"     +     ( pid    =  =    null    ?    UUID . randomUUID (  )     :    pid )  )     +     \"  . out . log \"  ;", "return   new   File ( get ( DaemonDir . class )  . getVersionedDir (  )  ,    fileName )  ;", "}", "METHOD_END"], "methodName": ["getDaemonLogFile"], "fileName": "org.gradle.launcher.daemon.server.DaemonServices"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    ( true )     {", "try    {", "switch    ( state )     {", "case   Idle    :", "case   Busy    :", ". LOGGER . debug (  \" daemon   is   running .    Sleeping   until   state   changes .  \"  )  ;", "condition . await (  )  ;", "break ;", "case   Canceled    :", ". LOGGER . debug (  \" cancel   requested .  \"  )  ;", "cancelNow (  )  ;", "break ;", "case   Broken    :", "throw   new   IllegalStateException (  \" This   daemon   is   in   a   broken   state .  \"  )  ;", "case   StopRequested    :", ". LOGGER . debug (  \" daemon   stop   has   been   requested .    Sleeping   until   state   changes .  \"  )  ;", "condition . await (  )  ;", "break ;", "case   Stopped    :", ". LOGGER . debug (  \" daemon   has   stopped .  \"  )  ;", "return   true ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["awaitStop"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "switch    ( state )     {", "case   Idle    :", "case   Busy    :", "case   Canceled    :", "case   Broken    :", "setState ( ntrol . State . StopRequested )  ;", "break ;", "case   StopRequested    :", "case   Stopped    :", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Daemon   is   in   unexpected   state :     \"     +     ( state )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["beginStopping"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "CountdownTimer   timer    =    Time . startCountdownTimer ( cancelTimeoutMs )  ;", ". LOGGER . debug (  \" Cancel   requested :    will   wait   for   daemon   to   become   idle .  \"  )  ;", "try    {", "cancellationToken . cancel (  )  ;", "}    catch    ( Exception   ex )     {", ". LOGGER . error (  \" Cancel   processing   failed .    Will   continue .  \"  ,    ex )  ;", "}", "lock . lock (  )  ;", "try    {", "while    (  !  ( timer . hasExpired (  )  )  )     {", "try    {", "switch    ( state )     {", "case   Idle    :", ". LOGGER . debug (  \" Cancel :    daemon   is   idle   now .  \"  )  ;", "return ;", "case   Busy    :", "case   Canceled    :", "case   StopRequested    :", ". LOGGER . debug (  \" Cancel :    daemon   is   busy ,    sleeping   until   state   changes .  \"  )  ;", "condition . await ( timer . getRemainingMillis (  )  ,    TimeUnit . MILLISECONDS )  ;", "break ;", "case   Broken    :", "throw   new   IllegalStateException (  \" This   daemon   is   in   a   broken   state .  \"  )  ;", "case   Stopped    :", ". LOGGER . debug (  \" Cancel :    daemon   has   stopped .  \"  )  ;", "return ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", ". LOGGER . debug (  \" Cancel :    daemon   is   still   busy   after   grace   period .    Will   force   stop .  \"  )  ;", "stopNow (  \" cancel   requested   but   timed   out \"  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["cancelNow"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state )     =  =     ( DaemonStateControl . State . Idle )  )     {", "return   idleTimer . getElapsedMillis (  )  ;", "} else    {", "return    0 L ;", "}", "}", "METHOD_END"], "methodName": ["getIdleMillis"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "return    (  ( iTimer . getElapsedMillis (  )  )     /     1  0  0  0  )     /     6  0  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getIdleMinutes"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "return    !  (  (  ( state )     =  =     ( DaemonStateControl . State . Idle )  )     |  |     (  ( state )     =  =     ( DaemonStateControl . State . Busy )  )  )  ;", "}", "METHOD_END"], "methodName": ["isWillRefuseNewCommands"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "result    =    failure ;", "conditiignalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onCommandFailed"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "result    =    this ;", "conditiignalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onCommandSuccessful"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", ". LOGGER . debug (  \" Command   execution :    completed    {  }  \"  ,    currentCommandExecution )  ;", "currentCommandExecution    =    null ;", "result    =    null ;", "stopReason    =    null ;", "updateActivityTimestamp (  )  ;", "switch    ( state )     {", "case   Idle    :", "case   Busy    :", "case   Canceled    :", "try    {", "onFinishCommand . run (  )  ;", "setState ( DaemonStateControl . State . Idle )  ;", "}    catch    ( Throwable   throwable )     {", "setState ( DaemonStateControl . State . Broken )  ;", "throw   UncheckedException . throwAsUncheckedException ( throwable )  ;", "}", "break ;", "case   StopRequested    :", "stopNow (  \" command   completed   and   stop   requested \"  )  ;", "break ;", "case   Stopped    :", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Daemon   is   in   unexpected   state :     \"     +     ( state )  )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onFinishCommand"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "switch    ( state )     {", "case   Broken    :", "throw   new   DaemonUnavailableException (  \" This   daemon   is   in   a   broken   state   and   will   stop .  \"  )  ;", "case   StopRequested    :", "throw   new   DaemonUnavailableException (  \" This   daemon   is   currently   stopping .  \"  )  ;", "case   Stopped    :", "throw   new   DaemonUnavailableException (  \" This   daemon   has   stopped .  \"  )  ;", "case   Busy    :", "case   Canceled    :", "throw   new   DaemonUnavailableException ( String . format (  \" This   daemon   is   currently   executing :     % s \"  ,    currentCommandExecution )  )  ;", "}", ". LOGGER . error (  \" Command   execution :    started    {  }    after    {  }    minutes   of   idle \"  ,    commandDisplayName ,    getIdleMinutes (  )  )  ;", "try    {", "setState ( DaemonStateControl . State . Busy )  ;", "onStartCommand . run (  )  ;", "currentCommandExecution    =    commandDisplayName ;", "result    =    null ;", "updateActivityTimestamp (  )  ;", "updateCancellationToken (  )  ;", "condition . signalAll (  )  ;", "}    catch    ( Throwable   throwable )     {", "setState ( DaemonStateControl . State . Broken )  ;", "throw   UncheckedException . throwAsUncheckedException ( throwable )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onStartCommand"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "this . state    =    state ;", "condition . signalAll (  )  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "stopNow (  \" service   stop \"  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "switch    ( state )     {", "case   Idle    :", "case   Busy    :", "case   Canceled    :", "case   Broken    :", "case   StopRequested    :", ". LOGGER . debug (  \" Marking   daemon   stopped   due   to    {  }  .    The   daemon   is   running   a   build :     {  }  \"  ,    reason ,     (  ( state )     =  =     ( DaemonStateControl . State . Busy )  )  )  ;", "stopReason    =    reason ;", "setState ( DaemonStateControl . State . Stopped )  ;", "break ;", "case   Stopped    :", "break ;", "default    :", "throw   new   IllegalStateException (  (  \" Daemon   is   in   unexpected   state :     \"     +     ( state )  )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopNow"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "DaemonStateCoordinator . LOGGER . debug (  \" resetting   idle   timer \"  )  ;", "idleTimer . reset (  )  ;", "}", "METHOD_END"], "methodName": ["updateActivityTimestamp"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "cancellationToken    =    new   DefaultBuildCancellationToken (  )  ;", "cancellationToken . addCallback ( onCancelCommand )  ;", "}", "METHOD_END"], "methodName": ["updateCancellationToken"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  (  (  (  ( state )     =  =     ( DaemonStateControl . State . Busy )  )     |  |     (  ( state )     =  =     ( DaemonStateControl . State . Canceled )  )  )     |  |     (  ( state )     =  =     ( DaemonStateControl . State . StopRequested )  )  )     &  &     (  ( result )     =  =    null )  )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", ". LOGGER . debug (  \" Command   execution :    finished   waiting   for    {  }  .    Result    {  }    with   state    {  }  \"  ,    currentCommandExecution ,    result ,    state )  ;", "if    (  ( result )    instanceof   Throwable )     {", "throw   UncheckedException . throwAsUncheckedException (  (  ( Throwable )     ( result )  )  )  ;", "}", "if    (  ( result )     !  =    null )     {", "return ;", "}", "switch    ( state )     {", "case   Stopped    :", "throw   new   DaemonStoppedException ( stopReason )  ;", "case   Broken    :", "throw   new   DaemonUnavailableException (  \" This   daemon   is   broken   and   will   stop .  \"  )  ;", "default    :", "throw   new   IllegalStateException (  (  \" Daemon   is   in   unexpected   state :     \"     +     ( state )  )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForCommandCompletion"], "fileName": "org.gradle.launcher.daemon.server.DaemonStateCoordinator"}, {"methodBody": ["METHOD_START", "{", "lifecycleLock . lock (  )  ;", "try    {", "if    ( stopped )     {", "throw   new   IllegalStateException (  \" server   connector   cannot   be   started   as   it   is   either   stopping   or   has   been   stopped \"  )  ;", "}", "if    ( started )     {", "throw   new   IllegalStateException (  \" server   connector   cannot   be   started   as   it   has   already   been   started \"  )  ;", "}", "Action < ConnectCompletion >    connectEvent    =    new   Action < ConnectCompletion >  (  )     {", "public   void   execute ( ConnectCompletion   completion )     {", "RemoteConnection < Message >    remoteConnection ;", "try    {", "remoteConnection    =    completion . create ( Serializers . stateful ( serializer )  )  ;", "}    catch    ( UncheckedIOException   e )     {", "connectionErrorHandler . run (  )  ;", "throw   e ;", "}", "handler . handle ( new   SynchronizedDispatchConnection < Message >  ( remoteConnection )  )  ;", "}", "}  ;", "acceptor    =    incoming . accept ( connectEvent ,    false )  ;", "started    =    true ;", "return   acceptor . getAddress (  )  ;", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.launcher.daemon.server.DaemonTcpServerConnector"}, {"methodBody": ["METHOD_START", "{", "lifecycleLock . lock (  )  ;", "try    {", "stopped    =    true ;", "}    finally    {", "lifecycleLock . unlock (  )  ;", "}", "CompositeStoppable . stoppable ( acceptor ,    incoming )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.DaemonTcpServerConnector"}, {"methodBody": ["METHOD_START", "{", "connection . dispatch ( buildStarted )  ;", "connection . flush (  )  ;", "}", "METHOD_END"], "methodName": ["buildStarted"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "connection . dispatch ( result )  ;", "connection . flush (  )  ;", "}", "METHOD_END"], "methodName": ["completed"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "connection . dispatch ( unavailable )  ;", "connection . flush (  )  ;", "}", "METHOD_END"], "methodName": ["daemonUnavailable"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "connection . dispatch ( new   OutputMessage ( logEvent )  )  ;", "connection . flush (  )  ;", "}", "METHOD_END"], "methodName": ["logEvent"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "cancelQueue . useHandler ( handler )  ;", "}", "METHOD_END"], "methodName": ["onCancel"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "disconnectQueue . useHandler ( handler )  ;", "}", "METHOD_END"], "methodName": ["onDisconnect"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "stdinQueue . useHandler ( handler )  ;", "}", "METHOD_END"], "methodName": ["onStdin"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "return   receiveQueue . take ( timeoutValue ,    timeoutUnits )  ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "CompositeStoppable . stoppable ( disconnectQueue ,    connection ,    executor ,    receiveQueue ,    stdinQueue ,    cancelQueue )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.DefaultDaemonConnection"}, {"methodBody": ["METHOD_START", "{", "onStartHandling ( connection )  ;", "workers . execute ( new    . ConnectionWorker ( connection )  )  ;", "}", "METHOD_END"], "methodName": ["handle"], "fileName": "org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "inProgress . remove ( c )  ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onFinishHandling"], "fileName": "org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "inProgress . add ( c )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onStartHandling"], "fileName": "org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  !  ( inProgress . isEmpty (  )  )  )     {", "try    {", "condi . await (  )  ;", "}    catch    ( InterruptedExcep   e )     {", "throw   UncheckedExcep . throwAsUncheckedExcep ( e )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler"}, {"methodBody": ["METHOD_START", "{", "final   LowMemoryDaemonExpirationStrategy   lowMemoryDaemonExpirationStrategy    =    new   LowMemoryDaemonExpirationStrategy (  0  .  0  5  )  ;", "listenerManager . addListener ( lowMemoryDaemonExpirationStrategy )  ;", "strategies . add ( new   AllDaemonExpirationStrategy ( ImmutableList . of ( new   DaemonIdleTimeoutExpirationStrategy ( daemon ,     . DUPLICATE _ DAEMON _ GRACE _ PERIOD _ MS ,    TimeUnit . MILLISECONDS )  ,    new   NotMostRecentlyUsedDaemonExpirationStrategy ( daemon )  ,    lowMemoryDaemonExpirationStrategy )  )  )  ;", "}", "METHOD_END"], "methodName": ["addLowMemoryDaemonExpirationStrategyWhenSupported"], "fileName": "org.gradle.launcher.daemon.server.MasterExpirationStrategy"}, {"methodBody": ["METHOD_START", "{", "String   mruUid    =    null ;", "Date   mruTimestamp    =    new   Date ( Long . MIN _ VALUE )  ;", "for    ( Info   daemonInfo    :    daemonInfos )     {", "Date   daemonAccessTime    =    daemonInfo . getLastBusy (  )  ;", "if    ( daemonAccessTime . after ( mruTimestamp )  )     {", "mruUid    =    daemonInfo . getUid (  )  ;", "mruTimestamp    =    daemonAccessTime ;", "}", "}", "return   thisContext . getUid (  )  . equals ( mruUid )  ;", "}", "METHOD_END"], "methodName": ["isMostRecentlyUsed"], "fileName": "org.gradle.launcher.daemon.server.NotMostRecentlyUsedDaemonExpirationStrategy"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( message   instanceof   OutputMessage )  )     {", ". LOGGER . debug (  \" thread    {  }  :    dispatching    {  }  \"  ,    Thread . currentThread (  )  . getId (  )  ,    message . getClass (  )  )  ;", "}", "synchronized ( lock )     {", "if    ( dispatching )     {", "throw   new   IllegalStateException (  \" This   thread   is   already   dispatching   a   message .  \"  )  ;", "}", "dispatching    =    true ;", "try    {", "delegate . dispatch ( message )  ;", "}    finally    {", "dispatching    =    false ;", "}", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.launcher.daemon.server.SynchronizedDispatchConnection"}, {"methodBody": ["METHOD_START", "{", "T   result    =    delegate . receive (  )  ;", ". LOGGER . debug (  \" thread    {  }  :    received    {  }  \"  ,    Thread . currentThread (  )  . getId (  )  ,     ( result    =  =    null    ?     \" null \"     :    result . getClass (  )  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.launcher.daemon.server.SynchronizedDispatchConnection"}, {"methodBody": ["METHOD_START", "{", "SynchronizedDispatchConnection . LOGGER . debug (  \" thread    {  }  :    stopping   connection \"  ,    Thread . currentThread (  )  . getId (  )  )  ;", "delegate . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.launcher.daemon.server.SynchronizedDispatchConnection"}, {"methodBody": ["METHOD_START", "{", "return   delegate . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.launcher.daemon.server.SynchronizedDispatchConnection"}, {"methodBody": ["METHOD_START", "{", "return   command ;", "}", "METHOD_END"], "methodName": ["getCommand"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   connection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   daemonContext ;", "}", "METHOD_END"], "methodName": ["getDaemonContext"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   daemonStateControl ;", "}", "METHOD_END"], "methodName": ["getDaemonStateControl"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   this . exception ;", "}", "METHOD_END"], "methodName": ["getException"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   this . result ;", "}", "METHOD_END"], "methodName": ["getResult"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "return   configuration . isSingleUse (  )  ;", "}", "METHOD_END"], "methodName": ["isSingleUseDaemon"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "if    ( actions . isEmpty (  )  )     {", "return   false ;", "} else    {", "actions . remove (  0  )  . ee ( this )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["proceed"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "this . exception    =    exception ;", "}", "METHOD_END"], "methodName": ["setException"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "this . result    =    result ;", "}", "METHOD_END"], "methodName": ["setResult"], "fileName": "org.gradle.launcher.daemon.server.api.DaemonCommandExecution"}, {"methodBody": ["METHOD_START", "{", "Command   command    =    execution . getCommand (  )  ;", "if    (  !  ( command   instanceof   Build )  )     {", "throw   new   IllegalStateException ( String . format (  \"  %  1  $ s   command   action   received   a   command   that   isn ' t   Build    ( command   is    %  2  $ s )  ,    this   shouldn ' t   happen \"  ,    this . getClass (  )  ,    command . getClass (  )  )  )  ;", "}", "doBuild ( execution ,     (  ( Build )     ( command )  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.BuildCommandOnly"}, {"methodBody": ["METHOD_START", "{", "new   DaemonCommandExecution ( configuration ,    connection ,    command ,    daemonContext ,    daemonStateControl ,    actions )  . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["executeCommand"], "fileName": "org.gradle.launcher.daemon.server.exec.DaemonCommandExecuter"}, {"methodBody": ["METHOD_START", "{", "Properties   originalSystemProperties    =    new   Properties (  )  ;", "originalSystemProperties . putAll ( System . getProperties (  )  )  ;", "Map < String ,    String >    originalEnv    =    new   HashMap < String ,    String >  ( System . getenv (  )  )  ;", "File   originalProcessDir    =    FileUtils . canonicalize ( new   File (  \"  .  \"  )  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    build . getParameters (  )  . getSystemProperties (  )  . entrySet (  )  )     {", "if    ( SystemProperties . getInstance (  )  . getStandardProperties (  )  . contains ( entry . getKey (  )  )  )     {", "continue ;", "}", "if    ( SystemProperties . getInstance (  )  . getNonStandardImportantProperties (  )  . contains ( entry . getKey (  )  )  )     {", "continue ;", "}", "if    (  (  ( entry . getKey (  )  . startsWith (  \" sun .  \"  )  )     |  |     ( entry . getKey (  )  . startsWith (  \" awt .  \"  )  )  )     |  |     ( entry . getKey (  )  . contains (  \"  . awt .  \"  )  )  )     {", "continue ;", "}", "System . setProperty ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", ". LOGGER . debug (  \" Configuring   env   variables :     {  }  \"  ,    build . getParameters (  )  . getEnvVariables (  )  )  ;", "EnvironmentModificationResult   setEnvironmentResult    =    processEnvironment . maybeSetEnvironment ( build . getParameters (  )  . getEnvVariables (  )  )  ;", "if    (  !  ( setEnvironmentResult . isSuccess (  )  )  )     {", ". LOGGER . warn (  (  (  (  (  (  (  (  (  (  \" Warning :    Unable   able   to   set   daemon ' s   environment   variables   to   match   the   client   because :     \"     +     ( System . getProperty (  \" line . separator \"  )  )  )     +     \"        \"  )     +    setEnvironmentResult )     +     ( System . getProperty (  \" line . separator \"  )  )  )     +     \"        \"  )     +     \" If   the   daemon   was   started   with   a   significantly   different   environment   from   the   client ,    and   your   build    \"  )     +     ( System . getProperty (  \" line . separator \"  )  )  )     +     \"        \"  )     +     \" relies   on   environment   variables ,    you   may   experience   unexpected   behavior .  \"  )  )  ;", "}", "processEnvironment . maybeSetProcessDir ( build . getParameters (  )  . getCurrentDir (  )  )  ;", "Locale   locale    =    Locale . getDefault (  )  ;", "try    {", "execution . proceed (  )  ;", "}    finally    {", "System . setProperties ( originalSystemProperties )  ;", "processEnvironment . maybeSetEnvironment ( originalEnv )  ;", "processEnvironment . maybeSetProcessDir ( originalProcessDir )  ;", "Locale . setDefault ( locale )  ;", "}", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment"}, {"methodBody": ["METHOD_START", "{", "ExecuteBuild . LOGGER . debug ( DaemonMessages . STARTED _ BUILD )  ;", "ExecuteBuild . LOGGER . debug (  \" Executing   build   with   daemon   context :     {  }  \"  ,    execution . getDaemonContext (  )  )  ;", "runningStats . buildStarted (  )  ;", "try    {", "BuildCancellationToken   cancellationToken    =    execution . getDaemonStateControl (  )  . getCancellationToken (  )  ;", "BuildRequestContext   buildRequestContext    =    new   DefaultBuildRequestContext ( build . getBuildRequestMetaData (  )  ,    cancellationToken ,    new   ExecuteBuild . DaemonConnectionBackedEventConsumer ( execution )  )  ;", "if    (  !  ( build . getParameters (  )  . isContinuous (  )  )  )     {", "buildRequestContext . getCancellationToken (  )  . addCallback ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "ExecuteBuild . LOGGER . info ( DaemonMessages . CANCELED _ BUILD )  ;", "}", "}  )  ;", "}", "Object   result    =    actionExecuter . execute ( build . getAction (  )  ,    buildRequestContext ,    build . getParameters (  )  ,    contextServices )  ;", "execution . setResult ( result )  ;", "}    catch    ( ReportedException   e )     {", "execution . setException ( e )  ;", "}    finally    {", "runningStats . buildFinished (  )  ;", "ExecuteBuild . LOGGER . debug ( DaemonMessages . FINISHED _ BUILD )  ;", "}", "execution . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.launcher.daemon.server.exec.ExecuteBuild"}, {"methodBody": ["METHOD_START", "{", "final   PipedOutputStream   inputSource    =    new   PipedOutputStream (  )  ;", "final   PipedInputStream   replacementStdin ;", "try    {", "replacementStdin    =    new   PipedInputStream ( inputSource )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "execution . getConnection (  )  . onStdin ( new   StdinHandler (  )     {", "public   void   onInput ( ForwardInput   input )     {", ". LOGGER . debug (  \" Writing   forwarded   input   on   daemon ' s   stdin .  \"  )  ;", "try    {", "inputSource . write ( input . getBytes (  )  )  ;", "}    catch    ( IOException   e )     {", ". LOGGER . warn (  \" Received   exception   trying   to   forward   client   input .  \"  ,    e )  ;", "}", "}", "public   void   onEndOfInput (  )     {", ". LOGGER . info (  \" Closing   daemon ' s   stdin   at   end   of   input .  \"  )  ;", "try    {", "inputSource . close (  )  ;", "}    catch    ( IOException   e )     {", ". LOGGER . warn (  \" Problem   closing   output   stream   connected   to   replacement   stdin \"  ,    e )  ;", "}    finally    {", ". LOGGER . info (  \" The   daemon   will   no   longer   process   any   standard   input .  \"  )  ;", "}", "}", "}  )  ;", "try    {", "try    {", "new   StdinSwapper (  )  . swap ( replacementStdin ,    new   Callable < Void >  (  )     {", "public   Void   call (  )     {", "execution . proceed (  )  ;", "return   null ;", "}", "}  )  ;", "}    finally    {", "execution . getConnection (  )  . onStdin ( null )  ;", "IOUtils . closeQuietly ( replacementStdin )  ;", "IOUtils . closeQuietly ( inputSource )  ;", "}", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.ForwardClientInput"}, {"methodBody": ["METHOD_START", "{", "execution . getConnection (  )  . onCancel ( new   Runnable (  )     {", "public   void   run (  )     {", ". LOGGER . info (  \"    processing    {  }  \"  ,    execution . getCommand (  )  )  ;", "execution . getDaemonStateControl (  )  . cancelBuild (  )  ;", "}", "}  )  ;", "try    {", "execution . proceed (  )  ;", "}    finally    {", "execution . getConnection (  )  . onCancel ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.HandleCancel"}, {"methodBody": ["METHOD_START", "{", "if    ( Boolean . getBoolean ( LogToClient . DISABLE _ OUTPUT )  )     {", "execution . proceed (  )  ;", "return ;", "}", "dispatcher    =    new   LogToClient . AsynchronousLogDispatcher ( execution . getConnection (  )  ,    build . getParameters (  )  . getLogLevel (  )  )  ;", "LogToClient . LOGGER . info (  \"  {  }  {  }  )  .    The   daemon   log   file :     {  }  \"  ,    DaemonMessages . STARTED _ RELAYING _ LOGS ,    diagnostics . getPid (  )  ,    diagnostics . getDaemonLog (  )  )  ;", "dispatcher . start (  )  ;", "try    {", "execution . proceed (  )  ;", "}    finally    {", "dispatcher . waitForCompletion (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.launcher.daemon.server.exec.LogToClient"}, {"methodBody": ["METHOD_START", "{", "execution . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.NoOpDaemonCommandAction"}, {"methodBody": ["METHOD_START", "{", "if    ( execution . isSingleUseDaemon (  )  )     {", ". LOGGER . debug (  \" Requesting   daemon   stop   after   processing    {  }  \"  ,    execution . getCommand (  )  )  ;", "execution . getDaemonStateControl (  )  . requestStop (  \" stopping   after   processing \"  )  ;", "}", "execution . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.RequestStopIfSingleUsedDaemon"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . reset (  )  ;", "execution . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger"}, {"methodBody": ["METHOD_START", "{", "execution . proceed (  )  ;", "Result   result ;", "Throwable   commandException    =    execution . getException (  )  ;", "if    ( commandException    !  =    null )     {", "result    =    new   Failure ( commandException )  ;", "} else    {", "result    =    new   Success ( execution . getResult (  )  )  ;", "}", ". LOGGER . debug (  \" Daemon   is   dispatching   the   build   result :     {  }  \"  ,    result )  ;", "execution . getConnection (  )  . completed ( result )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.ReturnResult"}, {"methodBody": ["METHOD_START", "{", "DaemonStateControl   stateCoordinator    =    execution . getDaemonStateControl (  )  ;", "try    {", "Runnable   command    =    new   Runnable (  )     {", "public   void   run (  )     {", ". LOGGER . info (  \" Daemon   is   about   to   start   building    {  }  .    Dispatching   build   started   information .  .  .  \"  ,    build )  ;", "execution . getConnection (  )  . buildStarted ( new   BuildStarted ( diagnostics )  )  ;", "execution . proceed (  )  ;", "}", "}  ;", "stateCoordinator . runCommand ( command ,    execution . toString (  )  )  ;", "}    catch    ( DaemonUnavailableException   e )     {", ". LOGGER . info (  \" Daemon   will   not   handle   the   command    {  }    because   is   unavailable :     {  }  \"  ,    build ,    e . getMessage (  )  )  ;", "execution . getConnection (  )  . daemonUnavailable ( new   DaemonUnavailable ( e . getMessage (  )  )  )  ;", "}    catch    ( DaemonStoppedException   e )     {", "execution . getConnection (  )  . completed ( new   Failure ( e )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy"}, {"methodBody": ["METHOD_START", "{", "execution . getConnection (  )  . onDisconnect ( new   Runnable (  )     {", "public   void   run (  )     {", ". LOGGER . warn (  \" thread    {  }  :    client   disconnection   detected ,    canceling   the   build \"  ,    Thread . currentThread (  )  . getId (  )  )  ;", "execution . getDaemonStateControl (  )  . requestCancel (  )  ;", "}", "}  )  ;", "try    {", "execution . proceed (  )  ;", "}    finally    {", "execution . getConnection (  )  . onDisconnect ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.daemon.server.exec.WatchForDisconnection"}, {"methodBody": ["METHOD_START", "{", "DaemonExpirationResult   expirationResult    =    DaemonExpirationResult . NOT _ TRIGGERED ;", "DaemonExpirationStatus   expirationStatus    =    DaemonExpirationStatus . DO _ NOT _ EXPIRE ;", "List < String >    reasons    =    Lists . newArrayList (  )  ;", "for    (    expirationStrategy    :    expirationStrategies )     {", "expirationResult    =    expirationStrategy . checkExpiration (  )  ;", "if    (  ( expirationResult . getStatus (  )  )     =  =     ( DaemonExpirationStatus . DO _ NOT _ EXPIRE )  )     {", "return   DaemonExpirationResult . NOT _ TRIGGERED ;", "} else    {", "reasons . add ( expirationResult . getReason (  )  )  ;", "expirationStatus    =    DaemonExpirationStatus . highestPriorityOf ( expirationResult . getStatus (  )  ,    expirationStatus )  ;", "}", "}", "if    (  ( expirationResult . getStatus (  )  )     =  =     ( DaemonExpirationStatus . DO _ NOT _ EXPIRE )  )     {", "return   DaemonExpirationResult . NOT _ TRIGGERED ;", "} else    {", "return   new   DaemonExpirationResult ( expirationStatus ,    Joiner . on (  \"    and    \"  )  . skipNulls (  )  . join ( reasons )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkExpiration"], "fileName": "org.gradle.launcher.daemon.server.expiry.AllDaemonExpirationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.gradle.launcher.daemon.server.expiry.DaemonExpirationResult"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.launcher.daemon.server.expiry.DaemonExpirationResult"}, {"methodBody": ["METHOD_START", "{", "if    (  ( left . ordinal (  )  )     >     ( right . ordinal (  )  )  )     {", "return   left ;", "} else    {", "return   right ;", "}", "}", "METHOD_END"], "methodName": ["highestPriorityOf"], "fileName": "org.gradle.launcher.daemon.server.expiry.DaemonExpirationStatus"}, {"methodBody": ["METHOD_START", "{", "DaemonExpirationResult   result    =    strategy . checkExpiration (  )  ;", "if    (  ( result . getStatus (  )  )     !  =     ( DaemonExpirationStatus . DO _ NOT _ EXPIRE )  )     {", "listenerBroadcast . onExpirationEvent ( result )  ;", "}", "}", "METHOD_END"], "methodName": ["executeHealthCheck"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthCheck"}, {"methodBody": ["METHOD_START", "{", "if    (  ( gcMonitor . getGcStrategy (  )  )     !  =     ( GarbageCollectorMonitoringStrategy . UNKNOWN )  )     {", "GarbageCollectionStats   tenuredStats    =    gcMonitor . getTenuredStats (  )  ;", "GarbageCollectionStats   permgenStats    =    gcMonitor . getPermGenStats (  )  ;", "String   message    =    String . format (  \" Starting    % s   build   in       [ uptime :     % s ,    performance :     % s %  %  \"  ,    NumberUtil . ordinal ( nextBuildNum )  ,    runningStats . getPrettyUpTime (  )  ,    getCurrentPerformance (  )  )  ;", "if    (  ( tenuredStats . getUsage (  )  )     >     0  )     {", "message    +  =    String . format (  \"  ,    GC   rate :     %  .  2 f / s ,    tenured   heap   usage :     % s %  %    of    % s \"  ,    tenuredStats . getRate (  )  ,    tenuredStats . getUsage (  )  ,    NumberUtil . formatBytes ( tenuredStats . getMax (  )  )  )  ;", "if    (  ( permgenStats . getUsage (  )  )     >     0  )     {", "message    +  =    String . format (  \"  ,    perm   gen   usage :     % s %  %    of    % s \"  ,    permgenStats . getUsage (  )  ,    NumberUtil . formatBytes ( permgenStats . getMax (  )  )  )  ;", "}", "} else    {", "message    +  =     \"  ,    no   major   garbage   collections \"  ;", "}", "message    +  =     \"  ]  \"  ;", "return   message ;", "} else    {", "return   String . format (  \" Starting    % s   build   in       [ uptime :     % s ,    performance :     % s %  %  ]  \"  ,    NumberUtil . ordinal ( nextBuildNum )  ,    runningStats . getPrettyUpTime (  )  ,    getCurrentPerformance (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getBuildHealthInfo"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthStats"}, {"methodBody": ["METHOD_START", "{", "long   collectionTime    =    gcInfo . getCollectionTime (  )  ;", "long   allBuildsTime    =    running . getAllBuildsTime (  )  ;", "if    (  ( collectionTime    >     0  )     &  &     ( collectionTime    <    allBuildsTime )  )     {", "return    1  0  0     -     ( NumberUtil . percentOf ( collectionTime ,    allBuildsTime )  )  ;", "} else    {", "return    1  0  0  ;", "}", "}", "METHOD_END"], "methodName": ["getCurrentPerformance"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthStats"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Starting   build   in   new   daemon    [ memory :     % s ]  \"  ,    NumberUtil . formatBytes ( Runtime . getRuntime (  )  . maxMemory (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirstBuildHealthInfo"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthStats"}, {"methodBody": ["METHOD_START", "{", "return   gcMonitor ;", "}", "METHOD_END"], "methodName": ["getGcMonitor"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthStats"}, {"methodBody": ["METHOD_START", "{", "int   nextBuildNum    =     ( runningStats . getBuildCount (  )  )     +     1  ;", "if    ( nextBuildNum    =  =     1  )     {", "return   getFirstBuildInfo (  )  ;", "} else    {", "return   getBuildInfo ( nextBuildNum )  ;", "}", "}", "METHOD_END"], "methodName": ["getHealthInfo"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonHealthStats"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( isEnabled (  )  )     &  &     (  ( strategy )     !  =     ( GarbageCollectorMonitoringStrategy . UNKNOWN )  )  )     &  &     ( spec . isSatisfiedBy ( gcStats )  )  )     {", "if    (  ( gcStats . getUsage (  )  )     >     0  )     {", ". LOGGER . debug ( String . format (  \" GC   rate :     %  .  2 f / s    % s   usage :     % s %  %  \"  ,    gcStats . getRate (  )  ,    pool ,    gcStats . getUsage (  )  )  )  ;", "} else    {", ". LOGGER . debug (  \" GC   rate :     0  .  0  / s \"  )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["exceedsThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "String   enabledValue    =    System . getProperty ( DaemonMemoryStatus . ENABLE _ PERFORMANCE _ MONITORING ,     \" true \"  )  ;", "return   Boolean . parseBoolean ( enabledValue )  ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "GarbageCollectionStats   gcStats    =    stats . getGcMonitor (  )  . getPermGenStats (  )  ;", "return   exceedsThreshold (  . PERMGEN ,    gcStats ,    new   Spec < GarbageCollectionStats >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( GarbageCollectionStats   gcStats )     {", "return    (  (  ( permgenUsageThreshold )     !  =     0  )     &  &     (  ( gcStats . getEventCount (  )  )     >  =     5  )  )     &  &     (  ( gcStats . getUsage (  )  )     >  =     ( permgenUsageThreshold )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["isPermGenSpaceExhausted"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "GarbageCollectionStats   gcStats    =    stats . getGcMonitor (  )  . getTenuredStats (  )  ;", "return   exceedsThreshold (  . TENURED ,    gcStats ,    new   Spec < GarbageCollectionStats >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( GarbageCollectionStats   gcStats )     {", "return    (  (  (  (  ( tenuredUsageThreshold )     !  =     0  )     &  &     (  ( tenuredRateThreshold )     !  =     0  )  )     &  &     (  ( gcStats . getEventCount (  )  )     >  =     5  )  )     &  &     (  ( gcStats . getUsage (  )  )     >  =     ( tenuredUsageThreshold )  )  )     &  &     (  ( gcStats . getRate (  )  )     >  =     ( tenuredRateThreshold )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["isTenuredSpaceExhausted"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "GarbageCollectionStats   gcStats    =    stats . getGcMonitor (  )  . getTenuredStats (  )  ;", "return   exceedsThreshold (  . TENURED ,    gcStats ,    new   Spec < GarbageCollectionStats >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( GarbageCollectionStats   gcStats )     {", "return    (  (  (  (  ( tenuredUsageThreshold )     !  =     0  )     &  &     (  ( thrashingThreshold )     !  =     0  )  )     &  &     (  ( gcStats . getEventCount (  )  )     >  =     5  )  )     &  &     (  ( gcStats . getUsage (  )  )     >  =     ( tenuredUsageThreshold )  )  )     &  &     (  ( gcStats . getRate (  )  )     >  =     ( thrashingThreshold )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["isThrashing"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "String   expireAt    =    System . getProperty ( property )  ;", "if    ( expireAt    =  =    null )     {", "return   defaultValue ;", "}", "try    {", "return   Double . parseDouble ( expireAt )  ;", "}    catch    ( Exception   e )     {", "throw   new   GException ( String . format (  \" System   property    '  % s '    has   incorrect   value :     '  % s '  .    The   value   needs   to   be   a   double .  \"  ,    property ,    expireAt )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseValue"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "String   expireAt    =    System . getProperty ( property )  ;", "if    ( expireAt    =  =    null )     {", "return   defaultValue ;", "}", "try    {", "return   Integer . parseInt ( expireAt )  ;", "}    catch    ( Exception   e )     {", "throw   new   GException ( String . format (  \" System   property    '  % s '    has   incorrect   value :     '  % s '  .    The   value   needs   to   be   an   integer .  \"  ,    property ,    expireAt )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseValue"], "fileName": "org.gradle.launcher.daemon.server.health.DaemonMemoryStatus"}, {"methodBody": ["METHOD_START", "{", "if    ( Boolean . getBoolean ( HealthLogger . HEALTH _ MESSAGE _ PROPERTY )  )     {", "logger . lifecycle ( stats . getHealthInfo (  )  )  ;", "} else    {", "logger . info ( stats . getHealthInfo (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logHealth"], "fileName": "org.gradle.launcher.daemon.server.health.HealthLogger"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( memoryStatus )     !  =    null )     {", "long   freeMem    =    memoryStatus . getFreePhysicalMemory (  )  ;", "if    ( freeMem    <     ( memoryThresholdInBytes )  )     {", ". LOG . info (  (  (  (  \" after   free   system   memory    (  \"     +     ( NumberUtil . formatBytes ( freeMem )  )  )     +     \"  )    fell   below   threshold   of    \"  )     +     ( NumberUtil . formatBytes ( memoryThresholdInBytes )  )  )  )  ;", "return   new   DaemonExpirationResult ( DaemonExpirationStatus . GRACEFUL _ EXPIRE ,     . EXPIRATION _ REASON )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "return   DaemonExpirationResult . NOT _ TRIGGERED ;", "}", "METHOD_END"], "methodName": ["checkExpiration"], "fileName": "org.gradle.launcher.daemon.server.health.LowMemoryDaemonExpirationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   Math . min ( maxValue ,    Math . max ( minValue ,    thresholdIn )  )  ;", "}", "METHOD_END"], "methodName": ["normalizeThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.LowMemoryDaemonExpirationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   count ;", "}", "METHOD_END"], "methodName": ["getCount"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionEvent"}, {"methodBody": ["METHOD_START", "{", "return   timestamp ;", "}", "METHOD_END"], "methodName": ["getTimestamp"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionEvent"}, {"methodBody": ["METHOD_START", "{", "return   usage ;", "}", "METHOD_END"], "methodName": ["getUsage"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionEvent"}, {"methodBody": ["METHOD_START", "{", "long   garbageCollectionTime    =     0  ;", "for    ( GarbageCollectorMXBean   gc    :    ManagementFactory . getGarbageCollectorMXBeans (  )  )     {", "long   time    =    gc . getCollectionTime (  )  ;", "if    ( time    >  =     0  )     {", "garbageCollectionTime    +  =    time ;", "}", "}", "return   garbageCollectionTime ;", "}", "METHOD_END"], "methodName": ["getCollectionTime"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionInfo"}, {"methodBody": ["METHOD_START", "{", "GarbageCollectionMonitor . JVMStrategy   jvmStrategy    =    GarbageCollectionMonitor . JVMStrategy . current (  )  ;", "final   List < String >    garbageCollectors    =    CollectionUtils . collect ( ManagementFactory . getGarbageCollectorMXBeans (  )  ,    new   Transformer < String ,    GarbageCollectorMXBean >  (  )     {", "@ Override", "public   String   transform ( GarbageCollectorMXBean   garbageCollectorMXBean )     {", "return   garbageCollectorMXBean . getName (  )  ;", "}", "}  )  ;", "GarbageCollectorMonitoringStrategy   gcStrategy    =    CollectionUtils . findFirst ( jvmStrategy . getGcStrategies (  )  ,    new   Spec < GarbageCollectorMonitoringStrategy >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( GarbageCollectorMonitoringStrategy   strategy )     {", "return   garbageCollectors . contains ( strategy . getGarbageCollectorName (  )  )  ;", "}", "}  )  ;", "if    ( gcStrategy    =  =    null )     {", "GarbageCollectionMonitor . LOGGER . info (  (  \" Unable   to   determine   a   garbage   collection   monitoring   strategy   for    \"     +     ( jvmStrategy . toString (  )  )  )  )  ;", "return   GarbageCollectorMonitoringStrategy . UNKNOWN ;", "} else    {", "return   gcStrategy ;", "}", "}", "METHOD_END"], "methodName": ["determineGcStrategy"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "SlidingWindow < GarbageCollectionEvent >    slidingWindow ;", "if    (  ( memoryPoolName    =  =    null )     |  |     (  ( events . get ( memoryPoolName )  )     =  =    null )  )     {", "slidingWindow    =    new   DefaultSlidingWindow < GarbageCollectionEvent >  (  . EVENT _ WINDOW )  ;", "} else    {", "slidingWindow    =    events . get ( memoryPoolName )  ;", "}", "return   new   GarbageCollectionStats ( slidingWindow . snapshot (  )  )  ;", "}", "METHOD_END"], "methodName": ["getGarbageCollectionStatsWithEmptyDefault"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "return   gcStrategy ;", "}", "METHOD_END"], "methodName": ["getGcStrategy"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "return   getGarbageCollectionStatsWithEmptyDefault ( gcStrategy . getPermGenPoolName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPermGenStats"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "return   getGarbageCollectionStatsWithEmptyDefault ( gcStrategy . getTenuredPoolName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTenuredStats"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "pollingExecutor . scheduleAtFixedRate ( new   GarbageCollectionCheck ( events ,    memoryPoolNames ,    garbageCollectorName )  ,    GarbageCollectionMonitor . POLL _ DELAY _ SECONDS ,    GarbageCollectionMonitor . POLL _ INTERVAL _ SECONDS ,    TimeUnit . SECONDS )  ;", "}", "METHOD_END"], "methodName": ["pollForValues"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionMonitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( events . size (  )  )     <     1  )     {", "return    -  1  ;", "}", "long   total    =     0  ;", "long   firstCount    =     0  ;", "long   lastCount    =     0  ;", "for    ( Event   event    :    events )     {", "if    (  (  ( event . getCount (  )  )     =  =    lastCount )     |  |     (  ( event . getCount (  )  )     =  =     0  )  )     {", "continue ;", "}", "MemoryUsage   usage    =    event . getUsage (  )  ;", "if    ( firstCount    =  =     0  )     {", "firstCount    =    event . getCount (  )  ;", "total    +  =    usage . getUsed (  )  ;", "} else    {", "total    +  =     ( usage . getUsed (  )  )     *     (  ( event . getCount (  )  )     -    lastCount )  ;", "}", "lastCount    =    event . getCount (  )  ;", "}", "if    (  ( lastCount    =  =     0  )     |  |     ( lastCount    =  =    firstCount )  )     {", "return    -  1  ;", "} else    {", "long   totalCount    =     ( lastCount    -    firstCount )     +     1  ;", "return   total    /    totalCount ;", "}", "}", "METHOD_END"], "methodName": ["calculateAverageUsage"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "if    (  ( events . size (  )  )     <     1  )     {", "return    -  1  ;", "}", "MryUsage   usage    =    events . iterator (  )  . next (  )  . getUsage (  )  ;", "return   usage . getMax (  )  ;", "}", "METHOD_END"], "methodName": ["calculateMaxSize"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "long   firstGC    =     0  ;", "long   lastGC    =     0  ;", "long   firstCount    =     0  ;", "long   lastCount    =     0  ;", "for    ( Event   event    :    events )     {", "if    (  (  ( event . getCount (  )  )     =  =    lastCount )     |  |     (  ( event . getCount (  )  )     =  =     0  )  )     {", "continue ;", "}", "lastCount    =    event . getCount (  )  ;", "if    ( firstGC    =  =     0  )     {", "firstGC    =    event . getTimestamp (  )  ;", "firstCount    =    event . getCount (  )  ;", "} else    {", "lastGC    =    event . getTimestamp (  )  ;", "}", "}", "if    (  (  ( events . size (  )  )     <     2  )     |  |     ( lastCount    =  =     0  )  )     {", "return    0  ;", "} else    {", "long   elapsed    =    lastGC    -    firstGC ;", "long   totalCount    =    lastCount    -    firstCount ;", "return    (  (  ( double )     ( totalCount )  )     /    elapsed )     *     1  0  0  0  ;", "}", "}", "METHOD_END"], "methodName": ["calculateRate"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "return   eventCount ;", "}", "METHOD_END"], "methodName": ["getEventCount"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "return   max ;", "}", "METHOD_END"], "methodName": ["getMax"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "return   rate ;", "}", "METHOD_END"], "methodName": ["getRate"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( used )     >     0  )     &  &     (  ( max )     >     0  )  )     {", "return   NumberUtil . percentOf ( used ,    max )  ;", "} else    {", "return    -  1  ;", "}", "}", "METHOD_END"], "methodName": ["getUsage"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "return   used ;", "}", "METHOD_END"], "methodName": ["getUsed"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectionStats"}, {"methodBody": ["METHOD_START", "{", "return   garbageCollectorName ;", "}", "METHOD_END"], "methodName": ["getGarbageCollectorName"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   gcRateThreshold ;", "}", "METHOD_END"], "methodName": ["getGcRateThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   permGenPoolName ;", "}", "METHOD_END"], "methodName": ["getPermGenPoolName"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   permGenUsageThreshold ;", "}", "METHOD_END"], "methodName": ["getPermGenUsageThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   tenuredPoolName ;", "}", "METHOD_END"], "methodName": ["getTenuredPoolName"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   tenuredUsageThreshold ;", "}", "METHOD_END"], "methodName": ["getTenuredUsageThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "return   thrashingThreshold ;", "}", "METHOD_END"], "methodName": ["getThrashingThreshold"], "fileName": "org.gradle.launcher.daemon.server.health.gc.GarbageCollectorMonitoringStrategy"}, {"methodBody": ["METHOD_START", "{", "long   buildTime    =    Math . max ( currentBuildTimer . getElapsedMillis (  )  ,     1  )  ;", "allBuildsTime    +  =    buildTime ;", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "+  +  ( buildCount )  ;", "currentBuildTimreset (  )  ;", "}", "METHOD_END"], "methodName": ["buildStarted"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "return   allBuildsTime ;", "}", "METHOD_END"], "methodName": ["getAllBuildsTime"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "return   buildCount ;", "}", "METHOD_END"], "methodName": ["getBuildCount"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "return   daemonTimer . getElapsed (  )  ;", "}", "METHOD_END"], "methodName": ["getPrettyUpTime"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "return   startTime ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.launcher.daemon.server.stats.DaemonRunningStats"}, {"methodBody": ["METHOD_START", "{", "return   currentDir ;", "}", "METHOD_END"], "methodName": ["getCurrentDir"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   envVariables ;", "}", "METHOD_END"], "methodName": ["getEnvVariables"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   injectedPluginClasspath ;", "}", "METHOD_END"], "methodName": ["getInjectedPluginClasspath"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   logLevel ;", "}", "METHOD_END"], "methodName": ["getLogLevel"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   systemProperties ;", "}", "METHOD_END"], "methodName": ["getSystemProperties"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   continuous ;", "}", "METHOD_END"], "methodName": ["isContinuous"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   interactive ;", "}", "METHOD_END"], "methodName": ["isInteractive"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "return   useDaemon ;", "}", "METHOD_END"], "methodName": ["isUseDaemon"], "fileName": "org.gradle.launcher.exec.DefaultBuildActionParameters"}, {"methodBody": ["METHOD_START", "{", "UnsupportedJavaRuntimeException . javaDeprecationWarning (  )  ;", "startParameter . checkDeprecation (  )  ;", "}", "METHOD_END"], "methodName": ["checkDeprecations"], "fileName": "org.gradle.launcher.exec.InProcessBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "GradleLauncherFactory   gradleLauncherFactory    =    contextServices . get ( GradleLauncherFactory . class )  ;", "GradleLauncher   gradleLauncher    =    gradleLauncherFactory . newInstance ( action . getStartParameter (  )  ,    buildRequestContext ,    contextServices )  ;", "GradleBuildController   buildController    =    new   GradleBuildController ( gradleLauncher )  ;", "checkDeprecations ( action . getStartParameter (  )  )  ;", "try    {", "RootBuildLifecycleListener   buildLifecycleListener    =    contextServices . get ( ListenerManager . class )  . getBroadcaster ( RootBuildLifecycleListener . class )  ;", "buildLifecycleListener . afterStart (  )  ;", "try    {", "bRunner . run ( action ,    buildController )  ;", "return   buildController . getResult (  )  ;", "}    finally    {", "buildLifecycleListener . beforeComplete (  )  ;", "}", "}    finally    {", "buildController . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.launcher.exec.InProcessBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( sendTestProgressEvents )     |  |     ( sendTaskProgressEvents )  )     |  |     ( sendBuildProgressEvents )  ;", "}", "METHOD_END"], "methodName": ["isSendAnyProgressEvents"], "fileName": "org.gradle.tooling.internal.provider.BuildClientSubscriptions"}, {"methodBody": ["METHOD_START", "{", "return   sendBuildProgressEvents ;", "}", "METHOD_END"], "methodName": ["isSendBuildProgressEvents"], "fileName": "org.gradle.tooling.internal.provider.BuildClientSubscriptions"}, {"methodBody": ["METHOD_START", "{", "return   sendTaskProgressEvents ;", "}", "METHOD_END"], "methodName": ["isSendTaskProgressEvents"], "fileName": "org.gradle.tooling.internal.provider.BuildClientSubscriptions"}, {"methodBody": ["METHOD_START", "{", "return   sendTestProgressEvents ;", "}", "METHOD_END"], "methodName": ["isSendTestProgressEvents"], "fileName": "org.gradle.tooling.internal.provider.BuildClientSubscriptions"}, {"methodBody": ["METHOD_START", "{", "return   modelName ;", "}", "METHOD_END"], "methodName": ["getModelName"], "fileName": "org.gradle.tooling.internal.provider.BuildModelAction"}, {"methodBody": ["METHOD_START", "{", "return    !  ( NULL _ MODEL . equals ( modelName )  )  ;", "}", "METHOD_END"], "methodName": ["isModelRequest"], "fileName": "org.gradle.tooling.internal.provider.BuildModelAction"}, {"methodBody": ["METHOD_START", "{", "return   runTasks ;", "}", "METHOD_END"], "methodName": ["isRunTasks"], "fileName": "org.gradle.tooling.internal.provider.BuildModelAction"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "org.gradle.tooling.internal.provider.ClientProvidedBuildAction"}, {"methodBody": ["METHOD_START", "{", "return   runTasks ;", "}", "METHOD_END"], "methodName": ["isRunTasks"], "fileName": "org.gradle.tooling.internal.provider.ClientProvidedBuildAction"}, {"methodBody": ["METHOD_START", "{", "serviceRegistration . add ( LoggingServiceRegistry . class ,    loggingServices )  ;", "serviceRegistration . addProvider ( new   Global ( true )  )  ;", "serviceRegistration . addProvider ( new   DaemonClientGlobalServices (  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.tooling.internal.provider.ConnectionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProtocolToModelAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["createProtocolToModelAdapter"], "fileName": "org.gradle.tooling.internal.provider.ConnectionScopeServices"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderCache   classLoaderCache    =    new   ClassLoaderCache (  )  ;", "return   new   Provider ( serviceRegistry ,    loggingServices ,    buildLayoutFactory ,    daemonClientFactory ,    buildActionExecuter ,    new   PayloadSerializer ( new   WellKnownClassLoaderRegistry ( new   ClientSidePayloadClassLoaderRegistry ( new   DefaultPayloadClassLoaderRegistry ( classLoaderCache ,    new   ClientSidePayloadClassLoaderFactory ( new   ModelClassLoaderFactory (  )  )  )  ,    new   ClasspathInferer (  )  ,    classLoaderCache )  )  )  ,    jvmVersionDetector )  ;", "}", "METHOD_END"], "methodName": ["createProviderConnection"], "fileName": "org.gradle.tooling.internal.provider.ConnectionScopeServices"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   clientServices    =    daemonClientFactory . createStopDaemonServices ( outputEventListener ,    new   DaemonParameters ( new   BuildLayoutParameters (  )  )  )  ;", "DaemonStopClient   client    =    clientServices . get ( DaemonStopClient . class )  ;", "ShutdownCoordinator   shutdownCoordinator    =    new   ShutdownCoordinator ( client )  ;", "listenerManager . addListener ( shutdownCoordinator )  ;", "return   shutdownCoordinator ;", "}", "METHOD_END"], "methodName": ["createShutdownCoordinator"], "fileName": "org.gradle.tooling.internal.provider.ConnectionScopeServices"}, {"methodBody": ["METHOD_START", "{", "final   CancellableOperationManager   cancellableOperationManager ;", "if    ( actionParameters . isInteractive (  )  )     {", "if    (  !  (  ( System . in )    instanceof   DisconnectableInputStream )  )     {", "System . setIn ( new   DisconnectableInputStream ( System . in )  )  ;", "}", "DisconnectableInputStream   inputStream    =     (  ( DisconnectableInputStream )     ( System . in )  )  ;", "cancellableOperationManager    =    new   execution . DefaultCancellableOperationManager ( executorFactory . create (  \" Cancel   signal   monitor \"  )  ,    inputStream ,    cancellationToken )  ;", "} else    {", "cancellableOperationManager    =    new   execution . PassThruCancellableOperationManager ( cancellationToken )  ;", "}", "return   cancellableOperationManager ;", "}", "METHOD_END"], "methodName": ["createCancellableOperationManager"], "fileName": "org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( actionParameters . isInteractive (  )  )     {", "if    ( operatingSystem . isWindows (  )  )     {", "return    \"     ( ctrl - d   then   enter   to   exit )  \"  ;", "} else    {", "return    \"     ( ctrl - d   to   exit )  \"  ;", "}", "} else    {", "return    \"  \"  ;", "}", "}", "METHOD_END"], "methodName": ["determineExitHint"], "fileName": "org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "try    {", "inputsListener . setFileSystemWaiter ( waiter )  ;", "return   delegate . e ( action ,    requestContext ,    actionParameters ,    buildSessionScopeServices )  ;", "}    finally    {", "inputsListener . setFileSystemWaiter ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["executeBuildAndAccumulateInputs"], "fileName": "org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "BuildCancellationToken   cancellationToken    =    requestContext . getCancellationToken (  )  ;", "BuildStartedTime   buildStartedTime    =    buildSessionScopeServices . get ( BuildStartedTime . class )  ;", "Clock   clock    =    buildSessionScopeServices . get ( Clock . class )  ;", "Object   lastResult ;", "while    ( true )     {", "PendingChangesListener   pendingChangesListener    =    buildSessionScopeServices . get ( ListenerManager . class )  . getBroadcaster ( PendingChangesListener . class )  ;", "final   FileSystemChangeWaiter   waiter    =    changeWaiterFactory . createChangeWaiter ( new   internal . filewatch . SingleFirePendingChangesListener ( pendingChangesListener )  ,    cancellationToken ,    continuousExecutionGate )  ;", "try    {", "try    {", "lastResult    =    executeBuildAndAccumulateInputs ( action ,    requestContext ,    actionParameters ,    waiter ,    buildSessionScopeServices )  ;", "}    catch    ( ReportedException   t )     {", "lastResult    =    t ;", "}", "if    (  !  ( waiter . isWatching (  )  )  )     {", "logger . println (  )  . withStyle ( Failure )  . println (  \" Exiting   continuous   build   as   no   executed   tasks   declared   file   system   inputs .  \"  )  ;", "if    ( lastResult   instanceof   ReportedException )     {", "throw    (  ( ReportedException )     ( lastResult )  )  ;", "}", "return   lastResult ;", "} else    {", "cancellableOperationManager . monitorInput ( new   api . Action < BuildCancellationToken >  (  )     {", "@ Override", "public   void   execute ( BuildCancellationToken   cancellationToken )     {", "FileWatcherEventListener   reporter    =    new   DefaultFileWatcherEventListener (  )  ;", "waiter . wait ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "logger . println (  )  . println (  (  \" Waiting   for   changes   to   input   files   of   tasks .  .  .  \"     +     ( determineExitHint ( actionParameters )  )  )  )  ;", "}", "}  ,    reporter )  ;", "if    (  !  ( cancellationToken . isCancellationRequested (  )  )  )     {", "reporter . reportChanges ( logger )  ;", "}", "}", "}  )  ;", "}", "}    finally    {", "waiter . stop (  )  ;", "}", "if    ( cancellationToken . isCancellationRequested (  )  )     {", "break ;", "} else    {", "logger . println (  \" Change   detected ,    executing   build .  .  .  \"  )  . println (  )  ;", "buildStartedTime . reset ( clock . getCurrentTime (  )  )  ;", "}", "}", "logger . println (  \" Build   cancelled .  \"  )  ;", "if    ( lastResult   instanceof   ReportedException )     {", "throw    (  ( ReportedException )     ( lastResult )  )  ;", "}", "return   lastResult ;", "}", "METHOD_END"], "methodName": ["executeMultipleBuilds"], "fileName": "org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "final   DeploymentRegistryInternal   deploymentRegistry    =    buildSessionScopeServices . get ( DeploymentRegistryInternal . class )  ;", "if    (  !  ( deploymentRegistry . getRunningDeployments (  )  . isEmpty (  )  )  )     {", "for    ( Deployment   deployment    :    deploymentRegistry . getRunningDeployments (  )  )     {", "(  ( DeploymentInternal )     ( deployment )  )  . outOfDate (  )  ;", "}", "logger . println (  )  . println (  \" Reloadable   deployment   detected .    Entering   continuous   build .  \"  )  ;", "ExecutionGate   deploymentRequestExecutionGate    =    deploymentRegistry . getExecutionGate (  )  ;", "executeMultipleBuilds ( action ,    requestContext ,    actionParameters ,    buildSessionScopeServices ,    cancellableOperationManager ,    deploymentRequestExecutionGate )  ;", "}", "cancellableOperationManager . closeInput (  )  ;", "}", "METHOD_END"], "methodName": ["waitForDeployments"], "fileName": "org.gradle.tooling.internal.provider.ContinuousBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   CustomModel ( this )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.tooling.internal.provider.CustomAction"}, {"methodBody": ["METHOD_START", "{", "return   value . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.tooling.internal.provider.CustomPayload"}, {"methodBody": ["METHOD_START", "{", "return    ( buildRequestContext . getCancellationToken (  )  )    instanceof   InternalCancellationToken ;", "}", "METHOD_END"], "methodName": ["doesConsumerSupportCancellation"], "fileName": "org.gradle.tooling.internal.provider.DaemonBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "boolean   continuous    =     (  (  ( action . getStartParameter (  )  )     !  =    null )     &  &     ( action . getStartParameter (  )  . isContinuous (  )  )  )     &  &     ( isNotBuildingModel ( action )  )  ;", "if    ( continuous    &  &     (  !  ( doesConsumerSupportCancellation ( buildRequestContext )  )  )  )     {", "throw   new   UnsupportedVersionException (  \" Continuous   build   requires   Tooling   API   client   version    2  .  1    or   later .  \"  )  ;", "}", "ClassPath   classPath    =    DefaultClassPath . of ( parameters . getInjectedPluginClasspath ( Collections .  < File > emptyList (  )  )  )  ;", "BuildActionParameters   actionParameters    =    new   DefaultBuildActionParameters ( daemonParameters . getEffectiveSystemProperties (  )  ,    daemonParameters . getEnvironmentVariables (  )  ,    SystemProperties . getInstance (  )  . getCurrentDir (  )  ,    parameters . getBuildLogLevel (  )  ,    daemonParameters . isEnabled (  )  ,    continuous ,    false ,    classPath )  ;", "try    {", "return   executer . execute ( action ,    buildRequestContext ,    actionParameters ,    contextServices )  ;", "}    catch    ( ReportedException   e )     {", "Throwable   t    =    e . getCause (  )  ;", "if    ( t   instanceof   InternalTestExecutionException )     {", "throw    (  ( InternalTestExecutionException )     ( t )  )  ;", "}", "while    ( t    !  =    null )     {", "if    ( t   instanceof   BuildCancelledException )     {", "throw   new   tocol . InternalBuildCancelledException ( e . getCause (  )  )  ;", "}", "t    =    t . getCause (  )  ;", "}", "throw   new   tocol . BuildExceptionVersion 1  ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.tooling.internal.provider.DaemonBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( action   instanceof   BuildModelAction )  )     {", "return   true ;", "}", "String   modelName    =     (  ( BuildModelAction )     ( action )  )  . getModelName (  )  ;", "return   modelName . equals ( NULL _ MODEL )  ;", "}", "METHOD_END"], "methodName": ["isNotBuildingModel"], "fileName": "org.gradle.tooling.internal.provider.DaemonBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "try    {", "UnsupportedJavaRuntimeException . assertUsingVersion (  \" G \"  ,    VERSION _  1  _  7  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "DeprecationLogger . nagUserWith ( e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertUsingJava7"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( consumerVersion . compareTo ( DefaultConnection . MIN _ LTS _ CLIENT _ VERSION )  )     <     0  )     &  &     (  ( parameters . getStandardOutput (  )  )     !  =    null )  )     {", "try    {", "parameters . getStandardOutput (  )  . write ( String . format ( DefaultConnection . DEPRECATION _ MESSAGE ,    createCurrentVersionMessage (  )  )  . getBytes (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkDeprecatedTapiVersion"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( consumerVersion )     =  =    null )     |  |     (  ( consumerVersion . compareTo ( DefaultConnection . MIN _ CLIENT _ VERSION )  )     <     0  )  )     {", "throw   unsupportedConnectionException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkUnsupportedTapiVersion"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "assertUsingJava 7  (  )  ;", "ProviderParameters   providerParameters    =    new   ProtocolToModelAdapter (  )  . adapt ( ProviderParameters . class ,    parameters )  ;", "File   gradleUserHomeDir    =    providerParameters . getGradleUserHomeDir ( null )  ;", "if    ( gradleUserHomeDir    =  =    null )     {", "gradleUserHomeDir    =    new   BuildLayoutParameters (  )  . getGradleUserHomeDir (  )  ;", "}", "initializeServices ( gradleUserHomeDir )  ;", "connection . configure ( providerParameters )  ;", "consumerVersion    =    GradleVersion . version ( providerParameters . getConsumerVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( consumerVersion )     =  =    null )     {", "return    \"  \"  ;", "} else    {", "return   String . format (  \" You   are   currently   using      API   version    % s .     \"  ,    consumerVersion . getVersion (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createCurrentVersionMessage"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "throw   unsupportedConnectionException (  )  ;", "}", "METHOD_END"], "methodName": ["executeBuild"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultConnectionMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["getMetaData"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "throw   unsupportedConnectionException (  )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "Object   result    =    c . run ( modelIdentifier . getName (  )  ,    new   DefaultBuildCancellationToken (  )  ,    providerParameters )  ;", "return   new   ProviderBuildResult < Object >  ( result )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "BuildCancellationToken   buildCancellationToken    =    new   InternalCancellationTokenAdapter ( cancellationToken )  ;", "Object   result    =    c . run ( modelIdentifier . getName (  )  ,    buildCancellationToken ,    providerParameters )  ;", "return   new   ProviderBuildResult < Object >  ( result )  ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "throw   unsupportedConnectionException (  )  ;", "}", "METHOD_END"], "methodName": ["getTheModel"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "NativeServices . initialize ( gradleUserHomeDir )  ;", "LoggingServiceRegistry   loggingServices    =    LoggingServiceRegistry . newEmbeddableLogging (  )  ;", "services    =    ServiceRegistryBuilder . builder (  )  . displayName (  \"    services \"  )  . parent ( loggingServices )  . parent ( NativeServices . getInstance (  )  )  . provider ( new   ScopeServices ( loggingServices )  )  . build (  )  ;", "adapter    =    services . get ( ProtocolToModelAdapter . class )  ;", "connection    =    services . get ( Provider . class )  ;", "}", "METHOD_END"], "methodName": ["initializeServices"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "throw   unsupportedConnectionException (  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "Object   results    =    c . run ( action ,    new   DefaultBuildCancellationToken (  )  ,    providerParameters )  ;", "return   new   ProviderBuildResult < T >  (  (  ( T )     ( results )  )  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "BuildCancellationToken   buildCancellationToken    =    new   InternalCancellationTokenAdapter ( cancellationToken )  ;", "Object   results    =    c . run ( action ,    buildCancellationToken ,    providerParameters )  ;", "return   new   ProviderBuildResult < T >  (  (  ( T )     ( results )  )  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "BuildCancellationToken   buildCancellationToken    =    new   InternalCancellationTokenAdapter ( cancellationToken )  ;", "Object   results    =    c . run ( action ,    buildCancellationToken ,    providerParameters )  ;", "return   new   ProviderBuildResult < T >  (  (  ( T )     ( results )  )  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderOperationParameters   providerParameters    =    validateAndConvert ( operationParameters )  ;", "ProviderInternalTestExecutionRequest   testExecutionRequestVersion 2     =    adapter . adapt ( ProviderInternalTestExecutionRequest . class ,    testExecutionRequest )  ;", "BuildCancellationToken   buildCancellationToken    =    new   InternalCancellationTokenAdapter ( cancellationToken )  ;", "Object   results    =    c . runTests ( testExecutionRequestVersion 2  ,    buildCancellationToken ,    providerParameters )  ;", "return   new   ProviderBuildResult < Object >  ( results )  ;", "}", "METHOD_END"], "methodName": ["runTests"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "CompositeStoppable . stoppable ( services )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "return   new   UnsupportedVersionException ( String . format ( DefaultConnection . UNSUPPORTED _ MESSAGE ,    createCurrentVersionMessage (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unsupportedConnectionException"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "DefaultConnection . LOGGER . info (  \" Tooling   API   is   using   target   Gradle   version :     {  }  .  \"  ,    GradleVersion . current (  )  . getVersion (  )  )  ;", "assertUsingJava 7  (  )  ;", "checkUnsupportedTapiVersion (  )  ;", "ProviderOperationParameters   parameters    =    adapter . builder ( ProviderOperationParameters . class )  . mixInTo ( ProviderOperationParameters . class ,    BuildLogLevelMixIn . class )  . build ( buildParameters )  ;", "checkDeprecatedTapiVersion ( parameters )  ;", "DeprecationLogger . reset (  )  ;", "return   parameters ;", "}", "METHOD_END"], "methodName": ["validateAndConvert"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnection"}, {"methodBody": ["METHOD_START", "{", "return    \" Gradle    \"     +     ( getVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnectionMetaData"}, {"methodBody": ["METHOD_START", "{", "return   GradleVersion . current (  )  . getVersion (  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.tooling.internal.provider.DefaultConnectionMetaData"}, {"methodBody": ["METHOD_START", "{", "return   cancellationToken . addCallback ( cancellationHandler )  ;", "}", "METHOD_END"], "methodName": ["addCallback"], "fileName": "org.gradle.tooling.internal.provider.InternalCancellationTokenAdapter"}, {"methodBody": ["METHOD_START", "{", "return   cancellationToken . isCancellationRequested (  )  ;", "}", "METHOD_END"], "methodName": ["isCancellationRequested"], "fileName": "org.gradle.tooling.internal.provider.InternalCancellationTokenAdapter"}, {"methodBody": ["METHOD_START", "{", "cancellationToken . removeCallback ( cancellationHandler )  ;", "}", "METHOD_END"], "methodName": ["removeCallback"], "fileName": "org.gradle.tooling.internal.provider.InternalCancellationTokenAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Boolean . TRUE . equals ( actionParameters . isColorOutput ( null )  )  )     &  &     (  ( actionParameters . getStandardOutput (  )  )     !  =    null )  )     {", "loggingManager . attachConsole ( actionParameters . getStandardOutput (  )  ,    notNull ( actionParameters . getStandardError (  )  )  ,    Rich )  ;", "} else", "if    (  (  ( actionParameters . getStandardOutput (  )  )     !  =    null )     |  |     (  ( actionParameters . getStandardError (  )  )     !  =    null )  )     {", "loggingManager . attachConsole ( notNull ( actionParameters . getStandardOutput (  )  )  ,    notNull ( actionParameters . getStandardError (  )  )  ,    ConsoleOutput . Plain )  ;", "}", "ProgressListenerVersion 1    progressListener    =    actionParameters . getProgressListener (  )  ;", ". OutputEventListenerAdapter   listener    =    new    . OutputEventListenerAdapter ( progressListener )  ;", "loggingManager . addOutputEventListener ( listener )  ;", "loggingManager . setLevelInternal ( actionParameters . getBuildLogLevel (  )  )  ;", "loggingManager . start (  )  ;", "try    {", "return   executer . execute ( action ,    buildRequestContext ,    actionParameters ,    contextServices )  ;", "}    finally    {", "loggingManager . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.tooling.internal.provider.LoggingBridgingBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( outputStream    =  =    null )     {", "return   NullOutputStream . INSTANCE ;", "}", "return   outputStream ;", "}", "METHOD_END"], "methodName": ["notNull"], "fileName": "org.gradle.tooling.internal.provider.LoggingBridgingBuildActionExecuter"}, {"methodBody": ["METHOD_START", "{", "LogLevel   providerLogLevel    =     ( parameters . getVerboseLogging (  )  )     ?    LogLevel . DEBUG    :    LogLevel . INFO ;", ". LOGGER . debug (  \" Configuring   logging   to   level :     {  }  \"  ,    providerLogLevel )  ;", "LoggingManagerInternal   loggingManager    =    loggingServices . newInstance ( LoggingManagerInternal . class )  ;", "loggingManager . setLevelInternal ( providerLogLevel )  ;", "loggingManager . start (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "LoggingManagerIloggingManager ;", "BuildActionExecuter < BuildActionParameters >    executer ;", "if    ( Boolean . TRUE . equals ( operationParameters . isEmbedded (  )  )  )     {", "loggingManager    =    loggingServices . getFactory ( LoggingManagerIclass )  . create (  )  ;", "loggingManager . captureSystemSources (  )  ;", "executer    =    embeddedExecutor ;", "} else    {", "LoggingServiceRegistry   loggingServices    =    LoggingServiceRegistry . newNestedLogging (  )  ;", "loggingManager    =    loggingServices . getFactory ( LoggingManagerIclass )  . create (  )  ;", "InputStream   standardInput    =    operationParameters . getStandardInput (  )  ;", "ServiceRegistry   clientServices    =    daemonClientFactory . createBuildClientServices ( loggingServices . get ( OutputEventListener . class )  ,    params . daemonParams ,     ( standardInput    =  =    null    ?    SafeStreams . emptyInput (  )     :    standardInput )  )  ;", "executer    =    clientServices . get ( DaemonClient . class )  ;", "}", "return   new   LoggingBridgingBuildActionExecuter ( new   DaemonBuildActionExecuter ( executer ,    params . daemonParams )  ,    loggingManager )  ;", "}", "METHOD_END"], "methodName": ["createExecuter"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "BuildLayoutParameters   layout    =    new   BuildLayoutParameters (  )  ;", "if    (  ( operationParameters . getGradleUserHomeDir (  )  )     !  =    null )     {", "layout . setGradleUserHomeDir ( operationParameters . getGradleUserHomeDir (  )  )  ;", "}", "layout . setSearchUpwards (  (  ( operationParameters . isSearchUpwards (  )  )     !  =    null    ?    operationParameters . isSearchUpwards (  )     :    true )  )  ;", "layout . setProjectDir ( operationParameters . getProjectDir (  )  )  ;", "Map < String ,    String >    properties    =    new   HashMap < String ,    String >  (  )  ;", "new   LayoutToPropertiesConverter ( buildLayoutFactory )  . convert ( layout ,    properties )  ;", "DaemonParameters   daemonParams    =    new   DaemonParameters ( layout )  ;", "new   PropertiesToDaemonParametersConverter (  )  . convert ( properties ,    daemonParams )  ;", "if    (  ( operationParameters . getDaemonBaseDir ( null )  )     !  =    null )     {", "daemonParams . setBaseDir ( operationParameters . getDaemonBaseDir ( null )  )  ;", "}", "List < String >    jvmArguments    =    operationParameters . getJvmArguments (  )  ;", "if    ( jvmArguments    !  =    null )     {", "daemonParams . setJvmArgs ( jvmArguments )  ;", "}", "Map < String ,    String >    envVariables    =    null ;", "try    {", "envVariables    =    operationParameters . getEnvironmentVariables (  )  ;", "}    catch    ( UnsupportedMethodException   e )     {", ". LOGGER . debug (  \" Environment   variables   customization   is   not   supported   by   target   Gradle   instance \"  ,    e )  ;", "}", "if    ( envVariables    !  =    null )     {", "daemonParams . setEnvironmentVariables ( envVariables )  ;", "}", "File   javaHome    =    operationParameters . getJavaHome (  )  ;", "if    ( javaHome    !  =    null )     {", "daemonParams . setJvm ( Jvm . forHome ( javaHome )  )  ;", "}", "daemonParams . applyDefaultsFor ( jvmVersionDetector . getJavaVersion ( daemonParams . getEffectiveJvm (  )  )  )  ;", "if    (  (  ( operationParameters . getDaemonMaxIdleTimeValue (  )  )     !  =    null )     &  &     (  ( operationParameters . getDaemonMaxIdleTimeUnits (  )  )     !  =    null )  )     {", "int   idleTimeout    =     (  ( int )     ( operationParameters . getDaemonMaxIdleTimeUnits (  )  . toMillis ( operationParameters . getDaemonMaxIdleTimeValue (  )  )  )  )  ;", "daemonParams . setIdleTimeout ( idleTimeout )  ;", "}", "return   new    . Parameters ( daemonParams ,    properties ,    layout . getGradleUserHomeDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["initParams"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "List < String >    tasks    =    providerParameters . getTasks (  )  ;", "if    (  ( modelName . equals ( NULL _ MODEL )  )     &  &     ( tasks    =  =    null )  )     {", "throw   new   IllegalArgumentException (  \" No   model   type   or   tasks   specified .  \"  )  ;", "}", "ProviderConnection . Parameters   params    =    initParams ( providerParameters )  ;", "Class <  ?  >    type    =    new   ModelMapping (  )  . getProtocolTypeFromModelName ( modelName )  ;", "if    ( type    =  =     ( InternalBuildEnvironment . class )  )     {", "if    ( tasks    !  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   run   tasks   and   fetch   the   build   environment   model .  \"  )  ;", "}", "return   new   build . DefaultBuildEnvironment ( new   DefaultBuildIdentifier ( providerParameters . getProjectDir (  )  )  ,    params . gradleUserhome ,    GradleVersion . current (  )  . getVersion (  )  ,    params . daemonParams . getEffectiveJvm (  )  . getJavaHome (  )  ,    params . daemonParams . getEffectiveJvmArgs (  )  )  ;", "}", "StartParameterInternal   startParameter    =    new   ProviderStartParameterConverter (  )  . toStartParameter ( providerParameters ,    params . properties )  ;", "ProviderConnection . ProgressListenerConfiguration   listenerConfig    =    ProviderConnection . ProgressListenerConfiguration . from ( providerParameters )  ;", "BuildAction   action    =    new   BuildModelAction ( startParameter ,    modelName ,     ( tasks    !  =    null )  ,    listenerConfig . clientSubscriptions )  ;", "return   run ( action ,    cancellationToken ,    listenerConfig ,    providerParameters ,    params )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "try    {", "BuildActionExecuter < ProviderOperationParameters >    executer    =    createExecuter ( providerParameters ,    parameters )  ;", "BuildRequestContext   buildRequestContext    =    new   initialization . DefaultBuildRequestContext ( new   DefaultBuildRequestMetaData ( providerParameters . getStartTime (  )  )  ,    cancellationToken ,    progressListenerConfiguration . buildEventConsumer )  ;", "BuildActionResult   result    =     (  ( BuildActionResult )     ( executer . execute ( action ,    buildRequestContext ,    providerParameters ,    sharedServices )  )  )  ;", "if    (  ( result . failure )     !  =    null )     {", "throw    (  ( RuntimeException )     ( payloadSerializer . deserialize ( result . failure )  )  )  ;", "}", "return   payloadSerializer . deserialize ( result . result )  ;", "}    finally    {", "progressListenerConfiguration . failsafeWrapper . rethrowErrors (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "return   runClientAction ( clientAction ,    cancellationToken ,    providerParameters )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "return   runClientAction ( clientAction ,    cancellationToken ,    providerParameters )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "List < String >    tasks    =    providerParameters . getTasks (  )  ;", "SerializedPayload   serializedAction    =    payloadSerializer . serialize ( clientAction )  ;", ". Parameters   params    =    initParams ( providerParameters )  ;", "StartParameterInternal   startParameter    =    new   ProviderStartParameterConverter (  )  . toStartParameter ( providerParameters ,    params . properties )  ;", ". ProgressListenerConfiguration   listenerConfig    =     . ProgressListenerConfiguration . from ( providerParameters )  ;", "BuildAction   action    =    new   ClientProvidedBuildAction ( startParameter ,    serializedAction ,     ( tasks    !  =    null )  ,    listenerConfig . clientSubscriptions )  ;", "return   run ( action ,    cancellationToken ,    listenerConfig ,    providerParameters ,    params )  ;", "}", "METHOD_END"], "methodName": ["runClientAction"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "ProviderConnection . Parameters   params    =    initParams ( providerParameters )  ;", "StartParameterInternal   startParameter    =    new   ProviderStartParameterConverter (  )  . toStartParameter ( providerParameters ,    params . properties )  ;", "ProviderConnection . ProgressListenerConfiguration   listenerConfig    =    ProviderConnection . ProgressListenerConfiguration . from ( providerParameters )  ;", "TestExecutionRequestAction   action    =    TestExecutionRequestAction . create ( listenerConfig . clientSubscriptions ,    startParameter ,    testExecutionRequest )  ;", "return   run ( action ,    cancellationToken ,    listenerConfig ,    providerParameters ,    params )  ;", "}", "METHOD_END"], "methodName": ["runTests"], "fileName": "org.gradle.tooling.internal.provider.ProviderConnection"}, {"methodBody": ["METHOD_START", "{", "StartParameterInternal   startParameter    =    new   StartParameterInternal (  )  ;", "startParameter . setProjectDir ( parameters . getProjectDir (  )  )  ;", "if    (  ( parameters . getGradleUserHomeDir (  )  )     !  =    null )     {", "startParameter . setGradleUserHomeDir ( parameters . getGradleUserHomeDir (  )  )  ;", "}", "List < InternalLaunchable >    launchables    =    parameters . getLaunchables ( null )  ;", "if    ( launchables    !  =    null )     {", "startParameter . setTaskRequests ( unpack ( launchables ,    parameters . getProjectDir (  )  )  )  ;", "} else", "if    (  ( parameters . getTasks (  )  )     !  =    null )     {", "startParameter . setTaskNames ( parameters . getTasks (  )  )  ;", "}", "new   PropertiesToStartParameterConverter (  )  . convert ( properties ,    startParameter )  ;", "List < String >    arguments    =    parameters . getArguments (  )  ;", "if    ( arguments    !  =    null )     {", "DefaultCommandLineConverter   converter    =    new   DefaultCommandLineConverter (  )  ;", "try    {", "converter . convert ( arguments ,    startParameter )  ;", "}    catch    ( CommandLineArgumentException   e )     {", "throw   new   tocol . exceptions . InternalUnsupportedBuildArgumentException (  (  (  (  (  (  (  (  (  (  \" Problem   with   provided   build   arguments :     \"     +    arguments )     +     \"  .     \"  )     +     \"  \\ n \"  )     +     ( e . getMessage (  )  )  )     +     \"  \\ nEither   it   is   not   a   valid   build   option   or   it   is   not   supported   in   the   target   Gradle   version .  \"  )     +     \"  \\ nNot   all   of   the   Gradle   command   line   options   are   supported   build   arguments .  \"  )     +     \"  \\ nExamples   of   supported   build   arguments :     \\  '  -  - info \\  '  ,     \\  '  - u \\  '  ,     \\  '  - p \\  '  .  \"  )     +     \"  \\ nExamples   of   unsupported   build   options :     \\  '  -  - daemon \\  '  ,     \\  '  -  ?  \\  '  ,     \\  '  - v \\  '  .  \"  )     +     \"  \\ nPlease   find   more   information   in   the   \"  )  ,    e )  ;", "}", "}", "if    (  ( parameters . isSearchUpwards (  )  )     !  =    null )     {", "startParameter . setSearchUpwards ( parameters . isSearchUpwards (  )  )  ;", "}", "if    (  ( parameters . getBuildLogLevel (  )  )     !  =    null )     {", "startParameter . setLogLevel ( parameters . getBuildLogLevel (  )  )  ;", "}", "if    (  ( parameters . getStandardInput (  )  )     !  =    null )     {", "startParameter . setInteractive ( true )  ;", "}", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["toStartParameter"], "fileName": "org.gradle.tooling.internal.provider.ProviderStartParameterConverter"}, {"methodBody": ["METHOD_START", "{", "List < TaskExecutionRequest >    requests    =    new   ArrayList < TaskExecutionRequest >  ( launchables . size (  )  )  ;", "for    ( InternalLaunchable   launchable    :    launchables )     {", "if    ( launchable   instanceof   TaskExecutionRequest )     {", "TaskExecutionRequest   originalLaunchable    =     (  ( TaskExecutionRequest )     ( launchable )  )  ;", "TaskExecutionRequest   launchableImpl    =    new   DefaultTaskExecutionRequest ( originalLaunchable . getArgs (  )  ,    originalLaunchable . getProjectPath (  )  ,    originalLaunchable . getRootDir (  )  )  ;", "requests . add ( launchableImpl )  ;", "} else    {", "throw   new   tocol . exceptions . InternalUnsupportedBuildArgumentException (  (  (  (  \" Problem   with   provided   launchable   arguments :     \"     +    launchables )     +     \"  .     \"  )     +     \"  \\ nOnly   objects   from   this   provider   can   be   built .  \"  )  )  ;", "}", "}", "return   requests ;", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "org.gradle.tooling.internal.provider.ProviderStartParameterConverter"}, {"methodBody": ["METHOD_START", "{", "daemons . add ( daemon )  ;", "}", "METHOD_END"], "methodName": ["daemonStarted"], "fileName": "org.gradle.tooling.internal.provider.ShutdownCoordinator"}, {"methodBody": ["METHOD_START", "{", "client . gracefulStop ( daemons )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.tooling.internal.provider.ShutdownCoordinator"}, {"methodBody": ["METHOD_START", "{", "return   clientSubscriptions ;", "}", "METHOD_END"], "methodName": ["getClientSubscriptions"], "fileName": "org.gradle.tooling.internal.provider.SubscribableBuildAction"}, {"methodBody": ["METHOD_START", "{", "listeners . add ( listener )  ;", "bOperationListenerManager . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.gradle.tooling.internal.provider.SubscribableBuildActionRunner"}, {"methodBody": ["METHOD_START", "{", "BuildEventConsumer   eventConsumer    =    gradle . getServices (  )  . get ( BuildEventConsumer . class )  ;", "for    ( Registration   registration    :    registrations )     {", "for    ( BuildOperationListener   listener    :    registration . createListeners ( clientSubscriptions ,    eventConsumer )  )     {", "registerListener ( listener )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["registerListenersForClientSubscriptions"], "fileName": "org.gradle.tooling.internal.provider.SubscribableBuildActionRunner"}, {"methodBody": ["METHOD_START", "{", "final   Collection < String >    testClassNames    =    testExecutionRequest . getTestClassNames (  )  ;", "final   Collection < InternalJvmTestRequest >    internalJvmTestRequests    =    testExecutionRequest . getInternalJvmTestRequests ( Collections .  < InternalJvmTestRequest > emptyList (  )  )  ;", "Set < InternalJvmTestRequest >    providerInternalJvmTestRequests    =    ImmutableSet . copyOf (  . toProviderInternalJvmTestRequest ( internalJvmTestRequests ,    testClassNames )  )  ;", "return   new    ( clientSubscriptions ,    startParameter ,    ImmutableSet . copyOf ( testExecutionRequest . getTestExecutionDescriptors (  )  )  ,    ImmutableSet . copyOf ( testClassNames )  ,    providerInternalJvmTestRequests )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.tooling.internal.provider.TestExecutionRequestAction"}, {"methodBody": ["METHOD_START", "{", "return   internalJvmTestRequests ;", "}", "METHOD_END"], "methodName": ["getInternalJvmTestRequests"], "fileName": "org.gradle.tooling.internal.provider.TestExecutionRequestAction"}, {"methodBody": ["METHOD_START", "{", "return   classNames ;", "}", "METHOD_END"], "methodName": ["getTestClassNames"], "fileName": "org.gradle.tooling.internal.provider.TestExecutionRequestAction"}, {"methodBody": ["METHOD_START", "{", "return   testDescriptors ;", "}", "METHOD_END"], "methodName": ["getTestExecutionDescriptors"], "fileName": "org.gradle.tooling.internal.provider.TestExecutionRequestAction"}, {"methodBody": ["METHOD_START", "{", "if    ( internalJvmTestRequests . isEmpty (  )  )     {", "return   CollectionUtils . collect ( testClassNames ,    new   api . Transformer < InternalJvmTestRequest ,    String >  (  )     {", "@ Override", "public   InternalJvmTestRequest   transform ( String   testClass )     {", "return   new   ProviderInternalJvmTestRequest ( testClass ,    null )  ;", "}", "}  )  ;", "} else    {", "return   CollectionUtils . collect ( internalJvmTestRequests ,    new   api . Transformer < InternalJvmTestRequest ,    InternalJvmTestRequest >  (  )     {", "@ Override", "public   InternalJvmTestRequest   transform ( InternalJvmTestRequest   internalTestMethod )     {", "return   new   ProviderInternalJvmTestRequest ( internalTestMethod . getClassName (  )  ,    internalTestMethod . getMethodName (  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["toProviderInternalJvmTestRequest"], "fileName": "org.gradle.tooling.internal.provider.TestExecutionRequestAction"}, {"methodBody": ["METHOD_START", "{", "return   payload . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.tooling.internal.provider.WrapperPayload"}, {"methodBody": ["METHOD_START", "{", "LoggingCommandLineConverter   converter    =    new   LoggingCommandLineConverter (  )  ;", "CommandLineParser   parser    =    new   CommandLineParser (  )  . allowUnknownOptions (  )  . allowMixedSubcommandsAndOptions (  )  ;", "converter . configure ( parser )  ;", "List < String >    arguments    =    parameters . getArguments (  )  ;", "ParsedCommandLine   parsedCommandLine    =    parser . parse (  ( arguments    =  =    null    ?    Collections .  < String > emptyList (  )     :    arguments )  )  ;", "if    (  ( parameters . getVerboseLogging (  )  )     &  &     (  !  ( parsedCommandLine . hasAnyOption ( converter . getOptions (  )  )  )  )  )     {", "return    . DEBUG ;", "}", "LoggingConfiguration   loggingConfiguration    =    converter . convert ( parsedCommandLine ,    new   DefaultLoggingConfiguration (  )  )  ;", "return   loggingConfiguration . get (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildLogLevel"], "fileName": "org.gradle.tooling.internal.provider.connection.BuildLogLevelMixIn"}, {"methodBody": ["METHOD_START", "{", "return   result ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.tooling.internal.provider.connection.ProviderBuildResult"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractProgressEvent"}, {"methodBody": ["METHOD_START", "{", "return   eventTime ;", "}", "METHOD_END"], "methodName": ["getEventTime"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractProgressEvent"}, {"methodBody": ["METHOD_START", "{", "return   endTime ;", "}", "METHOD_END"], "methodName": ["getEndTime"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractResult"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getFailures"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractResult"}, {"methodBody": ["METHOD_START", "{", "return   outcomeDescription ;", "}", "METHOD_END"], "methodName": ["getOutcomeDescription"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractResult"}, {"methodBody": ["METHOD_START", "{", "return   startTime ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.tooling.internal.provider.events.AbstractResult"}, {"methodBody": ["METHOD_START", "{", "StringWriter   out    =    new   StringWriter (  )  ;", "PrintWriter   wrt    =    new   PrintWriter ( out )  ;", "t . printStackTrace ( wrt )  ;", "Throwable   cause    =    t . getCause (  )  ;", "causeFailure    =     (  ( cause    !  =    null )     &  &     ( cause    !  =    t )  )     ?     . fromThrowable ( cause )     :    null ;", "return   new    ( t . getMessage (  )  ,    out . toString (  )  ,    causeFailure )  ;", "}", "METHOD_END"], "methodName": ["fromThrowable"], "fileName": "org.gradle.tooling.internal.provider.events.DefaultFailure"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.tooling.internal.provider.events.DefaultFailure"}, {"methodBody": ["METHOD_START", "{", "return   message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.tooling.internal.provider.events.DefaultFailure"}, {"methodBody": ["METHOD_START", "{", "return   taskPath ;", "}", "METHOD_END"], "methodName": ["getTaskPath"], "fileName": "org.gradle.tooling.internal.provider.events.DefaultTestDescriptor"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "for    (    classLoader    :    classLoaderDetails . asMap (  )  . keySet (  )  )     {", "Utils . tryClose ( classLoader )  ;", "}", "classLoaderDetails . invalidateAll (  )  ;", "classLoaderIds . invalidateAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "classLoader    =    classLoaderIds . getIfPresent ( details . uuid )  ;", "if    ( classLoader    !  =    null )     {", "return   classLoader ;", "}", "classLoader    =    factory . transform ( details )  ;", "classLoaderIds . put ( details . uuid ,    classLoader )  ;", "classLoaderDetails . put ( classLoader ,    details )  ;", "return   classLoader ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "Details   details    =    classLoaderDetails . getIfPresent ( classLoader )  ;", "if    ( details    !  =    null )     {", "return   details ;", "}", "details    =    factory . transform ( classLoader )  ;", "classLoaderDetails . put ( classLoader ,    details )  ;", "classLoaderIds . put ( details . uuid ,    classLoader )  ;", "return   details ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDetails"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "return   cDetails . getIfPresent ( c )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeGetDetails"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   targetClassLoader    =    target . getClassLoader (  )  ;", "if    (  ( targetClassLoader    =  =    null )     |  |     ( targetClassLoader    =  =     ( ClassLoaderUtils . getPlatformClassLoader (  )  )  )  )     {", "return ;", "}", "if    (  !  ( visited . add ( target )  )  )     {", "return ;", "}", "String   resourceName    =     ( target . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )     +     \"  . class \"  ;", "URL   resource    =    targetClassLoader . getResource ( resourceName )  ;", "try    {", "if    ( resource    =  =    null )     {", ". LOGGER . warn (  \" Could   not   determine   classpath   for    {  }  \"  ,    target )  ;", "return ;", "}", "File   classPathRoot    =    ClasspathUtil . getClasspathForClass ( target )  ;", "dest . add ( classPathRoot . toURI (  )  . toURL (  )  )  ;", "ClassReader   reader ;", "URLConnection   urlConnection    =    resource . openConnection (  )  ;", "if    ( urlConnection   instanceof   JarURLConnection )     {", "urlConnection . setUseCaches ( false )  ;", "}", "InputStream   inputStream    =    urlConnection . getInputStream (  )  ;", "try    {", "reader    =    new   ClassReader ( ByteStreams . toByteArray ( inputStream )  )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "char [  ]    charBuffer    =    new   char [ reader . getMaxStringLength (  )  ]  ;", "for    ( int   i    =     1  ;    i    <     ( reader . getItemCount (  )  )  ;    i +  +  )     {", "int   itemOffset    =    reader . getItem ( i )  ;", "if    (  ( itemOffset    >     0  )     &  &     (  ( reader . readByte (  ( itemOffset    -     1  )  )  )     =  =     7  )  )     {", "String   classDescriptor    =    reader . readUTF 8  ( itemOffset ,    charBuffer )  ;", "Type   type    =    Type . getObjectType ( classDescriptor )  ;", "while    (  ( type . getSort (  )  )     =  =     ( Type . ARRAY )  )     {", "type    =    type . getElementType (  )  ;", "}", "if    (  ( type . getSort (  )  )     !  =     ( Type . OBJECT )  )     {", "continue ;", "}", "String   className    =    type . getClassName (  )  ;", "if    ( className . equals ( target . getName (  )  )  )     {", "continue ;", "}", "Class <  ?  >    cl ;", "try    {", "cl    =    Class . forName ( className ,    false ,    targetClassLoader )  ;", "}    catch    ( ClassNotFoundException   e )     {", ". LOGGER . warn (  \" Could   not   determine   classpath   for    {  }  \"  ,    target )  ;", "continue ;", "}", "find ( cl ,    visited ,    dest )  ;", "}", "}", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   determine   the   class - path   for    % s .  \"  ,    target )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClasspathInferer"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "Collection < URL >    classPath    =    classPathCache . get ( target )  ;", "if    ( classPath    =  =    null )     {", "Set <  <  ?  >  >    visited    =    new   HashSet <  <  ?  >  >  (  )  ;", "classPath    =    new   LinkedHashSet < URL >  (  )  ;", "find ( target ,    visited ,    classPath )  ;", "classPathCache . put ( target ,    classPath )  ;", "}", "dest . addAll ( classPath )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getClassPathFor"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClasspathInferer"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientOwnedClassLoaderSpec"}, {"methodBody": ["METHOD_START", "{", "if    ( spec   instanceof   VisitableURLClassLoader . Spec )     {", "VisitableURLClassLoader . Spec   clSpec    =     (  ( VisitableURLClassLoader . Spec )     ( spec )  )  ;", "if    (  ( parents . size (  )  )     !  =     1  )     {", "throw   new   IllegalStateException (  \" Expected   exactly   one   parent   ClassLoader \"  )  ;", "}", "return   new    . MixInClassLoader ( parents . get (  0  )  ,    clSpec . getClasspath (  )  )  ;", "}", "return   classLoaderFactory . getClassLoaderFor ( spec ,    parents )  ;", "}", "METHOD_END"], "methodName": ["getClassLoaderFor"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientSidePayloadClassLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "ClientSidePayloadClassLoaderRegistry . LocalClassLoaderMapping   localClassLoaderMapping    =    classLoaders . get ( uuid )  ;", "if    ( localClassLoaderMapping    =  =    null )     {", "return   null ;", "}", "Set < ClassLoader >    candidates    =    Sets . newLinkedHashSet (  )  ;", "for    ( WeakReference < ClassLoader >    reference    :    localClassLoaderMapping . classLoaders )     {", "ClassLoader   classLoader    =    reference . get (  )  ;", "if    ( classLoader    !  =    null )     {", "candidates . add ( classLoader )  ;", "}", "}", "return   candidates ;", "}", "METHOD_END"], "methodName": ["getClassLoaders"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientSidePayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( ClientSidePayloadClassLoaderRegistry . LocalClassLoaderMapping   localClassLoaderMapping    :    new   ArrayList < ClientSidePayloadClassLoaderRegistry . LocalClassLoaderMapping >  ( classLoaders . values (  )  )  )     {", "Set < ClassLoader >    localCandidates    =    new   LinkedHashSet < ClassLoader >  (  )  ;", "for    ( WeakReference < ClassLoader >    reference    :    localClassLoaderMapping . classLoaders )     {", "ClassLoader   cl    =    reference . get (  )  ;", "if    ( cl    !  =    null )     {", "localCandidates . add ( cl )  ;", "}", "}", "if    ( localCandidates . isEmpty (  )  )     {", "classLoaders . remove ( localClassLoaderMapping . uuid )  ;", "continue ;", "}", "if    ( localCandidates . equals ( candidates )  )     {", "return   localClassLoaderMapping . uuid ;", "}", "}", "ClientSidePayloadClassLoaderRegistry . LocalClassLoaderMapping   details    =    new   ClientSidePayloadClassLoaderRegistry . LocalClassLoaderMapping ( UUID . randomUUID (  )  )  ;", "for    ( ClassLoader   candidate    :    candidates )     {", "details . classLoaders . add ( new   WeakReference < ClassLoader >  ( candidate )  )  ;", "}", "classLoaders . put ( details . uuid ,    details )  ;", "return   details . uuid ;", "}", "METHOD_END"], "methodName": ["getUuidForLocalClassLoaders"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientSidePayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "final   DeserializeMap   deserializeMap    =    delegate . newDeserializeSession (  )  ;", "return   new   DeserializeMap (  )     {", "public   Class <  ?  >    resolveClass ( Details   classLoaderDetails ,    String   className )    throws   ClassNotFoundException    {", "Set <  >    candidates ;", "lock . lock (  )  ;", "try    {", "candidates    =    gets ( classLoaderDetails . uuid )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "if    ( candidates    !  =    null )     {", "for    (    candidate    :    candidates )     {", "try    {", "return   candidate . loadClass ( className )  ;", "}    catch    ( ClassNotFoundException   e )     {", "}", "}", "throw   new   UnsupportedOperationException (  \" Unexpected   class   received   in   response .  \"  )  ;", "}", "return   deserializeMap . resolveClass ( classLoaderDetails ,    className )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newDeserializeSession"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientSidePayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "final   Set < ClassLoader >    candidates    =    new   LinkedHashSet < ClassLoader >  (  )  ;", "final   Set < URL >    classPath    =    new   LinkedHashSet < URL >  (  )  ;", "final   Map < ClassLoader ,    Short >    classLoaderIds    =    new   HashMap < ClassLoader ,    Short >  (  )  ;", "final   Map < Short ,    ClassLoaderDetails >    classLoaderDetails    =    new   HashMap < Short ,    ClassLoaderDetails >  (  )  ;", "return   new   SerializeMap (  )     {", "public   short   visitClass ( Class <  ?  >    target )     {", "ClassLoader   classLoader    =    target . getClassLoader (  )  ;", "Short   id    =    classLoaderIds . get ( classLoader )  ;", "if    ( id    !  =    null )     {", "return   id ;", "}", "ClassLoaderDetails   details    =    classLoaderCache . maybeGetDetails ( classLoader )  ;", "if    ( details    !  =    null )     {", "id    =     (  ( short )     (  (  ( classLoaderIds . size (  )  )     +     (  . CLIENT _ CLASS _ LOADER _ ID )  )     +     1  )  )  ;", "classLoaderIds . put ( classLoader ,    id )  ;", "classLoaderDetails . put ( id ,    details )  ;", "return   id ;", "}", "classpathInferer . getClassPathFor ( target ,    classPath )  ;", "candidates . add ( target . getClassLoader (  )  )  ;", "return    . CLIENT _ CLASS _ LOADER _ ID ;", "}", "@ Override", "public   void   collectClassLoaderDefinitions ( Map < Short ,    ClassLoaderDetails >    details )     {", "lock . lock (  )  ;", "UUID   uuid ;", "try    {", "uuid    =    getUuidForLocalClassLoaders ( candidates )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "details . putAll ( classLoaderDetails )  ;", "details . put (  . CLIENT _ CLASS _ LOADER _ ID ,    new   ClassLoaderDetails ( uuid ,    new   ClientOwnedClassLoaderSpec ( new   ArrayList < URL >  ( classPath )  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newSerializeSession"], "fileName": "org.gradle.tooling.internal.provider.serialization.ClientSidePayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parents . size (  )  )     !  =     1  )     {", "throw   new   IllegalStateException (  \" Expected   exactly   one   parent    \"  )  ;", "}", "Collection < URL >    cachedClassPathUrls    =    cachedClasspathTransformer . transform ( classpath )  ;", "return   new   VisitableURL ( parents . get (  0  )  ,    cachedClassPathUrls )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderForClassPath"], "fileName": "org.gradle.tooling.internal.provider.serialization.DaemonSidePayloadClassLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( spec   instanceof   ClientOwnedClassLoaderSpec )     {", "ClientOwnedClassLoaderSpec   clientSpec    =     (  ( ClientOwnedClassLoaderSpec )     ( spec )  )  ;", "return   createClassLoaderForClassPath ( parents ,    clientSpec . getClasspath (  )  )  ;", "}", "if    ( spec   instanceof   VisitableURLClassLoader . Spec )     {", "VisitableURLClassLoader . Spec   urlSpec    =     (  ( VisitableURLClassLoader . Spec )     ( spec )  )  ;", "return   createClassLoaderForClassPath ( parents ,    urlSpec . getClasspath (  )  )  ;", "}", "return   delegate . getClassLoaderFor ( spec ,    parents )  ;", "}", "METHOD_END"], "methodName": ["getClassLoaderFor"], "fileName": "org.gradle.tooling.internal.provider.serialization.DaemonSidePayloadClassLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    cache . getClassLoader ( details ,    detailsToClassLoader )  ;", "if    (  ( details . spec )    instanceof   ClientOwneSpec )     {", "ClientOwneSpec   spec    =     (  ( ClientOwneSpec )     ( details . spec )  )  ;", "VisitableURLClassLoader   urlClassLoader    =     (  ( VisitableURLClassLoader )     ( classLoader )  )  ;", "Set < URL >    currentClassPath    =    ImmutableSet . copyOf ( urlClassLoader . getURLs (  )  )  ;", "for    ( URL   url    :    spec . getClasspath (  )  )     {", "if    (  !  ( currentClassPath . contains ( url )  )  )     {", "JavaReflectionUtil . method ( URLClassLoader . class ,    Void . class ,     \" addURL \"  ,    URL . class )  . invoke ( urlClassLoader ,    url )  ;", "}", "}", "}", "return   classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.gradle.tooling.internal.provider.serialization.DefaultPayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   cache . getDetails ( classLoader ,    classLoaderToDetails )  ;", "}", "METHOD_END"], "methodName": ["getDetails"], "fileName": "org.gradle.tooling.internal.provider.serialization.DefaultPayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   DeserializeMap (  )     {", "public   Class <  ?  >    resolveClass ( Details   classLoaderDetails ,    String   className )    throws   ClassNotFoundException    {", "classLoader    =    get ( classLoaderDetails )  ;", "return   Class . forName ( className ,    false ,    classLoader )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newDeserializeSession"], "fileName": "org.gradle.tooling.internal.provider.serialization.DefaultPayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   SerializeMap (  )     {", "final   Map <  ,    Short >    classLoaderIds    =    new   HashMap <  ,    Short >  (  )  ;", "final   Map < Short ,    Details >    classLoaderDetails    =    new   HashMap < Short ,    Details >  (  )  ;", "public   short   visitClass ( Class <  ?  >    target )     {", "classLoader    =    target . get (  )  ;", "Short   id    =    classLoaderIds . get ( classLoader )  ;", "if    ( id    !  =    null )     {", "return   id ;", "}", "if    (  ( classLoaderIds . size (  )  )     =  =     ( Short . MAX _ VALUE )  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "Details   details    =    getDetails ( classLoader )  ;", "id    =     (  ( short )     (  ( classLoaderIds . size (  )  )     +     1  )  )  ;", "classLoaderIds . put ( classLoader ,    id )  ;", "classLoaderDetails . put ( id ,    details )  ;", "return   id ;", "}", "@ Override", "public   void   collectDefinitions ( Map < Short ,    Details >    details )     {", "details . putAll ( classLoaderDetails )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newSerializeSession"], "fileName": "org.gradle.tooling.internal.provider.serialization.DefaultPayloadClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( spec   instanceof   SystemClassLoaderSpec )     {", "return   rootClassLoader ;", "}", "if    ( spec   instanceof   MultiParentClassLoader . Spec )     {", "return   new   MultiParentClassLoader ( parents )  ;", "}", "if    (  ( parents . size (  )  )     !  =     1  )     {", "throw   new   IllegalArgumentException (  \" Expected   a   single   parent .  \"  )  ;", "}", "ClassLoader   parent    =    parents . get (  0  )  ;", "if    ( spec   instanceof   VisitableURLClassLoader . Spec )     {", "VisitableURLClassLoader . Spec   clSpec    =     (  ( VisitableURLClassLoader . Spec )     ( spec )  )  ;", "return   new   VisitableURLClassLoader ( parent ,    clSpec . getClasspath (  )  )  ;", "}", "if    ( spec   instanceof   CachingClassLoader . Spec )     {", "return   new   CachingClassLoader ( parent )  ;", "}", "if    ( spec   instanceof   FilteringClassLoader . Spec )     {", "FilteringClassLoader . Spec   clSpec    =     (  ( FilteringClassLoader . Spec )     ( spec )  )  ;", "return   new   FilteringClassLoader ( parent ,    clSpec )  ;", "}", "throw   new   IllegalArgumentException ( String . format (  \" Don ' t   know   how   to   create   a   ClassLoader   from   spec    % s \"  ,    spec )  )  ;", "}", "METHOD_END"], "methodName": ["getClassLoaderFor"], "fileName": "org.gradle.tooling.internal.provider.serialization.ModelClassLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "final   DeserializeMap   map    =    classLoaderRegistry . newDeserializeSession (  )  ;", "try    {", "final   Map < Short ,    ClassLoaderDetails >    classLoaderDetails    =     (  ( Map < Short ,    ClassLoaderDetails >  )     ( payload . getHeader (  )  )  )  ;", "StreamByteBuffer   buffer    =    StreamByteBuffer . of ( payload . getSerializedModel (  )  )  ;", "final   ObjectInputStream   objectStream    =    new   ObjectInputStream ( buffer . getInputStream (  )  ,    getClass (  )  . getClassLoader (  )  ,    classLoaderDetails ,    map )  ;", "return   objectStream . readObject (  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["deserialize"], "fileName": "org.gradle.tooling.internal.provider.serialization.PayloadSerializer"}, {"methodBody": ["METHOD_START", "{", "final   SerializeMap   map    =    classLoaderRegistry . newSerializeSession (  )  ;", "try    {", "StreamByteBuffer   buffer    =    new   StreamByteBuffer (  )  ;", "final   ObjectOutputStream   objectStream    =    new   ObjectOutputStream ( buffer . getOutputStream (  )  ,    map )  ;", "try    {", "objectStream . writeObject ( payload )  ;", "}    finally    {", "IoActions . closeQuietly ( objectStream )  ;", "}", "Map < Short ,    ClassLoaderDetails >    classLoaders    =    new   HashMap < Short ,    ClassLoaderDetails >  (  )  ;", "map . collectClassLoaderDefinitions ( classLoaders )  ;", "return   new   SerializedPayload ( classLoaders ,    buffer . readAsListOfByteArrays (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.gradle.tooling.internal.provider.serialization.PayloadSerializer"}, {"methodBody": ["METHOD_START", "{", "short   id    =    readShort (  )  ;", "String   className    =    readUTF (  )  ;", "if    ( id    =  =     ( OutputStream . SAME _ CLASSLOADER _ TOKEN )  )     {", "return   super . lookupClass ( className )  ;", "}", "ClassLoaderDetails   classLoader    =    classLoaderDetails . get ( id )  ;", "return   map . resolveClass ( classLoader ,    className )  ;", "}", "METHOD_END"], "methodName": ["readClass"], "fileName": "org.gradle.tooling.internal.provider.serialization.PayloadSerializerObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "writeClassLoader ( targetClass )  ;", "writeUTF ( targetClass . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeClass"], "fileName": "org.gradle.tooling.internal.provider.serialization.PayloadSerializerObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "if    ( TopLevelExceptionPlaceholder . class . getPackage (  )  . equals ( targetClass . getPackage (  )  )  )     {", "writeShort (  . SAME _ CLASSLOADER _ TOKEN )  ;", "} else    {", "writeShort ( map . visitClass ( targetClass )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeClassLoader"], "fileName": "org.gradle.tooling.internal.provider.serialization.PayloadSerializerObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   header ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.gradle.tooling.internal.provider.serialization.SerializedPayload"}, {"methodBody": ["METHOD_START", "{", "return   serializedModel ;", "}", "METHOD_END"], "methodName": ["getSerializedModel"], "fileName": "org.gradle.tooling.internal.provider.serialization.SerializedPayload"}]