[{"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["createActor"], "fileName": "org.gradle.internal.actor.TestActorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Actor (  )     {", "public    < T >    T   getProxy ( Class < T >    type )     {", "return   new   ProxyDispatchAdapter < T >  ( new   ReflectionDispatch ( target )  ,    type ,    ThreadSafe . class )  . getSource (  )  ;", "}", "public   void   stop (  )    throws   DispatchException    {", "}", "public   void   dispatch ( MethodInvocation   message )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createBlockingActor"], "fileName": "org.gradle.internal.actor.TestActorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( target   instanceof   DefaultActorFactory . NonBlockingActor )     {", "return    (  ( DefaultActorFactory . NonBlockingActor )     ( target )  )  ;", "}", "synchronized ( lock )     {", "if    ( blockingActors . containsKey ( target )  )     {", "throw   new   UnsupportedOperationException (  \" Cannot   create   a   non - blocking   and   blocking   actor   for   the   same   object .    This   is   not   implemented   yet .  \"  )  ;", "}", "DefaultActorFactory . NonBlockingActor   actor    =    nonBlockingActors . get ( target )  ;", "if    ( actor    =  =    null )     {", "actor    =    new   DefaultActorFactory . NonBlockingActor ( target )  ;", "nonBlockingActors . put ( target ,    actor )  ;", "}", "return   actor ;", "}", "}", "METHOD_END"], "methodName": ["createActor"], "fileName": "org.gradle.internal.actor.internal.DefaultActorFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "if    ( nonBlockingActors . containsKey ( target )  )     {", "throw   new   UnsupportedOperationException (  \" Cannot   create   a   non - blocking   and   blocking   actor   for   the   same   object .    This   is   not   implemented   yet .  \"  )  ;", "}", ". BlockingActor   actor    =    blockingActors . get ( target )  ;", "if    ( actor    =  =    null )     {", "actor    =    new    . BlockingActor ( target )  ;", "blockingActors . put ( target ,    actor )  ;", "}", "return   actor ;", "}", "}", "METHOD_END"], "methodName": ["createBlockingActor"], "fileName": "org.gradle.internal.actor.internal.DefaultActorFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "try    {", "CompositeStoppable . stoppable ( nonBlockings . values (  )  )  . add ( blockings . values (  )  )  . stop (  )  ;", "}    finally    {", "nonBlockings . clear (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.actor.internal.DefaultActorFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "blockings . values (  )  . remove ( actor )  ;", "}", "}", "METHOD_END"], "methodName": ["stopped"], "fileName": "org.gradle.internal.actor.internal.DefaultActorFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "nonBlockings . values (  )  . remove ( actor )  ;", "}", "}", "METHOD_END"], "methodName": ["stopped"], "fileName": "org.gradle.internal.actor.internal.DefaultActorFactory"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  (  ( state )     !  =     (  . State . Stopped )  )     &  &     (  ( queue . size (  )  )     >  =     ( maxQueueSize )  )  )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   UncheckedException ( e )  ;", "}", "}", "if    (  ( state )     =  =     (  . State . Stopped )  )     {", "throw   new   IllegalStateException (  (  \" Cannot   dispatch   message ,    as   this   message   dispatch   has   been   stopped .    Message :     \"     +    message )  )  ;", "}", "queue . add ( message )  ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "T   message    =    null ;", "lock . lock (  )  ;", "try    {", "while    (  (  ( state )     !  =     (  . State . Stopped )  )     &  &     ( queue . isEmpty (  )  )  )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   UncheckedException ( e )  ;", "}", "}", "if    (  !  ( queue . isEmpty (  )  )  )     {", "message    =    queue . remove (  )  ;", "condition . signalAll (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "if    ( message    =  =    null )     {", "return ;", "}", "dispatch . dispatch ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatchMessages"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "onDispatchThreadStart (  )  ;", "executor . execute ( new   CurrentBuildOperationPreservingRunnable ( new   Runnable (  )     {", "public   void   run (  )     {", "try    {", "dispatchMessages ( dispatch )  ;", "}    finally    {", "onDispatchThreadExit (  )  ;", "}", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["dispatchTo"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "setState ( AsyncDispatch . State . Stopped )  ;", "}", "METHOD_END"], "methodName": ["doRequestStop"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "( ers )  -  -  ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onDispatchThreadExit"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( state )     !  =     (  . State . Init )  )     {", "throw   new   IllegalStateException (  \" This   dispatch   has   been   stopped .  \"  )  ;", "}", "( dispatchers )  +  +  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onDispatchThreadStart"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "doRequestStop (  )  ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["requestStop"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "this . state    =    state ;", "condition . sigAll (  )  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "setState (  . State . Stopped )  ;", "while    (  ( dispatchers )     >     0  )     {", "condition . await (  )  ;", "}", "if    (  !  ( queue . isEmpty (  )  )  )     {", "throw   new   IllegalStateException (  \" Cannot   wait   for   messages   to   be   dispatched ,    as   there   are   no   dispatch   threads   running .  \"  )  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   new   UncheckedException ( e )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.dispatch.AsyncDispatch"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   original    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( contextClassLoader )  ;", "try    {", "dispatch . dispatch ( message )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( original )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.dispatch.ContextClassLoaderDispatch"}, {"methodBody": ["METHOD_START", "{", "return   adapter . getSource (  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.internal.dispatch.ContextClassLoaderProxy"}, {"methodBody": ["METHOD_START", "{", "logger . error ( String . format (  \" Could   not   dispatch   message    % s .    Discarding   message .  \"  ,    message )  ,    failure )  ;", "}", "METHOD_END"], "methodName": ["dispatchFailed"], "fileName": "org.gradle.internal.dispatch.DiscardingFailureHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . failure )     !  =    null )     {", "logger . error ( failure . getMessage (  )  ,    failure )  ;", "} else    {", "this . failure    =    new   Dispatch ( String . format (  \" Could   not   dispatch   message    % s .  \"  ,    message )  ,    failure )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatchFailed"], "fileName": "org.gradle.internal.dispatch.ExceptionTrackingFailureHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failure )     !  =    null )     {", "try    {", "throw   failure ;", "}    finally    {", "failure    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.dispatch.ExceptionTrackingFailureHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "message )  ;", "}    catch    ( Throwable   throwable )     {", "handler . ailed ( message ,    throwable )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.dispatch.FailureHandlingDispatch"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.internal.dispatch.MethodInvocation"}, {"methodBody": ["METHOD_START", "{", "return   method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.gradle.internal.dispatch.MethodInvocation"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.internal.dispatch.ProxyDispatchAdapter"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.internal.dispatch.ProxyDispatchAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   method    =    message . getMethod (  )  ;", "method . setAccessible ( true )  ;", "method . invoke ( target ,    message . getArguments (  )  )  ;", "}    c    ( InvocationTargetException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}    c    ( Throwable   throwable )     {", "throw   UncheckedException . throwAsUncheckedException ( throwable )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.dispatch.ReflectionDispatch"}, {"methodBody": ["METHOD_START", "{", "List < Throwable >    failures    =    null ;", "while    ( handlers . hasNext (  )  )     {", "< MethodInvocation >    handler    =    handlers . next (  )  ;", "try    {", "handler . dispatch ( invocation )  ;", "}    catch    ( ListenerNotificationException   e )     {", "if    ( failures    =  =    null )     {", "failures    =    new   ArrayList < Throwable >  (  )  ;", "}", "if    (  ( e . getEvent (  )  )     =  =    invocation )     {", "failures . addAll ( e . getCauses (  )  )  ;", "} else    {", "failures . add ( e )  ;", "}", "}    catch    ( UncheckedException   e )     {", "if    ( failures    =  =    null )     {", "failures    =    new   ArrayList < Throwable >  (  )  ;", "}", "failures . add ( e . getCause (  )  )  ;", "}    catch    ( Throwable   t )     {", "if    ( failures    =  =    null )     {", "failures    =    new   ArrayList < Throwable >  (  )  ;", "}", "failures . add ( t )  ;", "}", "}", "if    ( failures    =  =    null )     {", "return ;", "}", "if    (  (  ( failures . size (  )  )     =  =     1  )     &  &     (  ( failures . get (  0  )  )    instanceof   RuntimeException )  )     {", "throw    (  ( RuntimeException )     ( failures . get (  0  )  )  )  ;", "}", "throw   new   ListenerNotificationException ( invocation ,    getErrorMessage (  )  ,    failures )  ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.event.AbstractBroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "try    {", "handler . d ( invocation )  ;", "}    catch    ( UncheckedException   e )     {", "throw   new   ListenerNotificationException ( invocation ,    getErrorMessage (  )  ,    Collections . singletonList ( e . getCause (  )  )  )  ;", "}    catch    ( RuntimeException   t )     {", "throw   t ;", "}    catch    ( Throwable   t )     {", "throw   new   ListenerNotificationException ( invocation ,    getErrorMessage (  )  ,    Collections . singletonList ( t )  )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.event.AbstractBroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "String   typeDescription    =    type . getSimpleName (  )  . replaceAll (  \"  (  \\  \\ p { Upper }  )  \"  ,     \"     $  1  \"  )  . trim (  )  . toLowerCase (  )  ;", "return    (  \" Failed   to   notify    \"     +    typeDescription )     +     \"  .  \"  ;", "}", "METHOD_END"], "methodName": ["getErrorMessage"], "fileName": "org.gradle.internal.event.AbstractBroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "return   add ( listener ,    new   ReflectionDispatch ( listener )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "assertIsMethod ( methodName )  ;", "return   add ( action ,    new    . ActionInvocationHandler ( methodName ,    action )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "return   add ( dispatch ,    dispatch )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    type . getMethods (  )  )     {", "if    ( method . getName (  )  . equals ( methodName )  )     {", "return ;", "}", "}", "throw   new   IllegalArgumException ( String . format (  \" Method    % s (  )    not   found   for   listener   type    % s .  \"  ,    methodName ,    type . getSimpleName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertIsMethod"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "return   new   BroadcastDispatch . EmptyDispatch < T >  ( type )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.internal.event.BroadcastDispatch"}, {"methodBody": ["METHOD_START", "{", "DefaultListenerManager . ListenerDetails   details    =    null ;", "synchronized ( lock )     {", "if    (  !  ( allListeners . containsKey ( listener )  )  )     {", "details    =    new   DefaultListenerManager . ListenerDetails ( listener )  ;", "allListeners . put ( listener ,    details )  ;", "}", "}", "if    ( details    !  =    null )     {", "details . useAsListener (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "ListenerBroadcast < T >    broadcast    =    new   ListenerBroadcast ( listenerClass )  ;", "broadcast . add ( getBroadcasterInternal ( listenerClass )  . getDispatch ( true )  )  ;", "return   broadcast ;", "}", "METHOD_END"], "methodName": ["createAnonymousBroadcaster"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultListenerManager ( this )  ;", "}", "METHOD_END"], "methodName": ["createChild"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "return   getBroadcasterInternal ( listenerClass )  . getBroadcaster (  )  ;", "}", "METHOD_END"], "methodName": ["getBroadcaster"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", ". EventBroadcast < T >    broadcaster    =    broadcasters . get ( listenerClass )  ;", "if    ( broadcaster    =  =    null )     {", "broadcaster    =    new    . EventBroadcast < T >  ( listenerClass )  ;", "broadcasters . put ( listenerClass ,    broadcaster )  ;", "for    (  . ListenerDetails   listener    :    allListeners . values (  )  )     {", "broadcaster . maybeAdd ( listener )  ;", "}", "for    (  . ListenerDetails   logger    :    allLoggers . values (  )  )     {", "broadcaster . maybeSetLogger ( logger )  ;", "}", "}", "return   broadcaster ;", "}", "}", "METHOD_END"], "methodName": ["getBroadcasterInternal"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "DefaultListenerManager . ListenerDetails   details ;", "synchronized ( lock )     {", "details    =    allListeners . remove ( listener )  ;", "if    ( details    !  =    null )     {", "details . disconnect (  )  ;", "}", "}", "if    ( details    !  =    null )     {", "details . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "DefaultListenerManager . ListenerDetails   details    =    null ;", "synchronized ( lock )     {", "if    (  !  ( allLoggers . containsKey ( logger )  )  )     {", "details    =    new   DefaultListenerManager . ListenerDetails ( logger )  ;", "allLoggers . put ( logger ,    details )  ;", "}", "}", "if    ( details    !  =    null )     {", "details . useAsLogger (  )  ;", "}", "}", "METHOD_END"], "methodName": ["useLogger"], "fileName": "org.gradle.internal.event.DefaultListenerManager"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . add ( methodName ,    action )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . add ( dispatch )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . addAll ( listeners )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast . dispatch ( event )  ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "if    (  ( source )     =  =    null )     {", "source    =    new   ProxyDispatchAdap < T >  ( this ,    type )  ;", "}", "return   source . getSource (  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "return   broadcast . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    BroadcastDispatch . empty ( type )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "broadcast    =    broadcast . removeAll ( listeners )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.gradle.internal.event.ListenerBroadcast"}, {"methodBody": ["METHOD_START", "{", "return   event ;", "}", "METHOD_END"], "methodName": ["getEvent"], "fileName": "org.gradle.internal.event.ListenerNotificationException"}, {"methodBody": ["METHOD_START", "{", "EndPointQueue   queue    =    outgoingQueue . newEndpoint (  )  ;", "tate   state    =    new   tate ( this ,    connection ,    queue )  ;", "connections . add ( state )  ;", "return   state ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionSet"}, {"methodBody": ["METHOD_START", "{", "connections . remove ( connectionState )  ;", "if    ( stopping )     {", "maybeStop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["finished"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionSet"}, {"methodBody": ["METHOD_START", "{", "if    ( connections . isEmpty (  )  )     {", "outgoingQueue . discardQueued (  )  ;", "incomingQueue . queue ( new   EndOfStream (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeStop"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionSet"}, {"methodBody": ["METHOD_START", "{", "stopping    =    true ;", "maybeStop (  )  ;", "}", "METHOD_END"], "methodName": ["noFurtherConnections"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionSet"}, {"methodBody": ["METHOD_START", "{", "dispatchFinished    =    true ;", "maybeDisced (  )  ;", "}", "METHOD_END"], "methodName": ["dispatchFinished"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionState"}, {"methodBody": ["METHOD_START", "{", "return   connection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionState"}, {"methodBody": ["METHOD_START", "{", "return   dispatchQueue ;", "}", "METHOD_END"], "methodName": ["getDispatchQueue"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( dispatchFinished )     &  &     ( receiveFinished )  )     {", "owner . finished ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeDisconnected"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionState"}, {"methodBody": ["METHOD_START", "{", "receiveFinished    =    true ;", "if    (  !  ( dispatchFinished )  )     {", "dispatchQueue . stop (  )  ;", "}", "maybeDisced (  )  ;", "}", "METHOD_END"], "methodName": ["receiveFinished"], "fileName": "org.gradle.internal.remote.internal.hub.ConnectionState"}, {"methodBody": ["METHOD_START", "{", "queue ( new   EndOfStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["requestStop"], "fileName": "org.gradle.internal.remote.internal.hub.IncomingQueue"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "assertRunning (  \" add   connection \"  )  ;", "ConnectionState   connectionState    =    connections . add ( connection )  ;", "workers . execute ( new    . ConnectionDispatch ( connectionState )  )  ;", "workers . execute ( new    . ConnectionReceive ( connectionState )  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addConnection"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "assertRunning (  \" add   handler \"  )  ;", "RejectedMessageListener   rejectedMessageListener ;", "if    ( handler   instanceof   RejectedMessageListener )     {", "rejectedMessageListener    =     (  ( RejectedMessageListener )     ( handler )  )  ;", "} else    {", "rejectedMessageListener    =     . DISCARD ;", "}", "Dispatch < Object >    dispatch ;", "if    ( handler   instanceof   Dispatch )     {", "dispatch    =     (  ( Dispatch )     ( handler )  )  ;", "} else    {", "dispatch    =     . DISCARD ;", "}", "BoundedDispatch < Object >    boundedDispatch ;", "if    ( dispatch   instanceof   BoundedDispatch )     {", "boundedDispatch    =     (  ( BoundedDispatch )     ( dispatch )  )  ;", "} else    {", "boundedDispatch    =     . DISCARD ;", "}", "StreamFailureHandler   streamFailureHandler ;", "if    ( handler   instanceof   StreamFailureHandler )     {", "streamFailureHandler    =     (  ( StreamFailureHandler )     ( handler )  )  ;", "} else    {", "streamFailureHandler    =     . DISCARD ;", "}", "ChannelIdentifier   identifier    =    new   ChannelIdentifier ( channelName )  ;", "EndPointQueue   queue    =    incomingQueue . getChannel ( identifier )  . newEndpoint (  )  ;", "workers . execute ( new    . Handler ( queue ,    dispatch ,    boundedDispatch ,    rejectedMessageListener ,    streamFailureHandler )  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "incomingQueue . queue ( m )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addToIncoming"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state )     !  =     ( MessageHub . State . Running )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot    % s ,    as    % s   has   been   stopped .  \"  ,    action ,    displayName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertRunning"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "assertRunning (  \" create   outgoing   dispatch \"  )  ;", "return   new    . ChannelDispatch < T >  ( type ,    new   ChannelIdentifier ( channelName )  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getOutgoing"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "connections . noFurtherConnections (  )  ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["noFurtherConnections"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( state )     !  =     (  . State . Running )  )     {", "return ;", "}", "try    {", "outgoingQueue . endOutput (  )  ;", "connections . noFurtherConnections (  )  ;", "}    finally    {", "state    =     . State . Stopping ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["requestStop"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "try    {", "lock . lock (  )  ;", "try    {", "requestStop (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "workers . stop (  )  ;", "}    finally    {", "lock . lock (  )  ;", "try    {", "state    =     . State . Stopped ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHub"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageHubBackedObjectConnection ( executorFactory ,    connector . connect ( address )  )  ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedClient"}, {"methodBody": ["METHOD_START", "{", "if    (  ( connection )     !  =    null )     {", "throw   new   GradleException (  \" Cannot   add   incoming   message   handler   after   connection   established .  \"  )  ;", "}", "if    (  ( type . getClassLoader (  )  )     !  =     ( getClass (  )  . getClassLoader (  )  )  )     {", "methodParamClassLoaders . add ( type . getClassLoader (  )  )  ;", "}", "Dispatch < MethodInvocation >    handler    =    new    . DispatchWrapper < T >  ( instance )  ;", "hub . addHandler ( type . getName (  )  ,    handler )  ;", "}", "METHOD_END"], "methodName": ["addIncoming"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( connection )     !  =    null )     {", "throw   new   GradleException (  \" Cannot   add   outgoing   message   transmitter   after   connection   established .  \"  )  ;", "}", "methodParamClassLoaders . add ( type . getClassLoader (  )  )  ;", "ProxyDispatchAdapter < T >    adapter    =    new   ProxyDispatchAdapter < T >  ( hub . getOutgoing ( type . getName (  )  ,    MethodInvocation . class )  ,    type ,    ThreadSafe . class )  ;", "return   adapter . getSource (  )  ;", "}", "METHOD_END"], "methodName": ["addOutgoing"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   methodParamClassLoader ;", "if    (  ( methodParamClassLoaders . size (  )  )     =  =     0  )     {", "methodParamClassLoader    =    getClass (  )  . getClassLoader (  )  ;", "} else", "if    (  ( methodParamClassLoaders . size (  )  )     =  =     1  )     {", "methodParamClassLoader    =    methodParamClassLoaders . iterator (  )  . next (  )  ;", "} else    {", "methodParamClassLoader    =    new   classloader . CachingClassLoader ( new   classloader . MultiParentClassLoader ( methodParamClassLoaders )  )  ;", "}", "MethodArgsSerializer   argsSerializer    =    new   DefaultMethodArgsSerializer ( paramSerializers ,    new   JavaSerializationBackedMethodArgsSerializer ( methodParamClassLoader )  )  ;", "StatefulSerializer < InterHubMessage >    serializer    =    new   InterHubMessageSerializer ( new   TypeSafeSerializer < MethodInvocation >  ( MethodInvocation . class ,    new   MethodInvocationSerializer ( methodParamClassLoader ,    argsSerializer )  )  )  ;", "connection    =    completion . create ( serializer )  ;", "hub . addConnection ( connection )  ;", "hub . noFurtherConnections (  )  ;", "completion    =    null ;", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "hub . requestStop (  )  ;", "}", "METHOD_END"], "methodName": ["requestStop"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "CompositeStoppable . stoppable ( hub ,    connection )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "this . paramSerializers . add ( serializer )  ;", "}", "METHOD_END"], "methodName": ["useParameterSerializers"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection"}, {"methodBody": ["METHOD_START", "{", "return   connector . accept ( new   MessageHubBackedServer . ConnectEventAction ( action )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.gradle.internal.remote.internal.hub.MessageHubBackedServer"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodInvocationSerializer . MethodInvocationReader ( decoder ,    classLoader ,    methodArgsSerializer )  ;", "}", "METHOD_END"], "methodName": ["newReader"], "fileName": "org.gradle.internal.remote.internal.hub.MethodInvocationSerializer"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodInvocationSerializer . MethodInvocationWriter ( encoder ,    methodArgsSerializer )  ;", "}", "METHOD_END"], "methodName": ["newWriter"], "fileName": "org.gradle.internal.remote.internal.hub.MethodInvocationSerializer"}, {"methodBody": ["METHOD_START", "{", "List < InterHubMessage >    rejected    =    new   ArrayList < InterHubMessage >  (  )  ;", "drain ( rejected )  ;", "for    ( InterHubMessage   message    :    rejected )     {", "if    ( message   instanceof   ChannelMessage )     {", "ChannelMessage   channelMessage    =     (  ( ChannelMessage )     ( message )  )  ;", "incom . queue ( new   RejectedMessage ( channelMessage . getChannel (  )  ,    channelMessage . getPayload (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["discardQueued"], "fileName": "org.gradle.internal.remote.internal.hub.OutgoingQueue"}, {"methodBody": ["METHOD_START", "{", "dispatch ( new   EndOfStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["endOutput"], "fileName": "org.gradle.internal.remote.internal.hub.OutgoingQueue"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.ChannelIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   channel ;", "}", "METHOD_END"], "methodName": ["getChannel"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.ChannelMessage"}, {"methodBody": ["METHOD_START", "{", "return   payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.ChannelMessage"}, {"methodBody": ["METHOD_START", "{", "return   channel ;", "}", "METHOD_END"], "methodName": ["getChannel"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.RejectedMessage"}, {"methodBody": ["METHOD_START", "{", "return   payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.RejectedMessage"}, {"methodBody": ["METHOD_START", "{", "return   failure ;", "}", "METHOD_END"], "methodName": ["getFailure"], "fileName": "org.gradle.internal.remote.internal.hub.protocol.StreamFailureMessage"}, {"methodBody": ["METHOD_START", "{", "queue . add ( message )  ;", "condition . signalAll (  )  ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.remote.internal.hub.queue.EndPointQueue"}, {"methodBody": ["METHOD_START", "{", "owner . stopped ( this )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.remote.internal.hub.queue.EndPointQueue"}, {"methodBody": ["METHOD_START", "{", "if    ( queue . isEmpty (  )  )     {", "owner . empty ( this )  ;", "while    ( queue . isEmpty (  )  )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}", "drainTo . addAll ( queue )  ;", "queue . clear (  )  ;", "}", "METHOD_END"], "methodName": ["take"], "fileName": "org.gradle.internal.remote.internal.hub.queue.EndPointQueue"}, {"methodBody": ["METHOD_START", "{", "MultiEndPointQueue   queue    =    channels . get ( channel )  ;", "if    ( queue    =  =    null )     {", "queue    =    new   MultiEndPointQueue ( lock )  ;", "channels . put ( channel ,    queue )  ;", "initializer . onQueueAdded ( queue )  ;", "}", "return   queue ;", "}", "METHOD_END"], "methodName": ["getChannel"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiChannelQueue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( message . getDelivery (  )  )     =  =     ( InterHubMessage . Delivery . Stateful )  )     {", "initializer . onStatefulMessage ( message )  ;", "}", "if    ( message   instanceof   Routable )     {", "Routable   routableMessage    =     (  ( Routable )     ( message )  )  ;", "get ( routableMessage . get (  )  )  . dispatch ( message )  ;", "} else", "if    (  (  ( message . getDelivery (  )  )     =  =     ( InterHubMessage . Delivery . Stateful )  )     |  |     (  ( message . getDelivery (  )  )     =  =     ( InterHubMessage . Delivery . AllHandlers )  )  )     {", "for    ( MultiEndPointQueue   queue    :    channels . values (  )  )     {", "queue . dispatch ( message )  ;", "}", "} else    {", "throw   new   IllegalArgumentException ( String . format (  \" Don ' t   know   how   to   route   message    % s .  \"  ,    message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["queue"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiChannelQueue"}, {"methodBody": ["METHOD_START", "{", "queue . add ( message )  ;", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "drainTo . addAll (  ;", "clear (  )  ;", "}", "METHOD_END"], "methodName": ["drain"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "waiting . add ( endPointQueue )  ;", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "EndPointQueue   selected    =     ( waiting . isEmpty (  )  )     ?    null    :    waiting . get (  0  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "InterHubMessage   message    =    queue . get (  0  )  ;", "switch    ( message . getDelivery (  )  )     {", "case   Stateful    :", "case   AllHandlers    :", "if    ( endpoints . isEmpty (  )  )     {", "return ;", "}", "if    (  ( message . getDelivery (  )  )     =  =     ( InterHubMessage . Delivery . Stateful )  )     {", "initializer . onStatefulMessage ( message )  ;", "}", "for    ( EndPointQueue   endpoint    :    endpoints )     {", "endpoint . dispatch ( message )  ;", "}", "queue . remove (  0  )  ;", "waiting . clear (  )  ;", "continue ;", "case   SingleHandler    :", "if    ( selected    =  =    null )     {", "return ;", "}", "queue . remove (  0  )  ;", "waiting . remove ( selected )  ;", "selected . dispatch ( message )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unknown   delivery   type :     \"     +     ( message . getDelivery (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "EndPointQueue   endPointQueue    =    new   EndPointQueue ( this ,    lock . newCondition (  )  )  ;", "endpoints . add ( endPointQueue )  ;", "initializer . onQueueAdded ( endPointQueue )  ;", "return   endPointQueue ;", "}", "METHOD_END"], "methodName": ["newEndpoint"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "waiting . remove (  ;", "endpoints . remove (  ;", "dispatch ( new   EndOfStream (  )  )  ;", "}", "METHOD_END"], "methodName": ["stopped"], "fileName": "org.gradle.internal.remote.internal.hub.queue.MultiEndPointQueue"}, {"methodBody": ["METHOD_START", "{", "if    (  ( endOfStream )     !  =    null )     {", "dispatch ( endOfStream )  ;", "}", "}", "METHOD_END"], "methodName": ["onQueueAdded"], "fileName": "org.gradle.internal.remote.internal.hub.queue.QueueInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( message   instanceof   EndOfStream )     {", "endOfStream    =     (  ( EndOfStream )     ( message )  )  ;", "} else    {", "throw   new   UnsupportedOperationException ( String . format (  \" Received   unexpected   stateful   message :     % s \"  ,    message )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onStatefulMessage"], "fileName": "org.gradle.internal.remote.internal.hub.queue.QueueInitializer"}, {"methodBody": ["METHOD_START", "{", "communicationAddresses    =    new   ArrayList < InetAddress >  (  )  ;", "if    ( inetAddresses . getLoopback (  )  . isEmpty (  )  )     {", "if    ( inetAddresses . getRemote (  )  . isEmpty (  )  )     {", "InetAddress   fallback    =    InetAddress . getByName ( null )  ;", "logger . debug (  \" No   loopback   addresses ,    using   fallback    {  }  \"  ,    fallback )  ;", "communicationAddresses . add ( fallback )  ;", "} else    {", "logger . debug (  \" No   loopback   addresses ,    using   remote   addresses   instead .  \"  )  ;", "communicationAddresses . addAll ( inetAddresses . getRemote (  )  )  ;", "}", "} else    {", "communicationAddresses . addAll ( inetAddresses . getLoopback (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["findCommunicationAddresses"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( String   key    :    System . getenv (  )  . keySet (  )  )     {", "if    (  ( key . startsWith (  \" OPENSHIFT _  \"  )  )     &  &     ( key . endsWith (  \"  _ IP \"  )  )  )     {", "String   ipAddress    =    System . getenv ( key )  ;", "logger . debug (  \" OPENSHIFT   IP   environment   variable    {  }    detected .    Using   IP   address    {  }  .  \"  ,    key ,    ipAddress )  ;", "try    {", "return    . getByName ( ipAddress )  ;", "}    catch    ( UnknownHostException   e )     {", "throw   new   RuntimeException ( String . format (  \" Unable   to   use   OPENSHIFT   IP    -    invalid   IP   address    '  % s '    specified   in   environment   variable    % s .  \"  ,    ipAddress ,    key )  ,    e )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findOpenshiftAddresses"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "synchronized ( lock )     {", "init (  )  ;", "return   communicationes ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Could   not   determine   the   local   IP   addresses   for   this   machine .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getCommunicationAddresses"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "if    (  ( hostName )     =  =    null )     {", "try    {", "hostName    =     . getLocalHost (  )  . getHostName (  )  ;", "}    catch    ( UnknownHostException   e )     {", "hostName    =    getCommunicationAddresses (  )  . get (  0  )  . toString (  )  ;", "}", "}", "return   hostName ;", "}", "}", "METHOD_END"], "methodName": ["getHostname"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "synchronized ( lock )     {", "init (  )  ;", "return   localBinding ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Could   not   determine   a   usable   local   IP   for   this   machine .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getLocalBindingAddress"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "InetAddress   openshiftBindAddress    =    findOpenshiftAddresses (  )  ;", "if    ( openshiftBindAddress    !  =    null )     {", "localBindingAddress    =    openshiftBindAddress ;", "communicationAddresses . add ( openshiftBindAddress )  ;", "}", "}", "METHOD_END"], "methodName": ["handleOpenshift"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( initialized )     {", "return ;", "}", "initialized    =    true ;", "if    (  ( inetAddresses )     =  =    null )     {", "inetAddresses    =    new   es (  )  ;", "}", "localBindingAddress    =    new   InetSocketAddress (  0  )  . getAddress (  )  ;", "findCommunicationAddresses (  )  ;", "handleOpenshift (  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "synchronized ( lock )     {", "init (  )  ;", "return   communicationes . contains ( address )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Could   not   determine   the   IP   addresses   for   this   machine .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["isCommunicationAddress"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddressFactory"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" Adding   IP   addresses   for   network   interface    {  }  \"  ,    networkInterface . getDisplayName (  )  )  ;", "try    {", "boolean   isLoopbackInterface    =    networkInterface . isLoopback (  )  ;", "logger . debug (  \" Is   this   a   loopback   interface ?     {  }  \"  ,    isLoopbackInterface )  ;", "boolean   isMulticast    =    networkInterface . supportsMulticast (  )  ;", "logger . debug (  \" Is   this   a   multicast   interface ?     {  }  \"  ,    isMulticast )  ;", "boolean   isRemote    =    false ;", "Enumeration < InetAddress >    candidates    =    networkInterface . get (  )  ;", "while    ( candidates . hasMoreElements (  )  )     {", "InetAddress   candidate    =    candidates . nextElement (  )  ;", "if    ( isLoopbackInterface )     {", "if    ( candidate . isLoopbackAddress (  )  )     {", "logger . debug (  \" Adding   loopback   address    {  }  \"  ,    candidate )  ;", "loopback . add ( candidate )  ;", "} else    {", "logger . debug (  \" Ignoring   remote   address   on   loopback   interface    {  }  \"  ,    candidate )  ;", "}", "} else    {", "if    ( candidate . isLoopbackAddress (  )  )     {", "logger . debug (  \" Ignoring   loopback   address   on   remote   interface    {  }  \"  ,    candidate )  ;", "} else    {", "logger . debug (  \" Adding   remote   address    {  }  \"  ,    candidate )  ;", "remote . add ( candidate )  ;", "isRemote    =    true ;", "}", "}", "}", "if    ( isMulticast )     {", "if    ( isRemote )     {", "logger . debug (  \" Adding   remote   multicast   interface    {  }  \"  ,    networkInterface . getDisplayName (  )  )  ;", "multicastInterfaces . add (  0  ,    networkInterface )  ;", "} else    {", "logger . debug (  \" Adding   loopback   multicast   interface    {  }  \"  ,    networkInterface . getDisplayName (  )  )  ;", "multicastInterfaces . add ( networkInterface )  ;", "}", "}", "}    catch    ( SocketException   e )     {", "logger . debug (  \" Error   while   querying   interface    {  }    for   IP   addresses \"  ,    networkInterface ,    e )  ;", "}    catch    ( Throwable   e )     {", "throw   new   RuntimeException ( String . format (  \" Could   not   determine   the   IP   addresses   for   network   interface    % s \"  ,    networkInterface . getName (  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["analyzeNetworkInterface"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "Enumeration < NetworkInterface >    interfaces    =    NetworkInterface . getNetworkInterfaces (  )  ;", "while    ( interfaces . hasMoreElements (  )  )     {", "analyzeNetworkInterface ( interfaces . nextElement (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["analyzeNetworkInterfaces"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "return   loopback ;", "}", "METHOD_END"], "methodName": ["getLoopback"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "return   multicastInterfaces ;", "}", "METHOD_END"], "methodName": ["getMulticastInterfaces"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "return   remote ;", "}", "METHOD_END"], "methodName": ["getRemote"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "logger . debug (  \" No   multicast   interfaces ,    using   fallbacks \"  )  ;", "Enumeration < NetworkInterface >    networkInterfaces    =    NetworkInterface . getNetworkInterfaces (  )  ;", "while    ( networkInterfaces . hasMoreElements (  )  )     {", "multicastInterfaces . add ( networkInterfaces . nextElement (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["useMulticastFallback"], "fileName": "org.gradle.internal.remote.internal.inet.InetAddresses"}, {"methodBody": ["METHOD_START", "{", "return   new   MultiChoiceAddress ( canonicalAddress ,    port ,    Lists . newArrayList ( Iterables . concat ( candidates ,    this . candidates )  )  )  ;", "}", "METHOD_END"], "methodName": ["addAddresses"], "fileName": "org.gradle.internal.remote.internal.inet.MultiChoiceAddress"}, {"methodBody": ["METHOD_START", "{", "return   candidates ;", "}", "METHOD_END"], "methodName": ["getCandidates"], "fileName": "org.gradle.internal.remote.internal.inet.MultiChoiceAddress"}, {"methodBody": ["METHOD_START", "{", "return   canonicalAddress ;", "}", "METHOD_END"], "methodName": ["getCanonicalAddress"], "fileName": "org.gradle.internal.remote.internal.inet.MultiChoiceAddress"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \"  [  \"     +     ( canonicalAddress )  )     +     \"    port :  \"  )     +     ( port )  )     +     \"  ,    addresses :  \"  )     +     ( candidates )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.internal.remote.internal.inet.MultiChoiceAddress"}, {"methodBody": ["METHOD_START", "{", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.gradle.internal.remote.internal.inet.MultiChoiceAddress"}, {"methodBody": ["METHOD_START", "{", "return   new   SocketConnection < T >  ( socket ,    new   KryoBackedMessageSerializer (  )  ,    serializer )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.internal.remote.internal.inet.SocketConnectCompletion"}, {"methodBody": ["METHOD_START", "{", "try    {", "objectWriter . write ( message )  ;", "}    catch    ( ObjectStreamException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   write   message    % s   to    '  % s '  .  \"  ,    message ,    Address )  ,    e )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   write   message    % s   to    '  % s '  .  \"  ,    message ,    Address )  ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   write   message    % s   to    '  % s '  .  \"  ,    message ,    Address )  ,    e )  ;", "}    catch    ( Exception   e )     {", "throw   new   MessageIOException ( String . format (  \" Could   not   write   message    % s   to    '  % s '  .  \"  ,    message ,    Address )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.internal.remote.internal.inet.SocketConnection"}, {"methodBody": ["METHOD_START", "{", "if    ( e   instanceof   EOFException )     {", "return   true ;", "}", "if    ( e   instanceof   IOException )     {", "if    ( Objects . equal ( e . getMessage (  )  ,     \" An   existing   connection   was   forcibly   closed   by   the   remote   host \"  )  )     {", "return   true ;", "}", "if    ( Objects . equal ( e . getMessage (  )  ,     \" An   established   connection   was   aborted   by   the   software   in   your   host   machine \"  )  )     {", "return   true ;", "}", "if    ( Objects . equal ( e . getMessage (  )  ,     \"    reset   by   peer \"  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEndOfStream"], "fileName": "org.gradle.internal.remote.internal.inet.SocketConnection"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   objectReader . read (  )  ;", "}    catch    ( EOFException   e )     {", "if    (  . LOGGER . isDebugEnabled (  )  )     {", ". LOGGER . debug (  \" Discarding   EOFException :     {  }  \"  ,    e . toString (  )  )  ;", "}", "return   null ;", "}    catch    ( ObjectStreamException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   read   message   from    '  % s '  .  \"  ,    remoteAddress )  ,    e )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   read   message   from    '  % s '  .  \"  ,    remoteAddress )  ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   new   RecoverableMessageIOException ( String . format (  \" Could   not   read   message   from    '  % s '  .  \"  ,    remoteAddress )  ,    e )  ;", "}    catch    ( Exception   e )     {", "throw   new   MessageIOException ( String . format (  \" Could   not   read   message   from    '  % s '  .  \"  ,    remoteAddress )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.internal.remote.internal.inet.SocketConnection"}, {"methodBody": ["METHOD_START", "{", "CompositeStoppable . stoppable ( new   Closeable (  )     {", "@ Override", "public   void   close (  )    throws   IOException    {", "flush (  )  ;", "}", "}  ,    instr ,    outstr ,    s )  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.remote.internal.inet.SocketConnection"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.gradle.internal.remote.internal.inet.SocketInetAddress"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( address )  ;", "}", "METHOD_END"], "methodName": ["getCandidates"], "fileName": "org.gradle.internal.remote.internal.inet.SocketInetAddress"}, {"methodBody": ["METHOD_START", "{", "return    (  ( address )     +     \"  :  \"  )     +     ( port )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.internal.remote.internal.inet.SocketInetAddress"}, {"methodBody": ["METHOD_START", "{", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.gradle.internal.remote.internal.inet.SocketInetAddress"}, {"methodBody": ["METHOD_START", "{", "final   ServerSocketChannel   serverSocket ;", "int   localPort ;", "try    {", "serverSocket    =    ServerSocketChannel . open (  )  ;", "serverSocket . socket (  )  . bind ( new   InetSocketAddress ( addressFactory . getLocalBindingAddress (  )  ,     0  )  )  ;", "localPort    =    serverSocket . socket (  )  . getLocalPort (  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "UUID   id    =    idGenerator . generateId (  )  ;", "List < InetAddress >    addresses    =    addressFactory . getCommunicationAddresses (  )  ;", "final   Address   address    =    new   MultiChoiceAddress ( id ,    localPort ,    addresses )  ;", ". LOGGER . debug (  \" Listening   on    {  }  .  \"  ,    address )  ;", "final   ManagedExecutor   executor    =    executorFactory . create (  (  (  (  \" Incoming    \"     +     ( allowRemote    ?     \" remote \"     :     \" local \"  )  )     +     \"    TCP   Connector   on   port    \"  )     +    localPort )  )  ;", "executor . execute ( new    . Receiver ( serverSocket ,    action ,    allowRemote )  )  ;", "return   new   ConnectionAcceptor (  )     {", "public   Address   getAddress (  )     {", "return   address ;", "}", "public   void   requestStop (  )     {", "CompositeStoppable . stoppable ( serverSocket )  . stop (  )  ;", "}", "public   void   stop (  )     {", "requestStop (  )  ;", "executor . stop (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.gradle.internal.remote.internal.inet.TcpIncomingConnector"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( destinationAddress   instanceof   InetEndpoint )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   create   a   connection   to   address   of   unknown   type :     % s .  \"  ,    destinationAddress )  )  ;", "}", "InetEndpoint   address    =     (  ( InetEndpoint )     ( destinationAddress )  )  ;", ". LOGGER . debug (  \" Attempting   to   connect   to    {  }  .  \"  ,    address )  ;", "List < InetAddress >    candidateAddresses    =    address . getCandidates (  )  ;", "try    {", "Exception   lastFailure    =    null ;", "for    ( InetAddress   candidate    :    candidateAddresses )     {", ". LOGGER . debug (  \" Trying   to   connect   to   address    {  }  .  \"  ,    candidate )  ;", "SocketChannel   socketChannel ;", "try    {", "socketChannel    =    tryConnect ( address ,    candidate )  ;", "}    catch    ( SocketException   e )     {", ". LOGGER . debug (  \" Cannot   connect   to   address    {  }  ,    skipping .  \"  ,    candidate )  ;", "lastFailure    =    e ;", "continue ;", "}    catch    ( SocketTimeoutException   e )     {", ". LOGGER . debug (  \" Timeout   connecting   to   address    {  }  ,    skipping .  \"  ,    candidate )  ;", "lastFailure    =    e ;", "continue ;", "}", ". LOGGER . debug (  \" Connected   to   address    {  }  .  \"  ,    socketChannel . socket (  )  . getRemoteSocketAddress (  )  )  ;", "return   new   SocketConnectCompletion ( socketChannel )  ;", "}", "throw   new   ConnectException ( String . format (  \" Could   not   connect   to   server    % s .    Tried   addresses :     % s .  \"  ,    destinationAddress ,    candidateAddresses )  ,    lastFailure )  ;", "}    catch    ( ConnectException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( String . format (  \" Could   not   connect   to   server    % s .    Tried   addresses :     % s .  \"  ,    destinationAddress ,    candidateAddresses )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["connect"], "fileName": "org.gradle.internal.remote.internal.inet.TcpOutgoingConnector"}, {"methodBody": ["METHOD_START", "{", "Socket   socket    =    socketChannel . socket (  )  ;", "SocketAddress   localAddress    =    socket . getLocalSocketAddress (  )  ;", "SocketAddress   remoteAddress    =    socket . getRemoteSocketAddress (  )  ;", "if    ( localAddress . equals ( remoteAddress )  )     {", ". LOGGER . debug (  \" Detected   that   socket   was   bound   to    {  }    while   connecting   to    {  }  .    This   looks   like   the   socket   connected   to   itself .  \"  ,    localAddress ,    remoteAddress )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["detectSelfConnect"], "fileName": "org.gradle.internal.remote.internal.inet.TcpOutgoingConnector"}, {"methodBody": ["METHOD_START", "{", "SocketChannel   socketChannel    =    SocketChannel . open (  )  ;", "try    {", "socketChannel . socket (  )  . connect ( new   InetSocketAddress ( candidate ,    address . getPort (  )  )  ,     . CONNECT _ TIMEOUT )  ;", "if    (  !  ( detectSelfConnect ( socketChannel )  )  )     {", "return   socketChannel ;", "}", "socketChannel . close (  )  ;", "}    catch    ( IOException   e )     {", "socketChannel . close (  )  ;", "throw   e ;", "}    catch    ( Throwable   e )     {", "socketChannel . close (  )  ;", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "throw   new   ConnectException ( String . format (  \" Socket   connected   to   itself   on    % s   port    % s .  \"  ,    candidate ,    address . getPort (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["tryConnect"], "fileName": "org.gradle.internal.remote.internal.inet.TcpOutgoingConnector"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExecutorFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createExecutorFactory"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TcpIncomingConnector ( executorFactory ,    inetAddressFactory ,    idGenerator )  ;", "}", "METHOD_END"], "methodName": ["createIncomingConnector"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   new   InetAddressFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createInetAddressFactory"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageHubBackedClient ( outgoingConnector ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createMessagingClient"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   new   MessageHubBackedServer ( incomingConnector ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createMessagingServer"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TcpOutgoingConnector (  )  ;", "}", "METHOD_END"], "methodName": ["createOutgoingConnector"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "close (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.remote.services.MessagingServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stream )     =  =    null )     {", "stream    =    new    . DecoderStream (  )  ;", "}", "return   stream ;", "}", "METHOD_END"], "methodName": ["getInputStream"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "int   size    =    readSmallInt (  )  ;", "byte [  ]    result    =    new   byte [ size ]  ;", "readBytes ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["readBinary"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "readBytes ( buffer ,     0  ,    buffer . length )  ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "if    ( readBoolean (  )  )     {", "return   readString (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["readNullableString"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "return   readInt (  )  ;", "}", "METHOD_END"], "methodName": ["readSmallInt"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "return   readLong (  )  ;", "}", "METHOD_END"], "methodName": ["readSmallLong"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "long   remaining    =    count ;", "while    ( remaining    >     0  )     {", "long   skipped    =    maybeSkip ( remaining )  ;", "if    ( skipped    <  =     0  )     {", "break ;", "}", "remaining    -  =    skipped ;", "}", "if    ( remaining    >     0  )     {", "throw   new   EOFException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["skipBytes"], "fileName": "org.gradle.internal.serialize.AbstractDecoder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stream )     =  =    null )     {", "stream    =    new    . EncoderStream (  )  ;", "}", "return   stream ;", "}", "METHOD_END"], "methodName": ["getOutputStream"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "writeBinary ( bytes ,     0  ,    bytes . length )  ;", "}", "METHOD_END"], "methodName": ["writeBinary"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "writeSmallInt ( count )  ;", "writeBytes ( bytes ,    offset ,    count )  ;", "}", "METHOD_END"], "methodName": ["writeBinary"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "writeBytes ( bytes ,     0  ,    bytes . length )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "writeBoolean ( false )  ;", "} else    {", "writeBoolean ( true )  ;", "writeString ( value . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeNullableString"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "writeInt ( value )  ;", "}", "METHOD_END"], "methodName": ["writeSmallInt"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "writeLong ( value )  ;", "}", "METHOD_END"], "methodName": ["writeSmallLong"], "fileName": "org.gradle.internal.serialize.AbstractEncoder"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals ( String . class )  )     {", "return    (  ( Serializer < T >  )     (  . STRING _ SERIALIZER )  )  ;", "}", "if    ( type . equals ( Long . class )  )     {", "return    (  ( Serializer )     (  . LONG _ SERIALIZER )  )  ;", "}", "if    ( type . equals ( File . class )  )     {", "return    (  ( Serializer )     (  . FILE _ SERIALIZER )  )  ;", "}", "if    ( type . equals ( byte [  ]  . class )  )     {", "return    (  ( Serializer )     (  . BYTE _ ARRAY _ SERIALIZER )  )  ;", "}", "if    ( type . isEnum (  )  )     {", "return   new    . EnumSerializer ( type )  ;", "}", "if    ( type . equals ( Boolean . class )  )     {", "return    (  ( Serializer < T >  )     (  . BOOLEAN _ SERIALIZER )  )  ;", "}", "if    ( Throwable . class . isAssignableFrom ( type )  )     {", "return    (  ( Serializer < T >  )     (  . THROWABLE _ SERIALIZER )  )  ;", "}", "if    ( HashCode . class . isAssignableFrom ( type )  )     {", "return    (  ( Serializer < T >  )     (  . HASHCODE _ SERIALIZER )  )  ;", "}", "return   new   DefaultSerializer < T >  ( type . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSerializerFor"], "fileName": "org.gradle.internal.serialize.BaseSerializerFactory"}, {"methodBody": ["METHOD_START", "{", "return   classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.gradle.internal.serialize.DefaultSerializer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( T )     ( new   ClassLoaderObjectInputStream ( decoderetInputStream (  )  ,    classLoader )  . readObject (  )  )  )  ;", "}    catch    ( StreamCorruptedException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.internal.serialize.DefaultSerializer"}, {"methodBody": ["METHOD_START", "{", "this . classLoader    =    classLoader ;", "}", "METHOD_END"], "methodName": ["setClassLoader"], "fileName": "org.gradle.internal.serialize.DefaultSerializer"}, {"methodBody": ["METHOD_START", "{", "ObjectOutputStream   objectStr    =    new   ObjectOutputStream ( encoder . getOutputStream (  )  )  ;", "objectStr . writeObject ( value )  ;", "objectStr . flush (  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.internal.serialize.DefaultSerializer"}, {"methodBody": ["METHOD_START", "{", "return    ( cause )     !  =    null    ?    cause . read ( classNameTransformer ,    objectInputStreamCreator )     :    null ;", "}", "METHOD_END"], "methodName": ["getCause"], "fileName": "org.gradle.internal.serialize.ExceptionPlaceholder"}, {"methodBody": ["METHOD_START", "{", "final   Throwable   causeThrowable    =    getCause ( classNameTransformer ,    objectInputStreamCreator )  ;", "if    (  ( serializedException )     !  =    null )     {", "final   ExceptionReplacingObjectInputStream   ois    =    objectInputStreamCreator . transform ( new   ByteArrayInputStream ( serializedException )  )  ;", "ois . setObjectTransformer ( new   Transformer < Object ,    Object >  (  )     {", "@ Override", "public   Object   transform ( Object   obj )     {", "if    ( obj   instanceof   CausePlaceholder )     {", "return   causeThrowable ;", "}", "return   obj ;", "}", "}  )  ;", "try    {", "return    (  ( Throwable )     ( ois . readObject (  )  )  )  ;", "}    catch    ( ClassNotFoundException   ignored )     {", "}    catch    ( Throwable   failure )     {", ". LOGGER . debug (  \" Ignoring   failure   to   de - serialize   throwable .  \"  ,    failure )  ;", "}", "}", "try    {", "Class <  ?  >    clazz    =    classNameTransformer . transform ( type )  ;", "if    ( clazz    !  =    null )     {", "Constructor <  ?  >    constructor    =    clazz . getConstructor ( String . class )  ;", "Throwable   reconstructed    =     (  ( Throwable )     ( constructor . newInstance ( message )  )  )  ;", "reconstructed . initCause ( causeThrowable )  ;", "reconstructed . setStackTrace ( stackTrace )  ;", "return   reconstructed ;", "}", "}    catch    ( UncheckedException   ignore )     {", "}    catch    ( NoSuchMethodException   ignored )     {", "}    catch    ( Throwable   ignored )     {", ". LOGGER . debug (  \" Ignoring   failure   to   recreate   throwable .  \"  ,    ignored )  ;", "}", "Throwable   placeholder    =    new   PlaceholderException ( type ,    message ,    getMessageExec ,    toString ,    toStringRuntimeExec ,    causeThrowable )  ;", "placeholder . setStackTrace ( stackTrace )  ;", "return   placeholder ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.internal.serialize.ExceptionPlaceholder"}, {"methodBody": ["METHOD_START", "{", "return   new   ExceptionReplacingObjectInputStream ( inputStream ,    getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createNewInstance"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "if    ( obj   instanceof   TopLevelExceptionPlaceholder )     {", "return    (  ( ExceptionPlaceholder )     ( obj )  )  . read ( getClassNameTransformer (  )  ,    getCreator (  )  )  ;", "}", "return   obj ;", "}", "METHOD_END"], "methodName": ["doResolveObject"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < Class <  ?  >  ,    String >  (  )     {", "@ Override", "public   Class <  ?  >    transform ( String   type )     {", "try    {", "return   lookupClass ( type )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getClassNameTransformer"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < ExceptionReplacingObjectInputStream ,    InputStream >  (  )     {", "@ Override", "public   ExceptionReplacingObjectInputStream   transform ( InputStream   inputStream )     {", "try    {", "return   createNewInstance ( inputStream )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getObjectInputStreamCreator"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "return   objectTransformer ;", "}", "METHOD_END"], "methodName": ["getObjectTransformer"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "return   getClassLoader (  )  . loadClass ( type )  ;", "}", "METHOD_END"], "methodName": ["lookupClass"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "this . objectTransformer    =    objectTransformer ;", "}", "METHOD_END"], "methodName": ["setObjectTransformer"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectInputStream"}, {"methodBody": ["METHOD_START", "{", "return   new   ExceptionReplacingObjectOutputStream ( outputStream )  ;", "}", "METHOD_END"], "methodName": ["createNewInstance"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "if    ( obj   instanceof   Throwable )     {", "return   new   TopLevelExceptionPlaceholder (  (  ( Throwable )     ( obj )  )  ,    getCreator (  )  )  ;", "}", "return   obj ;", "}", "METHOD_END"], "methodName": ["doReplaceObject"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < ExceptionReplacingObjectOutputStream ,    OutputStream >  (  )     {", "@ Override", "public   ExceptionReplacingObjectOutputStream   transform ( OutputStream   outputStream )     {", "try    {", "return   createNewInstance ( outputStream )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getObjectOutputStreamCreator"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "return   objectTransformer ;", "}", "METHOD_END"], "methodName": ["getObjectTransformer"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "this . objectTransformer    =    objectTransformer ;", "}", "METHOD_END"], "methodName": ["setObjectTransformer"], "fileName": "org.gradle.internal.serialize.ExceptionReplacingObjectOutputStream"}, {"methodBody": ["METHOD_START", "{", "inputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return   inputStream . readBoolean (  )  ;", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( byte )     (  ( inputStream . readByte (  )  )     &     2  5  5  )  )  ;", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "inputStream . readFully ( buffer ,    offset ,    count )  ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return   inputStream . readInt (  )  ;", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return   inputStream . readLong (  )  ;", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return   inputStream . readUTF (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "org.gradle.internal.serialize.InputStreamBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "int   size    =    decoder . readInt (  )  ;", "Map < U ,    V >    valueMap    =    new   LinkedHashMap < U ,    V >  ( size )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "U   key    =    key . read ( decoder )  ;", "V   value    =    value . read ( decoder )  ;", "valueMap . put ( key ,    value )  ;", "}", "return   valueMap ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.internal.serialize.MapSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeInt ( value . size (  )  )  ;", "for    ( Map . Entry < U ,    V >    entry    :    value . entrySet (  )  )     {", "key . write ( encoder ,    entry . getKey (  )  )  ;", "value . write ( encoder ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.internal.serialize.MapSerializer"}, {"methodBody": ["METHOD_START", "{", "ObjectInputStream   ois    =    new   ExceptionReplacingObjectInputStream ( inputSteam ,    classLoader )  ;", "return   ois . readObject (  )  ;", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.internal.serialize.Message"}, {"methodBody": ["METHOD_START", "{", "ObjectOutputStream   oos    =    new   ExceptionReplacingObjectOutputStream ( outputSteam )  ;", "try    {", "oos . writeObject ( m )  ;", "}    finally    {", "oos . flush (  )  ;", "}", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.gradle.internal.serialize.Message"}, {"methodBody": ["METHOD_START", "{", "return   decoder . readNullableString (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.internal.serialize.NullSafeStringSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeNullableString ( value )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.internal.serialize.NullSafeStringSerializer"}, {"methodBody": ["METHOD_START", "{", "outputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "outputStream . writeBoolean ( value )  ;", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "outputStream . writeByte ( value )  ;", "}", "METHOD_END"], "methodName": ["writeByte"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "outputStream . write ( bytes ,    offset ,    count )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "outputStream . writeInt ( value )  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "outputStream . writeLong ( value )  ;", "}", "METHOD_END"], "methodName": ["writeLong"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   encode   a   null   string .  \"  )  ;", "}", "o . writeUTF ( value . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "org.gradle.internal.serialize.OutputStreamBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "return   exceptionClassName ;", "}", "METHOD_END"], "methodName": ["getExceptionClassName"], "fileName": "org.gradle.internal.serialize.PlaceholderException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( toStringRuntimeEx )     !  =    null )     {", "throw   Unchecked . throwAsUnchecked ( toStringRuntimeEx )  ;", "}", "return   toString ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.internal.serialize.PlaceholderException"}, {"methodBody": ["METHOD_START", "{", "return   new   Serializer < T >  (  )     {", "@ Override", "public   T   read ( Decoder   decoder )     {", "return   instance ;", "}", "@ Override", "public   void   write ( Encoder   encoder ,    T   value )     {", "if    ( value    !  =    instance )     {", "throw   new   IllegalArgumentException (  (  \" Cannot   serialize   constant   value :     \"     +    value )  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["constant"], "fileName": "org.gradle.internal.serialize.Serializers"}, {"methodBody": ["METHOD_START", "{", "return   new   Serializers . StatefulSerializerAdapter < T >  ( serializer )  ;", "}", "METHOD_END"], "methodName": ["stateful"], "fileName": "org.gradle.internal.serialize.Serializers"}, {"methodBody": ["METHOD_START", "{", "input . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return    ( input . total (  )  )     +     ( extraSkipped )  ;", "}", "METHOD_END"], "methodName": ["getReadPosition"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "if    ( e . getMessage (  )  . equals (  \" Buffer   underflow .  \"  )  )     {", "throw    (  ( EOFException )     ( new   EOFException (  )  . initCause ( e )  )  )  ;", "}", "throw   e ;", "}", "METHOD_END"], "methodName": ["maybeEndOfStream"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readBoolean (  )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readBoolean"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readByte (  )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readByte"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "input . readBytes ( buffer ,    offset ,    count )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readInt (  )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readInt"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readLong (  )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readLong"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readString (  )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readNullableString"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readInt ( true )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readSmallInt"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   input . readLong ( true )  ;", "}    catch    ( Exception   e )     {", "throw   maybeEndOfStream ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readSmallLong"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "return   readNullableString (  )  ;", "}", "METHOD_END"], "methodName": ["readString"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedDecoder"}, {"methodBody": ["METHOD_START", "{", "output . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "return   output . total (  )  ;", "}", "METHOD_END"], "methodName": ["getWritePosition"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeBoolean ( value )  ;", "}", "METHOD_END"], "methodName": ["writeBoolean"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeByte ( value )  ;", "}", "METHOD_END"], "methodName": ["writeByte"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeBytes ( bytes ,    offset ,    count )  ;", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeInt ( value )  ;", "}", "METHOD_END"], "methodName": ["writeInt"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeLong ( value )  ;", "}", "METHOD_END"], "methodName": ["writeLong"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeString ( value )  ;", "}", "METHOD_END"], "methodName": ["writeNullableString"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeInt ( value ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeSmallInt"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "output . writeLong ( value ,    true )  ;", "}", "METHOD_END"], "methodName": ["writeSmallLong"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Cannot   e   a   null   string .  \"  )  ;", "}", "output . writeString ( value )  ;", "}", "METHOD_END"], "methodName": ["writeString"], "fileName": "org.gradle.internal.serialize.kryo.KryoBackedEncoder"}, {"methodBody": ["METHOD_START", "{", "final   ObjectReader < T >    reader    =    serializer . newReader ( decoder )  ;", "return   new   ObjectReader < Object >  (  )     {", "public   Object   read (  )    throws   Exception    {", "return   reader . read (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newReader"], "fileName": "org.gradle.internal.serialize.kryo.TypeSafeSerializer"}, {"methodBody": ["METHOD_START", "{", "final   ObjectWriter < T >    writer    =    serializer . newWriter ( encoder )  ;", "return   new   ObjectWriter < Object >  (  )     {", "public   void   write ( Object   value )    throws   Exception    {", "writer . write ( type . cast ( value )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newWriter"], "fileName": "org.gradle.internal.serialize.kryo.TypeSafeSerializer"}]