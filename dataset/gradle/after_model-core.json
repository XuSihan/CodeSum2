[{"methodBody": ["METHOD_START", "{", "return    (  \"  [  \"     +     ( getName (  )  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["getCalculatedValue"], "fileName": "org.gradle.api.internal.model.AbstractNamed"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  [  \"     +     ( getName (  )  )  )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["getCalculatedValue"], "fileName": "org.gradle.api.internal.model.DummyNamed"}, {"methodBody": ["METHOD_START", "{", "FormattingValidationProblemCollector   problemCollector    =    new   FormattingValidationProblemCollector (  \" Named   implementation   class \"  ,    ModelType . of ( publicClass )  )  ;", "visitFields ( publicClass ,    problemCollector )  ;", "if    ( problemCollector . hasProblems (  )  )     {", "throw   new   GradleException ( problemCollector . format (  )  )  ;", "}", "AsmClassGenerator   generator    =    new   AsmClassGenerator ( publicClass ,     \"  $ Impl \"  )  ;", "Type   implementationType    =    generator . getGeneratedType (  )  ;", "ClassWriter   visitor    =    generator . getVisitor (  )  ;", "Type   publicType    =    Type . getType ( publicClass )  ;", "Type   superClass ;", "String [  ]    interfaces ;", "if    ( publicClass . isInterface (  )  )     {", "superClass    =     . OBJECT ;", "interfaces    =    new   String [  ]  {    publicType . getInternalName (  )  ,     . MANAGED . getInternalName (  )     }  ;", "} else    {", "superClass    =    publicType ;", "interfaces    =     . INTERFACES _ FOR _ ABSTRACT _ CLASS ;", "}", "visitor . visit ( V 1  _  5  ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  ,    implementationType . getInternalName (  )  ,    null ,    superClass . getInternalName (  )  ,    interfaces )  ;", "visitor . visitField ( ACC _ PRIVATE ,     . NAME _ FIELD ,     . STRING . getDescriptor (  )  ,    null ,    null )  ;", "MethodVisitor   methodVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,     . CONSTRUCTOR _ NAME ,     . RETURN _ VOID _ FROM _ STRING ,    null ,     . EMPTY _ STRINGS )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    superClass . getInternalName (  )  ,     . CONSTRUCTOR _ NAME ,     . RETURN _ VOID ,    false )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "methodVisitor . visitFieldInsn ( PUTFIELD ,    implementationType . getInternalName (  )  ,     . NAME _ FIELD ,     . STRING . getDescriptor (  )  )  ;", "methodVisitor . visitInsn ( RETURN )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "methodVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,     \" getName \"  ,     . RETURN _ STRING ,    null ,     . EMPTY _ STRINGS )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitFieldInsn ( GETFIELD ,    implementationType . getInternalName (  )  ,     . NAME _ FIELD ,     . STRING . getDescriptor (  )  )  ;", "methodVisitor . visitInsn ( ARETURN )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "methodVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,     \" toString \"  ,     . RETURN _ STRING ,    null ,     . EMPTY _ STRINGS )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitFieldInsn ( GETFIELD ,    implementationType . getInternalName (  )  ,     . NAME _ FIELD ,     . STRING . getDescriptor (  )  )  ;", "methodVisitor . visitInsn ( ARETURN )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "visitor . visitEnd (  )  ;", "generator . define (  )  ;", "generator    =    new   AsmClassGenerator ( publicClass ,     \"  $ Factory \"  )  ;", "visitor    =    generator . getVisitor (  )  ;", "visitor . visit ( V 1  _  5  ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  ,    generator . getGeneratedType (  )  . getInternalName (  )  ,    null ,     . CLASS _ GENERATING _ LOADER . getInternalName (  )  ,     . EMPTY _ STRINGS )  ;", "methodVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,     . CONSTRUCTOR _ NAME ,     . RETURN _ VOID ,    null ,     . EMPTY _ STRINGS )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,     . CLASS _ GENERATING _ LOADER . getInternalName (  )  ,     . CONSTRUCTOR _ NAME ,     . RETURN _ VOID ,    false )  ;", "methodVisitor . visitInsn ( RETURN )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "methodVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,     \" load \"  ,     . RETURN _ OBJECT _ FROM _ STRING ,    null ,     . EMPTY _ STRINGS )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitTypeInsn ( NEW ,    implementationType . getInternalName (  )  )  ;", "methodVisitor . visitInsn ( DUP )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    implementationType . getInternalName (  )  ,     . CONSTRUCTOR _ NAME ,     . RETURN _ VOID _ FROM _ STRING ,    false )  ;", "methodVisitor . visitInsn ( ARETURN )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "visitor . visitEnd (  )  ;", "Class < Object >    factoryClass    =    generator . define (  )  ;", "try    {", "return    (  (  . ClassGeneratingLoader )     ( factoryClass . newInstance (  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["loaderFor"], "fileName": "org.gradle.api.internal.model.NamedObjectInstantiator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   type . cast ( values . getUnchecked ( type )  . getUnchecked ( name )  )  ;", "}    catch    ( UncheckedExecutionException   e )     {", "throw   new   ionException ( type ,    e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["named"], "fileName": "org.gradle.api.internal.model.NamedObjectInstantiator"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals ( Object . class )  )     {", "return ;", "}", "if    (  ( type . getSuperclass (  )  )     !  =    null )     {", "visitFields ( type . getSuperclass (  )  ,    collector )  ;", "}", "for    ( Field   field    :    type . getDeclaredFields (  )  )     {", "if    (  ( Modifier . isStatic ( field . getModifiers (  )  )  )     |  |     (  ( GroovyObject . class . isAssignableFrom ( type )  )     &  &     ( field . getName (  )  . equals (  \" metaClass \"  )  )  )  )     {", "continue ;", "}", "collector . add ( field ,     \" A   Named   implementation   class   must   not   define   any   instance   fields .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitFields"], "fileName": "org.gradle.api.internal.model.NamedObjectInstantiator"}, {"methodBody": ["METHOD_START", "{", "Optional < ModelRuleDescriptor >    creator    =    creators . get ( type )  ;", "if    ( creator    !  =    null )     {", "StringBuilder   builder    =    new   StringBuilder (  \" Cannot   register   a   f   for   type    \"  )  . append ( type . getSimpleName (  )  )  . append (  \"    because   a   f   for   this   type   was   already   registered \"  )  ;", "if    ( creator . isPresent (  )  )     {", "builder . append (  \"    by    \"  )  ;", "creator . get (  )  . describeTo ( builder )  ;", "}", "builder . append (  \"  .  \"  )  ;", "throw   new   GradleException ( builder . toString (  )  )  ;", "}", "creators . put ( type ,    Optional . fromNullable ( descriptor )  )  ;", "}", "METHOD_END"], "methodName": ["checkCanRegister"], "fileName": "org.gradle.api.internal.rules.DefaultRuleAwareNamedDomainObjectFactoryRegistry"}, {"methodBody": ["METHOD_START", "{", "Type   genericSuperclass    =    getClass (  )  . getGenericSuperclass (  )  ;", "Type   type    =     ( genericSuperclass   instanceof   ParameterizedType )     ?     (  ( ParameterizedType )     ( genericSuperclass )  )  . getActualTypeArguments (  )  [  0  ]     :    Object . class ;", "return   Cast . uncheckedCast ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["captureTypeArgument"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   TypeOf . typeOfListFrom ( type . getTypeVariables (  )  )  ;", "}", "METHOD_END"], "methodName": ["getActualTypeArguments"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type . isGenericArray (  )     ?    TypeOf . typeOf ( type . getComponentType (  )  )     :    nullableTypeOf ( rawClass (  )  . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   rawClass (  )  . getModifiers (  )  ;", "}", "METHOD_END"], "methodName": ["getModifiers"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   TypeOf . typeOf ( type . getRawType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getParameterizedTypeDefinition"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   nullableTypeOf ( type . getUpperBound (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUpperBound"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return    ( type . isGenericArray (  )  )     |  |     (  ( type . isClass (  )  )     &  &     ( rawClass (  )  . isArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isArray"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   this . type . isAssignableFrom ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   this . type . isAssignableFrom ( type . type )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type . isParameterized (  )  ;", "}", "METHOD_END"], "methodName": ["isParameterized"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   Modifier . isPublic ( getModifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return    ( type . isClass (  )  )     &  &     (  !  ( rawClass (  )  . isArray (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSimple"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   rawClass (  )  . isSynthetic (  )  ;", "}", "METHOD_END"], "methodName": ["isSynthetic"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type . isWildcard (  )  ;", "}", "METHOD_END"], "methodName": ["isWildcard"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   copyOf ( transform ( iterable ,    function )  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   TypeOf . map ( Arrays . asList ( typeOfs )  ,    new   com . google . common . base . Function < TypeOf <  ?  >  ,    ModelType <  ?  >  >  (  )     {", "@ Override", "public   ModelType <  ?  >    apply ( TypeOf <  ?  >    it )     {", "return   it . type ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["modelTypeListFrom"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type    !  =    null    ?    TypeOf . typeOf ( type )     :    null ;", "}", "METHOD_END"], "methodName": ["nullableTypeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type    !  =    null    ?    TypeOf . typeOf ( type )     :    null ;", "}", "METHOD_END"], "methodName": ["nullableTypeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "ModelType <  ?  >    parameterizedModelType    =    parameterizedType . type ;", "if    (  !  ( parameterizedModelType . isParameterized (  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Expecting   a   parameterized   type ,    got :     \"     +    parameterizedType )     +     \"  .  \"  )  )  ;", "}", "return    . typeOf ( parameterizedModelType . withArguments (  . modelTypeListFrom ( typeArguments )  )  )  ;", "}", "METHOD_END"], "methodName": ["parameterizedTypeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   type . getRawClass (  )  ;", "}", "METHOD_END"], "methodName": ["rawClass"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeOf < T >  ( ModelType . of ( TypeOf . typeWhichCannotBeNull ( type )  )  )     {  }  ;", "}", "METHOD_END"], "methodName": ["typeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeOf < T >  ( Cast .  < ModelType < T >  > uncheckedCast ( ModelType . of ( TypeOf . typeWhichCannotBeNull ( type )  )  )  )     {  }  ;", "}", "METHOD_END"], "methodName": ["typeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   new   TypeOf < U >  ( componentType )     {  }  ;", "}", "METHOD_END"], "methodName": ["typeOf"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   TypeOf . map ( modelTypes ,    new   com . google . common . base . Function < ModelType <  ?  >  ,    TypeOf <  ?  >  >  (  )     {", "@ Override", "public   TypeOf <  ?  >    apply ( ModelType <  ?  >    it )     {", "return   TypeOf . typeOf ( it )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["typeOfListFrom"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "throw   new   IllegalArgumentException (  \" type   cannot   be   null .  \"  )  ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["typeWhichCannotBeNull"], "fileName": "org.gradle.api.reflect.TypeOf"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.model.InvalidModelRuleException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append (  \" Attempt   to   modify   a    \"  )  . append ( viewType )  . append (  \"    view   of      element    '  \"  )  ;", "result . append ( path )  ;", "result . append (  \"  '  \"  )  ;", "if    (  !  ( type . equals ( ModelType . UNTYPED )  )  )     {", "result . append (  \"    of   type    '  \"  )  ;", "result . append ( type . getDisplayName (  )  )  ;", "result . append (  \"  '  \"  )  ;", "}", "result . append (  \"    given   to   rule    \"  )  ;", "ruleDescriptor . describeTo ( result )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.gradle.model.ReadOnlyModelViewException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "result . append (  \" Attempt   to   read \"  )  ;", "if    ( property    !  =    null )     {", "result . append (  \"    property    '  \"  )  ;", "result . append ( property )  ;", "result . append (  \"  '  \"  )  ;", "}", "result . append (  \"    from   a   write   only   view   of      element    '  \"  )  ;", "result . append ( path )  ;", "result . append (  \"  '  \"  )  ;", "if    (  !  ( type . equals ( ModelType . UNTYPED )  )  )     {", "result . append (  \"    of   type    '  \"  )  ;", "result . append ( type . getDisplayName (  )  )  ;", "result . append (  \"  '  \"  )  ;", "}", "result . append (  \"    given   to   rule    \"  )  ;", "ruleDescriptor . describeTo ( result )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createMessage"], "fileName": "org.gradle.model.WriteOnlyModelViewException"}, {"methodBody": ["METHOD_START", "{", "return   define ( targetType . getClassLoader (  )  )  ;", "}", "METHOD_END"], "methodName": ["define"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   ClassLoaderUtils . define ( targetClassLoader ,    generatedTypeName ,    visitor . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["define"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   generatedType ;", "}", "METHOD_END"], "methodName": ["getGeneratedType"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   generatedTypeName ;", "}", "METHOD_END"], "methodName": ["getGeneratedTypeName"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   targetType ;", "}", "METHOD_END"], "methodName": ["getTargetType"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   visitor ;", "}", "METHOD_END"], "methodName": ["getVisitor"], "fileName": "org.gradle.model.internal.asm.AsmClassGenerator"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", ". visitFormalTypeParameters ( builder ,    constructor . getTypeParameters (  )  )  ;", ". visitParameters ( builder ,    constructor . getGenericParameterTypes (  )  )  ;", "builder . append (  \" V \"  )  ;", ". visitExceptions ( builder ,    constructor . getGenericExceptionTypes (  )  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["signature"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", ". visitFormalTypeParameters ( builder ,    method . getTypeParameters (  )  )  ;", ". visitParameters ( builder ,    method . getGenericParameterTypes (  )  )  ;", ". visitType ( method . getGenericReturnType (  )  ,    builder )  ;", ". visitExceptions ( builder ,    method . getGenericExceptionTypes (  )  )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["signature"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "for    ( Type   exceptionType    :    exceptionTypes )     {", "builder . append (  '  ^  '  )  ;", ". visitType ( exceptionType ,    builder )  ;", "}", "}", "METHOD_END"], "methodName": ["visitExceptions"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( typeParameters . length )     >     0  )     {", "builder . append (  '  <  '  )  ;", "for    ( TypeVariable <  ?  >    typeVariable    :    typeParameters )     {", "builder . append ( typeVariable . getName (  )  )  ;", "for    ( Type   bound    :    typeVariable . getBounds (  )  )     {", "builder . append (  '  :  '  )  ;", ". visitType ( bound ,    builder )  ;", "}", "}", "builder . append (  '  >  '  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitFormalTypeParameters"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   Class )     {", "Class <  ?  >    cl    =     (  ( Class <  ?  >  )     ( type )  )  ;", "if    ( cl . isPrimitive (  )  )     {", "builder . append ( Type . getType ( cl )  . getDescriptor (  )  )  ;", "} else    {", "builder . append (  ' L '  )  ;", "builder . append ( cl . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )  ;", "}", "} else    {", ". visitType ( type ,    builder )  ;", "}", "}", "METHOD_END"], "methodName": ["visitNested"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "builder . append (  '  (  '  )  ;", "for    ( Type   paramType    :    parameterTypes )     {", ". visitType ( paramType ,    builder )  ;", "}", "builder . append (  \"  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["visitParameters"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   Class )     {", "Class <  ?  >    cl    =     (  ( Class <  ?  >  )     ( type )  )  ;", "if    ( cl . isPrimitive (  )  )     {", "builder . append ( Type . getType ( cl )  . getDescriptor (  )  )  ;", "} else    {", "if    ( cl . isArray (  )  )     {", "builder . append ( cl . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )  ;", "} else    {", "builder . append (  ' L '  )  ;", "builder . append ( cl . getName (  )  . replace (  '  .  '  ,     '  /  '  )  )  ;", "builder . append (  '  ;  '  )  ;", "}", "}", "} else", "if    ( type   instanceof   ParameterizedType )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( type )  )  ;", ". visitNested ( parameterizedType . getRawType (  )  ,    builder )  ;", "builder . append (  '  <  '  )  ;", "for    ( Type   param    :    parameterizedType . getActualTypeArguments (  )  )     {", ". visitType ( param ,    builder )  ;", "}", "builder . append (  \"  >  ;  \"  )  ;", "} else", "if    ( type   instanceof   WildcardType )     {", "WildcardType   wildcardType    =     (  ( WildcardType )     ( type )  )  ;", "if    (  (  ( wildcardType . getUpperBounds (  )  . length )     =  =     1  )     &  &     ( wildcardType . getUpperBounds (  )  [  0  ]  . equals ( Object . class )  )  )     {", "if    (  ( wildcardType . getLowerBounds (  )  . length )     =  =     0  )     {", "builder . append (  '  *  '  )  ;", "return ;", "}", "} else    {", "for    ( Type   upperType    :    wildcardType . getUpperBounds (  )  )     {", "builder . append (  '  +  '  )  ;", ". visitType ( upperType ,    builder )  ;", "}", "}", "for    ( Type   lowerType    :    wildcardType . getLowerBounds (  )  )     {", "builder . append (  '  -  '  )  ;", ". visitType ( lowerType ,    builder )  ;", "}", "} else", "if    ( type   instanceof   TypeVariable )     {", "TypeVariable <  ?  >    typeVar    =     (  ( TypeVariable )     ( type )  )  ;", "builder . append (  ' T '  )  ;", "builder . append ( typeVar . getName (  )  )  ;", "builder . append (  '  ;  '  )  ;", "} else", "if    ( type   instanceof   GenericArrayType )     {", "GenericArrayType   arrayType    =     (  ( GenericArrayType )     ( type )  )  ;", "builder . append (  '  [  '  )  ;", ". visitType ( arrayType . getGenericComponentType (  )  ,    builder )  ;", "} else    {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   generate   signature   for    % s .  \"  ,    type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitType"], "fileName": "org.gradle.model.internal.asm.AsmClassGeneratorUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   AddProjectionsAction < T >  ( subject ,    descriptor ,    projections )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.AddProjectionsAction"}, {"methodBody": ["METHOD_START", "{", "return   AddProjectionsAction . of ( subject ,    descriptor ,    Arrays . asList ( projections )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.AddProjectionsAction"}, {"methodBody": ["METHOD_START", "{", "return   new   ChildNodeInitializerStrategyAccessor < T >  (  )     {", "@ Override", "public   ChildNodeInitializerStrategy < T >    getStrategy ( MutableModelNode   node )     {", "return   Cast . uncheckedCast ( node . getPrivateData (  . CHILD _ NODE _ INITIALIZER _ STRATEGY _ MODEL _ TYPE )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["fromPrivateData"], "fileName": "org.gradle.model.internal.core.ChildNodeInitializerStrategyAccessors"}, {"methodBody": ["METHOD_START", "{", "return   new   ChildNodeInitializerStrategyAccessor < T >  (  )     {", "@ Override", "public   ChildNodeInitializerStrategy < T >    getStrategy ( MutableModelNode   node )     {", "return   strategy ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ChildNodeInitializerStrategyAccessors"}, {"methodBody": ["METHOD_START", "{", "closed    =    true ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.model.internal.core.DefaultModelViewState"}, {"methodBody": ["METHOD_START", "{", "return   new   Action < Object >  (  )     {", "@ Override", "public   void   execute ( Object   o )     {", "close (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["closer"], "fileName": "org.gradle.model.internal.core.DefaultModelViewState"}, {"methodBody": ["METHOD_START", "{", "return   closed ;", "}", "METHOD_END"], "methodName": ["isClosed"], "fileName": "org.gradle.model.internal.core.DefaultModelViewState"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet . Builder < ModelType <  ?  >  >    constructibleTypes    =    ImmutableSortedSet . orderedBy ( ModelTypes . displayOrder (  )  )  ;", "for    ( ExtractionStrategy   extractor    :    additionalStrategies )     {", "for    ( ModelType <  ?  >    constructibleType    :    extractor . supportedTypes (  )  )     {", "if    ( context . getConstraints (  )  . isSatisfiedBy ( constructibleType )  )     {", "constructibleTypes . add ( constructibleType )  ;", "}", "}", "}", "return   new   ModelTypeInitializationException ( context ,    schemaStore ,    ScalarTypes . TYPES ,    constructibleTypes . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["canNotConstructTypeException"], "fileName": "org.gradle.model.internal.core.DefaultNodeInitializerRegistry"}, {"methodBody": ["METHOD_START", "{", "ModelSchema < T >    schema    =    schemaStore . getSchema ( context . getModelType (  )  )  ;", "for    ( NodeInitializerExtractionStrategy   extractor    :    allStrategies )     {", "NodeInitializer   nodeInitializer    =    extractor . extrac ( schema ,    context )  ;", "if    ( nodeInitializer    !  =    null )     {", "return   nodeInitializer ;", "}", "}", "throw   canNotConstructTypeException ( context )  ;", "}", "METHOD_END"], "methodName": ["extractNodeInitializer"], "fileName": "org.gradle.model.internal.core.DefaultNodeInitializerRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractModelAction < T >  ( reference ,    descriptor ,    input )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( modelNode ,    inputs )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeInputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectNodeInputUsingModelAction < T >  ( modelReference ,    descriptor ,    inputs ,    action )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeInputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractModelAction < T >  ( reference ,    descriptor ,    input )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( modelNode ,    Cast .  < I > uncheckedCast ( inputs . get (  0  )  . getInstance (  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeInputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractModelAction < T >  ( reference ,    descriptor ,    input 1  ,    input 2  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( modelNode ,    Cast .  < I > uncheckedCast ( inputs . get (  0  )  . getInstance (  )  )  ,    Cast .  < J > uncheckedCast ( inputs . get (  1  )  . getInstance (  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeInputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractModelAction < T >  ( reference ,    descriptor ,    Collections .  < ModelReference <  ?  >  > emptyList (  )  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( modelNode )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeNoInputsModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   DirectNodeNoInputsModelAction < T >  ( reference ,    descriptor ,    action )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.DirectNodeNoInputsModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   InputUsingModelAction < T >  ( modelReference ,    descriptor ,    inputs ,    initializer )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.InputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   new   InputUsingModelAction < T >  ( modelReference ,    descriptor ,    Collections .  < ModelReference <  ?  >  > singletonList ( input )  ,    new   BiAction < T ,    List < ModelView <  ?  >  >  >  (  )     {", "@ Override", "public   void   execute ( T   t ,    List < ModelView <  ?  >  >    modelViews )     {", "initializer . execute ( t ,    ModelViews . assertType ( modelViews . get (  0  )  ,    input . getType (  )  )  . getInstance (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["single"], "fileName": "org.gradle.model.internal.core.InputUsingModelAction"}, {"methodBody": ["METHOD_START", "{", "return   InstanceModelView . of ( path ,    type ,    instance ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.InstanceModelView"}, {"methodBody": ["METHOD_START", "{", "return   new   InstanceModelView < T >  ( path ,    type ,    instance ,    onClose )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.InstanceModelView"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTargetState"], "fileName": "org.gradle.model.internal.core.ModelActionRole"}, {"methodBody": ["METHOD_START", "{", "return   subjectViewAvailable ;", "}", "METHOD_END"], "methodName": ["isSubjectViewAvailable"], "fileName": "org.gradle.model.internal.core.ModelActionRole"}, {"methodBody": ["METHOD_START", "{", "afterEach ( new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["afterEach"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "afterEach ( type ,    new   ClosureBackedAction < S >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["afterEach"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "all ( new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "beforeEach ( new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["beforeEach"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "beforeEach ( type ,    new   ClosureBackedAction < S >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["beforeEach"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "create ( name ,    new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "create ( name ,    type ,    new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =     (  ( Object [  ]  )     ( argsObj )  )  ;", "if    (  (  ( args . length )     =  =     1  )     &  &     (  ( args [  0  ]  )    instanceof   Class <  ?  >  )  )     {", "Class <  ?    extends   I >    itemType    =     . uncheckedCast ( args [  0  ]  )  ;", "create ( name ,    itemType )  ;", "} else", "if    (  (  (  ( args . length )     =  =     2  )     &  &     (  ( args [  0  ]  )    instanceof   Class <  ?  >  )  )     &  &     (  ( args [  1  ]  )    instanceof   groovy . lang . Closure <  ?  >  )  )     {", "Class <  ?    extends   I >    itemType    =     . uncheckedCast ( args [  0  ]  )  ;", "groovy . lang . Closure <  ?    super   I >    closure    =     . uncheckedCast ( args [  1  ]  )  ;", "create ( name ,    itemType ,    closure )  ;", "} else", "if    (  (  ( args . length )     =  =     1  )     &  &     (  ( args [  0  ]  )    instanceof   groovy . lang . Closure <  ?  >  )  )     {", "groovy . lang . Closure <  ?    super   I >    closure    =     . uncheckedCast ( args [  0  ]  )  ;", "named ( name ,    closure )  ;", "} else    {", "throw   new   groovy . lang . MissingMethodException ( name ,    class ,    args )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["methodMissing"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "named ( name ,    new   ClosureBackedAction < I >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["named"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "withType ( type ,    new   ClosureBackedAction < S >  ( configAction )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.ModelMapGroovyView"}, {"methodBody": ["METHOD_START", "{", "ModelType <  ?    extends   I >    itemType    =    itemType ( targetType )  ;", "if    ( itemType    !  =    null )     {", "return    . uncheckedCast ( toView ( targetType ,    ruleDescriptor ,    node ,    itemType ,    mutable ,     (  (  !  ( managed )  )     |  |     (  ! mutable )  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doAs"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( containerType . getName (  )  )  ;", "if    (  ( creatableTypes . size (  )  )     =  =     1  )     {", "@ SuppressWarnings (  \" ConstantConditions \"  )", "String   onlyType    =    Iterables . getFirst ( creatableTypes ,    null )  . getName (  )  ;", "sb . append (  \"  <  \"  )  . append ( onlyType )  . append (  \"  >  \"  )  ;", "} else    {", "sb . append (  \"  < T >  ;    where   T   is   one   of    [  \"  )  ;", "Joiner . on (  \"  ,     \"  )  . appendTo ( sb ,    CollUtils . sort ( Iterables . transform ( creatableTypes ,    new   com . google . common . base . Function < Class <  ?  >  ,    String >  (  )     {", "public   String   apply ( Class <  ?  >    input )     {", "return   input . getName (  )  ;", "}", "}  )  )  )  ;", "sb . append (  \"  ]  \"  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getContainerTypeDescription"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singleton ( baseItemModelType . getConcreteClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCreatableTypes"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    targetClass    =    targetType . getRawClass (  )  ;", "if    ( targetClass . equals (  . class )  )     {", "ModelType <  ?  >    targetItemClass    =    targetType . getTypeVariables (  )  . get (  0  )  ;", "if    ( targetItemClass . isAssignableFrom ( baseItemModelType )  )     {", "return   baseItemModelType ;", "}", "if    ( baseItemModelType . isAssignableFrom ( targetItemClass )  )     {", "return   targetItemClass . asSubtype ( baseItemModelType )  ;", "}", "return   null ;", "}", "if    ( targetClass . isAssignableFrom (  . class )  )     {", "return   baseItemModelType ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["itemType"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelMapModelProjection < T >  ( publicType ,    itemType ,    true ,    creatorStrategyAccessor )  ;", "}", "METHOD_END"], "methodName": ["managed"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "ChildNodeInitializerStrategy <  ?    super   I >    creatorStrategy    =    creatorStrategyAccessor . getStrategy ( node )  ;", "DefaultModelViewState   state    =    new   DefaultModelViewState ( node . getPath (  )  ,    targetType ,    sourceDescriptor ,    mutable ,    canReadChildren )  ;", "NodeBacked < I >    builder    =    new   NodeBacked < I >  ( publicType ,    baseItemModelType ,    sourceDescriptor ,    node ,    state ,    creatorStrategy )  ;", "return   InstanceModelView . of ( node . getPath (  )  ,    ModelTypes . modelMap ( itemType )  ,    builder . withType ( itemType )  ,    state . closer (  )  )  ;", "}", "METHOD_END"], "methodName": ["toView"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   ModelMapModelProjection . unmanaged ( ModelType . of ( itemType )  ,    creatorStrategyAccessor )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelMapModelProjection < T >  ( ModelTypes . modelMap ( itemType )  ,    itemType ,    false ,    creatorStrategyAccessor )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.core.ModelMapModelProjection"}, {"methodBody": ["METHOD_START", "{", "modelNode . addLink ( ModelRegistrations . of ( modelNode . getPath (  )  . child ( name )  )  . action ( ModelActionRole . Create ,    ModelMaps . NODE _ INITIALIZER _ REGISTRY _ MODEL _ REFERENCE ,    new   BiAction < MutableModelNode ,    NodeInitializerRegistry >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   node ,    NodeInitializerRegistry   nodeInitializerRegistry )     {", "ChildNodeInitializerStrategy < T >    childFactory    =    NodeBackedModelMap . createUsingRegistry ( nodeInitializerRegistry )  ;", "node . setPrivateData ( ModelMaps . CHILD _ NODE _ INITIALIZER _ STRATEGY _ MODEL _ TYPE ,    childFactory )  ;", "}", "}  )  . descriptor ( modelNode . getDescriptor (  )  )  . withProjection ( ModelMapModelProjection . unmanaged ( elementModelType ,    ChildNodeInitializerStrategyAccessors . fromPrivateData (  )  )  )  . build (  )  )  ;", "MutableModelNode   mapNode    =    modelNode . getLink ( name )  ;", "assert   mapNode    !  =    null ;", "return   mapNode ;", "}", "METHOD_END"], "methodName": ["addModelMapNode"], "fileName": "org.gradle.model.internal.core.ModelMaps"}, {"methodBody": ["METHOD_START", "{", "mapNode . ensureUsable (  )  ;", "return   mapNode . asMutable ( ModelTypes . m ( elementModelType )  ,    RuleContext . get (  )  )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["toView"], "fileName": "org.gradle.model.internal.core.ModelMaps"}, {"methodBody": ["METHOD_START", "{", "return   Predicates . alwaysTrue (  )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.model.internal.core.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   ModelNodes . withType ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   ModelNodes . withType ( ModelType . of ( type )  ,    predicate )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   ModelNodes . withType ( type ,    Predicates .  < MutableModelNode > alwaysTrue (  )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "return   new   com . google . common . base . Predicate < MutableModelNode >  (  )     {", "@ Override", "public   boolean   apply ( MutableModelNode   node )     {", "node . ensureAtLeast ( ModelNode . State . Discovered )  ;", "return    ( node . canBeViewedAs ( type )  )     &  &     ( predicate . apply ( node )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.ModelNodes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . components . length )     =  =     0  )     {", "return    . path ( child ,    new   String [  ]  {    child    }  )  ;", "}", "String [  ]    childComponents    =    new   String [  ( components . length )     +     1  ]  ;", "System . arraycopy ( components ,     0  ,    childComponents ,     0  ,    components . length )  ;", "childComponents [ components . length ]     =    child ;", "return    . path (  (  (  ( path )     +     \"  .  \"  )     +    child )  ,    childComponents )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    (  ( components . length )     =  =     0  )     {", "return   path ;", "}", "if    (  ( path . components . length )     =  =     0  )     {", "return   this ;", "}", "String [  ]    descendantComponents    =    new   String [  ( components . length )     +     ( path . components . length )  ]  ;", "System . arraycopy ( components ,     0  ,    descendantComponents ,     0  ,    components . length )  ;", "System . arraycopy ( path . components ,     0  ,    descendantComponents ,    components . length ,    path . components . length )  ;", "return    . path (  (  (  ( this . path )     +     \"  .  \"  )     +     ( path . getPath (  )  )  )  ,    descendantComponents )  ;", "}", "METHOD_END"], "methodName": ["descendant"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    (  ( components . length )     =  =     0  )     {", "return   null ;", "}", "if    (  ( components . length )     =  =     1  )     {", "return    . ROOT ;", "}", "String [  ]    parentComponents    =    new   String [  ( components . length )     -     1  ]  ;", "System . arraycopy ( components ,     0  ,    parentComponents ,     0  ,     (  ( components . length )     -     1  )  )  ;", "int   parentPathLength    =     (  ( path . length (  )  )     -     ( components [  (  ( components . length )     -     1  )  ]  . length (  )  )  )     -     1  ;", "return    . path ( path . substring (  0  ,    parentPathLength )  ,    parentComponents )  ;", "}", "METHOD_END"], "methodName": ["doGetParent"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    (  ( components . length )     =  =     0  )     {", "return    \"  \"  ;", "}", "return   components [  (  ( components . length )     -     1  )  ]  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "return    ( components . length )     <  =     1     ?    null    :    ModelPath . path ( components [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getRootParent"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   false ;", "}", "length    =    components . length ;", "if    (  ( other . components . length )     <  =     ( components . length )  )     {", "return   false ;", "}", "for    (    i    =     0  ;    i    <    length ;    i +  +  )     {", "if    (  !  ( components [ i ]  . equals ( other . components [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isDescendant"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( other    =  =    null )     {", "return   false ;", "}", "if    (  ( other . components . length )     !  =     (  ( components . length )     +     1  )  )     {", "return   false ;", "}", "otherParent    =    other . getParent (  )  ;", "return    ( otherParent    !  =    null )     &  &     ( otherParent . equals ( this )  )  ;", "}", "METHOD_END"], "methodName": ["isDirectChild"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "throw   new   IllegalArgumentException (  \" path   cannot   be   null \"  )  ;", "} else    {", "return    . validatedPath ( path )  ;", "}", "}", "METHOD_END"], "methodName": ["nonNullValidatedPath"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "String [  ]    components    =    Iterables . toArray ( names ,    String . class )  ;", "String   path    =     . pathString ( components )  ;", "return    . path ( path ,    components )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "return   ModelPath . BY _ PATH . get ( path )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "for    ( String   name    :    names )     {", "if    (  ( name . indexOf (  '  .  '  )  )     >  =     0  )     {", "return   new    ( path ,    names )  ;", "}", "}", "return    . BY _ PATH . get ( path ,    names )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    (  ( names . length )     =  =     0  )     {", "return    \"  \"  ;", "}", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    (    i    =     0  ,    len    =    names . length ;    i    <    len ;    i +  +  )     {", "if    ( i    !  =     0  )     {", "builder . append (  \"  .  \"  )  ;", "}", "builder . append ( names [ i ]  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["pathString"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "List < String >    components    =    Lists . newArrayListWithCapacity ( path . length (  )  )  ;", "StringTokenizer   tokenizer    =    new   StringTokenizer ( path ,     \"  .  \"  )  ;", "while    ( tokenizer . hasMoreTokens (  )  )     {", "String   component    =    tokenizer . nextToken (  )  ;", "if    ( component . isEmpty (  )  )     {", "continue ;", "}", "components . add ( component )  ;", "}", "return   components . toArray ( new   String [ components . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["splitPath"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( name . isEmpty (  )  )     {", "throw   new    . InvalidNameException (  \" Cannot   use   an   empty   string   as   a   model   element   name .  \"  )  ;", "}", "char   firstChar    =    name . charAt (  0  )  ;", "if    (  . INVALID _ FIRST _ CHAR _ MATCHER . matches ( firstChar )  )     {", "throw   new    . InvalidNameException ( String . format (  \" Model   element   name    '  % s '    has   illegal   first   character    '  % s '     ( names   must   start   with   an   ASCII   letter   or   underscore )  .  \"  ,    name ,    firstChar )  )  ;", "}", "for    ( int   i    =     1  ;    i    <     ( name . length (  )  )  ;     +  + i )     {", "char   character    =    name . charAt ( i )  ;", "if    (  . INVALID _ CHAR _ MATCHER . matches ( character )  )     {", "throw   new    . InvalidNameException ( String . format (  \" Model   element   name    '  % s '    contains   illegal   character    '  % s '     ( only   ASCII   letters ,    numbers   and   the   underscore   are   allowed )  .  \"  ,    name ,    character )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateName"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( path . isEmpty (  )  )     {", "throw   new    . InvalidPathException (  \" Cannot   use   an   empty   string   as   a   model   path .  \"  ,    null )  ;", "}", "if    ( path . startsWith (  . SEPARATOR )  )     {", "throw   new    . InvalidPathException ( String . format (  \" Model   path    '  % s '    cannot   start   with   name   separator    '  % s '  .  \"  ,    path ,     . SEPARATOR )  ,    null )  ;", "}", "if    ( path . endsWith (  . SEPARATOR )  )     {", "throw   new    . InvalidPathException ( String . format (  \" Model   path    '  % s '    cannot   end   with   name   separator    '  % s '  .  \"  ,    path ,     . SEPARATOR )  ,    null )  ;", "}", "String [  ]    names    =     . splitPath ( path )  ;", "if    (  ( names . length )     =  =     1  )     {", ". validateName ( names [  0  ]  )  ;", "} else    {", "for    ( String   name    :    names )     {", "try    {", ". validateName ( name )  ;", "}    catch    (  . InvalidNameException   e )     {", "throw   new    . InvalidPathException ( String . format (  \" Model   path    '  % s '    is   invalid   due   to   invalid   name   component .  \"  ,    path )  ,    e )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validatePath"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "} else    {", ". validatePath ( path )  ;", "return    . path ( path )  ;", "}", "}", "METHOD_END"], "methodName": ["validatedPath"], "fileName": "org.gradle.model.internal.core.ModelPath"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getAncestor"], "fileName": "org.gradle.model.internal.core.ModelPredicate"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.model.internal.core.ModelPredicate"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.model.internal.core.ModelPredicate"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . ANY ;", "}", "METHOD_END"], "methodName": ["any"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "if    ( state . equals ( this . state )  )     {", "return   this ;", "}", "return   Cast . uncheckedCast ( new    < T >  ( path ,    type ,    scope ,    state ,    description )  )  ;", "}", "METHOD_END"], "methodName": ["atState"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   state ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "if    ( scope . equals ( this . scope )  )     {", "return   this ;", "}", "return   Cast . uncheckedCast ( new    < T >  ( path ,    type ,    scope ,    state ,    description )  )  ;", "}", "METHOD_END"], "methodName": ["inScope"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   type . equals ( ModelType . UNTYPED )  ;", "}", "METHOD_END"], "methodName": ["isUntyped"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of (  (  ( ModelPath )     ( null )  )  ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( ModelPath . path ( path )  ,    ModelType . UNTYPED )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( ModelPath . path ( path )  ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of (  ( path    =  =    null    ?    null    :    ModelPath . path ( path )  )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( ModelPath . path ( path )  ,    type ,    description )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( path ,    ModelType . UNTYPED )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( path ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( new   ModelReference < T >  ( path ,    type ,    null ,    null ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( new   ModelReference < T >  ( path ,    type ,    null ,    null ,    description )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( new   ModelReference < T >  ( path ,    type ,    null ,    state ,    null )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of (  (  ( ModelPath )     ( null )  )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . untyped ( path ,    null )  ;", "}", "METHOD_END"], "methodName": ["untyped"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelReference . of ( path ,    ModelType . UNTYPED ,    description )  ;", "}", "METHOD_END"], "methodName": ["untyped"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( new   ModelReference < T >  ( path ,    type ,    scope ,    state ,    description )  )  ;", "}", "METHOD_END"], "methodName": ["withPath"], "fileName": "org.gradle.model.internal.core.ModelReference"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . unmanagedInstance ( modelReference ,    Factories . constant ( instance )  ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["bridgedInstance"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelRegistrations . Builder ( path )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelRegistrations . Builder ( path ,    initializer )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . bridgedInstance ( modelReference ,    instance )  . hidden ( true )  ;", "}", "METHOD_END"], "methodName": ["serviceInstance"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . unmanagedInstance ( modelReference ,    factory ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["unmanagedInstance"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . unmanagedInstanceOf ( modelReference ,    new   Transformer < T ,    MutableModelNode >  (  )     {", "@ Override", "public   T   transform ( MutableModelNode   modelNode )     {", "T   t    =    factory . create (  )  ;", "initializer . execute ( modelNode )  ;", "return   t ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["unmanagedInstance"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . of ( modelReference . getPath (  )  )  . action ( ModelActionRole . Create ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode )     {", "T   t    =    factory . transform ( modelNode )  ;", "modelNode . setPrivateData ( modelReference . getType (  )  ,    t )  ;", "}", "}  )  . withProjection ( UnmanagedModelProjection . of ( modelReference . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["unmanagedInstanceOf"], "fileName": "org.gradle.model.internal.core.ModelRegistrations"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \" Exception   thrown   while   executing   model   rule :     \"  )  ;", "descriptor . describeTo ( builder )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.model.internal.core.ModelRuleExecutionException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \" error   executing   model   rule :     \"  )  ;", "descriptor . describeTo ( builder )  ;", "builder . append (  \"     -     \"  )  ;", "builder . append ( error )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.model.internal.core.ModelRuleExecutionException"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.gradle.model.internal.core.ModelSpec"}, {"methodBody": ["METHOD_START", "{", "s . append ( String . format (  \" A   valid   managed   collection   takes   the   form   of   ModelSet < T >    or   ModelMap < T >    where    ' T '    is :  % n                         -     % s \"  ,    ModelTypeInitializationException . MANAGED _ TYPE _ DESCRIPTION )  )  ;", "ModelTypeInitializationException . maybeAppendConstructibles ( s ,    constructibleTypes ,     ( pad    +     1  )  )  ;", "return   s . toString (  )  ;", "}", "METHOD_END"], "methodName": ["appendManagedCollections"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "return   Joiner . on (  \"  ,     \"  )  . join ( ImmutableSet . copyOf ( Iterables . transform ( types ,    new   com . google . common . base . Function < ModelType <  ?  >  ,    String >  (  )     {", "@ Override", "public   String   apply ( ModelType <  ?  >    input )     {", "return   input . getDisplayName (  )  ;", "}", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["describe"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" A   valid   scalar   collection   takes   the   form   of   List < T >    or   Set < T >    where    ' T '    is   one   of    (  % s )  \"  ,    ModelTypeInitializationException . describe ( scalarTypes )  )  ;", "}", "METHOD_END"], "methodName": ["explainScalarCollections"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    concreteClass    =    type . getConcreteClass (  )  ;", "return    ( concreteClass . equals ( Map . class )  )     |  |     ( concreteClass . equals ( Set . class )  )  ;", "}", "METHOD_END"], "methodName": ["isManagedCollection"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    concreteClass    =    propertyType . getConcreteClass (  )  ;", "return    (  ( concreteClass . equals ( List . class )  )     |  |     ( concreteClass . equals ( Set . class )  )  )     &  &     (  ! declaredAsHavingUnmanagedType )  ;", "}", "METHOD_END"], "methodName": ["isScalarCollection"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Iterables . isEmpty ( constructibleTypes )  )  )     {", "String   padding    =     . pad ( pad )  ;", "s . append ( String . format (  \"  % n % s -    or   a   type   which   Gradle   is   capable   of   constructing :  \"  ,    padding )  )  ;", "for    ( ModelType <  ?  >    modelType    :    constructibleTypes )     {", "s . append ( String . format (  \"  % n             % s -     % s \"  ,    padding ,    modelType . getName (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["maybeAppendConstructibles"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "return   Strings . padStart (  \"  \"  ,     ( padding    *     4  )  ,     '     '  )  ;", "}", "METHOD_END"], "methodName": ["pad"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "Optional <  ?    extends   NodeInitializerContext . PropertyContext >    propertyContextOptional    =    context . getPropertyContextOptional (  )  ;", "StringBuilder   s    =    new   StringBuilder (  )  ;", "if    ( propertyContextOptional . isPresent (  )  )     {", "NodeInitializerContext . PropertyContext   propertyContext    =    propertyContextOptional . get (  )  ;", "s . append ( String . format (  \" A   model   element   of   type :     '  % s '    can   not   be   constructed .  % n \"  ,    propertyContext . getDeclaringType (  )  . getName (  )  )  )  ;", "String   propertyName    =    propertyContext . getName (  )  ;", "ModelType <  ?  >    propertyType    =    propertyContext . getType (  )  ;", "if    (  . isManagedCollection ( propertyType )  )     {", "s . append ( String . format (  \" Its   property    '  % s    % s '    is   not   a   valid   managed   collection % n \"  ,    propertyType . getName (  )  ,    propertyName )  )  ;", "CollectionSchema <  ?  ,     ?  >    schema    =     (  ( CollectionSchema )     ( schemaStore . getSchema ( propertyType )  )  )  ;", "s . append ( String . format (  \" A   managed   collection   can   not   contain    '  % s ' s % n \"  ,    schema . getElementType (  )  )  )  ;", ". appendManagedCollections ( s ,     1  ,    constructibleTypes )  ;", "} else", "if    (  . isScalarCollection ( propertyType ,    propertyContext . isDeclaredAsHavingUnmanagedType (  )  )  )     {", "ModelType <  ?  >    innerType    =    propertyType . getTypeVariables (  )  . get (  0  )  ;", "s . append ( String . format (  \" Its   property    '  % s    % s '    is   not   a   valid   scalar   collection % n \"  ,    propertyType . getName (  )  ,    propertyName )  )  ;", "s . append ( String . format (  \" A   scalar   collection   can   not   contain    '  % s ' s % n \"  ,    innerType )  )  ;", "s . append (  . explainScalarCollections ( scalarTypes )  )  ;", "} else    {", "s . append ( String . format (  \" Its   property    '  % s    % s '    can   not   be   constructed % n \"  ,    propertyType . getName (  )  ,    propertyName )  )  ;", "s . append ( String . format (  \" It   must   be   one   of :  % n \"  )  )  ;", "s . append ( String . format (  \"              -     % s % n \"  ,     . MANAGED _ TYPE _ DESCRIPTION )  )  ;", "s . append (  \"              -    A   managed   collection .     \"  )  ;", ". appendManagedCollections ( s ,     1  ,    constructibleTypes )  ;", "s . append ( String . format (  \"  % n             -    A   scalar   collection .     % s % n             -     % s \"  ,     . explainScalarCollections ( scalarTypes )  ,     . UNMANAGED _ PROPERTY _ DESCRIPTION )  )  ;", ". maybeAppendConstructibles ( s ,    constructibleTypes ,     1  )  ;", "}", "} else    {", "s . append ( String . format (  \" A   model   element   of   type :     '  % s '    can   not   be   constructed .  % n \"  ,    context . getModelType (  )  . getName (  )  )  )  ;", "s . append ( String . format (  \" It   must   be   one   of :  % n \"  )  )  ;", "s . append ( String . format (  \"              -     % s \"  ,     . MANAGED _ TYPE _ DESCRIPTION )  )  ;", ". maybeAppendConstructibles ( s ,    constructibleTypes ,     1  )  ;", "}", "return   s . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.model.internal.core.ModelTypeInitializationException"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < Map < K ,    V >  >  (  )     {  }  . where ( new   ModelType . Parameter < K >  (  )     {  }  ,    k )  . where ( new   ModelType . Parameter < V >  (  )     {  }  ,    v )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildMap"], "fileName": "org.gradle.model.internal.core.ModelTypeJavaTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( new   ModelType < Map < String ,    Integer >  >  (  )     {  }  ,    ModelTypeJavaTest . buildMap ( ModelType . of ( String . class )  ,    ModelType . of ( Integer . class )  )  )  ;", "assertEquals ( new   ModelType < Map < String ,    Integer >  >  (  )     {  }  . hashCode (  )  ,    ModelTypeJavaTest . buildMap ( ModelType . of ( String . class )  ,    ModelType . of ( Integer . class )  )  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBuildType"], "fileName": "org.gradle.model.internal.core.ModelTypeJavaTest"}, {"methodBody": ["METHOD_START", "{", "ModelType <  ?  >    type    =    new   ModelType < ModelTypeJavaTest . Nested <  ?    super   Long >  . Child <  ?    extends   Runnable >  >  (  )     {  }  ;", "assertEquals ( type . getDisplayName (  )  ,     \" ModelTypeJavaTest . Nested <  ?    super   Long >  . Child <  ?    extends   Runnable >  \"  )  ;", "assertEquals ( type . toString (  )  ,     \"  . Nested <  ?    super   Long >  . Child <  ?    extends   Runnable >  \"  )  ;", "ModelType <  ?  >    listType    =    new   ModelType < List <  ?    extends   ModelTypeJavaTest . Nested < Number >  . Child <  ?    extends   Runnable >  >  >  (  )     {  }  ;", "assertEquals ( listType . getDisplayName (  )  ,     \" List <  ?    extends   ModelTypeJavaTest . Nested < Number >  . Child <  ?    extends   Runnable >  >  \"  )  ;", "assertEquals ( listType . toString (  )  ,     \" List <  ?    extends    . Nested < Number >  . Child <  ?    extends   Runnable >  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedParameterizedType"], "fileName": "org.gradle.model.internal.core.ModelTypeJavaTest"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . assertType ( untypedView ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["assertType"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . assertType ( untypedView ,    reference . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertType"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "if    ( type . isAssignableFrom ( untypedView . getType (  )  )  )     {", "@ SuppressWarnings (  \" unchecked \"  )", "< T >    view    =     (  (  < T >  )     ( untypedView )  )  ;", "return   view ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  \" Model   view   of   type    \"     +     ( untypedView . getType (  )  )  )     +     \"    requested   as    \"  )     +    type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertType"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . getInstance ( views . get ( index )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . getInstance ( views . get ( index )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . assertType ( untypedView ,    ModelType . of ( type )  )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . assertType ( untypedView ,    reference . getType (  )  )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   ModelViews . assertType ( untypedView ,    type )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.model.internal.core.ModelViews"}, {"methodBody": ["METHOD_START", "{", "return   new   NamedEntityInstantiator < S >  (  )     {", "@ Override", "public    < D   extends   S >    D   create ( String   name ,    Class < D >    type )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   create   an   item   of   type    % s   as   this   is   not   a   subtype   of    % s .  \"  ,    type . getName (  )  ,    baseClass . getName (  )  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["nonSubtype"], "fileName": "org.gradle.model.internal.core.NamedEntityInstantiators"}, {"methodBody": ["METHOD_START", "{", "return   new   NoInputsModelAction < T >  ( reference ,    descriptor ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.NoInputsModelAction"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Finalize ,    ModelType . of ( type )  ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["afterEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Finalize ,    elementType ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["afterEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Initialize ,    elementType ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Defaults ,    ModelType . of ( type )  ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["beforeEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Defaults ,    elementType ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["beforeEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "doCreate ( name ,    ModelType . of ( type )  ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "doCreate ( name ,    elementType ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "return   new   ChildNodeInitializerStrategy < T >  (  )     {", "@ Override", "public    < S   extends   T >    NodeInitializer   initializer ( final   ModelType < S >    type ,    Spec < ModelType <  ?  >  >    constraints )     {", "return   new   NodeInitializer (  )     {", "@ Override", "public   Multimap < ModelActionRole ,    ModelAction >    getActions ( ModelReference <  ?  >    subject ,    ModelRuleDescriptor   descriptor )     {", "return   ImmutableSetMultimap .  < ModelActionRole ,    ModelAction > builder (  )  . put ( ModelActionRole . Discover ,    AddProjectionsAction . of ( subject ,    descriptor ,    UnmanagedModelProjection . of ( type )  ,    new   ModelElementProjection ( type )  )  )  . put ( ModelActionRole . Create ,    DirectNodeNoInputsModelAction . of ( subject ,    descriptor ,    new   api . Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode )     {", "NamedEntityInstantiator < T >    instantiator    =    instantiatorTransform . transform ( modelNode . getParent (  )  )  ;", "S   item    =    instantiator . create ( modelNode . getPath (  )  . getName (  )  ,    type . getConcreteClass (  )  )  ;", "modelNode . setPrivateData ( type ,    item )  ;", "}", "}  )  )  . build (  )  ;", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createUsingParentNode"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "return   NodeBackedModelMap . createUsingParentNode ( new   Transformer < NamedEntityInstantiator < T >  ,    MutableModelNode >  (  )     {", "@ Override", "public   NamedEntityInstantiator < T >    transform ( MutableModelNode   modelNode )     {", "return   modelNode . getPrivateData ( NodeBackedModelMap . instantiatorTypeOf ( baseItemModelType )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createUsingParentNode"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "return   new   ChildNodeInitializerStrategy < T >  (  )     {", "@ Override", "public    < S   extends   T >    NodeInitializer   initializer ( Type < S >    type ,    Spec < Type <  ?  >  >    constraints )     {", "return   nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forExtensibleType ( type ,    constraints )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createUsingRegistry"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "ModelPath   childPath    =    modelNode . getPath (  )  . child ( name )  ;", "ModelRuleDescriptor   descriptor    =    sourceDescriptor . append (  \" create (  % s )  \"  ,    name )  ;", "if    ( initAction    !  =    null )     {", "doCreate ( childPath ,    type ,    descriptor ,    NoInputsModelAction . of ( ModelReference . of ( childPath ,    type )  ,    descriptor ,    initAction )  )  ;", "} else    {", "doCreate ( childPath ,    type ,    descriptor ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "ModelPath   childPath    =    modelNode . getPath (  )  . child ( name )  ;", "doCreate ( childPath ,    type ,    action . getDescriptor (  )  ,    DirectNodeNoInputsModelAction . of ( ModelReference . of ( childPath ,    type )  ,    action . getDescriptor (  )  ,    new   api . Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   node )     {", "action . execute ( node ,    ModelActionRole . Initialize )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "viewState . assertCanMutate (  )  ;", "elementFilter . validateCanCreateElement ( childPath ,    type )  ;", "NodeInitializer   nodeInitializer    =    creatorStrategy . initializer ( type ,    elementFilter )  ;", "Registrations . Builder   builder    =    Registrations . of ( childPath ,    nodeInitializer )  . descriptor ( descriptor )  ;", "if    ( initAction    !  =    null )     {", "builder . action ( ActionRole . Initialize ,    initAction )  ;", "}", "Registration   registration    =    builder . build (  )  ;", "modelNode . addLink ( registration )  ;", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < NamedEntityInstantiator < I >  >  (  )     {  }  . where ( new   ModelType . Parameter < I >  (  )     {  }  ,    type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["instantiatorTypeOf"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "viewState . assertCanMutate (  )  ;", "RuleDescriptor   descriptor    =    sourceDescriptor . append ( operation )  ;", "Reference < E >    subject    =    Reference . of ( filterType )  ;", "modelNode . applyTo ( NodePredicate . allLinks ( elementFilter . withType ( filterType )  )  ,    role ,    NoInputsAction . of ( subject ,    descriptor ,    configAction )  )  ;", "}", "METHOD_END"], "methodName": ["mutateChildren"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "viewState . assertCanMutate (  )  ;", "ModelReference < E >    subject    =    ModelReference . of ( filterType )  ;", "modelNode . defineRulesFor ( NodePredicate . allLinks ( elementFilter . withType ( filterType )  )  ,    role ,    new    . DeferredActionWrapper < E >  ( subject ,    role ,    configAction )  )  ;", "}", "METHOD_END"], "methodName": ["mutateChildren"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "viewState . assertCanMutate (  )  ;", "ModelReference < T >    subject    =    ModelReference . of ( modelNode . getPath (  )  . child ( name )  ,    elementType )  ;", "modelNode . applyToLink ( ModelActionRole . Initialize ,    new    . FilteringActionWrapper < T >  ( elementFilter ,    subject ,    new    . DeferredActionWrapper < T >  ( subject ,    ModelActionRole . Mutate ,    action )  )  )  ;", "}", "METHOD_END"], "methodName": ["named"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "mutateChildren ( ModelActionRole . Mutate ,    ModelType . of ( type )  ,    configAction )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "if    ( type . equals ( elementType )  )     {", "return    . uncheckedCast ( this )  ;", "}", "ChildNodeInitializerStrategy < S >    creatorStrategy 1     =     . uncheckedCast ( this . creatorStrategy )  ;", "return   new    < S >  ( publicType ,    type ,    sourceDescriptor ,    modelNode ,    viewState ,    elementFilter ,    creatorStrategy 1  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.NodeBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "afterEach ( ClosureBackedAction . of ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["afterEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelSet"}, {"methodBody": ["METHOD_START", "{", "beforeEach ( ClosureBackedAction . of ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["beforeEach"], "fileName": "org.gradle.model.internal.core.NodeBackedModelSet"}, {"methodBody": ["METHOD_START", "{", "create ( ClosureBackedAction . of ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.core.NodeBackedModelSet"}, {"methodBody": ["METHOD_START", "{", "state . assertCanReadChildren (  )  ;", "if    (  ( elements )     =  =    null )     {", "elements    =    Lists . newArrayList ( Iterables . transform ( Node . getLinks ( ModelNodes . withType ( elementType )  )  ,    new   com . google . common . base . Function < MutableModelNode ,    T >  (  )     {", "@ Override", "public   T   apply ( MutableModelNode   input )     {", "return   input . asImmutable ( elementType ,    descriptor )  . getInstance (  )  ;", "}", "}  )  )  ;", "}", "return   elements ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "org.gradle.model.internal.core.NodeBackedModelSet"}, {"methodBody": ["METHOD_START", "{", "return   new   NodeInitializerContext < T >  ( type ,    constraints ,    Optional .  < NodeInitializerContext . PropertyContext > absent (  )  )  ;", "}", "METHOD_END"], "methodName": ["forExtensibleType"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   new   NodeInitializerContext < T >  ( type ,    Specs .  < ModelType <  ?  >  > satisfyAll (  )  ,    Optional . of ( new   NodeInitializerContext . PropertyContext ( property . getName (  )  ,    property . getType (  )  ,    property . isWritable (  )  ,    property . isDeclaredAsHavingUnmanagedType (  )  ,    containingType )  )  )  ;", "}", "METHOD_END"], "methodName": ["forProperty"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   new   NodeInitializerContext < T >  ( type ,    Specs .  < ModelType <  ?  >  > satisfyAll (  )  ,    Optional .  < NodeInitializerContext . PropertyContext > absent (  )  )  ;", "}", "METHOD_END"], "methodName": ["forType"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   constraints ;", "}", "METHOD_END"], "methodName": ["getConstraints"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   modelType ;", "}", "METHOD_END"], "methodName": ["getModelType"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   propertyContextOptional ;", "}", "METHOD_END"], "methodName": ["getPropertyContextOptional"], "fileName": "org.gradle.model.internal.core.NodeInitializerContext"}, {"methodBody": ["METHOD_START", "{", "return   NodePredicate . allDescendants ( Predicates .  < MutableModelNode > alwaysTrue (  )  )  ;", "}", "METHOD_END"], "methodName": ["allDescendants"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   NodePredicate ( predicate )     {", "@ Override", "protected   ModelSpec   scope ( ModelPath   scope ,    Predicate <  ?    super   MutableModelNode >    matcher )     {", "return   new   NodePredicate . BasicPredicate ( null ,    null ,    scope ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["allDescendants"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "return   NodePredicate . allLinks ( Predicates .  < MutableModelNode > alwaysTrue (  )  )  ;", "}", "METHOD_END"], "methodName": ["allLinks"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "return   new   NodePredicate ( predicate )     {", "@ Override", "protected   ModelSpec   scope ( ModelPath   scope ,    Predicate <  ?    super   MutableModelNode >    matcher )     {", "return   new   NodePredicate . BasicPredicate ( null ,    scope ,    null ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["allLinks"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "return   scope ( scope ,    matcher )  ;", "}", "METHOD_END"], "methodName": ["scope"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "return   withType ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "final   Predicate < MutableModelNode >    matcher    =    ModelNodes . withType ( type ,    this . matcher )  ;", "final      parent    =    this ;", "return   new    ( matcher )     {", "@ Override", "protected   ModelSpec   scope ( ModelPath   scope ,    Predicate <  ?    super   MutableModelNode >    matcher )     {", "return   parent . scope ( scope ,    matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.model.internal.core.NodePredicate"}, {"methodBody": ["METHOD_START", "{", "ChildNodeInitializerStrategy <  ?    super   E >    creatorStrategy    =    creatorStrategyAccessor . getStrategy ( modelNode )  ;", "DefaultModelViewState   state    =    new   DefaultModelViewState ( modelNode . getPath (  )  ,    publicType ,    ruleDescriptor ,    mutable ,     (  ! mutable )  )  ;", "P   instance    =    DirectInstantiator . instantiate ( viewImpl ,    publicType ,    elementType ,    ruleDescriptor ,    modelNode ,    state ,    creatorStrategy )  ;", "return   InstanceModelView . of ( modelNode . getPath (  )  ,    publicType ,    instance ,    state . closer (  )  )  ;", "}", "METHOD_END"], "methodName": ["toView"], "fileName": "org.gradle.model.internal.core.SpecializedModelMapProjection"}, {"methodBody": ["METHOD_START", "{", "return    ( targetType . isAssignableFrom ( type )  )     |  |     (  ( targetType    =  =     ( ModelType . UNTYPED )  )     &  &     ( PrimitiveTypes . isPrimitiveType ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["canBeAssignedTo"], "fileName": "org.gradle.model.internal.core.TypeCompatibilityModelProjectionSupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type . getRawClass (  )  . getSuperclass (  )  )     =  =    null )     &  &     (  ( type . getRawClass (  )  . getInterfaces (  )  . length )     =  =     0  )  )     {", "return   type . toString (  )  ;", "}", "return    ( type . toString (  )  )     +     \"     ( or   assignment   cle   type   thereof )  \"  ;", "}", "METHOD_END"], "methodName": ["description"], "fileName": "org.gradle.model.internal.core.TypeCompatibilityModelProjectionSupport"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.core.TypeCompatibilityModelProjectionSupport"}, {"methodBody": ["METHOD_START", "{", "String   valueDescription    =    instance . toString (  )  ;", "if    ( valueDescription    !  =    null )     {", "return   valueDescription ;", "}", "return   new   StringBuilder ( type . toString (  )  )  . append (  \"  # toString (  )    returned   null \"  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toStringValueDescription"], "fileName": "org.gradle.model.internal.core.TypeCompatibilityModelProjectionSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   TypedModelProjection < M >  ( type ,    viewFactory )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.TypedModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   UnmanagedModelProjection . of ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.UnmanagedModelProjection"}, {"methodBody": ["METHOD_START", "{", "return   new   UnmanagedModelProjection < M >  ( type )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.UnmanagedModelProjection"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( getClassName (  )  )     +     \"  #  \"  )     +     ( method . getName (  )  )  )     +     \"  (  \"  )     +     ( MethodModelRuleDescriptor . toParameterList ( method . getGenericParameterTypes (  )  )  )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["createDescription"], "fileName": "org.gradle.model.internal.core.rule.describe.MethodModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   method . getDeclaringType (  )  . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.model.internal.core.rule.describe.MethodModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( description )     =  =    null )     {", "description    =    creation (  )  ;", "}", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.model.internal.core.rule.describe.MethodModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   MethodModelRuleDescriptor . DESCRIPTOR _ CACHE . get ( method )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.core.rule.describe.MethodModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   MethodModelRuleDescriptor . PARAM _ JOINER . join ( Iterables . transform ( genericParameterTypes ,    MethodModelRuleDescriptor . TYPE _ DISPLAYNAME _ FUNCTION )  )  ;", "}", "METHOD_END"], "methodName": ["toParameterList"], "fileName": "org.gradle.model.internal.core.rule.describe.MethodModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   factory . create (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.model.internal.core.rule.describe.SimpleModelRuleDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   action ( ModelType . of ( inputType )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( ModelPath . path ( modelPath )  ,    ModelType . of ( inputType )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( ModelPath . path ( modelPath )  ,    inputType ,    referenceDescription ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( modelPath ,    inputType ,    modelPath ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( ModelActionBuilder . NO _ REFS ,    new   TriAction < MutableModelNode ,    T ,    List < ModelView <  ?  >  >  >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode ,    T   t ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( t )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( modelPath ,    ModelType . of ( inputType )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( ModelReference . of ( modelPath ,    inputType ,    referenceDescription )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ( modelPath ,    inputType ,    inputType . toString (  )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   build ( Collections .  < ModelReference <  ?  >  > singletonList ( inputReference )  ,    new   TriAction < MutableModelNode ,    T ,    List < ModelView <  ?  >  >  >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode ,    T   t ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( t ,    ModelViews . assertType ( inputs . get (  0  )  ,    inputReference . getType (  )  )  . getInstance (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action (  (  ( ModelPath )     ( null )  )  ,    inputType ,    action )  ;", "}", "METHOD_END"], "methodName": ["action"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ModelActionBuilder . toAction ( references ,    action ,    path ,    type ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelActionBuilder < N >  ( path ,    type ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ( new   SimpleModelRuleDescriptor ( descriptor )  )  ;", "}", "METHOD_END"], "methodName": ["descriptor"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . descriptor    =    descriptor ;", "ren   this ;", "}", "METHOD_END"], "methodName": ["descriptor"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ModelActionBuilder . toAction ( action ,    path ,    type ,    descriptor )  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelActionBuilder < Object >  ( null ,    ModelType . UNTYPED ,    new   SimpleModelRuleDescriptor (  \" testrule \"  )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   this . path ( ModelPath . path ( path )  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "ren   this ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   path    !  =    null    ?    ModelReference . of ( path ,    type )     :    ModelReference . of ( type )  . inScope ( ModelPath . ROOT )  ;", "}", "METHOD_END"], "methodName": ["subject"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   DirectNodeInputUsingModelAction . of ( ModelActionBuilder . subject ( path ,    type )  ,    descriptor ,    references ,    new   TriAction < MutableModelNode ,    T ,    List < ModelView <  ?  >  >  >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    T   t ,    List < ModelView <  ?  >  >    inputs )     {", "action . execute ( modelNode ,    t ,    inputs )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["toAction"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   DirectNodeNoInputsModelAction . of ( ModelActionBuilder . subject ( path ,    type )  ,    descriptor ,    action )  ;", "}", "METHOD_END"], "methodName": ["toAction"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   type ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   copy ( type )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.model.internal.fixture.ModelActionBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < RuleAwarePolymorphicNamedEntityInstantiator < T >  >  (  )     {  }  . where ( new   ModelType . Parameter < T >  (  )     {  }  ,    ModelType . of ( typeClass )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["instantiatorType"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelper"}, {"methodBody": ["METHOD_START", "{", "ModelRegistryHelperExtension . addLink ( node ,    ModelPath . path ( path )  ,    definition )  ;", "}", "METHOD_END"], "methodName": ["addLink"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . addLink ( definition . transform ( ModelRegistryHelperExtension . registration ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["addLink"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "ModelRegistryHelperExtension . addLinkInstance ( node ,    ModelPath . path ( path )  ,    instance )  ;", "}", "METHOD_END"], "methodName": ["addLinkInstance"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . addLink ( ModelRegistryHelperExtension . unmanaged ( ModelRegistryHelperExtension . registration ( path )  ,    instance )  )  ;", "}", "METHOD_END"], "methodName": ["addLinkInstance"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . addReference ( name ,    ModelType . of ( type )  ,    target ,    new   SimpleModelRuleDescriptor (  \"  < test >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addReference"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . mutate ( modelRegistry ,    path ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode )     {", "mutableModelNode . applyToSelf ( rules )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . applyInternal ( modelRegistry ,    role ,    ModelType . of ( type )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["applyInternal"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . configure ( modelRegistry ,    role ,    ModelReference . of ( type )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["applyInternal"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . applyTo ( predicate ,    role ,    definition . transform ( ModelActionBuilder . of (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["applyTo"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . applyToLink ( role ,    action . transform ( ModelActionBuilder . of (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["applyToLink"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "node . applyToSelf ( role ,    action . transform ( ModelActionBuilder . of (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["applyToSelf"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   builder . withProjection ( UnmanagedModelProjection . of ( type )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["asUnmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MutableModelNode )     ( modelRegistry . atState ( ModelPath . path ( path )  ,    state )  )  )  ;", "}", "METHOD_END"], "methodName": ["atState"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return    (  ( MutableModelNode )     ( modelRegistry . atStateOrLater ( ModelPath . path ( path )  ,    state )  )  )  ;", "}", "METHOD_END"], "methodName": ["atStateOrLater"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . configure ( role ,    definition . transform ( ModelActionBuilder . of (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . configure ( modelRegistry ,    role ,    new   Transformer < ModelAction ,    ModelActionBuilder < Object >  >  (  )     {", "@ Override", "public   ModelAction   transform ( ModelActionBuilder < Object >    objectModelActionBuilder )     {", "return   objectModelActionBuilder . path ( reference . getPath (  )  )  . type ( reference . getType (  )  )  . action ( action )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . get ( modelRegistry ,    path ,    Object . class )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . realize ( ModelPath . nonNullValidatedPath ( path )  ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . get ( modelRegistry ,    path . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "final   ModelType < RuleAwarePolymorphicNamedEntityInstantiator < I >  >    instantiatorType    =    ModelRegistryHelper . instantiatorType ( itemType )  ;", "ModelType < I >    modelType    =    ModelType . of ( itemType )  ;", "return   builder . action ( ModelActionRole . Create ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode )     {", "RuleAwarePolymorphicNamedEntityInstantiator < I >    instantiator    =    new   DefaultRuleAwarePolymorphicNamedEntityInstantiator < I >  ( new   DefaultPolymorphicNamedEntityInstantiator < I >  ( itemType ,     \" this   collection \"  )  )  ;", "mutableModelNode . setPrivateData ( instantiatorType ,    instantiator )  ;", "}", "}  )  . withProjection ( ModelMapModelProjection . unmanaged ( modelType ,    ChildNodeInitializerStrategyAccessors . of ( NodeBackedModelMap . createUsingParentNode ( modelType )  )  )  )  . withProjection ( UnmanagedModelProjection . of ( instantiatorType )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["modelMap"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . applyInternal ( modelRegistry ,    ModelActionRole . Mutate ,    type ,    action )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . configure ( modelRegistry ,    ModelActionRole . Mutate ,    new   Transformer < ModelAction ,    ModelActionBuilder < Object >  >  (  )     {", "@ Override", "public   ModelAction   transform ( ModelActionBuilder < Object >    objectModelActionBuilder )     {", "return   objectModelActionBuilder . path ( path )  . node ( action )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . configure ( modelRegistry ,    ModelActionRole . Mutate ,    definition )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . configure ( modelRegistry ,    ModelActionRole . Mutate ,    reference ,    action )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . applyInternal ( modelRegistry ,    ModelActionRole . Mutate ,    type ,    action )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . mutate ( modelRegistry ,    new   Transformer < ModelAction ,    ModelActionBuilder < Object >  >  (  )     {", "@ Override", "public   ModelAction   transform ( ModelActionBuilder < Object >    builder )     {", "return   builder . path ( path )  . type ( ModelTypes . modelMap ( itemType )  )  . action ( action )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["mutateModelMap"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . node ( ModelPath . path ( path )  )  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . realize ( ModelPath . nonNullValidatedPath ( path )  ,    ModelType . UNTYPED )  ;", "}", "METHOD_END"], "methodName": ["realize"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . realize ( ModelPath . nonNullValidatedPath ( path )  ,    ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["realize"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . register ( modelRegistry ,    ModelPath . path ( path )  ,    definition )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . register ( definition . transform ( ModelRegistryHelperExtension . registration ( path )  )  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . register ( ModelRegistryHelperExtension . unmanaged ( ModelRegistryHelperExtension . registration ( ModelPath . path ( path )  )  ,    c )  )  ;", "}", "METHOD_END"], "methodName": ["registerInstance"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . register ( ModelRegistryHelperExtension . unmanaged ( ModelRegistryHelperExtension . registration ( ModelPath . path ( path )  )  ,    c ,    action )  )  ;", "}", "METHOD_END"], "methodName": ["registerInstance"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "ModelRegistryHelperExtension . configure ( modelRegistry ,    ModelActionRole . Initialize ,    ModelReference . of ( path ,    ModelRegistryHelper . instantiatorType ( itemType )  )  ,    new   Action < RuleAwarePolymorphicNamedEntityInstantiator < I >  >  (  )     {", "@ Override", "public   void   execute ( final   RuleAwarePolymorphicNamedEntityInstantiator < I >    instantiator )     {", "registrations . execute ( new   PolymorphicNamedEntityInstantiator < I >  (  )     {", "@ Override", "public   Set <  ?    extends   Class <  ?    extends   I >  >    getCreatableTypes (  )     {", "return   instantiator . getCreatableTypes (  )  ;", "}", "@ Override", "public    < U   extends   I >    void   registerFactory ( Class < U >    type ,    NamedDomainObjectFactory <  ?    extends   U >    factory )     {", "instantiator . registerFactory ( type ,    factory ,    new   SimpleModelRuleDescriptor (  \" ModelRegistryHelper . modelMap \"  )  )  ;", "}", "@ Override", "public    < S   extends   I >    S   create ( String   name ,    Class < S >    type )     {", "return   instantiator . create ( name ,    type )  ;", "}", "}  )  ;", "}", "}  )  ;", "return   ModelRegistryHelperExtension . register ( modelRegistry ,    path ,    new   Transformer < ModelRegistration ,    ModelRegistrations . Builder >  (  )     {", "@ Override", "public   ModelRegistration   transform ( ModelRegistrations . Builder   modelRegistrationBuilder )     {", "return   ModelRegistryHelperExtension . modelMap ( modelRegistrationBuilder ,    itemType )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerModelMap"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "NodeInitializerContext < C >    nodeInitializerContext    =    NodeInitializerContext . forType ( ModelType . of ( type )  )  ;", "ation   registration    =    ations . of ( ModelPath . path ( path )  ,    nodeInitializerRegistry . getNodeInitializer ( nodeInitializerContext )  )  . descriptor (  (  \" create    \"     +    path )  )  . build (  )  ;", "modelRegistry . register ( registration )  ;", "return   modelRegistry ;", "}", "METHOD_END"], "methodName": ["registerWithInitializer"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . of ( path )  . descriptor (  ( path    +     \"    creator \"  )  )  ;", "}", "METHOD_END"], "methodName": ["registration"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   modelRegistry . state ( ModelPath . path ( path )  )  ;", "}", "METHOD_END"], "methodName": ["state"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    c ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    ModelType . typeOf ( c )  . getConcreteClass (  )  ,    new   Factory < C >  (  )     {", "@ Override", "public   C   create (  )     {", "action . execute ( c )  ;", "return   c ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    ModelType . of ( type )  ,    Factories . constant ( c )  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    ModelType . of ( type )  ,    ModelType . of ( inputType )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    ModelType . of ( modelType )  ,    inputPath ,    referenceDescription ,    action )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    modelType ,    inputPath ,    inputPath ,    action )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    ModelType . of ( type )  ,    initializer )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   builder . action ( ModelActionRole . Create ,    ModelReference . of ( inputPath ,    ModelType . UNTYPED ,    inputDescriptor )  ,    new   BiAction < MutableModelNode ,    Object >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode ,    Object   input )     {", "mutableModelNode . setPrivateData ( modelType ,    action . transform ( input )  )  ;", "}", "}  )  . withProjection ( new   UnmanagedModelProjection < C >  ( modelType )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanaged ( builder ,    modelType ,    inputPath ,    inputPath ,    action )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   builder . action ( ModelActionRole . Create ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode )     {", "mutableModelNode . setPrivateData ( modelType ,    initializer . create (  )  )  ;", "}", "}  )  . withProjection ( UnmanagedModelProjection . of ( modelType )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   builder . action ( ModelActionRole . Create ,    ModelReference . of ( inputModelType )  ,    new   BiAction < MutableModelNode ,    I >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode ,    I   input )     {", "mutableModelNode . setPrivateData ( modelType ,    action . transform ( input )  )  ;", "}", "}  )  . withProjection ( new   UnmanagedModelProjection < C >  ( modelType )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["unmanaged"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistryHelperExtension . unmanagedNode ( builder ,    ModelType . of ( modelType )  ,    action )  ;", "}", "METHOD_END"], "methodName": ["unmanagedNode"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   builder . action ( ModelActionRole . Create ,    action )  . withProjection ( new   UnmanagedModelProjection < C >  ( modelType )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["unmanagedNode"], "fileName": "org.gradle.model.internal.fixture.ModelRegistryHelperExtension"}, {"methodBody": ["METHOD_START", "{", "return   annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.model.internal.inspect.AbstractAnnotationDrivenModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "return   ruleDefinition . getReturnType (  )  . equals ( AbstractAnnotationDrivenModelRuleExtractor . VOID )  ;", "}", "METHOD_END"], "methodName": ["isVoidMethod"], "fileName": "org.gradle.model.internal.inspect.AbstractAnnotationDrivenModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isVoidMethod ( ruleDefinition )  )  )     {", "problems . add ( ruleDefinition ,     (  (  \" A   method    \"     +     ( getDescription (  )  )  )     +     \"    must   have   void   return   type .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateIsVoidMethod"], "fileName": "org.gradle.model.internal.inspect.AbstractAnnotationDrivenModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "return   String . valueOf ( number )  ;", "}", "METHOD_END"], "methodName": ["thing"], "fileName": "org.gradle.model.internal.inspect.AbstractJavaPropertyRules"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.model.internal.inspect.AbstractMethodRuleAction"}, {"methodBody": ["METHOD_START", "{", "String   annotationValue    =    ruleDefinition . getAnnotation ( Model . class )  . value (  )  ;", "String   modelName    =     (  ( annotationValue    =  =    null )     |  |     ( annotationValue . isEmpty (  )  )  )     ?    ruleDefinition . getMethodName (  )     :    annotationValue ;", "try    {", "ModelPath . validatePath ( modelName )  ;", "}    catch    ( Exception   e )     {", "problems . add ( ruleDefinition ,     (  (  \" The   declared   model   element   path    '  \"     +    modelName )     +     \"  '    is   not   a   valid   path \"  )  ,    e )  ;", "}", "return   ModelPath . path ( modelName )  ;", "}", "METHOD_END"], "methodName": ["determineModelName"], "fileName": "org.gradle.model.internal.inspect.AbstractModelCreationRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "return   DefaultMethodRuleDefinition . innerCreate ( source ,    method )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.internal.inspect.DefaultMethodRuleDefinition"}, {"methodBody": ["METHOD_START", "{", "ModelType < R >    returnType    =    ModelType . returnType ( method )  ;", "return   new    < T ,    R ,    S >  ( method ,    ModelType . of ( source )  ,    returnType )  ;", "}", "METHOD_END"], "methodName": ["innerCreate"], "fileName": "org.gradle.model.internal.inspect.DefaultMethodRuleDefinition"}, {"methodBody": ["METHOD_START", "{", "Path   pathAnnotation    =     (  ( Path )     ( DefaultMethodRuleDefinition . findFirst ( annotations ,    new   Spec < Annotation >  (  )     {", "public   boolean   isSatisfiedBy ( Annotation   element )     {", "return   element . annotationType (  )  . equals ( Path . class )  ;", "}", "}  )  )  )  ;", "ModelPath   path    =     ( pathAnnotation    =  =    null )     ?    null    :    ModelPath . path ( pathAnnotation . value (  )  )  ;", "ModelType <  ?  >    cast    =    method . getGenericParameterTypes (  )  . get ( i )  ;", "return   ModelReference . of ( path ,    cast ,    DefaultMethodRuleDefinition . PARAMETER _ DESC [ i ]  )  ;", "}", "METHOD_END"], "methodName": ["reference"], "fileName": "org.gradle.model.internal.inspect.DefaultMethodRuleDefinition"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   errorString    =    new   StringBuilder ( String . format (  \" Type    % s   is   not   a   valid    % s :  \"  ,    source . getName (  )  ,    role )  )  ;", "if    (  (  ( ps . size (  )  )     =  =     1  )     &  &     (  (  ( errorString . length (  )  )     +     ( ps . get (  0  )  . length (  )  )  )     <     8  0  )  )     {", "errorString . append (  '     '  )  ;", "errorString . append ( ps . get (  0  )  )  ;", "} else    {", "for    ( String   p    :    ps )     {", "errorString . append ( String . format (  \"  \\ n -     % s \"  ,    p )  )  ;", "}", "}", "return   errorString . toString (  )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.model.internal.inspect.FormattingValidationProblemCollector"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   schemaStore . getSchema ( managedType )  ;", "}    catch    ( InvalidElementTypeException   e )     {", "throw   new   InvalidModelRuleDeclarationException ( ruleDefinition . getDescriptor (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getModelSchema"], "fileName": "org.gradle.model.internal.inspect.ManagedModelCreationRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forType ( modelSchema . getType (  )  )  )  ;", "}    catch    ( ModelTypeInitializationException   e )     {", "throw   new   InvaliRuleDeclarationException ( descriptor ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getNodeInitializer"], "fileName": "org.gradle.model.internal.inspect.ManagedModelCreationRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList .  < MethodModelRuleExtractor > of ( new   UnmanagedModelCreationRuleExtractor (  )  ,    new   ManagedModelCreationRuleExtractor ( modelSchemaStore )  ,    new   DefaultsModelRuleExtractor (  )  ,    new   MutateModelRuleExtractor (  )  ,    new   FinalizeModelRuleExtractor (  )  ,    new   ValidateModelRuleExtractor (  )  ,    new   RuleDefinitionRuleExtractor (  )  )  ;", "}", "METHOD_END"], "methodName": ["coreExtractors"], "fileName": "org.gradle.model.internal.inspect.MethodModelRuleExtractors"}, {"methodBody": ["METHOD_START", "{", "String   desc    =    Joiner . on (  \"  ,     \"  )  . join ( CollectionUtils . collect ( handlers ,    new   Transformer < String ,    MethodModelRuleExtractor >  (  )     {", "public   String   transform ( MethodModelRuleExtractor   original )     {", "return   original . getDescription (  )  ;", "}", "}  )  )  ;", "return    (  \"  [  \"     +    desc )     +     \"  ]  \"  ;", "}", "METHOD_END"], "methodName": ["describeHandlers"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "final   ModelType < T >    type    =    ModelType . of ( source )  ;", "FormattingValidationProblemCollector   problems    =    new   FormattingValidationProblemCollector (  \" rule   source \"  ,    type )  ;", "DefaultMethodModelRuleExtractionContext   context    =    new   DefaultMethodModelRuleExtractionContext ( this ,    problems )  ;", "StructSchema < T >    schema    =    getSchema ( source ,    context )  ;", "if    ( schema    =  =    null )     {", "throw   new   InvalidModelRuleDeclarationException ( problems . format (  )  )  ;", "}", "Set < Method >    methods    =    new   TreeSet < Method >  ( Ordering . usingToString (  )  )  ;", "methods . addAll ( Arrays . asList ( source . getDeclaredMethods (  )  )  )  ;", "ImmutableList . Builder < ModelProperty <  ?  >  >    implicitInputs    =    ImmutableList . builder (  )  ;", "ModelProperty <  ?  >    target    =    null ;", "for    ( ModelProperty <  ?  >    property    :    schema . getProperties (  )  )     {", "if    ( property . isAnnotationPresent ( RuleTarget . class )  )     {", "target    =    property ;", "} else", "if    (  ( property . isAnnotationPresent ( class )  )     &  &     (  !  (  ( property . getSchema (  )  )    instanceof   manage . schema . ScalarValueSchema )  )  )     {", "implicitInputs . add ( property )  ;", "}", "for    ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    method    :    property . getAccessors (  )  )     {", "methods . remove ( method . getMethod (  )  )  ;", "}", "}", "ImmutableList . Builder < ModelRuleExtractor . ExtractedRuleDetails >    rules    =    ImmutableList . builder (  )  ;", "for    ( Method   method    :    methods )     {", "MethodRuleDefinition <  ?  ,     ?  >    ruleDefinition    =    DefaultMethodRuleDefinition . create ( source ,    method )  ;", "ExtractedModelRule   rule    =    getMethodHandler ( ruleDefinition ,    method ,    context )  ;", "if    ( rule    !  =    null )     {", "rules . add ( new   ModelRuleExtractor . ExtractedRuleDetails ( ruleDefinition ,    rule )  )  ;", "}", "}", "if    ( context . hasProblems (  )  )     {", "throw   new   InvalidModelRuleDeclarationException ( problems . format (  )  )  ;", "}", "StructBindings < T >    bindings    =    structBindingsStore . getBindings ( schema . getType (  )  )  ;", "if    ( schema . getProperties (  )  . isEmpty (  )  )     {", "return   new   ModelRuleExtractor . StatelessRuleSource ( rules . build (  )  ,     ( Modifier . isAbstract ( source . getModifiers (  )  )     ?    new   ModelRuleExtractor . AbstractRuleSourceFactory < T >  ( schema ,    bindings ,    proxyFactory )     :    new   ModelRuleExtractor . ConcreteRuleSourceFactory < T >  ( type )  )  )  ;", "} else    {", "return   new   ModelRuleExtractor . ParameterizedRuleSource ( rules . build (  )  ,    target ,    implicitInputs . build (  )  ,    schema ,    bindings ,    proxyFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["doExtract"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   cache . get ( source )  . newInstance ( source )  ;", "}    catch    ( ExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    catch    ( UncheckedExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "MethodModelRuleExtractor   handler    =    null ;", "for    ( MethodModelRuleExtractor   candidateHandler    :    handlers )     {", "if    ( candidateHandler . isSatisfiedBy ( ruleDefinition )  )     {", "if    ( handler    =  =    null )     {", "handler    =    candidateHandler ;", "} else    {", "context . add ( method ,     (  \" Can   only   be   one   of    \"     +     ( describeHandlers (  )  )  )  )  ;", "validateRuleMethod ( ruleDefinition ,    method ,    context )  ;", "return   null ;", "}", "}", "}", "if    ( handler    !  =    null )     {", "validateRuleMethod ( ruleDefinition ,    method ,    context )  ;", "return   handler . registration ( ruleDefinition ,    context )  ;", "} else    {", "validateNonRuleMethod ( method ,    context )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getMethodHandler"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( RuleSource . class . isAssignableFrom ( source )  )  )     |  |     (  !  ( source . getSuperclass (  )  . equals ( RuleSource . class )  )  )  )     {", "problems . add (  (  \" Rule   source   classes   must   directly   extend    \"     +     ( RuleSource . class . getName (  )  )  )  )  ;", "}", "Schema < T >    schema    =    schemaStore . getSchema ( source )  ;", "if    (  !  ( schema   instanceof   StructSchema )  )     {", "return   null ;", "}", "validateClass ( source ,    problems )  ;", "return    (  ( StructSchema < T >  )     ( schema )  )  ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "int   modifiers    =    source . getModifiers (  )  ;", "if    ( Modifier . isInterface ( modifiers )  )     {", "problems . add (  \" Must   be   a   class ,    not   an   face \"  )  ;", "}", "if    (  ( source . getEnclosingClass (  )  )     !  =    null )     {", "if    ( Modifier . isStatic ( modifiers )  )     {", "if    ( Modifier . isPrivate ( modifiers )  )     {", "problems . add (  \" Class   cannot   be   private \"  )  ;", "}", "} else    {", "problems . add (  \" Enclosed   classes   must   be   static   and   non   private \"  )  ;", "}", "}", "Constructor <  ?  >  [  ]    constructors    =    source . getDeclaredConstructors (  )  ;", "for    ( Constructor <  ?  >    constructor    :    constructors )     {", "if    (  ( constructor . getParameterTypes (  )  . length )     >     0  )     {", "problems . add (  \" Cannot   declare   a   constructor   that   takes   arguments \"  )  ;", "break ;", "}", "}", "Field [  ]    fields    =    source . getDeclaredFields (  )  ;", "for    ( Field   field    :    fields )     {", "int   fieldModifiers    =    field . getModifiers (  )  ;", "if    (  (  !  ( field . isSynthetic (  )  )  )     &  &     (  !  (  ( Modifier . isStatic ( fieldModifiers )  )     &  &     ( Modifier . isFinal ( fieldModifiers )  )  )  )  )     {", "problems . add ( field ,     \" Fields   must   be   static   final .  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateClass"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  !  ( Modifier . isPrivate ( method . getModifiers (  )  )  )  )     &  &     (  !  ( Modifier . isStatic ( method . getModifiers (  )  )  )  )  )     &  &     (  !  ( method . isSynthetic (  )  )  )  )     &  &     (  !  ( GroovyMethods . isObjectMethod ( method )  )  )  )     {", "problems . add ( method ,     \" A   method   that   is   not   annotated   as   a   rule   must   be   private \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateNonRuleMethod"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    ( Modifier . isPrivate ( ruleMethod . getModifiers (  )  )  )     {", "problems . add ( ruleMethod ,     \" A   rule   method   cannot   be   private \"  )  ;", "}", "if    ( Modifier . isAbstract ( ruleMethod . getModifiers (  )  )  )     {", "problems . add ( ruleMethod ,     \" A   rule   method   cannot   be   abstract \"  )  ;", "}", "if    (  ( ruleMethod . getTypeParameters (  )  . length )     >     0  )     {", "problems . add ( ruleMethod ,     \" Cannot   have   type   variables    ( i . e .    cannot   be   a   generic   method )  \"  )  ;", "}", "ModelType <  ?  >    returnType    =    ModelType . returnType ( ruleMethod )  ;", "if    ( returnType . isRawClassOfParameterizedType (  )  )     {", "problems . add ( ruleMethod ,     (  (  \" Raw   type    \"     +    returnType )     +     \"    used   for   return   type    ( all   type   parameters   must   be   specified   of   parameterized   type )  \"  )  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( ruleDefinition . getReferences (  )  . size (  )  )  ;    i +  +  )     {", "eference <  ?  >    reference    =    ruleDefinition . getReferences (  )  . get ( i )  ;", "if    ( reference . getType (  )  . isRawClassOfParameterizedType (  )  )     {", "problems . add ( ruleMethod ,     (  (  (  (  \" Raw   type    \"     +     ( reference . getType (  )  )  )     +     \"    used   for   parameter    \"  )     +     ( i    +     1  )  )     +     \"     ( all   type   parameters   must   be   specified   of   parameterized   type )  \"  )  )  ;", "}", "if    (  ( reference . getPath (  )  )     !  =    null )     {", "try    {", "ModelPath . validatePath ( reference . getPath (  )  . getPath (  )  )  ;", "}    catch    ( Exception   e )     {", "problems . add ( ruleDefinition ,     (  (  (  (  \" The   declared   model   element   path    '  \"     +     ( reference . getPath (  )  . getPath (  )  )  )     +     \"  '    used   for   parameter    \"  )     +     ( i    +     1  )  )     +     \"    is   not   a   valid   path \"  )  ,    e )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validateRuleMethod"], "fileName": "org.gradle.model.internal.inspect.ModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   FluentIterable . from ( cache . get ( container )  )  . transform ( new   com . google . common . base . Function < Reference < Class <  ?    extends    >  >  ,    Class <  ?    extends    >  >  (  )     {", "@ Override", "public   Class <  ?    extends    >    apply ( Reference < Class <  ?    extends    >  >    input )     {", "return   input . get (  )  ;", "}", "}  )  . filter ( Predicates . notNull (  )  )  ;", "}    catch    ( ExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredSources"], "fileName": "org.gradle.model.internal.inspect.ModelRuleSourceDetector"}, {"methodBody": ["METHOD_START", "{", "return    !  ( Iterables . isEmpty ( getDeclaredSources ( container )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasRules"], "fileName": "org.gradle.model.internal.inspect.ModelRuleSourceDetector"}, {"methodBody": ["METHOD_START", "{", "return   RuleSource . class . isAssignableFrom ( clazz )  ;", "}", "METHOD_END"], "methodName": ["isRuleSource"], "fileName": "org.gradle.model.internal.inspect.ModelRuleSourceDetector"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Invalid   managed   model   type    '  % s '  :    read   only   property    '  % s '    has   non   managed   type    % s ,    only   managed   types   can   be   used \"  ,    managedModelType ,    name ,    propertyType )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.model.internal.inspect.ReadonlyImmutableManagedPropertyException"}, {"methodBody": ["METHOD_START", "{", "List < List < Annotation >  >    parameterAnnotations    =    ruleDefinition . getParameterAnnotations (  )  ;", "if    ( subjectParamIndex    >  =     ( parameterAnnotations . size (  )  )  )     {", "throw   new   IndexOutOfBoundsException (  (  (  \" Rule   definition   should   have   at   least    \"     +     ( subjectParamIndex    +     1  )  )     +     \"    parameters \"  )  )  ;", "}", "result    =    null ;", "for    ( int   paramIndex    =     0  ;    paramIndex    <     ( parameterAnnotations . size (  )  )  ;    paramIndex +  +  )     {", "List < Annotation >    annotations    =    parameterAnnotations . get ( paramIndex )  ;", "boolean   annotatedWithEach    =     . hasAnnotation ( annotations ,    Each . class )  ;", "if    ( paramIndex    =  =    subjectParamIndex )     {", "if    ( annotatedWithEach    &  &     (  . hasAnnotation ( annotations ,    Path . class )  )  )     {", "problems . add ( ruleDefinition ,     \" Rule   subject   must   not   be   annotated   with   both    @ Path   and    @ Each .  \"  )  ;", "}", "result    =     ( annotatedWithEach )     ?     . DESCENDANTS    :     . SELF ;", "} else", "if    ( annotatedWithEach )     {", "problems . add ( ruleDefinition ,    String . format (  \" Rule   parameter    #  % d   should   not   be   annotated   with    @ Each .  \"  ,     ( paramIndex    +     1  )  )  )  ;", "}", "}", "assert   result    !  =    null ;", "return   result ;", "}", "METHOD_END"], "methodName": ["fromRuleDefinition"], "fileName": "org.gradle.model.internal.inspect.RuleApplicationScope"}, {"methodBody": ["METHOD_START", "{", "for    ( Annotation   annotation    :    annotations )     {", "if    ( annotationType . isInstance ( annotation )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasAnnotation"], "fileName": "org.gradle.model.internal.inspect.RuleApplicationScope"}, {"methodBody": ["METHOD_START", "{", "ModelAction   action    =    context . contextualize ( ruleAction )  ;", "ModelRegistry   registry    =    context . getRegistry (  )  ;", "switch    ( ruleApplicationScope )     {", "case   SELF    :", "registry . configure ( role ,    action )  ;", "break ;", "case   DESCENDANTS    :", "registry . configureMatching ( new    . NonReferenceDescendantsSpec ( context . getScope (  )  )  ,    role ,    action )  ;", "break ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureRuleAction"], "fileName": "org.gradle.model.internal.inspect.RuleExtractorUtils"}, {"methodBody": ["METHOD_START", "{", "ModelRegistration   registration    =    builder . descriptor ( modelNode . getDescriptor (  )  )  . hidden ( internal )  . build (  )  ;", "modelNode . addLink ( registration )  ;", "}", "METHOD_END"], "methodName": ["addLink"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "modelNode . addProjection ( new   ManagedModelProjection < V >  ( viewSchema ,    bindings ,    proxyFactory ,    typeConverter )  )  ;", "}", "METHOD_END"], "methodName": ["addProjection"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "ModelType < P >    propertyType    =    property . getType (  )  ;", "ModelSchema < P >    propertySchema    =    schemaStore . getSchema ( propertyType )  ;", "ModelType < T >    publicType    =    bindings . getPublicSchema (  )  . getType (  )  ;", "validateProperty ( propertySchema ,    property ,    nodeInitializerRegistry )  ;", "ModelPath   childPath    =    modelNode . getPath (  )  . child ( property . getName (  )  )  ;", "if    ( propertySchema   instanceof   ManagedImplSchema )     {", "if    (  (  !  ( property . isWritable (  )  )  )     |  |     ( propertySchema   instanceof   ScalarCollectionSchema )  )     {", "ModelRegistrations . Builder   builder    =     . managedRegistrationBuilder ( childPath ,    property ,    nodeInitializerRegistry ,    publicType )  ;", "addLink ( modelNode ,    builder ,    property . isInternal (  )  )  ;", "} else    {", "modelNode . addReference ( property . getName (  )  ,    propertyType ,    null ,    modelNode . getDescriptor (  )  )  ;", "}", "} else    {", "ModelRegistrations . Builder   registrationBuilder ;", "if    ( shouldHaveANodeInitializer ( property ,    propertySchema )  )     {", "registrationBuilder    =     . managedRegistrationBuilder ( childPath ,    property ,    nodeInitializerRegistry ,    publicType )  ;", "} else    {", "registrationBuilder    =    ModelRegistrations . of ( childPath )  ;", "}", "registrationBuilder . withProjection ( new   UnmanagedModelProjection < P >  ( propertyType )  )  ;", "registrationBuilder . withProjection ( new   ModelElementProjection ( propertyType )  )  ;", "addLink ( modelNode ,    registrationBuilder ,    property . isInternal (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addPropertyLink"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "for    ( ManagedProperty <  ?  >    property    :    bindings . getManagedProperties (  )  . values (  )  )     {", "addPropertyLink ( modelNode ,    property ,    schemaStore ,    nRegistry )  ;", "}", "if    ( isNamedType (  )  )     {", "if    ( bindings . getManagedProperties (  )  . containsKey (  \" name \"  )  )     {", "MutableModelNode   nameLink    =    modelNode . getLink (  \" name \"  )  ;", "if    ( nameLink    =  =    null )     {", "throw   new   IllegalStateException (  (  \" expected   name   node   for    \"     +     ( modelNode . getPath (  )  )  )  )  ;", "}", "nameLink . setPrivateData ( ModelType . of ( String . class )  ,    modelNode . getPath (  )  . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addPropertyLinks"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return    ( propertySchema   instanceof   CollectionSchema )     &  &     (  !  ( propertySchema   instanceof   ScalarCollectionSchema )  )  ;", "}", "METHOD_END"], "methodName": ["isCollectionOfManagedTypes"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return    ( isNamedType (  )  )     &  &     (  \" name \"  . equals ( property . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isNamePropertyOfANamedType"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return   Named . class . isAssignableFrom ( bindings . getPublicSchema (  )  . getType (  )  . getRawClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["isNamedType"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return   ModelRegistrations . of ( childPath ,    nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forProperty ( property . getType (  )  ,    property ,    publicType )  )  )  ;", "}", "METHOD_END"], "methodName": ["managedRegistrationBuilder"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( propertySchema   instanceof   ScalarValueSchema )  )     &  &     (  !  ( property . isDeclaredAsHavingUnmanagedType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldHaveANodeInitializer"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "if    ( propertySchema   instanceof   ManagedImplSchema )     {", "if    (  !  ( property . isWritable (  )  )  )     {", "if    ( isCollectionOfManagedTypes ( propertySchema )  )     {", "CollectionSchema < P ,     ?  >    propertyCollectionsSchema    =     (  ( CollectionSchema < P ,     ?  >  )     ( propertySchema )  )  ;", "ModelType <  ?  >    elementType    =    propertyCollectionsSchema . getElementType (  )  ;", "nodeInitializerRegistry . ensureHasInitializer ( Context . forProperty ( elementType ,    property ,    bindings . getPublicSchema (  )  . getType (  )  )  )  ;", "}", "if    ( property . isDeclaredAsHavingUnmanagedType (  )  )     {", "throw   new   UnmanagedPropertyMissingSetterException ( property . getName (  )  )  ;", "}", "}", "} else", "if    (  (  (  !  ( shouldHaveA ( property ,    propertySchema )  )  )     &  &     (  !  ( property . isWritable (  )  )  )  )     &  &     (  !  ( isNamePropertyOfANamedType ( property )  )  )  )     {", "throw   new   ReadonlyImmutableManagedPropertyException ( bindings . getPublicSchema (  )  . getType (  )  ,    property . getName (  )  ,    property . getType (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateProperty"], "fileName": "org.gradle.model.internal.inspect.StructNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" unmanaged   property    '  % s '    cannot   be   read   only ,    unmanaged   properties   must   have   setters \"  ,    propertyName )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.model.internal.inspect.UnmanagedPropertyMissingSetterException"}, {"methodBody": ["METHOD_START", "{", "return   delegateSchema    =  =    null    ?    Collections .  < Wrapper < Method >  ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  > emptyMap (  )     :    DefaultStructBindingsStore . indexBySignature ( delegateSchema . getAllMethods (  )  )  ;", "}", "METHOD_END"], "methodName": ["collectDelegateMethods"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Map < Wrapper < Method >  ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    implementedMethodsBuilder    =    Maps . newLinkedHashMap (  )  ;", "for    ( Schema <  ?  >    implementedSchema    :    implementedSchemas )     {", "for    ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    viewMethod    :    implementedSchema . getAllMethods (  )  )     {", "implementedMethodsBuilder . put ( DESCRIPTOR _ EQUIVALENCE . wrap ( viewMethod . getMethod (  )  )  ,    viewMethod )  ;", "}", "}", "return   implementedMethodsBuilder . values (  )  ;", "}", "METHOD_END"], "methodName": ["collectImplementedMethods"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "final   Set < ModelType <  ?  >  >    viewsToImplement    =    Sets . newLinkedHashSet (  )  ;", "viewsToImplement . add ( publicType )  ;", "Iterables . addAll ( viewsToImplement ,    internalViewTypes )  ;", "if    ( delegateType    !  =    null )     {", "walkTypeHierarchy ( delegateType . getConcreteClass (  )  ,    new   internal . reflect . Types . TypeVisitor < D >  (  )     {", "@ Override", "public   void   visitType ( Class <  ?    super   D >    type )     {", "if    ( type . isInterface (  )  )     {", "viewsToImplement . add ( ModelType . of ( type )  )  ;", "}", "}", "}  )  ;", "}", "return   ModelTypes . collectHierarchy ( viewsToImplement )  ;", "}", "METHOD_END"], "methodName": ["collectImplementedViews"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    ManagedProperty <  ?  >  >    managedPropertiesBuilder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( Map . Entry < String ,    Multimap < PropertyAccessorType ,    StructMethodBinding >  >    propertyEntry    :    propertyBindings . entrySet (  )  )     {", "String   propertyName    =    propertyEntry . getKey (  )  ;", "Multimap < PropertyAccessorType ,    StructMethodBinding >    accessorBindings    =    propertyEntry . getValue (  )  ;", "if    (  . isManagedProperty ( extractionContext ,    propertyName ,    accessorBindings )  )     {", "if    (  ( hasSetter ( accessorBindings . keySet (  )  )  )     &  &     (  !  ( hasGetter ( accessorBindings . keySet (  )  )  )  )  )     {", "extractionContext . add ( propertyName ,     \" it   must   both   have   an   abstract   getter   and   a   setter \"  )  ;", "continue ;", "}", "ModelType <  ?  >    propertyType    =     . determineManagedPropertyType ( extractionContext ,    propertyName ,    accessorBindings )  ;", "ModelSchema <  ?  >    propertySchema    =    schemaStore . getSchema ( propertyType )  ;", "managedPropertiesBuilder . put ( propertyName ,     . createManagedProperty ( extractionContext ,    propertyName ,    propertySchema ,    accessorBindings )  )  ;", "}", "}", "return   managedPropertiesBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectManagedProperties"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Collection < WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    implementedMethods    =    DefaultStructBindingsStore . collectImplementedMethods ( extractionContext . getImplementedSchemas (  )  )  ;", "Map < Wrapper < Method >  ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    publicViewImplMethods    =    DefaultStructBindingsStore . collectPublicViewImplMethods ( extractionContext . getPublicSchema (  )  )  ;", "Map < Wrapper < Method >  ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    delegateMethods    =    DefaultStructBindingsStore . collectDelegateMethods ( extractionContext . getDelegateSchema (  )  )  ;", "ImmutableSet . Builder < StructMethodBinding >    methodBindingsBuilder    =    ImmutableSet . builder (  )  ;", "for    ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakImplementedMethod    :    implementedMethods )     {", "Method   implementedMethod    =    weakImplementedMethod . getMethod (  )  ;", "PropertyAccessorType   accessorType    =    PropertyAccessorType . of ( implementedMethod )  ;", "Wrapper < Method >    methodKey    =    SIGNATURE _ EQUIVALENCE . wrap ( implementedMethod )  ;", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakDelegateImplMethod    =    delegateMethods . get ( methodKey )  ;", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakPublicImplMethod    =    publicViewImplMethods . get ( methodKey )  ;", "if    (  ( weakDelegateImplMethod    !  =    null )     &  &     ( weakPublicImplMethod    !  =    null )  )     {", "extractionContext . add ( weakImplementedMethod ,    String . format (  \" it   is   both   implemented   by   the   view    '  % s '    and   the   delegate   type    '  % s '  \"  ,    extractionContext . getPublicSchema (  )  . getType (  )  . getDisplayName (  )  ,    extractionContext . getDelegateSchema (  )  . getType (  )  . getDisplayName (  )  )  )  ;", "}", "String   propertyName    =     ( accessorType    =  =    null )     ?    null    :    accessorType . propertyNameFor ( implementedMethod )  ;", "StructMethodBinding   binding ;", "if    (  !  ( Modifier . isAbstract ( implementedMethod . getModifiers (  )  )  )  )     {", "binding    =    new   DirectMethodBinding ( weakImplementedMethod ,    accessorType )  ;", "} else", "if    ( weakPublicImplMethod    !  =    null )     {", "binding    =    new   BridgeMethodBinding ( weakImplementedMethod ,    weakPublicImplMethod ,    accessorType )  ;", "} else", "if    ( weakDelegateImplMethod    !  =    null )     {", "binding    =    new   DelegateMethodBinding ( weakImplementedMethod ,    weakDelegateImplMethod ,    accessorType )  ;", "} else", "if    ( propertyName    !  =    null )     {", "binding    =    new   ManagedPropertyMethodBinding ( weakImplementedMethod ,    propertyName ,    accessorType )  ;", "} else    {", "DefaultStructBindingsStore . handleNoMethodImplementation ( extractionContext ,    weakImplementedMethod )  ;", "continue ;", "}", "methodBindingsBuilder . add ( binding )  ;", "if    ( accessorType    !  =    null )     {", "Multimap < PropertyAccessorType ,    StructMethodBinding >    accessorBindings    =    propertyBindings . get ( propertyName )  ;", "if    ( accessorBindings    =  =    null )     {", "accessorBindings    =    ArrayListMultimap . create (  )  ;", "propertyBindings . put ( propertyName ,    accessorBindings )  ;", "}", "accessorBindings . put ( accessorType ,    binding )  ;", "}", "}", "return   methodBindingsBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectMethodBindings"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "return   DefaultStructBindingsStore . indexBySignature ( Sets . filter ( publicSchema . getAllMethods (  )  ,    new   com . google . common . base . Predicate < WeaklyTypeReferencingMethod <  ?  ,     ?  >  >  (  )     {", "@ Override", "public   boolean   apply ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakMethod )     {", "return    !  ( Modifier . isAbstract ( weakMethod . getModifiers (  )  )  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["collectPublicViewImplMethods"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "boolean   writable    =    accessors . containsKey ( SETTER )  ;", "boolean   declaredAsUnmanaged    =     (  . isDeclaredAsHavingUnmanagedType ( accessors . get ( GET _ GETTER )  )  )     |  |     (  . isDeclaredAsHavingUnmanagedType ( accessors . get ( IS _ GETTER )  )  )  ;", "boolean   internal    =     !  ( extractionContext . getPublicSchema (  )  . hasProperty ( propertyName )  )  ;", ". validateManagedProperty ( extractionContext ,    propertyName ,    propertySchema ,    writable ,    declaredAsUnmanaged )  ;", "return   new   ManagedProperty < T >  ( propertyName ,    propertySchema . getType (  )  ,    writable ,    declaredAsUnmanaged ,    internal )  ;", "}", "METHOD_END"], "methodName": ["createManagedProperty"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Set < ModelType <  ?  >  >    potentialPropertyTypes    =    Sets . newLinkedHashSet (  )  ;", "for    ( StructMethodBinding   binding    :    accessorBindings . values (  )  )     {", "if    (  ( binding . getAccessorType (  )  )     =  =     ( SETTER )  )     {", "continue ;", "}", "ManagedPropertyMethodBinding   propertyBinding    =     (  ( ManagedPropertyMethodBinding )     ( binding )  )  ;", "potentialPropertyTypes . add ( propertyBinding . getDeclaredPropertyType (  )  )  ;", "}", "Collection < ModelType <  ?  >  >    convergingPropertyTypes    =     . findConvergingTypes ( potentialPropertyTypes )  ;", "if    (  ( convergingPropertyTypes . size (  )  )     !  =     1  )     {", "extractionContext . add ( propertyName ,    String . format (  \" it   must   have   a   consistent   type ,    but   it ' s   defined   as    % s \"  ,    Joiner . on (  \"  ,     \"  )  . join ( ModelTypes . getDisplayNames ( convergingPropertyTypes )  )  )  )  ;", "return   convergingPropertyTypes . iterator (  )  . next (  )  ;", "}", "ModelType <  ?  >    propertyType    =    Iterables . getOnlyElement ( convergingPropertyTypes )  ;", "for    ( StructMethodBinding   setterBinding    :    accessorBindings . get ( SETTER )  )     {", "ManagedPropertyMethodBinding   propertySetterBinding    =     (  ( ManagedPropertyMethodBinding )     ( setterBinding )  )  ;", "ModelType <  ?  >    declaredSetterType    =    propertySetterBinding . getDeclaredPropertyType (  )  ;", "if    (  !  ( declaredSetterType . equals ( propertyType )  )  )     {", "extractionContext . add ( setterBinding . getViewMethod (  )  ,    String . format (  \" it   should   take   parameter   with   type    '  % s '  \"  ,    propertyType . getDisplayName (  )  )  )  ;", "}", "}", "return   propertyType ;", "}", "METHOD_END"], "methodName": ["determineManagedPropertyType"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( typeClass . isInterface (  )  )  )     {", "return ;", "}", "for    ( Method   declaredMethod    :    declaredMethods )     {", "if    (  (  . isDefaultInterfaceMethod ( declaredMethod )  )     &  &     (  ( PropertyAccessorType . of ( declaredMethod )  )     =  =    null )  )     {", "problems . add ( declaredMethod ,     \" Default   interface   methods   are   only   supported   for   getters   and   setters .  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ensureNoDefaultMethods"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "List < Field >    declaredFields    =    Arrays . asList ( typeClass . getDeclaredFields (  )  )  ;", "for    ( Field   field    :    declaredFields )     {", "int   fieldModifiers    =    field . getModifiers (  )  ;", "if    (  (  !  ( field . isSynthetic (  )  )  )     &  &     (  !  (  ( Modifier . isStatic ( fieldModifiers )  )     &  &     ( Modifier . isFifieldModifiers )  )  )  )  )     {", "problems . add ( field ,     \" Fields   must   be   static   fi \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ensureNoInstanceScopedFields"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   declaredMethod    :    declaredMethods )     {", "modifiers    =    declaredMethod . getModifiers (  )  ;", "if    (  (  (  !  ( declaredMethod . isSynthetic (  )  )  )     &  &     (  !  ( Modifier . isPublic ( modifiers )  )  )  )     &  &     (  !  ( Modifier . isStatic ( modifiers )  )  )  )     {", "problems . add ( declaredMethod ,     \" Protected   and   private   methods   are   not   supported .  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["ensureNoProtectedOrPrivateMethods"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( delegateType    !  =    null )     &  &     ( Modifier . isAbstract ( delegateType . getConcreteClass (  )  . getModifiers (  )  )  )  )     {", "throw   new   InvalidManagedTypeException ( String . format (  \" Type    '  % s '    is   not   a   valid   managed   type :    delegate   type   must   be   null   or   a   non - abstract   type   instead   of    '  % s '  .  \"  ,    publicType . getDisplayName (  )  ,    delegateType . getDisplayName (  )  )  )  ;", "}", "Set < ModelType <  ?  >  >    implementedViews    =     . collectImplementedViews ( publicType ,    internalViewTypes ,    delegateType )  ;", "StructSchema < T >    publicSchema    =    getStructSchema ( publicType )  ;", "Iterable < StructSchema <  ?  >  >    declaredViewSchemas    =    getStructSchemas ( Iterables . concat ( Collections . singleton ( publicType )  ,    internalViewTypes )  )  ;", "Iterable < StructSchema <  ?  >  >    implementedSchemas    =    getStructSchemas ( implementedViews )  ;", "StructSchema < D >    delegateSchema    =     ( delegateType    =  =    null )     ?    null    :    getStructSchema ( delegateType )  ;", "StructBindingExtractionContext < T >    extractionContext    =    new   StructBindingExtractionContext < T >  ( publicSchema ,    implementedSchemas ,    delegateSchema )  ;", "if    (  !  ( publicSchema   instanceof   RuleSourceSchema )  )     {", ". validateTypeHierarchy ( extractionContext ,    publicType )  ;", "for    ( ModelType <  ?  >    internalViewType    :    internalViewTypes )     {", ". validateTypeHierarchy ( extractionContext ,    internalViewType )  ;", "}", "}", "Map < String ,    Multimap < PropertyAccessorType ,    StructMethodBinding >  >    propertyBindings    =    Maps . newTreeMap (  )  ;", "Set < StructMethodBinding >    methodBindings    =     . collectMethodBindings ( extractionContext ,    propertyBindings )  ;", "ImmutableSortedMap < String ,    ManagedProperty <  ?  >  >    managedProperties    =    collectManagedProperties ( extractionContext ,    propertyBindings )  ;", "if    ( extractionContext . problems . hasProblems (  )  )     {", "throw   new   InvalidManagedTypeException ( extractionContext . problems . format (  )  )  ;", "}", "return   new   DefaultStructBindings < T >  ( publicSchema ,    declaredViewSchemas ,    implementedSchemas ,    delegateSchema ,    managedProperties ,    methodBindings )  ;", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allTypes . size (  )  )     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" No   types   given \"  )  ;", "}", "if    (  ( allTypes . size (  )  )     =  =     1  )     {", "return   allTypes ;", "}", "Set < MType <  ?  >  >    typesToCheck    =    Sets . newLinkedHashSet ( allTypes )  ;", "Set < MType <  ?  >  >    convergingTypes    =    Sets . newLinkedHashSet ( allTypes )  ;", "while    (  !  ( typesToCheck . isEmpty (  )  )  )     {", "Iterator < MType <  ?  >  >    iTypeToCheck    =    typesToCheck . iterator (  )  ;", "MType <  ?  >    typeToCheck    =    iTypeToCheck . next (  )  ;", "iTypeToCheck . remove (  )  ;", "Iterator < MType <  ?  >  >    iRemainingType    =    convergingTypes . iterator (  )  ;", "while    ( iRemainingType . hasNext (  )  )     {", "MType <  ?  >    remainingType    =    iRemainingType . next (  )  ;", "if    (  (  !  ( remainingType . equals ( typeToCheck )  )  )     &  &     ( remainingType . isAssignableFrom ( typeToCheck )  )  )     {", "iRemainingType . remove (  )  ;", "typesToCheck . remove ( remainingType )  ;", "}", "}", "}", "return   convergingTypes ;", "}", "METHOD_END"], "methodName": ["findConvergingTypes"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >  [  ]    constructors    =    typeClass . getConstructors (  )  ;", "for    ( Constructor <  ?  >    constructor    :    constructors )     {", "if    (  ( constructor . getParameterTypes (  )  . length )     >     0  )     {", "return   constructor ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findCustomConstructor"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "ModelSchema < T >    schema    =    schemaStore . getSchema ( type )  ;", "if    (  !  ( schema   instanceof   Schema )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Type    '  % s '    is   not   a   struct .  \"  ,    type . getDisplayName (  )  )  )  ;", "}", "return   Cast . uncheckedCast ( schema )  ;", "}", "METHOD_END"], "methodName": ["getStructSchema"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . transform ( types ,    new   com . google . common . base . Function < ModelType <  ?    extends   T >  ,    StructSchema <  ?    extends   T >  >  (  )     {", "@ Override", "public   StructSchema <  ?    extends   T >    apply ( ModelType <  ?    extends   T >    type )     {", "return   geSchema ( type )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getStructSchemas"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "String   methodName    =    method . getName (  )  ;", "PropertyAccessorType   accessorType    =    PropertyAccessorType . fromName ( methodName )  ;", "if    ( accessorType    !  =    null )     {", "switch    ( accessorType )     {", "case   GET _ GETTER    :", "case   IS _ GETTER    :", "if    (  !  ( PropertyAccessorType . takesNoParameter ( method . getMethod (  )  )  )  )     {", "problems . add ( method ,     \" property   accessor \"  ,     \" getter   method   must   not   take   parameters \"  )  ;", "}", "break ;", "case   SETTER    :", "if    (  !  ( hasVoidReturnType ( method . getMethod (  )  )  )  )     {", "problems . add ( method ,     \" property   accessor \"  ,     \" setter   method   must   have   void   return   type \"  )  ;", "}", "if    (  !  ( takesSingleParameter ( method . getMethod (  )  )  )  )     {", "problems . add ( method ,     \" property   accessor \"  ,     \" setter   method   must   take   exactly   one   parameter \"  )  ;", "}", "break ;", "d    :", "throw   new   AssertionError (  )  ;", "}", "} else    {", "problems . add ( method ,     \" managed   type \"  ,     \" it   must   have   an   implementation \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleNoMethodImplementation"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "return   Maps . uniqueIndex ( methods ,    new   com . google . common . base . Function < WeaklyTypeReferencingMethod <  ?  ,     ?  >  ,    Wrapper < Method >  >  (  )     {", "@ Override", "public   Wrapper < Method >    apply ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakMethod )     {", "return   SIGNATURE _ EQUIVALENCE . wrap ( weakMethod . getMethod (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["indexBySignature"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "for    ( StructMethodBinding   accessorBinding    :    accessorBindings )     {", "if    ( accessorBinding . getViewMethod (  )  . getMethod (  )  . isAnnotationPresent ( Unmanaged . class )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isDeclaredAsHavingUnmanagedType"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "return    (  ( method . getModifiers (  )  )     &     (  (  ( Modifier . ABSTRACT )     |     ( Modifier . PUBLIC )  )     |     ( Modifier . STATIC )  )  )     =  =     ( Modifier . PUBLIC )  ;", "}", "METHOD_END"], "methodName": ["isDefaultInterfaceMethod"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Boolean   managed    =    null ;", "for    ( Map . Entry < PropertyAccessorType ,    Collection < StructMethodBinding >  >    accessorEntry    :    accessorBindings . asMap (  )  . entrySet (  )  )     {", "Collection < StructMethodBinding >    bindings    =    accessorEntry . getValue (  )  ;", "boolean   managedPropertyAccessor    =     . isManagedPropertyAccessor ( extractionContext ,    propertyName ,    bindings )  ;", "if    ( managed    =  =    null )     {", "managed    =    managedPropertyAccessor ;", "} else", "if    ( managed    !  =    managedPropertyAccessor )     {", "extractionContext . add ( propertyName ,     \" it   must   have   either   only   abstract   accessor   methods   or   only   implemented   accessor   methods \"  )  ;", "managed    =    false ;", "break ;", "}", "}", "assert   managed    !  =    null ;", "return   managed ;", "}", "METHOD_END"], "methodName": ["isManagedProperty"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Set < WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    implMethods    =    Sets . newLinkedHashSet (  )  ;", "for    ( StructMethod   binding    :    bindings )     {", "if    ( binding   instanceof   StructMethodImplementation )     {", "implMethods . add (  (  ( StructMethodImplementation )     ( binding )  )  . getImplementorMethod (  )  )  ;", "}", "}", "switch    ( implMethods . size (  )  )     {", "case    0     :", "return   true ;", "case    1     :", "return   false ;", "default    :", "extractionContext . add ( propertyName ,    String . format (  \" it   has   multiple   implementations   for   accessor   method :     % s \"  ,    Joiner . on (  \"  ,     \"  )  . join ( implMethods )  )  )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isManagedPropertyAccessor"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( propertyName . equals (  \" name \"  )  )     &  &     ( Named . class . isAssignableFrom ( extractionContext . getPublicSchema (  )  . getType (  )  . getRawClass (  )  )  )  )     {", "if    ( writable )     {", "extractionContext . add ( propertyName ,    String . format (  \" it   must   not   have   a   setter ,    because   the   type   implements    '  % s '  \"  ,    Named . class . getName (  )  )  )  ;", "}", "return ;", "}", "boolean   isAllowedPropertyTypeOfManagedType    =     ( propertySchema   instanceof   ManagedImplSchema )     |  |     ( propertySchema   instanceof   ScalarValueSchema )  ;", "ModelType <  ?  >    propertyType    =    propertySchema . getType (  )  ;", "if    ( isAllowedPropertyTypeOfManagedType    &  &    isDeclaredAsHavingUndType )     {", "extractionContext . add ( propertyName ,    String . format (  \" it   is   marked   as    @ Und ,    but   is   of    @ Managed   type    '  % s '  ;    please   remove   the    @ Managed   annotation \"  ,    propertyType . getDisplayName (  )  )  )  ;", "}", "if    (  (  ! writable )     &  &    isDeclaredAsHavingUndType )     {", "extractionContext . add ( propertyName ,     \" it   must   not   be   read   only ,    because   it   is   marked   as    @ Und \"  )  ;", "}", "if    (  !  (  ( extractionContext . getPublicSchema (  )  )    instanceof   RuleSourceSchema )  )     {", "if    ( propertySchema   instanceof   CollectionSchema )     {", "if    (  (  !  ( propertySchema   instanceof   ScalarCollectionSchema )  )     &  &    writable )     {", "extractionContext . add ( propertyName ,    String . format (  \" it   cannot   have   a   setter    (  % s   properties   must   be   read   only )  \"  ,    propertyType . getRawClass (  )  . getSimpleName (  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["validateManagedProperty"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( typeClass . isInterface (  )  )  )     &  &     (  !  ( Modifier . isAbstract ( typeClass . getModifiers (  )  )  )  )  )     {", "problems . add (  \" Must   be   defined   as   an   face   or   an   abstract   class .  \"  )  ;", "}", "if    (  ( typeClass . getTypeParameters (  )  . length )     >     0  )     {", "problems . add (  \" Cannot   be   a   parameterized   type .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateManagedType"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >    customConstructor    =    DefaultStructBindingsStore . findCustomConstructor ( typeClass )  ;", "if    ( customConstructor    !  =    null )     {", "problems . add ( customConstructor ,     \" Custom   constructors   are   not   supported .  \"  )  ;", "}", "DefaultStructBindingsStore . ensureNoInstanceScopedFields ( problems ,    typeClass )  ;", "Method [  ]    methods    =    typeClass . getDeclaredMethods (  )  ;", "Arrays . sort ( methods ,    Ordering . usingToString (  )  )  ;", "DefaultStructBindingsStore . ensureNoProtectedOrPrivateMethods ( problems ,    methods )  ;", "DefaultStructBindingsStore . ensureNoDefaultMethods ( problems ,    typeClass ,    methods )  ;", "}", "METHOD_END"], "methodName": ["validateType"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "walkTypeHierarchy ( type . getConcreteClass (  )  ,    new   TypeVisitor < T >  (  )     {", "@ Override", "public   void   visitType ( Class <  ?    super   T >    type )     {", "if    ( type . isAnnotationPresent ( Managed . class )  )     {", ". validateManagedType ( problems ,    type )  ;", "}", ". validateType ( problems ,    type )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["validateTypeHierarchy"], "fileName": "org.gradle.model.internal.manage.binding.DefaultStructBindingsStore"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.manage.binding.ManagedProperty"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.manage.binding.ManagedProperty"}, {"methodBody": ["METHOD_START", "{", "return   declaredAsHavingUnmanagedType ;", "}", "METHOD_END"], "methodName": ["isDeclaredAsHavingUnmanagedType"], "fileName": "org.gradle.model.internal.manage.binding.ManagedProperty"}, {"methodBody": ["METHOD_START", "{", "return   internal ;", "}", "METHOD_END"], "methodName": ["isInternal"], "fileName": "org.gradle.model.internal.manage.binding.ManagedProperty"}, {"methodBody": ["METHOD_START", "{", "return   writable ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.gradle.model.internal.manage.binding.ManagedProperty"}, {"methodBody": ["METHOD_START", "{", "PropertyAccessorType   accessorType    =    getAccessorType (  )  ;", "assert   accessorType    !  =    null ;", "return   ModelType . of ( accessorType . propertyTypeFor ( getViewMethod (  )  . getMethod (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredPropertyType"], "fileName": "org.gradle.model.internal.manage.binding.ManagedPropertyMethodBinding"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.gradle.model.internal.manage.binding.ManagedPropertyMethodBinding"}, {"methodBody": ["METHOD_START", "{", "return   delegateSchema ;", "}", "METHOD_END"], "methodName": ["getDelegateSchema"], "fileName": "org.gradle.model.internal.manage.binding.StructBindingExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   implementedSchemas ;", "}", "METHOD_END"], "methodName": ["getImplementedSchemas"], "fileName": "org.gradle.model.internal.manage.binding.StructBindingExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   publicSchema ;", "}", "METHOD_END"], "methodName": ["getPublicSchema"], "fileName": "org.gradle.model.internal.manage.binding.StructBindingExtractionContext"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?    extends   T >    generatedClass    =    Cast . uncheckedCast ( generatedImplementationTypes . get ( new    . CacheKey ( GeneratedViewState . class ,    viewSchema ,    bindings )  )  )  ;", "Constructor <  ?    extends   T >    constructor    =    generatedClass . getConstructor ( GeneratedViewState . class ,    TypeConverter . class )  ;", "return   constructor . newInstance ( state ,    null )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getTargetException (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "org.gradle.model.internal.manage.instance.ManagedProxyFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?    extends   T >    generatedClass    =    Cast . uncheckedCast ( generatedImplementationTypes . get ( new    . CacheKey ( ModelElementState . class ,    viewSchema ,    bindings )  )  )  ;", "StructSchema <  ?  >    delegateSchema    =    bindings . getDelegateSchema (  )  ;", "if    ( delegateSchema    =  =    null )     {", "Constructor <  ?    extends   T >    constructor    =    generatedClass . getConstructor ( ModelElementState . class ,    TypeConverter . class )  ;", "return   constructor . newInstance ( state ,    typeConverter )  ;", "} else    {", "ModelType <  ?  >    delegateType    =    delegateSchema . getType (  )  ;", "Object   delegate    =    state . getBackingNode (  )  . getPrivateData ( delegateType )  ;", "Constructor <  ?    extends   T >    constructor    =    generatedClass . getConstructor ( ModelElementState . class ,    TypeConverter . class ,    delegateType . getConcreteClass (  )  )  ;", "return   constructor . newInstance ( state ,    typeConverter ,    delegate )  ;", "}", "}    catch    ( InvocationTargetException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getTargetException (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createProxy"], "fileName": "org.gradle.model.internal.manage.instance.ManagedProxyFactory"}, {"methodBody": ["METHOD_START", "{", "return   elementType ;", "}", "METHOD_END"], "methodName": ["getElementType"], "fileName": "org.gradle.model.internal.manage.schema.CollectionSchema"}, {"methodBody": ["METHOD_START", "{", "return   elementTypeSchema ;", "}", "METHOD_END"], "methodName": ["getElementTypeSchema"], "fileName": "org.gradle.model.internal.manage.schema.CollectionSchema"}, {"methodBody": ["METHOD_START", "{", "this . elementTypeSchema    =    elementTypeSchema ;", "}", "METHOD_END"], "methodName": ["setElementTypeSchema"], "fileName": "org.gradle.model.internal.manage.schema.CollectionSchema"}, {"methodBody": ["METHOD_START", "{", "return   accessors . get ( accessorType )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   accessors . values (  )  ;", "}", "METHOD_END"], "methodName": ["getAccessors"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   declaredBy ;", "}", "METHOD_END"], "methodName": ["getDeclaredBy"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    getter    =    getAccessor ( GET _ GETTER )  ;", "if    ( getter    =  =    null )     {", "getter    =    getAccessor ( IS _ GETTER )  ;", "}", "if    ( getter    =  =    null )     {", "throw   new   IllegalStateException (  (  \" No   getter   for   p \"     +     ( this )  )  )  ;", "}", "return   getter ;", "}", "METHOD_END"], "methodName": ["getGetter"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   Cast .  < WeaklyTypeReferencingMethod < I ,    T >  > uncheckedCast ( getGetter (  )  )  . invoke ( instance )  ;", "}", "METHOD_END"], "methodName": ["getPropertyValue"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   schema ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return    ( isAnnotationPresent ( annotationType ,    getAccessor ( GET _ GETTER )  )  )     |  |     ( isAnnotationPresent ( annotationType ,    getAccessor ( IS _ GETTER )  )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return    ( getter    !  =    null )     &  &     ( getter . getMethod (  )  . isAnnotationPresent ( annotationType )  )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   hasSetter ( accessors . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "this . schema    =    schema ;", "}", "METHOD_END"], "methodName": ["setSchema"], "fileName": "org.gradle.model.internal.manage.schema.ModelProperty"}, {"methodBody": ["METHOD_START", "{", "return   implementationType . get (  )  ;", "}", "METHOD_END"], "methodName": ["getImplementationType"], "fileName": "org.gradle.model.internal.manage.schema.SpecializedMapSchema"}, {"methodBody": ["METHOD_START", "{", "return   annotated ;", "}", "METHOD_END"], "methodName": ["isAnnotated"], "fileName": "org.gradle.model.internal.manage.schema.UnmanagedImplStructSchema"}, {"methodBody": ["METHOD_START", "{", "Iterator < Map . Entry < WeakClassSet ,    Map < ModelType <  ?  >  ,    ModelSchema <  ?  >  >  >  >    iterator    =    cache . entrySet (  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "if    ( iterator . next (  )  . getKey (  )  . isCollected (  )  )     {", "iterator . remove (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "org.gradle.model.internal.manage.schema.cache.ModelSchemaCache"}, {"methodBody": ["METHOD_START", "{", "Map < ModelType <  ?  >  ,    ModelSchema <  ?  >  >    typeCache    =    cache . get ( WeakClassSet . of ( type )  )  ;", "if    ( typeCache    =  =    null )     {", "return   null ;", "} else    {", "return   Cast . uncheckedCast ( typeCache . get ( type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.manage.schema.cache.ModelSchemaCache"}, {"methodBody": ["METHOD_START", "{", "WeakClassSet   cacheKey    =    WeakClassSet . of ( type )  ;", "Map < ModelType <  ?  >  ,     <  ?  >  >    typeCache    =    cache . get ( cacheKey )  ;", "if    ( typeCache    =  =    null )     {", "typeCache    =    Maps . newHashMap (  )  ;", "cache . put ( cacheKey ,    typeCache )  ;", "}", "typeCache . put ( type ,    schema )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.model.internal.manage.schema.cache.ModelSchemaCache"}, {"methodBody": ["METHOD_START", "{", "cleanUp (  )  ;", "long   size    =     0  ;", "for    ( Map < ModelType <  ?  >  ,     <  ?  >  >    values    :    cache . values (  )  )     {", "size    +  =    values . size (  )  ;", "}", "return   size ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.model.internal.manage.schema.cache.ModelSchemaCache"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?  >  >    allClasses    =    type . getAllClasses (  )  ;", "if    (  ( allClasses . size (  )  )     =  =     1  )     {", "return   new   Single ( allClasses . iterator (  )  . next (  )  )  ;", "} else    {", "return   new   Multi ( allClasses )  ;", "}", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.manage.schema.cache.WeakClassSet"}, {"methodBody": ["METHOD_START", "{", "finishVisitingMethod ( methodVisitor ,    RETURN )  ;", "}", "METHOD_END"], "methodName": ["finishVisitingMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.AbstractProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitInsn ( returnOpcode )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["finishVisitingMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.AbstractProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "}", "METHOD_END"], "methodName": ["putThisOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.AbstractProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Builder < Equivalence . Wrapper < Method >  ,    Collection < Method >  >    builder    =    ImmutableMap . builder (  )  ;", "for    ( Map < Equivalence . Wrapper < Method >  ,    Collection < Method >  >    csForSomeName    :    cs . values (  )  )     {", "builder . putAll ( csForSomeName )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["allMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "return   candidates . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "return   candidates . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["methodNames"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( candidates . containsKey ( methodName )  )     {", "return   candidates . get ( methodName )  ;", "}", "return   Collections .  < Equivalence . Wrapper < Method >  ,    Collection < Method >  > emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["methodsNamed"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( candidates . containsKey ( methodName )  )     {", "Map < Equivalence . Wrapper < Method >  ,    Collection < Method >  >    overloadeds    =    candidates . get ( methodName )  ;", "if    (  ( overloadeds . size (  )  )     >     1  )     {", "return   overloadeds ;", "}", "}", "return   Collections .  < Equivalence . Wrapper < Method >  ,    Collection < Method >  > emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["overloadedMethodsNamed"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "return   Maps . filterKeys ( overloadedMethodsNamed ( methodName )  ,    Predicates . not ( Predicates . in ( excludes )  )  )  ;", "}", "METHOD_END"], "methodName": ["overloadedMethodsNamed"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "if    ( candidates . containsKey ( methodName )  )     {", "return   Maps . filterValues ( candidates . get ( methodName )  ,    new   com . google . common . base . Predicate < Collection < Method >  >  (  )     {", "@ Override", "public   boolean   apply ( Collection < Method >    equivalentMethods )     {", "return    ( equivalentMethods . size (  )  )     >     1  ;", "}", "}  )  ;", "}", "return   Collections .  < Equivalence . Wrapper < Method >  ,    Collection < Method >  > emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["overriddenMethodsNamed"], "fileName": "org.gradle.model.internal.manage.schema.extract.CandidateMethods"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return    ( description )     =  =    null    ?    type . toString (  )     :     (  (  ( description )     +     \"     (  \"  )     +     ( type )  )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   problems ;", "}", "METHOD_END"], "methodName": ["getProblems"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   result ;", "}", "METHOD_END"], "methodName": ["getResult"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModelSchemaExtractionContext < T >  ( null ,    type ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["root"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "if    (  ( validator )     !  =    null )     {", "validator . execute (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext"}, {"methodBody": ["METHOD_START", "{", "final   ModelType < T >    type    =    extractionContext . getType (  )  ;", "ModelSchema < T >    cached    =    cache . get ( type )  ;", "if    ( cached    !  =    null )     {", "extractionContext . found ( cached )  ;", "return ;", "}", "for    ( ionStrategy   strategy    :    strategies )     {", "strategy . extract ( extractionContext )  ;", "if    ( extractionContext . hasProblems (  )  )     {", "throw   new   InvalidManagedModelElementTypeException ( extractionContext )  ;", "}", "if    (  ( extractionContext . getResult (  )  )     !  =    null )     {", "cache . set ( type ,    extractionContext . getResult (  )  )  ;", "return ;", "}", "}", "throw   new   IllegalStateException (  (  \" No   extraction   strategy   found   for   type :     \"     +    type )  )  ;", "}", "METHOD_END"], "methodName": ["extractSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractor"}, {"methodBody": ["METHOD_START", "{", "Iterables . addAll ( dependencyQueue ,    Iterables . filter ( allDependencies ,    new   com . google . common . base . Predicate < ModelSchemaExtractionContext <  ?  >  >  (  )     {", "public   boolean   apply ( ModelSchemaExtractionContext <  ?  >    dependency )     {", "return    ( cache . get ( dependency . getType (  )  )  )     =  =    null ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["pushUnsatisfiedDependencies"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractor"}, {"methodBody": ["METHOD_START", "{", "extractionContext . validate ( cache . get ( extractionContext . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractor"}, {"methodBody": ["METHOD_START", "{", "return   DefaultModelSchemaExtractor . withDefaultStrategies ( Collections .  < ModelSchemaExtractionStrategy > emptyList (  )  ,    new   ModelSchemaAspectExtractor (  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultStrategies"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractor"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModelSchemaExtractor ( ImmutableList .  < ModelSchemaExtractionStrategy > builder (  )  . addAll ( strategies )  . add ( new   PrimitiveStrategy (  )  )  . add ( new   EnumStrategy (  )  )  . add ( new   JdkValueTypeStrategy (  )  )  . add ( new   ModelSetStrategy (  )  )  . add ( new   SpecializedMapStrategy (  )  )  . add ( new   ModelMapStrategy (  )  )  . add ( new   JavaUtilCollectionStrategy (  )  )  . add ( new   ManagedImplStructStrategy ( aspectExtractor )  )  . add ( new   RuleSourceSchemaExtractionStrategy ( aspectExtractor )  )  . add ( new   UnmanagedImplStructStrategy ( aspectExtractor )  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["withDefaultStrategies"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractor"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "return   ca . size (  )  ;", "}", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaStore"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( MType <  ?  >    supportedType    :    supportedTypes )     {", "if    ( constraints . isSatisfiedBy ( supportedType )  )     {", "if    (  ( builder . length (  )  )     >     0  )     {", "builder . append (  \"  ,     \"  )  ;", "}", "builder . append ( supportedType )  ;", "}", "}", "if    (  ( builder . length (  )  )     =  =     0  )     {", "return    \"  ( none )  \"  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["formatKnownTypes"], "fileName": "org.gradle.model.internal.manage.schema.extract.FactoryBasedStructNodeInitializerExtractionStrategy"}, {"methodBody": ["METHOD_START", "{", "ModelType < S >    publicType    =    schema . getType (  )  ;", "return   schema   instanceof   ManagedImplSchema    ?    instanceFactory . getManagedSubtypeImplementationInfo ( publicType )     :    instanceFactory . getImplementationInfo ( publicType )  ;", "}", "METHOD_END"], "methodName": ["getImplementationInfo"], "fileName": "org.gradle.model.internal.manage.schema.extract.FactoryBasedStructNodeInitializerExtractionStrategy"}, {"methodBody": ["METHOD_START", "{", "StructSchema < S >    publicSchema    =    Cast . uncheckedCast ( schema )  ;", "InstanceFactory . ImplementationInfo   implementationInfo    =    getImplementationInfo ( publicSchema )  ;", "if    ( implementationInfo    =  =    null )     {", "return   null ;", "}", "Set < ModelType <  ?  >  >    internalViews    =    implementationInfo . getInternalViews (  )  ;", "ModelType <  ?  >    delegateType    =    implementationInfo . getDelegateType (  )  ;", "StructBindings < S >    bindings    =    bindingsStore . getBindings ( publicSchema . getType (  )  ,    internalViews ,    delegateType )  ;", "return   new    < T ,    S >  ( bindings ,    implementationInfo )  ;", "}", "METHOD_END"], "methodName": ["getNodeInitializer"], "fileName": "org.gradle.model.internal.manage.schema.extract.FactoryBasedStructNodeInitializerExtractionStrategy"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prefix    =    new   StringBuilder (  \"        \"  )  ;", "Deque < String >    descriptions    =    Lists . newLinkedList (  )  ;", "DefaultModelSchemaExtractionContext <  ?  >    current    =    ionContext ;", "while    ( current    !  =    null )     {", "descriptions . push ( current . getDescription (  )  )  ;", "current    =    current . getParent (  )  ;", "}", "out . append ( descriptions . pop (  )  )  ;", "out . append (  '  \\ n '  )  ;", "while    (  !  ( descriptions . isEmpty (  )  )  )     {", "out . append ( prefix )  ;", "out . append (  \"  \\  \\  -  -  -     \"  )  ;", "out . append ( descriptions . pop (  )  )  ;", "if    (  !  ( descriptions . isEmpty (  )  )  )     {", "out . append (  '  \\ n '  )  ;", "prefix . append (  \"        \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["createPathString"], "fileName": "org.gradle.model.internal.manage.schema.extract.InvalidManagedModelElementTypeException"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   out    =    new   StringBuilder (  )  ;", "out . append ( extractionContext . getProblems (  )  . format (  )  )  ;", "if    (  ( extractionContext . getParent (  )  )     !  =    null )     {", "out . append (  \"  \\ n \\ n \"  )  ;", "out . append (  \" The   type   was   analyzed   due   to   the   following   dependencies :  \\ n \"  )  ;", ". createPathString ( extractionContext ,    out )  ;", "}", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.model.internal.manage.schema.extract.InvalidManagedModelElementTypeException"}, {"methodBody": ["METHOD_START", "{", "ModelType <  ?  >    type    =    extractionContext . getType (  )  ;", "StringBuilder   out    =    new   StringBuilder (  )  ;", "out . append (  \" Invalid   managed   model   type    \"  )  . append ( type )  . append (  \"  :     \"  )  . append ( message )  ;", "if    (  ( extractionContext . getParent (  )  )     !  =    null )     {", "out . append (  '  \\ n '  )  ;", "out . append (  \" The   type   was   analyzed   due   to   the   following   dependencies :  \\ n \"  )  ;", ". createPathString ( extractionContext ,    out )  ;", "}", "return   out . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.model.internal.manage.schema.extract.InvalidManagedModelElementTypeException"}, {"methodBody": ["METHOD_START", "{", "final   ScalarCollectionSchema < T ,    E >    schema    =    new   ScalarCollectionSchema < T ,    E >  ( type ,    elementType )  ;", "extractionContext . child ( elementType ,     \" element   type \"  ,    new   Action < ModelSchema < E >  >  (  )     {", "@ Override", "public   void   execute ( ModelSchema < E >    elementTypeSchema )     {", "schema . setElementTypeSchema ( elementTypeSchema )  ;", "}", "}  )  ;", "return   schema ;", "}", "METHOD_END"], "methodName": ["createSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.JavaUtilCollectionStrategy"}, {"methodBody": ["METHOD_START", "{", "AsmClassGenerator   classGenerator    =    new   AsmClassGenerator ( publicContractType ,     \"  _ Impl \"  )  ;", "ClassWriter   visitor    =    classGenerator . getVisitor (  )  ;", "Type   generatedType    =    classGenerator . getGeneratedType (  )  ;", "Type   superclassType    =    Type . getType ( implClass )  ;", "Type   publicType    =    Type . getType ( publicContractType )  ;", "generateClass ( visitor ,    generatedType ,    superclassType ,    publicType )  ;", "generateConstructors ( visitor ,    implClass ,    superclassType )  ;", "visitor . visitEnd (  )  ;", "return   classGenerator . define (  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedCollectionProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "visitor . visit ( V 1  _  6  ,    ACC _ PUBLIC ,    generatedType . getInternalName (  )  ,    null ,    superclassType . getInternalName (  )  ,    new   String [  ]  {    publicType . getInternalName (  )     }  )  ;", "}", "METHOD_END"], "methodName": ["generateClass"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedCollectionProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( Constructor <  ?  >    constructor    :    implClass . getConstructors (  )  )     {", "Type [  ]    paramTypes    =    new   Type [ constructor . getParameterTypes (  )  . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( paramTypes . length )  ;    i +  +  )     {", "paramTypes [ i ]     =    Type . getType ( constructor . getParameterTypes (  )  [ i ]  )  ;", "}", "String   methodDescriptor    =    Type . getMethodDescriptor ( VOID _ TYPE ,    paramTypes )  ;", "MethodVisitor   constructorVisitor    =    visitor . visitMethod ( ACC _ PUBLIC ,    Abstract . CONSTRUCTOR _ NAME ,    methodDescriptor ,    Abstract . CONCRETE _ SIGNATURE ,    Abstract . NO _ EXCEPTIONS )  ;", "constructorVisitor . visitCode (  )  ;", "putThisOnStack ( constructorVisitor )  ;", "for    ( int   i    =     0  ;    i    <     ( paramTypes . length )  ;    i +  +  )     {", "constructorVisitor . visitVarInsn ( paramTypes [ i ]  . getOpcode ( ILOAD )  ,     ( i    +     1  )  )  ;", "}", "constructorVisitor . visitMethodInsn ( INVOKESPECIAL ,    superclassType . getInternalName (  )  ,    Abstract . CONSTRUCTOR _ NAME ,    methodDescriptor ,    false )  ;", "finishVisitingMethod ( constructorVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["generateConstructors"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedCollectionProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   type . isAnnotationPresent ( Managed . class )  ;", "}", "METHOD_END"], "methodName": ["isTarget"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedImplStructNodeInitializerExtractionStrategy"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( constructorVisitor )  ;", "putThirdMethodArgumentOnStack ( constructorVisitor )  ;", "constructorVisitor . visitFieldInsn ( PUTFIELD ,    generatedType . getInternalName (  )  ,     . DELEGATE _ FIELD _ NAME ,    delegateType . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["assignDelegateField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( constructorVisitor )  ;", "putFirstMethodArgumentOnStack ( constructorVisitor )  ;", "constructorVisitor . visitFieldInsn ( PUTFIELD ,    generatedType . getInternalName (  )  ,     . STATE _ FIELD _ NAME ,     . GENERATED _ VIEW _ STATE _ TYPE . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["assignStateField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( constructorVisitor )  ;", "putSecondMethodArgumentOnStack ( constructorVisitor )  ;", "constructorVisitor . visitFieldInsn ( PUTFIELD ,    generatedType . getInternalName (  )  ,     . TYPE _ CONVERTER _ FIELD _ NAME ,     . TYPE _ CONVERTER _ TYPE . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["assignTypeConverterField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    boxedType    =    ManagedProxyClassGenerator . BOXED _ TYPES . get ( primitiveType )  ;", "methodVisitor . visitMethodInsn ( INVOKESTATIC ,    Type . getInternalName ( boxedType )  ,     \" valueOf \"  ,     (  (  (  \"  (  \"     +     ( Type . getDescriptor ( primitiveType )  )  )     +     \"  )  \"  )     +     ( Type . getDescriptor ( boxedType )  )  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["boxType"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( returnType . isPrimitive (  )  )     {", "unboxType ( methodVisitor ,    returnType )  ;", "} else    {", "methodVisitor . visitTypeInsn ( CHECKCAST ,    Type . getIName ( returnType )  )  ;", "}", "}", "METHOD_END"], "methodName": ["castFirstStackElement"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "declareField ( visitor ,    ManagedProxyClassGenerator . CAN _ CALL _ SETTERS _ FIELD _ NAME ,    Boolean . TYPE )  ;", "}", "METHOD_END"], "methodName": ["declareCanCallSettersField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "visitor . visit ( V 1  _  6  ,    ACC _ PUBLIC ,    generatedType . getInternalName (  )  ,    null ,    superclassType . getInternalName (  )  ,    Iterables . toArray ( interfaceInternalNames ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["declareClass"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "declareField ( visitor ,    ManagedProxyClassGenerator . DELEGATE _ FIELD _ NAME ,    delegateClass )  ;", "}", "METHOD_END"], "methodName": ["declareDelegateField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "visitor . visitField (  (  (  ( ACC _ PRIVATE )     |     ( ACC _ FINAL )  )     |     ( ACC _ SYNTHETIC )  )  ,    name ,    Type . getDescriptor ( fieldClass )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["declareField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "declareStaticField ( visitor ,    ManagedProxyClassGenerator . MANAGED _ TYPE _ FIELD _ NAME ,    ModelType . class )  ;", "}", "METHOD_END"], "methodName": ["declareManagedTypeField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   declareMethod ( visitor ,    methodName ,    methodDescriptor ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "}", "METHOD_END"], "methodName": ["declareMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   declareMethod ( visitor ,    methodName ,    methodDescriptor ,    methodSignature ,    ACC _ PUBLIC )  ;", "}", "METHOD_END"], "methodName": ["declareMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    visitor . visitMethod ( access ,    methodName ,    methodDescriptor ,    methodSignature ,    AbstractProxyClassGenerator . NO _ EXCEPTIONS )  ;", "methodVisitor . visitCode (  )  ;", "return   methodVisitor ;", "}", "METHOD_END"], "methodName": ["declareMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   declareMethod ( visitor ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  )  ;", "}", "METHOD_END"], "methodName": ["declareMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "declareField ( visitor ,    ManagedProxyClassGenerator . STATE _ FIELD _ NAME ,    GeneratedViewState . class )  ;", "}", "METHOD_END"], "methodName": ["declareStateField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   visitor . visitField (  (  (  (  ( ACC _ PRIVATE )     |     ( ACC _ FINAL )  )     |     ( ACC _ STATIC )  )     |     ( ACC _ SYNTHETIC )  )  ,    name ,    Type . getDescriptor ( fieldClass )  ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["declareStaticField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "declareField ( visitor ,    ManagedProxyClassGenerator . TYPE _ CONVERTER _ FIELD _ NAME ,    TypeConverter . class )  ;", "}", "METHOD_END"], "methodName": ["declareTypeConverterField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( structBindings . getImplementedViewSchemas (  )  . contains ( viewSchema )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" View    '  % s '    is   not   supported   by   struct    '  % s '  \"  ,    viewSchema . getType (  )  ,    structBindings . getPublicSchema (  )  . getType (  )  )  )  ;", "}", "ModelType < M >    viewType    =    viewSchema . getType (  )  ;", "StringBuilder   generatedTypeNameBuilder    =    new   StringBuilder (  )  ;", "if    ( backingStateType    =  =     ( GeneratedViewState . class )  )     {", "generatedTypeNameBuilder . append (  \"  $ View \"  )  ;", "} else    {", "generatedTypeNameBuilder . append (  \"  $ NodeView \"  )  ;", "}", "StructSchema < D >    delegateSchema    =    Cast . uncheckedCast ( structBindings . getDelegateSchema (  )  )  ;", "if    ( delegateSchema    !  =    null )     {", "generatedTypeNameBuilder . append (  \"  $  \"  )  . append ( delegateSchema . getType (  )  . getName (  )  . replaceAll (  \"  \\  \\  .  \"  ,     \"  _  \"  )  )  ;", "}", "String   classNameSuffix    =    generatedTypeNameBuilder . toString (  )  ;", "Class <  ?  >    superclass ;", "final   ImmutableSet . Builder < String >    interfacesToImplement    =    ImmutableSet . builder (  )  ;", "final   ImmutableSet . Builder < ModelType <  ?  >  >    typesToDelegate    =    ImmutableSet . builder (  )  ;", "typesToDelegate . add ( viewType )  ;", "interfacesToImplement . add (  . GENERATED _ VIEW _ TYPE . getInternalName (  )  )  ;", "if    ( backingStateType    =  =     ( ModelElementState . class )  )     {", "interfacesToImplement . add (  . MANAGED _ INSTANCE _ TYPE )  ;", "}", "Class < M >    viewClass    =    viewType . getConcreteClass (  )  ;", "if    ( viewClass . isInterface (  )  )     {", "superclass    =    Object . class ;", "interfacesToImplement . add ( Type . getInternalName ( viewClass )  )  ;", "} else    {", "superclass    =    viewClass ;", "}", "if    ( delegateSchema    !  =    null )     {", "walkTypeHierarchy ( delegateSchema . getType (  )  . getConcreteClass (  )  ,    ModelSchemaUtils . IGNORED _ OBJECT _ TYPES ,    new   TypeVisitor < D >  (  )     {", "@ Override", "public   void   visitType ( Class <  ?    super   D >    type )     {", "if    ( type . isInterface (  )  )     {", "typesToDelegate . add ( ModelType . of ( type )  )  ;", "interfacesToImplement . add ( Type . getInternalName ( type )  )  ;", "}", "}", "}  )  ;", "}", "ClassLoader   targetClassLoader    =    viewClass . getClassLoader (  )  ;", "if    ( delegateSchema    !  =    null )     {", "try    {", "viewClass . getClassLoader (  )  . loadClass ( delegateSchema . getType (  )  . getConcreteClass (  )  . getName (  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "targetClassLoader    =    delegateSchema . getType (  )  . getConcreteClass (  )  . getClassLoader (  )  ;", "}", "}", "AsmClassGenerator   generator    =    new   AsmClassGenerator ( viewClass ,    classNameSuffix )  ;", "ClassWriter   visitor    =    generator . getVisitor (  )  ;", "generateProxyClass ( visitor ,    viewSchema ,    structBindings ,    interfacesToImplement . build (  )  ,    typesToDelegate . build (  )  ,    generator . getGeneratedType (  )  ,    Type . getType ( superclass )  ,    backingStateType )  ;", "return   generator . define ( targetClassLoader )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    viewClass    =    viewSchema . getType (  )  . getConcreteClass (  )  ;", "StructSchema <  ?  >    delegateSchema    =    bindings . getDelegateSchema (  )  ;", "declareClass ( visitor ,    interfacesToImplement ,    generatedType ,    superclassType )  ;", "declareStateField ( visitor )  ;", "declareTypeConverterField ( visitor )  ;", "declareTypeField ( visitor )  ;", "declareCanCallSettersField ( visitor )  ;", "writeStaticConstructor ( visitor ,    generatedType ,    viewClass )  ;", "writeConstructor ( visitor ,    generatedType ,    superclassType ,    delegateSchema ,    Type . getType ( backingStateType )  )  ;", "writeToString ( visitor ,    generatedType ,    viewClass ,    delegateSchema )  ;", "writeGeneratedViewMethods ( visitor ,    generatedType )  ;", "if    ( backingStateType    =  =     ( ModelElementState . class )  )     {", "writeInstanceMethods ( visitor ,    generatedType )  ;", "}", "writeGroovyMethods ( visitor ,    viewClass )  ;", "writeViewMethods ( visitor ,    generatedType ,    viewTypes ,    bindings )  ;", "writeHashCodeMethod ( visitor ,    generatedType )  ;", "writeEqualsMethod ( visitor ,    generatedType )  ;", "visitor . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["generateProxyClass"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   dTypeClass . getMethod (  \" toString \"  )  ;", "}    catch    ( NoSuchMethodException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getToStringMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( methodVisitor )  ;", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "for    ( int   paramNo    =     0  ;    paramNo    <     ( parameterTypes . length )  ;    paramNo +  +  )     {", "putMethodArgumentOnStack ( methodVisitor ,    Type . getType ( parameterTypes [ paramNo ]  )  ,     ( paramNo    +     1  )  )  ;", "}", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    generatedType . getIName (  )  ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["invokeBridgedMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putDelegateFieldValueOnStack ( methodVisitor ,    generatedType ,    delegateType )  ;", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "for    ( int   paramNo    =     0  ;    paramNo    <     ( parameterTypes . length )  ;    paramNo +  +  )     {", "putMethodArgumentOnStack ( methodVisitor ,    Type . getType ( parameterTypes [ paramNo ]  )  ,     ( paramNo    +     1  )  )  ;", "}", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    delegateType . getIName (  )  ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["invokeDelegateMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE _ NAME ,     \" get \"  ,    ManagedProxyClassGenerator . STATE _ GET _ METHOD _ DESCRIPTOR ,    true )  ;", "}", "METHOD_END"], "methodName": ["invokeStateGetMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE _ NAME ,     \" set \"  ,    ManagedProxyClassGenerator . STATE _ SET _ METHOD _ DESCRIPTOR ,    true )  ;", "}", "METHOD_END"], "methodName": ["invokeStateSetMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( constructorVisitor )  ;", "constructorVisitor . visitMethodInsn ( INVOKESPECIAL ,    superclassType . getInternalName (  )  ,    Abstract . CONSTRUCTOR _ NAME ,    Type . getMethodDescriptor ( VOID _ TYPE )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["invokeSuperConstructor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( methodVisitor )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    Type . getIName ( superClass )  ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["invokeSuperMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitJumpInsn ( IFNE ,    label )  ;", "}", "METHOD_END"], "methodName": ["jumpToLabelIfStackEvaluatesToTrue"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedPropertyValueException ( String . format (  \" Cannot   set   property :     % s   for   class :     % s   to   value :     % s .  \"  ,    propertyName ,    viewType . getName (  )  ,    value )  ,    failure )  ;", "}", "METHOD_END"], "methodName": ["propertyValueConvertFailure"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "int   ins    =    ICONST _  0  ;", "if    (  ( long . c )     =  =    primitiveType )     {", "ins    =    LCONST _  0  ;", "} else", "if    (  ( double . c )     =  =    primitiveType )     {", "ins    =    DCONST _  0  ;", "} else", "if    (  ( float . c )     =  =    primitiveType )     {", "ins    =    FCONST _  0  ;", "}", "methodVisitor . visitInsn ( ins )  ;", "}", "METHOD_END"], "methodName": ["pushDefaultValue"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . CAN _ CALL _ SETTERS _ FIELD _ NAME ,    BOOLEAN _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["putCanCallSettersFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putConstantOnStack ( methodVisitor ,    managedTypeClass . getName (  )  )  ;", "methodVisitor . visitMethodInsn ( INVOKESTATIC ,     . CLASS _ INTERNAL _ NAME ,     \" forName \"  ,     . FOR _ NAME _ METHOD _ DESCRIPTOR ,    false )  ;", "}", "METHOD_END"], "methodName": ["putClassOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitLdcInsn ( value )  ;", "}", "METHOD_END"], "methodName": ["putConstantOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . DELEGATE _ FIELD _ NAME ,    delegateType )  ;", "}", "METHOD_END"], "methodName": ["putDelegateFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( methodVisitor )  ;", "methodVisitor . visitFieldInsn ( GETFIELD ,    generatedType . getIName (  )  ,    name ,    fieldType . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["putFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFirstMethodArgumentOnStack ( methodVisitor ,    ManagedProxyClassGenerator . OBJECT _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["putFirstMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "int   loadCode    =    argType . getOpcode ( ILOAD )  ;", "methodVisitor . visitVarInsn ( loadCode ,     1  )  ;", "}", "METHOD_END"], "methodName": ["putFirstMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putStaticFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . MANAGED _ TYPE _ FIELD _ NAME ,    ManagedProxyClassGenerator . MODEL _ TYPE _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["putManagedTypeFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitVarInsn ( ALOAD ,    index )  ;", "}", "METHOD_END"], "methodName": ["putMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitVarInsn ( type . getOpcode ( ILOAD )  ,    index )  ;", "}", "METHOD_END"], "methodName": ["putMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . STATE _ FIELD _ NAME ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE )  ;", "methodVisitor . visitTypeInsn ( CHECKCAST ,    ManagedProxyClassGenerator . MODEL _ ELEMENT _ STATE _ TYPE _ INTERNAL _ NAME )  ;", "}", "METHOD_END"], "methodName": ["putNodeStateFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitVarInsn ( ALOAD ,     2  )  ;", "}", "METHOD_END"], "methodName": ["putSecondMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . STATE _ FIELD _ NAME ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["putStateFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitFieldInsn ( GETSTATIC ,    generatedType . getInternalName (  )  ,    name ,    fieldType . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["putStaticFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "methodVisitor . visitVarInsn ( ALOAD ,     3  )  ;", "}", "METHOD_END"], "methodName": ["putThirdMethodArgumentOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putFieldValueOnStack ( methodVisitor ,    generatedType ,    ManagedProxyClassGenerator . TYPE _ CONVERTER _ FIELD _ NAME ,    ManagedProxyClassGenerator . TYPE _ CONVERTER _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["putTypeConverterFieldValueOnStack"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   returnType . getOpcode ( IRETURN )  ;", "}", "METHOD_END"], "methodName": ["returnCode"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "putThisOnStack ( methodVisitor )  ;", "methodVisitor . visitLdcInsn ( canCallSetters )  ;", "methodVisitor . visitFieldInsn ( PUTFIELD ,    generatedType . getInternalName (  )  ,     . CAN _ CALL _ SETTERS _ FIELD _ NAME ,    BOOLEAN _ TYPE . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["setCanCallSettersField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "String   exceptionInternalName    =    Type . getInternalName ( UnsupportedOperationException . class )  ;", "methodVisitor . visitTypeInsn ( NEW ,    exceptionInternalName )  ;", "methodVisitor . visitInsn ( DUP )  ;", "putConstantOnStack ( methodVisitor ,     \" Calling   setters   of   a   managed   type   on   itself   is   not   allowed \"  )  ;", "String   constructorDescriptor    =    Type . getMethodDescriptor ( VOID _ TYPE ,     . STRING _ TYPE )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    exceptionInternalName ,    AbstractProxyClassGenerator . CONSTRUCTOR _ NAME ,    constructorDescriptor ,    false )  ;", "methodVisitor . visitInsn ( ATHROW )  ;", "}", "METHOD_END"], "methodName": ["throwExceptionBecauseCalledOnItself"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    boxedType    =    ManagedProxyClassGenerator . BOXED _ TYPES . get ( primitiveClass )  ;", "Type   primitiveType    =    Type . getType ( primitiveClass )  ;", "methodVisitor . visitTypeInsn ( CHECKCAST ,    Type . getInternalName ( boxedType )  )  ;", "methodVisitor . visitInsn ( DUP )  ;", "Label   exit    =    new   Label (  )  ;", "Label   elseValue    =    new   Label (  )  ;", "methodVisitor . visitJumpInsn ( IFNONNULL ,    elseValue )  ;", "methodVisitor . visitInsn ( POP )  ;", "pushDefaultValue ( methodVisitor ,    primitiveClass )  ;", "methodVisitor . visitJumpInsn ( GOTO ,    exit )  ;", "methodVisitor . visitLabel ( elseValue )  ;", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    Type . getInternalName ( boxedType )  ,     (  ( primitiveClass . getSimpleName (  )  )     +     \" Value \"  )  ,    Type . getMethodDescriptor ( primitiveType )  ,    false )  ;", "methodVisitor . visitLabel ( exit )  ;", "}", "METHOD_END"], "methodName": ["unboxType"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  ,    AsmClassGeneratorUtils . signature ( method )  )  ;", "invokeBridgedMethod ( methodVisitor ,    generatedType ,    method )  ;", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "finishVisitingMethod ( methodVisitor ,    returnCode ( Type . getType ( returnType )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeBridgeMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! writable )     &  &     (  ( property . getSchema (  )  )    instanceof   CompositeSchema )  )     {", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    property . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . CLOSURE _ TYPE )  ,    null )  ;", "putNodeStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "putConstantOnStack ( methodVisitor ,    property . getName (  )  )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,     . MODEL _ ELEMENT _ STATE _ TYPE _ INTERNAL _ NAME ,     \" apply \"  ,     . STATE _ APPLY _ METHOD _ DESCRIPTOR ,    true )  ;", "finishVisitingMethod ( methodVisitor )  ;", "return ;", "}", "if    (  (  ! writable )     &  &     (  ( property . getSchema (  )  )    instanceof   UnmanagedImplStructSchema )  )     {", "UnmanagedImplStructSchema <  ?  >    structSchema    =     (  ( UnmanagedImplStructSchema <  ?  >  )     ( property . getSchema (  )  )  )  ;", "if    (  !  ( structSchema . isAnnotated (  )  )  )     {", "return ;", "}", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    property . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . CLOSURE _ TYPE )  ,    null )  ;", "putThisOnStack ( methodVisitor )  ;", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    generatedType . getInternalName (  )  ,    property . getGetter (  )  . getName (  )  ,    Type . getMethodDescriptor ( Type . getType ( property . getType (  )  . getConcreteClass (  )  )  )  ,    false )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "methodVisitor . visitMethodInsn ( INVOKESTATIC ,    Type . getInternalName ( ClosureBackedAction . class )  ,     \" execute \"  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . OBJECT _ TYPE ,     . CLOSURE _ TYPE )  ,    false )  ;", "finishVisitingMethod ( methodVisitor )  ;", "return ;", "}", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    property . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . CLOSURE _ TYPE )  ,    null )  ;", "putThisOnStack ( methodVisitor )  ;", "putConstantOnStack ( methodVisitor ,    property . getName (  )  )  ;", "methodVisitor . visitInsn ( ICONST _  1  )  ;", "methodVisitor . visitTypeInsn ( ANEWARRAY ,     . OBJECT _ TYPE . getInternalName (  )  )  ;", "methodVisitor . visitInsn ( DUP )  ;", "methodVisitor . visitInsn ( ICONST _  0  )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "methodVisitor . visitInsn ( AASTORE )  ;", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    generatedType . getInternalName (  )  ,     \" methodMissing \"  ,     . METHOD _ MISSING _ METHOD _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor )  ;", "}", "METHOD_END"], "methodName": ["writeConfigureMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "String   constructorDescriptor ;", "Type   delegateType ;", "if    ( delegateSchema    =  =    null )     {", "delegateType    =    null ;", "constructorDescriptor    =    Type . getMethodDescriptor ( VOID _ TYPE ,    backingStateType ,     . TYPE _ CONVERTER _ TYPE )  ;", "} else    {", "delegateType    =    Type . getType ( delegateSchema . getType (  )  . getConcreteClass (  )  )  ;", "constructorDescriptor    =    Type . getMethodDescriptor ( VOID _ TYPE ,    backingStateType ,     . TYPE _ CONVERTER _ TYPE ,    delegateType )  ;", "}", "MethodVisitor   constructorVisitor    =    declareMethod ( visitor ,    AbstractProxyClassGenerator . CONSTRUCTOR _ NAME ,    constructorDescriptor ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "invokeSuperConstructor ( constructorVisitor ,    superclassType )  ;", "assignStateField ( constructorVisitor ,    generatedType )  ;", "assignTypeConverterField ( constructorVisitor ,    generatedType )  ;", "if    ( delegateType    !  =    null )     {", "assignDelegateField ( constructorVisitor ,    generatedType ,    delegateType )  ;", "}", "setCanCallSettersField ( constructorVisitor ,    generatedType ,    true )  ;", "finishVisitingMethod ( constructorVisitor )  ;", "}", "METHOD_END"], "methodName": ["writeConstructor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \" toString \"  ,    ManagedProxyClassGenerator . TO _ STRING _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE _ NAME ,     \" getDisplayName \"  ,    ManagedProxyClassGenerator . TO _ STRING _ METHOD _ DESCRIPTOR ,    true )  ;", "finishVisitingMethod ( methodVisitor ,    ARETURN )  ;", "}", "METHOD_END"], "methodName": ["writeDefaultToString"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    method . getName (  )  ,    Type . getMethodDescriptor ( method )  ,    AsmClassGeneratorUtils . signature ( method )  )  ;", "invokeDelegateMethod ( methodVisitor ,    generatedType ,    delegateType ,    method )  ;", "Class <  ?  >    returnType    =    method . getReturnType (  )  ;", "finishVisitingMethod ( methodVisitor ,    returnCode ( Type . getType ( returnType )  )  )  ;", "}", "METHOD_END"], "methodName": ["writeDelegatingMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \" toString \"  ,    ManagedProxyClassGenerator . TO _ STRING _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "putDelegateFieldValueOnStack ( methodVisitor ,    generatedType ,    delegateType )  ;", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    delegateType . getInternalName (  )  ,     \" getDisplayName \"  ,    ManagedProxyClassGenerator . TO _ STRING _ METHOD _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor ,    ARETURN )  ;", "}", "METHOD_END"], "methodName": ["writeDelegatingToString"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    cw . visitMethod ( ACC _ PUBLIC ,     \" equals \"  ,    ManagedProxyClassGenerator . EQUALS _ METHOD _ DESCRIPTOR ,    null ,    null )  ;", "methodVisitor . visitCode (  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     0  )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "Label   notSameLabel    =    new   Label (  )  ;", "methodVisitor . visitJumpInsn ( IF _ ACMPNE ,    notSameLabel )  ;", "methodVisitor . visitInsn ( ICONST _  1  )  ;", "methodVisitor . visitInsn ( IRETURN )  ;", "methodVisitor . visitLabel ( notSameLabel )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "methodVisitor . visitTypeInsn ( INSTANCEOF ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ TYPE . getInternalName (  )  )  ;", "Label   generatedViewLabel    =    new   Label (  )  ;", "methodVisitor . visitJumpInsn ( IFNE ,    generatedViewLabel )  ;", "methodVisitor . visitInsn ( ICONST _  0  )  ;", "methodVisitor . visitInsn ( IRETURN )  ;", "methodVisitor . visitLabel ( generatedViewLabel )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "methodVisitor . visitTypeInsn ( CHECKCAST ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ TYPE . getInternalName (  )  )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ TYPE . getInternalName (  )  ,     \"  _  _ view _ state _  _  \"  ,    ManagedProxyClassGenerator . GET _ VIEW _ STATE _ METHOD _ DESCRIPTOR ,    true )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE _ NAME ,     \" equals \"  ,    ManagedProxyClassGenerator . EQUALS _ METHOD _ DESCRIPTOR ,    true )  ;", "finishVisitingMethod ( methodVisitor ,    Opcodes . IRETURN )  ;", "}", "METHOD_END"], "methodName": ["writeEqualsMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \"  _  _ view _ state _  _  \"  ,    ManagedProxyClassGenerator . GET _ VIEW _ STATE _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "finishVisitingMethod ( methodVisitor ,    ARETURN )  ;", "}", "METHOD_END"], "methodName": ["writeGeneratedViewMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Method   getter    =    weakGetter . getMethod (  )  ;", "Type   propertyType    =    Type . getType ( propertyClass )  ;", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    getter . getName (  )  ,    Type . getMethodDescriptor ( propertyType )  ,    AsmUtils . signature ( getter )  )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "putConstantOnStack ( methodVisitor ,    propertyName )  ;", "invokeStateGetMethod ( methodVisitor )  ;", "castFirstStackElement ( methodVisitor ,    propertyClass )  ;", "finishVisitingMethod ( methodVisitor ,    returnCode ( propertyType )  )  ;", "}", "METHOD_END"], "methodName": ["writeGetter"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \" propertyMissing \"  ,    ManagedProxyClassGenerator . GET _ PROPERTY _ MISSING _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "methodVisitor . visitTypeInsn ( NEW ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ EXCEPTION _ TYPE )  ;", "methodVisitor . visitInsn ( DUP )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "putClassOnStack ( methodVisitor ,    viewClass )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ EXCEPTION _ TYPE ,     \"  < init >  \"  ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ CONSTRUCTOR _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor ,    ATHROW )  ;", "methodVisitor    =    declareMethod ( visitor ,     \" propertyMissing \"  ,    ManagedProxyClassGenerator . SET _ PROPERTY _ MISSING _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "methodVisitor . visitTypeInsn ( NEW ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ EXCEPTION _ TYPE )  ;", "methodVisitor . visitInsn ( DUP )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "putClassOnStack ( methodVisitor ,    viewClass )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ EXCEPTION _ TYPE ,     \"  < init >  \"  ,    ManagedProxyClassGenerator . MISSING _ PROPERTY _ CONSTRUCTOR _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor ,    ATHROW )  ;", "methodVisitor    =    declareMethod ( visitor ,     \" methodMissing \"  ,    ManagedProxyClassGenerator . METHOD _ MISSING _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE )  ;", "methodVisitor . visitTypeInsn ( NEW ,    ManagedProxyClassGenerator . MISSING _ METHOD _ EXCEPTION _ TYPE )  ;", "methodVisitor . visitInsn ( DUP )  ;", "putMethodArgumentOnStack ( methodVisitor ,     1  )  ;", "putClassOnStack ( methodVisitor ,    viewClass )  ;", "putMethodArgumentOnStack ( methodVisitor ,     2  )  ;", "methodVisitor . visitTypeInsn ( CHECKCAST ,    ManagedProxyClassGenerator . OBJECT _ ARRAY _ TYPE )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,    ManagedProxyClassGenerator . MISSING _ METHOD _ EXCEPTION _ TYPE ,     \"  < init >  \"  ,    ManagedProxyClassGenerator . MISSING _ METHOD _ EXCEPTION _ CONSTRUCTOR _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor ,    ATHROW )  ;", "}", "METHOD_END"], "methodName": ["writeGroovyMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \" hashCode \"  ,    ManagedProxyClassGenerator . HASH _ CODE _ METHOD _ DESCRIPTOR ,    null )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . GENERATED _ VIEW _ STATE _ TYPE _ NAME ,     \" hashCode \"  ,    ManagedProxyClassGenerator . HASH _ CODE _ METHOD _ DESCRIPTOR ,    true )  ;", "finishVisitingMethod ( methodVisitor ,    IRETURN )  ;", "}", "METHOD_END"], "methodName": ["writeHashCodeMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,     \" getBackingNode \"  ,    ManagedProxyClassGenerator . GET _ BACKING _ NODE _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  )  ;", "putNodeStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,    ManagedProxyClassGenerator . MODEL _ ELEMENT _ STATE _ TYPE _ INTERNAL _ NAME ,     \" getBackingNode \"  ,    ManagedProxyClassGenerator . GET _ BACKING _ NODE _ METHOD _ DESCRIPTOR ,    true )  ;", "finishVisitingMethod ( methodVisitor ,    ARETURN )  ;", "}", "METHOD_END"], "methodName": ["writeManagedInstanceGetBackingNodeMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   managedTypeVisitor    =    declareMethod ( visitor ,     \" getManagedType \"  ,    ManagedProxyClassGenerator . GET _ MANAGED _ TYPE _ METHOD _ DESCRIPTOR ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  )  ;", "putManagedTypeFieldValueOnStack ( managedTypeVisitor ,    generatedType )  ;", "finishVisitingMethod ( managedTypeVisitor ,    ARETURN )  ;", "}", "METHOD_END"], "methodName": ["writeManagedInstanceGetManagedTypeMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "writeManagedInstanceGetBackingNodeMethod ( visitor ,    generatedType )  ;", "writeManagedInstanceGetManagedTypeMethod ( visitor ,    generatedType )  ;", "}", "METHOD_END"], "methodName": ["writeManagedInstanceMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "constructorVisitor . visitLdcInsn ( Type . getType ( managedTypeClass )  )  ;", "constructorVisitor . visitMethodInsn ( INVOKESTATIC ,     . MODEL _ TYPE _ INTERNAL _ NAME ,     \" of \"  ,     . MODEL _ TYPE _ OF _ METHOD _ DESCRIPTOR ,    false )  ;", "constructorVisitor . visitFieldInsn ( PUTSTATIC ,    generatedType . getInternalName (  )  ,     . MANAGED _ TYPE _ FIELD _ NAME ,    Type . getDescriptor ( ModelType . class )  )  ;", "}", "METHOD_END"], "methodName": ["writeManagedTypeStaticField"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Label   start    =    new   Label (  )  ;", "Label   end    =    new   Label (  )  ;", "Label   handler    =    new   Label (  )  ;", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    method )  ;", "methodVisitor . visitTryCatchBlock ( start ,    end ,    handler ,    null )  ;", "setCanCallSettersField ( methodVisitor ,    gedType ,    false )  ;", "methodVisitor . visitLabel ( start )  ;", "invokeSuperMethod ( methodVisitor ,    managedTypeClass ,    method )  ;", "methodVisitor . visitLabel ( end )  ;", "setCanCallSettersField ( methodVisitor ,    gedType ,    true )  ;", "methodVisitor . visitInsn ( ARETURN )  ;", "methodVisitor . visitLabel ( handler )  ;", "setCanCallSettersField ( methodVisitor ,    gedType ,    true )  ;", "methodVisitor . visitInsn ( ATHROW )  ;", "methodVisitor . visitMaxs (  0  ,     0  )  ;", "methodVisitor . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["writeNonAbstractMethodWrapper"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "if    (  ! writable )     {", "String   setterName    =     \" set \"     +     ( StringUtils . capitalize ( property . getName (  )  )  )  ;", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    setterName ,     . SET _ OBJECT _ PROPERTY _ DESCRIPTOR ,    null ,     (  ( ACC _ PUBLIC )     |     ( ACC _ SYNTHETIC )  )  )  ;", "methodVisitor . visitTypeInsn ( NEW ,     . READ _ ONLY _ PROPERTY _ EXCEPTION _ TYPE )  ;", "methodVisitor . visitInsn ( DUP )  ;", "putConstantOnStack ( methodVisitor ,    property . getName (  )  )  ;", "putClassOnStack ( methodVisitor ,    viewClass )  ;", "methodVisitor . visitMethodInsn ( INVOKESPECIAL ,     . READ _ ONLY _ PROPERTY _ EXCEPTION _ TYPE ,     \"  < init >  \"  ,     . MISSING _ PROPERTY _ CONSTRUCTOR _ DESCRIPTOR ,    false )  ;", "finishVisitingMethod ( methodVisitor ,    ATHROW )  ;", "}", "}", "METHOD_END"], "methodName": ["writeReadOnlySetter"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    setter    =    property . getAccessor ( SETTER )  ;", "if    (  ( setter    !  =    null )     &  &     (  ( property . getSchema (  )  )    instanceof   ScalarValueSchema )  )     {", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    property . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . OBJECT _ TYPE )  ,    null )  ;", "putThisOnStack ( methodVisitor )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    generatedType . getInternalName (  )  ,    setter . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . OBJECT _ TYPE )  ,    false )  ;", "finishVisitingMethod ( methodVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSetMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Type   propertyType    =    Type . getType ( propertyClass )  ;", "Label   calledOutsideOfConstructor    =    new   Label (  )  ;", "Method   setter    =    weakSetter . getMethod (  )  ;", "String   methodDescriptor    =    Type . getMethodDescriptor ( VOID _ TYPE ,    propertyType )  ;", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    setter . getName (  )  ,    methodDescriptor ,    AsmUtils . signature ( setter )  )  ;", "putCanCallSettersFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "jumpToLabelIfStackEvaluatesToTrue ( methodVisitor ,    calledOutsideOfConstructor )  ;", "throwExceptionBecauseCalledOnItself ( methodVisitor )  ;", "methodVisitor . visitLabel ( calledOutsideOfConstructor )  ;", "putStateFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "putConstantOnStack ( methodVisitor ,    propertyName )  ;", "putFirstMethodArgumentOnStack ( methodVisitor ,    propertyType )  ;", "if    ( propertyClass . isPrimitive (  )  )     {", "boxType ( methodVisitor ,    propertyClass )  ;", "}", "invokeStateSetMethod ( methodVisitor )  ;", "finishVisitingMethod ( methodVisitor )  ;", "}", "METHOD_END"], "methodName": ["writeSetter"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   constructorVisitor    =    declareMethod ( visitor ,    AbstractProxyClassGenerator . STATIC _ CONSTRUCTOR _ NAME ,     \"  (  ) V \"  ,    AbstractProxyClassGenerator . CONCRETE _ SIGNATURE ,    ACC _ STATIC )  ;", "writeManagedTypeStaticField ( generatedType ,    managedTypeClass ,    constructorVisitor )  ;", "finishVisitingMethod ( constructorVisitor )  ;", "}", "METHOD_END"], "methodName": ["writeStaticConstructor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Method   toStringMethod    =    getToStringMethod ( viewClass )  ;", "if    (  ( toStringMethod    !  =    null )     &  &     (  !  ( toStringMethod . getDeclaringClass (  )  . equals ( Object . class )  )  )  )     {", "writeNonAbstractMethodWrapper ( visitor ,    gedType ,    viewClass ,    toStringMethod )  ;", "} else", "if    (  ( delegateSchema    !  =    null )     &  &     ( delegateSchema . hasProperty (  \" displayName \"  )  )  )     {", "writeDelegatingToString ( visitor ,    gedType ,    Type . getType ( delegateSchema . getType (  )  . getConcreteClass (  )  )  )  ;", "} else    {", "writeDefaultToString ( visitor ,    gedType )  ;", "}", "}", "METHOD_END"], "methodName": ["writeToString"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakSetter    =    property . getAccessor ( SETTER )  ;", "if    ( weakSetter    =  =    null )     {", "return ;", "}", "if    (  !  (  ( property . getSchema (  )  )    instanceof   ScalarValueSchema )  )     {", "return ;", "}", "Class <  ?  >    propertyClass    =    property . getType (  )  . getConcreteClass (  )  ;", "Type   propertyType    =    Type . getType ( propertyClass )  ;", "Class <  ?  >    boxedClass    =     ( propertyClass . isPrimitive (  )  )     ?     . BOXED _ TYPES . get ( propertyClass )     :    propertyClass ;", "Type   boxedType    =    Type . getType ( boxedClass )  ;", "Method   setter    =    weakSetter . getMethod (  )  ;", "MethodVisitor   methodVisitor    =    declareMethod ( visitor ,    setter . getName (  )  ,     . SET _ OBJECT _ PROPERTY _ DESCRIPTOR ,     . SET _ OBJECT _ PROPERTY _ DESCRIPTOR )  ;", "putThisOnStack ( methodVisitor )  ;", "putTypeConverterFieldValueOnStack ( methodVisitor ,    generatedType )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     1  )  ;", "methodVisitor . visitLdcInsn ( boxedType )  ;", "methodVisitor . visitInsn (  ( propertyClass . isPrimitive (  )     ?    ICONST _  1     :    ICONST _  0  )  )  ;", "Label   startTry    =    new   Label (  )  ;", "methodVisitor . visitLabel ( startTry )  ;", "methodVisitor . visitMethodInsn ( INVOKEINTERFACE ,     . TYPE _ CONVERTER _ TYPE . getInternalName (  )  ,     \" convert \"  ,     . COERCE _ TO _ SCALAR _ DESCRIPTOR ,    true )  ;", "Label   endTry    =    new   Label (  )  ;", "methodVisitor . visitLabel ( endTry )  ;", "methodVisitor . visitTypeInsn ( CHECKCAST ,    boxedType . getInternalName (  )  )  ;", "if    ( propertyClass . isPrimitive (  )  )     {", "unboxType ( methodVisitor ,    propertyClass )  ;", "}", "methodVisitor . visitMethodInsn ( INVOKEVIRTUAL ,    generatedType . getInternalName (  )  ,    setter . getName (  )  ,    Type . getMethodDescriptor ( VOID _ TYPE ,    propertyType )  ,    false )  ;", "methodVisitor . visitInsn ( RETURN )  ;", "Label   startCatch    =    new   Label (  )  ;", "methodVisitor . visitLabel ( startCatch )  ;", "methodVisitor . visitTryCatchBlock ( startTry ,    endTry ,    startCatch ,     . TYPE _ CONVERSION _ EXCEPTION _ TYPE . getInternalName (  )  )  ;", "methodVisitor . visitVarInsn ( ASTORE ,     2  )  ;", "putClassOnStack ( methodVisitor ,    viewClass )  ;", "methodVisitor . visitLdcInsn ( property . getName (  )  )  ;", "putFirstMethodArgumentOnStack ( methodVisitor )  ;", "methodVisitor . visitVarInsn ( ALOAD ,     2  )  ;", "methodVisitor . visitMethodInsn ( INVOKESTATIC ,    Type . getInternalName (  . class )  ,     \" propertyValueConvertFailure \"  ,    Type . getMethodDescriptor ( VOID _ TYPE ,     . CLASS _ TYPE ,     . STRING _ TYPE ,     . OBJECT _ TYPE ,     . TYPE _ CONVERSION _ EXCEPTION _ TYPE )  ,    false )  ;", "finishVisitingMethod ( methodVisitor )  ;", "}", "METHOD_END"], "methodName": ["writeTypeConvertingSetter"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Type   delegateType ;", "StructSchema <  ?  >    delegateSchema    =    bindings . getDelegateSchema (  )  ;", "if    ( delegateSchema    !  =    null )     {", "Class <  ?  >    delegateClass    =    delegateSchema . getType (  )  . getRawClass (  )  ;", "declareDelegateField ( visitor ,    delegateClass )  ;", "delegateType    =    Type . getType ( delegateClass )  ;", "} else    {", "delegateType    =    null ;", "}", "Multimap < String ,    ModelProperty <  ?  >  >    viewPropertiesByNameBuilder    =    ArrayListMultimap . create (  )  ;", "Set < Wrapper < Method >  >    viewMethods    =    Sets . newLinkedHashSet (  )  ;", "for    ( StructSchema <  ?  >    viewSchema    :    bindings . getImplementedViewSchemas (  )  )     {", "for    ( ModelType <  ?  >    viewType    :    viewTypes )     {", "if    ( viewType . equals ( viewSchema . getType (  )  )  )     {", "for    ( ModelProperty <  ?  >    property    :    viewSchema . getProperties (  )  )     {", "String   propertyName    =    property . getName (  )  ;", "viewPropertiesByNameBuilder . put ( propertyName ,    property )  ;", "}", "for    ( WeaklyTypeReferencingMethod <  ?  ,     ?  >    viewMethod    :    viewSchema . getAllMethods (  )  )     {", "viewMethods . add ( SIGNATURE _ EQUIVALENCE . wrap ( viewMethod . getMethod (  )  )  )  ;", "}", "break ;", "}", "}", "}", "Class <  ?  >    viewClass    =    bindings . getPublicSchema (  )  . getType (  )  . getConcreteClass (  )  ;", "for    ( Collection < ModelProperty <  ?  >  >    viewProperties    :    viewPropertiesByNameBuilder . asMap (  )  . values (  )  )     {", "writeViewPropertyDslMethods ( visitor ,    generatedType ,    viewProperties ,    viewClass )  ;", "}", "for    ( StructMethodBinding   methodBinding    :    bindings . getMethodBindings (  )  )     {", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    weakViewMethod    =    methodBinding . getViewMethod (  )  ;", "Method   viewMethod    =    weakViewMethod . getMethod (  )  ;", "Wrapper < Method >    methodKey    =    SIGNATURE _ EQUIVALENCE . wrap ( viewMethod )  ;", "if    (  !  ( viewMethods . contains ( methodKey )  )  )     {", "continue ;", "}", "if    ( methodBinding   instanceof   DirectMethodBinding )     {", "boolean   isGetterMethod    =     (  ( methodBinding . getAccessorType (  )  )     =  =     ( GET _ GETTER )  )     |  |     (  ( methodBinding . getAccessorType (  )  )     =  =     ( IS _ GETTER )  )  ;", "if    (  ( isGetterMethod    &  &     (  !  ( Modifier . isFinal ( viewMethod . getModifiers (  )  )  )  )  )     &  &     (  !  ( viewMethod . getName (  )  . equals (  \" getMetaClass \"  )  )  )  )     {", "writeNonAbstractMethodWrapper ( visitor ,    generatedType ,    viewClass ,    viewMethod )  ;", "}", "} else", "if    ( methodBinding   instanceof   binding . BridgeMethodBinding )     {", "writeBridgeMethod ( visitor ,    generatedType ,    viewMethod )  ;", "} else", "if    ( methodBinding   instanceof   binding . DelegateMethodBinding )     {", "writeDelegatingMethod ( visitor ,    generatedType ,    delegateType ,    viewMethod )  ;", "} else", "if    ( methodBinding   instanceof   binding . ManagedPropertyMethodBinding )     {", "binding . ManagedPropertyMethodBinding   propertyBinding    =     (  ( binding . ManagedPropertyMethodBinding )     ( methodBinding )  )  ;", "binding . ManagedProperty <  ?  >    managedProperty    =    bindings . getManagedProperty ( propertyBinding . getPropertyName (  )  )  ;", "String   propertyName    =    managedProperty . getName (  )  ;", "Class <  ?  >    propertyClass    =    managedProperty . getType (  )  . getRawClass (  )  ;", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    propertyAccessor    =    propertyBinding . getViewMethod (  )  ;", "switch    ( propertyBinding . getAccessorType (  )  )     {", "case   GET _ GETTER    :", "case   IS _ GETTER    :", "writeGetter ( visitor ,    generatedType ,    propertyName ,    propertyClass ,    propertyAccessor )  ;", "break ;", "case   SETTER    :", "writeSetter ( visitor ,    generatedType ,    propertyName ,    propertyClass ,    propertyAccessor )  ;", "break ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "} else    {", "throw   new   AssertionError (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["writeViewMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "boolean   writable    =    Iterables . any ( viewProperties ,    new   com . google . common . base . Predicate < ModelProperty <  ?  >  >  (  )     {", "@ Override", "public   boolean   apply ( ModelProperty <  ?  >    viewProperty )     {", "return   viewProperty . isWritable (  )  ;", "}", "}  )  ;", "ModelProperty <  ?  >    firstProperty    =    viewProperties . it (  )  . next (  )  ;", "writeConfigureMethod ( visitor ,    generatedType ,    firstProperty ,    writable )  ;", "writeSetMethod ( visitor ,    generatedType ,    firstProperty )  ;", "writeTypeConvertingSetter ( visitor ,    generatedType ,    viewClass ,    firstProperty )  ;", "writeReadOnlySetter ( visitor ,    viewClass ,    writable ,    firstProperty )  ;", "}", "METHOD_END"], "methodName": ["writeViewPropertyDslMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ManagedProxyClassGenerator"}, {"methodBody": ["METHOD_START", "{", "final   ModelMapSchema < T ,    E >    schema    =    new   ModelMapSchema < T ,    E >  ( extractionContext . getType (  )  ,    elementType )  ;", "extractionContext . child ( elementType ,     \" element   type \"  ,    new   Action < ModelSchema < E >  >  (  )     {", "@ Override", "public   void   execute ( ModelSchema < E >    elementTypeSchema )     {", "schema . setElementTypeSchema ( elementTypeSchema )  ;", "}", "}  )  ;", "return   schema ;", "}", "METHOD_END"], "methodName": ["getModelSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelMapStrategy"}, {"methodBody": ["METHOD_START", "{", "PropertyAccessorType   type    =    accessor . getAccessorType (  )  ;", "accessors . put ( type ,    accessor )  ;", "}", "METHOD_END"], "methodName": ["addAccessor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "PropertyAccessorExtractionContext   removedAccessor    =    accessors . remove ( type )  ;", "if    ( removedAccessor    !  =    null )     {", "droppedMethods . add ( removedAccessor . getMostSpecificDeclaration (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["dropInvalidAccessor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   accessors . get ( type )  ;", "}", "METHOD_END"], "methodName": ["getAccessor"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   accessors . values (  )  ;", "}", "METHOD_END"], "methodName": ["getAccessors"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet . Builder < ModelType <  ?  >  >    declaredBy    =    new   ImmutableSortedSet . Builder < ModelType <  ?  >  >  ( Ordering . usingToString (  )  )  ;", "for    ( PropertyAccessor   accessor    :    accessors . values (  )  )     {", "for    ( Method   method    :    accessor . getDeclaringMethods (  )  )     {", "declaredBy . add ( ModelType . declaringType ( method )  )  ;", "}", "}", "return   declaredBy . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredBy"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   hasGetter ( accessors . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["isReadable"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   hasSetter ( accessors . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "PropertyAccessorExtractionContext   getGetter    =    getAccessor ( GET _ GETTER )  ;", "PropertyAccessorExtractionContext   isGetter    =    getAccessor ( IS _ GETTER )  ;", "if    (  ( getGetter    =  =    null )     &  &     ( isGetter    =  =    null )  )     {", "return   null ;", "}", "Iterable < Method >    getMethods    =     ( getGetter    !  =    null )     ?    getGetter . getDeclaringMethods (  )     :    Collections .  < Method > emptyList (  )  ;", "Iterable < Method >    isMethods    =     ( isGetter    !  =    null )     ?    isGetter . getDeclaringMethods (  )     :    Collections .  < Method > emptyList (  )  ;", "return   new   PropertyAccessorExtractionContext ( PropertyAccessorType . GET _ GETTER ,    Iterables . concat ( getMethods ,    isMethods )  )  ;", "}", "METHOD_END"], "methodName": ["mergeGetters"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   accessors ;", "}", "METHOD_END"], "methodName": ["getAccessors"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionResult"}, {"methodBody": ["METHOD_START", "{", "return   property ;", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelPropertyExtractionResult"}, {"methodBody": ["METHOD_START", "{", "return   aspect ;", "}", "METHOD_END"], "methodName": ["getAspect"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaAspectExtractionResult"}, {"methodBody": ["METHOD_START", "{", "List < ModelSchemaAspect >    aspects    =    Lists . newArrayList (  )  ;", "for    ( ionStrategy   strategy    :    strategies )     {", "ionResult   result    =    strategy . extract ( extractionContext ,    propertyResults )  ;", "if    ( result    !  =    null )     {", "aspects . add ( result . getAspect (  )  )  ;", "}", "}", "return   aspects ;", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaAspectExtractor"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    declaringMethods )     {", "if    ( Proxy . isProxyClass ( method . getDeclaringClass (  )  )  )     {", "continue ;", "}", "return   method ;", "}", "throw   new   IllegalArgumentException (  (  \" Cannot   find   most - specific   declaration   of   method .    Declarations   cked :     \"     +    declaringMethods )  )  ;", "}", "METHOD_END"], "methodName": ["findMostSpecificMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaUtils"}, {"methodBody": ["METHOD_START", "{", "final   Builder < String ,    Method >    methodsByNameBuilder    =    ImmutableListMultimap . builder (  )  ;", "walkTypeHierarchy ( clazz ,     . IGNORED _ OBJECT _ TYPES ,    new   TypeVisitor < T >  (  )     {", "@ Override", "public   void   visitType ( Class <  ?    super   T >    type )     {", "Method [  ]    declaredMethods    =    type . getDeclaredMethods (  )  ;", "Arrays . sort ( declaredMethods ,    Ordering . usingToString (  )  )  ;", "for    ( Method   method    :    declaredMethods )     {", "if    (  . isIgnoredMethod ( method )  )     {", "continue ;", "}", "methodsByNameBuilder . put ( method . getName (  )  ,    method )  ;", "}", "}", "}  )  ;", "ImmutableListMultimap < String ,    Method >    methodsByName    =    methodsByNameBuilder . build (  )  ;", "ImmutableSortedMap . Builder < String ,    Map < Equivalence . Wrapper < Method >  ,    Collection < Method >  >  >    candidatesBuilder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( String   methodName    :    methodsByName . keySet (  )  )     {", "ImmutableList < Method >    methodsWithSameName    =    methodsByName . get ( methodName )  ;", "ListMultimap < Equivalence . Wrapper < Method >  ,    Method >    equivalenceIndex    =    Multimaps . index ( methodsWithSameName ,    new   com . google . common . base . Function < Method ,    Equivalence . Wrapper < Method >  >  (  )     {", "@ Override", "public   Equivalence . Wrapper < Method >    apply ( Method   method )     {", "return   SIGNATURE _ EQUIVALENCE . wrap ( method )  ;", "}", "}  )  ;", "candidatesBuilder . put ( methodName ,    equivalenceIndex . asMap (  )  )  ;", "}", "return   new   CandidateMethods ( candidatesBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaUtils"}, {"methodBody": ["METHOD_START", "{", "int   modifiers    =    method . getModifiers (  )  ;", "if    (  ( method . isSynthetic (  )  )     |  |     ( Modifier . isStatic ( modifiers )  )  )     {", "return   true ;", "}", "return   GroovyMethods . isObjectMethod ( method )  ;", "}", "METHOD_END"], "methodName": ["isIgnoredMethod"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaUtils"}, {"methodBody": ["METHOD_START", "{", "Method   mostSpecificDeclaration    =    ModelSchemaUtils . findMostSpecificMethod ( declarations )  ;", "return   ModelSchemaUtils . isMethodDeclaredInManagedType ( mostSpecificDeclaration )  ;", "}", "METHOD_END"], "methodName": ["isMethodDeclaredInManagedType"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaUtils"}, {"methodBody": ["METHOD_START", "{", "return   method . getDeclaringClass (  )  . isAnnotationPresent ( Managed . class )  ;", "}", "METHOD_END"], "methodName": ["isMethodDeclaredInManagedType"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSchemaUtils"}, {"methodBody": ["METHOD_START", "{", "final   CollectionSchema < T ,    E >    schema    =    new   ModelSetSchema < T ,    E >  ( extractionContext . getType (  )  ,    elementType )  ;", "extractionContext . child ( elementType ,     \" element   type \"  ,    new   Action < ModelSchema < E >  >  (  )     {", "@ Override", "public   void   execute ( ModelSchema < E >    elementTypeSchema )     {", "schema . setElementTypeSchema ( elementTypeSchema )  ;", "}", "}  )  ;", "return   schema ;", "}", "METHOD_END"], "methodName": ["getModelSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.ModelSetStrategy"}, {"methodBody": ["METHOD_START", "{", "Object   defaultValue    =    PrimitiveTypes . TYPES _ DEFAULT _ VALUES . get ( primitiveModelType )  ;", "if    ( defaultValue    =  =    null )     {", "throw   new   IllegalArgumentException (  ( primitiveModelType    +     \"    is   not   a   primitive   type .  \"  )  )  ;", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["defaultValueOf"], "fileName": "org.gradle.model.internal.manage.schema.extract.PrimitiveTypes"}, {"methodBody": ["METHOD_START", "{", "return   PrimitiveTypes . TYPES _ DEFAULT _ VALUES . containsKey ( modelType )  ;", "}", "METHOD_END"], "methodName": ["isPrimitiveType"], "fileName": "org.gradle.model.internal.manage.schema.extract.PrimitiveTypes"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?    extends   Annotation >  ,    Annotation >    annotations    =    Maps . newLinkedHashMap (  )  ;", "for    ( Method   method    :    methods )     {", "for    ( Annotation   annotation    :    method . getDeclaredAnnotations (  )  )     {", "if    (  !  ( annotations . containsKey ( annotation . annotationType (  )  )  )  )     {", "annotations . put ( annotation . annotationType (  )  ,    annotation )  ;", "}", "}", "}", "return   Colles . unmodifiableMap ( annotations )  ;", "}", "METHOD_END"], "methodName": ["collectAnnotations"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   accessorType ;", "}", "METHOD_END"], "methodName": ["getAccessorType"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( annotations . get ( annotationType )  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotation"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   annotations . values (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   declaringMethods ;", "}", "METHOD_END"], "methodName": ["getDeclaringMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "List < Method >    getters ;", "if    (  ( mostSpecificDeclaration . getReturnType (  )  )     =  =     ( Boolean . TYPE )  )     {", "getters    =    Lists . newArrayList (  )  ;", "for    ( Method   getter    :    declaringMethods )     {", "if    ( Proxy . isProxyClass ( getter . getDeclaringClass (  )  )  )     {", "continue ;", "}", "getters . add ( getter )  ;", "}", "} else    {", "getters    =    Colles . singletonList ( mostSpecificDeclaration )  ;", "}", "return   getters ;", "}", "METHOD_END"], "methodName": ["getGetters"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   mostSpecificDeclaration ;", "}", "METHOD_END"], "methodName": ["getMostSpecificDeclaration"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   mostSpecificSignature ;", "}", "METHOD_END"], "methodName": ["getMostSpecificSignature"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   annotations . containsKey ( annotationType )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   declaredAsAbstract ;", "}", "METHOD_END"], "methodName": ["isDeclaredAsAbstract"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   declaredInManagedType ;", "}", "METHOD_END"], "methodName": ["isDeclaredInManagedType"], "fileName": "org.gradle.model.internal.manage.schema.extract.PropertyAccessorExtractionContext"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( modelNode . getPrivateData ( Collection . class )  )  ;", "}", "METHOD_END"], "methodName": ["getBackingValue"], "fileName": "org.gradle.model.internal.manage.schema.extract.ScalarCollectionModelView"}, {"methodBody": ["METHOD_START", "{", "Collection < E >    delegate    =    initialValue (  )  ;", "setBackingValue ( delegate )  ;", "return   delegate ;", "}", "METHOD_END"], "methodName": ["initializeEmptyCollection"], "fileName": "org.gradle.model.internal.manage.schema.extract.ScalarCollectionModelView"}, {"methodBody": ["METHOD_START", "{", "if    ( state . isCanMutate (  )  )     {", "modelNode . setPrivateData (  . class ,    values )  ;", "}", "}", "METHOD_END"], "methodName": ["setBackingValue"], "fileName": "org.gradle.model.internal.manage.schema.extract.ScalarCollectionModelView"}, {"methodBody": ["METHOD_START", "{", "state . assertCanMutate (  )  ;", "if    ( values    =  =    null )     {", "setBackingValue ( null )  ;", "return   null ;", "} else    {", "< E >    objects    =    initializeEmpty (  )  ;", "objects . addAll (  (  (  <  ?    extends   E >  )     ( values )  )  )  ;", "return   objects ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.gradle.model.internal.manage.schema.extract.ScalarCollectionModelView"}, {"methodBody": ["METHOD_START", "{", "return   ScalarTypes . TYPES . contains ( modelType )  ;", "}", "METHOD_END"], "methodName": ["isScalarType"], "fileName": "org.gradle.model.internal.manage.schema.extract.ScalarTypes"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSetMultimap .  < ModelActionRole ,    ModelAction > builder (  )  . put ( ModelActionRole . Discover ,    DirectNodeNoInputsModelAction . of ( subject ,    descriptor ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode )     {", "ChildStrategyAccessor < E >    strategyAccessor    =    ChildStrategyAccessors . fromPrivateData (  )  ;", "Class <  ?    extends   T >    implementationType    =    schema . getImplementationType (  )  . asSubclass ( schema . getType (  )  . getConcreteClass (  )  )  ;", "modelNode . addProjection ( new   SpecializedModelMapProjection < T ,    E >  ( schema . getType (  )  ,    schema . getElementType (  )  ,    implementationType ,    strategyAccessor )  )  ;", "modelNode . addProjection ( ModelMapModelProjection . managed ( schema . getType (  )  ,    schema . getElementType (  )  ,    strategyAccessor )  )  ;", "}", "}  )  )  . put ( ModelActionRole . Create ,    DirectNodeInputUsingModelAction . of ( subject ,    descriptor ,    ModelReference . of ( Registry . class )  ,    new   BiAction < MutableModelNode ,    Registry >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    Registry   nodeInitializerRegistry )     {", "ChildStrategy < E >    childFactory    =    NodeBackedModelMap . createUsingRegistry ( nodeInitializerRegistry )  ;", "modelNode . setPrivateData ( ModelType . of ( ChildStrategy . class )  ,    childFactory )  ;", "}", "}  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "org.gradle.model.internal.manage.schema.extract.SpecializedMapNodeInitializer"}, {"methodBody": ["METHOD_START", "{", "final   SpecializedMapSchema < T ,    E >    schema    =    new   SpecializedMapSchema < T ,    E >  ( extractionContext . getType (  )  ,    elementType ,    implementationType )  ;", "extractionContext . child ( elementType ,     \" element   type \"  ,    new   Action < ModelSchema < E >  >  (  )     {", "@ Override", "public   void   execute ( ModelSchema < E >    elementTypeSchema )     {", "schema . setElementTypeSchema ( elementTypeSchema )  ;", "}", "}  )  ;", "return   schema ;", "}", "METHOD_END"], "methodName": ["getModelSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.SpecializedMapStrategy"}, {"methodBody": ["METHOD_START", "{", "return   new   Action < ModelSchema < P >  >  (  )     {", "@ Override", "public   void   execute ( ModelSchema < P >    propertySchema )     {", "property . setSchema ( propertySchema )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["attachSchema"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "Builder < PropertyAccessorType ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  >    accessors    =    ImmutableMap . builder (  )  ;", "for    ( PropertyAccessorContext   accessor    :    propertyContext . getAccessors (  )  )     {", "WeaklyTypeReferencingMethod <  ?  ,     ?  >    accessorMethod    =    WeaklyTypeReferencingMethod . of ( accessor . getMostSpecificDeclaration (  )  )  ;", "accessors . put ( accessor . getAccessorType (  )  ,    accessorMethod )  ;", "}", "ModelProperty < P >    property    =    new   ModelProperty < P >  ( propertyType ,    propertyContext . getPropertyName (  )  ,    propertyContext . getDeclaredBy (  )  ,    accessors . build (  )  )  ;", "return   new   ModelPropertyResult < P >  ( property ,    propertyContext . getAccessors (  )  )  ;", "}", "METHOD_END"], "methodName": ["createProperty"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "return   accessor    =  =    null    ?    null    :    ModelType . of ( accessor . getAccessorType (  )  . propertyTypeFor ( accessor . getMostSpecificDeclaration (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["determinePropertyType"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < ModelPropertyExtractionResult <  ?  >  >    builder    =    ImmutableList . builder (  )  ;", "for    ( ModelPropertyExtractionContext   propertyContext    :    properties )     {", "builder . add (  . extractProperty ( propertyContext )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["extractProperties"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "ModelType <  ?  >    propertyType    =    StructSchemaExtractionStrategySupport . determinePropertyType ( property . getAccessor ( GET _ GETTER )  )  ;", "if    ( propertyType    =  =    null )     {", "propertyType    =    StructSchemaExtractionStrategySupport . determinePropertyType ( property . getAccessor ( IS _ GETTER )  )  ;", "}", "if    ( propertyType    =  =    null )     {", "propertyType    =    StructSchemaExtractionStrategySupport . determinePropertyType ( property . getAccessor ( SETTER )  )  ;", "}", "return   StructSchemaExtractionStrategySupport . createProperty ( propertyType ,    property )  ;", "}", "METHOD_END"], "methodName": ["extractProperty"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "Set < Method >    nonPropertyMethods    =    Sets . newLinkedHashSet ( Iterables . transform ( candidateMethods . allMethods (  )  . keySet (  )  ,    new   com . google . common . base . Function < Wrapper < Method >  ,    Method >  (  )     {", "@ Override", "public   Method   apply ( Wrapper < Method >    method )     {", "return   method . get (  )  ;", "}", "}  )  )  ;", "for    ( ModelPropertyResult <  ?  >    extractedProperty    :    extractedProperties )     {", "for    ( PropertyAccessorContext   accessor    :    extractedProperty . getAccessors (  )  )     {", "nonPropertyMethods . removeAll ( accessor . getDeclaringMethods (  )  )  ;", "}", "}", "return   Sets . newLinkedHashSet ( Iterables . transform ( nonPropertyMethods ,    new   com . google . common . base . Function < Method ,    WeaklyTypeReferencingMethod <  ?  ,     ?  >  >  (  )     {", "@ Override", "public   WeaklyTypeReferencingMethod <  ?  ,     ?  >    apply ( Method   method )     {", "return   WeaklyTypeReferencingMethod . of ( method )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["getNonPropertyMethods"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( property . getDeclaredBy (  )  . size (  )  )     =  =     1  )     &  &     ( property . getDeclaredBy (  )  . contains ( parentContext . getType (  )  )  )  )     {", "return   String . format (  \" property    '  % s '  \"  ,    property . getName (  )  )  ;", "} else    {", "ImmutableSortedSet < String >    declaredBy    =    ImmutableSortedSet . copyOf ( Iterables . transform ( property . getDeclaredBy (  )  ,    Funs . toStringFun (  )  )  )  ;", "return   String . format (  \" property    '  % s '    declared   by    % s \"  ,    property . getName (  )  ,    Joiner . on (  \"  ,     \"  )  . join ( declaredBy )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyDescription"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ModelPropertyExtractionContext >    propertiesMap    =    Maps . newTreeMap (  )  ;", "for    ( Map . Entry < Wrapper < Method >  ,    Collection < Method >  >    entry    :    candidateMethods . allMethods (  )  . entrySet (  )  )     {", "Method   method    =    entry . getKey (  )  . get (  )  ;", "PropertyAccessorType   propertyAccessorType    =    PropertyAccessorType . of ( method )  ;", "Collection < Method >    methodsWithEqualSignature    =    entry . getValue (  )  ;", "if    ( propertyAccessorType    !  =    null )     {", "String   propertyName    =    propertyAccessorType . propertyNameFor ( method )  ;", "ModelPropertyExtractionContext   propertyContext    =    propertiesMap . get ( propertyName )  ;", "if    ( propertyContext    =  =    null )     {", "propertyContext    =    new   ModelPropertyExtractionContext ( propertyName )  ;", "propertiesMap . put ( propertyName ,    propertyContext )  ;", "}", "propertyContext . addAccessor ( new   PropertyAccessorExtractionContext ( propertyAccessorType ,    methodsWithEqualSignature )  )  ;", "}", "}", "return   Collections 2  . filter ( propertiesMap . values (  )  ,    new   com . google . common . base . Predicate < ModelPropertyExtractionContext >  (  )     {", "@ Override", "public   boolean   apply ( ModelPropertyExtractionContext   property )     {", "return   property . isReadable (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["selectProperties"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "ModelProperty < P >    property    =    propertyResult . getProperty (  )  ;", "String   propertyDescription    =     . propertyDescription ( parentContext ,    property )  ;", "parentContext . child ( property . getType (  )  ,    propertyDescription ,     . attachSchema ( property )  )  ;", "}", "METHOD_END"], "methodName": ["toPropertyExtractionContext"], "fileName": "org.gradle.model.internal.manage.schema.extract.StructSchemaExtractionStrategySupport"}, {"methodBody": ["METHOD_START", "{", "return   getMethod (  )  . getAnnotations (  )  ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   declaringType ;", "}", "METHOD_END"], "methodName": ["getDeclaringType"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   paramTypes ;", "}", "METHOD_END"], "methodName": ["getGenericParameterTypes"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    paramTypesArray    =    Iterables . toArray ( Iterables . transform ( paramTypes ,    new   com . google . common . base . Function < ModelType <  ?  >  ,    Class <  ?  >  >  (  )     {", "public   Class <  ?  >    apply ( ModelType <  ?  >    modelType )     {", "return   modelType . getRawClass (  )  ;", "}", "}  )  ,    Class . class )  ;", "try    {", "return   declaringType . getRawClass (  )  . getDeclared ( name ,    paramTypesArray )  ;", "}    catch    ( NoSuchException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   modifiers ;", "}", "METHOD_END"], "methodName": ["getModifiers"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   returnType ;", "}", "METHOD_END"], "methodName": ["getReturnType"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "Method    =    getMethod (  )  ;", "setAccessible ( true )  ;", "try    {", "Object   result    =    invoke ( target ,    args )  ;", "return   returnType . getConcreteClass (  )  . cast ( result )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   call    % s .  % s (  )    on    % s \"  ,    getDeclaringClass (  )  . getSimpleName (  )  ,    getName (  )  ,    target )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   WeaklyTypeReferencingMethod . of ( ModelType . declaringType ( method )  ,    ModelType . returnType ( method )  ,    method )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   new   WeaklyTypeReferencingMethod < T ,    R >  ( target ,    returnType ,    method )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.method.WeaklyTypeReferencingMethod"}, {"methodBody": ["METHOD_START", "{", "return   reference ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.gradle.model.internal.registry.BindingPredicate"}, {"methodBody": ["METHOD_START", "{", "return   reference . getScope (  )  ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.model.internal.registry.BindingPredicate"}, {"methodBody": ["METHOD_START", "{", "return   reference . getState (  )  ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.model.internal.registry.BindingPredicate"}, {"methodBody": ["METHOD_START", "{", "return   reference . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.registry.BindingPredicate"}, {"methodBody": ["METHOD_START", "{", "return    ( reference . isUntyped (  )  )     |  |     ( node . canBeViewedAs ( reference . getType (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.gradle.model.internal.registry.BindingPredicate"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < ModelActionRole ,     ?    extends   ModelAction >    entry    :    actions . entries (  )  )     {", "ModelActionRole   role    =    entry . getKey (  )  ;", "ModelAction   action    =    entry . getValue (  )  ;", ". checkNodePath ( node ,    action )  ;", "RuleBinder   binder    =    bindInternal ( action . getSubject (  )  ,    role ,    action )  ;", "node . addRegistrationActionBinder ( binder )  ;", "}", "}", "METHOD_END"], "methodName": ["addRuleBindings"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "return   atStateOrMaybeLater ( path ,    state ,    false )  ;", "}", "METHOD_END"], "methodName": ["atState"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   node    =    modelGraph . find ( path )  ;", "if    ( node    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   model   node   at    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "transition ( node ,    state ,    laterOk )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["atStateOrMaybeLater"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "BindingPredicate   mappedSubject    =    mapSubject ( subject ,    role )  ;", "L < BindingPredicate >    mappedInputs    =    mapInputs ( mutator . getInputs (  )  )  ;", "RuleBinder   binder    =    new   RuleBinder ( mappedSubject ,    mappedInputs ,    mutator ,    unboundRules )  ;", "ruleBindings . add ( binder )  ;", "return   binder ;", "}", "METHOD_END"], "methodName": ["bindInternal"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . getPath (  )  . equals ( action . getSubject (  )  . getPath (  )  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Element   action   reference   has   path    (  % s )    which   does   not   reference   this   node    (  % s )  .  \"  ,    action . getSubject (  )  . getPath (  )  ,    node . getPath (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNodePath"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node   instanceof   ModelReferenceNode )  )     {", "for    ( ModelNodeInternal   childNode    :    node . getLinks (  )  )     {", "ensureCanRemove ( childNode ,    nodesToRemove )  ;", "}", "}", "if    (  !  ( Iterables . isEmpty ( node . getDependents (  )  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Tried   to   remove   model    '  % s '    but   it   is   depended   on   by :     '  % s '  \"  ,    node . getPath (  )  ,    Joiner . on (  \"  ,     \"  )  . join ( node . getDependents (  )  )  )  )  ;", "}", "nodesToRemove . add ( node )  ;", "}", "METHOD_END"], "methodName": ["ensureCanRemove"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "final   List < ModelView <  ?  >  >    inputs    =    toViews ( boundMutator . getInputBindings (  )  ,    boundMutator . getAction (  )  . getDescriptor (  )  )  ;", "ModelBinding   subjectBinding    =    boundMutator . getSubjectBinding (  )  ;", "final   ModelNodeInternal   node    =    subjectBinding . getNode (  )  ;", "final   ModelAction   mutator    =    boundMutator . getAction (  )  ;", "ModelRuleDescriptor   descriptor    =    mutator . getDescriptor (  )  ;", ". LOGGER . debug (  \" Project    {  }     -    Mutating    {  }    using    {  }  \"  ,    projectPath ,    node . getPath (  )  ,    descriptor )  ;", "try    {", "RuleContext . run ( descriptor ,    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "mutator . execute ( node ,    inputs )  ;", "}", "}  )  ;", "}    catch    ( Throwable   e )     {", "throw   new   ModelRuleExecutionException ( descriptor ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["fireAction"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "DefaultModelRegistry . GoalGraph   graph    =    new   DefaultModelRegistry . GoalGraph (  )  ;", "transitionTo ( graph ,    graph . nodeAtState ( new   NodeAtState ( path ,    ModelNode . State . Registered )  )  )  ;", "ModelNodeInternal   node    =    modelGraph . find ( path )  ;", "if    ( node    =  =    null )     {", "return   null ;", "}", "transitionTo ( graph ,    graph . nodeAtState ( new   NodeAtState ( path ,    ModelNode . State . GraphClosed )  )  )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( inputs . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "ArrayList < BindingPredicate >    result    =    new   ArrayList < BindingPredicate >  ( inputs . size (  )  )  ;", "for    ( ference <  ?  >    input    :    inputs )     {", "if    (  (  ( input . getPath (  )  )     =  =    null )     &  &     (  ( input . getScope (  )  )     =  =    null )  )     {", "result . add ( new   BindingPredicate ( input . inScope ( ModelPath . ROOT )  )  )  ;", "} else    {", "result . add ( new   BindingPredicate ( input )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["mapInputs"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( role . isSubjectViewAvailable (  )  )  )     &  &     (  !  ( subjectReference . isUntyped (  )  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   bind   subject    '  % s '    to   role    '  % s '    because   it   is   targeting   a   type   and   subject   types   are   not   yet   available   in   that   role \"  ,    subjectReference ,    role )  )  ;", "}", "return   new   BindingPredicate ( subjectReference . atState ( role . getTargetState (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mapSubject"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "return   modelGraph . find ( path )  ;", "}", "METHOD_END"], "methodName": ["node"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "modelGraph . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["registerListener"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   node    =    get ( path )  ;", "if    ( node    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" No   model   node   at    '  \"     +    path )     +     \"  '  \"  )  )  ;", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "List < String >    path    =    new   ArrayList < String >  (  )  ;", "int   pos    =    queue . indexOf ( brokenGoal )  ;", "ListIterator <  . ModelGoal >    iterator    =    queue . listIterator (  ( pos    +     1  )  )  ;", "while    ( iterator . hasPrevious (  )  )     {", ". ModelGoal   goal    =    iterator . previous (  )  ;", "goal . attachToCycle ( path )  ;", "}", "brokenGoal . attachToCycle ( path )  ;", "Formatter   out    =    new   Formatter (  )  ;", "out . format (  \" A   cycle   has   been   detected   in   model   rule   dependencies .    References   forming   the   cycle :  \"  )  ;", "String   last    =    null ;", "StringBuilder   indent    =    new   StringBuilder (  \"  \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( path . size (  )  )  ;    i +  +  )     {", "String   node    =    path . get ( i )  ;", "if    ( node . equals ( last )  )     {", "continue ;", "}", "last    =    node ;", "if    ( i    =  =     0  )     {", "out . format (  \"  % n % s % s \"  ,    indent ,    node )  ;", "} else    {", "out . format (  \"  % n % s \\  \\  -     % s \"  ,    indent ,    node )  ;", "indent . append (  \"           \"  )  ;", "}", "}", "return   new   ConfigurationCycleException ( out . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["ruleCycle"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =    null )     {", "return   null ;", "} else    {", "return   node . asImmutable ( type ,    new   SimpleuleDescriptor ( msg )  )  . getInstance (  )  ;", "}", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "ModelView <  ?  >  [  ]    array    =    new   ModelView <  ?  >  [ bindings . size (  )  ]  ;", "int   i    =     0  ;", "for    ( ModelBinding   binding    :    bindings )     {", "ModelNodeI   element    =    binding . getNode (  )  ;", "ModelView <  ?  >    view    =    element . asImmutable ( binding . getPredicate (  )  . getType (  )  ,    descriptor )  ;", "array [  ( i +  +  )  ]     =    view ;", "}", "@ SuppressWarnings (  \" unchecked \"  )", "List < ModelView <  ?  >  >    views    =    Arrays . asList ( array )  ;", "return   views ;", "}", "METHOD_END"], "methodName": ["toViews"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "Deque < DefaultModelRegistry . ModelGoal >    queue    =    new   ArrayDeque < DefaultModelRegistry . ModelGoal >  (  )  ;", "queue . add ( targetGoal )  ;", "List < DefaultModelRegistry . ModelGoal >    newDependencies    =    new   ArrayList < DefaultModelRegistry . ModelGoal >  (  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "DefaultModelRegistry . ModelGoal   goal    =    queue . getFirst (  )  ;", "if    (  ( goal . state )     =  =     ( DefaultModelRegistry . ModelGoal . State . Achieved )  )     {", "queue . removeFirst (  )  ;", "continue ;", "}", "if    (  ( goal . state )     =  =     ( DefaultModelRegistry . ModelGoal . State . NotSeen )  )     {", "if    ( goal . isAchieved (  )  )     {", "goal . state    =    DefaultModelRegistry . ModelGoal . State . Achieved ;", "queue . removeFirst (  )  ;", "continue ;", "}", "}", "if    (  ( goal . state )     =  =     ( DefaultModelRegistry . ModelGoal . State . VisitingDependencies )  )     {", "goal . apply (  )  ;", "goal . state    =    DefaultModelRegistry . ModelGoal . State . Achieved ;", "queue . removeFirst (  )  ;", "continue ;", "}", "newDependencies . clear (  )  ;", "goal . attachNode (  )  ;", "boolean   done    =    goal . calculateDependencies ( goalGraph ,    newDependencies )  ;", "goal . state    =     ( done    |  |     ( newDependencies . isEmpty (  )  )  )     ?    DefaultModelRegistry . ModelGoal . State . VisitingDependencies    :    DefaultModelRegistry . ModelGoal . State . DiscoveringDependencies ;", "for    ( int   i    =     ( newDependencies . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "DefaultModelRegistry . ModelGoal   dependency    =    newDependencies . get ( i )  ;", "if    (  ( dependency . state )     =  =     ( DefaultModelRegistry . ModelGoal . State . Achieved )  )     {", "continue ;", "}", "if    (  ( dependency . state )     =  =     ( DefaultModelRegistry . ModelGoal . State . NotSeen )  )     {", "queue . addFirst ( dependency )  ;", "continue ;", "}", "throw   ruleCycle ( dependency ,    Lists . newArrayList ( queue )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["transitionTo"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "ModelPathSuggestionProvider   suggestionsProvider    =    new   ModelPathSuggestionProvider ( modelGraph . getFlattened (  )  . keySet (  )  )  ;", "List <  ?    extends   UnboundRule >    unboundRules    =    new   UnboundRulesProcessor ( binders ,    suggestionsProvider )  . process (  )  ;", "return   new   UnboundulesException ( unboundRules )  ;", "}", "METHOD_END"], "methodName": ["unbound"], "fileName": "org.gradle.model.internal.registry.DefaultModelRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( boundTo )     =  =    null )     {", "throw   new   IllegalStateException (  \" Target   n   has   not   been   bound .  \"  )  ;", "}", "return   boundTo ;", "}", "METHOD_END"], "methodName": ["getNode"], "fileName": "org.gradle.model.internal.registry.ModelBinding"}, {"methodBody": ["METHOD_START", "{", "return   predicate ;", "}", "METHOD_END"], "methodName": ["getPredicate"], "fileName": "org.gradle.model.internal.registry.ModelBinding"}, {"methodBody": ["METHOD_START", "{", "return    ( boundTo )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isBound"], "fileName": "org.gradle.model.internal.registry.ModelBinding"}, {"methodBody": ["METHOD_START", "{", "if    (  ( boundTo )     !  =    null )     {", "ModelRuleDescriptor   creatorDescriptor    =    node . getDescriptor (  )  ;", "ModelPath   path    =    node . getPath (  )  ;", "throw   new   InvalidModelRuleException ( referrer ,    new   ModelRuleException ( new   AmbiguousReporter ( predicate . getReference (  )  ,    boundTo . getPath (  )  ,    boundTo . getDescriptor (  )  ,    path ,    creatorDescriptor )  . asString (  )  )  )  ;", "}", "doOnBind ( node )  ;", "}", "METHOD_END"], "methodName": ["onBind"], "fileName": "org.gradle.model.internal.registry.ModelBinding"}, {"methodBody": ["METHOD_START", "{", "if    ( node    =  =     ( boundTo )  )     {", "boundTo    =    null ;", "}", "}", "METHOD_END"], "methodName": ["onUnbind"], "fileName": "org.gradle.model.internal.registry.ModelBinding"}, {"methodBody": ["METHOD_START", "{", "ModelPath   childPath    =    child . getPath (  )  ;", "if    (  !  ( getPath (  )  . isDirectChild ( childPath )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Element   registration   has   a   path    (  % s )    which   is   not   a   child   of   this   node    (  % s )  .  \"  ,    childPath ,    getPath (  )  )  )  ;", "}", "ModelNodeInternal   currentChild    =     (  ( links )     =  =    null )     ?    null    :    links . get ( childPath . getName (  )  )  ;", "if    ( currentChild    !  =    null )     {", "if    (  !  ( currentChild . isAtLeast ( ModelNode . State . Created )  )  )     {", "throw   new   DuplicateModelException ( String . format (  \" Cannot   create    '  % s '    using   creation   rule    '  % s '    as   the   rule    '  % s '    is   already   registered   to   create   this   model   element .  \"  ,    childPath ,     . describe ( registration . getDescriptor (  )  )  ,     . describe ( currentChild . getDescriptor (  )  )  )  )  ;", "}", "throw   new   DuplicateModelException ( String . format (  \" Cannot   create    '  % s '    using   creation   rule    '  % s '    as   the   rule    '  % s '    has   already   been   used   to   create   this   model   element .  \"  ,    childPath ,     . describe ( registration . getDescriptor (  )  )  ,     . describe ( currentChild . getDescriptor (  )  )  )  )  ;", "}", "if    (  !  ( isMutable (  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   create    '  % s '    using   creation   rule    '  % s '    as   model   element    '  % s '    is   no   longer   mutable .  \"  ,    childPath ,     . describe ( registration . getDescriptor (  )  )  ,    getPath (  )  )  )  ;", "}", "if    (  ( links )     =  =    null )     {", "links    =    Maps . newTreeMap (  )  ;", "}", "links . put ( child . getPath (  )  . getName (  )  ,    child )  ;", "modelRegistry . registerNode ( child ,    registration . getActions (  )  )  ;", "}", "METHOD_END"], "methodName": ["addNode"], "fileName": "org.gradle.model.internal.registry.ModelElementNode"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   stringBuilder    =    new   StringBuilder (  )  ;", "descriptor . describeTo ( stringBuilder )  ;", "return   stringBuilder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["describe"], "fileName": "org.gradle.model.internal.registry.ModelElementNode"}, {"methodBody": ["METHOD_START", "{", "return    ( links )     =  =    null    ?    Collections .  < String > emptySet (  )     :    links . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getLinkNames"], "fileName": "org.gradle.model.internal.registry.ModelElementNode"}, {"methodBody": ["METHOD_START", "{", "if    ( notifying )     {", "pendingNodes . put ( node ,     . PendingState . ADD )  ;", "return ;", "}", "doAdd ( node )  ;", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "if    ( ModelPath . ROOT . equals ( listener . getAncestor (  )  )  )     {", "addEverythingListener ( listener )  ;", "return ;", "}", "ModelNodeI   ancestor    =    flattened . get ( listener . getAncestor (  )  )  ;", "if    ( ancestor    !  =    null )     {", "Deque < ModelNodeI >    queue    =    new   ArrayDeque < ModelNodeI >  (  )  ;", "queue . add ( ancestor )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "ModelNodeI   parent    =    queue . removeFirst (  )  ;", "for    ( ModelNodeI   node    :    parent . getLinks (  )  )     {", "maybeNotify ( node ,    listener )  ;", "queue . addFirst ( node )  ;", "}", "}", "}", "ancestorListeners . put ( listener . getAncestor (  )  ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addAncestorListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelNodeInternal   node    :    flattened . values (  )  )     {", "maybeNotify ( node ,    listener )  ;", "}", "listeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addEverythingListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "if    ( notifying )     {", "pendingLeners . add ( lener )  ;", "return ;", "}", "doAddLener ( lener )  ;", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   parent    =    flattened . get ( listener . getParent (  )  )  ;", "if    ( parent    !  =    null )     {", "for    ( ModelNodeInternal   node    :    parent . getLinks (  )  )     {", "maybeNotify ( node ,    listener )  ;", "}", "}", "parentListeners . put ( listener . getParent (  )  ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addParentListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   node    =    flattened . get ( listener . getPath (  )  )  ;", "if    ( node    !  =    null )     {", "maybeNotify ( node ,    listener )  ;", "}", "pathListeners . put ( listener . getPath (  )  ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addPathListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "flattened . put ( node . getPath (  )  ,    node )  ;", "if    ( node . isAtLeast ( Node . State . Discovered )  )     {", "doNotify ( node )  ;", "}", "}", "METHOD_END"], "methodName": ["doAdd"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "notifying    =    true ;", "{", "if    (  ( listener . getPath (  )  )     !  =    null )     {", "addPathListener ( listener )  ;", "return ;", "}", "if    (  ( listener . getParent (  )  )     !  =    null )     {", "addParentListener ( listener )  ;", "return ;", "}", "if    (  ( listener . getAncestor (  )  )     !  =    null )     {", "addAncestorListener ( listener )  ;", "return ;", "}", "addEverythingListener ( listener )  ;", "}    finally    {", "notifying    =    false ;", "}", "}", "METHOD_END"], "methodName": ["doAddListener"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "notifying    =    true ;", "try    {", "notifyListeners ( node ,    pathListeners . get ( node . getPath (  )  )  )  ;", "notifyListeners ( node ,    parentListeners . get ( node . getPath (  )  . getParent (  )  )  )  ;", "notifyListeners ( node ,    listeners )  ;", "if    (  !  ( ancestorListeners . isEmpty (  )  )  )     {", "for    ( Path   path    =    node . getPath (  )  . getParent (  )  ;    path    !  =    null ;    path    =    path . getParent (  )  )     {", "notifyListeners ( node ,    ancestorListeners . get ( path )  )  ;", "}", "}", "}    finally    {", "notifying    =    false ;", "}", "}", "METHOD_END"], "methodName": ["doNotify"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "return   flattened . get ( path )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( pendingListeners . isEmpty (  )  )  )     {", "doAddListener ( pendingListeners . remove (  0  )  )  ;", "}", "while    (  !  ( pendingNodes . isEmpty (  )  )  )     {", "Iterator < Map . Entry < ModelNodeInternal ,     . PendingState >  >    iPendingNodes    =    pendingNodes . entrySet (  )  . iterator (  )  ;", "Map . Entry < ModelNodeInternal ,     . PendingState >    entry    =    iPendingNodes . next (  )  ;", "iPendingNodes . remove (  )  ;", "ModelNodeInternal   pendingNode    =    entry . getKey (  )  ;", "switch    ( entry . getValue (  )  )     {", "case   ADD    :", "doAdd ( pendingNode )  ;", "break ;", "case   NOTIFY    :", "doNotify ( pendingNode )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   found    =    find ( path )  ;", "if    ( found    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Expected   model   node    @     '  \"     +    path )     +     \"  '    but   none   was   found \"  )  )  ;", "}", "return   found ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( flattened )  ;", "}", "METHOD_END"], "methodName": ["getFlattened"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( node . isAtLeast ( ModelNode . State . Discovered )  )  )     {", "return ;", "}", "listener . onDiscovered ( node )  ;", "}", "METHOD_END"], "methodName": ["maybeNotify"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "if    ( notifying )     {", "if    (  !  ( pendingNodes . containsKey ( node )  )  )     {", "pendingNodes . put ( node ,     . PendingState . NOTIFY )  ;", "}", "return ;", "}", "doNotify ( node )  ;", "flush (  )  ;", "}", "METHOD_END"], "methodName": ["nodeDiscovered"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "for    ( ModelListener   listener    :    listeners )     {", "maybeNotify ( node ,    listener )  ;", "}", "}", "METHOD_END"], "methodName": ["notifyListeners"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "ModelNodeInternal   parentNode    =    find ( node . getPath (  )  . getParent (  )  )  ;", "if    ( parentNode    !  =    null )     {", "parentNode . removeLink ( node . getPath (  )  . getName (  )  )  ;", "}", "return   flattened . remove ( node . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.model.internal.registry.ModelGraph"}, {"methodBody": ["METHOD_START", "{", "if    (  ( registrationActionBinders )     =  =    null )     {", "registrationActionBinders    =    Lists . newArrayList (  )  ;", "}", "registrationActionBinders . add ( binder )  ;", "}", "METHOD_END"], "methodName": ["addRegistrationActionBinder"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( state . isAtLeast ( ModelNode . State . Created )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   get   adapter   for    '  % s '    in   state    % s .  \"  ,    getPath (  )  ,    state )  )  ;", "}", "return   toProjection (  )  ;", "}", "METHOD_END"], "methodName": ["getAdapter"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( dependencies )     =  =    null    ?    Collections .  < ModelNode > emptyList (  )     :    dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( dependents )     =  =    null    ?    Collections .  < ModelNode > emptyList (  )     :    dependents ;", "}", "METHOD_END"], "methodName": ["getDependents"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "return   toProjection (  )  ;", "}", "METHOD_END"], "methodName": ["getProjection"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( state . isAtLeast ( ModelNode . State . Discovered )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   get   promise   for    '  % s '    in   state    % s .  \"  ,    getPath (  )  ,    state )  )  ;", "}", "return   toProjection (  )  ;", "}", "METHOD_END"], "methodName": ["getPromise"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( registrationActionBinders )     =  =    null    ?    Collections .  < RuleBinder > emptyList (  )     :    registrationActionBinders ;", "}", "METHOD_END"], "methodName": ["getRegistrationActionBinders"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "assert   binder . isBound (  )     :     \" RuleBinder   must   be   in   a   bound   state \"  ;", "for    ( ModelBinding   inputBinding    :    binder . getInputBindings (  )  )     {", "node    =    inputBinding . getNode (  )  ;", "if    (  ( dependencies )     =  =    null )     {", "dependencies    =    Sets . newHashSet (  )  ;", "}", "dependencies . add ( node )  ;", "if    (  ( node . dependents )     =  =    null )     {", "node . dependents    =    Sets . newHashSet (  )  ;", "}", "node . dependents . add ( this )  ;", "}", "if    (  ( executedRules )     =  =    null )     {", "executedRules    =    Lists . newArrayList (  )  ;", "}", "executedRules . add ( binder . getDescriptor (  )  )  ;", "}", "METHOD_END"], "methodName": ["notifyFired"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "this . state    =    state ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  ( projections )     =  =    null )     {", "return   EmptyProjection . INSTANCE ;", "}", "return   new   ChainingProjection ( projections )  ;", "}", "METHOD_END"], "methodName": ["toProjection"], "fileName": "org.gradle.model.internal.registry.ModelNodeInternal"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.gradle.model.internal.registry.ModelReferenceNode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reference . getPath (  )  )     !  =    null )     {", "return   new   PathBinderCreationListener ( descriptor ,    reference ,    writable ,    bindAction )  ;", "}", "return   new   OneOfTypCreationListener ( descriptor ,    reference ,    writable ,    bindAction )  ;", "}", "METHOD_END"], "methodName": ["binding"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "return   action . getDescriptor (  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "return   inputBindings ;", "}", "METHOD_END"], "methodName": ["getInputBindings"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "return   subjectBinding ;", "}", "METHOD_END"], "methodName": ["getSubjectBinding"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "if    ( inputReferences . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "List < ModelBinding >    bindings    =    new   ArrayList < ModelBinding >  ( inputReferences . size (  )  )  ;", "for    ( BindingPredicate   inputReference    :    inputReferences )     {", "bindings . add (  . binding ( inputReference ,    descriptor ,    false ,    inputBindAction )  )  ;", "}", "return   bindings ;", "}", "METHOD_END"], "methodName": ["inputBindings"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "return    ( subjectBinding . isBound (  )  )     &  &     (  ( inputsBound )     =  =     ( inputReferences . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isBound"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "if    ( isBound (  )  )     {", "bs . remove ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeFire"], "fileName": "org.gradle.model.internal.registry.RuleBinder"}, {"methodBody": ["METHOD_START", "{", "addRule ( ruleBinder ,    rulesBySubject ,    ruleBinder . getSubjectBinding (  )  )  ;", "for    ( ModelBinding   binding    :    ruleBinder . getInput (  )  )     {", "addRule ( ruleBinder ,    rulesByInput ,    binding )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "RuleBindings . Reference   reference    =    new   RuleBindings . Reference ( rule ,    index ,    binding )  ;", "BindingPredicate   predicate    =    binding . getPredicate (  )  ;", "if    (  ( predicate . getPath (  )  )     !  =    null )     {", "if    (  ( predicate . getScope (  )  )     !  =    null )     {", "throw   new   UnsupportedOperationException (  \" Currently   not   implemented \"  )  ;", "}", "if    ( reference . binding . canBindInState ( ModelNode . State . Registered )  )     {", "untypedPathReferences . addReference ( reference )  ;", "} else    {", "typedPathReferences . addReference ( reference )  ;", "}", "} else", "if    (  ( predicate . getScope (  )  )     !  =    null )     {", "scopeReferences . addReference ( reference )  ;", "} else    {", "throw   new   UnsupportedOperationException (  \" Currently   not   implemented \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "ModelBinding   binding    =    reference . binding ;", "binding . onBind ( node )  ;", "reference . index . put ( new   NodeAtState ( node . getPath (  )  ,    binding . predicate . getState (  )  )  ,    reference . owner )  ;", "}", "METHOD_END"], "methodName": ["bound"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "return   rulesByInput . get ( input )  ;", "}", "METHOD_END"], "methodName": ["getRulesWithInput"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "return   rulesBySubject . get ( target )  ;", "}", "METHOD_END"], "methodName": ["getRulesWithSubject"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "untypedPathReferences . addNode ( node )  ;", "}", "METHOD_END"], "methodName": ["nodeCreated"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "typedPathReferences . addNode ( node )  ;", "scopeReferences . addNodeToScope ( node . getPath (  )  ,    node )  ;", "scopeReferences . addNodeToScope ( node . getPath (  )  . getParent (  )  ,    node )  ;", "}", "METHOD_END"], "methodName": ["nodeDiscovered"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "untypedPathReferences . removeNode ( node )  ;", "typedPathReferences . removeNode ( node )  ;", "scopeReferences . removeNodeFromScope ( node . getPath (  )  ,    node )  ;", "scopeReferences . removeNodeFromScope ( node . getPath (  )  . getParent (  )  ,    node )  ;", "rulesBySubject . nodeRemoved ( node )  ;", "rulesByInput . nodeRemoved ( node )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "rule . getSubjectBinding (  )  . onUnbind ( node )  ;", "for    ( ModelBinding   binding    :    rule . getInput (  )  )     {", "binding . onUnbind ( node )  ;", "}", "}", "METHOD_END"], "methodName": ["unbind"], "fileName": "org.gradle.model.internal.registry.RuleBindings"}, {"methodBody": ["METHOD_START", "{", "return   RuleContext . STACK . get (  )  . peek (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.internal.registry.RuleContext"}, {"methodBody": ["METHOD_START", "{", "RuleContext . STACK . get (  )  . push ( descriptor )  ;", "try    {", "runnable . run (  )  ;", "}    finally    {", "RuleContext . STACK . get (  )  . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.model.internal.registry.RuleContext"}, {"methodBody": ["METHOD_START", "{", "return   rules ;", "}", "METHOD_END"], "methodName": ["getRules"], "fileName": "org.gradle.model.internal.registry.UnboundModelRulesException"}, {"methodBody": ["METHOD_START", "{", "StringWriter   string    =    new   StringWriter (  )  ;", "PrintWriter   writer    =    new   PrintWriter ( string )  ;", "writer . println (  . MESSAGE )  ;", "writer . println (  )  ;", "new   UnboundRulesReporter ( writer ,     \"        \"  )  . reportOn ( rules )  ;", "return   string . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.model.internal.registry.UnboundModelRulesException"}, {"methodBody": ["METHOD_START", "{", "List < UnboundRule >    unboundRules    =    new   ArrayList < UnboundRule >  (  )  ;", "for    ( RuleBinder   binder    :    binders )     {", "UnboundRule . Builder   builder    =    UnboundRule . descriptor ( String . valueOf ( binder . getDescriptor (  )  )  )  ;", "ModelBinding   subjectBinding    =    binder . getSubjectBinding (  )  ;", "if    (  ( subjectBinding . getPredicate (  )  . getState (  )  . compareTo ( ModelNode . State . Created )  )     >     0  )     {", "UnboundRuleInput . Builder   inputBuilder    =    toInputBuilder ( subjectBinding )  ;", "builder . mutableInput ( inputBuilder )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( binder . getInputBindings (  )  . size (  )  )  ;     +  + i )     {", "ModelBinding   binding    =    binder . getInputBindings (  )  . get ( i )  ;", "builder . immutableInput ( toInputBuilder ( binding )  )  ;", "}", "unboundRules . add ( builder . build (  )  )  ;", "}", "return   unboundRules ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.model.internal.registry.UnboundRulesProcessor"}, {"methodBody": ["METHOD_START", "{", "ModelReference <  ?  >    reference    =    binding . getPredicate (  )  . getReference (  )  ;", "Input . Builder   builder    =    Input . type ( reference . getType (  )  )  ;", "ModelPath   path ;", "if    ( binding . isBound (  )  )     {", "builder . bound (  )  ;", "path    =    binding . getNode (  )  . getPath (  )  ;", "} else    {", "path    =    reference . getPath (  )  ;", "if    ( path    !  =    null )     {", "builder . suggestions ( CollectionUtils . stringize ( suggestionsProvider . transform ( path )  )  )  ;", "}", "ModelPath   scope    =    reference . getScope (  )  ;", "if    (  ( scope    !  =    null )     &  &     (  !  ( scope . equals ( ModelPath . ROOT )  )  )  )     {", "builder . scope ( scope . toString (  )  )  ;", "}", "}", "if    ( path    !  =    null )     {", "builder . path ( path )  ;", "}", "builder . description ( reference . getDescription (  )  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["toInputBuilder"], "fileName": "org.gradle.model.internal.registry.UnboundRulesProcessor"}, {"methodBody": ["METHOD_START", "{", "StringWriter   string    =    new   StringWriter (  )  ;", "writeTo ( new   PrintWriter ( string )  )  ;", "return   string . toString (  )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.gradle.model.internal.report.AmbiguousBindingReporter"}, {"methodBody": ["METHOD_START", "{", "writer . print (  \" Type - only   model   reference   of   type    \"  )  ;", "writer . print ( referenceType )  ;", "if    (  ( referenceDescription )     !  =    null )     {", "writer . print (  \"     (  \"  )  ;", "writer . print ( referenceDescription )  ;", "writer . print (  \"  )  \"  )  ;", "}", "writer . println (  \"    is   ambiguous   as   multiple   model   elements   are   available   for   this   type :  \"  )  ;", "boolean   first    =    true ;", "for    (  . Provider   provider    :    providers )     {", "if    (  ! first )     {", "writer . println (  )  ;", "}", "writer . print (  . INDENT )  ;", "writer . print (  \"  -     \"  )  ;", "writer . print ( provider . getPath (  )  )  ;", "writer . print (  \"     ( created   by :     \"  )  ;", "writer . print ( provider . getDescription (  )  )  ;", "writer . print (  \"  )  \"  )  ;", "first    =    false ;", "}", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.gradle.model.internal.report.AmbiguousBindingReporter"}, {"methodBody": ["METHOD_START", "{", "StringWriter   string    =    new   StringWriter (  )  ;", "writeTo ( new   PrintWriter ( string )  )  ;", "return   string . toString (  )  ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.gradle.model.internal.report.IncompatibleTypeReferenceReporter"}, {"methodBody": ["METHOD_START", "{", "ModelPath   path    =    node . getPath (  )  ;", "ModelRuleDescriptor   creatorDescriptor    =    node . getDescriptor (  )  ;", "return   new    ( creatorDescriptor . toString (  )  ,    path . toString (  )  ,    type . toString (  )  ,    description ,    writable ,    node . getTypeDescriptions (  )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.report.IncompatibleTypeReferenceReporter"}, {"methodBody": ["METHOD_START", "{", "writer . print (  \" Model   reference   to   element    '  \"  )  ;", "writer . print ( path )  ;", "writer . print (  \"  '    with   type    \"  )  ;", "writer . print ( type )  ;", "if    (  ( description )     !  =    null )     {", "writer . print (  \"     (  \"  )  ;", "writer . print ( description )  ;", "writer . print (  \"  )  \"  )  ;", "}", "writer . println (  \"    is   invalid   due   to   incompatible   types .  \"  )  ;", "writer . print (  \" This   element   was   created   by    \"  )  ;", "writer . print ( creator )  ;", "writer . print (  \"    and   can   be    \"  )  ;", "writer . print (  ( writable    ?     \" mutated \"     :     \" read \"  )  )  ;", "writer . println (  \"    as   the   following   types :  \"  )  ;", "boolean   first    =    true ;", "for    ( String   candidateType    :    candidateTypes )     {", "if    (  ! first )     {", "writer . println (  )  ;", "}", "writer . print (  . INDENT )  ;", "writer . print (  \"  -     \"  )  ;", "writer . print ( candidateType )  ;", "first    =    false ;", "}", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.gradle.model.internal.report.IncompatibleTypeReferenceReporter"}, {"methodBody": ["METHOD_START", "{", "return   new   UnboundRule . Builder ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["descriptor"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRule"}, {"methodBody": ["METHOD_START", "{", "return   new   UnboundRule . Builder ( String . format (  \"  % s    @    build   file    '  % s '    line    % d ,    column    % d \"  ,    descriptor ,    location . getAbsolutePath (  )  ,    line ,    column )  )  ;", "}", "METHOD_END"], "methodName": ["descriptor"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRule"}, {"methodBody": ["METHOD_START", "{", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRule"}, {"methodBody": ["METHOD_START", "{", "return   immutableInputs ;", "}", "METHOD_END"], "methodName": ["getImmutableInputs"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRule"}, {"methodBody": ["METHOD_START", "{", "return   mutableInputs ;", "}", "METHOD_END"], "methodName": ["getMutableInputs"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRule"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   suggestedPaths ;", "}", "METHOD_END"], "methodName": ["getSuggestedPaths"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   bound ;", "}", "METHOD_END"], "methodName": ["isBound"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   UnboundRuleInput . type ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   new   UnboundRuleInput . Builder ( type )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "return   UnboundRuleInput . type ( type . getDisplayName (  )  )  ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRuleInput"}, {"methodBody": ["METHOD_START", "{", "writer . print ( indent (  1  )  )  ;", "writer . println ( heading )  ;", "}", "METHOD_END"], "methodName": ["heading"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRulesReporter"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   buff    =    new   StringBuffer ( prefix )  ;", "for    ( int   i    =     0  ;    i    <    times ;    i +  +  )     {", "buff . append (  . INDENT )  ;", "}", "return   buff . toString (  )  ;", "}", "METHOD_END"], "methodName": ["indent"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRulesReporter"}, {"methodBody": ["METHOD_START", "{", "for    ( UnboundRuleInput   input    :    inputs )     {", "writer . print ( indent (  2  )  )  ;", "writer . write (  \"  -     \"  )  ;", "writer . write (  (  ( input . getPath (  )  )     =  =    null    ?     \"  < no   path >  \"     :    input . getPath (  )  )  )  ;", "writer . write (  \"     \"  )  ;", "writer . write (  (  ( input . getType (  )  )     =  =    null    ?     \"  < untyped >  \"     :    input . getType (  )  )  )  ;", "if    (  ( input . getDescription (  )  )     !  =    null )     {", "writer . write (  \"     \"  )  ;", "writer . write (  \"  (  \"  )  ;", "writer . write ( input . getDescription (  )  )  ;", "writer . write (  \"  )  \"  )  ;", "}", "if    (  !  ( input . isBound (  )  )  )     {", "writer . write (  \"     \"  )  ;", "writer . write (  \"  [  *  ]  \"  )  ;", "}", "writer . println (  )  ;", "if    (  (  ( input . getPath (  )  )     =  =    null )     &  &     (  ( input . getScope (  )  )     !  =    null )  )     {", "writer . write ( indent (  4  )  )  ;", "writer . write (  \" scope :     \"  )  ;", "writer . println ( input . getScope (  )  )  ;", "}", "if    (  ( input . getSuggestedPaths (  )  . size (  )  )     >     0  )     {", "writer . write ( indent (  4  )  )  ;", "writer . write (  \" suggestions :     \"  )  ;", "writer . println ( Joiner . on (  \"  ,     \"  )  . join ( input . getSuggestedPaths (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["reportInputs"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRulesReporter"}, {"methodBody": ["METHOD_START", "{", "for    ( UnboundRule   rule    :    rules )     {", "writer . print ( prefix )  ;", "writer . println ( rule . getDescriptor (  )  )  ;", "if    (  ( rule . getMutableInputs (  )  . size (  )  )     >     0  )     {", "heading (  \" subject :  \"  )  ;", "reportInputs ( rule . getMutableInputs (  )  )  ;", "}", "if    (  ( rule . getImmutableInputs (  )  . size (  )  )     >     0  )     {", "heading (  \" inputs :  \"  )  ;", "reportInputs ( rule . getImmutableInputs (  )  )  ;", "}", "writer . println (  )  ;", "}", "writer . println (  \"  [  *  ]     -    indicates   that   a   model   item   could   not   be   found   for   the   path   or   type .  \"  )  ;", "}", "METHOD_END"], "methodName": ["reportOn"], "fileName": "org.gradle.model.internal.report.unbound.UnboundRulesReporter"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    enclosingClass    =    clazz . getEnclosingClass (  )  ;", "if    (  (  ( enclosingClass    !  =    null )     &  &     ( enclosingClass . isEnum (  )  )  )     &  &     (  ( clazz . getSuperclass (  )  )     =  =    enclosingClass )  )     {", "return   enclosingClass ;", "}", "return   clazz ;", "}", "METHOD_END"], "methodName": ["effectiveClassOf"], "fileName": "org.gradle.model.internal.type.ClassTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Class <  ?  >  >    classChain    =    new   ArrayList < Class <  ?  >  >  (  )  ;", "Class <  ?  >    clazz    =    unwrap (  )  ;", "do    {", "classChain . add ( clazz )  ;", "clazz    =    clazz . getEnclosingClass (  )  ;", "}    while    ( clazz    !  =    null    )  ;", "return   classChain ;", "}", "METHOD_END"], "methodName": ["getEnclosingClassChain"], "fileName": "org.gradle.model.internal.type.ClassTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Class <  ?  >  >    classChain    =    getEnclosingClassChain (  )  ;", "int   topLevelIndex    =     ( classChain . size (  )  )     -     1  ;", "Class <  ?  >    topLevelClass    =    classChain . get ( topLevelIndex )  ;", "StringBuilder   representation    =    new   StringBuilder (  )  ;", "representation . append (  ( full    ?    topLevelClass . getName (  )     :    topLevelClass . getSimpleName (  )  )  )  ;", "for    ( int   i    =    topLevelIndex    -     1  ;    i    >  =     0  ;    i -  -  )     {", "representation . append (  '  .  '  )  ;", "representation . append ( classChain . get ( i )  . getSimpleName (  )  )  ;", "}", "return   representation . toString (  )  ;", "}", "METHOD_END"], "methodName": ["tryToGetRepresentation"], "fileName": "org.gradle.model.internal.type.ClassTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   reference . get (  )  ;", "}", "METHOD_END"], "methodName": ["unwrap"], "fileName": "org.gradle.model.internal.type.ClassTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   componentType ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.gradle.model.internal.type.GenericArrayTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( isWildcard (  )  )     {", "throw   new   IllegalStateException (  (  ( this )     +     \"    is   a   wildcard   type \"  )  )  ;", "}", "if    ( m . isWildcard (  )  )     {", "throw   new   IllegalArgumentException (  ( m    +     \"    is   a   wildcard   type \"  )  )  ;", "}", "if    ( m . getRawClass (  )  . isAssignableFrom ( getRawClass (  )  )  )     {", "return   Cast . uncheckedCast ( this )  ;", "} else    {", "throw   new   ClassCastException ( String . format (  \"  '  % s '    cannot   be   cast   as   a   subtype   of    '  % s '  \"  ,    this ,    m )  )  ;", "}", "}", "METHOD_END"], "methodName": ["asSubtype"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Simple < T >  ( method . getDeclaringClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["declaringType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "ImmutableList . Builder < Class <  ?  >  >    builder    =    ImmutableList . builder (  )  ;", "wrapper . collectClasses ( builder )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getAllClasses"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . Simple . typed (  (  ( GenericArrayTypeWrapper )     ( wrapper )  )  . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getComponentType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( wrapper . getRawClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getConcreteClass"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   wrapper . getRepresentation ( false )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "WildcardWrapper   wildcardType    =    getWildcardType (  )  ;", "if    ( wildcardType    =  =    null )     {", "return   null ;", "} else    {", "TypeWrapper   lowerBound    =    wildcardType . getLowerBound (  )  ;", "if    ( lowerBound    =  =    null )     {", "return   null ;", "}", "return    . Simple . typed ( lowerBound )  ;", "}", "}", "METHOD_END"], "methodName": ["getLowerBound"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   wrapper . getRepresentation ( true )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( wrapper . getRawClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRawClass"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . Simple . typed (  (  ( ParameterizedTypeWrapper )     ( wrapper )  )  . getRawType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRawType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    ( isParameterized (  )  )     {", "TypeWrapper [  ]    typeArguments    =     (  ( ParameterizedTypeWrapper )     ( wrapper )  )  . getActualTypeArguments (  )  ;", "ImmutableList . Builder <  <  ?  >  >    builder    =    ImmutableList . builder (  )  ;", "for    ( TypeWrapper   typeArgument    :    typeArguments )     {", "builder . add (  . Simple . typed ( typeArgument )  )  ;", "}", "return   builder . build (  )  ;", "} else    {", "return   Collections . emptyList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getTypeVariables"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "WildcardWrapper   wildcardType    =    getWildcardType (  )  ;", "if    ( wildcardType    =  =    null )     {", "return   null ;", "} else    {", "<  ?  >    upperBound    =     . Simple . typed ( wildcardType . getUpperBound (  )  )  ;", "if    ( upperBound . equals (  . UNTYPED )  )     {", "return   null ;", "}", "return   upperBound ;", "}", "}", "METHOD_END"], "methodName": ["getUpperBound"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( wrapper )    instanceof   WildcardWrapper )     {", "return    (  ( WildcardWrapper )     ( wrapper )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getWildcardType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   getRawClass (  )  . isAnnotationPresent ( annotation )  ;", "}", "METHOD_END"], "methodName": ["isAnnotationPresent"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    ( modelType    =  =     ( this )  )     |  |     ( wrapper . isAssignableFrom ( modelType . wrapper )  )  ;", "}", "METHOD_END"], "methodName": ["isAssignableFrom"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    ( wrapper )    instanceof   ClassTypeWrapper ;", "}", "METHOD_END"], "methodName": ["isClass"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    ( wrapper )    instanceof   GenericArrayTypeWrapper ;", "}", "METHOD_END"], "methodName": ["isGenericArray"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    ( isWildcard (  )  )     {", "return   true ;", "} else", "if    ( isParameterized (  )  )     {", "for    (  <  ?  >    typeVariable    :    getTypeVariables (  )  )     {", "if    ( typeVariable . isHasWildcardTypeVariables (  )  )     {", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isHasWildcardTypeVariables"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    ( wrapper )    instanceof   ParameterizedTypeWrapper ;", "}", "METHOD_END"], "methodName": ["isParameterized"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    (  ( wrapper )    instanceof   ClassTypeWrapper )     &  &     (  (  (  ( ClassTypeWrapper )     ( wrapper )  )  . unwrap (  )  . getTypeParameters (  )  . length )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["isRawClassOfParameterizedType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return    ( getWildcardType (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isWildcard"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Simple < T >  ( clazz )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . Simple . typed ( type )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "Type [  ]    parameterTypes    =    method . getGenericParameterTypes (  )  ;", "if    ( i    <     ( parameterTypes . length )  )     {", "return   new    . Simple < T >  ( parameterTypes [ i ]  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["paramType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Simple < T >  ( method . getGenericReturnType (  )  )  ;", "}", "METHOD_END"], "methodName": ["returnType"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   wrapper . getRepresentation ( true )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    (  ( types . length )     =  =     0  )     {", "return    . EMPTY _ TYPE _ WRAPPER _ ARRAY ;", "} else    {", "TypeWrapper [  ]    wrappers    =    new   TypeWrapper [ types . length ]  ;", "int   i    =     0  ;", "for    ( Type   type    :    types )     {", "wrappers [  ( i +  +  )  ]     =     . wrap ( type )  ;", "}", "return   wrappers ;", "}", "}", "METHOD_END"], "methodName": ["toWrappers"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    ( types . isEmpty (  )  )     {", "return    . EMPTY _ TYPE _ WRAPPER _ ARRAY ;", "} else    {", "TypeWrapper [  ]    wrappers    =    new   TypeWrapper [ types . size (  )  ]  ;", "int   i    =     0  ;", "for    (  <  ?  >    type    :    types )     {", "wrappers [  ( i +  +  )  ]     =    type . wrapper ;", "}", "return   wrappers ;", "}", "}", "METHOD_END"], "methodName": ["toWrappers"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Class < T >    clazz    =     (  ( Class < T >  )     ( instance . getClass (  )  )  )  ;", "return    . of ( clazz )  ;", "}", "METHOD_END"], "methodName": ["typeOf"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . UNTYPED ;", "}", "METHOD_END"], "methodName": ["untyped"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . Simple . typed (  (  ( ParameterizedTypeWrapper )     ( wrapper )  )  . substituteAll ( ModelType . toWrappers ( types )  )  )  ;", "}", "METHOD_END"], "methodName": ["withArguments"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "if    ( type    =  =    null )     {", "return   null ;", "} else", "if    ( type   instanceof   Class )     {", "return   new   ClassTypeWrapper (  (  ( Class <  ?  >  )     ( type )  )  )  ;", "} else", "if    ( type   instanceof   ParameterizedType )     {", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( type )  )  ;", "return   new   ParameterizedTypeWrapper (  . toWrappers ( parameterizedType . getActualTypeArguments (  )  )  ,     (  ( ClassTypeWrapper )     (  . wrap ( parameterizedType . getRawType (  )  )  )  )  ,     . wrap ( parameterizedType . getOwnerType (  )  )  )  ;", "} else", "if    ( type   instanceof   WildcardType )     {", "WildcardType   wildcardType    =     (  ( WildcardType )     ( type )  )  ;", "return   new   WildcardTypeWrapper (  . toWrappers ( wildcardType . getUpperBounds (  )  )  ,     . toWrappers ( wildcardType . getLowerBounds (  )  )  ,    type . hashCode (  )  )  ;", "} else", "if    ( type   instanceof   TypeVariable )     {", "TypeVariable <  ?  >    typeVariable    =     (  ( TypeVariable <  ?  >  )     ( type )  )  ;", "return   new   TypeVariableTypeWrapper ( typeVariable . getName (  )  ,     . toWrappers ( typeVariable . getBounds (  )  )  ,    type . hashCode (  )  )  ;", "} else", "if    ( type   instanceof   GenericArrayType )     {", "GenericArrayType   genericArrayType    =     (  ( GenericArrayType )     ( type )  )  ;", "return   new   GenericArrayTypeWrapper (  . wrap ( genericArrayType . getGenericComponentType (  )  )  ,    type . hashCode (  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" cannot   wrap   type   of   type    \"     +     ( type . getClass (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.model.internal.type.ModelType"}, {"methodBody": ["METHOD_START", "{", "Queue < ModelType <  ?  >  >    queue    =    new   ArrayDeque < ModelType <  ?  >  >  (  (  ( Iterables . size ( types )  )     *     2  )  )  ;", "Iterables . addAll ( queue ,    types )  ;", "Set < ModelType <  ?  >  >    seenTypes    =    Sets . newLinkedHashSet (  )  ;", "ModelType <  ?  >    type ;", "while    (  ( type    =    queue . poll (  )  )     !  =    null )     {", "Class <  ?  >    rawClass    =    type . getRawClass (  )  ;", "if    (  ( rawClass . equals ( Object . class )  )     |  |     ( rawClass . equals ( GroovyObject . class )  )  )     {", "continue ;", "}", "if    (  !  ( seenTypes . add ( type )  )  )     {", "continue ;", "}", "Class <  ?  >    superclass    =    rawClass . getSuperclass (  )  ;", "if    ( superclass    !  =    null )     {", "ModelType <  ?  >    superType    =    ModelType . of ( superclass )  ;", "if    (  !  ( seenTypes . contains ( superType )  )  )     {", "queue . add ( superType )  ;", "}", "}", "for    ( Class <  ?  >    iface    :    rawClass . getInterfaces (  )  )     {", "ModelType <  ?  >    ifaceType    =    ModelType . of ( iface )  ;", "if    (  !  ( seenTypes . contains ( ifaceType )  )  )     {", "queue . add ( ifaceType )  ;", "}", "}", "}", "return   seenTypes ;", "}", "METHOD_END"], "methodName": ["collectHierarchy"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   new   com . google . common . collect . Ordering < ModelType <  ?    extends   T >  >  (  )     {", "@ Override", "public   int   compare ( ModelType <  ?    extends   T >    left ,    ModelType <  ?    extends   T >    right )     {", "return   left . getDisplayName (  )  . compareTo ( right . getDisplayName (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["displayOrder"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet . Builder < String >    builder    =    ImmutableSortedSet . naturalOrder (  )  ;", "for    (  <  ?  >    type    :    types )     {", "builder . add ( type . getDisplayName (  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayNames"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < List < I >  >  (  )     {  }  . where ( new   ModelType . Parameter < I >  (  )     {  }  ,    type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["list"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   ModelTypes . modelMap ( ModelType . of ( type )  )  ;", "}", "METHOD_END"], "methodName": ["modelMap"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < ModelMap < I >  >  (  )     {  }  . where ( new   ModelType . Parameter < I >  (  )     {  }  ,    type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["modelMap"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < ModelSet < I >  >  (  )     {  }  . where ( new   ModelType . Parameter < I >  (  )     {  }  ,    type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["modelSet"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelType . Builder < Set < I >  >  (  )     {  }  . where ( new   ModelType . Parameter < I >  (  )     {  }  ,    type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.model.internal.type.ModelTypes"}, {"methodBody": ["METHOD_START", "{", "if    ( type 1    instanceof   WildcardWrapper )     {", "WildcardWrapper   wildcardType 1     =     (  ( WildcardWrapper )     ( type 1  )  )  ;", "bound 1     =    wildcardType 1  . getLowerBound (  )  ;", "if    ( bound 1     !  =    null )     {", "bound 2  ;", "if    ( type 2    instanceof   WildcardWrapper )     {", "bound 2     =     (  ( WildcardWrapper )     ( type 2  )  )  . getLowerBound (  )  ;", "if    ( bound 2     =  =    null )     {", "return   false ;", "}", "} else    {", "bound 2     =    type 2  ;", "}", "return   bound 2  . isAssignableFrom ( bound 1  )  ;", "} else    {", "bound 1     =    wildcardType 1  . getUpperBound (  )  ;", "bound 2  ;", "if    ( type 2    instanceof   WildcardWrapper )     {", "bound 2     =     (  ( WildcardWrapper )     ( type 2  )  )  . getUpperBound (  )  ;", "} else    {", "bound 2     =    type 2  ;", "}", "return   bound 1  . isAssignableFrom ( bound 2  )  ;", "}", "}", "return   type 1  . equals ( type 2  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   actualTypeArguments ;", "}", "METHOD_END"], "methodName": ["getActualTypeArguments"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   rawType ;", "}", "METHOD_END"], "methodName": ["getRawType"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "int   hashCode    =    rawType . hashCode (  )  ;", "for    (    actualTypeArgument    :    actualTypeArguments )     {", "hashCode    ^  =    actualTypeArgument . hashCode (  )  ;", "}", "if    ( ownerType    !  =    null )     {", "hashCode    ^  =    ownerType . hashCode (  )  ;", "}", "return   hashCode ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "TypeWrapper [  ]    newArguments    =    new   TypeWrapper [ actualTypeArguments . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( newArguments . length )  ;    i +  +  )     {", "TypeWrapper   argument    =    actualTypeArguments [ i ]  ;", "if    ( argument   instanceof   TypeVariableTypeWrapper )     {", "TypeVariableTypeWrapper   candidate    =     (  ( TypeVariableTypeWrapper )     ( argument )  )  ;", "if    ( candidate . getName (  )  . equals ( typeVariable . getName (  )  )  )     {", "newArguments [ i ]     =    type ;", "continue ;", "}", "}", "newArguments [ i ]     =    argument ;", "}", "return   new    ( newArguments ,    rawType ,    ownerType )  ;", "}", "METHOD_END"], "methodName": ["substitute"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( actualTypeArguments . length )     !  =     ( newArguments . length )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Expecting    \"     +     ( actualTypeArguments . length )  )     +     \"    type   arguments   but   got    \"  )     +     ( newArguments . length )  )     +     \"  .  \"  )  )  ;", "}", "return   new    ( newArguments ,    rawType ,    ownerType )  ;", "}", "METHOD_END"], "methodName": ["substituteAll"], "fileName": "org.gradle.model.internal.type.ParameterizedTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.model.internal.type.TypeVariableTypeWrapper"}, {"methodBody": ["METHOD_START", "{", "BaseInstanceFactory . ImplementationFactory <  ?    extends   PUBLIC ,     ?  >    implementationFactory    =    factories . get ( implementationClass )  ;", "if    ( implementationFactory    !  =    null )     {", "return   Cast . uncheckedCast ( implementationFactory )  ;", "}", "Class <  ?  >    superclass    =    implementationClass . getSuperclass (  )  ;", "if    (  ( superclass    !  =    null )     &  &     ( superclass    !  =     ( Object . class )  )  )     {", "implementationFactory    =    findFactory ( superclass )  ;", "factories . put ( implementationClass ,    implementationFactory )  ;", "return   Cast . uncheckedCast ( implementationFactory )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFactory"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "BaseInstanceFactory < PUBLIC >  . TypeRegistration < S >    registration    =    getRegistration ( type )  ;", "if    ( registration    =  =    null )     {", "return   null ;", "}", "if    (  ( registration . implementationRegistration )     =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   create   a    '  % s '    because   this   type   does   not   have   an   implementation   registered .  \"  ,    type )  )  ;", "}", "return   registration . implementationRegistration ;", "}", "METHOD_END"], "methodName": ["getImplementationRegistration"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "final   ImmutableSet . Builder < ModelType <  ?  >  >    builder    =    ImmutableSet . builder (  )  ;", ". walkTypeHierarchy ( publicType . getConcreteClass (  )  ,    new   RegistrationHierarchyVisitor < S >  (  )     {", "@ Override", "protected   void   visitRegistration (  < PUBLIC >  . TypeRegistration <  ?    extends   PUBLIC >    registration )     {", "for    (  . InternalViewRegistration <  ?  >    internalViewRegistration    :    registration . internalViewRegistrations )     {", "builder . add ( internalViewRegistration . getInternalView (  )  )  ;", "}", "}", "}  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getInternalViews"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( registrations . get ( type )  )  ;", "}", "METHOD_END"], "methodName": ["getRegistration"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "return   type . isAnnotationPresent ( Managed . class )  ;", "}", "METHOD_END"], "methodName": ["isManaged"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "BaseInstanceFactory . TypeRegistrationBuilder < S >    registration    =    register ( publicType ,    definedBy )  ;", "if    ( implementationType    !  =    null )     {", "registration . withImplementation ( implementationType )  ;", "}", "for    ( Class <  ?  >    internalView    :    internalViews )     {", "registration . withInternalView ( ModelType . of ( internalView )  )  ;", "}", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "BaseInstanceFactory < PUBLIC >  . TypeRegistration < S >    registration    =    Cast . uncheckedCast ( registrations . get ( publicType )  )  ;", "if    ( registration    =  =    null )     {", "registration    =    new   TypeRegistration < S >  ( publicType )  ;", "registrations . put ( publicType ,    registration )  ;", "}", "return   new   TypeRegistrationBuilderImpl < S >  ( source ,    registration )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "factories . put ( implementationType ,    implementationFactory )  ;", "}", "METHOD_END"], "methodName": ["registerFactory"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( BaseInstanceFactory < PUBLIC >  . TypeRegistration <  ?    extends   PUBLIC >    registration    :    registrations . values (  )  )     {", "registration . validate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateRegistrations"], "fileName": "org.gradle.model.internal.typeregistration.BaseInstanceFactory"}]