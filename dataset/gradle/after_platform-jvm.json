[{"methodBody": ["METHOD_START", "{", "return   attributes . equals ( o )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.gradle.api.java.archives.internal.DefaultAttributes"}, {"methodBody": ["METHOD_START", "{", "return   attributes . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.gradle.api.java.archives.internal.DefaultAttributes"}, {"methodBody": ["METHOD_START", "{", "attributes . put (  \" Manifest - Version \"  ,     \"  1  .  0  \"  )  ;", "for    ( Object   attributeKey    :    getMainAttributes (  )  . keySet (  )  )     {", "String   attributeName    =    attributeKey . toString (  )  ;", "String   attributeValue    =    getMainAttributes (  )  . getValue ( attributeName )  ;", "attributes . put ( attributeName ,    attributeValue )  ;", "}", "}", "METHOD_END"], "methodName": ["addJavaManifestToAttributes"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Attributes >    sectionEntry    :    getEntries (  )  . entrySet (  )  )     {", "String   sectionName    =    sectionEntry . getKey (  )  ;", "DefaultAttributes   sectionAttributes    =    new   DefaultAttributes (  )  ;", "for    ( Object   attributeKey    :    sectionEntry . getValue (  )  . keySet (  )  )     {", "String   attributeName    =    attributeKey . toString (  )  ;", "String   attributeValue    =    sectionEntry . getValue (  )  . getValue ( attributeName )  ;", "sectionAttributes . put ( attributeName ,    attributeValue )  ;", "}", "sections . put ( sectionName ,    sectionAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["addJavaManifestToSections"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Object >    entry    :    gradleManifest . getAttributes (  )  . entrySet (  )  )     {", "String   mainAttributeName    =    entry . getKey (  )  ;", "String   mainAttributeValue    =    entry . getValue (  )  . toString (  )  ;", "getMainAttributes (  )  . putValue ( mainAttributeName ,    mainAttributeValue )  ;", "}", "}", "METHOD_END"], "methodName": ["addMainAttributesToJavaManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Attributes >    entry    :    gradleManifest . getSections (  )  . entrySet (  )  )     {", "String   sectionName    =    entry . getKey (  )  ;", "Attributes   sectionAttributes    =    new   Attributes (  )  ;", "for    ( Map . Entry < String ,    Object >    attribute    :    entry . getValue (  )  . entrySet (  )  )     {", "String   attributeName    =    attribute . getKey (  )  ;", "String   attributeValue    =    attribute . getValue (  )  . toString (  )  ;", "sectionAttributes . putValue ( attributeName ,    attributeValue )  ;", "}", "getEntries (  )  . put ( sectionName ,    sectionAttributes )  ;", "}", "}", "METHOD_END"], "methodName": ["addSectionAttributesToJavaManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "attributes . clear (  )  ;", "sections . clear (  )  ;", "mMergeSpecs . clear (  )  ;", "init (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "Manifest   javaManifest    =    new   Manifest (  )  ;", ". addMainAttributesToJavaManifest ( gradleManifest ,    javaManifest )  ;", ". addSectionAttributesToJavaManifest ( gradleManifest ,    javaManifest )  ;", "return   javaManifest ;", "}", "METHOD_END"], "methodName": ["generateJavaManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "DefaultManifest   resultManifest    =    baseManifest ;", "for    ( ManifestMergeSpec   manifestMergeSpec    :    manifestMergeSpecs )     {", "resultManifest    =     (  ( DefaultManifestMergeSpec )     ( manifestMergeSpec )  )  . merge ( resultManifest ,    fileResolver )  ;", "}", "return   resultManifest ;", "}", "METHOD_END"], "methodName": ["getEffectiveManifestInternal"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "return   manifestMergeSpecs ;", "}", "METHOD_END"], "methodName": ["getMergeSpecs"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "getAttributes (  )  . put (  \" Manifest - Version \"  ,     \"  1  .  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  ( o    =  =    null )     |  |     (  !  ( o   instanceof    )  )  )     {", "return   false ;", "}", "effectiveThis    =    getEffectiveManifest (  )  ;", "effectiveThat    =     (  (  )     ( o )  )  . getEffectiveManifest (  )  ;", "if    (  !  ( effectiveThis . attributes . equals ( effectiveThat . attributes )  )  )     {", "return   false ;", "}", "if    (  !  ( effectiveThis . sections . equals ( effectiveThat . sections )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEqualsTo"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "return   attributes ( attributes )  ;", "}", "METHOD_END"], "methodName": ["mainAttributes"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   output    =    new   ByteArrayOutputStream (  )  ;", "boolean   useCarriageReturns    =    false ;", "byte   carriageReturn    =     (  ( byte )     (  '  \\ r '  )  )  ;", "byte   newLine    =     (  ( byte )     (  '  \\ n '  )  )  ;", "for    ( int   idx    =     0  ;    idx    <     ( origilength )  ;    idx +  +  )     {", "byte   current    =    origiidx ]  ;", "if    ( current    =  =    carriageReturn )     {", "useCarriageReturns    =    true ;", "}", "if    ( idx    =  =     (  ( origilength )     -     1  )  )     {", "output . write ( current )  ;", "if    ( useCarriageReturns )     {", "output . write ( carriageReturn )  ;", "}", "output . write ( newLine )  ;", "} else", "if    (  ( current    =  =    newLine )     &  &     (  ( idx    +     5  )     <     ( origilength )  )  )     {", "output . write ( current )  ;", "if    (  (  (  (  (  (  ( origi ( idx    +     1  )  ]  )     =  =     ' N '  )     |  |     (  ( origi ( idx    +     1  )  ]  )     =  =     ' n '  )  )     &  &     (  (  ( origi ( idx    +     2  )  ]  )     =  =     ' A '  )     |  |     (  ( origi ( idx    +     2  )  ]  )     =  =     ' a '  )  )  )     &  &     (  (  ( origi ( idx    +     3  )  ]  )     =  =     ' M '  )     |  |     (  ( origi ( idx    +     3  )  ]  )     =  =     ' m '  )  )  )     &  &     (  (  ( origi ( idx    +     4  )  ]  )     =  =     ' E '  )     |  |     (  ( origi ( idx    +     4  )  ]  )     =  =     ' e '  )  )  )     &  &     (  ( origi ( idx    +     5  )  ]  )     =  =     '  :  '  )  )     {", "if    ( useCarriageReturns )     {", "output . write ( carriageReturn )  ;", "}", "output . write ( newLine )  ;", "}", "} else    {", "output . write ( current )  ;", "}", "}", "return   output . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["prepareManifestBytesForInteroperability"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "File   manifestFile    =    fileResolver . resolve ( manifestPath )  ;", "try    {", "byte [  ]    manifestBytes    =    FileUtils . readFileToByteArray ( manifestFile )  ;", "manifestBytes    =    prepareManifestBytesForInteroperability ( manifestBytes )  ;", "if    (  !  (  . DEFAULT _ CONTENT _ CHARSET . equals ( contentCharset )  )  )     {", "manifestBytes    =    new   String ( manifestBytes ,    contentCharset )  . getBytes (  . DEFAULT _ CONTENT _ CHARSET )  ;", "}", "Manifest   javaManifest    =    new   Manifest ( new   ByteArrayInputStream ( manifestBytes )  )  ;", "addJavaManifestToAttributes ( javaManifest )  ;", "addJavaManifestToSections ( javaManifest )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "try    {", "Manifest   javaManifest    =     . generateJavaManifest ( manifest . getEffectiveManifest (  )  )  ;", "ByteArrayOutputStream   buffer    =    new   ByteArrayOutputStream (  )  ;", "write ( buffer )  ;", "byte [  ]    manifestBytes ;", "if    (  . DEFAULT _ CONTENT _ CHARSET . equals ( contentCharset )  )     {", "manifestBytes    =    buffer . toByteArray (  )  ;", "} else    {", "manifestBytes    =    buffer . toString (  . DEFAULT _ CONTENT _ CHARSET )  . getBytes ( contentCharset )  ;", "}", "outputStream . write ( manifestBytes )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifest"}, {"methodBody": ["METHOD_START", "{", "return   excluded ;", "}", "METHOD_END"], "methodName": ["isExcluded"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeDetails"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mergeDetails . isExcluded (  )  )  )     {", "if    ( section    =  =    null )     {", "merged . attributes ( WrapUtil . toMap ( mergeDetails . getKey (  )  ,    mergeDetails . getValue (  )  )  )  ;", "} else    {", "merged . attributes ( WrapUtil . toMap ( mergeDetails . getKey (  )  ,    mergeDetails . getValue (  )  )  ,    section )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addMergeDetailToManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "if    ( mergePath   instanceof   DefaultManifest )     {", "return    (  ( DefaultManifest )     ( mergePath )  )  . getEffectiveManifest (  )  ;", "}", "return   new   DefaultManifest ( mergePath ,    fileResolver ,    contentCharset )  ;", "}", "METHOD_END"], "methodName": ["createManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "String   value    =    null ;", "String   baseValueString    =     ( baseValue    !  =    null )     ?    baseValue . toString (  )     :    null ;", "String   mergeValueString    =     ( mergeValue    !  =    null )     ?    mergeValue . toString (  )     :    null ;", "value    =     ( mergeValueString    =  =    null )     ?    baseValueString    :    mergeValueString ;", "return   new   Details ( section ,    key ,    baseValueString ,    mergeValueString ,    value )  ;", "}", "METHOD_END"], "methodName": ["getMergeDetails"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "return   mergePaths ;", "}", "METHOD_END"], "methodName": ["getMergePaths"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "String   baseContentCharset    =     ( baseManifest   instanceof   ManifestInternal )     ?     (  ( ManifestInternal )     ( baseManifest )  )  . getContentCharset (  )     :    DefaultManifest . DEFAULT _ CONTENT _ CHARSET ;", "DefaultManifest   mergedManifest    =    new   DefaultManifest ( fileResolver ,    baseContentCharset )  ;", "mergedManifest . getAttributes (  )  . putAll ( baseManifest . getAttributes (  )  )  ;", "mergedManifest . getSections (  )  . putAll ( baseManifest . getSections (  )  )  ;", "for    ( Object   mergePath    :    mergePaths )     {", "DefaultManifest   manifestToMerge    =    createManifest ( mergePath ,    fileResolver ,    contentCharset )  ;", "mergedManifest    =    mergeManifest ( mergedManifest ,    manifestToMerge ,    fileResolver )  ;", "}", "return   mergedManifest ;", "}", "METHOD_END"], "methodName": ["merge"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "DefaultManifest   mergedManifest    =    new   DefaultManifest ( fileResolver )  ;", "mergeSection ( null ,    mergedManifest ,    baseManifest . getAttributes (  )  ,    toMergeManifest . getAttributes (  )  )  ;", "Set < String >    allSections    =    Sets . union ( baseManifest . getSections (  )  . keySet (  )  ,    toMergeManifest . getSections (  )  . keySet (  )  )  ;", "for    ( String   section    :    allSections )     {", "mergeSection ( section ,    mergedManifest ,    GUtil . elvis ( baseManifest . getSections (  )  . get ( section )  ,    new   DefaultAttributes (  )  )  ,    GUtil . elvis ( toMergeManifest . getSections (  )  . get ( section )  ,    new   DefaultAttributes (  )  )  )  ;", "}", "return   mergedManifest ;", "}", "METHOD_END"], "methodName": ["mergeManifest"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    mergeOnlyAttributes    =    new   LinkedHashMap < String ,    Object >  ( mergeAttributes )  ;", "Set < Details >    mergeDetailsSet    =    new   LinkedHashSet < Details >  (  )  ;", "for    ( Map . Entry < String ,    Object >    baseEntry    :    baseAttributes . entrySet (  )  )     {", "Object   mergeValue    =    mergeAttributes . get ( baseEntry . getKey (  )  )  ;", "mergeDetailsSet . add ( getMergeDetails ( section ,    baseEntry . getKey (  )  ,    baseEntry . getValue (  )  ,    mergeValue )  )  ;", "mergeOnlyAttributes . remove ( baseEntry . getKey (  )  )  ;", "}", "for    ( Map . Entry < String ,    Object >    mergeEntry    :    mergeOnlyAttributes . entrySet (  )  )     {", "mergeDetailsSet . add ( getMergeDetails ( section ,    mergeEntry . getKey (  )  ,    null ,    mergeEntry . getValue (  )  )  )  ;", "}", "for    ( Details   mergeDetails    :    mergeDetailsSet )     {", "for    ( Action <  ?    super   ManifestMergeDetails >    action    :    actions )     {", "action . execute ( mergeDetails )  ;", "}", "addMergeDetailToManifest ( section ,    mergedManifest ,    mergeDetails )  ;", "}", "}", "METHOD_END"], "methodName": ["mergeSection"], "fileName": "org.gradle.api.java.archives.internal.DefaultManifestMergeSpec"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultJarFile ( getIdentifier (  )  . child ( childName )  )  ;", "}", "METHOD_END"], "methodName": ["childJarFile"], "fileName": "org.gradle.jvm.internal.DefaultJarBinarySpec"}, {"methodBody": ["METHOD_START", "{", "try    {", "PackageName . of ( value )  ;", "}    catch    ( IllegalArgumentException   cause )     {", "throw   new   InvalidUserDataException ( String . format (  \" Invalid   public   API   specification :     % s \"  ,    cause . getMessage (  )  )  ,    cause )  ;", "}", "}", "METHOD_END"], "methodName": ["validatePackageName"], "fileName": "org.gradle.jvm.internal.DefaultJvmApiSpec"}, {"methodBody": ["METHOD_START", "{", "this . targetPlatform    =    targetPlatform ;", "}", "METHOD_END"], "methodName": ["setTargetPlatform"], "fileName": "org.gradle.jvm.internal.DefaultJvmAssembly"}, {"methodBody": ["METHOD_START", "{", "this . toolChain    =    toolChain ;", "}", "METHOD_END"], "methodName": ["setToolChain"], "fileName": "org.gradle.jvm.internal.DefaultJvmAssembly"}, {"methodBody": ["METHOD_START", "{", "List < DependencySpec >    dependencies    =    Lists . newArrayList (  )  ;", "if    ( specificDependencies    !  =    null )     {", "for    ( Collection < DependencySpec >    deps    :    specificDependencies )     {", "dependencies . addAll ( deps )  ;", "}", "}", "Collection < LanguageSourceSet >    bources    =    binary . getSources (  )  . values (  )  ;", "Iterable < LanguageSourceSet >    sourceSets    =     ( owner    !  =    null )     ?    Iterables . concat ( owner . getSources (  )  . values (  )  ,    bources )     :    bources ;", "for    ( LanguageSourceSet   sourceSet    :    sourceSets )     {", "if    ( sourceSet   instanceof   DependentSourceSet )     {", "dependencies . addAll (  (  ( DependentSourceSet )     ( sourceSet )  )  . getDependencies (  )  . getDependencies (  )  )  ;", "}", "}", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["collectDependencies"], "fileName": "org.gradle.jvm.internal.DefaultJvmBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   assembly ;", "}", "METHOD_END"], "methodName": ["getAssembly"], "fileName": "org.gradle.jvm.internal.DefaultJvmBinarySpec"}, {"methodBody": ["METHOD_START", "{", "final   Set < Class <  ?    extends   TransformationFileType >  >    inputTypes    =    new   HashSet < Class <  ?    extends   TransformationFileType >  >  (  )  ;", "inputTypes . add ( JvmResources . class )  ;", "inputTypes . add ( JvmByteCode . class )  ;", "return   inputTypes ;", "}", "METHOD_END"], "methodName": ["defaultJvmComponentInputTypes"], "fileName": "org.gradle.jvm.internal.DefaultJvmLibrarySpec"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resolveResult )     =  =    null )     {", "resolveResult    =    resolve (  )  ;", "}", "if    ( failFast )     {", "failOnUnresolved ( resolveResult . notFound )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureResolved"], "fileName": "org.gradle.jvm.internal.DependencyResolvingClasspath"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( notFound . isEmpty (  )  )  )     {", "throw   new   language . base . internal . resolve . LibraryResolveException ( String . format (  \" Could   not   resolve   all   dependencies   for    '  % s '     % s \"  ,    binary . getDisplayName (  )  ,    descriptor )  ,    notFound )  ;", "}", "}", "METHOD_END"], "methodName": ["failOnUnresolvedDependency"], "fileName": "org.gradle.jvm.internal.DependencyResolvingClasspath"}, {"methodBody": ["METHOD_START", "{", "DependencyResolvingClasspath . ResolveResult   result    =    new   DependencyResolvingClasspath . ResolveResult (  )  ;", "dependencyResolver . resolve ( resolveContext ,    remoteRepositories ,    globalRules ,    Specs .  < DependencyMetadata > satisfyAll (  )  ,    result ,    result ,    attributesSchema ,    new   ArtifactTypeRegistry (  )     {", "@ Override", "public   ImmutableAttributes   mapAttributesFor ( File   file )     {", "return   ImmutableAttributes . EMPTY ;", "}", "@ Override", "public   ImmutableAttributes   mapAttributesFor ( VariantResolveMetadata   variant )     {", "return   variant . getAttributes (  )  . asImmutable (  )  ;", "}", "@ Override", "public   ArtifactTypeContainer   create (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.jvm.internal.DependencyResolvingClasspath"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.jvm.internal.JvmPackageName"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( token . isEmpty (  )  )     |  |     ( JvmPackageName . JAVA _ KEYWORDS . contains ( token )  )  )     |  |     ( JvmPackageName . BOOLEAN _ AND _ NULL _ LITERALS . contains ( token )  )  )     |  |     (  !  ( Character . isJavaIdentifierStart ( token . charAt (  0  )  )  )  )  )     {", "return   false ;", "}", "if    (  ( token . length (  )  )     >     1  )     {", "for    ( char   c    :    token . substring (  1  )  . toCharArray (  )  )     {", "if    (  !  ( Character . isJavaIdentifierPart ( c )  )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isIdentifier"], "fileName": "org.gradle.jvm.internal.JvmPackageName"}, {"methodBody": ["METHOD_START", "{", "if    ( JvmPackageName . UNNAMED _ PACKAGE . equals ( value )  )     {", "return   true ;", "}", "if    (  (  ( value    =  =    null )     |  |     ( value . startsWith (  \"  .  \"  )  )  )     |  |     ( value . endsWith (  \"  .  \"  )  )  )     {", "return   false ;", "}", "for    ( String   token    :    value . split (  \"  \\  \\  .  \"  )  )     {", "if    (  !  ( JvmPackageName . isIdentifier ( token )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isValidPackageName"], "fileName": "org.gradle.jvm.internal.JvmPackageName"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( JvmPackageName . isValidPackageName ( value )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \"  '  % s '    is   not   a   valid   package   name \"  ,    value )  )  ;", "}", "return   new   JvmPackageName ( value )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.jvm.internal.JvmPackageName"}, {"methodBody": ["METHOD_START", "{", "return   DefaultLibraryResolutionErrorMessageBuilder . TARGET _ PLATFORM . equals ( variantAxis )     ?     \" platform \"     :    variantAxis ;", "}", "METHOD_END"], "methodName": ["renderAxisName"], "fileName": "org.gradle.jvm.internal.resolve.DefaultLibraryResolutionErrorMessageBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultVariantAxisCompatibilityFactory ( clazz ,    selector )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.jvm.internal.resolve.DefaultVariantAxisCompatibilityFactory"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    variants    =    Maps . newLinkedHashMap (  )  ;", "Builder < String ,    ModelType <  ?  >  >    dimensionTypesBuilder    =    ImmutableMap . builder (  )  ;", "if    ( binarySpecSchema   instanceof   StructSchema )     {", "VariantAspect   variantAspect    =     (  ( StructSchema <  ?  >  )     ( binarySpecSchema )  )  . getAspect ( VariantAspect . class )  ;", "if    ( variantAspect    !  =    null )     {", "for    ( ModelProperty <  ?  >    property    :    variantAspect . getDimensions (  )  )     {", "Object   value    =    property . getPropertyValue ( binarySpec )  ;", "variants . put ( property . getName (  )  ,    value )  ;", "dimensionTypesBuilder . put ( property . getName (  )  ,    property . getType (  )  )  ;", "}", "}", "}", "return   new    ( Collections . unmodifiableMap ( variants )  ,    dimensionTypesBuilder . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["extractFrom"], "fileName": "org.gradle.jvm.internal.resolve.DefaultVariantsMetaData"}, {"methodBody": ["METHOD_START", "{", "return   variants ;", "}", "METHOD_END"], "methodName": ["getVariants"], "fileName": "org.gradle.jvm.internal.resolve.JvmLibraryResolveContext"}, {"methodBody": ["METHOD_START", "{", "List < PublishArtifact >    publishArtifacts    =    artifacts . get ( usage )  ;", "for    ( File   dir    :    directories )     {", "DefaultPublishArtifact   publishArtifact    =    new   DefaultPublishArtifact (  \" assembly \"  ,     \"  \"  ,     \"  \"  ,     \"  \"  ,    new   e ( dir . lastModified (  )  )  ,    dir )  ;", "publishArtifact . builtBy ( assembly )  ;", "publishArtifacts . add ( publishArtifact )  ;", "}", "}", "METHOD_END"], "methodName": ["addArtifact"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "LibraryPublishArtifact   publishArtifact    =    new   LibraryPublishArtifact (  \" jar \"  ,    jarFile . getFile (  )  )  ;", "publishArtifact . builtBy ( jarFile )  ;", "artifacts . get ( usage )  . add ( publishArtifact )  ;", "}", "METHOD_END"], "methodName": ["addArtifact"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "Iterable < DependencySpec >    dependencySpecs    =    dependenciesPerUsage . get ( usage )  ;", "dependenciesPerUsage . put ( usage ,    Iterables . concat ( dependencies ,    dependencySpecs )  )  ;", "}", "METHOD_END"], "methodName": ["configureUsageMetadata"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "JarFile   apiJar    =    jarBinarySpec . getApiJar (  )  ;", ". configureUsageMetadata ( UsageKind . API ,    jarBinarySpec . getApiDependencies (  )  ,    dependenciesPerUsage )  ;", "JarFile   runtimeJar    =    jarBinarySpec . getRuntimeJar (  )  ;", "JvmLibrarySpec   library    =    jarBinarySpec . getLibrary (  )  ;", ". configureUsageMetadata ( UsageKind . RUNTIME ,     ( library    !  =    null    ?    DefaultJvmBinarySpec . collectDependencies ( jarBinarySpec ,    library ,    library . getDependencies (  )  . getDependencies (  )  ,    jarBinarySpec . getApiDependencies (  )  )     :    Collections .  < DependencySpec > emptyList (  )  )  ,    dependenciesPerUsage )  ;", "if    (  ! toAssembly )     {", ". addArtifact ( UsageKind . API ,    apiJar ,    artifacts )  ;", ". addArtifact ( UsageKind . RUNTIME ,    runtimeJar ,    artifacts )  ;", "}", "}", "METHOD_END"], "methodName": ["createJarBinarySpecLocalComponentMetaData"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "JvmLocalLibraryMetaDataAdapter . configureUsageMetadata ( UsageKind . API ,    Collections .  < DependencySpec > emptyList (  )  ,    dependenciesPerUsage )  ;", "JvmLocalLibraryMetaDataAdapter . configureUsageMetadata ( UsageKind . RUNTIME ,    Collections .  < DependencySpec > emptyList (  )  ,    dependenciesPerUsage )  ;", "if    ( toAssembly )     {", "JvmLocalLibraryMetaDataAdapter . addArtifact ( UsageKind . API ,    assembly . getClassDirectories (  )  ,    artifacts ,    assembly )  ;", "JvmLocalLibraryMetaDataAdapter . addArtifact ( UsageKind . RUNTIME ,    Sets . union ( assembly . getClassDirectories (  )  ,    assembly . getResourceDirectories (  )  )  ,    artifacts ,    assembly )  ;", "}", "}", "METHOD_END"], "methodName": ["createJvmAssemblyLocalComponentMetaData"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "final   DefaultLibraryLocalComponentMetadata   metadata    =    DefaultLibraryLocalComponentMetadata . newResolvedLibraryMetadata ( selectedBinary . getId (  )  ,    toStringMap ( dependenciesPerUsage )  ,    projectPath )  ;", "for    ( Map . Entry < UsageKind ,    List < PublishArtifact >  >    entry    :    artifacts . entrySet (  )  )     {", "UsageKind   usage    =    entry . getKey (  )  ;", "final   List < PublishArtifact >    publishArtifacts    =    entry . getValue (  )  ;", "metadata . addArtifacts ( usage . getConfigurationName (  )  ,    publishArtifacts )  ;", "metadata . addVariant ( usage . getConfigurationName (  )  ,    new   OutgoingVariant (  )     {", "@ Override", "public   DisplayName   asDescribable (  )     {", "return   Describables . of ( metadata . getId (  )  )  ;", "}", "@ Override", "public   AttributeContainerInternal   getAttributes (  )     {", "return   ImmutableAttributes . EMPTY ;", "}", "@ Override", "public   Set <  ?    extends   PublishArtifact >    getArtifacts (  )     {", "return   new   LinkedHashSet < PublishArtifact >  ( publishArtifacts )  ;", "}", "@ Override", "public   Set <  ?    extends   OutgoingVariant >    getChildren (  )     {", "return   ImmutableSet . of (  )  ;", "}", "}  )  ;", "}", "return   metadata ;", "}", "METHOD_END"], "methodName": ["createResolvedMetaData"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "for    ( UsageKind   usageKind    :    UsageKind . values (  )  )     {", "dependenciesPerUsage . put ( usageKind ,    Collections .  < DependencySpec > emptyList (  )  )  ;", "artifacts . put ( usageKind ,    new   LinkedList < PublishArtifact >  (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeUsages"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    T >    map    =    new   HashMap < String ,    T >  ( enumMap . size (  )  )  ;", "for    ( Map . Entry <  ?    extends   Enum < UsageKind >  ,    T >    tEntry    :    enumMap . entrySet (  )  )     {", "UsageKind   usageKind    =    UsageKind . valueOf ( tEntry . getKey (  )  . name (  )  )  ;", "map . put ( usageKind . getConfigurationName (  )  ,    tEntry . getValue (  )  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["toStringMap"], "fileName": "org.gradle.jvm.internal.resolve.JvmLocalLibraryMetaDataAdapter"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . substringAfterLast ( file . getName (  )  ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["determineExtension"], "fileName": "org.gradle.jvm.internal.resolve.LibraryPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . substringBeforeLast ( file . getName (  )  ,     \"  .  \"  )  ;", "}", "METHOD_END"], "methodName": ["determineName"], "fileName": "org.gradle.jvm.internal.resolve.LibraryPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   configurationName ;", "}", "METHOD_END"], "methodName": ["getConfigurationName"], "fileName": "org.gradle.jvm.internal.resolve.UsageKind"}, {"methodBody": ["METHOD_START", "{", "for    ( VariantAxisCompatibilityFactory   factory    :    factories )     {", "@ SuppressWarnings (  \" unchecked \"  )", "VariantAxisCompatibility < Object >    selector    =    factory . getVariantAxisCompatibility ( o )  ;", "if    ( selector    !  =    null )     {", "return   selector ;", "}", "}", "return   new   DefaultVariantAxisCompatibility (  )  ;", "}", "METHOD_END"], "methodName": ["createSelector"], "fileName": "org.gradle.jvm.internal.resolve.VariantsMatcher"}, {"methodBody": ["METHOD_START", "{", "if    ( binaries . isEmpty (  )  )     {", "return   binaries ;", "}", "Set < String >    resolveDimensions    =    variantsMetaData . getNonNullVariantAxes (  )  ;", "TreeMultimap < String ,     . VariantValue >    selectedVariants    =    TreeMultimap . create ( String . CASE _ INSENSITIVE _ ORDER ,     . SPEC _ COMPARATOR )  ;", "Set < BinarySpec >    removedSpecs    =    Sets . newHashSet (  )  ;", "for    ( BinarySpec   binarySpec    :    binaries )     {", "if    ( binarySpecType . isAssignableFrom ( binarySpec . getClass (  )  )  )     {", "VariantsMetaData   binaryVariants    =    DefaultVariantsMetaData . extractFrom ( binarySpec ,    schemaStore . getSchema (  (  ( BinarySpecInternal )     ( binarySpec )  )  . getPublicType (  )  )  )  ;", "Set < String >    commonsDimensions    =    Sets . intersection ( resolveDimensions ,    binaryVariants . getNonNullVariantAxes (  )  )  ;", "Set < String >    incompatibleDimensionTypes    =    VariantsMetaDataHelper . determineAxesWithIncompatibleTypes ( variantsMetaData ,    binaryVariants ,    commonsDimensions )  ;", "if    ( incompatibleDimensionTypes . isEmpty (  )  )     {", "for    ( String   dimension    :    commonsDimensions )     {", "Class <  ?  >    dimensionType    =    variantsMetaData . getVariantAxisType ( dimension )  . getConcreteClass (  )  ;", "boolean   isStringType    =     ( String . class )     =  =    dimensionType ;", "Object   requestedValue    =     ( isStringType )     ?    variantsMetaData . getValueAsString ( dimension )     :    variantsMetaData . getValueAsType ( Cast .  < Class <  ?    extends   Named >  > uncheckedCast ( dimensionType )  ,    dimension )  ;", "Object   binaryValue    =     ( isStringType )     ?    binaryVariants . getValueAsString ( dimension )     :    binaryVariants . getValueAsType ( Cast .  < Class <  ?    extends   Named >  > uncheckedCast ( dimensionType )  ,    dimension )  ;", "VariantAxisCompatibility < Object >    selector    =    createSelector ( requestedValue )  ;", "if    ( selector . isCompatibleWithRequirement ( requestedValue ,    binaryValue )  )     {", ". VariantValue   value    =    new    . VariantValue ( binaryValue ,    binarySpec )  ;", "SortedSet <  . VariantValue >    variantValues    =    selectedVariants . get ( dimension )  ;", "for    (  . VariantValue   variantValue    :    variantValues )     {", "if    ( selector . betterFit ( requestedValue ,    variantValue . value ,    binaryValue )  )     {", "removedSpecs . add ( variantValue . spec )  ;", "} else", "if    ( selector . betterFit ( requestedValue ,    binaryValue ,    variantValue . value )  )     {", "removedSpecs . add ( value . spec )  ;", "}", "}", "selectedVariants . put ( dimension ,    value )  ;", "} else    {", "removedSpecs . add ( binarySpec )  ;", "}", "}", "}", "}", "}", "Set < BinarySpec >    union    =    null ;", "for    ( String   dimension    :    selectedVariants . keySet (  )  )     {", "Set < BinarySpec >    variantValues    =    ImmutableSet . copyOf ( Iterables . transform ( selectedVariants . get ( dimension )  ,     . VariantValue . SPEC _ FUNCTION )  )  ;", "union    =     ( union    =  =    null )     ?    variantValues    :    Sets . union ( union ,    variantValues )  ;", "}", "return   union    =  =    null    ?    Collections .  < BinarySpec > emptySet (  )     :    Sets . difference ( union ,    removedSpecs )  ;", "}", "METHOD_END"], "methodName": ["filterBinaries"], "fileName": "org.gradle.jvm.internal.resolve.VariantsMatcher"}, {"methodBody": ["METHOD_START", "{", "Set < String >    result    =    Sets . newHashSet (  )  ;", "for    ( String   commonDimension    :    testedDimensions )     {", "ModelType <  ?  >    Type    =    reference . getVariantAxisType ( commonDimension )  ;", "ModelType <  ?  >    binaryVariantType    =    candidate . getVariantAxisType ( commonDimension )  ;", "if    (  ( binaryVariantType    !  =    null )     &  &     (  !  ( Type . isAssignableFrom ( binaryVariantType )  )  )  )     {", "result . add ( commonDimension )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["determineAxesWithIncompatibleTypes"], "fileName": "org.gradle.jvm.internal.resolve.VariantsMetaDataHelper"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultJavaPlatform ( JavaVersion . current (  )  )  ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.gradle.jvm.platform.internal.DefaultJavaPlatform"}, {"methodBody": ["METHOD_START", "{", "return    \" java \"     +     ( getMajorVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["generateName"], "fileName": "org.gradle.jvm.platform.internal.DefaultJavaPlatform"}, {"methodBody": ["METHOD_START", "{", "return   getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.jvm.platform.internal.DefaultJavaPlatform"}, {"methodBody": ["METHOD_START", "{", "if    (  ( manifest )     =  =    null )     {", "manifest    =    new   DefaultManifest (  (  ( ProjectInternal )    etProject (  )  )  ) etFileResolver (  )  )  ;", "}", "return   manifest ;", "}", "METHOD_END"], "methodName": ["forceManifest"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "return   manifest ;", "}", "METHOD_END"], "methodName": ["getManifest"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "return   manifestContentCharset ;", "}", "METHOD_END"], "methodName": ["getManifestContentCharset"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "return   metaInf . addChild (  )  ;", "}", "METHOD_END"], "methodName": ["getMetaInf"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configure ( configureClosure ,    forceManifest (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["manifest"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "configureAction . execute ( forceManifest (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["manifest"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "return   ConfigureUtil . configure ( configureClosure ,    getMetaInf (  )  )  ;", "}", "METHOD_END"], "methodName": ["metaInf"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "CopySpec   metaInf    =    getMetaInf (  )  ;", "configureAction . execute ( metaInf )  ;", "return   metaInf ;", "}", "METHOD_END"], "methodName": ["metaInf"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "this . manifest    =    manifest ;", "}", "METHOD_END"], "methodName": ["setManifest"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "if    ( manifestContentCharset    =  =    null )     {", "throw   new   InvalidUserDataException (  \" manifestContentCharset   must   not   be   null \"  )  ;", "}", "if    (  !  ( Charset . isSupported ( manifestContentCharset )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Charset   for   manifestContentCharset    '  % s '    is   not   supported   by   your   JVM \"  ,    manifestContentCharset )  )  ;", "}", "this . manifestContentCharset    =    manifestContentCharset ;", "}", "METHOD_END"], "methodName": ["setManifestContentCharset"], "fileName": "org.gradle.jvm.tasks.Jar"}, {"methodBody": ["METHOD_START", "{", "final   List < File >    sourceFiles    =    sortedSourceFiles (  )  ;", "final   ApiClassExtractor   apiClassExtractor    =    new   ApiClassExtractor ( getExportedPackages (  )  )  ;", "withResource ( new   JarOutputStream ( new   BufferedOutputStream ( new   FileOutputStream ( getOutputFile (  )  )  ,     6  5  5  3  6  )  )  ,    new   internal . ErroringAction < JarOutputStream >  (  )     {", "@ Override", "protected   void   doExecute ( final   JarOutputStream   jos )    throws   Exception    {", "writeManifest ( jos )  ;", "writeClasses ( jos )  ;", "}", "private   void   writeManifest ( JarOutputStream   jos )    throws   IOException    {", "writeEntry ( jos ,     \" META - INF / MANIFEST . MF \"  ,     \" Manifest - Version :     1  .  0  \\ n \"  . getBytes (  )  )  ;", "}", "private   void   writeClasses ( JarOutputStream   jos )    throws   Exception    {", "for    ( File   sourceFile    :    sourceFiles )     {", "if    (  !  ( isClassFile ( sourceFile )  )  )     {", "continue ;", "}", "ClassReader   classReader    =    new   ClassReader ( FileUtils . readFileToByteArray ( sourceFile )  )  ;", "if    (  !  ( apiClassExtractor . shouldExtractApiClassFrom ( classReader )  )  )     {", "continue ;", "}", "byte [  ]    apiClassBytes    =    apiClassExtractor . extractApiClassFrom ( classReader )  ;", "if    ( apiClassBytes    =  =    null )     {", "continue ;", "}", "String   internalClassName    =    classReader . getClassName (  )  ;", "String   entryPath    =    internalClassName    +     \"  . class \"  ;", "writeEntry ( jos ,    entryPath ,    apiClassBytes )  ;", "}", "}", "private   void   writeEntry ( JarOutputStream   jos ,    String   name ,    byte [  ]    bytes )    throws   IOException    {", "JarEntry   je    =    new   JarEntry ( name )  ;", "je . setTime (  0  )  ;", "je . setSize ( bytes . length )  ;", "jos . putNextEntry ( je )  ;", "jos . write ( bytes )  ;", "jos . closeEntry (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createApiJar"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "return   exportedPackages ;", "}", "METHOD_END"], "methodName": ["getExportedPackages"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "return   hasExtension ( file ,     \"  . class \"  )  ;", "}", "METHOD_END"], "methodName": ["isClassFile"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "this . exportedPackages    =    exportedPackages ;", "}", "METHOD_END"], "methodName": ["setExportedPackages"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "this . outputFile    =    outputFile ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "List < File >    sourceFiles    =    Lists . newArrayList ( getSource (  )  . getFiles (  )  )  ;", "Collections . sort ( sourceFiles )  ;", "return   sourceFiles ;", "}", "METHOD_END"], "methodName": ["sortedSourceFiles"], "fileName": "org.gradle.jvm.tasks.api.ApiJar"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( jdk . getJavaHome (  )  ,     \" bin \"  )  ;", "}", "METHOD_END"], "methodName": ["getBinDir"], "fileName": "org.gradle.jvm.toolchain.internal.InstalledJdkInternal"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( InstalledJdkInternal . getBinDir ( jdk )  ,    OperatingSystem . current (  )  . getExecutableName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.jvm.toolchain.internal.InstalledJdkInternal"}, {"methodBody": ["METHOD_START", "{", "return   InstalledJdkInternal . getExecutable ( this ,     \" javac \"  )  ;", "}", "METHOD_END"], "methodName": ["getJavaCompileExecutable"], "fileName": "org.gradle.jvm.toolchain.internal.InstalledJdkInternal"}, {"methodBody": ["METHOD_START", "{", "return   InstalledJdkInternal . getExecutable ( this ,     \" java \"  )  ;", "}", "METHOD_END"], "methodName": ["getJavaExecutable"], "fileName": "org.gradle.jvm.toolchain.internal.InstalledJdkInternal"}, {"methodBody": ["METHOD_START", "{", "return   InstalledJdkInternal . getExecutable ( this ,     \" javadoc \"  )  ;", "}", "METHOD_END"], "methodName": ["getJavadocExecutable"], "fileName": "org.gradle.jvm.toolchain.internal.InstalledJdkInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( jdkPath . exists (  )  )  )     {", "return    . ProbeResult . failure (  . InstallType . NO _ SUCH _ DIRECTORY ,     (  \" No   such   directory :     \"     +    jdkPath )  )  ;", "}", "EnumMap <  . SysProp ,    String >    metadata    =    cache . getUnchecked ( jdkPath )  ;", "String   version    =    metadata . get (  . SysProp . VERSION )  ;", "if    (  . UNKNOWN . equals ( version )  )     {", "return    . ProbeResult . failure (  . InstallType . INVALID _ JDK ,    metadata . get (  . SysProp . Z _ ERROR )  )  ;", "}", "try    {", "JavaVersion . toVersion ( version )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "return    . ProbeResult . failure (  . InstallType . INVALID _ JDK ,     (  \" Cannot   parse   version   number :     \"     +    version )  )  ;", "}", "if    (  . javaExe ( jdkPath ,     \" javac \"  )  . exists (  )  )     {", "return    . ProbeResult . success (  . InstallType . IS _ JDK ,    metadata )  ;", "}", "return    . ProbeResult . success (  . InstallType . IS _ JRE ,    metadata )  ;", "}", "METHOD_END"], "methodName": ["checkJdk"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "String   basename    =     ( result    =  =     ( JavaInstallationProbe . InstallType . IS _ JDK )  )     ?     \" JDK \"     :     \" JRE \"  ;", "String   vendor    =    metadata . get ( JavaInstallationProbe . SysProp . VENDOR )  ;", "if    ( vendor    =  =    null )     {", "return   basename ;", "} else    {", "vendor    =    vendor . toLowerCase (  )  ;", "}", "if    ( vendor . contains (  \" apple \"  )  )     {", "return    \" Apple    \"     +    basename ;", "} else", "if    (  ( vendor . contains (  \" oracle \"  )  )     |  |     ( vendor . contains (  \" sun \"  )  )  )     {", "String   vm    =    metadata . get ( JavaInstallationProbe . SysProp . VM )  ;", "if    (  ( vm    !  =    null )     &  &     ( vm . contains (  \" OpenJDK \"  )  )  )     {", "return   result    =  =     ( JavaInstallationProbe . InstallType . IS _ JDK )     ?     \" OpenJDK \"     :     \" OpenJDK   JRE \"  ;", "}", "return    \" Oracle    \"     +    basename ;", "} else", "if    ( vendor . contains (  \" ibm \"  )  )     {", "return    \" IBM    \"     +    basename ;", "} else", "if    ( vendor . contains (  \" azul   systems \"  )  )     {", "return    \" Zulu    \"     +    basename ;", "} else", "if    ( vendor . contains (  \" hewlett - packard \"  )  )     {", "return    \" HP - UX    \"     +    basename ;", "}", "return   basename ;", "}", "METHOD_END"], "methodName": ["computeJdkName"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "EnumMap < JavaInstallationProbe . SysProp ,    String >    result    =    new   EnumMap < JavaInstallationProbe . SysProp ,    String >  ( JavaInstallationProbe . SysProp . class )  ;", "for    ( JavaInstallationProbe . SysProp   type    :    JavaInstallationProbe . SysProp . values (  )  )     {", "result . put ( type ,    System . getProperty ( type . sysProp ,    JavaInstallationProbe . UNKNOWN )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "JavaInstallationProbe . ProbeResult . success ( JavaInstallationProbe . InstallType . IS _ JDK ,    JavaInstallationProbe . current (  )  )  . configure ( currentJava )  ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "EnumMap < JavaInstallationProbe . SysProp ,    String >    result    =    new   EnumMap < JavaInstallationProbe . SysProp ,    String >  ( JavaInstallationProbe . SysProp . class )  ;", "for    ( JavaInstallationProbe . SysProp   type    :    JavaInstallationProbe . SysProp . values (  )  )     {", "result . put ( type ,    JavaInstallationProbe . UNKNOWN )  ;", "}", "result . put ( JavaInstallationProbe . SysProp . Z _ ERROR ,    message )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "JavaExecAction   exec    =    factory . newJavaExecAction (  )  ;", "exec . executable (  . javaExe ( jdkPath ,     \" java \"  )  )  ;", "File   workingDir    =    Files . createTempDir (  )  ;", "exec . setWorkingDir ( workingDir )  ;", "exec . setClasspath ( new   SimpleFileCollection ( workingDir )  )  ;", "try    {", ". writeProbe ( workingDir )  ;", "exec . setMain (  . JavaProbe . CLASSNAME )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "exec . setStandardOutput ( baos )  ;", "ByteArrayOutputStream   errorOutput    =    new   ByteArrayOutputStream (  )  ;", "exec . setErrorOutput ( errorOutput )  ;", "exec . setIgnoreExitValue ( true )  ;", "ExecResult   result    =    exec . execute (  )  ;", "int   exitValue    =    result . getExitValue (  )  ;", "if    ( exitValue    =  =     0  )     {", "return    . parseExecOutput ( baos . toString (  )  )  ;", "}", "return    . error (  (  (  (  \" Command   returned   unexpected   result   code :     \"     +    exitValue )     +     \"  \\ nError   output :  \\ n \"  )     +    errorOutput )  )  ;", "}    catch    ( ExecException   ex )     {", "return    . error ( ex . getMessage (  )  )  ;", "}    finally    {", "try    {", "FileUtils . deleteDirectory ( workingDir )  ;", "}    catch    ( IOException   e )     {", "throw   new   GradleException (  \" Unable   to   delete   temp   directory \"  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getMetadataInternal"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( new   File ( jdkPath ,     \" bin \"  )  ,    OperatingSystem . current (  )  . getExecutableName ( command )  )  ;", "}", "METHOD_END"], "methodName": ["javaExe"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "String [  ]    split    =    probeResult . split ( System . getProperty (  \" line . separator \"  )  )  ;", "if    (  ( split . length )     !  =     (  (  . SysProp . values (  )  . length )     -     1  )  )     {", "return    . error (  (  \" Unexpected   command   output :     \\ n \"     +    probeResult )  )  ;", "}", "EnumMap <  . SysProp ,    String >    result    =    new   EnumMap <  . SysProp ,    String >  (  . SysProp . class )  ;", "for    (  . SysProp   type    :     . SysProp . values (  )  )     {", "if    ( type    !  =     (  . SysProp . Z _ ERROR )  )     {", "result . put ( type ,    split [ type . ordinal (  )  ]  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseExecOutput"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}, {"methodBody": ["METHOD_START", "{", "File   probeFile    =    new   File ( workingDir ,     (  ( JavaInstallationProbe . JavaProbe . CLASSNAME )     +     \"  . class \"  )  )  ;", "try    {", "IoActions . withResource ( new   FileOutputStream ( probeFile )  ,    new   ErroringAction < FileOutputStream >  (  )     {", "@ Override", "protected   void   doExecute ( FileOutputStream   thing )    throws   Exception    {", "thing . write ( JavaInstallationProbe . JavaProbe . dump (  )  )  ;", "}", "}  )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   new   GradleException (  \" Unable   to   write   Java   probe   file \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["writeProbe"], "fileName": "org.gradle.jvm.toolchain.internal.JavaInstallationProbe"}]