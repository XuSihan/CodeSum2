[{"methodBody": ["METHOD_START", "{", "task . setDescription (  (  (  (  \" Assembles   the    \"     +    sourceSet )     +     \"    of    \"  )     +    binary )  )  ;", "task . getToolChain (  )  . set ( binary . getToolChain (  )  )  ;", "task . getTargetPlatform (  )  . set ( binary . getTargetPlatform (  )  )  ;", "task . source ( sourceSet . getSource (  )  )  ;", "FileCollectionFactory   fileCollectionFactory    =     (  ( ProjectInternal )     ( task . getProject (  )  )  )  . getServices (  )  . get ( FileCollectionFactory . class )  ;", "task . includes ( fileCollectionFactory . create ( new   MinimalFileSet (  )     {", "@ Override", "public   Set < File >    getFiles (  )     {", "PlatformToolProvider   platformToolProvider    =     (  ( NativeToolChainInternal )     ( binary . getToolChain (  )  )  )  . select (  (  ( NativePlatformInternal )     ( binary . getTargetPlatform (  )  )  )  )  ;", "return   new   LinkedHashSet < File >  ( platformToolProvider . getSystemLibraries ( ASSEMBLER )  . getIncludeDirs (  )  )  ;", "}", "@ Override", "public   String   getDisplayName (  )     {", "return    \" System   includes   for    \"     +     ( binary . getToolChain (  )  . getDisplayName (  )  )  ;", "}", "}  )  )  ;", "final   Project   project    =    task . getProject (  )  ;", "task . setObjectFileDir ( new   File ( binary . getNamingScheme (  )  . getOutputDirectory ( project . getBuildDir (  )  ,     \" objs \"  )  ,    sourceSet . getProjectScopedName (  )  )  )  ;", "Tool   Tool    =    binary . getToolByName (  \"  \"  )  ;", "task . setAssemblerArgs ( Tool . getArgs (  )  )  ;", "binary . binaryInputs ( task . getOutputs (  )  . getFiles (  )  . getAsFileTree (  )  . matching ( new   PatternSet (  )  . include (  \"  *  *  /  *  . obj \"  ,     \"  *  *  /  *  . o \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureAssembleTask"], "fileName": "org.gradle.language.assembler.plugins.internal.AssembleTaskConfig"}, {"methodBody": ["METHOD_START", "{", "BuildOperationLogger   operationLogger    =    getOperationLoggerFactory (  )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "SimpleStaleClassCleaner   cleaner    =    new   SimpleStaleClassCleaner ( getOutputs (  )  )  ;", "cleaner . setDestinationDir ( getObjectFileDir (  )  )  ;", "cleaner . execute (  )  ;", "DefaultSpec   spec    =    new   DefaultSpec (  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setObjectFileDir ( getObjectFileDir (  )  )  ;", "spec . source ( getSource (  )  )  ;", "spec . include ( getIncludes (  )  )  ;", "spec . args ( getrArgs (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "NativeToolChainInternal   nativeToolChain    =     (  ( NativeToolChainInternal )     ( toolChain . get (  )  )  )  ;", "NativePlatformInternal   nativePlatform    =     (  ( NativePlatformInternal )     ( targetPlatform . get (  )  )  )  ;", "Compiler < Spec >    compiler    =    nativeToolChain . select ( nativePlatform )  . newCompiler ( Spec . class )  ;", "WorkResult   result    =    BuildOperationLoggingCompilerDecorator . wrap ( compiler )  . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["assemble"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   assemblerArgs ;", "}", "METHOD_END"], "methodName": ["getAssemblerArgs"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   objectFileDir ;", "}", "METHOD_END"], "methodName": ["getObjectFileDir"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationLoggerFactory"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "includes . from ( includeRoots )  ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "this . assemblerArgs    =    assemblerArgs ;", "}", "METHOD_END"], "methodName": ["setAssemblerArgs"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "this . objectFileDir    =    objectFileDir ;", "}", "METHOD_END"], "methodName": ["setObjectFileDir"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "source . from ( sourceFiles )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.language.assembler.tasks.Assemble"}, {"methodBody": ["METHOD_START", "{", "DefaultCppExecutable   result    =    objectFactory . newInstance ( DefaultCppExecutable . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( identity . getName (  )  )  )  )  ,    getBaseName (  )  ,    getCppSource (  )  ,    getPrivateHeaderDirs (  )  ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addExecutable"], "fileName": "org.gradle.language.cpp.internal.DefaultCppApplication"}, {"methodBody": ["METHOD_START", "{", "action . execute ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["dependencies"], "fileName": "org.gradle.language.cpp.internal.DefaultCppApplication"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileOperations"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "return   identity ;", "}", "METHOD_END"], "methodName": ["getIdentity"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "return   includePathConfiguration ;", "}", "METHOD_END"], "methodName": ["getIncludePathConfiguration"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getNativeDependencyCache"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "return   platformToolProvider ;", "}", "METHOD_END"], "methodName": ["getPlatformToolProvider"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTemporaryFileProvider"], "fileName": "org.gradle.language.cpp.internal.DefaultCppBinary"}, {"methodBody": ["METHOD_START", "{", "return   fileOperations . files ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "if    ( dirs . getFrom (  )  . isEmpty (  )  )     {", "return   fileOperations . files ( convionLocation )  ;", "}", "return   dirs ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createDirView"], "fileName": "org.gradle.language.cpp.internal.DefaultCppComponent"}, {"methodBody": ["METHOD_START", "{", "return   privateHeadersWithConvention ;", "}", "METHOD_END"], "methodName": ["getAllHeaderDirs"], "fileName": "org.gradle.language.cpp.internal.DefaultCppComponent"}, {"methodBody": ["METHOD_START", "{", "DefaultCppSharedLibrary   result    =    objectFactory . newInstance ( DefaultCppSharedLibrary . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( identity . getName (  )  )  )  )  ,    getBaseName (  )  ,    getCppSource (  )  ,    getAllHeaderDirs (  )  ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addSharedLibrary"], "fileName": "org.gradle.language.cpp.internal.DefaultCppLibrary"}, {"methodBody": ["METHOD_START", "{", "DefaultCppStaticLibrary   result    =    objectFactory . newInstance ( DefaultCppStaticLibrary . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( identity . getName (  )  )  )  )  ,    getBaseName (  )  ,    getCppSource (  )  ,    getAllHeaderDirs (  )  ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addStaticLibrary"], "fileName": "org.gradle.language.cpp.internal.DefaultCppLibrary"}, {"methodBody": ["METHOD_START", "{", "action . execute ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["dependencies"], "fileName": "org.gradle.language.cpp.internal.DefaultCppLibrary"}, {"methodBody": ["METHOD_START", "{", "return   apiElements ;", "}", "METHOD_END"], "methodName": ["getApiElements"], "fileName": "org.gradle.language.cpp.internal.DefaultCppLibrary"}, {"methodBody": ["METHOD_START", "{", "variants . add ( variant )  ;", "}", "METHOD_END"], "methodName": ["addVariant"], "fileName": "org.gradle.language.cpp.internal.MainExecutableVariant"}, {"methodBody": ["METHOD_START", "{", "artifacts . add ( artifact )  ;", "}", "METHOD_END"], "methodName": ["addArtifact"], "fileName": "org.gradle.language.cpp.internal.MainLibraryVariant"}, {"methodBody": ["METHOD_START", "{", "variants . add ( variant )  ;", "}", "METHOD_END"], "methodName": ["addVariant"], "fileName": "org.gradle.language.cpp.internal.MainLibraryVariant"}, {"methodBody": ["METHOD_START", "{", "final   String   hash    =    HashUtil . compactStringFor ( moduleMap . getHashCode (  )  )  ;", "return   cache . useCache ( new   internal . Factory < File >  (  )     {", "@ Override", "public   File   create (  )     {", "File   dir    =    new   File ( cache . getBaseDir (  )  ,     (  (  (  \" maps /  \"     +    hash )     +     \"  /  \"  )     +     ( moduleMap . getModuleName (  )  )  )  )  ;", "File   moduleMapFile    =    new   File ( dir ,     \" module . modulemap \"  )  ;", "if    (  !  ( moduleMapFile . isFile (  )  )  )     {", "generateFile ( moduleMapFile ,    moduleMap . getModuleName (  )  ,    moduleMap . getPublicHeaderPaths (  )  )  ;", "}", "return   moduleMapFile ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getModuleMapFile"], "fileName": "org.gradle.language.cpp.internal.NativeDependencyCache"}, {"methodBody": ["METHOD_START", "{", "final   String   hash    =    HashUtil . compactStringFor ( fileHasher . hash ( headersZip )  )  ;", "return   cache . useCache ( new   internal . Factory < File >  (  )     {", "@ Override", "public   File   create (  )     {", "File   dir    =    new   File ( cache . getBaseDir (  )  ,     (  ( hash    +     \"  /  \"  )     +    baseName )  )  ;", "if    ( dir . isDirectory (  )  )     {", "return   dir ;", "}", "try    {", "unzipTo ( headersZip ,    dir )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException (  (  \" Could   not   unzip   headers   from    \"     +    headersZip )  ,    e )  ;", "}", "return   dir ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getUnpackedHeaders"], "fileName": "org.gradle.language.cpp.internal.NativeDependencyCache"}, {"methodBody": ["METHOD_START", "{", "ZipInputStream   inputStream    =    new   ZipInputStream ( new   BufferedInputStream ( new   FileInputStream ( headersZip )  )  )  ;", "try    {", "ZipEntry   entry    =    null ;", "while    (  ( entry    =    inputStream . getNextEntry (  )  )     !  =    null )     {", "if    ( entry . isDirectory (  )  )     {", "continue ;", "}", "File   outFile    =    new   File ( unzipDir ,    entry . getName (  )  )  ;", "Files . createParentDirs ( outFile )  ;", "FileOutputStream   outputStream    =    new   FileOutputStream ( outFile )  ;", "try    {", "IOUtils . copyLarge ( inputStream ,    outputStream )  ;", "}    fily    {", "outputStream . close (  )  ;", "}", "}", "}    fily    {", "inputStream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["unzipTo"], "fileName": "org.gradle.language.cpp.internal.NativeDependencyCache"}, {"methodBody": ["METHOD_START", "{", "return   linkUsage ;", "}", "METHOD_END"], "methodName": ["getLinkUsageContext"], "fileName": "org.gradle.language.cpp.internal.NativeVariantIdentity"}, {"methodBody": ["METHOD_START", "{", "return   operatingSystemFamily ;", "}", "METHOD_END"], "methodName": ["getOperatingSystemFamily"], "fileName": "org.gradle.language.cpp.internal.NativeVariantIdentity"}, {"methodBody": ["METHOD_START", "{", "return   runtimeUsage ;", "}", "METHOD_END"], "methodName": ["getRuntimeUsageContext"], "fileName": "org.gradle.language.cpp.internal.NativeVariantIdentity"}, {"methodBody": ["METHOD_START", "{", "return   debuggable ;", "}", "METHOD_END"], "methodName": ["isDebuggable"], "fileName": "org.gradle.language.cpp.internal.NativeVariantIdentity"}, {"methodBody": ["METHOD_START", "{", "return   optimized ;", "}", "METHOD_END"], "methodName": ["isOptimized"], "fileName": "org.gradle.language.cpp.internal.NativeVariantIdentity"}, {"methodBody": ["METHOD_START", "{", "if    ( isDimensionVisible ( multivalueProperty )  )     {", "return   StringUtils . capitalize ( dimensionValue . getName (  )  . toLowerCase (  )  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["createDimensionSuffix"], "fileName": "org.gradle.language.cpp.plugins.CppApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( multivalueProperty . size (  )  )     >     1  ;", "}", "METHOD_END"], "methodName": ["isDimensionVisible"], "fileName": "org.gradle.language.cpp.plugins.CppApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( isDimensionVisible ( multivalueProperty )  )     {", "return   StringUtils . capitalize ( dimensionValue . getName (  )  . toLowerCase (  )  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["createDimensionSuffix"], "fileName": "org.gradle.language.cpp.plugins.CppLibraryPlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( multivalueProperty . size (  )  )     >     1  ;", "}", "METHOD_END"], "methodName": ["isDimensionVisible"], "fileName": "org.gradle.language.cpp.plugins.CppLibraryPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state )     !  =     ( DefaultBinaryCollection . State . Collecting )  )     {", "throw   new   IllegalStateException (  \" Cannot   add   an   element   to   this   collection   as   it   has   already   been   realized .  \"  )  ;", "}", "elements . add ( element )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.language.internal.DefaultBinaryCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state )     !  =     ( DefaultBinaryCollection . State . Collecting )  )     {", "throw   new   IllegalStateException (  \" Cannot   realize   this   collection   as   it   has   already   been   realized .  \"  )  ;", "}", "state    =    DefaultBinaryCollection . State . Realizing ;", "for    ( T   element    :    elements )     {", "knownActions . execute ( element )  ;", "}", "knownActions    =    ImmutableActionSet . empty (  )  ;", "for    ( DefaultBinaryCollection < T >  . SingleElementProvider <  ?  >    provider    :    pending )     {", "provider . selectNow (  )  ;", "}", "pending    =    null ;", "for    ( T   element    :    elements )     {", "configureActions . execute ( element )  ;", "}", "configureActions    =    ImmutableActionSet . empty (  )  ;", "state    =    DefaultBinaryCollection . State . Finalized ;", "for    ( T   element    :    elements )     {", "finalizeActions . execute ( element )  ;", "}", "finalizeActions    =    ImmutableActionSet . empty (  )  ;", "}", "METHOD_END"], "methodName": ["realizeNow"], "fileName": "org.gradle.language.internal.DefaultBinaryCollection"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyHandler"], "fileName": "org.gradle.language.internal.DefaultComponentDependencies"}, {"methodBody": ["METHOD_START", "{", "return   implementation ;", "}", "METHOD_END"], "methodName": ["getImplementationDependencies"], "fileName": "org.gradle.language.internal.DefaultComponentDependencies"}, {"methodBody": ["METHOD_START", "{", "return   apiDependencies ;", "}", "METHOD_END"], "methodName": ["getApiDependencies"], "fileName": "org.gradle.language.internal.DefaultLibraryDependencies"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getDependencies (  )  )  ;", "}", "METHOD_END"], "methodName": ["dependencies"], "fileName": "org.gradle.language.internal.DefaultNativeBinary"}, {"methodBody": ["METHOD_START", "{", "return   dependencies . getImplementationDependencies (  )  ;", "}", "METHOD_END"], "methodName": ["getImplementationDependencies"], "fileName": "org.gradle.language.internal.DefaultNativeBinary"}, {"methodBody": ["METHOD_START", "{", "return   objectsDir ;", "}", "METHOD_END"], "methodName": ["getObjectsDir"], "fileName": "org.gradle.language.internal.DefaultNativeBinary"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    iterable )     {", "list . add ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.language.nativeplatform.internal.AbstractNativeCompileSpec"}, {"methodBody": ["METHOD_START", "{", "return   debuggable ;", "}", "METHOD_END"], "methodName": ["isDebuggable"], "fileName": "org.gradle.language.nativeplatform.internal.BuildType"}, {"methodBody": ["METHOD_START", "{", "return   optimized ;", "}", "METHOD_END"], "methodName": ["isOptimized"], "fileName": "org.gradle.language.nativeplatform.internal.BuildType"}, {"methodBody": ["METHOD_START", "{", "task . getToolChain (  )  . set ( binary . getToolChain (  )  )  ;", "task . getTargetPlatform (  )  . set ( binary . getTargetPlatform (  )  )  ;", "task . setPositionIndependentCode (  ( binary   instanceof   SharedLibraryBinarySpec )  )  ;", "task . includes (  (  ( HeaderExportingSourceSet )     ( sourceSet )  )  . getExportedHeaders (  )  . getSourceDirectories (  )  )  ;", "task . includes ( new   Callable < List < FileCollection >  >  (  )     {", "public   List < FileCollection >    call (  )     {", "Collection < NativeDependencySet >    libs    =    binary . getLibs (  (  ( DependentSourceSet )     ( sourceSet )  )  )  ;", "return   CollectionUtils . collect ( libs ,    new   api . Transformer < FileCollection ,    NativeDependencySet >  (  )     {", "public   FileCollection   transform ( NativeDependencySet   original )     {", "return   original . getIncludeRoots (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "FileCollectionFactory   fileCollectionFactory    =     (  ( ProjectInternal )     ( task . getProject (  )  )  )  . getServices (  )  . get ( FileCollectionFactory . class )  ;", "task . getSystemIncludes (  )  . from ( fileCollectionFactory . create ( new   MinimalFileSet (  )     {", "@ Override", "public   Set < File >    getFiles (  )     {", "PlatformToolProvider   platformToolProvider    =     (  ( NativeToolChainInternal )     ( binary . getToolChain (  )  )  )  . select (  (  ( NativePlatformInternal )     ( binary . getTargetPlatform (  )  )  )  )  ;", "ToolType   toolType    =    determineToolType ( languageTransform . getLanguageName (  )  )  ;", "return   new   LinkedHashSet < File >  ( platformToolProvider . getSystemLibraries ( toolType )  . getIncludeDirs (  )  )  ;", "}", "@ Override", "public   String   getDisplayName (  )     {", "return    \" System   includes   for    \"     +     ( binary . getToolChain (  )  . getDisplayName (  )  )  ;", "}", "}  )  )  ;", "for    ( String   toolName    :    languageTransform . getBinaryTools (  )  . keySet (  )  )     {", "Tool   tool    =    binary . getToolByName ( toolName )  ;", "if    ( tool   instanceof   PreprocessingTool )     {", "task . setMacros (  (  ( PreprocessingTool )     ( tool )  )  . getMacros (  )  )  ;", "}", "task . getCompilerArgs (  )  . set ( tool . getArgs (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureCompileTaskCommon"], "fileName": "org.gradle.language.nativeplatform.internal.CompileTaskConfig"}, {"methodBody": ["METHOD_START", "{", "if    ( languageName . equals (  \" cpp \"  )  )     {", "return   ToolType . CPP _ COMPILER ;", "}", "return   ToolType . C _ COMPILER ;", "}", "METHOD_END"], "methodName": ["determineToolType"], "fileName": "org.gradle.language.nativeplatform.internal.CompileTaskConfig"}, {"methodBody": ["METHOD_START", "{", "final   PatternSet   patternSet    =    new   PatternSet (  )  ;", "for    ( String   sourceExtension    :    sourceExtensions )     {", "patternSet . include (  (  \"  *  *  /  *  .  \"     +    sourceExtension )  )  ;", "}", "return   fileOperations . files ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "FileTree   tree ;", "if    ( source . getFrom (  )  . isEmpty (  )  )     {", "tree    =    fileOperations . fileTree ( dLocation )  ;", "} else    {", "tree    =    source . getAsFileTree (  )  ;", "}", "return   tree . matching ( patternSet )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createSourceView"], "fileName": "org.gradle.language.nativeplatform.internal.DefaultNativeComponent"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.nativeplatform.internal.DefaultNativeComponent"}, {"methodBody": ["METHOD_START", "{", "action . execute ( source )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.language.nativeplatform.internal.DefaultNativeComponent"}, {"methodBody": ["METHOD_START", "{", "return   getDisplayName (  )  . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.language.nativeplatform.internal.DefaultNativeComponent"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" main \"  )  )     {", "return   new    . Main (  )  ;", "}", "if    ( name . endsWith (  \" Executable \"  )  )     {", "return   new    . Other ( name . substring (  0  ,     (  ( name . length (  )  )     -     1  0  )  )  )  ;", "}", "return   new    . Other ( name )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.language.nativeplatform.internal.Names"}, {"methodBody": ["METHOD_START", "{", "return   sourceFileStates . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceInputs"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.BuildableCompilationState"}, {"methodBody": ["METHOD_START", "{", "sourceFileStates . put ( file ,    sourceFileState )  ;", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.BuildableCompilationState"}, {"methodBody": ["METHOD_START", "{", "return   new   CompilationState ( ImmutableMap . copyOf ( sourceFileStates )  )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.BuildableCompilationState"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( includeDirectives . hasMacros (  )  )  )     &  &     (  !  ( includeDirectives . hasMacroFunctions (  )  )  )  )     {", "return ;", "}", "if    (  ( visible )     =  =    null )     {", "visible    =    new   LinkedHashMap < File ,    IncludeDirectives >  (  )  ;", "visible . put ( file ,    includeDirectives )  ;", "} else", "if    (  !  ( visible . containsKey ( file )  )  )     {", "visible . put ( file ,    includeDirectives )  ;", "}", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CollectingMacroLookup"}, {"methodBody": ["METHOD_START", "{", "uncollected . add ( source )  ;", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CollectingMacroLookup"}, {"methodBody": ["METHOD_START", "{", "collectAll (  )  ;", "if    (  ( visible )     !  =    null )     {", "for    ( Map . Entry < File ,    IncludeDirectives >    entry    :    visible . entrySet (  )  )     {", "lookup . append ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["appendTo"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CollectingMacroLookup"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( uncollected . isEmpty (  )  )  )     {", ". MacroSource   source    =    uncollected . remove (  0  )  ;", "source . collectInto ( this )  ;", "}", "}", "METHOD_END"], "methodName": ["collectAll"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CollectingMacroLookup"}, {"methodBody": ["METHOD_START", "{", "return   fileStates ;", "}", "METHOD_END"], "methodName": ["getFileStates"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CompilationState"}, {"methodBody": ["METHOD_START", "{", "return   fileStates . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceInputs"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CompilationState"}, {"methodBody": ["METHOD_START", "{", "return   fileStates . get ( file )  ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.CompilationState"}, {"methodBody": ["METHOD_START", "{", "for    ( final   File   includeRoot    :    includeRoots )     {", "logger . info (  \" adding   files   in    {  }    to   header   dependencies   for    {  }  \"  ,    includeRoot ,    taskPath )  ;", "directoryFileTreeFactory . create ( includeRoot )  . visit ( new   EmptyFileVisitor (  )     {", "@ Override", "public   void   visitFile ( FileVisitDetails   fileDetails )     {", "h . add ( fileDetails . getFile (  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["addIncludeRoots"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultHeaderDependenciesCollector"}, {"methodBody": ["METHOD_START", "{", "File   sourceDir    =    sourceFile . getParentFile (  )  ;", "if    (  (  ( iPaths . size (  )  )     >     1  )     &  &     ( iPaths . get (  0  )  . equals ( sourceDir )  )  )     {", "return   iPaths ;", "}", "List < File >    quotedSearchPath    =    new   ArrayList < File >  (  (  ( iPaths . size (  )  )     +     1  )  )  ;", "quotedSearchPath . add ( sourceDir )  ;", "quotedSearchPath . addAll ( iPaths )  ;", "return   quotedSearchPath ;", "}", "METHOD_END"], "methodName": ["prependSourceDir"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "Collection < Expression >    expressions    =    resolveTokenConcatenationToTokens ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "for    ( Expression   concatExpression    :    expressions )     {", "resolveExpression ( visibleMacros ,    concatExpression . asMacroExpansion (  )  ,    visitor ,    tokenLookup )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveAndExpandTokenConcatenation"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . SYSTEM )  )     {", "visitor . visitSystem ( expression )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . QUOTED )  )     {", "visitor . visitQuoted ( expression )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . IDENTIFIER )  )     {", "visitor . visitIdentifier ( expression )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . ARGS _ LIST )  )     {", "visitor . visitTokens ( expression )  ;", "} else    {", "if    (  !  ( visitor . startVisit ( expression )  )  )     {", "return ;", "}", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . MACRO )  )     {", "resolveMacro ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . MACRO _ FUNCTION )  )     {", "resolveMacroFunction ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . TOKEN _ CONCATENATION )  )     {", "resolveTokenConcatenation ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . EXPAND _ TOKEN _ CONCATENATION )  )     {", "resolveAndExpandTokenConcatenation ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "} else", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . EXPRESSIONS )  )     {", "resolveExpressionSequence ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "} else    {", "visitor . visitUnresolved (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resolveExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "List < Expression >    expressions    =    expression . getArguments (  )  ;", "if    (  ( expressions . size (  )  )     <     2  )     {", "visitor . visitUnrd (  )  ;", "return ;", "}", "Expression   argListExpression    =    expressions . get (  (  ( expressions . size (  )  )     -     1  )  )  ;", "List < Expression >    headExpressions    =    expressions . subList (  0  ,     (  ( expressions . size (  )  )     -     1  )  )  ;", "Collection < Expression >    args    =    rExpressionToTokens ( visibleMacros ,    argListExpression ,    visitor ,    tokenLookup )  ;", "for    ( Expression   value    :    args )     {", "rExpressionSequenceForArgs ( visibleMacros ,    headExpressions ,    value ,    visitor ,    tokenLookup )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveExpressionSequence"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . getType (  )  )     !  =     ( IncludeType . ARGS _ LIST )  )     {", "visitor . visitUnresolved (  )  ;", "return ;", "}", "Expression   macroFunctionExpression    =    expressions . get (  (  ( expressions . size (  )  )     -     1  )  )  ;", "List < Expression >    headExpressions    =    expressions . subList (  0  ,     (  ( expressions . size (  )  )     -     1  )  )  ;", "Collection < Expression >    identifiers    =    resolveExpressionToTokens ( visibleMacros ,    macroFunctionExpression ,    visitor ,    tokenLookup )  ;", "for    ( Expression   value    :    identifiers )     {", "if    (  ( value . getType (  )  )     !  =     ( IncludeType . IDENTIFIER )  )     {", "visitor . visitUnresolved (  )  ;", "continue ;", "}", "ComplexExpression   macroExpression    =    new   ComplexExpression ( IncludeType . MACRO _ FUNCTION ,    value . getValue (  )  ,    args . getArguments (  )  )  ;", "if    ( headExpressions . isEmpty (  )  )     {", "resolveExpression ( visibleMacros ,    macroExpression ,    visitor ,    tokenLookup )  ;", "return ;", "}", "Collection < Expression >    resolved    =    resolveExpressionToTokens ( visibleMacros ,    macroExpression ,    visitor ,    tokenLookup )  ;", "for    ( Expression   newArgs    :    resolved )     {", "resolveExpressionSequenceForArgs ( visibleMacros ,    headExpressions ,    newArgs ,    visitor ,    tokenLookup )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resolveExpressionSequenceForArgs"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . TOKEN _ CONCATENATION )  )     {", "return   resolveTokenConcatenationToTokens ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "}", "if    (  (  (  ( expression . getType (  )  )     !  =     ( IncludeType . MACRO )  )     &  &     (  ( expression . getType (  )  )     !  =     ( IncludeType . MACRO _ FUNCTION )  )  )     &  &     (  ( expression . getType (  )  )     !  =     ( IncludeType . EXPAND _ TOKEN _ CONCATENATION )  )  )     {", "return   Collections . singletonList ( expression )  ;", "}", "if    (  !  ( tokenLookup . hasTokensFor ( expression )  )  )     {", "resolveExpression ( visibleMacros ,    expression ,    new    . CollectTokens ( tokenLookup ,    expression )  ,    tokenLookup )  ;", "}", "if    ( tokenLookup . isUnresolved ( expression )  )     {", "visitor . visitUnresolved (  )  ;", "}", "return   tokenLookup . tokensFor ( expression )  ;", "}", "METHOD_END"], "methodName": ["resolveExpressionToTokens"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "boolean   found    =    false ;", "for    ( Directives   includeDirectives    :    visibleMacros )     {", "Iterable < Macro >    macros    =    includeDirectives . getMacros ( expression . getValue (  )  )  ;", "for    ( Macro   macro    :    macros )     {", "found    =    true ;", "resolveExpression ( visibleMacros ,    macro ,    visitor ,    tokenLookup )  ;", "}", "}", "if    (  ! found )     {", "visitor . visitIdentifier ( new   SimpleExpression ( expression . getValue (  )  ,    Type . IDENTIFIER )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveMacro"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "boolean   found    =    false ;", "for    ( Directives   includeDirectives    :    visibleMacros )     {", "Iterable < MacroFunction >    macroFunctions    =    includeDirectives . getMacroFunctions ( expression . getValue (  )  )  ;", "for    ( MacroFunction   macro    :    macroFunctions )     {", "List < Expression >    arguments    =    expression . getArguments (  )  ;", "if    (  ( arguments . isEmpty (  )  )     &  &     (  ( macro . getParameterCount (  )  )     =  =     1  )  )     {", "arguments    =    Collections . singletonList ( SimpleExpression . EMPTY _ EXPRESSIONS )  ;", "}", "if    (  ( macro . getParameterCount (  )  )     =  =     ( arguments . size (  )  )  )     {", "found    =    true ;", "Expression   result    =    macro . evaluate ( arguments )  ;", "resolveExpression ( visibleMacros ,    result ,    visitor ,    tokenLookup )  ;", "}", "}", "}", "if    (  ! found )     {", "visitor . visitUnresolved (  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveMacroFunction"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "Collection < Expression >    expressions    =    resolveTokenConcatenationToTokens ( visibleMacros ,    expression ,    visitor ,    tokenLookup )  ;", "for    ( Expression   concatExpression    :    expressions )     {", "resolveExpression ( visibleMacros ,    concatExpression ,    visitor ,    tokenLookup )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveTokenConcatenation"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "Expression   left    =    expression . getArguments (  )  . get (  0  )  ;", "Expression   right    =    expression . getArguments (  )  . get (  1  )  ;", "Collection < Expression >    leftValues    =    resolveExpressionToTokens ( visibleMacros ,    left ,    visitor ,    tokenLookup )  ;", "Collection < Expression >    rightValues    =    resolveExpressionToTokens ( visibleMacros ,    right ,    visitor ,    tokenLookup )  ;", "if    (  ( leftValues . isEmpty (  )  )     |  |     ( rightValues . isEmpty (  )  )  )     {", "return   Collections . emptyList (  )  ;", "}", "List < Expression >    expressions    =    new   ArrayList < Expression >  (  (  ( leftValues . size (  )  )     *     ( rightValues . size (  )  )  )  )  ;", "for    ( Expression   leftValue    :    leftValues )     {", "if    (  ( leftValue . getType (  )  )     !  =     ( Type . IDENTIFIER )  )     {", "if    (  ( rightValues . size (  )  )     =  =     1  )     {", "Expression   rightValue    =    rightValues . iterator (  )  . next (  )  ;", "if    (  (  ( rightValue . getType (  )  )     =  =     ( Type . EXPRESSIONS )  )     &  &     ( rightValue . getArguments (  )  . isEmpty (  )  )  )     {", "expressions . add ( leftValue )  ;", "continue ;", "}", "}", "visitor . visitUnresolved (  )  ;", "continue ;", "}", "String   leftString    =    leftValue . getValue (  )  ;", "for    ( Expression   rightValue    :    rightValues )     {", "if    (  ( rightValue . getType (  )  )     =  =     ( Type . IDENTIFIER )  )     {", "expressions . add ( new   SimpleExpression (  ( leftString    +     ( rightValue . getValue (  )  )  )  ,    Type . IDENTIFIER )  )  ;", "continue ;", "}", "if    (  ( rightValue . getType (  )  )     =  =     ( Type . ARGS _ LIST )  )     {", "expressions . add ( new   ComplexExpression ( Type . MACRO _ FUNCTION ,    leftString ,    rightValue . getArguments (  )  )  )  ;", "continue ;", "}", "if    (  (  ( rightValue . getType (  )  )     =  =     ( Type . EXPRESSIONS )  )     &  &     ( rightValue . getArguments (  )  . isEmpty (  )  )  )     {", "expressions . add ( new   SimpleExpression ( leftString ,    Type . IDENTIFIER )  )  ;", "continue ;", "}", "visitor . visitUnresolved (  )  ;", "}", "}", "return   expressions ;", "}", "METHOD_END"], "methodName": ["resolveTokenConcatenationToTokens"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( File   searchDir    :    searchPath )     {", "Map < String ,     . IncludeFileImpl >    searchedIncludes    =    includeRoots . get ( searchDir )  ;", "if    ( searchedIncludes    =  =    null )     {", "searchedIncludes    =    new   HashMap < String ,     . IncludeFileImpl >  (  )  ;", "includeRoots . put ( searchDir ,    searchedIncludes )  ;", "}", "if    ( searchedIncludes . containsKey ( include )  )     {", ". IncludeFileImpl   includeFile    =    searchedIncludes . get ( include )  ;", "if    (  ( includeFile . snapshot . getType (  )  )     =  =     ( FileType . RegularFile )  )     {", "dependencies . resolved ( includeFile )  ;", "return ;", "}", "continue ;", "}", "File   candidate    =    new   File ( searchDir ,    include )  ;", "FileSnapshot   fileSnapshot    =    fileSystemSnapshotter . snapshotSelf ( candidate )  ;", ". IncludeFileImpl   includeFile    =     (  ( fileSnapshot . getType (  )  )     =  =     ( FileType . RegularFile )  )     ?    new    . IncludeFileImpl ( candidate ,    fileSnapshot )     :    new    . IncludeFileImpl ( null ,    fileSnapshot )  ;", "searchedIncludes . put ( include ,    includeFile )  ;", "if    (  ( fileSnapshot . getType (  )  )     =  =     ( FileType . RegularFile )  )     {", "dependencies . resolved ( includeFile )  ;", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["searchForDependency"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.DefaultSourceIncludesResolver"}, {"methodBody": ["METHOD_START", "{", "return   hash ;", "}", "METHOD_END"], "methodName": ["getHash"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncludeFileState"}, {"methodBody": ["METHOD_START", "{", "return   includeFile ;", "}", "METHOD_END"], "methodName": ["getIncludeFile"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncludeFileState"}, {"methodBody": ["METHOD_START", "{", "return   new   IncrementalCompileFilesFactory . DefaultIncementalCompileSourceProcessor ( previousCompileState )  ;", "}", "METHOD_END"], "methodName": ["filesFor"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncrementalCompileFilesFactory"}, {"methodBody": ["METHOD_START", "{", "return   buildOperationExecutor . call ( new   CallableBuildOperation < IncrementalCompilation >  (  )     {", "@ Override", "public   IncrementalCompilation   call ( BuildOperationContext   context )     {", "CompilationState   previousCompileState    =    previousCompileStateCache . get (  )  ;", "IncementalCompileSourceProcessor   processor    =    incrementalCompileFilesFactory . filesFor ( previousCompileState )  ;", "for    ( File   sourceFile    :    sourceFiles )     {", "processor . processSource ( sourceFile )  ;", "}", "return   processor . getResult (  )  ;", "}", "@ Override", "public   Builder   description (  )     {", "ProcessSourceFilesDetails   operationDetails    =    new   ProcessSourceFilesDetails ( sourceFiles . size (  )  )  ;", "return   BuildOperationDescriptor . displayName (  \" Processing   source   files \"  )  . details ( operationDetails )  ;", "}", "class   ProcessSourceFilesDetails    {", "private   final   int   sourceFileCount ;", "ProcessSourceFilesDetails ( int   sourceFileCount )     {", "this . sourceFileCount    =    sourceFileCount ;", "}", "public   int   getSourceFileCount (  )     {", "return   sourceFileCount ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["processSourceFiles"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncrementalCompileProcessor"}, {"methodBody": ["METHOD_START", "{", "SimpleStaleClassCleaner   cleaner    =    new   SimpleStaleClassCleaner ( outputs )  ;", "cleaner . setDestionDir ( spec . getObjectFileDir (  )  )  ;", "cleaner . execute (  )  ;", "return   cleaner . getDidWork (  )  ;", "}", "METHOD_END"], "methodName": ["cleanPreviousOutputs"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncrementalNativeCompiler"}, {"methodBody": ["METHOD_START", "{", "boolean   deleted    =    cleanPreviousOutputs ( spec )  ;", "WorkResult   compileResult    =    delegat . execute ( spec )  ;", "if    ( deleted    &  &     (  !  ( compileResult . getDidWork (  )  )  )  )     {", "return   WorkResults . didWork ( true )  ;", "}", "return   compileResult ;", "}", "METHOD_END"], "methodName": ["doCleanIncrementalCompile"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncrementalNativeCompiler"}, {"methodBody": ["METHOD_START", "{", "spec . setSourceFiles ( compilation . getRecompile (  )  )  ;", "spec . setRemovedSourceFiles ( compilation . getRemoved (  )  )  ;", "return   delegat . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["doIncrementalCompile"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.IncrementalNativeCompiler"}, {"methodBody": ["METHOD_START", "{", "return   hash ;", "}", "METHOD_END"], "methodName": ["getHash"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.SourceFileState"}, {"methodBody": ["METHOD_START", "{", "return   resolvedIncludes ;", "}", "METHOD_END"], "methodName": ["getResolvedIncludes"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.SourceFileState"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( hash . equals ( previousState . hash )  )  )     |  |     (  !  ( resolvedIncludes . equals ( previousState . resolvedIncludes )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasChanged"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.SourceFileState"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tokensFor )     =  =    null )     {", "tokensFor    =    LinkedHashMultimap . create (  )  ;", "}", "tokensFor . put ( expression ,    tokens )  ;", "}", "METHOD_END"], "methodName": ["addTokensFor"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.TokenLookup"}, {"methodBody": ["METHOD_START", "{", "return    (  ( tokensFor )     !  =    null )     &  &     ( tokensFor . containsKey ( expression )  )  ;", "}", "METHOD_END"], "methodName": ["hasTokensFor"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.TokenLookup"}, {"methodBody": ["METHOD_START", "{", "return    (  ( broken )     !  =    null )     &  &     ( broken . contains ( expression )  )  ;", "}", "METHOD_END"], "methodName": ["isUnresolved"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.TokenLookup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tokensFor )     =  =    null )     {", "return   Collections . emptyList (  )  ;", "}", "return   tokensFor . get ( expression )  ;", "}", "METHOD_END"], "methodName": ["tokensFor"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.TokenLookup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( broken )     =  =    null )     {", "broken    =    new   HashSet < Expression >  (  )  ;", "}", "broken . add ( expression )  ;", "}", "METHOD_END"], "methodName": ["unresolved"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.TokenLookup"}, {"methodBody": ["METHOD_START", "{", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . IDENTIFIER )  )     {", "return   new   Simple ( expression . getValue (  )  ,    IncludeType . MACRO )  ;", "}", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . TOKEN _ CONCATENATION )  )     {", "return   new   Complex ( IncludeType . EXPAND _ TOKEN _ CONCATENATION ,    expression . getValue (  )  ,    expression . getArguments (  )  )  ;", "}", "if    (  (  ( expression . getType (  )  )     =  =     ( IncludeType . ARGS _ LIST )  )     &  &     (  !  ( expression . getArguments (  )  . isEmpty (  )  )  )  )     {", "List <  >    mapped    =    new   ArrayList <  >  ( expression . getArguments (  )  . size (  )  )  ;", "for    (    arg    :    expression . getArguments (  )  )     {", "mapped . add ( arg . asMacroExpansion (  )  )  ;", "}", "return   new   Complex ( IncludeType . ARGS _ LIST ,    null ,    mapped )  ;", "}", "return   expression ;", "}", "METHOD_END"], "methodName": ["asMacroExpansion"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.AbstractExpression"}, {"methodBody": ["METHOD_START", "{", "return   AbstractExpression . format ( expression . getType (  )  ,    expression . getValue (  )  ,    expression . getArguments (  )  )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.AbstractExpression"}, {"methodBody": ["METHOD_START", "{", "switch    ( type )     {", "case   QUOTED    :", "return    (  '  \"  '     +    value )     +     '  \"  '  ;", "case   SYSTEM    :", "return    (  '  <  '     +    value )     +     '  >  '  ;", "case   MACRO    :", "case   IDENTIFIER    :", "case   TOKEN    :", "return   value ;", "case   TOKEN _ CONCATENATION    :", "case   EXPAND _ TOKEN _ CONCATENATION    :", "return    (  ( arguments . get (  0  )  . getAsSText (  )  )     +     \"  #  #  \"  )     +     ( arguments . get (  1  )  . getAsSText (  )  )  ;", "case   MACRO _ FUNCTION    :", "return    (  ( value    +     \"  (  \"  )     +     ( Joiner . on (  \"  ,     \"  )  . join ( arguments )  )  )     +     \"  )  \"  ;", "case   EXPRESSIONS    :", "return   Joiner . on (  \"     \"  )  . join ( arguments )  ;", "case   ARGS _ LIST    :", "return    (  \"  (  \"     +     ( Joiner . on (  \"  ,     \"  )  . join ( arguments )  )  )     +     \"  )  \"  ;", "default    :", "return   value    !  =    null    ?    value    :     \"  ?  ?  \"  ;", "}", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.AbstractExpression"}, {"methodBody": ["METHOD_START", "{", "return    \"  =  >     ?  ?  ?  \"  ;", "}", "METHOD_END"], "methodName": ["getBody"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.AbstractMacroFunction"}, {"methodBody": ["METHOD_START", "{", "return   argsMap ;", "}", "METHOD_END"], "methodName": ["getArgsMap"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ArgsMappingMacroFunction"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ArgsMappingMacroFunction"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ArgsMappingMacroFunction"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ArgsMappingMacroFunction"}, {"methodBody": ["METHOD_START", "{", "int   replaceWith    =    argsMap [ currentMapPos ]  ;", "currentMapPos +  +  ;", "if    ( replaceWith    =  =     ( ArgsMappingMacroFunction . KEEP )  )     {", "mapped . add ( expression )  ;", "} else", "if    ( replaceWith    =  =     ( ArgsMappingMacroFunction . REPLACE _ ARGS )  )     {", "List < Expression >    mappedArgs    =    new   ArrayList < Expression >  ( expression . getArguments (  )  . size (  )  )  ;", "for    ( Expression   arg    :    expression . getArguments (  )  )     {", "currentMapPos    =    mapInto ( arg ,    arguments ,    currentMapPos ,    mappedArgs )  ;", "}", "mapped . add ( new   ComplexExpression ( expression . getType (  )  ,    expression . getValue (  )  ,    mappedArgs )  )  ;", "} else", "if    (  ( type )     =  =     ( IncludeType . MACRO _ FUNCTION )  )     {", "mapped . add ( arguments . get ( replaceWith )  . asMacroExpansion (  )  )  ;", "} else    {", "mapped . add ( arguments . get ( replaceWith )  )  ;", "}", "return   currentMapPos ;", "}", "METHOD_END"], "methodName": ["mapInto"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ArgsMappingMacroFunction"}, {"methodBody": ["METHOD_START", "{", "return   IncludeWithSimpleExpression . INTERNER . intern ( new   IncludeWithSimpleExpression ( value ,    isImport ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.IncludeWithSimpleExpression"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( expression . getType (  )  )     =  =     ( IncludeType . MACRO _ FUNCTION )  )     &  &     (  !  ( expression . getArguments (  )  . isEmpty (  )  )  )  )     {", "return   new   IncludeWithMacroFunctionCallExpression ( expression . getValue (  )  ,    isImport ,    ImmutableList . copyOf ( expression . getArguments (  )  )  )  ;", "}", "return    . create ( expression . getValue (  )  ,    isImport ,    expression . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.IncludeWithSimpleExpression"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    RegexBackedCSourceParser . parseExpression ( value )  ;", "return    . create ( expression . getValue (  )  ,    isImport ,    expression . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.IncludeWithSimpleExpression"}, {"methodBody": ["METHOD_START", "{", "int   nextChar    =    next (  )  ;", "if    ( nextChar    =  =     '  \\ n '  )     {", "return   true ;", "} else", "if    ( nextChar    =  =     '  \\ r '  )     {", "int   followingChar    =    next (  )  ;", "if    ( followingChar    =  =     '  \\ n '  )     {", "return   true ;", "}", "pushBack ( nextChar )  ;", "pushBack ( followingChar )  ;", "return   false ;", "} else    {", "pushBack ( nextChar )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["discardNewLine"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.PreprocessingReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( readAheadChars [  0  ]  )     !  =     (  -  1  )  )     {", "int   ch    =    readAheadChars [  0  ]  ;", "readAheadChars [  0  ]     =    readAheadChars [  1  ]  ;", "readAheadChars [  1  ]     =     -  1  ;", "return   ch ;", "}", "return   r . read (  )  ;", "}", "METHOD_END"], "methodName": ["next"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.PreprocessingReader"}, {"methodBody": ["METHOD_START", "{", "if    (  ( readAheadChars [  1  ]  )     !  =     (  -  1  )  )     {", "throw   new   IllegalStateException (  )  ;", "}", "if    (  ( readAheadChars [  0  ]  )     !  =     (  -  1  )  )     {", "readAheadChars [  1  ]     =    ch ;", "} else    {", "readAheadChars [  0  ]     =    ch ;", "}", "}", "METHOD_END"], "methodName": ["pushBack"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.PreprocessingReader"}, {"methodBody": ["METHOD_START", "{", "int   ch    =    next (  )  ;", "if    ( ch    =  =     '  \\  \\  '  )     {", "if    ( discardNewLine (  )  )     {", "return   read (  )  ;", "}", "}", "if    (  ( ch    =  =     '  \"  '  )     &  &     (  !  ( quoted )  )  )     {", "inString    =     !  ( inString )  ;", "quoted    =    false ;", "} else", "if    ( ch    =  =     '  \\  \\  '  )     {", "quoted    =     !  ( quoted )  ;", "} else    {", "quoted    =    false ;", "if    (  !  ( inString )  )     {", "if    ( ch    =  =     '  /  '  )     {", "ch    =    next (  )  ;", "if    ( ch    =  =     '  /  '  )     {", "while    (  (  ( ch    !  =     '  \\ n '  )     &  &     ( ch    !  =     (  -  1  )  )  )     &  &     ( ch    !  =     '  \\ r '  )  )     {", "ch    =    next (  )  ;", "}", "} else", "if    ( ch    =  =     '  *  '  )     {", "while    ( ch    !  =     (  -  1  )  )     {", "ch    =    next (  )  ;", "if    ( ch    =  =     '  *  '  )     {", "ch    =    next (  )  ;", "while    ( ch    =  =     '  *  '  )     {", "ch    =    next (  )  ;", "}", "if    ( ch    =  =     '  /  '  )     {", "ch    =     '     '  ;", "break ;", "}", "}", "}", "} else    {", "pushBack ( ch )  ;", "ch    =     '  /  '  ;", "}", "}", "}", "}", "return   ch ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.PreprocessingReader"}, {"methodBody": ["METHOD_START", "{", "int   ch ;", "boolean   read    =    false ;", "while    (  ( ch    =    read (  )  )     >  =     0  )     {", "if    ( ch    =  =     '  \\ n '  )     {", "return   true ;", "}", "if    ( ch    =  =     '  \\ r '  )     {", "int   next    =    next (  )  ;", "if    ( next    !  =     '  \\ n '  )     {", "pushBack ( next )  ;", "}", "return   true ;", "}", "buffer . append (  (  ( char )     ( ch )  )  )  ;", "read    =    true ;", "}", "return   read ;", "}", "METHOD_END"], "methodName": ["readNextLine"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.PreprocessingReader"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    RegexBackedCSourceParser . readArgument ( buffer )  ;", "if    ( expression    =  =    null )     {", "if    (  !  ( buffer . has (  '  ,  '  )  )  )     {", "return ;", "}", "expression    =    SimpleExpression . EMPTY _ EXPRESSIONS ;", "}", "expressions . add ( expression )  ;", "while    ( true )     {", "buffer . consumeWhitespace (  )  ;", "if    (  !  ( buffer . consume (  '  ,  '  )  )  )     {", "return ;", "}", "expression    =    RegexBackedCSourceParser . readArgument ( buffer )  ;", "if    ( expression    =  =    null )     {", "expression    =    SimpleExpression . EMPTY _ EXPRESSIONS ;", "}", "expressions . add ( expression )  ;", "}", "}", "METHOD_END"], "methodName": ["consumeArgumentList"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    startOffset ;", "while    ( pos    <     ( value . length (  )  )  )     {", "char   ch    =    value . charAt ( pos )  ;", "if    (  (  (  !  ( Character . isLetterOrDigit ( ch )  )  )     &  &     ( ch    !  =     '  _  '  )  )     &  &     ( ch    !  =     '  $  '  )  )     {", "break ;", "}", "pos +  +  ;", "}", "return   pos ;", "}", "METHOD_END"], "methodName": ["consumeIdentifier"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "String   paramName    =    buffer . readIdentifier (  )  ;", "while    ( paramName    !  =    null )     {", "paramNames . add ( paramName )  ;", "buffer . consumeWhitespace (  )  ;", "if    (  !  ( buffer . consume (  '  ,  '  )  )  )     {", "return ;", "}", "buffer . consumeWhitespace (  )  ;", "paramName    =    buffer . readIdentifier (  )  ;", "if    ( paramName    =  =    null )     {", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["consumeParameterList"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    startOffset ;", "while    ( pos    <     ( value . length (  )  )  )     {", "char   ch    =    value . charAt ( pos )  ;", "if    (  (  !  ( Character . isWhitespace ( ch )  )  )     &  &     ( ch    !  =     0  )  )     {", "break ;", "}", "pos +  +  ;", "}", "return   pos ;", "}", "METHOD_END"], "methodName": ["consumeWhitespace"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "boolean   usesParameters    =    false ;", "for    ( int   i    =     0  ;    i    <     ( expression . getArgus (  )  . size (  )  )  ;    i +  +  )     {", "Expression   argu    =    expression . getArgus (  )  . get ( i )  ;", "if    (  ( argu . getType (  )  )     =  =     ( IncludeType . IDENTIFIER )  )     {", "boolean   matches    =    false ;", "for    ( int   j    =     0  ;    j    <     ( paramNames . size (  )  )  ;    j +  +  )     {", "String   paramName    =    paramNames . get ( j )  ;", "if    ( argu . getValue (  )  . equals ( paramName )  )     {", "argsMap . add ( j )  ;", "usesParameters    =    true ;", "matches    =    true ;", "break ;", "}", "}", "if    ( matches )     {", "continue ;", "}", "}", "if    ( argu . getArgus (  )  . isEmpty (  )  )     {", "argsMap . add ( ArgsMappingMacroFunction . KEEP )  ;", "continue ;", "}", "List < Integer >    nestedMap    =    new   ArrayList < Integer >  ( argu . getArgus (  )  . size (  )  )  ;", "boolean   argUsesParameters    =    mapArgs ( paramNames ,    argu ,    nestedMap )  ;", "if    ( argUsesParameters )     {", "argsMap . add ( ArgsMappingMacroFunction . REPLACE _ ARGS )  ;", "argsMap . addAll ( nestedMap )  ;", "} else    {", "argsMap . add ( ArgsMappingMacroFunction . KEEP )  ;", "}", "usesParameters    |  =    argUsesParameters ;", "}", "return   usesParameters ;", "}", "METHOD_END"], "methodName": ["mapArgs"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( buffer . consumeWhitespace (  )  )  )     {", "return ;", "}", "String   name    =    buffer . readIdentifier (  )  ;", "if    ( name    =  =    null )     {", "return ;", "}", "if    ( buffer . consume (  '  (  '  )  )     {", "MacroFunctionDirectiveBody ( buffer ,    name ,    macroFunctions )  ;", "} else    {", "MacroObjectDirectiveBody ( buffer ,    name ,    macros )  ;", "}", "}", "METHOD_END"], "methodName": ["parseDefineDirectiveBody"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   startPos    =    buffer . pos ;", "Expression   expression    =     . parseExpression ( buffer )  ;", "buffer . consumeWhitespace (  )  ;", "if    (  ( expression    =  =    null )     |  |     ( buffer . hasAny (  )  )  )     {", "return   new   SimpleExpression ( buffer . substring ( startPos )  . trim (  )  ,    IncludeType . OTHER )  ;", "}", "return   expression ;", "}", "METHOD_END"], "methodName": ["parseDirectiveBodyExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "RegexBackedCSourceParser . Buffer   buffer    =    new   RegexBackedCSourceParser . Buffer (  )  ;", "buffer . value . append ( value )  ;", "return   RegexBackedCSourceParser . parseDirectiveBodyExpression ( buffer )  . asMacroExpansion (  )  ;", "}", "METHOD_END"], "methodName": ["parseExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "buffer . consumeWhitespace (  )  ;", "if    (  !  ( buffer . hasAny (  )  )  )     {", "return   null ;", "}", "Expression   expression    =     . readPathExpression ( buffer )  ;", "if    ( expression    !  =    null )     {", "return   expression ;", "}", "List < Expression >    arguments    =     . readArgumentList ( buffer )  ;", "if    ( arguments    !  =    null )     {", "if    ( arguments . isEmpty (  )  )     {", "return   SimpleExpression . EMPTY _ ARGS ;", "} else    {", "return   new   ComplexExpression ( IncludeType . ARGS _ LIST ,    null ,    arguments )  ;", "}", "}", "String   identifier    =    buffer . readIdentifier (  )  ;", "if    ( identifier    =  =    null )     {", "String   token    =    buffer . readAnyExcept (  \"  (  )  ,  \"  )  ;", "if    ( token    !  =    null )     {", "return   new   SimpleExpression ( token ,    IncludeType . TOKEN )  ;", "}", "return   null ;", "}", "buffer . consumeWhitespace (  )  ;", "arguments    =     . readArgumentList ( buffer )  ;", "if    ( arguments    !  =    null )     {", "if    ( arguments . isEmpty (  )  )     {", "return   new   SimpleExpression ( identifier ,    IncludeType . MACRO _ FUNCTION )  ;", "} else    {", "return   new   ComplexExpression ( IncludeType . MACRO _ FUNCTION ,    identifier ,    arguments )  ;", "}", "}", "expression    =     . readTokenConcatenation ( buffer ,    identifier )  ;", "if    ( expression    !  =    null )     {", "return   expression ;", "}", "return   new   SimpleExpression ( identifier ,    IncludeType . IDENTIFIER )  ;", "}", "METHOD_END"], "methodName": ["parseExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( buffer . hasAny (  )  )  )     {", "return ;", "}", "if    ( buffer . hasIdentifierChar (  )  )     {", "return ;", "}", "Expression   expression    =     . parseDirectiveBodyExpression ( buffer )  ;", "if    (  (  (  ( expression . getType (  )  )     =  =     ( IncludeType . TOKEN _ CONCATENATION )  )     |  |     (  ( expression . getType (  )  )     =  =     ( IncludeType . ARGS _ LIST )  )  )     |  |     (  ( expression . getType (  )  )     =  =     ( IncludeType . EXPRESSIONS )  )  )     {", "expression    =    new   SimpleExpression ( expression . getAsSourceText (  )  ,    IncludeType . OTHER )  ;", "}", "expression    =    expression . asMacroExpansion (  )  ;", "if    (  (  ( expression . getType (  )  )     !  =     ( IncludeType . OTHER )  )     |  |     (  !  ( expression . getValue (  )  . isEmpty (  )  )  )  )     {", "includes . add ( IncludeWithSimpleExpression . create ( expression ,    isImport )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseIncludeOrImportDirectiveBody"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "buffer . consumeWhitespace (  )  ;", "List < String >    paramNames    =    new   ArrayList < String >  (  )  ;", "consumeParameterList ( buffer ,    paramNames )  ;", "if    (  !  ( buffer . consume (  '  )  '  )  )  )     {", "return ;", "}", "Expression   expression    =     . parseDirectiveBodyExpression ( buffer )  ;", "if    (  (  ( expression . getType (  )  )     =  =     ( IncludeType . QUOTED )  )     |  |     (  ( expression . getType (  )  )     =  =     ( IncludeType . SYSTEM )  )  )     {", "macroFunctions . add ( new   ReturnFixedValueMacroFunction ( macroName ,    paramNames . size (  )  ,    expression . getType (  )  ,    expression . getValue (  )  ,    Collections .  < Expression > emptyList (  )  )  )  ;", "return ;", "}", "if    (  ( expression . getType (  )  )     =  =     ( IncludeType . IDENTIFIER )  )     {", "for    ( int   i    =     0  ;    i    <     ( paramNames . size (  )  )  ;    i +  +  )     {", "String   name    =    paramNames . get ( i )  ;", "if    ( name . equals ( expression . getValue (  )  )  )     {", "macroFunctions . add ( new   ReturnParameterMacroFunction ( macroName ,    paramNames . size (  )  ,    i )  )  ;", "return ;", "}", "}", "macroFunctions . add ( new   ReturnFixedValueMacroFunction ( macroName ,    paramNames . size (  )  ,    IncludeType . MACRO ,    expression . getValue (  )  ,    Collections .  < Expression > emptyList (  )  )  )  ;", "return ;", "}", "if    (  ( expression . getType (  )  )     !  =     ( IncludeType . OTHER )  )     {", "if    (  ( paramNames . isEmpty (  )  )     |  |     ( expression . getArguments (  )  . isEmpty (  )  )  )     {", "expression    =    expression . asMacroExpansion (  )  ;", "macroFunctions . add ( new   ReturnFixedValueMacroFunction ( macroName ,    paramNames . size (  )  ,    expression . getType (  )  ,    expression . getValue (  )  ,    expression . getArguments (  )  )  )  ;", "return ;", "}", "List < Integer >    argsMap    =    new   ArrayList < Integer >  ( expression . getArguments (  )  . size (  )  )  ;", "boolean   usesArgs    =    mapArgs ( paramNames ,    expression ,    argsMap )  ;", "if    (  ! usesArgs )     {", "expression    =    expression . asMacroExpansion (  )  ;", "macroFunctions . add ( new   ReturnFixedValueMacroFunction ( macroName ,    paramNames . size (  )  ,    expression . getType (  )  ,    expression . getValue (  )  ,    expression . getArguments (  )  )  )  ;", "} else    {", "int [  ]    argsMapArray    =    new   int [ argsMap . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( argsMap . size (  )  )  ;    i +  +  )     {", "argsMapArray [ i ]     =    argsMap . get ( i )  ;", "}", "expression    =    expression . asMacroExpansion (  )  ;", "macroFunctions . add ( new   ArgsMappingMacroFunction ( macroName ,    paramNames . size (  )  ,    argsMapArray ,    expression . getType (  )  ,    expression . getValue (  )  ,    expression . getArguments (  )  )  )  ;", "}", "return ;", "}", "macroFunctions . add ( new   UnresolveableMacroFunction ( macroName ,    paramNames . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parseMacroFunctionDirectiveBody"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    RegexBackedCSourceParser . parseDirectiveBodyExpression ( buffer )  ;", "expression    =    expression . asMacroExpansion (  )  ;", "if    (  !  ( expression . getArguments (  )  . isEmpty (  )  )  )     {", "macros . add ( new   MacroWithComplexExpression ( macroName ,    expression . getType (  )  ,    expression . getValue (  )  ,    expression . getArguments (  )  )  )  ;", "} else", "if    (  ( expression . getType (  )  )     !  =     ( IncludeType . OTHER )  )     {", "macros . add ( new   MacroWithSimpleExpression ( macroName ,    expression . getType (  )  ,    expression . getValue (  )  )  )  ;", "} else    {", "macros . add ( new   UnresolveableMacro ( macroName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseMacroObjectDirectiveBody"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "Set < Include >    includes    =    Sets . newLinkedHashSet (  )  ;", "List < Macro >    macros    =    Lists . newArrayList (  )  ;", "List < MacroFunction >    macroFunctions    =    Lists . newArrayList (  )  ;", "BufferedReader   reader    =    new   BufferedReader ( sourceReader )  ;", "PreprocessingReader   lineReader    =    new   PreprocessingReader ( reader )  ;", ". Buffer   buffer    =    new    . Buffer (  )  ;", "while    ( true )     {", "buffer . reset (  )  ;", "if    (  !  ( lineReader . readNextLine ( buffer . value )  )  )     {", "break ;", "}", "buffer . consumeWhitespace (  )  ;", "if    (  !  ( buffer . consume (  '  #  '  )  )  )     {", "continue ;", "}", "buffer . consumeWhitespace (  )  ;", "if    ( buffer . consume (  \" define \"  )  )     {", "parseDefineDirectiveBody ( buffer ,    macros ,    macroFunctions )  ;", "} else", "if    ( buffer . consume (  \" include \"  )  )     {", "parseIncludeOrImportDirectiveBody ( buffer ,    false ,    includes )  ;", "} else", "if    ( buffer . consume (  \" import \"  )  )     {", "parseIncludeOrImportDirectiveBody ( buffer ,    true ,    includes )  ;", "}", "}", "return   new   DefaultIncludeDirectives ( ImmutableList . copyOf ( includes )  ,    ImmutableList . copyOf ( macros )  ,    ImmutableList . copyOf ( macroFunctions )  )  ;", "}", "METHOD_END"], "methodName": ["parseSource"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "Expression   expression    =    RegexBackedCSourceParser . parseExpression ( buffer )  ;", "if    ( expression    =  =    null )     {", "return   null ;", "}", "buffer . consumeWhitespace (  )  ;", "if    ( buffer . hasAny (  \"  ,  )  \"  )  )     {", "return   expression ;", "}", "List < Expression >    expressions    =    new   ArrayList < Expression >  (  )  ;", "expressions . add ( expression )  ;", "do    {", "expression    =    RegexBackedCSourceParser . parseExpression ( buffer )  ;", "if    ( expression    =  =    null )     {", "return   null ;", "}", "expressions . add ( expression )  ;", "buffer . consumeWhitespace (  )  ;", "}    while    (  !  ( buffer . hasAny (  \"  ,  )  \"  )  )     )  ;", "return   new   ComplexExpression ( IncludeType . EXPRESSIONS ,    null ,    expressions )  ;", "}", "METHOD_END"], "methodName": ["readArgument"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    buffer . pos ;", "if    (  !  ( buffer . consume (  '  (  '  )  )  )     {", "return   null ;", "}", "List < Expression >    argumentExpressions    =    new   ArrayList < Expression >  (  )  ;", "buffer . consumeWhitespace (  )  ;", ". consumeArgumentList ( buffer ,    argumentExpressions )  ;", "if    (  !  ( buffer . consume (  '  )  '  )  )  )     {", "buffer . pos    =    pos ;", "return   null ;", "}", "return   argumentExpressions ;", "}", "METHOD_END"], "methodName": ["readArgumentList"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   startValue    =    buffer . pos ;", "buffer . consumeUpTo ( endDelim )  ;", "int   endValue    =    buffer . pos ;", "if    (  !  ( buffer . consume ( endDelim )  )  )     {", "return   null ;", "}", "return   new   SimpleExpression ( buffer . value . substring ( startValue ,    endValue )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["readDelimitedExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "if    ( buffer . consume (  '  <  '  )  )     {", "return    . readDelimitedExpression ( buffer ,     '  >  '  ,    SYSTEM )  ;", "} else", "if    ( buffer . consume (  '  \"  '  )  )     {", "return    . readDelimitedExpression ( buffer ,     '  \"  '  ,    IncludeType . QUOTED )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["readPathExpression"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "int   pos    =    buffer . pos ;", "if    (  !  ( buffer . consume (  \"  #  #  \"  )  )  )     {", "return   null ;", "}", "buffer . consumeWhitespace (  )  ;", "String   right    =    buffer . readIdentifier (  )  ;", "if    ( right    =  =    null )     {", "buffer . pos    =    pos ;", "return   null ;", "}", "ComplexExpression   concatExpression    =    new   ComplexExpression ( IncludeType . TOKEN _ CONCATENATION ,    null ,    Arrays .  < Expression > asList ( new   SimpleExpression ( leftToken ,    IncludeType . IDENTIFIER )  ,    new   SimpleExpression ( right ,    IncludeType . IDENTIFIER )  )  )  ;", "buffer . consumeWhitespace (  )  ;", "while    ( buffer . consume (  \"  #  #  \"  )  )     {", "buffer . consumeWhitespace (  )  ;", "right    =    buffer . readIdentifier (  )  ;", "if    ( right    =  =    null )     {", "buffer . pos    =    pos ;", "return   null ;", "}", "concatExpression    =    new   ComplexExpression ( IncludeType . TOKEN _ CONCATENATION ,    null ,    Arrays .  < Expression > asList ( concatExpression ,    new   SimpleExpression ( right ,    IncludeType . IDENTIFIER )  )  )  ;", "buffer . consumeWhitespace (  )  ;", "}", "return   concatExpression ;", "}", "METHOD_END"], "methodName": ["readTokenConcatenation"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.RegexBackedCSourceParser"}, {"methodBody": ["METHOD_START", "{", "return   parameterToReturn ;", "}", "METHOD_END"], "methodName": ["getParameterToReturn"], "fileName": "org.gradle.language.nativeplatform.internal.incremental.sourceparser.ReturnParameterMacroFunction"}, {"methodBody": ["METHOD_START", "{", "BuildOperationLogger   operationLogger    =    getOperationLoggerFactory (  )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "Spec   spec    =    createCompileSpec (  )  ;", "spec . setTargetPlatform ( targetPlatform . get (  )  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setObjectFileDir ( objectFileDir . get (  )  . getAsFile (  )  )  ;", "spec . include ( includes )  ;", "spec . systemInclude ( systemIncludes )  ;", "spec . source ( getSource (  )  )  ;", "spec . setMacros ( getMacros (  )  )  ;", "spec . args ( getCompilerArgs (  )  . get (  )  )  ;", "spec . setPositionIndependentCode ( isPositionIndependentCode (  )  )  ;", "spec . setDebuggable ( isDebuggable (  )  )  ;", "spec . setOptimized ( isOptimized (  )  )  ;", "spec . setIncrementalCompile ( inputs . isIncremental (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "configureSpec ( spec )  ;", "NativeToolChainInternal   nativeToolChain    =     (  ( NativeToolChainInternal )     ( toolChain . get (  )  )  )  ;", "NativePlatformInternal   nativePlatform    =     (  ( NativePlatformInternal )     ( targetPlatform . get (  )  )  )  ;", "PlatformToolProvider   platformToolProvider    =    nativeToolChain . select ( nativePlatform )  ;", "setDidWork ( doCompile ( spec ,    platformToolProvider )  . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "Class < T >    specType    =    Cast . uncheckedCast ( spec . getClass (  )  )  ;", "Compiler < T >    baseCompiler    =    ToolProvider . newCompiler ( specType )  ;", "Compiler < T >    incrementalCompiler    =    this . incrementalCompiler . createCompiler ( baseCompiler )  ;", "Compiler < T >    loggingCompiler    =    BuildOperationLoggingCompilerDecorator . wrap ( incrementalCompiler )  ;", "return   loggingCompiler . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["doCompile"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   compilerArgs ;", "}", "METHOD_END"], "methodName": ["getCompilerArgs"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileCollectionFactory"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   incrementalCompiler . getHeaderFiles (  )  ;", "}", "METHOD_END"], "methodName": ["getHeaderDependencies"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getIncrementalCompilerBuilder"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   macros ;", "}", "METHOD_END"], "methodName": ["getMacros"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   objectFileDir ;", "}", "METHOD_END"], "methodName": ["getObjectFileDir"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationLoggerFactory"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   systemIncludes ;", "}", "METHOD_END"], "methodName": ["getSystemIncludes"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTaskFileVarFactory"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "includes . from ( includeRoots )  ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   debug ;", "}", "METHOD_END"], "methodName": ["isDebuggable"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   optimize ;", "}", "METHOD_END"], "methodName": ["isOptimized"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   positionIndependentCode ;", "}", "METHOD_END"], "methodName": ["isPositionIndependentCode"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "this . debug    =    debug ;", "}", "METHOD_END"], "methodName": ["setDebuggable"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "this . macros . clear (  )  ;", "this . macros . putAll ( macros )  ;", "}", "METHOD_END"], "methodName": ["setMacros"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "this . optimize    =    optimize ;", "}", "METHOD_END"], "methodName": ["setOptimized"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "this . positionIndependentCode    =    positionIndependentCode ;", "}", "METHOD_END"], "methodName": ["setPositionIndependentCode"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "source . from ( sourceFiles )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeCompileTask"}, {"methodBody": ["METHOD_START", "{", "NativeToolChainInternal   toolChain    =     (  ( NativeToolChainInternal )     ( getToolChain (  )  . get (  )  )  )  ;", "NativePlatformInternal   targetPlatform    =     (  ( NativePlatformInternal )     ( getTargetPlatform (  )  . get (  )  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "Compiler <  ?    extends   NativSpec >    compiler    =    toolProvider . newCompiler ( creatSpec (  )  . getClass (  )  )  ;", "if    (  !  ( compiler   instanceof   VersionAwarr )  )     {", "return   null ;", "}", "return    (  ( VersionAwarr )     ( compiler )  )  . getVersion (  )  ;", "}", "METHOD_END"], "methodName": ["getCompilerVersion"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeSourceCompileTask"}, {"methodBody": ["METHOD_START", "{", "return   preCompiledHeader ;", "}", "METHOD_END"], "methodName": ["getPreCompiledHeader"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeSourceCompileTask"}, {"methodBody": ["METHOD_START", "{", "this . preCompiledHeader    =    preCompiledHeader ;", "}", "METHOD_END"], "methodName": ["setPreCompiledHeader"], "fileName": "org.gradle.language.nativeplatform.tasks.AbstractNativeSourceCompileTask"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ComponentWithBinaries . class ,    new   Action < ComponentWithBinaries >  (  )     {", "@ Override", "public   void   execute ( final   ComponentWithBinaries   component )     {", "component . getBinaries (  )  . whenElementKnown ( new   Action < SoftwareComponent >  (  )     {", "@ Override", "public   void   execute ( SoftwareComponent   binary )     {", "components . add ( binary )  ;", "}", "}  )  ;", "if    ( component   instanceof   ProductionComponent )     {", "component . getBinaries (  )  . whenElementFinalized ( ComponentWithOutputs . class ,    new   Action < ComponentWithOutputs >  (  )     {", "@ Override", "public   void   execute ( ComponentWithOutputs   binary )     {", "FileCollection   outputs    =    binary . getOutputs (  )  ;", "Names   names    =     (  ( ComponentWithNames )     ( binary )  )  . getNames (  )  ;", "Task   lifecycleTask    =    tasks . create ( names . getTaskName (  \" assemble \"  )  )  ;", "lifecycleTask . dependsOn ( outputs )  ;", "if    ( binary    =  =     (  (  ( ProductionComponent )     ( component )  )  . getDevelopmentBinary (  )  . get (  )  )  )     {", "tasks . getByName ( ASSEMBLE _ TASK _ NAME )  . dependsOn ( outputs )  ;", "}", "}", "}  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addLifecycleTasks"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ConfigurableComponentWithLinkUsage . class ,    new   Action < ConfigurableComponentWithLinkUsage >  (  )     {", "@ Override", "public   void   execute ( ConfigurableComponentWithLinkUsage   component )     {", "Names   names    =    component . getNames (  )  ;", "Configuration   linkElements    =    configurations . create ( names . withSuffix (  \" linkElements \"  )  )  ;", "linkElements . extendsFrom ( component . getImplementationDependencies (  )  )  ;", "linkElements . setCanBeResolved ( false )  ;", "AttributeContainer   attributes    =    component . getLinkAttributes (  )  ;", "copyAttributesTo ( attributes ,    linkElements )  ;", "linkElements . getOutgoing (  )  . artifact ( component . getLinkFile (  )  )  ;", "component . getLinkElements (  )  . set ( linkElements )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addOutgoingConfigurationForLinkUsage"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ConfigurableComponentWithRuntimeUsage . class ,    new   Action < ConfigurableComponentWithRuntimeUsage >  (  )     {", "@ Override", "public   void   execute ( ConfigurableComponentWithRuntimeUsage   component )     {", "Names   names    =    component . getNames (  )  ;", "Configuration   runtimeElements    =    configurations . create ( names . withSuffix (  \" runtimeElements \"  )  )  ;", "runtimeElements . extendsFrom ( component . getImplementationDependencies (  )  )  ;", "runtimeElements . setCanBeResolved ( false )  ;", "AttributeContainer   attributes    =    component . getRuntimeAttributes (  )  ;", "copyAttributesTo ( attributes ,    runtimeElements )  ;", "if    ( component . hasRuntimeFile (  )  )     {", "runtimeElements . getOutgoing (  )  . artifact ( component . getRuntimeFile (  )  )  ;", "}", "component . getRuntimeElements (  )  . set ( runtimeElements )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addOutgoingConfigurationForRuntimeUsage"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . withPlugin (  \" maven - publish \"  ,    new   Action < AppliedPlugin >  (  )     {", "@ Override", "public   void   execute ( AppliedPlugin   appliedPlugin )     {", "components . withType ( PublicationAwareComponent . class ,    new   Action < PublicationAwareComponent >  (  )     {", "@ Override", "public   void   execute ( final   PublicationAwareComponent   component )     {", "project . getExtensions (  )  . configure ( PublishingExtension . class ,    new   Action < PublishingExtension >  (  )     {", "@ Override", "public   void   execute ( PublishingExtension   publishing )     {", "final   ComponentWithVariants   mainVariant    =    component . getMainPublication (  )  ;", "publishing . getPublications (  )  . create (  \" main \"  ,    MavenPublication . class ,    new   Action < MavenPublication >  (  )     {", "@ Override", "public   void   execute ( MavenPublication   publication )     {", "publication . setGroupId ( project . getGroup (  )  . toString (  )  )  ;", "publication . setArtifactId ( component . getBaseName (  )  . get (  )  )  ;", "publication . setVersion ( project . getVersion (  )  . toString (  )  )  ;", "publication . from ( mainVariant )  ;", "(  ( MavenPublicationInternal )     ( publication )  )  . publishWithOriginalFileName (  )  ;", "}", "}  )  ;", "for    ( final   SoftwareComponent   child    :    mainVariant . getVariants (  )  )     {", "if    ( child   instanceof   PublishableComponent )     {", "final   ModuleVersionIdentifier   coordinates    =     (  ( PublishableComponent )     ( child )  )  . getCoordinates (  )  ;", "publishing . getPublications (  )  . create ( child . getName (  )  ,    MavenPublication . class ,    new   Action < MavenPublication >  (  )     {", "@ Override", "public   void   execute ( MavenPublication   publication )     {", "publication . setGroupId ( coordinates . getGroup (  )  )  ;", "publication . setArtifactId ( coordinates . getName (  )  )  ;", "publication . setVersion ( coordinates . getVersion (  )  )  ;", "publication . from ( child )  ;", "(  ( MavenPublicationInternal )     ( publication )  )  . publishWithOriginalFileName (  )  ;", "}", "}  )  ;", "}", "}", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addPublicationsFromVariants"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ConfigurableComponentWithExecutable . class ,    new   Action < ConfigurableComponentWithExecutable >  (  )     {", "@ Override", "public   void   execute ( final   ConfigurableComponentWithExecutable   executable )     {", "final   Names   names    =    executable . getNames (  )  ;", "NativeToolChain   toolChain    =    executable . getToolChain (  )  ;", "NativePlatform   targetPlatform    =    executable . getTargetPlatform (  )  ;", "LinkExecutable   link    =    tasks . create ( names . getTaskName (  \" link \"  )  ,    LinkExecutable . class )  ;", "link . source ( executable . getObjects (  )  )  ;", "link . lib ( executable . getLinkLibraries (  )  )  ;", "final   PlatformToolProvider   toolProvider    =    executable . getPlatformToolProvider (  )  ;", "link . getLinkedFile (  )  . set ( buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getExecutableName (  (  (  \" exe /  \"     +     ( names . getDirName (  )  )  )     +     ( executable . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  )  ;", "link . getTargetPlatform (  )  . set ( targetPlatform )  ;", "link . getToolChain (  )  . set ( toolChain )  ;", "link . getDebuggable (  )  . set ( executable . isDebuggable (  )  )  ;", "executable . getLinkTask (  )  . set ( link )  ;", "executable . getDebuggerExecutableFile (  )  . set ( link . getLinkedFile (  )  )  ;", "if    (  (  ( executable . isDebuggable (  )  )     &  &     ( executable . isOptimized (  )  )  )     &  &     ( toolProvider . requiresDebugBinaryStripping (  )  )  )     {", "Provider < RegularFile >    symbolLocation    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getExecutableSymbolFileName (  (  (  (  \" exe /  \"     +     ( names . getDirName (  )  )  )     +     \" stripped /  \"  )     +     ( executable . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "Provider < RegularFile >    strippedLocation    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getExecutableName (  (  (  (  \" exe /  \"     +     ( names . getDirName (  )  )  )     +     \" stripped /  \"  )     +     ( executable . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "StripSymbols   stripSymbols    =    stripSymbols ( link ,    names ,    tasks ,    toolChain ,    targetPlatform ,    strippedLocation )  ;", "executable . getExecutableFile (  )  . set ( stripSymbols . getOutputFile (  )  )  ;", "ExtractSymbols   extractSymbols    =    extractSymbols ( link ,    names ,    tasks ,    toolChain ,    targetPlatform ,    symbolLocation )  ;", "executable . getOutputs (  )  . from ( extractSymbols . getSymbolFile (  )  )  ;", "} else    {", "executable . getExecutableFile (  )  . set ( link . getLinkedFile (  )  )  ;", "}", "final   InstallExecutable   install    =    tasks . create ( names . getTaskName (  \" install \"  )  ,    InstallExecutable . class )  ;", "install . getTargetPlatform (  )  . set ( targetPlatform )  ;", "install . getToolChain (  )  . set ( toolChain )  ;", "install . getInstallDirectory (  )  . set ( buildDirectory . dir (  (  \" install /  \"     +     ( names . getDirName (  )  )  )  )  )  ;", "install . getExecutableFile (  )  . set ( executable . getExecutableFile (  )  )  ;", "install . lib ( executable . getRuntimeLibraries (  )  )  ;", "executable . getInstallTask (  )  . set ( install )  ;", "executable . getInstallDirectory (  )  . set ( install . getInstallDirectory (  )  )  ;", "executable . getOutputs (  )  . from ( executable . getInstallDirectory (  )  )  ;", "executable . getDebuggerExecutableFile (  )  . set ( install . getInstalledExecutable (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTasksForComponentWithExecutable"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ConfigurableComponentWithSharedLibrary . class ,    new   Action < ConfigurableComponentWithSharedLibrary >  (  )     {", "@ Override", "public   void   execute ( final   ConfigurableComponentWithSharedLibrary   library )     {", "final   Names   names    =    library . getNames (  )  ;", "NativePlatform   targetPlatform    =    library . getTargetPlatform (  )  ;", "NativeToolChain   toolChain    =    library . getToolChain (  )  ;", "final   LinkSharedLibrary   link    =    tasks . create ( names . getTaskName (  \" link \"  )  ,    LinkSharedLibrary . class )  ;", "link . source ( library . getObjects (  )  )  ;", "link . lib ( library . getLinkLibraries (  )  )  ;", "final   PlatformToolProvider   toolProvider    =    library . getPlatformToolProvider (  )  ;", "Provider < RegularFile >    runtimeFile    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getSharedLibraryName (  (  (  \" lib /  \"     +     ( names . getDirName (  )  )  )     +     ( library . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "link . getLinkedFile (  )  . set ( runtimeFile )  ;", "link . getTargetPlatform (  )  . set ( targetPlatform )  ;", "link . getToolChain (  )  . set ( toolChain )  ;", "link . getDebuggable (  )  . set ( library . isDebuggable (  )  )  ;", "Provider < RegularFile >    linkFile    =    link . getLinkedFile (  )  ;", "runtimeFile    =    link . getLinkedFile (  )  ;", "if    ( toolProvider . producesImportLibrary (  )  )     {", "Provider < RegularFile >    importLibrary    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getImportLibraryName (  (  (  \" lib /  \"     +     ( names . getDirName (  )  )  )     +     ( library . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "link . getImportLibrary (  )  . set ( importLibrary )  ;", "linkFile    =    link . getImportLibrary (  )  ;", "}", "if    (  (  ( library . isDebuggable (  )  )     &  &     ( library . isOptimized (  )  )  )     &  &     ( toolProvider . requiresDebugBinaryStripping (  )  )  )     {", "Provider < RegularFile >    symbolLocation    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getLibrarySymbolFileName (  (  (  (  \" lib /  \"     +     ( names . getDirName (  )  )  )     +     \" stripped /  \"  )     +     ( library . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "Provider < RegularFile >    strippedLocation    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getSharedLibraryName (  (  (  (  \" lib /  \"     +     ( names . getDirName (  )  )  )     +     \" stripped /  \"  )     +     ( library . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "StripSymbols   stripSymbols    =    stripSymbols ( link ,    names ,    tasks ,    toolChain ,    targetPlatform ,    strippedLocation )  ;", "runtimeFile    =    stripSymbols . getOutputFile (  )  ;", "linkFile    =    stripSymbols . getOutputFile (  )  ;", "ExtractSymbols   extractSymbols    =    extractSymbols ( link ,    names ,    tasks ,    toolChain ,    targetPlatform ,    symbolLocation )  ;", "library . getOutputs (  )  . from ( extractSymbols . getSymbolFile (  )  )  ;", "}", "library . getLinkTask (  )  . set ( link )  ;", "library . getLinkFile (  )  . set ( linkFile )  ;", "library . getRuntimeFile (  )  . set ( runtimeFile )  ;", "library . getOutputs (  )  . from ( library . getLinkFile (  )  )  ;", "library . getOutputs (  )  . from ( library . getRuntimeFile (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTasksForComponentWithSharedLibrary"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "components . withType ( ConfigurableComponentWithStaticLibrary . class ,    new   Action < ConfigurableComponentWithStaticLibrary >  (  )     {", "@ Override", "public   void   execute ( final   ConfigurableComponentWithStaticLibrary   library )     {", "final   Names   names    =    library . getNames (  )  ;", "final   CreateStaticLibrary   createTask    =    tasks . create ( names . getTaskName (  \" create \"  )  ,    CreateStaticLibrary . class )  ;", "createTask . source ( library . getObjects (  )  )  ;", "final   PlatformToolProvider   toolProvider    =    library . getPlatformToolProvider (  )  ;", "Provider < RegularFile >    linktimeFile    =    buildDirectory . file ( providers . provider ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   toolProvider . getStaticLibraryName (  (  (  \" lib /  \"     +     ( names . getDirName (  )  )  )     +     ( library . getBaseName (  )  . get (  )  )  )  )  ;", "}", "}  )  )  ;", "createTask . getOutputFile (  )  . set ( linktimeFile )  ;", "createTask . getTargetPlatform (  )  . set ( library . getTargetPlatform (  )  )  ;", "createTask . getToolChain (  )  . set ( library . getToolChain (  )  )  ;", "library . getLinkFile (  )  . set ( createTask . getBinaryFile (  )  )  ;", "library . getCreateTask (  )  . set ( createTask )  ;", "library . getOutputs (  )  . from ( library . getLinkFile (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addTasksForComponentWithStaticLibrary"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute <  ?  >    attribute    :    attributes . keySet (  )  )     {", "Object   value    =    attributes . getAttribute ( attribute )  ;", "linkElements . getAttributes (  )  . attribute ( internal . Cast .  < Attribute < Object >  > uncheckedCast ( attribute )  ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["copyAttributesTo"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "ExtractSymbols   extractSymbols    =    tasks . create ( names . getTaskName (  \" extractSymbols \"  )  ,    ExtractSymbols . class )  ;", "extractSymbols . getBinaryFile (  )  . set ( link . getLinkedFile (  )  )  ;", "extractSymbols . getSymbolFile (  )  . set ( symbolLocon )  ;", "extractSymbols . getTargetPlatform (  )  . set ( currentPlatform )  ;", "extractSymbols . getToolChain (  )  . set ( toolChain )  ;", "return   extractSymbols ;", "}", "METHOD_END"], "methodName": ["extractSymbols"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "StripSymbols   stripSymbols    =    tasks . create ( names . getTaskName (  \" stripSymbols \"  )  ,    StripSymbols . class )  ;", "stripSymbols . getBinaryFile (  )  . set ( link . getLinkedFile (  )  )  ;", "stripSymbols . getOutputFile (  )  . set ( strippedLocon )  ;", "stripSymbols . getTargetPlatform (  )  . set ( currentPlatform )  ;", "stripSymbols . getToolChain (  )  . set ( toolChain )  ;", "return   stripSymbols ;", "}", "METHOD_END"], "methodName": ["stripSymbols"], "fileName": "org.gradle.language.plugins.NativeBasePlugin"}, {"methodBody": ["METHOD_START", "{", "task . setDescription (  (  (  (  \" Compiles   resources   of   the    \"     +    sourceSet )     +     \"    of    \"  )     +    binary )  )  ;", "task . getToolChain (  )  . set ( binary . getToolChain (  )  )  ;", "task . getTargetPlatform (  )  . set ( binary . getTargetPlatform (  )  )  ;", "task . includes ( sourceSet . getExportedHeaders (  )  . getSourceDirectories (  )  )  ;", "FileCollectionFactory   fileCollectionFactory    =     (  ( ProjectInternal )     ( task . getProject (  )  )  )  . getServices (  )  . get ( FileCollectionFactory . class )  ;", "task . includes ( fileCollectionFactory . create ( new   MinimalFileSet (  )     {", "@ Override", "public   Set < File >    getFiles (  )     {", "PlatformToolProvider   platformToolProvider    =     (  ( NativeToolChainInternal )     ( binary . getToolChain (  )  )  )  . select (  (  ( NativePlatformInternal )     ( binary . getTargetPlatform (  )  )  )  )  ;", "return   new   LinkedHashSet < File >  ( platformToolProvider . getSystemLibraries ( WINDOW _ RESOURCES _ COMPILER )  . getIncludeDirs (  )  )  ;", "}", "@ Override", "public   String   getDisplayName (  )     {", "return    \" System   includes   for    \"     +     ( binary . getToolChain (  )  . getDisplayName (  )  )  ;", "}", "}  )  )  ;", "task . source ( sourceSet . getSource (  )  )  ;", "final   Project   project    =    task . getProject (  )  ;", "task . setOutputDir ( new   File ( binary . getNamingScheme (  )  . getOutputDirectory ( project . getBuildDir (  )  ,     \" objs \"  )  ,     (  ( LanguageSourceSetInternal )     ( sourceSet )  )  . getProjectScopedName (  )  )  )  ;", "PreprocessingTool   rcCompiler    =     (  ( PreprocessingTool )     ( binary . getToolByName (  \" rcCompiler \"  )  )  )  ;", "task . setMacros ( rcCompiler . getMacros (  )  )  ;", "task . setCompilerArgs ( rcCompiler . getArgs (  )  )  ;", "FileTree   resourceOutputs    =    task . getOutputs (  )  . getFiles (  )  . getAsFileTree (  )  . matching ( new   PatternSet (  )  . include (  \"  *  *  /  *  . res \"  )  )  ;", "binary . binaryInputs ( resourceOutputs )  ;", "if    ( binary   instanceof   StaticLibraryBinarySpecInternal )     {", "(  ( StaticLibraryBinarySpecInternal )     ( binary )  )  . additionalLinkFiles ( resourceOutputs )  ;", "}", "}", "METHOD_END"], "methodName": ["configureResourceCompileTask"], "fileName": "org.gradle.language.rc.plugins.internal.WindowsResourcesCompileTaskConfig"}, {"methodBody": ["METHOD_START", "{", "BuildOperationLogger   operationLogger    =    getOperationLoggerFactory (  )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "NativeCompileSpec   spec    =    new   DefaultSpec (  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setObjectFileDir ( getOutputDir (  )  )  ;", "spec . include ( getIncludes (  )  )  ;", "spec . source ( getSource (  )  )  ;", "spec . setMacros ( getMacros (  )  )  ;", "spec . args ( getCompilerArgs (  )  )  ;", "spec . setIncrementalCompile ( inputs . isIncremental (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "NativeToolChainInternal   nativeToolChain    =     (  ( NativeToolChainInternal )     ( toolChain . get (  )  )  )  ;", "NativePlatformInternal   nativePlatform    =     (  ( NativePlatformInternal )     ( targetPlatform . get (  )  )  )  ;", "PlatformToolProvider   platformToolProvider    =    nativeToolChain . select ( nativePlatform )  ;", "WorkResult   result    =    doCompile ( spec ,    platformToolProvider )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "Class < T >    specType    =    Cast . uncheckedCast ( spec . getClass (  )  )  ;", "Compiler < T >    basr    =    platformToolProvider . newCompiler ( specType )  ;", "Compiler < T >    incrementalCompiler    =    this . incrementalCompiler . creatr ( basr )  ;", "Compiler < T >    loggingCompiler    =    BuildOperationLoggingCompilerDecorator . wrap ( incrementalCompiler )  ;", "return   CompilerUtil . castCompiler ( loggingCompiler )  . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["doCompile"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   compilerArgs ;", "}", "METHOD_END"], "methodName": ["getCompilerArgs"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   incrementalCompiler . getHeaderFiles (  )  ;", "}", "METHOD_END"], "methodName": ["getHeaderDependencies"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getIncrementalCompilerBuilder"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   macros ;", "}", "METHOD_END"], "methodName": ["getMacros"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationLoggerFactory"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   outputDir ;", "}", "METHOD_END"], "methodName": ["getOutputDir"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "includes . from ( includeRoots )  ;", "}", "METHOD_END"], "methodName": ["includes"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "this . compilerArgs    =    compilerArgs ;", "}", "METHOD_END"], "methodName": ["setCompilerArgs"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "this . macros    =    macros ;", "}", "METHOD_END"], "methodName": ["setMacros"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "this . outputDir    =    outputDir ;", "}", "METHOD_END"], "methodName": ["setOutputDir"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "source . from ( sourceFiles )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.language.rc.tasks.WindowsResourceCompile"}, {"methodBody": ["METHOD_START", "{", "SwiftExecutable   result    =    objectFactory . newInstance ( DefaultSwiftExecutable . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( identity . getName (  )  )  )  )  ,    getModule (  )  ,    testable ,    getSwiftSource (  )  ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addExecutable"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftApplication"}, {"methodBody": ["METHOD_START", "{", "action . execute ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["dependencies"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftApplication"}, {"methodBody": ["METHOD_START", "{", "return   identity ;", "}", "METHOD_END"], "methodName": ["getIdentity"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftBinary"}, {"methodBody": ["METHOD_START", "{", "return   importPathConfiguration ;", "}", "METHOD_END"], "methodName": ["getImportPathConfiguration"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftBinary"}, {"methodBody": ["METHOD_START", "{", "return   moduleFile ;", "}", "METHOD_END"], "methodName": ["getModuleFile"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftBinary"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getNativeDependencyCache"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftBinary"}, {"methodBody": ["METHOD_START", "{", "return   platformToolProvider ;", "}", "METHOD_END"], "methodName": ["getPlatformToolProvider"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftBinary"}, {"methodBody": ["METHOD_START", "{", "SwiftSharedLibrary   result    =    objectFactory . newInstance ( DefaultSwiftSharedLibrary . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( nameSuffix )  )  )  ,    getModule (  )  ,    testable ,    getSwiftSource (  )  ,    configurations ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addSharedLibrary"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftLibrary"}, {"methodBody": ["METHOD_START", "{", "SwiftStaticLibrary   result    =    objectFactory . newInstance ( DefaultSwiftStaticLibrary . class ,     (  ( getName (  )  )     +     ( StringUtils . capitalize ( nameSuffix )  )  )  ,    getModule (  )  ,    testable ,    getSwiftSource (  )  ,    getImplementationDependencies (  )  ,    targetPlatform ,    toolChain ,    platformToolProvider ,    identity )  ;", "getBinaries (  )  . add ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["addStaticLibrary"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftLibrary"}, {"methodBody": ["METHOD_START", "{", "action . execute ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["dependencies"], "fileName": "org.gradle.language.swift.internal.DefaultSwiftLibrary"}, {"methodBody": ["METHOD_START", "{", "if    ( isDimensionVisible ( multivalueProperty )  )     {", "return   StringUtils . capitalize ( dimensionValue . getName (  )  . toLowerCase (  )  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["createDimensionSuffix"], "fileName": "org.gradle.language.swift.plugins.SwiftApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( multivalueProperty . size (  )  )     >     1  ;", "}", "METHOD_END"], "methodName": ["isDimensionVisible"], "fileName": "org.gradle.language.swift.plugins.SwiftApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( swiftCompilerVersion . getMajor (  )  )     =  =     3  )     {", "return   SwiftVersion . SWIFT 3  ;", "} else", "if    (  ( swiftCompilerVersion . getMajor (  )  )     =  =     4  )     {", "return   SwiftVersion . SWIFT 4  ;", "} else    {", "throw   new   IllegalArgumentException ( String . format (  \" Swift      version   is   unknown   for   the   specified   Swift   compiler   version    (  % s )  \"  ,    swiftCompilerVersion . toString (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toSwiftVersion"], "fileName": "org.gradle.language.swift.plugins.SwiftBasePlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( isDimensionVisible ( multivalueProperty )  )     {", "return   StringUtils . capitalize ( dimensionValue . getName (  )  . toLowerCase (  )  )  ;", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["createDimensionSuffix"], "fileName": "org.gradle.language.swift.plugins.SwiftLibraryPlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( multivalueProperty . size (  )  )     >     1  ;", "}", "METHOD_END"], "methodName": ["isDimensionVisible"], "fileName": "org.gradle.language.swift.plugins.SwiftLibraryPlugin"}, {"methodBody": ["METHOD_START", "{", "final   List < File >    removedFiles    =    Lists . newArrayList (  )  ;", "final   Set < File >    changedFiles    =    Sets . newHashSet (  )  ;", "boolean   isIncremental    =    inputs . isIncremental (  )  ;", "if    ( isIncremental )     {", "inputs . outOfDate ( new   Action < InputFileDetails >  (  )     {", "@ Override", "public   void   execute ( InputFileDetails   inputFileDetails )     {", "if    ( inputFileDetails . isModified (  )  )     {", "changedFiles . add ( inputFileDetails . getFile (  )  )  ;", "}", "}", "}  )  ;", "inputs . removed ( new   Action < InputFileDetails >  (  )     {", "@ Override", "public   void   execute ( InputFileDetails   removed )     {", "removedFiles . add ( removed . getFile (  )  )  ;", "}", "}  )  ;", "Set < File >    allSourceFiles    =    getSource (  )  . getFiles (  )  ;", "if    (  !  ( allSourceFiles . containsAll ( changedFiles )  )  )     {", "isIncremental    =    false ;", "}", "}", "BuildOperationLogger   operationLogger    =    getServices (  )  . get ( BuildOperationLoggerFactory . class )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "Spec   spec    =    createSpec ( operationLogger ,    isIncremental ,    changedFiles ,    removedFiles ,    targetPlatform )  ;", "Compiler < Spec >    baseCompiler    =    new   Incrementalr ( createCompiler (  )  ,    getOutputs (  )  ,    compilerOutputFileNamingSchemeFactory )  ;", "Compiler < Spec >    loggingCompiler    =    BuildOperationLoggingCompilerDecorator . wrap ( baseCompiler )  ;", "WorkResult   result    =    loggingCompiler . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "NativeToolChainInternal   toolChain    =    Cast . cast ( NativeToolChainInternal . class ,    getToolChain (  )  . get (  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "return   toolProvider . newCompiler ( Spec . class )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "SwiftCompileSpec   spec    =    new   DefaultSwiftCompileSpec (  )  ;", "spec . setModuleName ( moduleName . getOrNull (  )  )  ;", "spec . setModuleFile ( moduleFile . get (  )  . getAsFile (  )  )  ;", "for    ( File   file    :    modules . getFiles (  )  )     {", "if    ( file . isFile (  )  )     {", "spec . include ( file . getParentFile (  )  )  ;", "} else    {", "spec . include ( file )  ;", "}", "}", "spec . setTargetPlatform ( targetPlatform )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setObjectFileDir ( objectFileDir . get (  )  . getAsFile (  )  )  ;", "spec . source ( getSource (  )  )  ;", "spec . setRemovedSourceFiles ( removedFiles )  ;", "spec . setChangedFiles ( changedFiles )  ;", "Map < String ,    String >    macros    =    new   LinkedHashMap < String ,    String >  (  )  ;", "for    ( String   macro    :    getMacros (  )  . get (  )  )     {", "macros . put ( macro ,    null )  ;", "}", "spec . setMacros ( macros )  ;", "spec . args ( getCompilerArgs (  )  . get (  )  )  ;", "spec . setDebuggable ( getDebuggable (  )  . get (  )  )  ;", "spec . setOptimized ( getOptimized (  )  . get (  )  )  ;", "spec . setIncrementalCompile ( isIncremental )  ;", "spec . setOperationLogger ( operationLogger )  ;", "spec . setSourceCompatibility ( sourceCompatibility . get (  )  )  ;", "return   spec ;", "}", "METHOD_END"], "methodName": ["createSpec"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   compilerArgs ;", "}", "METHOD_END"], "methodName": ["getCompilerArgs"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return    (  ( VersionAwareCompiler )     ( createCompiler (  )  )  )  . getVersion (  )  ;", "}", "METHOD_END"], "methodName": ["getCompilerVersion"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   debuggable ;", "}", "METHOD_END"], "methodName": ["getDebuggable"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   macros ;", "}", "METHOD_END"], "methodName": ["getMacros"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   moduleFile ;", "}", "METHOD_END"], "methodName": ["getModuleFile"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   modules ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   objectFileDir ;", "}", "METHOD_END"], "methodName": ["getObjectFileDir"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   optimize ;", "}", "METHOD_END"], "methodName": ["getOptimized"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   sourceCompatibility ;", "}", "METHOD_END"], "methodName": ["getSourceCompatibility"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   debuggable . get (  )  ;", "}", "METHOD_END"], "methodName": ["isDebuggable"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "return   optimize . get (  )  ;", "}", "METHOD_END"], "methodName": ["isOptimized"], "fileName": "org.gradle.language.swift.tasks.SwiftCompile"}, {"methodBody": ["METHOD_START", "{", "Set < File >    objectFiles    =    getSource (  )  . getFiles (  )  ;", "if    ( objectFiles . isEmpty (  )  )     {", "return   null ;", "} else", "if    (  ( objectFiles . size (  )  )     =  =     1  )     {", "return   objectFiles . iterator (  )  . next (  )  ;", "} else    {", "return   util . CollectionUtils . findFirst ( objectFiles ,    new   api . specs . Spec < File >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( File   objectFile )     {", "return   objectFile . getName (  )  . equalsIgnoreCase (  \" main . o \"  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["findMainObject"], "fileName": "org.gradle.language.swift.tasks.UnexportMainSymbol"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mainObjectFile )     =  =    null )     {", "mainObjectFile    =    findObject (  )  ;", "}", "return   mainObjectFile ;", "}", "METHOD_END"], "methodName": ["getMainObject"], "fileName": "org.gradle.language.swift.tasks.UnexportMainSymbol"}, {"methodBody": ["METHOD_START", "{", "return   outputDirectory . getAsFileTree (  )  ;", "}", "METHOD_END"], "methodName": ["getObjects"], "fileName": "org.gradle.language.swift.tasks.UnexportMainSymbol"}, {"methodBody": ["METHOD_START", "{", "return   outputDirectory ;", "}", "METHOD_END"], "methodName": ["getOutputDirectory"], "fileName": "org.gradle.language.swift.tasks.UnexportMainSymbol"}, {"methodBody": ["METHOD_START", "{", "final   File   mainObjectFile    =    getMainObject (  )  ;", "if    ( mainObjectFile    !  =    null )     {", "final   File   relocatedMainObject    =    outputDirectory . file ( mainObjectFile . getName (  )  )  . get (  )  . getAsFile (  )  ;", "getProject (  )  . exec ( new   api . Action < ExecSpec >  (  )     {", "@ Override", "public   void   execute ( ExecSpec   execSpec )     {", "if    ( OperatingSystem . current (  )  . isMacOsX (  )  )     {", "execSpec . executable (  \" ld \"  )  ;", "execSpec . args ( mainObjectFile )  ;", "execSpec . args (  \"  - o \"  ,    relocatedMainObject )  ;", "execSpec . args (  \"  - r \"  )  ;", "execSpec . args (  \"  - unexported _ symbol \"  ,     \"  _ main \"  )  ;", "} else", "if    ( OperatingSystem . current (  )  . isLinux (  )  )     {", "execSpec . executable (  \" objcopy \"  )  ;", "execSpec . args (  \"  - L \"  ,     \" main \"  )  ;", "execSpec . args ( mainObjectFile )  ;", "execSpec . args ( relocatedMainObject )  ;", "} else    {", "throw   new   IllegalStateException (  (  \" Do   not   know   how   to   hide   a   main   symbol   on    \"     +     ( OperatingSystem . current (  )  )  )  )  ;", "}", "}", "}  )  ;", "setDidWork ( true )  ;", "} else    {", "setDidWork ( getProject (  )  . delete ( outputDirectory )  )  ;", "}", "}", "METHOD_END"], "methodName": ["unexport"], "fileName": "org.gradle.language.swift.tasks.UnexportMainSymbol"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.gradle.swiftpm.internal.AbstractProduct"}, {"methodBody": ["METHOD_START", "{", "return   branch ;", "}", "METHOD_END"], "methodName": ["getBranch"], "fileName": "org.gradle.swiftpm.internal.BranchDependency"}, {"methodBody": ["METHOD_START", "{", "return   linkage ;", "}", "METHOD_END"], "methodName": ["getLinkage"], "fileName": "org.gradle.swiftpm.internal.DefaultLibraryProduct"}, {"methodBody": ["METHOD_START", "{", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.swiftpm.internal.DefaultPackage"}, {"methodBody": ["METHOD_START", "{", "return   swiftLanguageVersion ;", "}", "METHOD_END"], "methodName": ["getSwiftLanguageVersion"], "fileName": "org.gradle.swiftpm.internal.DefaultPackage"}, {"methodBody": ["METHOD_START", "{", "return   targets ;", "}", "METHOD_END"], "methodName": ["getTargets"], "fileName": "org.gradle.swiftpm.internal.DefaultPackage"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   publicHeaderDir ;", "}", "METHOD_END"], "methodName": ["getPublicHeaderDir"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   requiredProducts ;", "}", "METHOD_END"], "methodName": ["getRequiredProducts"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   requiredTargets ;", "}", "METHOD_END"], "methodName": ["getRequiredTargets"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   sourceFiles ;", "}", "METHOD_END"], "methodName": ["getSourceFiles"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "this . publicHeaderDir    =    publicHeaderDir ;", "}", "METHOD_END"], "methodName": ["setPublicHeaderDir"], "fileName": "org.gradle.swiftpm.internal.DefaultTarget"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.gradle.swiftpm.internal.Dependency"}, {"methodBody": ["METHOD_START", "{", "return   targetName ;", "}", "METHOD_END"], "methodName": ["getTargetName"], "fileName": "org.gradle.swiftpm.internal.SwiftPmTarget"}, {"methodBody": ["METHOD_START", "{", "return   lowerBound ;", "}", "METHOD_END"], "methodName": ["getLowerBound"], "fileName": "org.gradle.swiftpm.internal.VersionDependency"}, {"methodBody": ["METHOD_START", "{", "return   upperBound ;", "}", "METHOD_END"], "methodName": ["getUpperBound"], "fileName": "org.gradle.swiftpm.internal.VersionDependency"}, {"methodBody": ["METHOD_START", "{", "return   upperInclusive ;", "}", "METHOD_END"], "methodName": ["isUpperInclusive"], "fileName": "org.gradle.swiftpm.internal.VersionDependency"}, {"methodBody": ["METHOD_START", "{", "DefaultPackage   srcPackage    =     (  ( DefaultPackage )     ( packageProperty . get (  )  )  )  ;", "Path   manifest    =    manifestFile . get (  )  . getAsFile (  )  . toPath (  )  ;", "try    {", "Path   baseDir    =    manifest . getParent (  )  ;", "Files . createDirectories ( baseDir )  ;", "PrintWriter   writer    =    new   PrintWriter ( Files . newBufferedWriter ( manifest ,    Charset . forName (  \" utf -  8  \"  )  )  )  ;", "try    {", "writer . println (  \"  /  /    swift - tools - version :  4  .  0  \"  )  ;", "writer . println (  \"  /  /  \"  )  ;", "writer . println (  \"  /  /    GENERATED   FILE    -    do   not   edit \"  )  ;", "writer . println (  \"  /  /  \"  )  ;", "writer . println (  \" import   PackageDescription \"  )  ;", "writer . println (  )  ;", "writer . println (  \" let   package    =    Package (  \"  )  ;", "writer . println (  (  (  \"             name :     \\  \"  \"     +     ( getProject (  )  . getName (  )  )  )     +     \"  \\  \"  ,  \"  )  )  ;", "writer . println (  \"             products :     [  \"  )  ;", "for    ( AbstractProduct   product    :    srcPackage . getProducts (  )  )     {", "if    ( product . isExecutable (  )  )     {", "writer . print (  \"                          . executable (  \"  )  ;", "writer . print (  \" name :     \\  \"  \"  )  ;", "writer . print ( product . getName (  )  )  ;", "writer . print (  \"  \\  \"  \"  )  ;", "} else    {", "writer . print (  \"                          . library (  \"  )  ;", "writer . print (  \" name :     \\  \"  \"  )  ;", "writer . print ( product . getName (  )  )  ;", "DefaultLibraryProduct   library    =     (  ( DefaultLibraryProduct )     ( product )  )  ;", "if    (  ( library . getLinkage (  )  )     =  =     ( Linkage . SHARED )  )     {", "writer . print (  \"  \\  \"  ,    type :     . dynamic \"  )  ;", "} else    {", "writer . print (  \"  \\  \"  ,    type :     . static \"  )  ;", "}", "}", "writer . print (  \"  ,    targets :     [  \\  \"  \"  )  ;", "writer . print ( product . getTarget (  )  . getName (  )  )  ;", "writer . println (  \"  \\  \"  ]  )  ,  \"  )  ;", "}", "writer . println (  \"              ]  ,  \"  )  ;", "if    (  !  ( srcPackage . getDependencies (  )  . isEmpty (  )  )  )     {", "writer . println (  \"             dependencies :     [  \"  )  ;", "for    ( Dependency   dependency    :    srcPackage . getDependencies (  )  )     {", "writer . print (  \"                          . package ( url :     \\  \"  \"  )  ;", "if    ( dependency . getUrl (  )  . getScheme (  )  . equals (  \" file \"  )  )     {", "writer . print ( baseDir . relativize ( new   File ( dependency . getUrl (  )  )  . toPath (  )  )  )  ;", "} else    {", "writer . print ( dependency . getUrl (  )  )  ;", "}", "writer . print (  \"  \\  \"  ,     \"  )  ;", "if    ( dependency   instanceof   VersionDependency )     {", "VersionDependency   versionDependency    =     (  ( VersionDependency )     ( dependency )  )  ;", "if    (  ( versionDependency . getUpperBound (  )  )     =  =    null )     {", "writer . print (  \" from :     \\  \"  \"  )  ;", "writer . print ( versionDependency . getLowerBound (  )  )  ;", "writer . print (  \"  \\  \"  \"  )  ;", "} else", "if    ( versionDependency . isUpperInclusive (  )  )     {", "writer . print (  \"  \\  \"  \"  )  ;", "writer . print ( versionDependency . getLowerBound (  )  )  ;", "writer . print (  \"  \\  \"  .  .  .  \\  \"  \"  )  ;", "writer . print ( versionDependency . getUpperBound (  )  )  ;", "writer . print (  \"  \\  \"  \"  )  ;", "} else    {", "writer . print (  \"  \\  \"  \"  )  ;", "writer . print ( versionDependency . getLowerBound (  )  )  ;", "writer . print (  \"  \\  \"  .  .  <  \\  \"  \"  )  ;", "writer . print ( versionDependency . getUpperBound (  )  )  ;", "writer . print (  \"  \\  \"  \"  )  ;", "}", "} else    {", "writer . print (  \"  . branch (  \\  \"  \"  )  ;", "writer . print (  (  ( BranchDependency )     ( dependency )  )  . getBranch (  )  )  ;", "writer . print (  \"  \\  \"  )  \"  )  ;", "}", "writer . println (  \"  )  ,  \"  )  ;", "}", "writer . println (  \"              ]  ,  \"  )  ;", "}", "writer . println (  \"             targets :     [  \"  )  ;", "for    ( DefaultTarget   target    :    srcPackage . getTargets (  )  )     {", "writer . println (  \"                          . target (  \"  )  ;", "writer . print (  \"                                     name :     \\  \"  \"  )  ;", "writer . print ( target . getName (  )  )  ;", "writer . println (  \"  \\  \"  ,  \"  )  ;", "if    (  (  !  ( target . getRequiredTargets (  )  . isEmpty (  )  )  )     |  |     (  !  ( target . getRequiredProducts (  )  . isEmpty (  )  )  )  )     {", "writer . println (  \"                                     dependencies :     [  \"  )  ;", "for    ( String   dep    :    target . getRequiredTargets (  )  )     {", "writer . print (  \"                                                  . target ( name :     \\  \"  \"  )  ;", "writer . print ( dep )  ;", "writer . println (  \"  \\  \"  )  ,  \"  )  ;", "}", "for    ( String   dep    :    target . getRequiredProducts (  )  )     {", "writer . print (  \"                                                  . product ( name :     \\  \"  \"  )  ;", "writer . print ( dep )  ;", "writer . println (  \"  \\  \"  )  ,  \"  )  ;", "}", "writer . println (  \"                                      ]  ,  \"  )  ;", "}", "writer . print (  \"                                     path :     \\  \"  \"  )  ;", "Path   productPath    =    target . getPath (  )  . toPath (  )  ;", "String   relPath    =    baseDir . relativize ( productPath )  . toString (  )  ;", "writer . print (  ( relPath . isEmpty (  )     ?     \"  .  \"     :    relPath )  )  ;", "writer . println (  \"  \\  \"  ,  \"  )  ;", "writer . println (  \"                                     sources :     [  \"  )  ;", "Set < String >    sorted    =    new   TreeSet < String >  (  )  ;", "for    ( File   sourceFile    :    target . getSourceFiles (  )  )     {", "sorted . add ( productPath . relativize ( sourceFile . toPath (  )  )  . toString (  )  )  ;", "}", "for    ( String   sourcePath    :    sorted )     {", "writer . print (  \"                                                  \\  \"  \"  )  ;", "writer . print ( sourcePath )  ;", "writer . println (  \"  \\  \"  ,  \"  )  ;", "}", "writer . print (  \"                                      ]  \"  )  ;", "if    (  ( target . getPublicHeaderDir (  )  )     !  =    null )     {", "writer . println (  \"  ,  \"  )  ;", "writer . print (  \"                                     publicHeadersPath :     \\  \"  \"  )  ;", "writer . print ( productPath . relativize ( target . getPublicHeaderDir (  )  . toPath (  )  )  )  ;", "writer . print (  \"  \\  \"  \"  )  ;", "}", "writer . println (  )  ;", "writer . println (  \"                          )  ,  \"  )  ;", "}", "writer . print (  \"              ]  \"  )  ;", "if    (  ( srcPackage . getSwiftLanguageVersion (  )  )     !  =    null )     {", "writer . println (  \"  ,  \"  )  ;", "writer . print (  \"             swiftLanguageVersions :     [  \"  )  ;", "writer . print ( srcPackage . getSwiftLanguageVersion (  )  . getVersion (  )  )  ;", "writer . print (  \"  ]  \"  )  ;", "}", "writer . println (  )  ;", "writer . println (  \"  )  \"  )  ;", "}    finally    {", "writer . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   write   manifest   file    % s .  \"  ,    manifest )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.swiftpm.tasks.GenerateSwiftPackageManagerManifest"}, {"methodBody": ["METHOD_START", "{", "return   manifestFile ;", "}", "METHOD_END"], "methodName": ["getManifestFile"], "fileName": "org.gradle.swiftpm.tasks.GenerateSwiftPackageManagerManifest"}, {"methodBody": ["METHOD_START", "{", "return   packageProperty ;", "}", "METHOD_END"], "methodName": ["getPackage"], "fileName": "org.gradle.swiftpm.tasks.GenerateSwiftPackageManagerManifest"}]