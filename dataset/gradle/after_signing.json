[{"methodBody": ["METHOD_START", "{", "return   signatures . add ( signature )  ;", "}", "METHOD_END"], "methodName": ["addSignature"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    files )     {", "addature ( new   ature ( file ,    classifier ,    this ,    this )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addSignatures"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getSignatory (  )  )     =  =    null )     {", "throw   new   api . InvalidUserDataException (  (  (  \" Cannot   perform   signing   task    \\  '  \"     +     ( getPath (  )  )  )     +     \"  \\  '    because   it   has   no   configured   signatory \"  )  )  ;", "}", "for    ( Signature   signature    :    signatures )     {", "signature . generate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileCollectionFactory"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   getFileCollectionFactory (  )  . fixed (  (  (  \" Task    \\  '  \"     +     ( getPath (  )  )  )     +     \"  \\  '    files   to   sign \"  )  ,    Lists . newLinkedList ( Iterables . filter ( getInputFiles (  )  ,    Predicates . notNull (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFilesToSign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . transform ( signatures ,    Sign . SIGNATURE _ TO _ SIGN _ FILE _ FUNCTION )  ;", "}", "METHOD_END"], "methodName": ["getInputFiles"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "ArrayListMultimap < String ,    File >    filesWithPotentialNameCollisions    =    ArrayListMultimap . create (  )  ;", "for    ( Signature   ature    :    getSignatures (  )  )     {", "String   name    =    Sign . JAVA _ PARTS . matcher ( ature . getName (  )  )  . replaceAll (  \"  _  \"  )  ;", "if    (  (  ( name . length (  )  )     >     0  )     &  &     (  !  ( Character . isJavaIdentifierStart ( name . codePointAt (  0  )  )  )  )  )     {", "name    =     \"  _  \"     +     ( name . substring (  1  )  )  ;", "}", "filesWithPotentialNameCollisions . put ( name ,    ature . getFile (  )  )  ;", "}", "Map < String ,    File >    files    =    Maps . newHashMap (  )  ;", "for    ( Map . Entry < String ,    Collection < File >  >    entry    :    filesWithPotentialNameCollisions . asMap (  )  . entrySet (  )  )     {", "File [  ]    filesWithSameName    =    entry . getValue (  )  . toArray ( new   File [  0  ]  )  ;", "boolean   hasMoreThanOneFileWithSameName    =     ( filesWithSameName . length )     >     1  ;", "for    ( int   i    =     0  ;    i    <     ( filesWithSameName . length )  ;    i +  +  )     {", "File   file    =    filesWithSameName [ i ]  ;", "String   key    =    entry . getKey (  )  ;", "if    ( hasMoreThanOneFileWithSameName )     {", "key    +  =     \"  $  \"     +     ( i    +     1  )  ;", "}", "files . put ( key ,    file )  ;", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["getOutputFiles"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   signatory ;", "}", "METHOD_END"], "methodName": ["getSignatory"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   getFileCollectionFactory (  )  . fixed (  (  (  \" Task    \\  '  \"     +     ( getPath (  )  )  )     +     \"  \\  '    signature   files \"  )  ,    Lists . newLinkedList ( Iterables . filter ( Iterables . transform ( signatures ,    Sign . SIGNATURE _ FILE _ FUNCTION )  ,    Predicates . notNull (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSignatureFiles"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   signatureType ;", "}", "METHOD_END"], "methodName": ["getSignatureType"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   signatures ;", "}", "METHOD_END"], "methodName": ["getSignatures"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "final   DomainObjectSet < Signature >    signatureSet    =    getSignatures (  )  ;", "if    (  ( signatureSet . size (  )  )     =  =     0  )     {", "throw   new   IllegalStateException (  \" Expected    % s   to   contain   exactly   one   signature ,    however ,    it   contains   no   signatures .  \"  )  ;", "} else", "if    (  ( signatureSet . size (  )  )     =  =     1  )     {", "return   signatureSet . iterator (  )  . next (  )  ;", "} else    {", "throw   new   IllegalStateException (  (  (  \" Expected    % s   to   contain   exactly   one   signature ,    however ,    it   contains   no    \"     +     ( String . valueOf ( signatureSet . size (  )  )  )  )     +     \"    signatures .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSingleSignature"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "return   required ;", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "setRequired ( required )  ;", "}", "METHOD_END"], "methodName": ["required"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "this . required    =    required ;", "}", "METHOD_END"], "methodName": ["setRequired"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "this . signatory    =    signatory ;", "}", "METHOD_END"], "methodName": ["setSignatory"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "this . signatureType    =    signatureType ;", "}", "METHOD_END"], "methodName": ["setSignatureType"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "addSignatures ( null ,    files )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "addSignatures ( classifier ,    files )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "for    ( Task   task    :    tasks )     {", "if    (  !  ( task   instanceof   AbstractArchiveTask )  )     {", "throw   new   api . InvalidUserDataException (  (  (  \" You   cannot   sign   tasks   that   are   not    \\  ' archive \\  '    tasks ,    such   as    \\  ' jar \\  '  ,     \\  ' zip \\  '    etc .     ( you   tried   to   sign    \"     +     ( String . valueOf ( task )  )  )     +     \"  )  \"  )  )  ;", "}", "signTask (  (  ( AbstractArchiveTask )     ( task )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "for    ( Configuration   configuration    :    configurations )     {", "configuration . getAllArtifacts (  )  . all ( new   api . Action < PublishArtifact >  (  )     {", "@ Override", "public   void   execute ( PublishArtifact   artifact )     {", "if    ( artifact   instanceof   Signature )     {", "return ;", "}", "signArtifact ( artifact )  ;", "}", "}  )  ;", "configuration . getAllArtifacts (  )  . whenObjectRemoved ( new   api . Action < PublishArtifact >  (  )     {", "@ Override", "public   void   execute ( final   PublishArtifact   publishArtifact )     {", "signatures . remove ( Iterables . find ( signatures ,    new   com . google . common . base . Predicate < Signature >  (  )     {", "@ Override", "public   boolean   apply ( Signature   input )     {", "return   input . getToSignArtifact (  )  . equals ( publishArtifact )  ;", "}", "}  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "for    ( PublishArtifact   publishArtifact    :    publishArtifacts )     {", "Artifact ( publishArtifact )  ;", "}", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "dependsOn ( publishArtifact )  ;", "addature ( new   ature ( publishArtifact ,    this ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["signArtifact"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "dependsOn ( archiveTask )  ;", "addature ( new   ature ( new   Callable < File >  (  )     {", "public   File   call (  )     {", "return   archiveTask . getArchivePath (  )  ;", "}", "}  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return   archiveTask . getClassifier (  )  ;", "}", "}  ,    this ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["signTask"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "this . signatory    =    signatory ;", "}", "METHOD_END"], "methodName": ["signatory"], "fileName": "org.gradle.plugins.signing.Sign"}, {"methodBody": ["METHOD_START", "{", "ArrayList < File >    files    =    new   ArrayList < File >  ( signatures . size (  )  )  ;", "for    ( Signature   signature    :    signatures )     {", "File   file    =    getFile . apply ( signature )  ;", "if    ( file    !  =    null )     {", "files . add ( file )  ;", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["collectSignatureFiles"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configureSelf ( closure ,    this )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( Signature   signature    :    signatures )     {", "signature . generate (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "return    \" SignOperation \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "return   newSignatureFileCollection ( new   com . google . common . base . Function < Signature ,    File >  (  )     {", "@ Override", "public   File   apply ( Signature   input )     {", "return   input . getToSign (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getFilesToSign"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "return   newSignatureFileCollection ( new   com . google . common . base . Function < Signature ,    File >  (  )     {", "@ Override", "public   File   apply ( Signature   input )     {", "return   input . getFile (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getSignatureFiles"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList < Signature >  ( signatures )  ;", "}", "METHOD_END"], "methodName": ["getSignatures"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "final   int   size    =    signatures . size (  )  ;", "switch    ( size )     {", "case    1     :", "return   signatures . get (  0  )  ;", "case    0     :", "throw   new   IllegalStateException (  \" Expected   o   to   contain   exactly   one   signature ,    however ,    it   contains   no   signatures .  \"  )  ;", "default    :", "throw   new   IllegalStateException (  (  (  \" Expected   o   to   contain   exactly   one   signature ,    however ,    it   contains    \"     +     ( String . valueOf ( size )  )  )     +     \"    signatures .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSingleSignature"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleFileCollection ( collectSignatureFiles ( getFile )  )  ;", "}", "METHOD_END"], "methodName": ["newSignatureFileCollection"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    files )     {", "atures . add ( new   Signature ( file ,    this )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    files )     {", "atures . add ( new   Signature ( file ,    classifier ,    this )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "for    ( PublishArtifact   artifact    :    artifacts )     {", "atures . add ( new   Signature ( artifact ,    this )  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "this . signatory    =    signatory ;", "return   this ;", "}", "METHOD_END"], "methodName": ["signatory"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "this . signatureType    =    type ;", "return   this ;", "}", "METHOD_END"], "methodName": ["signatureType"], "fileName": "org.gradle.plugins.signing.SignOperation"}, {"methodBody": ["METHOD_START", "{", "File   file    =    getFile (  )  ;", "if    ( file    =  =    null )     {", "ren   null ;", "}", "long   modified    =    file . lastModified (  )  ;", "if    ( modified    =  =     0 L )     {", "ren   null ;", "}", "ren   new   Date ( modified )  ;", "}", "METHOD_END"], "methodName": ["defaultDate"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( toSignArtifact )     !  =    null    ?    toSignArtifact . getName (  )     :    fileName (  )  ;", "}", "METHOD_END"], "methodName": ["defaultName"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "File   toSign    =    getToSign (  )  ;", "Type   signatureType    =    getType (  )  ;", "return    ( toSign    !  =    null )     &  &     ( signatureType    !  =    null )     ?    signatureType . combinedExtension ( toSign )     :    null ;", "}", "METHOD_END"], "methodName": ["defaultType"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "final   Fifi =    getFi )  ;", "return   fi !  =    null    ?    figetName (  )     :    null ;", "}", "METHOD_END"], "methodName": ["fileName"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "File   toSign    =    getToSign (  )  ;", "if    ( toSign    =  =    null )     {", "if    ( signatureSpec . isRequired (  )  )     {", "throw   new   InvalidUserDataException (  \" Unable   to   generate   signature   as   the   file   to   sign   has   not   been   specified \"  )  ;", "} else    {", "return ;", "}", "}", "Signatory   signatory    =    getSignatory (  )  ;", "if    ( signatory    =  =    null )     {", "if    ( signatureSpec . isRequired (  )  )     {", "throw   new   InvalidUserDataException (  (  (  \" Unable   to   generate   signature   for    \\  '  \"     +     ( String . valueOf ( toSign )  )  )     +     \"  \\  '    as   no   signatory   is   available   to   sign \"  )  )  ;", "} else    {", "return ;", "}", "}", "Type   signatureType    =    getType (  )  ;", "if    ( signatureType    =  =    null )     {", "if    ( signatureSpec . isRequired (  )  )     {", "throw   new   InvalidUserDataException (  (  (  \" Unable   to   generate   signature   for    \\  '  \"     +     ( String . valueOf ( toSign )  )  )     +     \"  \\  '    as   no   signature   type   has   been   configured \"  )  )  ;", "} else    {", "return ;", "}", "}", "signatureType . sign ( signatory ,    toSign )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( classifier )     !  =    null    ?    classifier    :    uncheckedCall ( classifierGenerator )  ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( date )     !  =    null    ?    date    :    defaultDate (  )  ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( extension )     !  =    null    ?    extension    :    signatureTypeExtension (  )  ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "File   toSign    =    getToSign (  )  ;", "Type   signatureType    =    getType (  )  ;", "return    ( toSign    !  =    null )     &  &     ( signatureType    !  =    null )     ?    signatureType . fileFor ( toSign )     :    null ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( name )     !  =    null    ?    name    :    defaultName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return   signatureSpec . getSignatory (  )  ;", "}", "METHOD_END"], "methodName": ["getSignatory"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return   signatureSpec ;", "}", "METHOD_END"], "methodName": ["getSignatureSpec"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return   signatureSpec . getSignatureType (  )  ;", "}", "METHOD_END"], "methodName": ["getSignatureType"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "File   toSign    =    uncheckedCall ( toSignGenerator )  ;", "return   toSign    !  =    null    ?    toSign    :    null ;", "}", "METHOD_END"], "methodName": ["getToSign"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return   toSignArtifact ;", "}", "METHOD_END"], "methodName": ["getToSignArtifact"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "return    ( type )     !  =    null    ?    type    :    defaultType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . toSignGenerator    =    toSign ;", "this . classifierGenerator    =    classifier ;", "this . sSpec    =    sSpec ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . classifier    =    classifier ;", "}", "METHOD_END"], "methodName": ["setClassifier"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . date    =    date ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . extension    =    extension ;", "}", "METHOD_END"], "methodName": ["setExtension"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . nagUserOfDeprecated (  \" Using   Signature . setFile (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . signatureSpec    =    signatureSpec ;", "}", "METHOD_END"], "methodName": ["setSignatureSpec"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "SignatureType   signatureType    =    getSignatureType (  )  ;", "return   signatureType    !  =    null    ?    signatureType . getExtension (  )     :    null ;", "}", "METHOD_END"], "methodName": ["signatureTypeExtension"], "fileName": "org.gradle.plugins.signing.Signature"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( spec   instanceof   IConventionAware )  )     {", "throw   new   InvalidUserDataException (  (  (  \" Cannot   add   conventions   to   ature   spec    \\  '  \"     +     ( String . valueOf ( spec )  )  )     +     \"  \\  '    as   it   is   not   convention   aware \"  )  )  ;", "}", "ConventionMapping   conventionMapping    =     (  ( IConventionAware )     ( spec )  )  . getConventionMapping (  )  ;", "conventionMapping . map (  \" atory \"  ,    new   Callable < Signatory >  (  )     {", "public   Signatory   call (  )     {", "return   getSignatory (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" atureType \"  ,    new   Callable < SignatureType >  (  )     {", "public   SignatureType   call (  )     {", "return   getSignatureType (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" required \"  ,    new   Callable < Boolean >  (  )     {", "public   Boolean   call (  )     {", "return   isRequired (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addSignatureSpecConventions"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "task . getSignatures (  )  . all ( new   Action < Signature >  (  )     {", "public   void   execute ( Signature   sig )     {", "configuration . getArtifacts (  )  . add ( sig )  ;", "}", "}  )  ;", "return   task . getSignatures (  )  . whenObjectRemoved ( new   Action < Signature >  (  )     {", "public   void   execute ( Signature   sig )     {", "configuration . getArtifacts (  )  . remove ( sig )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addSignaturesToConfiguration"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "Sign   signTask    =    project . getTasks (  )  . create (  (  \" sign \"     +     ( capitalize ( name )  )  )  ,    Sign . class ,    taskConfiguration )  ;", "addSignaturesToConfiguration ( signTask ,    getConfiguration (  )  )  ;", "return   signTask ;", "}", "METHOD_END"], "methodName": ["createSignTaskFor"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   PgpSignatoryProvider (  )  ;", "}", "METHOD_END"], "methodName": ["createSignatoryProvider"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultSignatureTypeProvider (  )  ;", "}", "METHOD_END"], "methodName": ["createSignatureTypeProvider"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   doSignOperation ( new   Action < SignOperation >  (  )     {", "@ Override", "public   void   execute ( SignOperation   operation )     {", "operation . configure ( setup )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["doSignOperation"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "SignOperation   operation    =    instantiator (  )  . newInstance ( SignOperation . class )  ;", "addSignatureSpecConventions ( operation )  ;", "setup . execute ( operation )  ;", "operation . execute (  )  ;", "return   operation ;", "}", "METHOD_END"], "methodName": ["doSignOperation"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   maybeCallable   instanceof   Callable    ?    uncheckedCall (  (  ( Callable )     ( maybeCallable )  )  )     :    maybeCallable ;", "}", "METHOD_END"], "methodName": ["force"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   configuration ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "Configuration   configuration    =    configurations . findByName (  . DEFAULT _ CONFIGURATION _ NAME )  ;", "return   configuration    !  =    null    ?    configuration    :    configurations . create (  . DEFAULT _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getDefaultConfiguration"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   signatories ;", "}", "METHOD_END"], "methodName": ["getSignatories"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   signatories . getDefaultSignatory ( project )  ;", "}", "METHOD_END"], "methodName": ["getSignatory"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   signatureTypes . getDefaultType (  )  ;", "}", "METHOD_END"], "methodName": ["getSignatureType"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   signatureTypes ;", "}", "METHOD_END"], "methodName": ["getSignatureTypes"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ProjectInternal )     ( project )  )  . getServices (  )  . get ( Instantiator . class )  ;", "}", "METHOD_END"], "methodName": ["instantiator"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   castToBoolean ( force ( required )  )  ;", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "this . required    =    required ;", "}", "METHOD_END"], "methodName": ["setRequired"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "this . required    =    required ;", "}", "METHOD_END"], "methodName": ["setRequired"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "this . signatories    =    signatories ;", "}", "METHOD_END"], "methodName": ["setSignatories"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "this . signatureTypes    =    signatureTypes ;", "}", "METHOD_END"], "methodName": ["setSignatureTypes"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   doSignOperation ( closure )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   doSignOperation ( new   Action < SignOperation >  (  )     {", "public   void   execute ( SignOperation   operation )     {", "operation . sign ( files )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   doSignOperation ( new   Action < SignOperation >  (  )     {", "public   void   execute ( SignOperation   operation )     {", "operation . sign ( classifier ,    files )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "List < Sign >    result    =    new   ArrayList < Sign >  ( tasks . length )  ;", "for    ( final   Task   taskToSign    :    tasks )     {", "result . add ( createSignTaskFor ( taskToSign . getName (  )  ,    new   api . Action < Sign >  (  )     {", "public   void   execute ( Sign   task )     {", "task . sign ( taskToSign )  ;", "}", "}  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "List < Sign >    result    =    new   ArrayList < Sign >  ( configurations . length )  ;", "for    ( final   Configuration   configurationToSign    :    configurations )     {", "result . add ( createSignTaskFor ( configurationToSign . getName (  )  ,    new   api . Action < Sign >  (  )     {", "public   void   execute ( Sign   task )     {", "task . sign ( configurationToSign )  ;", "}", "}  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   doSignOperation ( new   Action < SignOperation >  (  )     {", "public   void   execute ( SignOperation   operation )     {", "operation . sign ( publishArtifacts )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "return   signPom ( mavenDeployment ,    null )  ;", "}", "METHOD_END"], "methodName": ["signPom"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "SignOperation   signOperation    =    doSignOperation ( new   Action < SignOperation >  (  )     {", "public   void   execute ( SignOperation   so )     {", "so . sign ( mavenDeployment . getPomArtifact (  )  )  ;", "so . configure ( closure )  ;", "}", "}  )  ;", "Signature   pomSignature    =    signOperation . getSingleSignature (  )  ;", "if    (  !  ( pomSignature . getFile (  )  . exists (  )  )  )     {", "return   null ;", "}", "pomSignature . setType (  (  \" pom .  \"     +     ( pomSignature . getSignatureType (  )  . getExtension (  )  )  )  )  ;", "mavenDeployment . addArtifact ( pomSignature )  ;", "return   pomSignature ;", "}", "METHOD_END"], "methodName": ["signPom"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "signatories . configure ( this ,    closure )  ;", "return   signatories ;", "}", "METHOD_END"], "methodName": ["signatories"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "setSignatories ( new   GnupgSignatoryProvider (  )  )  ;", "}", "METHOD_END"], "methodName": ["useGpgCmd"], "fileName": "org.gradle.plugins.signing.SigningExtension"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( BasePlugin . class )  ;", "project . getExtensions (  )  . create (  \"  \"  ,    SigningExtension . class ,    project )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.plugins.signing.SigningPlugin"}, {"methodBody": ["METHOD_START", "{", "String   defaultExecutable    =     ( useLegacyGpg )     ?     \" gpg \"     :     \" gpg 2  \"  ;", "if    ( OperaSystem . current (  )  . isWindows (  )  )     {", "defaultExecutable    +  =     \"  . exe \"  ;", "}", "return   defaultExecutable ;", "}", "METHOD_END"], "methodName": ["defaultExecutable"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executable )     =  =    null )     {", "return   defaultExecutable (  )  ;", "}", "return   executable ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "return   homeDir ;", "}", "METHOD_END"], "methodName": ["getHomeDir"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "return   keyName ;", "}", "METHOD_END"], "methodName": ["getKeyName"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "return   optionsFile ;", "}", "METHOD_END"], "methodName": ["getOptionsFile"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "return   passphrase ;", "}", "METHOD_END"], "methodName": ["getPassphrase"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "return   useLegacyGpg ;", "}", "METHOD_END"], "methodName": ["getUseLegacyGpg"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . executable    =    executable ;", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . homeDir    =    homeDir ;", "}", "METHOD_END"], "methodName": ["setHomeDir"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . keyName    =    keyName ;", "}", "METHOD_END"], "methodName": ["setKeyName"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . optionsFile    =    optionsFile ;", "}", "METHOD_END"], "methodName": ["setOptionsFile"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . passphrase    =    passphrase ;", "}", "METHOD_END"], "methodName": ["setPassphrase"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "this . useLegacyGpg    =    useLegacyGpg ;", "}", "METHOD_END"], "methodName": ["setUseLegacyGpg"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSettings"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    args    =    new   ArrayList < String >  (  )  ;", "if    (  ( homeDir )     !  =    null )     {", "args . add (  \"  -  - homedir \"  )  ;", "args . add ( homeDir . getAbsolutePath (  )  )  ;", "}", "if    (  ( optionsFile )     !  =    null )     {", "args . add (  \"  -  - options \"  )  ;", "args . add ( optionsFile . getAbsolutePath (  )  )  ;", "}", "if    (  ( keyName )     !  =    null )     {", "args . add (  \"  -  - local - user \"  )  ;", "args . add ( keyName )  ;", "}", "if    (  ( passphrase )     !  =    null )     {", "if    ( useLegacyGpg )     {", "args . add (  \"  -  - no - use - agent \"  )  ;", "} else    {", "args . add (  \"  -  - pinentry - mode = loopback \"  )  ;", "}", "args . add (  \"  -  - passphrase \"  )  ;", "args . add ( passphrase )  ;", "} else    {", "if    ( useLegacyGpg )     {", "args . add (  \"  -  - use - agent \"  )  ;", "}", "}", "args . add (  \"  -  - no - tty \"  )  ;", "args . add (  \"  -  - batch \"  )  ;", "args . add (  \"  -  - detach -  \"  )  ;", "return   args ;", "}", "METHOD_END"], "methodName": ["buildArgumentList"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatory"}, {"methodBody": ["METHOD_START", "{", "return    (  (  \" signing . gnupg .  \"     +    propertyPrefix )     +     ( propertyPrefix . isEmpty (  )     ?     \"  \"     :     \"  .  \"  )  )     +    property ;", "}", "METHOD_END"], "methodName": ["buildQualifiedProperty"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( project ,     \" default \"  )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( project ,    name ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   GnupgSignatory ( project ,    name ,    readSettings ( project ,    propertyPrefix )  )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "Object   executable    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" executable \"  )  )  ;", "Object   useLegacyGpg    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" useLegacyGpg \"  )  )  ;", "Object   homeDir    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" homeDir \"  )  )  ;", "Object   optionsFile    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" optionsFile \"  )  )  ;", "Object   keyName    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" keyName \"  )  )  ;", "Object   passphrase    =    project . findProperty ( buildQualifiedProperty ( propertyPrefix ,     \" passphrase \"  )  )  ;", "ettings   settings    =    new   ettings (  )  ;", "if    ( executable    !  =    null )     {", "settings . setExecutable ( executable . toString (  )  )  ;", "}", "if    ( useLegacyGpg    !  =    null )     {", "settings . setUseLegacyGpg ( Boolean . parseBoolean ( useLegacyGpg . toString (  )  )  )  ;", "}", "if    ( homeDir    !  =    null )     {", "settings . setHomeDir ( project . file ( homeDir . toString (  )  )  )  ;", "}", "if    ( optionsFile    !  =    null )     {", "settings . setOptionsFile ( project . file ( optionsFile . toString (  )  )  )  ;", "}", "if    ( keyName    !  =    null )     {", "settings . setKeyName ( keyName . toString (  )  )  ;", "}", "if    ( passphrase    !  =    null )     {", "settings . setPassphrase ( passphrase . toString (  )  )  ;", "}", "return   settings ;", "}", "METHOD_END"], "methodName": ["readSettings"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     0  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Invalid   args    (  \"     +    name )     +     \"  :     \"  )     +     ( String . valueOf ( args )  )  )     +     \"  )  \"  )  )  ;", "}", "signatories . put ( name ,    factory . create ( project ,    name ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["createSignatoryFor"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "return   getSignatory ( signatoryName )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.plugins.signing.signatory.internal.gnupg.GnupgSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "return   asHex ;", "}", "METHOD_END"], "methodName": ["getAsHex"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpKeyId"}, {"methodBody": ["METHOD_START", "{", "return   asLong ;", "}", "METHOD_END"], "methodName": ["getAsLong"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpKeyId"}, {"methodBody": ["METHOD_START", "{", "String   keyIdUpped    =    keyId . toUpperCase (  )  ;", "switch    ( keyIdUpped . length (  )  )     {", "case    1  0     :", "if    (  !  ( keyIdUpped . startsWith (  \"  0 X \"  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  1  0    character   key   IDs   must   start   with    0 x    ( given   value :     \"     +    keyId )     +     \"  )  \"  )  )  ;", "}", "return   keyIdUpped . substring (  2  )  ;", "case    8     :", "if    ( keyId . startsWith (  \"  0 X \"  )  )     {", "throw   new   IllegalArgumentException (  (  (  \"  8    character   key   IDs   must   not   start   with    0 x    ( given   value :     \"     +    keyId )     +     \"  )  \"  )  )  ;", "}", "return   keyIdUpped ;", "default    :", "throw   new   IllegalStateException (  (  \" The   key   ID   must   be   in   a   valid   form    ( eg    0  0 B 5  0  5  0 F   or    0 x 0  0 B 5  0  5  0 F )  ,    given   value :     \"     +    keyId )  )  ;", "}", "}", "METHOD_END"], "methodName": ["normaliseKeyId"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpKeyId"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \"  %  0  8 X \"  ,     (  4  2  9  4  9  6  7  2  9  5 L    &    keyId )  )  ;", "}", "METHOD_END"], "methodName": ["toHex"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpKeyId"}, {"methodBody": ["METHOD_START", "{", "if    ( keyId    =  =    null )     {", "throw   new   IllegalArgumentException (  \"  ' keyId '    cannot   be   null \"  )  ;", "}", "String   normalised    =     . normaliseKeyId ( keyId )  ;", "try    {", "return   Long . parseLong ( normalised ,     1  6  )  ;", "}    catch    ( NumberFormatException   e )     {", "throw   new   IllegalArgumentException (  (  (  \" the   key   id    \\  '  \"     +    keyId )     +     \"  \\  '    is   not   a   valid   hex   string \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toLong"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpKeyId"}, {"methodBody": ["METHOD_START", "{", "try    {", "PBESecretKeyDecryptor   decryptor    =    new   BcPBESecretKeyDecryptorBuilder ( new   BcPGPDigestCalculatorProvider (  )  )  . build ( password . toCharArray (  )  )  ;", "return   secretKey . extractPrivateKey ( decryptor )  ;", "}    catch    ( PGPException   e )     {", "throw   new   internal . UncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createPrivateKey"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatory"}, {"methodBody": ["METHOD_START", "{", "try    {", "PGPSignatureGenerator   generator    =    new   PGPSignatureGenerator ( new   BcPGPContentSignerBuilder ( secretKey . getPublicKey (  )  . getAlgorithm (  )  ,    PGPUtil . SHA 1  )  )  ;", "generator . init ( BINARY _ DOCUMENT ,    privateKey )  ;", "return   generator ;", "}    catch    ( PGPException   e )     {", "throw   new   internal . UncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createSignatureGenerator"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatory"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [  1  0  2  4  ]  ;", "int   read    =    to . read ( buffer )  ;", "while    ( read    >     0  )     {", "generator . update ( buffer ,     0  ,    read )  ;", "read    =    to . read ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["feedGeneratorWith"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatory"}, {"methodBody": ["METHOD_START", "{", "BCPGOutputStream   bufferedOutput    =    new   BCPGOutputStream ( signatureDestination )  ;", "pure . encode ( bufferedOutput )  ;", "bufferedOutput . flush (  )  ;", "}", "METHOD_END"], "methodName": ["writeSignatureTo"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( name ,    readSecretKey ( keyId ,    keyRing )  ,    password )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PgpSignatory ( name ,    secretKey ,    password )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( project ,    false )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   readProperties ( project ,    null ,     \" default \"  ,    required )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( project ,    propertyPrefix ,    false )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   readProperties ( project ,    propertyPrefix ,    propertyPrefix ,    required )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   createSignatory ( project ,    propertyPrefix ,    name ,    false )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   readProperties ( project ,    propertyPrefix ,    name ,    required )  ;", "}", "METHOD_END"], "methodName": ["createSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "Iterator < PGPSecretKeyRing >    keyRingIterator    =    uncheckedCast ( keyRings . getKeyRings (  )  )  ;", "while    ( keyRingIterator . hasNext (  )  )     {", "PGPSecretKeyRing   keyRing    =    keyRingIterator . next (  )  ;", "Iterator < PGPSecretKey >    secretKeyIterator    =    uncheckedCast ( keyRing . getSecretKeys (  )  )  ;", "while    ( secretKeyIterator . hasNext (  )  )     {", "PGPSecretKey   secretKey    =    secretKeyIterator . next (  )  ;", "if    ( hasId ( keyId ,    secretKey )  )     {", "return   secretKey ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSecretKey"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "final   boolean   propertyFound    =    project . hasProperty ( qualifiedProperty )  ;", "if    (  (  ! propertyFound )     &  &    required )     {", "throw   new   InvalidUserDataException (  (  (  \" property    \\  '  \"     +    qualifiedProperty )     +     \"  \\  '    could   not   be   found   on   project   and   is   needed   for    \"  )  )  ;", "}", "if    ( propertyFound )     {", "Object   prop    =    project . property ( qualifiedProperty )  ;", "if    (  ( prop    =  =    null )     &  &    required )     {", "throw   new   InvalidUserDataException (  (  (  \" property    \\  '  \"     +    qualifiedProperty )     +     \"  \\  '    was   null .    A   valid   value   is   needed   for    \"  )  )  ;", "}", "return   prop ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPropertySafely"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  \" signing .  \"     +     ( propertyPrefix    !  =    null    ?    propertyPrefix    +     \"  .  \"     :     \"  \"  )  )     +    name ;", "}", "METHOD_END"], "methodName": ["getQualifiedPropertyName"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   PgpKeyId ( secretKey . getKeyID (  )  )  . equals ( keyId )  ;", "}", "METHOD_END"], "methodName": ["hasId"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   KeyId ( keyId )  ;", "}    catch    ( IllegalArgumentException   e )     {", "throw   new   InvalidUserDataException ( e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["normalizeKeyId"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   newInputStream ( file )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   new   InvalidUserDataException (  (  (  \" Unable   to   retrieve   secret   key   from   key   rfile    \\  '  \"     +     ( StrvalueOf ( file )  )  )     +     \"  \\  '    as   it   does   not   exist \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["openSecretKeyFile"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "return   readProperties ( project ,    prefix ,    name ,    false )  ;", "}", "METHOD_END"], "methodName": ["readProperties"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Object >    values    =    new   ArrayList < Object >  (  )  ;", "for    ( String   property    :     . PROPERTIES )     {", "String   qualifiedProperty    =     (  ( String )     ( getQualifiedPropertyName ( prefix ,    property )  )  )  ;", "Object   prop    =    getPropertySafely ( project ,    qualifiedProperty ,    required )  ;", "if    ( prop    !  =    null )     {", "values . add ( prop )  ;", "} else    {", "return   null ;", "}", "}", "String   keyId    =    values . get (  0  )  . toString (  )  ;", "File   keyRing    =    project . file ( values . get (  1  )  . toString (  )  )  ;", "String   password    =    values . get (  2  )  . toString (  )  ;", "return   createSignatory ( name ,    keyId ,    keyRing ,    password )  ;", "}", "METHOD_END"], "methodName": ["readProperties"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "Object   keyRingCollection ;", "try    {", "keyRingCollection    =    new   BcPGPSecretKeyRingCollection ( input )  ;", "}    catch    ( Exception   e )     {", "throw   new   InvalidUserDataException (  (  (  \" Unable   to   read   secret   key   from    \"     +    sourceDescription )     +     \"     ( it   may   not   be   a   PGP   secret   key   ring )  \"  )  ,    e )  ;", "}", "return   readSecretKey (  (  ( PGPSecretKeyRingCollection )     ( keyRingCollection )  )  ,    normalizeKeyId ( keyId )  ,    sourceDescription )  ;", "}", "METHOD_END"], "methodName": ["readSecretKey"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "InputStream   inputStream    =    openSecretKeyFifi ;", "try    {", "return   readSecretKey ( inputStream ,    keyId ,     (  \" fi    \"     +     ( figetAbsolutePath (  )  )  )  )  ;", "}    finally    {", "uncheckedClose ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["readSecretKey"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "PGPSecretKey   key    =    findSecretKey ( keyR ,    keyId )  ;", "if    ( key    =  =    null )     {", "throw   new   InvalidUserDataException (  (  (  (  (  \" did   not   find   secret   key   for   id    \\  '  \"     +     ( StrvalueOf ( keyId )  )  )     +     \"  \\  '    in   key   source    \\  '  \"  )     +    sourceDescription )     +     \"  \\  '  \"  )  )  ;", "}", "return   key ;", "}", "METHOD_END"], "methodName": ["readSecretKey"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryFactory"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configure ( closure ,    new   Object (  )     {", "@ SuppressWarnings (  \" unused \"  )", "public   void   methodMissing ( String   name ,    Object   args )     {", "createFor ( settings . getProject (  )  ,    name ,    asType ( args ,    Object [  ]  . class )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "switch    ( args . length )     {", "case    3     :", "String   keyId    =    args [  0  ]  . toString (  )  ;", "File   keyRing    =    project . file ( args [  1  ]  . toString (  )  )  ;", "String   password    =    args [  2  ]  . toString (  )  ;", "signatories . put ( name ,    factory . create ( name ,    keyId ,    keyRing ,    password )  )  ;", "break ;", "case    0     :", "signatories . put ( name ,    factory . create ( project ,    name ,    true )  )  ;", "break ;", "default    :", "throw   new   IllegalArgumentException (  (  (  (  (  \" Invalid   args    (  \"     +    name )     +     \"  :     \"  )     +     ( String . valueOf ( args )  )  )     +     \"  )  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createSignatoryFor"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "return   factory . createSignatory ( project )  ;", "}", "METHOD_END"], "methodName": ["getDefaultSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "return   signatories . get ( name )  ;", "}", "METHOD_END"], "methodName": ["getSignatory"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "return   getSignatory ( signatoryName )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.plugins.signing.signatory.pgp.PgpSignatoryProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( hasTypeForExtension ( extension )  )  )     {", "throw   new   InvalidUserDataException (  (  (  \" no   s   type   is   registered   for   extension    \\  '  \"     +    extension )     +     \"  \\  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertHasTypeForExtension"], "fileName": "org.gradle.plugins.signing.type.AbstractSignatureTypeProvider"}, {"methodBody": ["METHOD_START", "{", "types . put ( type . getExtension (  )  ,    type )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.plugins.signing.type.AbstractSignatureTypeProvider"}]