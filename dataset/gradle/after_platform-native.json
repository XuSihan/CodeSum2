[{"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.language.swift.SwiftVersion"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.nativeplatform.NativeExecutableFileSpec"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.NativeExecutableFileSpec"}, {"methodBody": ["METHOD_START", "{", "this . file    =    file ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.nativeplatform.NativeExecutableFileSpec"}, {"methodBody": ["METHOD_START", "{", "this . toolChain    =    toolChain ;", "}", "METHOD_END"], "methodName": ["setToolChain"], "fileName": "org.gradle.nativeplatform.NativeExecutableFileSpec"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.gradle.nativeplatform.NativeInstallationSpec"}, {"methodBody": ["METHOD_START", "{", "this . directory    =    directory ;", "}", "METHOD_END"], "methodName": ["setDirectory"], "fileName": "org.gradle.nativeplatform.NativeInstallationSpec"}, {"methodBody": ["METHOD_START", "{", "return   getName (  )  . equals ( osFamily )  ;", "}", "METHOD_END"], "methodName": ["is"], "fileName": "org.gradle.nativeplatform.OperatingSystemFamily"}, {"methodBody": ["METHOD_START", "{", "return   is ( OperatingSystemFamily . LINUX )  ;", "}", "METHOD_END"], "methodName": ["isLinux"], "fileName": "org.gradle.nativeplatform.OperatingSystemFamily"}, {"methodBody": ["METHOD_START", "{", "return   is ( OperatingSystemFamily . MACOS )  ;", "}", "METHOD_END"], "methodName": ["isMacOs"], "fileName": "org.gradle.nativeplatform.OperatingSystemFamily"}, {"methodBody": ["METHOD_START", "{", "return   is ( OperatingSystemFamily . WINDOWS )  ;", "}", "METHOD_END"], "methodName": ["isWindows"], "fileName": "org.gradle.nativeplatform.OperatingSystemFamily"}, {"methodBody": ["METHOD_START", "{", "File   compilerExe    =    OperatingSystem . current (  )  . findInPath (  \" clang \"  )  ;", "if    ( compilerExe    !  =    null )     {", "return   new    . InstalledClang (  )  ;", "}", "return   new    . UnavailableToolChain (  \" clang \"  )  ;", "}", "METHOD_END"], "methodName": ["findClang"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "File   compilerExe    =    new   File (  \" C :  / cygwin / bin / g +  +  . exe \"  )  ;", "if    ( compilerExe . isFile (  )  )     {", "return   new    . InstalledWindowsGcc (  \" gcc   cygwin \"  )  . inPath ( compilerExe . getParentFile (  )  )  ;", "}", "return   new    . UnavailableToolChain (  \" gcc   cygwin \"  )  ;", "}", "METHOD_END"], "methodName": ["findCygwin"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "GccMetadataProvider   versionDeterminer    =    GccMetadataProvider . forGcc ( TestFiles . execActionFactory (  )  )  ;", "Set < File >    gppCandidates    =    ImmutableSet . copyOf ( OperatingSystem . current (  )  . findAllInPath (  \" g +  +  \"  )  )  ;", "List <  . ToolChainCandidate >    toolChains    =    Lists . newArrayList (  )  ;", "if    (  !  ( gppCandidates . isEmpty (  )  )  )     {", "File   firstInPath    =    gppCandidates . iterator (  )  . next (  )  ;", "for    ( File   candidate    :    gppCandidates )     {", "SearchResult < GccMetadata >    version    =    versionDeterminer . getCompilerMetaData ( candidate ,    Collections .  < String > emptyList (  )  )  ;", "if    ( version . isAvailable (  )  )     {", ". InstalledGcc   gcc    =    new    . InstalledGcc (  (  (  \" gcc \"     +     \"     \"  )     +     ( version . getComponent (  )  . getVersion (  )  )  )  )  ;", "if    (  !  ( candidate . equals ( firstInPath )  )  )     {", "gcc . inPath ( candidate . getParentFile (  )  )  ;", "}", "toolChains . add ( gcc )  ;", "}", "}", "}", "if    ( mustFind    &  &     ( toolChains . isEmpty (  )  )  )     {", "toolChains . add ( new    . UnavailableToolChain (  \" gcc \"  )  )  ;", "}", "return   toolChains ;", "}", "METHOD_END"], "methodName": ["findGccs"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "File   compilerExe    =    new   File (  \" C :  / MinGW / bin / g +  +  . exe \"  )  ;", "if    ( compilerExe . isFile (  )  )     {", "return   new    . InstalledWindowsGcc (  \" mingw \"  )  . inPath ( compilerExe . getParentFile (  )  )  ;", "}", "return   new    . UnavailableToolChain (  \" mingw \"  )  ;", "}", "METHOD_END"], "methodName": ["findMinGW"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "List < AvailableToolChains . ToolChainCandidate >    toolChains    =    Lists . newArrayList (  )  ;", "SwiftcMetadataProvider   versionDeterminer    =    new   SwiftcMetadataProvider ( TestFiles . execActionFactory (  )  )  ;", "File   rootSwiftInstall    =    new   File (  \"  / opt / swift \"  )  ;", "File [  ]    candidates    =    GUtil . elvis ( rootSwiftInstall . listFiles ( new   FileFilter (  )     {", "@ Override", "public   boolean   accept ( File   swiftInstall )     {", "return    ( swiftInstall . isDirectory (  )  )     &  &     (  !  ( swiftInstall . getName (  )  . equals (  \" latest \"  )  )  )  ;", "}", "}  )  ,    new   File [  0  ]  )  ;", "for    ( File   swiftInstall    :    candidates )     {", "File   swiftc    =    new   File ( swiftInstall ,     \"  / usr / bin / swiftc \"  )  ;", "SearchResult < SwiftcMetadata >    version    =    versionDeterminer . getCompilerMetaData ( swiftc ,    Collections .  < String > emptyList (  )  )  ;", "if    ( version . isAvailable (  )  )     {", "File   binDir    =    swiftc . getParentFile (  )  ;", "toolChains . add ( new   AvailableToolChains . InstalledSwiftc ( binDir ,    version . getComponent (  )  . getVersion (  )  )  . inPath ( binDir ,    new   File (  \"  / usr / bin \"  )  )  )  ;", "}", "}", "List < File >    swiftcCandidates    =    OperatingSystem . current (  )  . findAllInPath (  \" swiftc \"  )  ;", "for    ( File   candidate    :    swiftcCandidates )     {", "SearchResult < SwiftcMetadata >    version    =    versionDeterminer . getCompilerMetaData ( candidate ,    Collections .  < String > emptyList (  )  )  ;", "if    ( version . isAvailable (  )  )     {", "File   binDir    =    candidate . getParentFile (  )  ;", "AvailableToolChains . InstalledSwiftc   swiftc    =    new   AvailableToolChains . InstalledSwiftc ( binDir ,    version . getComponent (  )  . getVersion (  )  )  ;", "swiftc . inPath ( binDir ,    new   File (  \"  / usr / bin \"  )  )  ;", "toolChains . add ( swiftc )  ;", "}", "}", "if    ( toolChains . isEmpty (  )  )     {", "toolChains . add ( new   AvailableToolChains . UnavailableToolChain (  \" swiftc \"  )  )  ;", "}", "return   toolChains ;", "}", "METHOD_END"], "methodName": ["findSwiftcs"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "final   List <  ?    extends   VisualStudioInstall >    searchResults    =    VisualStudioLocatorTestFixture . getVisualStudioLocator (  )  . locateAllComponents (  )  ;", "List <  . ToolChainCandidate >    toolChains    =    Lists . newArrayList (  )  ;", "for    ( VisualStudioInstall   install    :    searchResults )     {", "if    (  . isTestableVisualStudioVersion ( install . getVersion (  )  )  )     {", "toolChains . add ( new    . InstalledVisualCpp (  . getVisualStudioVersion ( install . getVersion (  )  )  )  . withInstall ( install )  )  ;", "}", "}", "if    ( toolChains . isEmpty (  )  )     {", "toolChains . add ( new    . UnavailableToolChain (  \" visual   c +  +  \"  )  )  ;", "}", "return   toolChains ;", "}", "METHOD_END"], "methodName": ["findVisualCpps"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "for    ( AvailableToolChains . ToolChainCandidate   toolChain    :    AvailableToolChains . getToolChains (  )  )     {", "if    ( toolChain . isAvailable (  )  )     {", "return    (  ( AvailableToolChains . InstalledToolChain )     ( toolChain )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDefaultToolChain"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "for    ( AvailableToolChains . ToolChainCandidate   toolChainCandidate    :    AvailableToolChains . getToolChains (  )  )     {", "if    ( toolChainCandidate . meets ( requirement )  )     {", "assert   toolChainCandidate . isAvailable (  )  ;", "return    (  ( AvailableToolChains . InstalledToolChain )     ( toolChainCandidate )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "if    (  ( AvailableToolChains . toolChains )     =  =    null )     {", "List < AvailableToolChains . ToolChainCandidate >    compilers    =    new   ArrayList < AvailableToolChains . ToolChainCandidate >  (  )  ;", "if    ( OperatingSystem . current (  )  . isWindows (  )  )     {", "compilers . addAll ( AvailableToolChains . findVisualCpps (  )  )  ;", "compilers . add ( AvailableToolChains . findMinGW (  )  )  ;", "compilers . add ( AvailableToolChains . findCygwin (  )  )  ;", "} else", "if    ( OperatingSystem . current (  )  . isMacOsX (  )  )     {", "compilers . add ( AvailableToolChains . findClang (  )  )  ;", "compilers . addAll ( AvailableToolChains . findGccs ( false )  )  ;", "compilers . addAll ( AvailableToolChains . findSwiftcs (  )  )  ;", "} else    {", "compilers . addAll ( AvailableToolChains . findGccs ( true )  )  ;", "compilers . add ( AvailableToolChains . findClang (  )  )  ;", "compilers . addAll ( AvailableToolChains . findSwiftcs (  )  )  ;", "}", "AvailableToolChains . toolChains    =    compilers ;", "}", "return   AvailableToolChains . toolChains ;", "}", "METHOD_END"], "methodName": ["getToolChains"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . findFirst ( VisualStudioVersion . values (  )  ,    new   Spec < VisualStudioVersion >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( VisualStudioVersion   candidate )     {", "return    ( candidate . getVersion (  )  . getMajor (  )  )     =  =     ( version . getMajor (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getVisualStudioVersion"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "return    ( AvailableToolChains . getVisualStudioVersion ( version )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isTestableVisualStudioVersion"], "fileName": "org.gradle.nativeplatform.fixtures.AvailableToolChains"}, {"methodBody": ["METHOD_START", "{", "return   new   NativePlatforms (  )  . getDefaultPlatformName (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultPlatformName"], "fileName": "org.gradle.nativeplatform.fixtures.NativePlatformsTestFixture"}, {"methodBody": ["METHOD_START", "{", "if    ( toolChain . meets ( ToolChainRequirement . SWIFTC )  )     {", "RequiresInstalledToolChain   toolChainRequirement    =    target . getAnnotation ( RequiresInstalledToolChain . class )  ;", "return   toolChainRequirement    !  =    null ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["canUseToolChain"], "fileName": "org.gradle.nativeplatform.fixtures.SingleToolChainTestRunner"}, {"methodBody": ["METHOD_START", "{", "final   CppLibraryElement   delegate    =    this ;", "return   new   CppLibraryElement (  )     {", "@ Override", "public   SourceElement   getPublicHeaders (  )     {", "List < SourceFile >    headers    =    new   ArrayList < SourceFile >  (  )  ;", "for    ( SourceFile   sourceFile    :    delegate . getPublicHeaders (  )  . getFiles (  )  )     {", "headers . add ( sourceFile (  \" public \"  ,    sourceFile . getName (  )  ,    sourceFile . getContent (  )  )  )  ;", "}", "return   SourceElement . ofFiles ( headers )  ;", "}", "@ Override", "public   SourceElement   getPrivateHeaders (  )     {", "return   delegate . getPrivateHeaders (  )  ;", "}", "@ Override", "public   SourceElement   getSources (  )     {", "return   delegate . getSources (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["asLib"], "fileName": "org.gradle.nativeplatform.fixtures.app.CppLibraryElement"}, {"methodBody": ["METHOD_START", "{", "return   SourceElement . empty (  )  ;", "}", "METHOD_END"], "methodName": ["getPrivateHeaders"], "fileName": "org.gradle.nativeplatform.fixtures.app.CppLibraryElement"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . filter ( getSourceFileNames (  )  ,    new   Spec < String >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( String   sourceFileName )     {", "return    !  ( sourceFileName . endsWith (  \"  . h \"  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getSourceFileNamesWithoutHeaders"], "fileName": "org.gradle.nativeplatform.fixtures.app.CppSourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceFile ( path ,    name ,    content )  ;", "}", "METHOD_END"], "methodName": ["sourceFile"], "fileName": "org.gradle.nativeplatform.fixtures.app.Element"}, {"methodBody": ["METHOD_START", "{", "return   compilerConfig (  \" args \"  ,    arg )  ;", "}", "METHOD_END"], "methodName": ["compilerArgs"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "String   quotedArgs    =    CollectionUtils . join (  \"  ,  \"  ,    CollectionUtils . collect ( args ,    new   HelloWorldApp . SingleQuotingTransformer (  )  )  )  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( String   plugin    :    getPluginList (  )  )     {", "String   compilerPrefix    =    getCompilerPrefix ( plugin )  ;", "if    ( compilerPrefix    =  =    null )     {", "continue ;", "}", "builder . append ( compilerPrefix )  . append (  \" Compiler .  \"  )  . append ( action )  . append (  \"     \"  )  . append ( quotedArgs )  . append (  \"  \\ n \"  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["compilerConfig"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   compilerConfig (  \" define \"  ,    define )  ;", "}", "METHOD_END"], "methodName": ["compilerDefine"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   compilerConfig (  \" define \"  ,    define ,    value )  ;", "}", "METHOD_END"], "methodName": ["compilerDefine"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "if    ( plugin . equals (  \" c \"  )  )     {", "return    \" c \"  ;", "}", "if    ( plugin . equals (  \" cpp \"  )  )     {", "return    \" cpp \"  ;", "}", "if    ( plugin . equals (  \" objec - c \"  )  )     {", "return    \" objc \"  ;", "}", "if    ( plugin . equals (  \" objec - cpp \"  )  )     {", "return    \" objcpp \"  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getCompilerPrefix"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   value    +     \"  \\ n 1  2  \"  ;", "}", "METHOD_END"], "methodName": ["getCustomOutput"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return    ( HelloWorldApp . HELLO _ WORLD )     +     \"  \\ n 1  2  \"  ;", "}", "METHOD_END"], "methodName": ["getEnglishOutput"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getExtraConfiguration"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getExtraConfiguration"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return    ( HelloWorldApp . HELLO _ WORLD _ FRENCH )     +     \"  \\ n 1  2  \"  ;", "}", "METHOD_END"], "methodName": ["getFrenchOutput"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   getSourceType (  )  . replaceAll (  \"  (  [ a - z ]  )  (  [ A - Z ]  )  \"  ,     \"  $  1  -  $  2  \"  )  . toLowerCase (  )  ;", "}", "METHOD_END"], "methodName": ["getNormalizedPluginName"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( getNormalizedPluginName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPluginList"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "for    ( String   plugin    :    getPluginList (  )  )     {", "builderend ( ly   plugin :     '  \"  ) end ( plugin ) end (  \"  \\  '  \\ n \"  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getPluginScript"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   FilenameUtils . getExtension ( getMainSource (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSourceExtension"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   getMainSource (  )  . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceType"], "fileName": "org.gradle.nativeplatform.fixtures.app.HelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   IncrementalCppElement . rename ( beforeElement ,    IncrementalElement . AbstractRenameTransform . DEFAULT _ RENAME _ PREFIX )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalCppElement"}, {"methodBody": ["METHOD_START", "{", "SourceFile   beforeFile    =    beforeElement . getSource (  )  . getSourceFile (  )  ;", "final   SourceFile   afterFile    =    new   SourceFile ( beforeFile . getPath (  )  ,     ( renamePrefix    +     ( beforeFile . getName (  )  )  )  ,    beforeFile . getContent (  )  )  ;", "return   new   Element . AbstractRenameTransform ( beforeFile ,    afterFile ,    beforeElement )     {", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "List < SourceFile >    result    =    new   ArrayList < SourceFile >  (  )  ;", "result . addAll ( beforeElement . getHeaders (  )  . getFiles (  )  )  ;", "result . add ( afterFile )  ;", "return   result ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalCppElement"}, {"methodBody": ["METHOD_START", "{", "return   new   IncrementalElement . Transform (  )     {", "@ Override", "public   void   applyChangesToProject ( TestFile   projectDir )     {", "afterElement . writeToProject ( projectDir )  ;", "}", "@ Override", "public   List < SourceFile >    getBeforeFiles (  )     {", "return   Collections . emptyList (  )  ;", "}", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   afterElement . getFiles (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "for    ( IncrementalElement . Transform   transform    :    getIncrementalChanges (  )  )     {", "transform . applyChangesToProject ( projectDir )  ;", "}", "}", "METHOD_END"], "methodName": ["applyChangesToProject"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "final   String   sourceSetName    =    beforeElement . getSourceSetName (  )  ;", "final   List < SourceFile >    beforeFiles    =    beforeElement . getFiles (  )  ;", "return   new    . Transform (  )     {", "@ Override", "public   void   applyChangesToProject ( TestFile   projectDir )     {", "for    ( SourceFile   beforeFile    :    beforeFiles )     {", "TestFile   file    =    projectDir . file ( beforeFile . withPath (  (  \" src /  \"     +    sourceSetName )  )  )  ;", "file . assertExists (  )  ;", "file . delete (  )  ;", "}", "}", "@ Override", "public   List < SourceFile >    getBeforeFiles (  )     {", "return   beforeElement . getFiles (  )  ;", "}", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   Collections . emptyList (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "return    \" main \"  ;", "}", "METHOD_END"], "methodName": ["getSourceSetName"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( beforeFiles . size (  )  )     !  =     ( afterFiles . size (  )  )  )     {", "return   false ;", "}", "for    ( SourceFile   beforeFile    :    beforeFiles )     {", "boolean   found    =    false ;", "for    ( SourceFile   afterFile    :    afterFiles )     {", "if    (  ( beforeFile . getName (  )  . equals ( afterFile . getName (  )  )  )     &  &     ( beforeFile . getPath (  )  . equals ( afterFile . getPath (  )  )  )  )     {", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["hasSameFiles"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "assert   IncrementalElement . hasSameFiles ( beforeElement . getFiles (  )  ,    afterElement . getFiles (  )  )  ;", "assert   beforeElement . getSourceSetName (  )  . equals ( afterElement . getSourceSetName (  )  )  ;", "return   new   IncrementalElement . Transform (  )     {", "@ Override", "public   void   applyChangesToProject ( TestFile   projectDir )     {", "afterElement . writeToProject ( projectDir )  ;", "}", "@ Override", "public   List < SourceFile >    getBeforeFiles (  )     {", "return   beforeElement . getFiles (  )  ;", "}", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   afterElement . getFiles (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["modify"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "return   new   IncrementalElement . Transform (  )     {", "@ Override", "public   void   applyChangesToProject ( TestFile   projectDir )     {", "}", "@ Override", "public   List < SourceFile >    getBeforeFiles (  )     {", "return   element . getFiles (  )  ;", "}", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   element . getFiles (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["preserve"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "original . writeToProject ( projectDir )  ;", "}", "METHOD_END"], "methodName": ["writeToProject"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalElement"}, {"methodBody": ["METHOD_START", "{", "return   new   TestApp (  )     {", "@ Override", "public   SourceFile   getMainSource (  )     {", "return   getAlternateMainSource (  )  ;", "}", "@ Override", "public   SourceFile   getLibraryHeader (  )     {", "return   getAlternateLibraryHeader (  )  ;", "}", "@ Override", "public   List < SourceFile >    getLibrarySources (  )     {", "return   getAlternateLibrarySources (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getAlternate"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalHelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "return   getLibraryHeader (  )  ;", "}", "METHOD_END"], "methodName": ["getAlternateLibraryHeader"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalHelloWorldApp"}, {"methodBody": ["METHOD_START", "{", "assert    ( beforeElement . getFiles (  )  . size (  )  )     =  =     1  ;", "assert    ( afterElement . getFiles (  )  . size (  )  )     =  =     1  ;", "assert   beforeElement . getSourceSetName (  )  . equals ( afterElement . getSourceSetName (  )  )  ;", "final   String   sourceSetName    =    beforeElement . getSourceSetName (  )  ;", "final   SourceFile   beforeFile    =    beforeElement . getSourceFile (  )  ;", "final   SourceFile   afterFile    =    afterElement . getSourceFile (  )  ;", "assert   beforeFile . getPath (  )  . equals ( afterFile . getPath (  )  )  ;", "assert   beforeFile . getName (  )  . equals ( afterFile . getName (  )  )  ;", "assert    !  ( beforeFile . getContent (  )  . equals ( afterFile . getContent (  )  )  )  ;", "return   new   Element . Transform (  )     {", "@ Override", "public   void   applyChangesToProject ( TestFile   projectDir )     {", "TestFile   file    =    projectDir . file ( beforeFile . withPath (  (  \" src /  \"     +    sourceSetName )  )  )  ;", "file . assertExists (  )  ;", "file . write ( afterFile . getContent (  )  )  ;", "}", "@ Override", "public   List < SourceFile >    getBeforeFiles (  )     {", "return   Arrays . asList ( beforeFile )  ;", "}", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   Arrays . asList ( afterFile )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["modify"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftElement"}, {"methodBody": ["METHOD_START", "{", "return   IncrementalSwiftElement . rename ( beforeElement ,    IncrementalElement . AbstractRenameTransform . DEFAULT _ RENAME _ PREFIX )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftElement"}, {"methodBody": ["METHOD_START", "{", "assert    ( beforeElement . getFiles (  )  . size (  )  )     =  =     1  ;", "SourceFile   beforeFile    =    beforeElement . getSourceFile (  )  ;", "final   SourceFile   afterFile    =    new   SourceFile ( beforeFile . getPath (  )  ,     ( renamePrefix    +     ( beforeFile . getName (  )  )  )  ,    beforeFile . getContent (  )  )  ;", "return   new   Element . AbstractRenameTransform ( beforeFile ,    afterFile ,    beforeElement )     {", "@ Override", "public   List < SourceFile >    getAfterFiles (  )     {", "return   Arrays . asList ( afterFile )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftElement"}, {"methodBody": ["METHOD_START", "{", "XCTestSourceElement . assertTestCasesRanInSuite ( testExecutionResult ,    getAlternateTestSuites (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAlternateTestCasesRan"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "XCTestSourceElement . assertTestCasesRanInSuite ( testExecutionResult ,    getTestSuites (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertTestCasesRan"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( XCTestSourceFile   element    :    getAlternateTestSuites (  )  )     {", "result    +  =    element . getFailureCount (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAlternateFailureCount"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( XCTestSourceFile   element    :    getAlternateTestSuites (  )  )     {", "result    +  =    element . getPassCount (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAlternatePassCount"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "int   result    =     0  ;", "for    ( XCTestSourceFile   element    :    getAlternateTestSuites (  )  )     {", "result    +  =    element . getTestCount (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAlternateTestCount"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "if    ( OperatingSystem . current (  )  . isLinux (  )  )     {", "new   SourceFile (  )     {", "@ Override", "public   String   getSourceSetName (  )     {", "return    \" test \"  ;", "}", "@ Override", "public   SourceFile   getSourceFile (  )     {", "return   XCTestSource . getLinuxMainSourceFile ( testSuites )  ;", "}", "}  . writeToProject ( projectDir )  ;", "}", "}", "METHOD_END"], "methodName": ["writeLinuxMainToProjectIfNeeded"], "fileName": "org.gradle.nativeplatform.fixtures.app.IncrementalSwiftXCTestElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceElement (  )     {", "@ Override", "public   List < SourceFile >    getFiles (  )     {", "return   Collections . emptyList (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . collect ( getFiles (  )  ,    new   Transformer < String ,    SourceFile >  (  )     {", "@ Override", "public   String   transform ( SourceFile   sourceFile )     {", "return   sourceFile . getName (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getSourceFileNames"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return    \" main \"  ;", "}", "METHOD_END"], "methodName": ["getSourceSetName"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceElement (  )     {", "@ Override", "public   List < SourceFile >    getFiles (  )     {", "List < SourceFile >    files    =    new   ArrayList < SourceFile >  (  )  ;", "for    ( SourceElement   element    :    elements )     {", "files . addAll ( element . getFiles (  )  )  ;", "}", "return   files ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["ofElements"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceElement (  )     {", "@ Override", "public   List < SourceFile >    getFiles (  )     {", "return   files ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["ofFiles"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceElement (  )     {", "@ Override", "public   List < SourceFile >    getFiles (  )     {", "return   Arrays . asList ( files )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["ofFiles"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "TestFile   srcDir    =    projectDir . file (  (  \" src /  \"     +     ( getSourceSetName (  )  )  )  )  ;", "for    ( SourceFile   sourceFile    :    getFiles (  )  )     {", "sourceFile . writeToDir ( srcDir )  ;", "}", "}", "METHOD_END"], "methodName": ["writeToProject"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "for    ( SourceFile   sourceFile    :    getFiles (  )  )     {", "sourceFile . writeToFile ( sourceDir . file ( sourceFile . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeToSourceDir"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceFileElement (  )     {", "@ Override", "public   SourceFile   getSourceFile (  )     {", "return   file ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["ofFile"], "fileName": "org.gradle.nativeplatform.fixtures.app.SourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . capitalize ( projectName )  ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.gradle.nativeplatform.fixtures.app.SwiftSourceElement"}, {"methodBody": ["METHOD_START", "{", "return   projectName ;", "}", "METHOD_END"], "methodName": ["getProjectName"], "fileName": "org.gradle.nativeplatform.fixtures.app.SwiftSourceElement"}, {"methodBody": ["METHOD_START", "{", "return   new   TestNativeComponent (  )     {", "@ Override", "public   List < SourceFile >    getHeaderFiles (  )     {", "return   Collections . emptyList (  )  ;", "}", "@ Override", "public   List < SourceFile >    getSourceFiles (  )     {", "return   Arrays . asList ( getMainSource (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.nativeplatform.fixtures.app.TestApp"}, {"methodBody": ["METHOD_START", "{", "return   new   TestNativeComponent (  )     {", "@ Override", "public   List < SourceFile >    getSourceFiles (  )     {", "return   getLibrarySources (  )  ;", "}", "@ Override", "public   List < SourceFile >    getHeaderFiles (  )     {", "return   Arrays . asList ( getLibraryHeader (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getLibrary"], "fileName": "org.gradle.nativeplatform.fixtures.app.TestApp"}, {"methodBody": ["METHOD_START", "{", "XCTestSourceElement . assertTestCasesRanInSuite ( testExecutionResult ,    getTestSuites (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertTestCasesRan"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceElement"}, {"methodBody": ["METHOD_START", "{", "for    ( XCTestSourceFileElement   element    :    testSuites )     {", "element . assertTestCasesRan ( testExecutionResult . testClass ( element . getTestSuiteName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertTestCasesRanInSuite"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceElement"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   content    =    new   StringBuilder (  )  ;", "content . append (  \" import   XCTest \\ n \"  )  ;", "for    ( FileElement   testSuite    :    testSuites )     {", "content . append (  (  (  \" extension    \"     +     ( testSuite . getTestSuiteName (  )  )  )     +     \"     {  \\ n \"  )  )  ;", "content . append (  \"       public   static   var   allTests    =     [  \\ n \"  )  ;", "for    ( XCTestCaseElement   testCase    :    testSuite . getTestCases (  )  )     {", "content . append (  (  (  (  (  \"              (  \\  \"  \"     +     ( testCase . getName (  )  )  )     +     \"  \\  \"  ,     \"  )     +     ( testCase . getName (  )  )  )     +     \"  )  ,  \\ n \"  )  )  ;", "}", "content . append (  \"        ]  \\ n \"  )  ;", "content . append (  \"  }  \\ n \"  )  ;", "}", "content . append (  \" XCTMain (  [  \\ n \"  )  ;", "for    ( FileElement   testSuite    :    testSuites )     {", "content . append (  (  (  \"       testCase (  \"     +     ( testSuite . getTestSuiteName (  )  )  )     +     \"  . allTests )  ,  \\ n \"  )  )  ;", "}", "content . append (  \"  ]  )  \\ n \"  )  ;", "return   new   SourceFile (  \" swift \"  ,     \" main . swift \"  ,    content . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLinuxMainSourceFile"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceElement"}, {"methodBody": ["METHOD_START", "{", "testExecutionResult . assertTestCount ( getTestCount (  )  ,    getFailureCount (  )  ,     0  )  ;", "for    ( XCTestCas   testCase    :    getTestCases (  )  )     {", "if    ( testCase . isExpectFailure (  )  )     {", "testExecutionResult . assertTestFailed ( testCase . getName (  )  ,    Matchers . anything (  )  )  ;", "} else    {", "testExecutionResult . assertTestPassed ( testCase . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertTestCasesRan"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   sourceFile (  \" resources \"  ,     \" Info . plist \"  ,     (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \" UTF -  8  \\  \"  ?  >  \\ n \"     +     (  (  (  (  \"  <  ! DOCTYPE   plist   PUBLIC    \\  \"  -  /  / Apple /  / DTD   PLIST    1  .  0  /  / EN \\  \"     \\  \" http :  /  / www . apple . com / DTDs / PropertyList -  1  .  0  . dtd \\  \"  >  \\ n \"     +     \"  < plist   version =  \\  \"  1  .  0  \\  \"  >  \\ n \"  )     +     \"  < dict >  \\ n \"  )     +     \"  <  / dict >  \\ n \"  )     +     \"  <  / plist >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["emptyInfoPlist"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   testCase ( methodName ,     \" XCTAssert ( false )  \"  ,    true )  ;", "}", "METHOD_END"], "methodName": ["failingTestCase"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   imports ;", "}", "METHOD_END"], "methodName": ["getImports"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   sourceFile (  \" swift \"  ,     (  ( getTestSuiteName (  )  )     +     \"  . swift \"  )  ,     (  (  (  (  (  (  (  (  ( renderImports (  )  )     +     \"  \\ n \"  )     +     \" class    \"  )     +     ( getTestSuiteName (  )  )  )     +     \"  :    XCTestCase    {  \\ n \"  )     +     \"              \"  )     +     ( renderTestCases (  )  )  )     +     \"  \\ n \"  )     +     \"  }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getSourceFile"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   testSuiteName ;", "}", "METHOD_END"], "methodName": ["getTestSuiteName"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   testableImports ;", "}", "METHOD_END"], "methodName": ["getTestableImports"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   testCase ( methodName ,     \" XCTAssert ( true )  \"  ,    false )  ;", "}", "METHOD_END"], "methodName": ["passingTestCase"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( String   importModule    :    getImports (  )  )     {", "sbend (  \" import    \"  ) end ( importModule ) end (  '  \\ n '  )  ;", "}", "for    ( String   importModule    :    getTestableImports (  )  )     {", "sbend (  \"  @ testable   import    \"  ) end ( importModule ) end (  '  \\ n '  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["renderImports"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   Joiner . on (  \"  \\ n \"  )  . join ( CollectionUtils . collect ( getTestCases (  )  ,    new   Transformer < String ,    XCTestCaseElement >  (  )     {", "@ Override", "public   String   transform ( XCTestCaseElement   testCase )     {", "return    ( testCase . getContent (  )  )     +     \"  \\ n \"  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["renderTestCases"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   testCase ( methodName ,    assertion ,    false )  ;", "}", "METHOD_END"], "methodName": ["testCase"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "return   new   XCTestCaseElement (  )     {", "@ Override", "public   String   getContent (  )     {", "return    (  (  (  (  (  \" func    \"     +    methodName )     +     \"  (  )     {  \\ n \"  )     +     \"              \"  )     +    assertion )     +     \"  \\ n \"  )     +     \"  }  \"  ;", "}", "@ Override", "public   String   getName (  )     {", "return   methodName ;", "}", "@ Override", "public   boolean   isExpectFailure (  )     {", "return   isExpectFailure ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["testCase"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "imports . add ( importName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withImport"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "testableImports . add ( importName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withTestableImport"], "fileName": "org.gradle.nativeplatform.fixtures.app.XCTestSourceFileElement"}, {"methodBody": ["METHOD_START", "{", "VisualCppMetadataProvider   visualCppMetadataProvider    =    new   DefaultVisualCppMetadataProvider ( NativeServicesTestFixture . getInstance (  )  . get ( WindowsRegistry . class )  )  ;", "VisualStudioVersionLocator   commandLineLocator    =    new   CommandLineToolVersionLocator ( TestFiles . execActionFactory (  )  ,    visualCppMetadataProvider ,     . getVswhereLocator (  )  )  ;", "VisualStudioVersionLocator   windowsRegistryLocator    =    new   WindowsRegistryVersionLocator ( NativeServicesTestFixture . getInstance (  )  . get ( WindowsRegistry . class )  )  ;", "VisualStudioMetaDataProvider   versionDeterminer    =    new   VisualStudioVersionDeterminer ( commandLineLocator ,    windowsRegistryLocator ,    visualCppMetadataProvider )  ;", "VisualStudioVersionLocator   systemPathLocator    =    new   SystemPathVersionLocator ( OperatingSystem . current (  )  ,    versionDeterminer )  ;", "return   new   DefaultVisualStudioLocator ( commandLineLocator ,    windowsRegistryLocator ,    systemPathLocator ,    versionDeterminer ,    NativeServicesTestFixture . getInstance (  )  . get ( SystemInfo . class )  )  ;", "}", "METHOD_END"], "methodName": ["getVisualStudioLocator"], "fileName": "org.gradle.nativeplatform.fixtures.msvcpp.VisualStudioLocatorTestFixture"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultVswhereVersionLocator ( NativeServicesTestFixture . getInstance (  )  . get ( WindowsRegistry . class )  ,    OperatingSystem . current (  )  )  ;", "}", "METHOD_END"], "methodName": ["getVswhereLocator"], "fileName": "org.gradle.nativeplatform.fixtures.msvcpp.VisualStudioLocatorTestFixture"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.nativeplatform.fixtures.msvcpp.VisualStudioVersion"}, {"methodBody": ["METHOD_START", "{", "return   year ;", "}", "METHOD_END"], "methodName": ["getYear"], "fileName": "org.gradle.nativeplatform.fixtures.msvcpp.VisualStudioVersion"}, {"methodBody": ["METHOD_START", "{", "return   fileCollectionFactory ;", "}", "METHOD_END"], "methodName": ["getFileCollectionFactory"], "fileName": "org.gradle.nativeplatform.internal.AbstractNativeBinarySpec"}, {"methodBody": ["METHOD_START", "{", "Set <  ?    super   Object >    allLibs    =    new   LinkedHashSet < Object >  ( libs )  ;", "for    ( DependentSourceSet   dependentSourceSet    :    sourceSets )     {", "allLibs . addAll ( dependentSourceSet . getLibs (  )  )  ;", "}", "ResolveResult   resolution    =    new   ResolveResult ( this ,    allLibs )  ;", "resolver . resolve ( resolution )  ;", "return   resolution ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.nativeplatform.internal.AbstractNativeBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   getFileCollectionFactory (  )  . create ( new   AbstractNativeLibraryBinarySpec . HeaderFileSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getHeaderDirs"], "fileName": "org.gradle.nativeplatform.internal.AbstractNativeLibraryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "for    ( LanguageSourceSet   sourceSet    :    getInputs (  )  )     {", "if    (  !  ( sourceSet . getSource (  )  . isEmpty (  )  )  )     {", "return   true ;", "}", "if    ( sourceSet . hasBuildDependencies (  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasSources"], "fileName": "org.gradle.nativeplatform.internal.AbstractNativeLibraryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "if    ( names . isEmpty (  )  )     {", "return   new   LinkedHashSet < T >  ( candidates )  ;", "}", "Set < String >    unusmes    =    new   HashSet < String >  ( names )  ;", "Set < T >    chosen    =    new   LinkedHashSet < T >  (  )  ;", "for    ( T   candidate    :    candidates )     {", "if    ( unusmes . remove ( candidate . getName (  )  )  )     {", "chosen . add ( candidate )  ;", "}", "}", "if    (  !  ( unusmes . isEmpty (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Invalid    % s :     '  % s '  \"  ,    type . getSimpleName (  )  ,    unusmes . iterator (  )  . next (  )  )  )  ;", "}", "return   chosen ;", "}", "METHOD_END"], "methodName": ["chooseElements"], "fileName": "org.gradle.nativeplatform.internal.AbstractTargetedNativeComponentSpec"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildOperationLoggingCompilerDecorator < T >  ( delegate )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.nativeplatform.internal.BuildOperationLoggingCompilerDecorator"}, {"methodBody": ["METHOD_START", "{", "return   HashUtil . createCompactMD 5  ( fileResolver . resolveAsRelativePath ( sourceFile )  )  ;", "}", "METHOD_END"], "methodName": ["generateUniqueNameFor"], "fileName": "org.gradle.nativeplatform.internal.CompilerOutputFileNamingScheme"}, {"methodBody": ["METHOD_START", "{", "final   String   baseName    =    FilenameUtils . removeExtension ( sourceFile . getName (  )  )  ;", "final   String   uniqueName    =    generateUniqueNameFor ( sourceFile )  ;", "File   hashDirectory    =    new   File ( outputBaseFolder ,    uniqueName )  ;", "return   new   File ( hashDirectory ,     ( baseName    +     ( objeceSuffix )  )  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.gradle.nativeplatform.internal.CompilerOutputFileNamingScheme"}, {"methodBody": ["METHOD_START", "{", "this . objectFileNameSuffix    =    suffix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withObjectFileNameSuffix"], "fileName": "org.gradle.nativeplatform.internal.CompilerOutputFileNamingScheme"}, {"methodBody": ["METHOD_START", "{", "this . outputBaseFolder    =    outputBaseFolder ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withOutputBaseFolder"], "fileName": "org.gradle.nativeplatform.internal.CompilerOutputFileNamingScheme"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    iterable )     {", "list . add ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.nativeplatform.internal.DefaultLinkerSpec"}, {"methodBody": ["METHOD_START", "{", "binary . getTasks (  )  . create ( namingScheme . getTaskName ( NativeComponents . ASSEMBLE _ DEPENDENTS _ TASK _ NAME )  ,    DefaultTask . class ,    new   Action < DefaultTask >  (  )     {", "@ Override", "public   void   execute ( DefaultTask   buildDependentsTask )     {", "buildDependentsTask . setGroup (  \" Build   Dependents \"  )  ;", "buildDependentsTask . setDescription (  (  (  \" Assemble   dependents   of    \"     +     ( binary . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "buildDependentsTask . dependsOn ( binary )  ;", "}", "}  )  ;", "binary . getTasks (  )  . create ( namingScheme . getTaskName ( NativeComponents . BUILD _ DEPENDENTS _ TASK _ NAME )  ,    DefaultTask . class ,    new   Action < DefaultTask >  (  )     {", "@ Override", "public   void   execute ( DefaultTask   buildDependentsTask )     {", "buildDependentsTask . setGroup (  \" Build   Dependents \"  )  ;", "buildDependentsTask . setDescription (  (  (  \" Build   dependents   of    \"     +     ( binary . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "buildDependentsTask . dependsOn ( binary )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createBuildDependentBinariesTasks"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "for    ( final   VariantComponentSpec   component    :    components . withType ( NativeComponentSpec . class )  . withType ( VariantComponentSpec . class )  )     {", "tasks . create (  . getAssembleDependentComponentsTaskName ( component )  ,    DefaultTask . class ,    new   Action < DefaultTask >  (  )     {", "@ Override", "public   void   execute ( DefaultTask   assembleDependents )     {", "assembleDependents . setGroup (  \" Build   Dependents \"  )  ;", "assembleDependents . setDescription (  (  (  \" Assemble   dependents   of    \"     +     ( component . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "}", "}  )  ;", "tasks . create (  . getBuildDependentComponentsTaskName ( component )  ,    DefaultTask . class ,    new   Action < DefaultTask >  (  )     {", "@ Override", "public   void   execute ( DefaultTask   buildDependents )     {", "buildDependents . setGroup (  \" Build   Dependents \"  )  ;", "buildDependents . setDescription (  (  (  \" Build   dependents   of    \"     +     ( component . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["createBuildDependentComponentsTasks"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "String   taskName    =    binary . getNamingScheme (  )  . getTaskName (  \" link \"  )  ;", "binary . getTasks (  )  . create ( taskName ,    LinkExecutable . class ,    new   Action < LinkExecutable >  (  )     {", "@ Override", "public   void   execute ( LinkExecutable   linkTask )     {", "linkTask . setDescription (  (  \" Links    \"     +     ( binary . getDisplayName (  )  )  )  )  ;", "linkTask . getToolChain (  )  . set ( binary . getToolChain (  )  )  ;", "linkTask . getTargetPlatform (  )  . set ( binary . getTargetPlatform (  )  )  ;", "linkTask . getLinkedFile (  )  . set ( executableFile )  ;", "linkTask . getLinkerArgs (  )  . set ( binary . getLinker (  )  . getArgs (  )  )  ;", "linkTask . lib ( new    . BinaryLibs ( binary )     {", "@ Override", "protected   FileCollection   getFiles ( NativeDependencySet   nativeDependencySet )     {", "return   nativeDependencySet . getLinkFiles (  )  ;", "}", "}  )  ;", "binary . builtBy ( linkTask )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createExecutableTask"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "binary . getTasks (  )  . create ( namingScheme . getTaskName (  \" install \"  )  ,    InstallExecutable . class ,    new   Action < InstallExecutable >  (  )     {", "@ Override", "public   void   execute ( InstallExecutable   installTask )     {", "installTask . setDescription (  (  \" Installs   a   development   image   of    \"     +     ( binary . getDisplayName (  )  )  )  )  ;", "installTask . setGroup ( BUILD _ GROUP )  ;", "installTask . getToolChain (  )  . set ( executable . getToolChain (  )  )  ;", "installTask . getTargetPlatform (  )  . set ( binary . getTargetPlatform (  )  )  ;", "installTask . getExecutableFile (  )  . set ( executable . getFile (  )  )  ;", "installTask . getInstallDirectory (  )  . set ( installation . getDirectory (  )  )  ;", "installTask . lib ( new    . BinaryLibs ( binary )     {", "@ Override", "protected   FileCollection   getFiles ( NativeDependencySet   nativeDependencySet )     {", "return   nativeDependencySet . getRuntimeFiles (  )  ;", "}", "}  )  ;", "installTask . dependsOn ( binary )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createInstallTask"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "return    ( NativeComponents . ASSEMBLE _ DEPENDENTS _ TASK _ NAME )     +     ( StringUtils . capitalize ( component . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getAssembleDependentComponentsTaskName"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "return    ( NativeComponents . BUILD _ DEPENDENTS _ TASK _ NAME )     +     ( StringUtils . capitalize ( component . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildDependentComponentsTaskName"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "List < Task >    dependencies    =    Lists . newArrayList (  )  ;", "DependentBinariesResolvedResult   result    =    dependentsResolver . resolve ( binary )  . getRoot (  )  ;", "for    ( DependentBinariesResolvedResult   dependent    :    result . getChildren (  )  )     {", "if    ( dependent . isBuildable (  )  )     {", "ModelRegistry   modelRegistry    =    projectModelResolver . resolveProjectModel ( dependent . getId (  )  . getProjectPath (  )  )  ;", "ModelMap < NativeBinarySpecI   projectBinaries    =    modelRegistry . realize (  \" binaries \"  ,    ModelTypes . modelMap ( NativeBinarySpecIclass )  )  ;", "ModelMap < Task >    projectTasks    =    modelRegistry . realize (  \" tasks \"  ,    ModelTypes . modelMap ( Task . class )  )  ;", "NativeBinarySpecIdependentBinary    =    projectBinaries . get ( dependent . getProjectScopedName (  )  )  ;", "dependencies . add ( projectTasks . get ( dependentBinary . getNamingScheme (  )  . getTaskName ( dependedOnBinaryTaskName )  )  )  ;", "}", "}", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependentTaskDependencies"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "final   ModelMap < NativeBinarySpecInternal >    nativeBinaries    =    binaries . withType ( NativeBinarySpecInternal . class )  ;", "for    ( final   BinarySpecInternal   binary    :    nativeBinaries )     {", "Task   assembleDependents    =    tasks . get ( binary . getNamingScheme (  )  . getTaskName (  . ASSEMBLE _ DEPENDENTS _ TASK _ NAME )  )  ;", "Task   buildDependents    =    tasks . get ( binary . getNamingScheme (  )  . getTaskName (  . BUILD _ DEPENDENTS _ TASK _ NAME )  )  ;", "Task   assembleDependentComponents    =    tasks . get (  . getAssembleDependentComponentsTaskName ( binary . getComponent (  )  )  )  ;", "if    ( assembleDependentComponents    !  =    null )     {", "assembleDependentComponents . dependsOn ( assembleDependents )  ;", "}", "Task   buildDependentComponents    =    tasks . get (  . getBuildDependentComponentsTaskName ( binary . getComponent (  )  )  )  ;", "if    ( buildDependentComponents    !  =    null )     {", "buildDependentComponents . dependsOn ( buildDependents )  ;", "}", "assembleDependents . dependsOn ( new   Callable < Iterable < Task >  >  (  )     {", "@ Override", "public   Iterable < Task >    call (  )     {", "return    . getDependentTaskDependencies (  . ASSEMBLE _ DEPENDENTS _ TASK _ NAME ,    binary ,    dependentsResolver ,    projectModelResolver )  ;", "}", "}  )  ;", "buildDependents . dependsOn ( new   Callable < Iterable < Task >  >  (  )     {", "@ Override", "public   Iterable < Task >    call (  )     {", "return    . getDependentTaskDependencies (  . BUILD _ DEPENDENTS _ TASK _ NAME ,    binary ,    dependentsResolver ,    projectModelResolver )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["wireBuildDependentTasks"], "fileName": "org.gradle.nativeplatform.internal.NativeComponents"}, {"methodBody": ["METHOD_START", "{", "List < NativeBinarySpecInternal >    binaries    =    Lists . newArrayList (  )  ;", "for    ( VariantComponentSpec   nativeComponent    :    components )     {", "for    ( NativeBinarySpecInternal   nativeBinary    :    nativeComponent . ge (  )  . withType ( NativeBinarySpecInternal . class )  )     {", "binaries . add ( nativeBinary )  ;", "}", "}", "return   binaries ;", "}", "METHOD_END"], "methodName": ["allBinariesOf"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "Deque < NativeBinarySpecInternal >    stack    =    new   ArrayDeque < NativeBinarySpecInternal >  (  )  ;", "return   doBuildResolvedResult ( target ,    state ,    stack )  ;", "}", "METHOD_END"], "methodName": ["buildResolvedResult"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "NativeDependentBinariesResolutionStrategy . State   state    =    new   NativeDependentBinariesResolutionStrategy . State (  )  ;", "List < ProjectInternal >    orderedProjects    =    Ordering . usingToString (  )  . sortedCopy ( projectRegistry . getAllProjects (  )  )  ;", "for    ( ProjectInternal   project    :    orderedProjects )     {", "if    ( project . getPlugins (  )  . hasPlugin ( ComponentModelBasePlugin . class )  )     {", "ModelRegistry   modelRegistry    =    projectModelResolver . resolveProjectModel ( project . getPath (  )  )  ;", "ModelMap < NativeComponentSpec >    components    =    modelRegistry . realize (  \" components \"  ,    ModelTypes . modelMap ( NativeComponentSpec . class )  )  ;", "for    ( NativeBinarySpecInternal   binary    :    allBinariesOf ( components . withType ( VariantComponentSpec . class )  )  )     {", "state . registerBinary ( binary )  ;", "}", "ModelMap < Object >    testSuites    =    modelRegistry . find (  \" testSuites \"  ,    ModelTypes . modelMap ( Object . class )  )  ;", "if    ( testSuites    !  =    null )     {", "for    ( NativeBinarySpecInternal   binary    :    allBinariesOf ( testSuites . withType ( NativeComponentSpec . class )  . withType ( VariantComponentSpec . class )  )  )     {", "state . registerBinary ( binary )  ;", "}", "}", "}", "}", "for    ( NativeBinarySpecInternal   nativeBinary    :    state . dependencies . keySet (  )  )     {", "for    ( NativeLibraryBinary   libraryBinary    :    nativeBinary . getDependentBinaries (  )  )     {", "if    ( libraryBinary   instanceof   NativeBinarySpecInternal )     {", "state . dependencies . get ( nativeBinary )  . add (  (  ( NativeBinarySpecInternal )     ( libraryBinary )  )  )  ;", "}", "}", "if    (  ( testSupport )     !  =    null )     {", "state . dependencies . get ( nativeBinary )  . addAll ( testSupport . getTestDependencies ( nativeBinary )  )  ;", "}", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["buildState"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "if    ( stack . contains ( target )  )     {", "onCircularDependencies ( state ,    stack ,    target )  ;", "}", "List < vedResult >    result    =    resultsCache . getIfPresent ( target )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "stack . push ( target )  ;", "result    =    Lists . newArrayList (  )  ;", "List < NativeBinarySpecInternal >    dependents    =    state . getDependents ( target )  ;", "for    ( NativeBinarySpecInternal   dependent    :    dependents )     {", "List < vedResult >    children    =    doBuildResolvedResult ( dependent ,    state ,    stack )  ;", "result . add ( new   DefaultvedResult ( dependent . getId (  )  ,    dependent . getProjectScopedName (  )  ,    dependent . isBuildable (  )  ,    isTestSuite ( dependent )  ,    children )  )  ;", "}", "stack . pop (  )  ;", "resultsCache . put ( target ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["doBuildResolvedResult"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   stateCache . get (  \" state \"  ,    new   Callable <  . State >  (  )     {", "@ Override", "public    . State   call (  )     {", "return   buildState (  )  ;", "}", "}  )  ;", "}    catch    ( ExecutionException   ex )     {", "throw   new   RuntimeException (  \" Unable   to   build   native   dependent   binaries   resolution   cache \"  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "GraphNodeRenderer < NativeBinarySpecInternal >    nodeRenderer    =    new   GraphNodeRenderer < NativeBinarySpecInternal >  (  )     {", "@ Override", "public   void   renderTo ( NativeBinarySpecInternal   node ,    StyledTextOutput   output )     {", "String   name    =    ComponentsUtils . getBuildScopedTerseName ( node . getId (  )  )  ;", "output . withStyle ( Identifier )  . text ( name )  ;", "}", "}  ;", "DirectedGraph < NativeBinarySpecInternal ,    Object >    directedGraph    =    new   DirectedGraph < NativeBinarySpecInternal ,    Object >  (  )     {", "@ Override", "public   void   getNodeValues ( NativeBinarySpecInternal   node ,    Collection <  ?    super   Object >    values ,    Collection <  ?    super   NativeBinarySpecInternal >    connectedNodes )     {", "for    ( NativeBinarySpecInternal   binary    :    stack )     {", "if    ( state . gets ( node )  . contains ( binary )  )     {", "connectedNodes . add ( binary )  ;", "}", "}", "}", "}  ;", "DirectedGraphRenderer < NativeBinarySpecInternal >    graphRenderer    =    new   DirectedGraphRenderer < NativeBinarySpecInternal >  ( nodeRenderer ,    directedGraph )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "graphRenderer . renderTo ( target ,    writer )  ;", "throw   new   CircularReferenceException ( String . format (  \" Circular   dependency   between   the   following   binaries :  % n % s \"  ,    writer . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["onCircularDependencies"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "NativeDependentBinariesResolutionStrategy . State   state    =    getState (  )  ;", "return   buildResolvedResult ( target ,    state )  ;", "}", "METHOD_END"], "methodName": ["resolveDependentBinaries"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "this . testSupport    =    testSupport ;", "}", "METHOD_END"], "methodName": ["setTestSupport"], "fileName": "org.gradle.nativeplatform.internal.NativeDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "T   binary    =    BaseBinaryFixtures . create ( publicType ,    implType ,    name ,    componentNode ,    taskFactory )  ;", ". initialize ( binary ,    namingScheme ,    resolver ,    TestFiles . fileCollectionFactory (  )  ,    platform ,    buildType ,    flavor )  ;", "SourceComponentSpec   component    =    componentNode . asImmutable ( ModelType . of ( SourceComponentSpec . class )  ,    new   SimpleModelRuleDescriptor (  (  \" get   component   of    \"     +    name )  )  )  . getInstance (  )  ;", "binary . getInputs (  )  . addAll ( component . getSources (  )  . values (  )  )  ;", "return   binary ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.nativeplatform.internal.TestNativeBinariesFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( component   instanceof   NativeLibrarySpec )     {", ". createNativeBinary ( SharedLibraryBinarySpec . class ,    binaries ,    resolver ,    fileCollectionFactory ,    namingScheme . withBinaryType (  \" SharedLibrary \"  )  . withRole (  \" shared \"  ,    false )  ,    platform ,    buildType ,    flavor )  ;", ". createNativeBinary ( StaticLibraryBinarySpec . class ,    binaries ,    resolver ,    fileCollectionFactory ,    namingScheme . withBinaryType (  \" StaticLibrary \"  )  . withRole (  \" static \"  ,    false )  ,    platform ,    buildType ,    flavor )  ;", "} else    {", ". createNativeBinary ( NativeExecutableBinarySpec . class ,    binaries ,    resolver ,    fileCollectionFactory ,    namingScheme . withBinaryType (  \" Executable \"  )  . withRole (  \" executable \"  ,    true )  ,    platform ,    buildType ,    flavor )  ;", "}", "}", "METHOD_END"], "methodName": ["createNativeBinaries"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaries"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    namingScheme . getBinaryName (  )  ;", "binaries . create ( name ,    type )  ;", "MutableModelNode   backingNode    =     (  ( ManagedInstance )     ( binaries )  )  . getBackingNode (  )  ;", "ModelPath   binaryPath    =    backingNode . getPath (  )  . child ( name )  ;", "backingNode . applyToLink ( Defaults ,    DirectNodeNoInputsModelAction . of ( ModelReference . of ( binaryPath ,    NativeBinarySpec . class )  ,    new   SimpleModelRuleDescriptor (  (  \" initialize   binary    \"     +    binaryPath )  )  ,    new   BiAction < MutableModelNode ,    NativeBinarySpec >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   mutableModelNode ,    NativeBinarySpec   nativeBinarySpec )     {", ". initialize ( nativeBinarySpec ,    namingScheme ,    resolver ,    fileCollectionFactory ,    platform ,    buildType ,    flavor )  ;", "}", "}  )  )  ;", "binaries . named ( name ,    NativeBinaryRules . class )  ;", "}", "METHOD_END"], "methodName": ["createNativeBinary"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaries"}, {"methodBody": ["METHOD_START", "{", "NativeBinarySpecInternal   nativeBinary    =     (  ( NativeBinarySpecInternal )     ( nativeBinarySpec )  )  ;", "nativeBinary . setNamingScheme ( namingScheme )  ;", "nativeBinary . setTargetPlatform ( platform )  ;", "nativeBinary . setBuildType ( buildType )  ;", "nativeBinary . setFlavor ( flavor )  ;", "nativeBinary . setResolver ( resolver )  ;", "nativeBinary . setFileCollectionFactory ( fileCollectionFactory )  ;", "}", "METHOD_END"], "methodName": ["initialize"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaries"}, {"methodBody": ["METHOD_START", "{", "NativeBinarySpecInternal   nativeBinary    =     (  ( NativeBinarySpecInternal )     ( nativeBinarySpec )  )  ;", ". assignToolsToNativeBinary ( nativeBinary ,    nativeBinarySpec ,    toolChains )  ;", ". assignToolsToNativeBinaryExtension ( nativeBinary ,    buildDir )  ;", "}", "METHOD_END"], "methodName": ["assignTools"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "NativeBinaryRules . assignTools ( nativeBinarySpec ,    toolChains ,    projectLayout . getBuildDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["assignTools"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "NativeToolChainInternal   toolChain    =    NativeBinaryRules . toolChainFor ( nativeBinarySpec ,    toolChains )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select (  (  ( NativePlatformInternal )     ( nativeBinarySpec . getTargetPlatform (  )  )  )  )  ;", "nativeBinary . setToolChain ( toolChain )  ;", "nativeBinary . setPlatformToolProvider ( toolProvider )  ;", "}", "METHOD_END"], "methodName": ["assignToolsToNativeBinary"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "if    ( nativeBinary   instanceof   NativeExecutableBinarySpec )     {", "NativeBinaryRules . assignToolsToNativeExecutableBinary ( nativeBinary ,    buildDir )  ;", "} else", "if    ( nativeBinary   instanceof   SharedLibraryBinarySpec )     {", "NativeBinaryRules . assignToolsToSharedLibraryBinary ( nativeBinary ,    buildDir )  ;", "} else", "if    ( nativeBinary   instanceof   StaticLibraryBinarySpec )     {", "NativeBinaryRules . assignToolsToStaticLibraryBinary ( buildDir ,    nativeBinary )  ;", "}", "}", "METHOD_END"], "methodName": ["assignToolsToNativeBinaryExtension"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "NativeExecutableBinarySpec   nativeExecutable    =     (  ( NativeExecutableBinarySpec )     ( nativeBinary )  )  ;", "NativeExecutableFileSpec   executable    =    nativeExecutable . getExecutable (  )  ;", "executable . setFile (  . executableFileFor ( nativeBinary ,    buildDir )  )  ;", "executable . setToolChain ( nativeBinary . getToolChain (  )  )  ;", "nativeExecutable . getInstallation (  )  . setDirectory (  . installationDirFor ( nativeBinary ,    buildDir )  )  ;", "}", "METHOD_END"], "methodName": ["assignToolsToNativeExecutableBinary"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "SharedLibraryBinarySpec   sharedLibrary    =     (  ( SharedLibraryBinarySpec )     ( nativeBinary )  )  ;", "sharedLibrary . setSharedLibraryFile (  . sharedLibraryFileFor ( nativeBinary ,    buildDir )  )  ;", "sharedLibrary . setSharedLibraryLinkFile (  . sharedLibraryLinkFileFor ( nativeBinary ,    buildDir )  )  ;", "}", "METHOD_END"], "methodName": ["assignToolsToSharedLibraryBinary"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "StaticLibraryBinarySpec   staticLibrary    =     (  ( StaticLibraryBinarySpec )     ( nativeBinary )  )  ;", "staticLibrary . setStaticLibraryFile (  . staticLibraryFileFor ( nativeBinary ,    buildDir )  )  ;", "}", "METHOD_END"], "methodName": ["assignToolsToStaticLibraryBinary"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getComponent (  )  . getBaseName (  )  ;", "}", "METHOD_END"], "methodName": ["baseNameOf"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( nativeBinary . getNamingScheme (  )  . getOutputDirectory ( buildDir ,     \" exe \"  )  ,    NativeBinaryRules . executableNameFor ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["executableFileFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getPlatformToolProvider (  )  . getExecutableName ( NativeBinaryRules . baseNameOf ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["executableNameFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getNamingScheme (  )  . getOutputDirectory ( buildDir ,     \" install \"  )  ;", "}", "METHOD_END"], "methodName": ["installationDirFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( nativeBinary . getNamingScheme (  )  . getOutputDirectory ( buildDir ,     \" libs \"  )  ,    NativeBinaryRules . sharedLibraryNameFor ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["sharedLibraryFileFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( nativeBinary . getNamingScheme (  )  . getOutputDirectory ( buildDir ,     \" libs \"  )  ,    NativeBinaryRules . sharedLibraryLinkFileNameFor ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["sharedLibraryLinkFileFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getPlatformToolProvider (  )  . getSharedLibraryLinkFileName ( NativeBinaryRules . baseNameOf ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["sharedLibraryLinkFileNameFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getPlatformToolProvider (  )  . getSharedLibraryName ( NativeBinaryRules . baseNameOf ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["sharedLibraryNameFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( nativeBinary . getNamingScheme (  )  . getOutputDirectory ( buildDir ,     \" libs \"  )  ,    NativeBinaryRules . staticLibraryNameFor ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["staticLibraryFileFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return   nativeBinary . getPlatformToolProvider (  )  . getStaticLibraryName ( NativeBinaryRules . baseNameOf ( nativeBinary )  )  ;", "}", "METHOD_END"], "methodName": ["staticLibraryNameFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "return    (  ( NativeToolChainInternal )     ( toolChains . getForPlatform ( nativeBinary . getTargetPlatform (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toolChainFor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeBinaryRules"}, {"methodBody": ["METHOD_START", "{", "List < NativePlatform >    resolvedPlatforms    =    NativeComponentRules . resolvePlatforms ( nativeComponent ,    nativePlatforms ,    platforms )  ;", "for    ( NativePlatform   platform    :    resolvedPlatforms )     {", "BinaryNamingScheme   namingScheme    =    DefaultBinaryNamingScheme . component ( nativeComponent . getName (  )  )  ;", "namingScheme    =    namingScheme . withVariantDimension ( platform ,    resolvedPlatforms )  ;", "NativeComponentRules . executeForEachBuildType ( nativeComponent ,     (  ( NativePlatformInternal )     ( platform )  )  ,    namingScheme ,    buildTypes ,    flavors ,    nativeDependencyResolver ,    fileCollectionFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["createBinariesImpl"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeComponentRules"}, {"methodBody": ["METHOD_START", "{", "Set < BuildType >    targetBuildTypes    =    projectNativeComponent . chooseBuildTypes ( allBuildTypes )  ;", "for    ( BuildType   buildType    :    targetBuildTypes )     {", "BinaryNamingScheme   namingSchemeWithBuildType    =    namingScheme . withVariantDimension ( buildType ,    targetBuildTypes )  ;", ". executeForEachFlavor ( projectNativeComponent ,    platform ,    buildType ,    namingSchemeWithBuildType ,    allFlavors ,    nativeDependencyResolver ,    fileCollectionFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["executeForEachBuildType"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeComponentRules"}, {"methodBody": ["METHOD_START", "{", "Set < Flavor >    targetFlavors    =    projectNativeComponent . chooseFlavors ( allFlavors )  ;", "for    ( Flavor   flavor    :    targetFlavors )     {", "BinaryNamingScheme   namingSchemeWithFlavor    =    namingScheme . withVariantDimension ( flavor ,    targetFlavors )  ;", "NativeBinaries . createNativeBinaries ( projectNativeComponent ,    projectNativeComponent . getBinaries (  )  . withType ( NativeBinarySpec . class )  ,    nativeDependencyResolver ,    fileCollectionFactory ,    namingSchemeWithFlavor ,    platform ,    buildType ,    flavor )  ;", "}", "}", "METHOD_END"], "methodName": ["executeForEachFlavor"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeComponentRules"}, {"methodBody": ["METHOD_START", "{", "List < PlatformRequirement >    targetPlatforms    =    targetedComponent . getTargetPlatforms (  )  ;", "if    ( targetPlatforms . isEmpty (  )  )     {", "PlatformRequirement   requirement    =    DefaultPlatformRequirement . create ( nativePlatforms . getDefaultPlatformName (  )  )  ;", "targetPlatforms    =    Collections . singletonList ( requirement )  ;", "}", "return   CollectionUtils . collect ( targetPlatforms ,    new   api . Transformer < NativePlatform ,    PlatformRequirement >  (  )     {", "@ Override", "public   NativePlatform   transform ( PlatformRequirement   platformRequirement )     {", "return   platforms . resolve ( NativePlatform . class ,    platformRequirement )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["resolvePlatforms"], "fileName": "org.gradle.nativeplatform.internal.configure.NativeComponentRules"}, {"methodBody": ["METHOD_START", "{", "List < String >    lines    =    Lists . newArrayList (  (  (  \" module    \"     +    moduleName )     +     \"     {  \"  )  )  ;", "List < String >    validHeaderDirs    =    filter ( publicHeaderDirs ,    new   Spec < String >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( String   path )     {", "return   new   File ( path )  . exists (  )  ;", "}", "}  )  ;", "lines . addAll ( collect ( validHeaderDirs ,    new   Transformer < String ,    String >  (  )     {", "@ Override", "public   String   transform ( String   path )     {", "return    (  \"  \\ tumbrella    \\  \"  \"     +    path )     +     \"  \\  \"  \"  ;", "}", "}  )  )  ;", "lines . add (  \"  \\ texport    *  \"  )  ;", "lines . add (  \"  }  \"  )  ;", "try    {", "Files . createParentDirs ( m )  ;", "FileUtils . writeLines ( m ,    lines )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException (  (  \" Could   not   generate   a   module   map   for    \"     +    moduleName )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["generateFile"], "fileName": "org.gradle.nativeplatform.internal.modulemap.GenerateModuleMapFile"}, {"methodBody": ["METHOD_START", "{", "return   Hashing . md 5  (  )  . hashString (  (  ( moduleName )     +     ( CollectionUtils . join (  \"  \"  ,    publicHeaderPaths )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHashCode"], "fileName": "org.gradle.nativeplatform.internal.modulemap.ModuleMap"}, {"methodBody": ["METHOD_START", "{", "return   moduleName ;", "}", "METHOD_END"], "methodName": ["getModuleName"], "fileName": "org.gradle.nativeplatform.internal.modulemap.ModuleMap"}, {"methodBody": ["METHOD_START", "{", "return   publicHeaderPaths ;", "}", "METHOD_END"], "methodName": ["getPublicHeaderPaths"], "fileName": "org.gradle.nativeplatform.internal.modulemap.ModuleMap"}, {"methodBody": ["METHOD_START", "{", "return   fileCollectionFactory . create ( new   AbstractPrebuiltLibraryBinary . ValidatingFileSet ( file ,    fileCollectionDisplayName ,    fileDescription )  )  ;", "}", "METHOD_END"], "methodName": ["createFileCollection"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.AbstractPrebuiltLibraryBinary"}, {"methodBody": ["METHOD_START", "{", "return   library ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.AbstractPrebuiltLibraryBinary"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.AbstractPrebuiltLibraryBinary"}, {"methodBody": ["METHOD_START", "{", "for    ( PrebuiltLibraries   prebuiltLibraries    :    repositories )     {", "prebuiltLibrary    =    prebuiltLibraries . resolveLibrary ( libraryName )  ;", "if    ( prebuiltLibrary    !  =    null )     {", "return   prebuiltLibrary ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPrebuiltLibrary"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.PrebuiltLibraryBinaryLocator"}, {"methodBody": ["METHOD_START", "{", "createNativeBinary ( DefaultPrebuiltSharedLibraryBinary . class ,     \" shared \"  ,    library ,    platform ,    buildType ,    flavor ,    fileCollectionFactory )  ;", "createNativeBinary ( DefaultPrebuiltStaticLibraryBinary . class ,     \" static \"  ,    library ,    platform ,    buildType ,    flavor ,    fileCollectionFactory )  ;", "}", "METHOD_END"], "methodName": ["createNativeBinaries"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.PrebuiltLibraryInitializer"}, {"methodBody": ["METHOD_START", "{", "String   name    =    getName ( typeName ,    library ,    platform ,    buildType ,    flavor )  ;", "T   nativeBinary    =    instantiator . newInstance ( type ,    name ,    library ,    buildType ,    platform ,    flavor ,    fileCollectionFactory )  ;", "library . getBinaries (  )  . add ( nativeBinary )  ;", "}", "METHOD_END"], "methodName": ["createNativeBinary"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.PrebuiltLibraryInitializer"}, {"methodBody": ["METHOD_START", "{", "BinaryNamingScheme   namingScheme    =    DefaultBinaryNamingScheme . component ( library . getName (  )  )  . withBinaryType ( typeName )  . withVariantDimension ( platform . getName (  )  )  . withVariantDimension ( buildType . getName (  )  )  . withVariantDimension ( flavor . getName (  )  )  ;", "return   namingScheme . getBinaryName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.nativeplatform.internal.prebuilt.PrebuiltLibraryInitializer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resolution . getRequirement (  )  )     =  =    null )     {", "return   null ;", "}", "return   resolution . getRequirement (  )  . getLinkage (  )  ;", "}", "METHOD_END"], "methodName": ["getLinkage"], "fileName": "org.gradle.nativeplatform.internal.resolve.ApiRequirementNativeDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \"  '  % s '    in   project    '  % s '  \"  ,    context . getComponent (  )  . getName (  )  ,    context . getProjectPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["getContextMessage"], "fileName": "org.gradle.nativeplatform.internal.resolve.DefaultLibraryResolver"}, {"methodBody": ["METHOD_START", "{", "return    (  ( requirement . getProjectPath (  )  )     =  =    null )     |  |     ( requirement . getProjectPath (  )  . equals ( context . getProjectPath (  )  )  )     ?    String . format (  \" Could   not   locate   library    '  % s '    required   by    % s .  \"  ,    requirement . getLibraryName (  )  ,    getContextMessage (  )  )     :    String . format (  \" Could   not   locate   library    '  % s '    in   project    '  % s '    required   by    % s .  \"  ,    requirement . getLibraryName (  )  ,    requirement . getProjectPath (  )  ,    getContextMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFailureMessage"], "fileName": "org.gradle.nativeplatform.internal.resolve.DefaultLibraryResolver"}, {"methodBody": ["METHOD_START", "{", "DomainObjectSet < NativeLibraryBinary >    binaries    =    libraryBinaryLocator . getBinaries ( new   LibraryIdentifier ( requirement . getProjectPath (  )  ,    requirement . getLibraryName (  )  )  )  ;", "if    ( binaries    =  =    null )     {", "throw   new   LibraryResolveException ( getFailureMessage ( requirement )  )  ;", "}", "return   new    . LibraryResolution (  )  . withFlavor ( context . getFlavor (  )  )  . withPlatform ( context . getTargetPlatform (  )  )  . withBuildType ( context . getBuildType (  )  )  . resolveLibrary ( binaries )  ;", "}", "METHOD_END"], "methodName": ["resolveLibraryBinary"], "fileName": "org.gradle.nativeplatform.internal.resolve.DefaultLibraryResolver"}, {"methodBody": ["METHOD_START", "{", "return   libraryName ;", "}", "METHOD_END"], "methodName": ["getLibraryName"], "fileName": "org.gradle.nativeplatform.internal.resolve.LibraryIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   projectPath ;", "}", "METHOD_END"], "methodName": ["getProjectPath"], "fileName": "org.gradle.nativeplatform.internal.resolve.LibraryIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   input ;", "}", "METHOD_END"], "methodName": ["getInput"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   libraryBinary ;", "}", "METHOD_END"], "methodName": ["getLibraryBinary"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   nativeDependencySet ;", "}", "METHOD_END"], "methodName": ["getNativeDependencySet"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   requirement ;", "}", "METHOD_END"], "methodName": ["getRequirement"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "return    ( nativeDependencySet )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "this . libraryBinary    =    libraryBinary ;", "}", "METHOD_END"], "methodName": ["setLibraryBinary"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "this . nativeDependencySet    =    nativeDependencySet ;", "}", "METHOD_END"], "methodName": ["setNativeDependencySet"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "this . requirement    =    requirement ;", "}", "METHOD_END"], "methodName": ["setRequirement"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryRequirementResolveResult"}, {"methodBody": ["METHOD_START", "{", "List < NativeLibraryBinary >    result    =    new   ArrayList < NativeLibraryBinary >  (  )  ;", "for    ( quirementResolveResult   resolution    :    getAllResolutions (  )  )     {", "if    (  ( resolution . getLibraryBinary (  )  )     !  =    null )     {", "result . add ( resolution . getLibraryBinary (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllLibraryBinaries"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   resolutions ;", "}", "METHOD_END"], "methodName": ["getAllResolutions"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . collect ( getAllResolutions (  )  ,    new   Transformer < NativeDependencySet ,    NativeBinaryRequirementResolveResult >  (  )     {", "public   NativeDependencySet   transform ( NativeBinaryRequirementResolveResult   original )     {", "return   original . getNativeDependencySet (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getAllResults"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . filter ( resolutions ,    new   Spec < NativeBinaryRequirementResolveResult >  (  )     {", "public   boolean   isSatisfiedBy ( NativeBinaryRequirementResolveResult   element )     {", "return    !  ( element . isComplete (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getPendingResolutions"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeBinaryResolveResult"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( NativeLibraryRequirement . class )  . converter ( new   NativeDependencyNotationParser . LibraryConverter (  )  )  . converter ( new   NativeDependencyNotationParser . NativeLibraryRequirementMapNotationConverter (  )  )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeDependencyNotationParser"}, {"methodBody": ["METHOD_START", "{", "List < LibraryBinaryLocator >    locators    =    new   ArrayList < LibraryBinaryLocator >  (  )  ;", "locators . add ( new   ProjectLibraryBinaryLocator ( projectModel )  )  ;", "locators . add ( new   PrebuiltLibraryBinaryLocator ( projectModel )  )  ;", "return   new   CachingLibraryBinaryLocator ( new   ChainedLibraryBinaryLocator ( locators )  )  ;", "}", "METHOD_END"], "methodName": ["createLibraryBinaryLocator"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeDependencyResolverServices"}, {"methodBody": ["METHOD_START", "{", "NativeDependencyResolver   resolver    =    new   LibraryNativeDependencyResolver ( locator )  ;", "resolver    =    new   ApiRequirementNativeDependencyResolver ( resolver ,    fileCollectionFactory )  ;", "resolver    =    new   RequirementParsingNativeDependencyResolver ( resolver )  ;", "resolver    =    new   SourceSetNativeDependencyResolver ( resolver ,    fileCollectionFactory )  ;", "return   new   InputHandlingNativeDependencyResolver ( resolver )  ;", "}", "METHOD_END"], "methodName": ["createResolver"], "fileName": "org.gradle.nativeplatform.internal.resolve.NativeDependencyResolverServices"}, {"methodBody": ["METHOD_START", "{", "if    ( sourceSet   instanceof   HeaderExportingSourceSet )     {", "return   new    . LanguageSourceSetNativeDependencySet (  (  ( HeaderExportingSourceSet )     ( sourceSet )  )  ,    fileCollectionFactory )  ;", "}", "return   new    . EmptyNativeDependencySet (  )  ;", "}", "METHOD_END"], "methodName": ["createNativeDependencySet"], "fileName": "org.gradle.nativeplatform.internal.resolve.SourceSetNativeDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Architectures . KnownArchitecture   knownArchitecture    :    Architectures . KNOWN _ ARCHITECTURES )     {", "if    ( knownArchitecture . isAlias ( input . toLowerCase (  )  )  )     {", "return   new   DefaultArchitecture ( knownArchitecture . getCanonicalName (  )  )  ;", "}", "}", "return   new   DefaultArchitecture ( input )  ;", "}", "METHOD_END"], "methodName": ["forInput"], "fileName": "org.gradle.nativeplatform.platform.internal.Architectures"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultArchitecture ( architecture . canonicalName )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.nativeplatform.platform.internal.Architectures"}, {"methodBody": ["METHOD_START", "{", "String   architectureName ;", "try    {", "architectureName    =    Services . getInstance (  )  . get ( SystemInfo . class )  . getArchitectureName (  )  ;", "}    catch    ( IntegrationUnavailableException   e )     {", "architectureName    =    System . getProperty (  \" os . arch \"  )  ;", "}", "return   Architectures . forInput ( architectureName )  ;", "}", "METHOD_END"], "methodName": ["getCurrentArchitecture"], "fileName": "org.gradle.nativeplatform.platform.internal.DefaultNativePlatform"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultOperatingSystem ( System . getProperty (  \" os . name \"  )  ,    OperatingSystem . current (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentOperatingSystem"], "fileName": "org.gradle.nativeplatform.platform.internal.DefaultNativePlatform"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultNativePlatform . HostPlatform (  )  ;", "}", "METHOD_END"], "methodName": ["host"], "fileName": "org.gradle.nativeplatform.platform.internal.DefaultNativePlatform"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultNativePlatform ( name ,    operatingSystem ,    architecture )  ;", "}", "METHOD_END"], "methodName": ["withArchitecture"], "fileName": "org.gradle.nativeplatform.platform.internal.DefaultNativePlatform"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultNativePlatform ( NativePlatforms . platformName ( os . getName (  )  ,    arch . getName (  )  )  ,    os ,    arch )  ;", "}", "METHOD_END"], "methodName": ["createPlatform"], "fileName": "org.gradle.nativeplatform.platform.internal.NativePlatforms"}, {"methodBody": ["METHOD_START", "{", "Set < DefaultNativePlatform >    platforms    =    new   LinkedHashSet < DefaultNativePlatform >  (  )  ;", "OperatingSystemInternal   windows    =    new   DefaultOperatingSystem (  . OS _ WINDOWS )  ;", "OperatingSystemInternal   linux    =    new   DefaultOperatingSystem (  . OS _ LINUX )  ;", "OperatingSystemInternal   osx    =    new   DefaultOperatingSystem (  . OS _ OSX )  ;", "OperatingSystemInternal   unix    =    new   DefaultOperatingSystem (  . OS _ UNIX )  ;", "OperatingSystemInternal   freebsd    =    new   DefaultOperatingSystem (  \" freebsd \"  )  ;", "OperatingSystemInternal   solaris    =    new   DefaultOperatingSystem (  \" solaris \"  )  ;", "ArchitectureInternal   x 8  6     =    Architectures . forInput (  . ARCH _ X 8  6  )  ;", "ArchitectureInternal   x 6  4     =    Architectures . forInput (  \" x 8  6  _  6  4  \"  )  ;", "ArchitectureInternal   ia 6  4     =    Architectures . forInput (  \" ia 6  4  \"  )  ;", "ArchitectureInternal   armv 7     =    Architectures . forInput (  \" armv 7  \"  )  ;", "ArchitectureInternal   armv 8     =    Architectures . forInput (  \" armv 8  \"  )  ;", "ArchitectureInternal   sparc    =    Architectures . forInput (  \" sparc \"  )  ;", "ArchitectureInternal   ultrasparc    =    Architectures . forInput (  \" ultrasparc \"  )  ;", "ArchitectureInternal   ppc    =    Architectures . forInput (  \" ppc \"  )  ;", "ArchitectureInternal   ppc 6  4     =    Architectures . forInput (  \" ppc 6  4  \"  )  ;", "platforms . add (  . createPlatform ( windows ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( windows ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( windows ,    armv 7  )  )  ;", "platforms . add (  . createPlatform ( windows ,    ia 6  4  )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    armv 7  )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    armv 8  )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    ppc )  )  ;", "platforms . add (  . createPlatform ( freebsd ,    ppc 6  4  )  )  ;", "platforms . add (  . createPlatform ( unix ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( unix ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( unix ,    armv 7  )  )  ;", "platforms . add (  . createPlatform ( unix ,    armv 8  )  )  ;", "platforms . add (  . createPlatform ( unix ,    ppc )  )  ;", "platforms . add (  . createPlatform ( unix ,    ppc 6  4  )  )  ;", "platforms . add (  . createPlatform ( linux ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( linux ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( linux ,    armv 7  )  )  ;", "platforms . add (  . createPlatform ( linux ,    armv 8  )  )  ;", "platforms . add (  . createPlatform ( osx ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( osx ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( solaris ,    x 6  4  )  )  ;", "platforms . add (  . createPlatform ( solaris ,    x 8  6  )  )  ;", "platforms . add (  . createPlatform ( solaris ,    sparc )  )  ;", "platforms . add (  . createPlatform ( solaris ,    ultrasparc )  )  ;", "return   platforms ;", "}", "METHOD_END"], "methodName": ["defaultPlatformDefinitions"], "fileName": "org.gradle.nativeplatform.platform.internal.NativePlatforms"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   defaultPlatform    =    new   DefaultNativePlatform (  \" default \"  )  ;", "OperatingSystemInternal   os    =    defaultPlatform . getOperatingSystem (  )  ;", "ArchitectureInternal   architecture    =    defaultPlatform . getArchitecture (  )  ;", "if    ( os . isWindows (  )  )     {", "return    . platformName (  . OS _ WINDOWS ,     . ARCH _ X 8  6  )  ;", "}", "if    ( os . isLinux (  )  )     {", "return    . platformName (  . OS _ LINUX ,    architecture . getName (  )  )  ;", "}", "if    ( os . isMacOsX (  )  )     {", "return    . platformName (  . OS _ OSX ,    architecture . getName (  )  )  ;", "}", "return    . platformName (  . OS _ UNIX ,     . ARCH _ X 8  6  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultPlatformName"], "fileName": "org.gradle.nativeplatform.platform.internal.NativePlatforms"}, {"methodBody": ["METHOD_START", "{", "return    ( os    +     \"  _  \"  )     +    arch ;", "}", "METHOD_END"], "methodName": ["platformName"], "fileName": "org.gradle.nativeplatform.platform.internal.NativePlatforms"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "NativeToolChainInternal   toolChain    =    Cast . cast ( NativeToolChainInternal . class ,    getToolChain (  )  . get (  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "Class < LinkerSpec >    linkerSpecType    =     (  ( Class < LinkerSpec >  )     ( createLinkerSpec (  )  . getClass (  )  )  )  ;", "return   toolProvider . newCompiler ( linkerSpecType )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return    (  ( VersionAwareCompiler )     ( createCompiler (  )  )  )  . getVersion (  )  ;", "}", "METHOD_END"], "methodName": ["getCompilerVersion"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   debuggable ;", "}", "METHOD_END"], "methodName": ["getDebuggable"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   destinationDirectory ;", "}", "METHOD_END"], "methodName": ["getDestinationDirectory"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   libs ;", "}", "METHOD_END"], "methodName": ["getLibs"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   linkedFile ;", "}", "METHOD_END"], "methodName": ["getLinkedFile"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   linkerArgs ;", "}", "METHOD_END"], "methodName": ["getLinkerArgs"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationLoggerFactory"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "return   debuggable . get (  )  ;", "}", "METHOD_END"], "methodName": ["isDebuggable"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "this . libs . from ( libs )  ;", "}", "METHOD_END"], "methodName": ["lib"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "SimpleStaleClassCleaner   cleaner    =    new   SimpleStaleClassCleaner ( getOutputs (  )  )  ;", "cleaner . setDestinationDir ( getDestinationDirectory (  )  . get (  )  . getAsFile (  )  )  ;", "cleaner . execute (  )  ;", "if    ( getSource (  )  . isEmpty (  )  )     {", "setDidWork ( cleaner . getDidWork (  )  )  ;", "return ;", "}", "LinkerSpec   spec    =    createLinkerSpec (  )  ;", "spec . setTargetP ( getTargetP (  )  . get (  )  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setOutputFile ( getLinkedFile (  )  . get (  )  . getAsFile (  )  )  ;", "spec . objectFiles ( getSource (  )  )  ;", "spec . libraries ( getLibs (  )  )  ;", "spec . args ( getLinkerArgs (  )  . get (  )  )  ;", "spec . setDebuggable ( getDebuggable (  )  . get (  )  )  ;", "BuildOperationLogger   operationLogger    =    getOperationLoggerFactory (  )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "Compiler < LinkerSpec >    compiler    =    createCompiler (  )  ;", "compiler    =    BuildOperationLoggingCompilerDecorator . wrap ( compiler )  ;", "WorkResult   result    =    compiler . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["link"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "this . libs . setFrom ( libs )  ;", "}", "METHOD_END"], "methodName": ["setLibs"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "this . source . setFrom ( source )  ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "this . source . from ( source )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.nativeplatform.tasks.AbstractLinkTask"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "NativeToolChainInternal   toolChain    =    Cast . cast ( NativeToolChainInternal . class ,    getToolChain (  )  . get (  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "return   toolProvider . newCompiler ( ArchiverSpec . class )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   this . outputFile ;", "}", "METHOD_END"], "methodName": ["getBinaryFile"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOperationLoggerFactory"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   staticLibArgs ;", "}", "METHOD_END"], "methodName": ["getStaticLibArgs"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "StaticLibraryArchiverSpec   spec    =    new   DefaultStaticLibraryArchiverSpec (  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setOutputFile ( getOutputFile (  )  . get (  )  . getAsFile (  )  )  ;", "spec . objectFiles ( getSource (  )  )  ;", "spec . args ( getStaticLibArgs (  )  . get (  )  )  ;", "BuildOperationLogger   operationLogger    =    getOperationLoggerFactory (  )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "Compiler < StaticLibraryArchiverSpec >    compiler    =    createCompiler (  )  ;", "WorkResult   result    =    BuildOperationLoggingCompilerDecorator . wrap ( compiler )  . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["link"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "this . source . from ( source )  ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.nativeplatform.tasks.CreateStaticLibrary"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "NativeToolChainInternal   toolChain    =    Cast . cast ( NativeToolChainInternal . class ,    getToolChain (  )  . get (  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "return   toolProvider . newCompiler ( SymbolExtractorSpec . class )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "BuildOperationLogger   operationLogger    =    getServices (  )  . get ( BuildOperationLoggerFactory . class )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "SymbolorSpec   spec    =    new   DefaultSymbolorSpec (  )  ;", "spec . setBinaryFile ( binaryFile . get (  )  . getAsFile (  )  )  ;", "spec . setSymbolFile ( symbolFile . get (  )  . getAsFile (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "Compiler < SymbolorSpec >    symbolor    =    createCompiler (  )  ;", "symbolor    =    BuildOperationLoggingCompilerDecorator . wrap ( symbolor )  ;", "WorkResult   result    =    symbolor . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["extractSymbols"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "return   binaryFile ;", "}", "METHOD_END"], "methodName": ["getBinaryFile"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "return   symbolFile ;", "}", "METHOD_END"], "methodName": ["getSymbolFile"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.tasks.ExtractSymbols"}, {"methodBody": ["METHOD_START", "{", "return   executable ;", "}", "METHOD_END"], "methodName": ["getExecutableFile"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileOperations"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileSystem"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "RegularFileProperty   sourceFile    =    getExecutableFile (  )  ;", "if    (  ( sourceFile . isPresent (  )  )     &  &     ( sourceFile . get (  )  . getAsFile (  )  . exists (  )  )  )     {", "return   sourceFile . get (  )  . getAsFile (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getInputFileIfExists"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   installDirectory ;", "}", "METHOD_END"], "methodName": ["getInstallDirectory"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   installedExecutable ;", "}", "METHOD_END"], "methodName": ["getInstalledExecutable"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   getInstallDirectory (  )  . dir (  \" lib \"  )  ;", "}", "METHOD_END"], "methodName": ["getLibDirectory"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   libs ;", "}", "METHOD_END"], "methodName": ["getLibs"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   installDirectory . file ( executable . map ( new   Transformer < CharSequence ,    RegularFile >  (  )     {", "@ Override", "public   CharSequence   transform ( RegularFile   regularFile )     {", "OperatingSystem   operatingSystem    =    OperatingSystem . forName ( targetPlatform . get (  )  . getOperatingSystem (  )  . getName (  )  )  ;", "return   operatingSystem . getScriptName ( regularFile . getAsFile (  )  . getName (  )  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["getRunScriptFile"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "workerLeaseService . withoutProjectLock ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "if    ( targetPget (  )  . getOperatingSystem (  )  . isWindows (  )  )     {", "installWindows (  )  ;", "} else    {", "installUnix (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["install"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "getFileOperations (  )  . sync ( new   Action < CopySpec >  (  )     {", "public   void   execute ( CopySpec   copySpec )     {", "copySpec . into ( binaryDir )  ;", "copySpec . from ( getExecutableFile (  )  )  ;", "copySpec . from ( getLibs (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["installToDir"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "final   File   destination    =    getInstallDirectory (  )  . get (  )  . getAsFile (  )  ;", "final   File   executable    =    getFile (  )  . get (  )  . getAsFile (  )  ;", "installToDir ( new   File ( destination ,     \" lib \"  )  )  ;", "String   runScriptText    =     (  (  (  \"  #  !  / bin / sh \"     +     (  (  (  (  (  \"  \\ nAPP _ BASE _ NAME =  ` dirname    \\  \"  $  0  \\  \"  `  \"     +     \"  \\ nDYLD _ LIBRARY _ PATH =  \\  \"  $ APP _ BASE _ NAME / lib \\  \"  \"  )     +     \"  \\ nexport   DYLD _ LIBRARY _ PATH \"  )     +     \"  \\ nLD _ LIBRARY _ PATH =  \\  \"  $ APP _ BASE _ NAME / lib \\  \"  \"  )     +     \"  \\ nexport   LD _ LIBRARY _ PATH \"  )     +     \"  \\ nexec    \\  \"  $ APP _ BASE _ NAME / lib /  \"  )  )     +     ( executable . getName (  )  )  )     +     \"  \\  \"     \\  \"  $  @  \\  \"  \"  )     +     \"  \\ n \"  ;", "File   runScript    =    getRunScriptFile (  )  . get (  )  . getAsFile (  )  ;", "GFileUtils . writeFile ( runScriptText ,    runScript )  ;", "getFileSystem (  )  . chmod ( runScript ,     4  9  3  )  ;", "}", "METHOD_END"], "methodName": ["installUnix"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "final   File   executable    =    getExecutableFile (  )  . get (  )  . getAsFile (  )  ;", "installToDir ( getLibDirectory (  )  . get (  )  . getAsFile (  )  )  ;", "StringBuilder   toolChainPath    =    new   StringBuilder (  )  ;", "NativeToolChain   toolChain    =    getToolChain (  )  . get (  )  ;", "if    ( toolChain   instanceof   Gcc )     {", "toolChainPath . append (  \" SET   PATH =  \"  )  ;", "for    ( File   pathEntry    :     (  ( Gcc )     ( toolChain )  )  . getPath (  )  )     {", "toolChainPath . append ( pathEntry . getAbsolutePath (  )  )  . append (  \"  ;  \"  )  ;", "}", "toolChainPath . append (  \"  % PATH %  \"  )  ;", "}", "String   runScriptText    =     (  (  (  (  (  (  (  \"  \\ n @ echo   off \"     +     (  \"  \\ nSETLOCAL \"     +     \"  \\ n \"  )  )     +    toolChainPath )     +     \"  \\ nCALL    \\  \"  %  ~ dp 0 lib \\  \\  \"  )     +     ( executable . getName (  )  )  )     +     \"  \\  \"     %  *  \"  )     +     \"  \\ nEXIT    / B    % ERRORLEVEL %  \"  )     +     \"  \\ nENDLOCAL \"  )     +     \"  \\ n \"  ;", "GFileUtils . writeFile ( runScriptText ,    getRunScriptFile (  )  . get (  )  . getAsFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["installWindows"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "this . libs . from ( libs )  ;", "}", "METHOD_END"], "methodName": ["lib"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "this . libs . setFrom ( libs )  ;", "}", "METHOD_END"], "methodName": ["setLibs"], "fileName": "org.gradle.nativeplatform.tasks.InstallExecutable"}, {"methodBody": ["METHOD_START", "{", "return   importLibrary ;", "}", "METHOD_END"], "methodName": ["getImportLibrary"], "fileName": "org.gradle.nativeplatform.tasks.LinkSharedLibrary"}, {"methodBody": ["METHOD_START", "{", "return   installName ;", "}", "METHOD_END"], "methodName": ["getInstallName"], "fileName": "org.gradle.nativeplatform.tasks.LinkSharedLibrary"}, {"methodBody": ["METHOD_START", "{", "this . installName    =    installName ;", "}", "METHOD_END"], "methodName": ["setInstallName"], "fileName": "org.gradle.nativeplatform.tasks.LinkSharedLibrary"}, {"methodBody": ["METHOD_START", "{", "workerExecutor . submit ( PrefixHeaderFileGenerateTask . GeneratePrefixHeaderFile . class ,    new   Action < WorkerConfiguration >  (  )     {", "@ Override", "public   void   execute ( WorkerConfiguration   config )     {", "config . setIsolationMode ( NONE )  ;", "config . setParams ( header ,    prefixHeaderFile )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["generatePrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask"}, {"methodBody": ["METHOD_START", "{", "return   header ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask"}, {"methodBody": ["METHOD_START", "{", "return   prefixHeaderFile ;", "}", "METHOD_END"], "methodName": ["getPrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask"}, {"methodBody": ["METHOD_START", "{", "this . header    =    header ;", "}", "METHOD_END"], "methodName": ["setHeader"], "fileName": "org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask"}, {"methodBody": ["METHOD_START", "{", "this . prefixHeaderFile    =    prefixHeaderFile ;", "}", "METHOD_END"], "methodName": ["setPrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask"}, {"methodBody": ["METHOD_START", "{", "NativePlatformInternal   targetPlatform    =    Cast . cast ( NativePlatformInternal . class ,    this . targetPlatform . get (  )  )  ;", "NativeToolChainInternal   toolChain    =    Cast . cast ( NativeToolChainInternal . class ,    getToolChain (  )  . get (  )  )  ;", "PlatformToolProvider   toolProvider    =    toolChain . select ( targetPlatform )  ;", "return   toolProvider . newCompiler ( StripperSpec . class )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "return   binaryFile ;", "}", "METHOD_END"], "methodName": ["getBinaryFile"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "BuildOperationLogger   operationLogger    =    getServices (  )  . get ( BuildOperationLoggerFactory . class )  . newOperationLogger ( getName (  )  ,    getTemporaryDir (  )  )  ;", "perSpec   spec    =    new   DefaultperSpec (  )  ;", "spec . setBinaryFile ( binaryFile . get (  )  . getAsFile (  )  )  ;", "spec . setOutputFile ( outputFile . get (  )  . getAsFile (  )  )  ;", "spec . setOperationLogger ( operationLogger )  ;", "Compiler < perSpec >    symbolper    =    createCompiler (  )  ;", "symbolper    =    BuildOperationLoggingCompilerDecorator . wrap ( symbolper )  ;", "WorkResult   result    =    symbolper . execute ( spec )  ;", "setDidWork ( result . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["stripSymbols"], "fileName": "org.gradle.nativeplatform.tasks.StripSymbols"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    argsTransformer . transform ( spec )  ;", "Action < List < String >  >    userArgTransformer    =    invocationContext . getArgAction (  )  ;", "userArgTransformer . execute ( args )  ;", "if    ( useCommandFile )     {", "addOptionsFileArgs ( args ,    spec . getTempDir (  )  )  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractCompiler"}, {"methodBody": ["METHOD_START", "{", "return   invocationContext . createInvocation ( name ,    workingDirectory ,    args ,    operationLogger )  ;", "}", "METHOD_END"], "methodName": ["newInvocation"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractCompiler"}, {"methodBody": ["METHOD_START", "{", "return   invocationContext . createInvocation ( name ,    args ,    operationLogger )  ;", "}", "METHOD_END"], "methodName": ["newInvocation"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractCompiler"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Assembler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createAssembler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" C   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createCCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" C   pre - compiled   header   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createCPCHCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" C +  +    compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createCppCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" C +  +    pre - compiled   header   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createCppPCHCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Linker   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createLinker"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Objective - C   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createObjectiveCCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Objective - C   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createObjectiveCPCHCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Objective - C +  +    compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createObjectiveCppCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Objective - C +  +    pre - compiled   header   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createObjectiveCppPCHCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Static   library   archiver   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createStaticLibraryArchiver"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Stripper   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createStripper"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Symbol   extracter   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createSymbolExtractor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "throw   unavailableTool (  \" Windows   resource   compiler   is   not   available \"  )  ;", "}", "METHOD_END"], "methodName": ["createWindowsResourceCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   RuntimeException ( message )  ;", "}", "METHOD_END"], "methodName": ["unavailableTool"], "fileName": "org.gradle.nativeplatform.toolchain.internal.AbstractPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return    ( stdOutput . readAsString ( Charset . defaultCharset (  )  )  )     +     ( errOutput . readAsString ( Charset . defaultCharset (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["combineOutput"], "fileName": "org.gradle.nativeplatform.toolchain.internal.DefaultCommandLineToolInvocationWorker"}, {"methodBody": ["METHOD_START", "{", "configureActions . add ( action )  ;", "}", "METHOD_END"], "methodName": ["eachPlatform"], "fileName": "org.gradle.nativeplatform.toolchain.internal.ExtendableToolChain"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . resolve ( path )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.nativeplatform.toolchain.internal.ExtendableToolChain"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . concat ( genericArgs ,    pchArgs ,    sourceArgs ,    outputArgs )  ;", "}", "METHOD_END"], "methodName": ["buildPerFileArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "List < String >    sourceArgs    =    getSourceArgs ( sourceFile )  ;", "List < String >    outputArgs    =    getOutputArgs ( spec ,    getOutputFileDir ( sourceFile ,    objectDir ,    objectFileExtension )  )  ;", "List < String >    pchArgs    =    maybeGetPCHArgs ( spec ,    sourceFile )  ;", "return   newInvocation (  \" cing    \"  . concat ( sourceFile . getName (  )  )  ,    objectDir ,    buildPerFileArgs ( genericArgs ,    sourceArgs ,    outputArgs ,    pchArgs )  ,    spec . getOperationLogger (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPerFileInvocation"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "return    \" The   source   file    \"  . concat ( sourceFile . getName (  )  )  . concat (  \"    includes   the   header    \"  )  . concat ( pchHeader )  . concat (  \"    but   it   is   not   the   first   declared   header ,    so   the   pre - compiled   header   will   not   be   used .  \"  )  ;", "}", "METHOD_END"], "methodName": ["getCantUsePCHMessage"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "boolean   windowsPathLimitation    =    OperatingSystem . current (  )  . isWindows (  )  ;", "File   outputFile    =    cOutputFileNamingSchemeFactory . create (  )  . withObjectFileNameSuffix ( fileSuffix )  . withOutputBaseFolder ( objectFileDir )  . map ( sourceFile )  ;", "File   outputDirectory    =    outputFile . getParentFile (  )  ;", "if    (  !  ( outputDirectory . exists (  )  )  )     {", "outputDirectory . mkdirs (  )  ;", "}", "return   windowsPathLimitation    ?    FileUtils . assertInWindowsPathLengthLimitation ( outputFile )     :    outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFileDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( sourceFile . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSourceArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( spec . getPreCompiledHeader (  )  )     =  =    null )     {", "return   Lists . newArrayList (  )  ;", "}", "final   IncludeDirectives   includes    =    spec . getSourceFileIncludeDirectives (  )  . get ( sourceFile )  ;", "final   String   header    =    spec . getPreCompiledHeader (  )  ;", "List < Include >    headers    =    includes . getAll (  )  ;", "boolean   usePCH    =     (  !  ( headers . isEmpty (  )  )  )     &  &     ( header . equals ( headers . get (  0  )  . getValue (  )  )  )  ;", "if    ( usePCH )     {", "return   getPCHArgs ( spec )  ;", "} else    {", "boolean   containsHeader    =    CollectionUtils . any ( headers ,    new   Spec < Include >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( Include   include )     {", "return   include . getValue (  )  . equals ( header )  ;", "}", "}  )  ;", "if    ( containsHeader )     {", "logger . log ( WARN ,     . getCantUsePCHMessage ( spec . getPreCompiledHeader (  )  ,    sourceFile )  )  ;", "}", "return   Lists . newArrayList (  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeGetPCHArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "final   File   objectDir    =    spec . getObjectFileDir (  )  ;", "return   new   api . Action < internal . operations . BuildOperationQueue < CommandLineToolInvocation >  >  (  )     {", "@ Override", "public   void   execute ( internal . operations . BuildOperationQueue < CommandLineToolInvocation >    buildQueue )     {", "buildQueue . setLogLocation ( spec . getOperationLogger (  )  . getLogLocation (  )  )  ;", "for    ( File   sourceFile    :    spec . getSourceFiles (  )  )     {", "CommandLineToolInvocation   perFileInvocation    =    createPerFileInvocation ( genericArgs ,    sourceFile ,    objectDir ,    spec )  ;", "buildQueue . add ( perFileInvocation )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["newInvocationAction"], "fileName": "org.gradle.nativeplatform.toolchain.internal.NativeCompiler"}, {"methodBody": ["METHOD_START", "{", "return   originalArgs ;", "}", "METHOD_END"], "methodName": ["transformArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.OptionsFileArgsWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( spec . getSourceFiles (  )  . isEmpty (  )  )     {", "return   false ;", "}", "return   c . execute ( spec )  . getDidWork (  )  ;", "}", "METHOD_END"], "methodName": ["compileSources"], "fileName": "org.gradle.nativeplatform.toolchain.internal.OutputCleaningCompiler"}, {"methodBody": ["METHOD_START", "{", "boolean   didRemove    =    false ;", "for    ( File   removedSource    :    spec . getRemovedSourceFiles (  )  )     {", "File   objectFile    =    getObjectFile ( spec . getObjectFileDir (  )  ,    removedSource )  ;", "new   File ( objectFile . getParentFile (  )  ,     (  ( objectFile . getName (  )  )     +     \"  . pdb \"  )  )  . delete (  )  ;", "if    ( objectFile . delete (  )  )     {", "didRemove    =    true ;", "objectFile . getParentFile (  )  . delete (  )  ;", "}", "}", "return   didRemove ;", "}", "METHOD_END"], "methodName": ["deleteOutputsForRemovedSources"], "fileName": "org.gradle.nativeplatform.toolchain.internal.OutputCleaningCompiler"}, {"methodBody": ["METHOD_START", "{", "return   compilerOutputFileNamingSchemeFactory . create (  )  . withObjectFileNameSuffix ( outputFileSuffix )  . withOutputBaseFolder ( objectFileRoot )  . map ( sourceFile )  ;", "}", "METHOD_END"], "methodName": ["getObjectFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.OutputCleaningCompiler"}, {"methodBody": ["METHOD_START", "{", "File   generatedDir    =    new   File ( tempDir ,     \" preCompiledHeaders \"  )  ;", "generatedDir . mkdirs (  )  ;", "File   generatedHeader    =    new   File ( generatedDir ,    prefixHeaderFile . getName (  )  )  ;", "File   generatedPCH    =    new   File ( generatedDir ,    preCompiledHeaderObjectFile . getName (  )  )  ;", "try    {", "File . copyFile ( prefixHeaderFile ,    generatedHeader )  ;", "File . copyFile ( preCompiledHeaderObjectFile ,    generatedPCH )  ;", "return   generatedDir ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["generatePCHObjectDirectory"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PCHUtils"}, {"methodBody": ["METHOD_START", "{", "File   generatedSourceDir    =    new   File ( original . getTempDir (  )  ,     \" pchGenerated \"  )  ;", "generatedSourceDir . mkdirs (  )  ;", "File   generatedSource    =    new   File ( generatedSourceDir ,    FilenameUtils . removeExtension ( sourceFile . getName (  )  )  . concat (  . getSourceFileExtension ( original . getClass (  )  )  )  )  ;", "File   headerFileCopy    =    new   File ( generatedSourceDir ,    sourceFile . getName (  )  )  ;", "try    {", "FileUtils . copyFile ( sourceFile ,    headerFileCopy )  ;", "FileUtils . writeStringToFile ( generatedSource ,     \"  # include    \\  \"  \"  . concat ( headerFileCopy . getName (  )  )  . concat (  \"  \\  \"  \"  )  )  ;", "return   generatedSource ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["generatePCHSourceFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PCHUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( headerFile . getParentFile (  )  . exists (  )  )  )     {", "headerFile . getParentFile (  )  . mkdirs (  )  ;", "}", "try    {", "FileUtils . writeLines ( headerFile ,    CollectionUtils . collect ( headers ,    new   api . Transformer < String ,    String >  (  )     {", "@ Override", "public   String   transform ( String   header )     {", "if    ( header . startsWith (  \"  <  \"  )  )     {", "return    \"  # include    \"  . concat ( header )  ;", "} else    {", "return    \"  # include    \\  \"  \"  . concat ( header )  . concat (  \"  \\  \"  \"  )  ;", "}", "}", "}  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["generatePrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PCHUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < T ,    T >  (  )     {", "@ Override", "public   T   transform ( T   original )     {", "List < File >    newSourceFiles    =    Lists . newArrayList (  )  ;", "for    ( File   sourceFile    :    original . getSourceFiles (  )  )     {", "newSourceFiles . add ( PCHUtils . generatePCHSourceFile ( original ,    sourceFile )  )  ;", "}", "original . setSourceFiles ( newSourceFiles )  ;", "return   original ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getHeaderToSourceFileTransformer"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PCHUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( CPCHCompileSpec . class . isAssignableFrom ( specClass )  )     {", "return    \"  . c \"  ;", "}", "if    ( CppPCHCompileSpec . class . isAssignableFrom ( specClass )  )     {", "return    \"  . cpp \"  ;", "}", "throw   new   IllegalArgumentException (  \" Cannot   determine   source   file   extension   for   spec   with   type    \"  . concat ( specClass . getSimpleName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSourceFileExtension"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PCHUtils"}, {"methodBody": ["METHOD_START", "{", "return   includeString ;", "}", "METHOD_END"], "methodName": ["getIncludeString"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "return    ( pchObjects )     =  =    null    ?    null    :    pchObjects . getSingleFile (  )  ;", "}", "METHOD_END"], "methodName": ["getObjectFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "return   pchObjects ;", "}", "METHOD_END"], "methodName": ["getPchObjects"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "return   prefixHeaderFile ;", "}", "METHOD_END"], "methodName": ["getPrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "this . includeString    =    includeString ;", "}", "METHOD_END"], "methodName": ["setIncludeString"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "this . pchObjects    =    pchObjects ;", "}", "METHOD_END"], "methodName": ["setPchObjects"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "this . prefixHeaderFile    =    prefixHeaderFile ;", "}", "METHOD_END"], "methodName": ["setPrefixHeaderFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.PreCompiledHeader"}, {"methodBody": ["METHOD_START", "{", "if    ( SymbolExtractorOsConfig . OS . isMacOsX (  )  )     {", "return   SymbolExtractorOsConfig . DSYMUTIL ;", "} else    {", "return   SymbolExtractorOsConfig . OBJCOPY ;", "}", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.gradle.nativeplatform.toolchain.internal.SymbolExtractorOsConfig"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.nativeplatform.toolchain.internal.SymbolExtractorOsConfig"}, {"methodBody": ["METHOD_START", "{", "return   executable ;", "}", "METHOD_END"], "methodName": ["getExecutableName"], "fileName": "org.gradle.nativeplatform.toolchain.internal.SymbolExtractorOsConfig"}, {"methodBody": ["METHOD_START", "{", "return   extension ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.nativeplatform.toolchain.internal.SymbolExtractorOsConfig"}, {"methodBody": ["METHOD_START", "{", "return   Lists . newArrayList ( inputFilePath ,    outputFilePath )  ;", "}", "METHOD_END"], "methodName": ["getInputOutputFileArguments"], "fileName": "org.gradle.nativeplatform.toolchain.internal.SymbolExtractorOsConfig"}, {"methodBody": ["METHOD_START", "{", "return   toolName ;", "}", "METHOD_END"], "methodName": ["getToolName"], "fileName": "org.gradle.nativeplatform.toolchain.internal.ToolType"}, {"methodBody": ["METHOD_START", "{", "TreeFormatter   formatter    =    new   TreeFormatter (  )  ;", "this . explain ( formatter )  ;", "return   new   api . GradleException ( formatter . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["failure"], "fileName": "org.gradle.nativeplatform.toolchain.internal.UnavailablePlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . C _ COMPILER ,     \" gcc \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . CPP _ COMPILER ,     \" g +  +  \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . LINKER ,     \" g +  +  \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . STATIC _ LIB _ ARCHIVER ,     \" ar \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . OBJECTIVECPP _ COMPILER ,     \" g +  +  \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . OBJECTIVEC _ COMPILER ,     \" gcc \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . ASSEMBLER ,     \" gcc \"  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . SYMBOL _ EXTRACTOR ,    SymbolExtractorOsConfig . current (  )  . getExecutableName (  )  )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class ,    ToolType . STRIPPER ,     \" strip \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultTools"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "TargetPlatformConfiguration   targetPlatformConfigurationConfiguration    =    getPlatformConfiguration ( targetPlatform )  ;", "if    ( targetPlatformConfigurationConfiguration    =  =    null )     {", "return   new   UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem (  )  ,    String . format (  \" Don ' t   know   how   to   build   for    % s .  \"  ,    targetPlatform . getDisplayName (  )  )  )  ;", "}", "DefaultGccPlatformToolChain   configurableToolChain    =    instantiator . newInstance ( DefaultGccPlatformToolChain . class ,    targetPlatform )  ;", "addDefaultTools ( configurableToolChain )  ;", "configureDefaultTools ( configurableToolChain )  ;", "targetPlatformConfigurationConfiguration . apply ( configurableToolChain )  ;", "configureActions . execute ( configurableToolChain )  ;", "configurableToolChain . compilerProbeArgs ( standardLibraryDiscovery . compilerProbeArgs ( targetPlatform )  )  ;", "ToolChainAvailability   result    =    new   ToolChainAvailability (  )  ;", "initTools ( configurableToolChain ,    result )  ;", "if    (  !  ( result . isAvailable (  )  )  )     {", "return   new   UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem (  )  ,    result )  ;", "}", "return   new   GccPlatformToolProvider ( targetPlatform ,    buildOperationExecutor ,    targetPlatform . getOperatingSystem (  )  ,    toolSearchPath ,    configurableToolChain ,    execActionFactory ,    compilerOutputFileNamingSchemeFactory ,    configurableToolChain . isCanUseCommandFile (  )  ,    workerLeaseService ,    new    . CompilerMetaDataProviderWithDefaultArgs ( configurableToolChain . getCompilerProbeArgs (  )  ,    metaDataProvider )  ,    standardLibraryDiscovery )  ;", "}", "METHOD_END"], "methodName": ["createPlatformToolProvider"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "return   metaDataProvider ;", "}", "METHOD_END"], "methodName": ["getMetaDataProvider"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "for    ( TargetPlatformConfiguration   platformConfig    :    platformConfigs )     {", "if    ( platformConfig . supportsPlatform ( targetPlatform )  )     {", "return   platformConfig ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPlatformConfiguration"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "PlatformToolProvider   toolProvider    =    toolProviders . get ( targetPlatform )  ;", "if    ( toolProvider    =  =    null )     {", "toolProvider    =    createPlatformToolProvider ( targetPlatform )  ;", "toolProviders . put ( targetPlatform ,    toolProvider )  ;", "}", "return   toolProvider ;", "}", "METHOD_END"], "methodName": ["getProviderForPlatform"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "for    ( GccCommandLineToolConfigurationInternal   tool    :    platformToolChain . getCompilers (  )  )     {", "CommandLineToolSearchResult   compiler    =    locate ( tool )  ;", "if    ( compiler . isAvailable (  )  )     {", "SearchResult < GccMetadata >    gccMetadata    =    getMetaDataProvider (  )  . getCompilerMetaData ( compiler . getTool (  )  ,    platformToolChain . getCompilerProbeArgs (  )  )  ;", "availability . mustBeAvailable ( gccMetadata )  ;", "if    (  !  ( gccMetadata . isAvailable (  )  )  )     {", "return ;", "}", ". LOGGER . debug (  \" Found    {  }    with   version    {  }  \"  ,    tool . getToolType (  )  . getToolName (  )  ,    gccMetadata )  ;", "initForImplementation ( platformToolChain ,    gccMetadata . getComponent (  )  )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["initTools"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "return   toolSearchPath . locate ( tool . getToolType (  )  ,    tool . getExecutable (  )  )  ;", "}", "METHOD_END"], "methodName": ["locate"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "target ( new   AbstractGccCompatibleToolChain . DefaultTargetPlatformConfiguration ( platformNames ,    action )  )  ;", "}", "METHOD_END"], "methodName": ["target"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "platformConfigs . add ( configInsertLocation ,    targetPlatformConfiguration )  ;", "( configInsertLocation )  +  +  ;", "}", "METHOD_END"], "methodName": ["target"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.AbstractGccCompatibleToolChain"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( spec . getOutputFile (  )  . isFile (  )  )  )     {", "return ;", "}", "if    (  !  ( spec . getOutputFile (  )  . delete (  )  )  )     {", "throw   new   GradleException (  \" Create   static   a   failed :    could   not   delete   previous   a \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["deletePreviousOutput"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.ArStaticLibraryArchiver"}, {"methodBody": ["METHOD_START", "{", "tools . put ( tool . getToolType (  )  ,    tool )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "this . compilerProbeArgs . addAll ( Arrays . asList ( args )  )  ;", "}", "METHOD_END"], "methodName": ["compilerProbeArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   compilerProbeArgs ;", "}", "METHOD_END"], "methodName": ["getCompilerProbeArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( tools . get ( ToolType . C _ COMPILER )  ,    tools . get ( ToolType . CPP _ COMPILER )  ,    tools . get ( ToolType . OBJECTIVEC _ COMPILER )  ,    tools . get ( ToolType . OBJECTIVECPP _ COMPILER )  )  ;", "}", "METHOD_END"], "methodName": ["getCompilers"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   tools . get ( ToolType . STRIPPER )  ;", "}", "METHOD_END"], "methodName": ["getStripper"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   tools . get ( ToolType . SYMBOL _ EXTRACTOR )  ;", "}", "METHOD_END"], "methodName": ["getSymbolExtractor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   tools . values (  )  ;", "}", "METHOD_END"], "methodName": ["getTools"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "return   canUseCommandFile ;", "}", "METHOD_END"], "methodName": ["isCanUseCommandFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "this . canUseCommandFile    =    canUseCommandFile ;", "}", "METHOD_END"], "methodName": ["setCanUseCommandFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.DefaultGccPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    spec . getIncludeRoots (  )  )     {", "args . add (  \"  - I \"  )  ;", "args . add ( file . getAbsolutePath (  )  )  ;", "}", "for    ( File   file    :    spec . getSystemIncludeRoots (  )  )     {", "args . add (  \"  - isystem \"  )  ;", "args . add ( file . getAbsolutePath (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addIncludeArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "for    ( String   macroArg    :    new   MacroArgsConverter (  )  . transform ( spec . getMacros (  )  )  )     {", "args . add (  (  \"  - D \"     +    macroArg )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addMacroArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "Collections . addAll ( args ,     \"  - x \"  ,    getLanguage (  )  )  ;", "args . add (  \"  - c \"  )  ;", "if    ( spec . isPositionIndependentCode (  )  )     {", "if    (  !  ( spec . getTargetP (  )  . getOperatingSystem (  )  . isWindows (  )  )  )     {", "args . add (  \"  - fPIC \"  )  ;", "}", "}", "if    ( spec . isDebuggable (  )  )     {", "args . add (  \"  - g \"  )  ;", "}", "if    ( spec . isOptimized (  )  )     {", "args . add (  \"  - O 3  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["addToolSpecificArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "args . addAll ( spec . getAllArgs (  )  )  ;", "}", "METHOD_END"], "methodName": ["addUserArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "List < String >    commandLineOnlyArgs    =    new   ArrayList < String >  ( allArgs )  ;", "commandLineOnlyArgs . retainAll (  . CLI _ ONLY _ ARGS )  ;", "return   commandLineOnlyArgs ;", "}", "METHOD_END"], "methodName": ["getCommandLineOnlyArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccOptionsFileArgsWriter"}, {"methodBody": ["METHOD_START", "{", "ToolType   key    =    tool . getToolType (  )  ;", "String   exeName    =    tool . getExecutable (  )  ;", "return   new   DefaultCommandLineToolInvocationWorker ( key . getToolName (  )  ,    toolSearchPath . locate ( key ,    exeName )  . getTool (  )  ,    execActionFactory )  ;", "}", "METHOD_END"], "methodName": ["commandLineTool"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "MutableCommandLineToolContext   baseInvocation    =    new   DefaultMutableCommandLineToolContext (  )  ;", "baseInvocation . addPath ( toolSearchPath . getPath (  )  )  ;", "baseInvocation . addEnvironmentVar (  \" CYGWIN \"  ,     \" nodosfilewarning \"  )  ;", "baseInvocation . setArgAction ( toolConfiguration . getArgAction (  )  )  ;", "return   baseInvocation ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "GccCommandLineToolConfigurationInternal   compiler    =    toolRegistry . getTool ( compilerType )  ;", "if    ( compiler    =  =    null )     {", "return   new   ComponentNotFound < metadata . GccMetadata >  (  (  (  \" Tool    \"     +     ( compilerType . getToolName (  )  )  )     +     \"    is   not   available \"  )  )  ;", "}", "CommandLineToolSearchResult   searchResult    =    toolSearchPath . locate ( compiler . getToolType (  )  ,    compiler . getExecutable (  )  )  ;", "String   language    =    GccPlatformToolProvider . LANGUAGE _ FOR _ COMPILER . get ( compilerType )  ;", "List < String >    languageArgs    =     ( language    =  =    null )     ?    Collections .  < String > emptyList (  )     :    ImmutableList . of (  \"  - x \"  ,    language )  ;", "return   metadataProvider . getCompilerMetaData ( searchResult . getTool (  )  ,    languageArgs )  ;", "}", "METHOD_END"], "methodName": ["getGccMetadata"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return    \"  . h . gch \"  ;", "}", "METHOD_END"], "methodName": ["getPCHFileExtension"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "SearchResult < GccMetadata >    gccMetadata    =    getGccMetadata ( toolType )  ;", "return   new   language . base . internal . compile . VersionAwareCompiler < T >  ( compiler ,    new   language . base . internal . compile . DefaultCompilerVersion ( metadataProvider . getCompilerType (  )  . getIdentifier (  )  ,    gccMetadata . getComponent (  )  . getVendor (  )  ,    gccMetadata . getComponent (  )  . getVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["versionAwareCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.GccPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccCompilerType"}, {"methodBody": ["METHOD_START", "{", "return   identifier ;", "}", "METHOD_END"], "methodName": ["getIdentifier"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccCompilerType"}, {"methodBody": ["METHOD_START", "{", "boolean   i 3  8  6     =    defines . containsKey (  \"  _  _ i 3  8  6  _  _  \"  )  ;", "boolean   amd 6  4     =    defines . containsKey (  \"  _  _ amd 6  4  _  _  \"  )  ;", "final   ArchitectureInternal   architecture ;", "if    ( i 3  8  6  )     {", "architecture    =    Architectures . forInput (  \" i 3  8  6  \"  )  ;", "} else", "if    ( amd 6  4  )     {", "architecture    =    Architectures . forInput (  \" amd 6  4  \"  )  ;", "} else    {", "architecture    =    platform . internal . DefaultNativePlatform . getCurrentArchitecture (  )  ;", "}", "return   architecture ;", "}", "METHOD_END"], "methodName": ["determineArchitecture"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "BufferedReader   reader    =    new   BufferedReader ( new   StringReader ( error )  )  ;", "String   line ;", "ImmutableList . Builder < File >    builder    =    ImmutableList . builder (  )  ;", "boolean   systemIncludesStarted    =    false ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "if    (  . SYSTEM _ INCLUDES _ END . equals ( line )  )     {", "break ;", "}", "if    (  . SYSTEM _ INCLUDES _ START . equals ( line )  )     {", "systemIncludesStarted    =    true ;", "continue ;", "}", "if    ( systemIncludesStarted )     {", "if    (  (  ( compilerType )     =  =     ( GccCompilerType . CLANG )  )     &  &     ( line . contains (  . FRAMEWORK _ INCLUDE )  )  )     {", "continue ;", "}", "if    (  (  ( compilerType )     =  =     ( GccCompilerType . GCC )  )     &  &     ( line . endsWith (  \"  / Library / Frameworks \"  )  )  )     {", "continue ;", "}", "builder . add ( new   File ( line . trim (  )  )  )  ;", "}", "}", "return   builder . build (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["determineSystemIncludes"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "BufferedReader   reader    =    new   BufferedReader ( new   StringReader ( error )  )  ;", "String   majorMinorOnly    =     (  ( versionNumber . getMajor (  )  )     +     \"  .  \"  )     +     ( versionNumber . getMinor (  )  )  ;", "String   line ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "if    (  (  (  ( line . contains ( majorMinorOnly )  )     &  &     ( line . contains (  \"    version    \"  )  )  )     &  &     ( line . contains ( compilerType . getIdentifier (  )  )  )  )     &  &     (  !  ( line . contains (  \"    default   target    \"  )  )  )  )     {", "return   line ;", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "throw   new   Abstract . BrokenResultException ( String . format (  \" Could   not   determine    % s   metadata :    could   not   find   vendor   in   output   of    % s .  \"  ,    compilerType . getDescription (  )  ,    gccBinary )  )  ;", "}", "METHOD_END"], "methodName": ["determineVendor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "int   major ;", "int   minor ;", "int   patch ;", "switch    ( compilerType )     {", "case   CLANG    :", "if    (  !  ( defines . containsKey (  \"  _  _ clang _  _  \"  )  )  )     {", "throw   new   Abstract . BrokenResultException ( String . format (  \"  % s   appears   to   be   GCC   rather   than   Clang .    Treating   it   as   GCC .  \"  ,    gccBinary . getName (  )  )  )  ;", "}", "major    =    toInt ( defines . get (  \"  _  _ clang _ major _  _  \"  )  )  ;", "minor    =    toInt ( defines . get (  \"  _  _ clang _ minor _  _  \"  )  )  ;", "patch    =    toInt ( defines . get (  \"  _  _ clang _ patchlevel _  _  \"  )  )  ;", "break ;", "case   GCC    :", "if    ( defines . containsKey (  \"  _  _ clang _  _  \"  )  )     {", "throw   new   Abstract . BrokenResultException ( String . format (  \" XCode    % s   is   a   wrapper   around   Clang .    Treating   it   as   Clang   and   not   GCC .  \"  ,    gccBinary . getName (  )  )  )  ;", "}", "major    =    toInt ( defines . get (  \"  _  _ GNUC _  _  \"  )  )  ;", "minor    =    toInt ( defines . get (  \"  _  _ GNUC _ MINOR _  _  \"  )  )  ;", "patch    =    toInt ( defines . get (  \"  _  _ GNUC _ PATCHLEVEL _  _  \"  )  )  ;", "break ;", "default    :", "throw   new   GradleException (  (  \" Unknown   compiler   type    \"     +     ( compilerType )  )  )  ;", "}", "return   new   VersionNumber ( major ,    minor ,    patch ,    null )  ;", "}", "METHOD_END"], "methodName": ["determineVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   GccMetadataProvider ( execActionFactory ,    GccCompilerType . CLANG )  ;", "}", "METHOD_END"], "methodName": ["forClang"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   GccMetadataProvider ( execActionFactory ,    GccCompilerType . GCC )  ;", "}", "METHOD_END"], "methodName": ["forGcc"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "BufferedReader   reader    =    new   BufferedReader ( new   StringReader ( output )  )  ;", "String   line ;", "Map < String ,    String >    defines    =    new   HashMap < String ,    String >  (  )  ;", "try    {", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "Matcher   matcher    =     . DEFINE _ PATTERN . matcher ( line )  ;", "if    (  !  ( matcher . matches (  )  )  )     {", "throw   new   AbstractMetadataProvider . BrokenResultException ( String . format (  \" Could   not   determine    % s   metadata :     % s   produced   unexpected   output .  \"  ,    compilerType . getDescription (  )  ,    gccBinary . getName (  )  )  )  ;", "}", "defines . put ( matcher . group (  1  )  ,    matcher . group (  2  )  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "if    (  (  !  ( defines . containsKey (  \"  _  _ GNUC _  _  \"  )  )  )     &  &     (  !  ( defines . containsKey (  \"  _  _ clang _  _  \"  )  )  )  )     {", "throw   new   AbstractMetadataProvider . BrokenResultException ( String . format (  \" Could   not   determine    % s   metadata :     % s   produced   unexpected   output .  \"  ,    compilerType . getDescription (  )  ,    gccBinary . getName (  )  )  )  ;", "}", "return   defines ;", "}", "METHOD_END"], "methodName": ["parseDefines"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return    0  ;", "}", "try    {", "return   Iger . parseInt ( value )  ;", "}    catch    ( NumberFormatException   e )     {", "return    0  ;", "}", "}", "METHOD_END"], "methodName": ["toInt"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.GccMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target . getOperatingSystem (  )  . isMacOsX (  )  )  )     {", "return   new   String [  0  ]  ;", "}", "File   sdkDir    =    macOSSdkPathLocator . find (  )  ;", "return   new   String [  ]  {     \"  - isysroot \"  ,    sdkDir . getAbsolutePath (  )     }  ;", "}", "METHOD_END"], "methodName": ["compilerProbeArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.gcc.metadata.SystemLibraryDiscovery"}, {"methodBody": ["METHOD_START", "{", "ExecAction   exec    =    execActionFactory . newExecAction (  )  ;", "exec . executable ( gccBinary . getAbsolutePath (  )  )  ;", "exec . setWorkingDir ( gccBinary . getParentFile (  )  )  ;", "exec . args ( args )  ;", "StreamByteBuffer   buffer    =    new   StreamByteBuffer (  )  ;", "StreamByteBuffer   errorBuffer    =    new   StreamByteBuffer (  )  ;", "exec . setStandardOutput ( buffer . getOutputStream (  )  )  ;", "exec . setErrorOutput ( errorBuffer . getOutputStream (  )  )  ;", "exec . setIgnoreExitValue ( true )  ;", "ExecResult   result    =    exec . execute (  )  ;", "int   exitValue    =    result . getExitValue (  )  ;", "if    ( exitValue    =  =     0  )     {", "return   Pair . of ( buffer . readAsString (  )  ,    errorBuffer . readAsString (  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["runCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.metadata.AbstractMetadataProvider"}, {"methodBody": ["METHOD_START", "{", "return   clang ;", "}", "METHOD_END"], "methodName": ["clang"], "fileName": "org.gradle.nativeplatform.toolchain.internal.metadata.CompilerMetaDataProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   gcc ;", "}", "METHOD_END"], "methodName": ["gcc"], "fileName": "org.gradle.nativeplatform.toolchain.internal.metadata.CompilerMetaDataProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   swiftc ;", "}", "METHOD_END"], "methodName": ["swiftc"], "fileName": "org.gradle.nativeplatform.toolchain.internal.metadata.CompilerMetaDataProviderFactory"}, {"methodBody": ["METHOD_START", "{", "Set < T >    found    =    new   LinkedHashSet < T >  (  )  ;", "String [  ]    versionDirs    =    getComponentVersionDirs ( windowsKitDir )  ;", "for    ( String   versionDir    :    versionDirs )     {", "VersionNumber   version    =    VersionNumber . withPatchNumber (  )  . parse ( versionDir )  ;", ". LOGGER . debug (  \" Found    {  }     {  }    at    {  }  \"  ,    getDisplayName (  )  ,    version . toString (  )  ,    windowsKitDir )  ;", "File   binDir    =    new   File ( windowsKitDir ,     (  \" bin /  \"     +    versionDir )  )  ;", "File   unversionedBinDir    =    new   File ( windowsKitDir ,     \" bin \"  )  ;", "if    ( isValidComponentBinDir ( binDir )  )     {", "T   component    =    newComponent ( windowsKitDir ,    binDir ,    version ,    discoveryType )  ;", "found . add ( component )  ;", "} else", "if    ( isValidComponentBinDir ( unversionedBinDir )  )     {", "T   component    =    newComponent ( windowsKitDir ,    unversionedBinDir ,    version ,    discoveryType )  ;", "found . add ( component )  ;", "}", "}", "if    ( found . isEmpty (  )  )     {", ". LOGGER . debug (  \" Ignoring   candidate   directory    {  }    as   it   does   not   look   like   a    {  }    installation .  \"  ,    windowsKitDir ,    getDisplayName (  )  )  ;", "}", "return   found ;", "}", "METHOD_END"], "methodName": ["findIn"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "final   SortedSet < T >    candidates    =    new   TreeSet < T >  ( new   DescendingComponentVersionComparator (  )  )  ;", "candidates . addAll ( foundComponents . values (  )  )  ;", "return   candidates . isEmpty (  )     ?    null    :    candidates . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["getBestComponent"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "File   includeDir    =    new   File ( candidate ,     \" Include \"  )  ;", "File   libDir    =    new   File ( candidate ,     \" Lib \"  )  ;", "if    (  (  !  ( includeDir . isDirectory (  )  )  )     |  |     (  !  ( libDir . isDirectory (  )  )  )  )     {", "return   new   String [  0  ]  ;", "}", "Map < String ,    File >    includeDirs    =    new   HashMap < String ,    File >  (  )  ;", "for    ( File   dir    :    includeDir . listFiles ( windowsKitVersionFilter )  )     {", "includeDirs . put ( dir . getName (  )  ,    dir )  ;", "}", "Map < String ,    File >    libDirs    =    new   HashMap < String ,    File >  (  )  ;", "for    ( File   dir    :    libDir . listFiles ( windowsKitVersionFilter )  )     {", "libDirs . put ( dir . getName (  )  ,    dir )  ;", "}", "Set < String >    kitVersions    =    new   HashSet < String >  (  )  ;", "kitVersions . addAll ( includeDirs . keySet (  )  )  ;", "kitVersions . addAll ( libDirs . keySet (  )  )  ;", "List < String >    result    =    new   ArrayList < String >  (  )  ;", "for    ( String   version    :    kitVersions )     {", "File   inc    =    includeDirs . get ( version )  ;", "File   lib    =    libDirs . get ( version )  ;", "if    (  ( inc    !  =    null )     &  &     ( lib    !  =    null )  )     {", "File   componentInc    =    new   File ( inc ,    geName (  )  )  ;", "File   componentLib    =    new   File ( lib ,    geName (  )  )  ;", "if    (  ( isValidComponentIncludeDir ( componentInc )  )     &  &     ( isValidComponentLibDir ( componentLib )  )  )     {", "result . add ( version )  ;", "}", "}", "}", "return   result . toArray ( new   String [ result . size (  )  ]  )  ;", "}", "METHOD_END"], "methodName": ["getComponentVersionDirs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "switch    ( discoveryType )     {", "case   USER    :", "return    (  (  (  (  . USER _ PROVIDED )     +     \"     \"  )     +     ( getDisplayName (  )  )  )     +     \"     \"  )     +     ( version . getMajor (  )  )  ;", "case   REGISTRY    :", "return    (  ( getDisplayName (  )  )     +     \"     \"  )     +     ( version . getMajor (  )  )  ;", "default    :", "throw   new   IllegalArgumentException (  (  (  (  \" Unknown   discovery   method   for    \"     +     ( getDisplayName (  )  )  )     +     \"  :     \"  )     +    discoveryType )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getVersionedDisplayName"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialised )  )     {", "locatesInRegistry (  )  ;", "initialised    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initializeComponents"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "for    ( String   baseKey    :    AbstractWindowsKitComponentLocator . REGISTRY _ BASEPATHS )     {", "locateComponentsInRegistry ( baseKey )  ;", "}", "}", "METHOD_END"], "methodName": ["locateComponentsInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "try    {", "File   windowsKitDir    =    FileUtils . canonicalize ( new   File ( windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,     ( baseKey    +     (  . REGISTRY _ ROOTPATH _ KIT )  )  ,     . REGISTRY _ KIT _  1  0  )  )  )  ;", "Set < T >    found    =    findIn ( windowsKitDir ,     . DiscoveryType . REGISTRY )  ;", "if    ( found . isEmpty (  )  )     {", "brokenComponents . add ( windowsKitDir )  ;", "}", "for    ( T   t    :    found )     {", "foundComponents . put ( t . getBaseDir (  )  ,    t )  ;", "}", "}    catch    ( MissingRegistryEntryException   e )     {", "}", "}", "METHOD_END"], "methodName": ["locateComponentsInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "T   selected    =    getBestComponent (  )  ;", "if    ( selected    !  =    null )     {", "return   new   platform . base . internal . toolchain . ComponentFound < T >  ( selected )  ;", "}", "if    ( brokenComponents . isEmpty (  )  )     {", "return   new   platform . base . internal . toolchain . ComponentNotFound < T >  (  (  (  \" Could   not   locate   a    \"     +     ( getDisplayName (  )  )  )     +     \"    installation   using   the   Windows   registry .  \"  )  )  ;", "}", "return   new   platform . base . internal . toolchain . ComponentNotFound < T >  (  (  (  \" Could   not   locate   a    \"     +     ( getDisplayName (  )  )  )     +     \"    installation .    None   of   the   following   locations   contain   a   valid   installation \"  )  ,    CollectionUtils . collect ( brokenComponents ,    new   api . Transformer < String ,    File >  (  )     {", "@ Override", "public   String   transform ( File   file )     {", "return   file . getAbsolutePath (  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["locateDefaultComponent"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "File   windowsKitDir    =    FileUtils . canonicalize ( candidate )  ;", "Set < T >    candidates    =    foundComponents . get ( windowsKitDir )  ;", "if    ( candidates . isEmpty (  )  )     {", "candidates    =    findIn ( windowsKitDir ,     . DiscoveryType . USER )  ;", "}", "if    ( candidates . isEmpty (  )  )     {", "return   new   ComponentNotFound < T >  ( String . format (  \" The   specified   installation   directory    '  % s '    does   not   appear   to   contain   a    % s   installation .  \"  ,    candidate ,    getDisplayName (  )  )  )  ;", "}", "Set < T >    found    =    new   TreeSet < T >  ( new   DescendingComponentVersionComparator (  )  )  ;", "found . addAll ( candidates )  ;", "return   new   ComponentFound < T >  ( found . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["locateUserSpecifiedComponent"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.AbstractWindowsKitComponentLocator"}, {"methodBody": ["METHOD_START", "{", "File   commonTools    =    new   File ( vsPath ,    ArchitectureDescriptorBuilder . PATH _ COMMONTOOLS )  ;", "File   commonIde    =    new   File ( vsPath ,    ArchitectureDescriptorBuilder . PATH _ COMMONIDE )  ;", "List < File >    paths    =    Lists . newArrayList ( commonTools ,    commonIde )  ;", "File   crossCompilePath    =    getCrossCompilePath ( basePath )  ;", "if    ( crossCompilePath    !  =    null )     {", "paths . add ( crossCompilePath )  ;", "}", "File   includePath    =    new   File ( basePath ,    ArchitectureDescriptorBuilder . PATH _ INCLUDE )  ;", "return   new   ArchitectureSpecificVisualCpp ( compilerVersion ,    paths ,    getBinPath ( basePath )  ,    getLibPath ( basePath )  ,    getCompilerPath ( basePath )  ,    includePath ,    asmFilename ,    getDefinitions (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildDescriptor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( basePath ,    binPath )  ;", "}", "METHOD_END"], "methodName": ["getBinPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( getBinPath ( basePath )  ,    ArchitectureDescriptorBuilder . COMPILER _ FILENAME )  ;", "}", "METHOD_END"], "methodName": ["getCompilerPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCrossCompilePath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   Maps . newHashMap (  )  ;", "}", "METHOD_END"], "methodName": ["getDefinitions"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( basePath ,    libPath )  ;", "}", "METHOD_END"], "methodName": ["getLibPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureDescriptorBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( binDir . exists (  )  )     &  &     ( compilerPath . exists (  )  )  )     &  &     ( libDir . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["isInstalled"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.ArchitectureSpecificVisualCpp"}, {"methodBody": ["METHOD_START", "{", "return   DefaultUcrtLocator . COMPONENT _ NAME ;", "}", "METHOD_END"], "methodName": ["getComponentName"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultUcrtLocator"}, {"methodBody": ["METHOD_START", "{", "File   visualCppDir    =    install . getVisualCppDir (  )  ;", "File   visualStudioDir    =    install . getInstallDir (  )  ;", "if    ( foundInstalls . containsKey ( visualStudioDir )  )     {", "return   true ;", "}", "if    ( brokenInstalls . contains ( visualStudioDir )  )     {", "return   false ;", "}", "if    (  (  . isValidInstall ( install )  )     &  &     (  ( install . getVisualCppVersion (  )  )     !  =     ( VersionNumber . UNKNOWN )  )  )     {", ". LOGGER . debug (  \" Found   Visual   C +  +     {  }    at    {  }  \"  ,    install . getVisualCppVersion (  )  ,    visualCppDir )  ;", "VersionNumber   visualStudioVersion    =    install . getVersion (  )  ;", "String   visualStudioDisplayVersion    =     (  ( install . getVersion (  )  )     =  =     ( VersionNumber . UNKNOWN )  )     ?     \" from    \"     +    source    :    install . getVersion (  )  . toString (  )  ;", "VisualCppInstall   visualCpp    =    buildVisualCppInstall (  (  \" Visual   C +  +     \"     +     ( install . getVisualCppVersion (  )  )  )  ,    visualStudioDir ,    visualCppDir ,    install . getVisualCppVersion (  )  ,    install . getCompatibility (  )  )  ;", "VisualStudioInstall   visualStudio    =    new   VisualStudioInstall (  (  \" Visual   Studio    \"     +    visualStudioDisplayVersion )  ,    visualStudioDir ,    visualStudioVersion ,    visualCpp )  ;", "foundInstalls . put ( visualStudioDir ,    visualStudio )  ;", "return   true ;", "} else    {", ". LOGGER . debug (  \" Ignoring   candidate   Visual   C +  +    directory    {  }    as   it   does   not   look   like   a   Visual   C +  +    installation .  \"  ,    visualCppDir )  ;", "brokenInstalls . add ( visualStudioDir )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["addInstallIfValid"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "List < ArchitectureDescriptorBuilder >    architectureDescriptorBuilders    =    Lists . newArrayList (  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ X 8  6  _ ON _ X 8  6  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ AMD 6  4  _ ON _ X 8  6  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ IA 6  4  _ ON _ X 8  6  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ ARM _ ON _ X 8  6  )  ;", "boolean   isNativeAmd 6  4     =     ( systemInfo . getArchitecture (  )  )     =  =     ( Architecture . amd 6  4  )  ;", "if    ( isNativeAmd 6  4  )     {", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ AMD 6  4  _ ON _ AMD 6  4  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ X 8  6  _ ON _ AMD 6  4  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . LEGACY _ ARM _ ON _ AMD 6  4  )  ;", "}", "Map < Architecture ,    ArchitectureSpecificCpp >    descriptors    =    Maps . newHashMap (  )  ;", "for    ( ArchitectureDescriptorBuilder   architectureDescriptorBuilder    :    architectureDescriptorBuilders )     {", "ArchitectureSpecificCpp   descriptor    =    architectureDescriptorBuilder . buildDescriptor ( version ,    basePath ,    vsPath )  ;", "if    ( descriptor . isInstalled (  )  )     {", "descriptors . put ( architectureDescriptorBuilder . architecture ,    descriptor )  ;", "}", "}", "return   new   CppInstall ( name ,    version ,    descriptors )  ;", "}", "METHOD_END"], "methodName": ["buildLegacyVisualCppInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "List < ArchitectureDescriptorBuilder >    architectureDescriptorBuilders    =    Lists . newArrayList (  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . X 8  6  _ ON _ X 8  6  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . AMD 6  4  _ ON _ X 8  6  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . ARM _ ON _ X 8  6  )  ;", "boolean   isNativeAmd 6  4     =     ( systemInfo . getArchitecture (  )  )     =  =     ( Architecture . amd 6  4  )  ;", "if    ( isNativeAmd 6  4  )     {", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . AMD 6  4  _ ON _ AMD 6  4  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . X 8  6  _ ON _ AMD 6  4  )  ;", "architectureDescriptorBuilders . add ( ArchitectureDescriptorBuilder . ARM _ ON _ AMD 6  4  )  ;", "}", "Map < Architecture ,    ArchitectureSpecificCpp >    descriptors    =    Maps . newHashMap (  )  ;", "for    ( ArchitectureDescriptorBuilder   architectureDescriptorBuilder    :    architectureDescriptorBuilders )     {", "ArchitectureSpecificCpp   descriptor    =    architectureDescriptorBuilder . buildDescriptor ( version ,    basePath ,    vsPath )  ;", "if    ( descriptor . isInstalled (  )  )     {", "descriptors . put ( architectureDescriptorBuilder . architecture ,    descriptor )  ;", "}", "}", "return   new   CppInstall ( name ,    version ,    descriptors )  ;", "}", "METHOD_END"], "methodName": ["buildVisualCppInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "switch    ( compatibility )     {", "case   LEGACY    :", "return   buildLegacyCppInstall ( name ,    vsPath ,    basePath ,    version )  ;", "case   VS 2  0  1  7  _ OR _ LATER    :", "return   buildCppInstall ( name ,    vsPath ,    basePath ,    version )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Cannot   build   Cpp   install   for   unknown   compatibility   level :     \"     +    compatibility )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildVisualCppInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "VisualStudioInstall   candidate    =    null ;", "for    ( VisualStudioInstall   visualStudio    :    foundInstalls . values (  )  )     {", "if    (  ( candidate    =  =    null )     |  |     (  ( visualStudio . getVersion (  )  . compareTo ( candidate . getVersion (  )  )  )     >     0  )  )     {", "candidate    =    visualStudio ;", "}", "}", "if    ( candidate    !  =    null )     {", "return   new   ComponentFound < VisualStudioInstall >  ( candidate )  ;", "}", "if    ( brokenInstalls . isEmpty (  )  )     {", "return   new   ComponentNotFound < VisualStudioInstall >  (  \" Could   not   locate   a   Visual   Studio   installation ,    using   the   command   line   tool ,    Windows   registry   or   system   path .  \"  )  ;", "}", "return   new   ComponentNotFound < VisualStudioInstall >  (  \" Could   not   locate   a   Visual   Studio   installation .    None   of   the   following   locations   contain   a   valid   installation \"  ,    CollectionUtils . collect ( brokenInstalls ,    new   ArrayList < String >  (  )  ,    new   Transformer < String ,    File >  (  )     {", "@ Override", "public   String   transform ( File   file )     {", "return   file . getAbsolutePath (  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["determineDefaultInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialised )  )     {", "locateInstallsWith ( commandLine )  ;", "locateInstallsWith ( windowsRegistry )  ;", "if    ( foundInstalls . isEmpty (  )  )     {", "locateInstallsWith ( systemPath )  ;", "}", "initialised    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initializeVisualStudioInstalls"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( candidate ,     (  ( DefaultVisualStudioLocator . PATH _ BIN )     +     ( DefaultVisualStudioLocator . LEGACY _ COMPILER _ FILENAME )  )  )  . isFile (  )  ;", "}", "METHOD_END"], "methodName": ["isLegacyVisualCpp"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( candidate ,     (  ( DefaultVisualStudioLocator . PATH _ BIN )     +     ( DefaultVisualStudioLocator . VS 2  0  1  7  _ COMPILER _ FILENAME )  )  )  . isFile (  )  ;", "}", "METHOD_END"], "methodName": ["isVS2017VisualCpp"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "switch    ( install . getCompatibility (  )  )     {", "case   LEGACY    :", "return    ( new   File ( install . getInstallDir (  )  ,     . PATH _ COMMON )  . isDirectory (  )  )     &  &     (  . isLegacyVisualCpp ( install . getVisualCppDir (  )  )  )  ;", "case   VS 2  0  1  7  _ OR _ LATER    :", "return    ( new   File ( install . getInstallDir (  )  ,     . PATH _ COMMON )  . isDirectory (  )  )     &  &     (  . isVS 2  0  1  7 VisualCpp ( install . getVisualCppDir (  )  )  )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Cannot   determine   valid   install   for   unknown   compatibility :     \"     +     ( install . getCompatibility (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isValidInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "List < VisualStudioInstallCandidate >    installs    =    versionLocator . getVisualStudioInstalls (  )  ;", "for    ( VisualStudioInstallCandidate   install    :    installs )     {", "addInstallIfValid ( install ,    versionLocator . getSource (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["locateInstallsWith"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "VisualStudioInstallCandidate   install    =    versionDeterminer . getVisualStudioMetadataFromInstallDir ( candidate )  ;", "if    (  ( install    !  =    null )     &  &     ( addInstallIfValid ( install ,     \" user   provided   path \"  )  )  )     {", "return   new   ComponentFound < VisualStudioInstall >  ( foundInstalls . get ( install . getInstallDir (  )  )  )  ;", "} else    {", ". LOGGER . debug (  \" Ignoring   candidate   Visual   C +  +    install   for    {  }    as   it   does   not   look   like   a   Visual   C +  +    installation .  \"  ,    candidate )  ;", "return   new   ComponentNotFound < VisualStudioInstall >  ( String . format (  \" The   specified   installation   directory    '  % s '    does   not   appear   to   contain   a   Visual   Studio   installation .  \"  ,    candidate )  )  ;", "}", "}", "METHOD_END"], "methodName": ["locateUserSpecifiedInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.DefaultVisualStudioLocator"}, {"methodBody": ["METHOD_START", "{", "return   new   EscapeUserArgs (  )  . transform ( original )  ;", "}", "METHOD_END"], "methodName": ["escapeUserArg"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.EscapeUserArgs"}, {"methodBody": ["METHOD_START", "{", "return   new   EscapeUserArgs (  )  . transform ( original )  ;", "}", "METHOD_END"], "methodName": ["escapeUserArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.EscapeUserArgs"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . collect ( args ,    this )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.EscapeUserArgs"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkInstall"}, {"methodBody": ["METHOD_START", "{", "foundSdks . put ( path ,    new   LegacyWindowsSdkInstall ( path ,    VersionNumber . parse ( version )  ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["addSdk"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "int   index    =    StringUtils . ordinalIndexOf ( version ,     \"  .  \"  ,     2  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "version    =    version . substring (  0  ,    index )  ;", "}", "return   version ;", "}", "METHOD_END"], "methodName": ["formatVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( initialised )  )     {", "leSdksInRegistry (  )  ;", "leKitsInRegistry (  )  ;", "leSdkInPath (  )  ;", "initialised    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initializeWindowsSdks"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "boolean   hasResourceCompiler    =    false ;", "boolean   hasKernel 3  2 Lib    =    false ;", "for    ( String   path    :     . RESOURCE _ PATHS )     {", "if    ( new   File ( candidate ,     ( path    +     (  . RESOURCE _ FILENAME )  )  )  . isFile (  )  )     {", "hasResourceCompiler    =    true ;", "break ;", "}", "}", "for    ( String   path    :     . KERNEL 3  2  _ PATHS )     {", "if    ( new   File ( candidate ,     ( path    +     (  . KERNEL 3  2  _ FILENAME )  )  )  . isFile (  )  )     {", "hasKernel 3  2 Lib    =    true ;", "break ;", "}", "}", "return   hasResourceCompiler    &  &    hasKernel 3  2 Lib ;", "}", "METHOD_END"], "methodName": ["isWindowsSdk"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pathSdk )     !  =    null )     {", "return   new   platform . base . internal . toolchain . ComponentFound < WindowsSdkInstall >  ( pathSdk )  ;", "}", "WindowsSdkInstall   candidate    =    null ;", "for    ( WindowsSdkInstall   windowsSdk    :    foundSdks . values (  )  )     {", "if    (  ( candidate    =  =    null )     |  |     (  ( windowsSdk . getVersion (  )  . compareTo ( candidate . getVersion (  )  )  )     >     0  )  )     {", "candidate    =    windowsSdk ;", "}", "}", "return   candidate    =  =    null    ?    new   platform . base . internal . toolchain . ComponentNotFound < WindowsSdkInstall >  (  \" Could   not   locate   a   Windows   SDK   installation ,    using   the   Windows   registry   and   system   path .  \"  )     :    new   platform . base . internal . toolchain . ComponentFound < WindowsSdkInstall >  ( candidate )  ;", "}", "METHOD_END"], "methodName": ["locateDefaultSdk"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "for    ( String   baseKey    :    LegacyWindowsSdkLocator . REGISTRY _ BASEPATHS )     {", "locateKitsInRegistry ( baseKey )  ;", "}", "}", "METHOD_END"], "methodName": ["locateKitsInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "String [  ]    versions    =    new   String [  ]  {    LegacyWindowsSdkLocator . VERSION _ KIT _  8  ,    LegacyWindowsSdkLocator . VERSION _ KIT _  8  1     }  ;", "String [  ]    keys    =    new   String [  ]  {    LegacyWindowsSdkLocator . REGISTRY _ KIT _  8  ,    LegacyWindowsSdkLocator . REGISTRY _ KIT _  8  1     }  ;", "for    ( int   i    =     0  ;    i    !  =     ( keys . length )  ;     +  + i )     {", "try    {", "File   kitDir    =    FileUtils . canonicalize ( new   File ( windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,     ( baseKey    +     ( LegacyWindowsSdkLocator . REGISTRY _ ROOTPATH _ KIT )  )  ,    keys [ i ]  )  )  )  ;", "if    ( LegacyWindowsSdkLocator . isWindowsSdk ( kitDir )  )     {", "LegacyWindowsSdkLocator . LOGGER . debug (  \" Found   Windows   Kit    {  }    at    {  }  \"  ,    versions [ i ]  ,    kitDir )  ;", "addSdk ( kitDir ,    versions [ i ]  ,     (  (  ( LegacyWindowsSdkLocator . NAME _ KIT )     +     \"     \"  )     +     ( versions [ i ]  )  )  )  ;", "} else    {", "LegacyWindowsSdkLocator . LOGGER . debug (  \" Ignoring   candidate   Windows   Kit   directory    {  }    as   it   does   not   look   like   a   Windows   Kit   installation .  \"  ,    kitDir )  ;", "}", "}    catch    ( MissingRegistryEntryException   e )     {", "}", "}", "}", "METHOD_END"], "methodName": ["locateKitsInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "File   resourceCompiler    =    os . findInPath ( LegacyWindowsSdkLocator . RESOURCE _ FILENAME )  ;", "if    ( resourceCompiler    =  =    null )     {", "LegacyWindowsSdkLocator . LOGGER . debug (  \" Could   not   find   Windows   resource   compiler   in   system   path .  \"  )  ;", "return ;", "}", "File   sdkDir    =    FileUtils . canonicalize ( resourceCompiler . getParentFile (  )  . getParentFile (  )  )  ;", "if    (  !  ( LegacyWindowsSdkLocator . isWindowsSdk ( sdkDir )  )  )     {", "sdkDir    =    sdkDir . getParentFile (  )  ;", "if    (  !  ( LegacyWindowsSdkLocator . isWindowsSdk ( sdkDir )  )  )     {", "LegacyWindowsSdkLocator . LOGGER . debug (  \" Ignoring   candidate   Windows   SDK   for    {  }    as   it   does   not   look   like   a   Windows   SDK   installation .  \"  ,    resourceCompiler )  ;", "}", "}", "LegacyWindowsSdkLocator . LOGGER . debug (  \" Found   Windows   SDK    {  }    using   system   path \"  ,    sdkDir )  ;", "if    (  !  ( foundSdks . containsKey ( sdkDir )  )  )     {", "addSdk ( sdkDir ,     \" path \"  ,     \" Path - resolved   Windows   SDK \"  )  ;", "}", "pathSdk    =    foundSdks . get ( sdkDir )  ;", "}", "METHOD_END"], "methodName": ["locateSdkInPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "for    ( String   baseKey    :    LegacyWindowsSdkLocator . REGISTRY _ BASEPATHS )     {", "locateSdksInRegistry ( baseKey )  ;", "}", "}", "METHOD_END"], "methodName": ["locateSdksInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "try    {", "List < String >    subkeys    =    windowsRegistry . getSubkeys ( HKEY _ LOCAL _ MACHINE ,     ( baseKey    +     (  . REGISTRY _ ROOTPATH _ SDK )  )  )  ;", "for    ( String   subkey    :    subkeys )     {", "try    {", "String   basePath    =     (  ( baseKey    +     (  . REGISTRY _ ROOTPATH _ SDK )  )     +     \"  \\  \\  \"  )     +    subkey ;", "File   sdkDir    =    FileUtils . canonicalize ( new   File ( windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,    basePath ,     . REGISTRY _ FOLDER )  )  )  ;", "String   version    =     . formatVersion ( windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,    basePath ,     . REGISTRY _ VERSION )  )  ;", "String   name    =    windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,    basePath ,     . REGISTRY _ NAME )  ;", "if    (  . isWindowsSdk ( sdkDir )  )     {", ". LOGGER . debug (  \" Found   Windows   SDK    {  }    at    {  }  \"  ,    version ,    sdkDir )  ;", "addSdk ( sdkDir ,    version ,    name )  ;", "} else    {", ". LOGGER . debug (  \" Ignoring   candidate   Windows   SDK   directory    {  }    as   it   does   not   look   like   a   Windows   SDK   installation .  \"  ,    sdkDir )  ;", "}", "}    catch    ( MissingRegistryEntryException   e )     {", "}", "}", "}    catch    ( MissingRegistryEntryException   e )     {", "}", "}", "METHOD_END"], "methodName": ["locateSdksInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "File   sdkDir    =    FileUtils . canonicalize ( candidate )  ;", "if    (  !  (  . isWindowsSdk ( sdkDir )  )  )     {", "return   new   ComponentNotFound < WindowsSdkInstall >  ( String . format (  \" The   specified   installation   directory    '  % s '    does   not   appear   to   contain   a   Windows   SDK   installation .  \"  ,    candidate )  )  ;", "}", "if    (  !  ( foundSdks . containsKey ( sdkDir )  )  )     {", "addSdk ( sdkDir ,     . VERSION _ USER ,     . NAME _ USER )  ;", "}", "return   new   ComponentFound < WindowsSdkInstall >  ( foundSdks . get ( sdkDir )  )  ;", "}", "METHOD_END"], "methodName": ["locateUserSpecifiedSdk"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LegacyWindowsSdkLocator"}, {"methodBody": ["METHOD_START", "{", "new   VisualCppOptionsFileArgsWriter ( tempDir )  . execute ( args )  ;", "}", "METHOD_END"], "methodName": ["addOptionsFileArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.LinkExeLinker"}, {"methodBody": ["METHOD_START", "{", "if    ( platform . getArchitecture (  )  . isAmd 6  4  (  )  )     {", "return   new    . UcrtSystemLibraries (  \" x 6  4  \"  )  ;", "}", "if    ( platform . getArchitecture (  )  . isArm (  )  )     {", "return   new    . UcrtSystemLibraries (  \" arm \"  )  ;", "}", "if    ( platform . getArchitecture (  )  . isI 3  8  6  (  )  )     {", "return   new    . UcrtSystemLibraries (  \" x 8  6  \"  )  ;", "}", "throw   new   UnsupportedOperationException ( String . format (  \" Supported    % s   for    % s .  \"  ,    platform . getArchitecture (  )  . getDisplayName (  )  ,    toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCRuntime"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.UcrtInstall"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    spec . getIncludeRoots (  )  )     {", "args . add (  (  \"  / I \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}", "for    ( File   file    :    spec . getSystemIncludeRoots (  )  )     {", "args . add (  (  \"  / I \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addIncludeArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "for    ( String   macroArg    :    new   MacroArgsConverter (  )  . transform ( spec . getMacros (  )  )  )     {", "args . add ( EscapeUserArgs . escapeUserArg (  (  \"  / D \"     +    macroArg )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addMacroArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "args . add ( getLanguageOption (  )  )  ;", "args . add (  \"  / nologo \"  )  ;", "args . add (  \"  / c \"  )  ;", "if    ( spec . isDebuggable (  )  )     {", "args . add (  \"  / Zi \"  )  ;", "}", "if    ( spec . isOptimized (  )  )     {", "args . add (  \"  / O 2  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["addToolSpecificArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "args . addAll ( EscapeUserArgs . escapeUserArgs ( spec . getAllArgs (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addUserArgs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["getLanguageOption"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppCompilerArgsTransformer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( targetPlatform . getOperatingSystem (  )  . isWindows (  )  )  )     {", "return   null ;", "}", "return   platforms . get ( getPlatformArchitecture ( targetPlatform )  )  ;", "}", "METHOD_END"], "methodName": ["forPlatform"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppInstall"}, {"methodBody": ["METHOD_START", "{", "return   platforms . get ( getPlatformArchitecture ( targetPlatform )  )  ;", "}", "METHOD_END"], "methodName": ["getDescriptor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppInstall"}, {"methodBody": ["METHOD_START", "{", "return   targetPlatform . getArchitecture (  )  ;", "}", "METHOD_END"], "methodName": ["getPlatformArchitecture"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppInstall"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppInstall"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < T ,    T >  (  )     {", "public   T   transform ( T   original )     {", "for    ( Map . Entry < String ,    String >    definition    :    libraries . getPreprocessorMacros (  )  . entrySet (  )  )     {", "original . define ( definition . getKey (  )  ,    definition . getValue (  )  )  ;", "}", "return   original ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["addDefinitions"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < LinkerSpec ,    LinkerSpec >  (  )     {", "public   LinkerSpec   transform ( LinkerSpec   original )     {", "original . libraryPath ( libraries . getLibDirs (  )  )  ;", "return   original ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["addLibraryPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?  >    environmentVariables    =    Jvm . current (  )  . getInheritableEnvironmentVariables ( System . getenv (  )  )  ;", "for    ( String   name    :    names )     {", "Object   value    =    environmentVariables . get ( name )  ;", "if    ( value    !  =    null )     {", "ToolChain . LOGGER . debug (  \" Ignoring   value    '  {  }  '    set   for   environment   variable    '  {  }  '  .  \"  ,    value ,    name )  ;", "invocation . addEnvironmentVar ( name ,     \"  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["clearEnvironmentVars"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "MutableCommandLineToolContext   invocationContext    =    new   DefaultMutableCommandLineToolContext (  )  ;", "invocationContext . addPath ( v . getPath (  )  )  ;", "invocationContext . addPath ( sdk . getPath (  )  )  ;", "clearEnvironmentVars ( invocationContext ,     \" INCLUDE \"  ,     \" CL \"  ,     \" LIBPATH \"  ,     \" LINK \"  ,     \" LIB \"  )  ;", "invocationContext . setArgAction ( commandLineToolConfiguration . getArgAction (  )  )  ;", "return   invocationContext ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return    \"  . pch \"  ;", "}", "METHOD_END"], "methodName": ["getPCHFileExtension"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < T ,    T >  (  )     {", "@ Override", "public   T   transform ( T   original )     {", "List < Transformer < T ,    T >  >    transformers    =    Lists . newArrayList (  )  ;", "transformers . add ( PCHUtils . getHeaderToSourceFileTransformer ( type )  )  ;", "transformers . add ( addDefinitions ( type )  )  ;", "T   next    =    original ;", "for    ( Transformer < T ,    T >    transformer    :    transformers )     {", "next    =    transformer . transform ( next )  ;", "}", "return   next ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["pchSpecTransforms"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCommandLineToolInvocationWorker ( toolName ,    exe ,    execActionFactory )  ;", "}", "METHOD_END"], "methodName": ["tool"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   VersionAwareCompiler < T >  ( outputCleaningCompiler ,    new   DefaultCompilerVersion ( VisualCppToolChain . DEFAULT _ NAME ,     \" Microsoft \"  ,    visualCpp . getImplementationVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["versionAwareCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( operatingSystem . isWindows (  )  )  )     {", "availability . unavailable (  \" Visual   Studio   is   not   available   on   this   operating   system .  \"  )  ;", "return ;", "}", "SearchResult < VisualStudioInstall >    visualStudioSearchResult    =    visualStudioLocator . locateComponent ( installDir )  ;", "availability . mustBeAvailable ( visualStudioSearchResult )  ;", "if    ( visualStudioSearchResult . isAvailable (  )  )     {", "visualStudio    =    visualStudioSearchResult . getComponent (  )  ;", "visualCpp    =    visualStudioSearchResult . getComponent (  )  . get (  )  ;", "}", "SearchResult < WindowsSdkInstall >    windowsSdkSearchResult    =    windowsSdkLocator . locateComponent ( windowsSdkDir )  ;", "availability . mustBeAvailable ( windowsSdkSearchResult )  ;", "if    ( windowsSdkSearchResult . isAvailable (  )  )     {", "windowsSdk    =    windowsSdkSearchResult . getComponent (  )  ;", "}", "if    ( is 2  0  1  5  (  )  )     {", "SearchResult < UcrtInstall >    ucrtSearchResult    =    ucrtLocator . locateComponent ( ucrtDir )  ;", "availability . mustBeAvailable ( ucrtSearchResult )  ;", "if    ( ucrtSearchResult . isAvailable (  )  )     {", "ucrt    =    ucrtSearchResult . getComponent (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkAvailable"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppToolChain"}, {"methodBody": ["METHOD_START", "{", "if    (  ( availability )     =  =    null )     {", "availability    =    new   Availability (  )  ;", "checkAvailable ( availability )  ;", "}", "return   availability ;", "}", "METHOD_END"], "methodName": ["getAvailability"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppToolChain"}, {"methodBody": ["METHOD_START", "{", "return   ucrtDir ;", "}", "METHOD_END"], "methodName": ["getUcrtDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppToolChain"}, {"methodBody": ["METHOD_START", "{", "return    (  ( visualCpp )     !  =    null )     &  &     (  ( visualCpp . getVersion (  )  . getMajor (  )  )     >  =     1  4  )  ;", "}", "METHOD_END"], "methodName": ["isVisualCpp2015"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppToolChain"}, {"methodBody": ["METHOD_START", "{", "this . ucrtDir    =    resolve ( ucrtDirPath )  ;", "}", "METHOD_END"], "methodName": ["setUcrtDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualCppToolChain"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualStudioInstall"}, {"methodBody": ["METHOD_START", "{", "return   visualCppInstall ;", "}", "METHOD_END"], "methodName": ["getVisualCpp"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualStudioInstall"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getVisualStudioDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.VisualStudioInstall"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.WindowsKitInstall"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.WindowsKitInstall"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.WindowsKitInstall"}, {"methodBody": ["METHOD_START", "{", "if    (  ( VersionNumber . parse ( version )  . getMajor (  )  )     >  =     1  5  )     {", "return   visualCppMetadataProvider . getVisualCppFromMetadataFile ( installDir )  ;", "} else    {", "return   visualCppMetadataProvider . getVisualCppFromRegistry ( version )  ;", "}", "}", "METHOD_END"], "methodName": ["findVisualCppMetadata"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.CommandLineToolVersionLocator"}, {"methodBody": ["METHOD_START", "{", "ExecAction   exec    =    execActionFactory . newExecAction (  )  ;", "exec . args ( args )  ;", "exec . executable ( vswhereBinary . getAbsolutePath (  )  )  ;", "exec . setWorkingDir ( vswhereBinary . getParentFile (  )  )  ;", "StreamByteBuffer   buffer    =    new   StreamByteBuffer (  )  ;", "exec . setStandardOutput ( buffer . getOutputStream (  )  )  ;", "exec . setErrorOutput ( INSTANCE )  ;", "exec . setIgnoreExitValue ( true )  ;", "ExecResult   result    =    exec . execute (  )  ;", "int   exitValue    =    result . getExitValue (  )  ;", "if    ( exitValue    =  =     0  )     {", "return   buffer . readAsString (  \" UTF -  8  \"  )  ;", "} else    {", ". LOGGER . debug (  \" vswhere . exe   returned   a   non - zero   exit   value    (  {  }  )     -    ignoring \"  ,    result . getExitValue (  )  )  ;", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getVswhereOutput"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.CommandLineToolVersionLocator"}, {"methodBody": ["METHOD_START", "{", "List < VisualStudioInstallCandidate >    installs    =    Lists . newArrayList (  )  ;", "JsonReader   reader    =    new   JsonReader ( new   StringReader ( json )  )  ;", "try    {", "try    {", "reader . beginArray (  )  ;", "while    ( reader . hasNext (  )  )     {", "VisualStudioInstallCandidate   candidate    =    readInstall ( reader )  ;", "if    ( candidate    !  =    null )     {", "installs . add ( candidate )  ;", "}", "}", "reader . endArray (  )  ;", "}    finally    {", "reader . close (  )  ;", "}", "}    catch    ( IOExcepte )     {", "throw   UncheckedExceptthrowAsUncheckedExcepte )  ;", "}", "return   installs ;", "}", "METHOD_END"], "methodName": ["parseJson"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.CommandLineToolVersionLocator"}, {"methodBody": ["METHOD_START", "{", "String   visualStudioInstallPath    =    null ;", "String   visualStudioVersion    =    null ;", "reader . beginObject (  )  ;", "while    ( reader . hasNext (  )  )     {", "String   key    =    reader . nextName (  )  ;", "if    ( key . equals (  . INSTALLATION _ PATH _ KEY )  )     {", "visualStudioInstallPath    =    reader . nextString (  )  ;", "} else", "if    ( key . equals (  . INSTALLATION _ VERSION _ KEY )  )     {", "visualStudioVersion    =    reader . nextString (  )  ;", "} else    {", "reader . skipValue (  )  ;", "}", "}", "reader . endObject (  )  ;", "File   visualStudioInstallDir    =    new   File ( visualStudioInstallPath )  ;", "VisualCppInstallCandidate   visualCppMetadata    =    findVisualCppMetadata ( visualStudioInstallDir ,    visualStudioVersion )  ;", "if    ( visualCppMetadata    =  =    null )     {", ". LOGGER . debug (  (  (  (  (  \" Ignoring   candidate   Visual   Studio   version    \"     +    visualStudioVersion )     +     \"    at    \"  )     +    visualStudioInstallPath )     +     \"    because   it   does   not   appear   to   be   a   valid   installation \"  )  )  ;", "return   null ;", "} else    {", "return   new   VisualStudioMetadataBuilder (  )  . installDir ( visualStudioInstallDir )  . visualCppDir ( visualCppMetadata . getVisualCppDir (  )  )  . version ( VersionNumber . parse ( visualStudioVersion )  )  . visualCppVersion ( visualCppMetadata . getVersion (  )  )  . build (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readInstall"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.CommandLineToolVersionLocator"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultVisualStudioMetadata ( installDir ,    visualCppDir ,    version ,    visualCppVersion ,    compatibility )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "this . compatibility    =    compatibility ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compatibility"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "this . installDir    =    FileUtils . canonicalize ( installDir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["installDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "this . version    =    version ;", "return   this ;", "}", "METHOD_END"], "methodName": ["version"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "this . visualCppDir    =    FileUtils . canonicalize ( visualCppDir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["visualCppDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "this . visualCppVersion    =    version ;", "return   this ;", "}", "METHOD_END"], "methodName": ["visualCppVersion"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "for    ( VisualStudioInstallCandidate   install    :    installs )     {", "if    ( spec . isSatisfiedBy ( install )  )     {", "return   install ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findMetadataForInstallDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioVersionDeterminer"}, {"methodBody": ["METHOD_START", "{", "if    ( n    =  =     0  )     {", "return   file ;", "} else    {", "File   parent    =    file . getParentFile (  )  ;", "if    ( parent    !  =    null )     {", "return    . getNthParent ( parent ,     (  -  - n )  )  ;", "} else    {", "return   file ;", "}", "}", "}", "METHOD_END"], "methodName": ["getNthParent"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioVersionDeterminer"}, {"methodBody": ["METHOD_START", "{", "List < VisualStudioInstallCandidate >    installs    =    commandLineLocator . getVisualStudioInstalls (  )  ;", "if    (  ( installs . size (  )  )     >     0  )     {", "VisualStudioInstallCandidate   install    =    findMetadataForInstallDir ( spec ,    installs )  ;", "if    ( install    !  =    null )     {", "return   install ;", "}", "} else    {", "installs    =    windowsRegistryLocator . getVisualStudioInstalls (  )  ;", "VisualStudioInstallCandidate   install    =    findMetadataForInstallDir ( spec ,    installs )  ;", "if    ( install    !  =    null )     {", "return   install ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getVisualStudioMetadata"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.VisualStudioVersionDeterminer"}, {"methodBody": ["METHOD_START", "{", "List < String >    visualCppVersions ;", "try    {", "visualCppVersions    =    windowsRegistry . getValueNames ( HKEY _ LOCAL _ MACHINE ,     ( baseKey    +     (  . REGISTRY _ ROOTPATH _ VC )  )  )  ;", "}    catch    ( MissingRegistryEntryException   e )     {", "return ;", "}", "for    ( String   versionString    :    visualCppVersions )     {", "if    (  !  ( versionString . matches (  \"  \\  \\ d +  \\  \\  .  \\  \\ d +  \"  )  )  )     {", "continue ;", "}", "File   visualCppDir    =    new   File ( windowsRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,     ( baseKey    +     (  . REGISTRY _ ROOTPATH _ VC )  )  ,    versionString )  )  ;", "visualCppDir    =    FileUtils . canonicalize ( visualCppDir )  ;", "File   visualStudioDir    =    visualCppDir . getParentFile (  )  ;", "VersionNumber   version    =    VersionNumber . parse ( versionString )  ;", "installs . add ( new   VisualStudioMetadataBuilder (  )  . installDir ( visualStudioDir )  . visualCppDir ( visualCppDir )  . version ( version )  . visualCppVersion ( version )  . build (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["locateInstallsInRegistry"], "fileName": "org.gradle.nativeplatform.toolchain.internal.msvcpp.version.WindowsRegistryVersionLocator"}, {"methodBody": ["METHOD_START", "{", "tools . put ( tool . getToolType (  )  ,    tool )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.DefaultSwiftcPlatformToolChain"}, {"methodBody": ["METHOD_START", "{", "SimpleStaleClassCleaner   cleaner    =    new   SimpleStaleClassCleaner ( outputs )  ;", "cleaner . setDestionDir ( spec . getObjectFileDir (  )  )  ;", "cleaner . execute (  )  ;", "return   cleaner . getDidWork (  )  ;", "}", "METHOD_END"], "methodName": ["cleanPreviousOutputs"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.IncrementalSwiftCompiler"}, {"methodBody": ["METHOD_START", "{", "return   compiler . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.IncrementalSwiftCompiler"}, {"methodBody": ["METHOD_START", "{", "boolean   didRemove    =    false ;", "for    ( File   removedSource    :    spec . getRemovedSourceFiles (  )  )     {", "File   objectFile    =    getObjectFile ( spec . getObjectFileDir (  )  ,    removedSource )  ;", "if    ( objectFile . delete (  )  )     {", "didRemove    =    true ;", "GFileUtils . deleteDirectory ( objectFile . getParentFile (  )  )  ;", "}", "}", "return   didRemove ;", "}", "METHOD_END"], "methodName": ["deleteOutputsForRemovedSources"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.IncrementalSwiftCompiler"}, {"methodBody": ["METHOD_START", "{", "return   compilerOutputFileNamingSchemeFactory . create (  )  . withObjectFileNameSuffix (  \"  . o \"  )  . withOutputBaseFolder ( objectFileRoot )  . map ( sourceFile )  ;", "}", "METHOD_END"], "methodName": ["getObjectFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.IncrementalSwiftCompiler"}, {"methodBody": ["METHOD_START", "{", "boolean   windowsPathLimitation    =    OperatingSystem . current (  )  . isWindows (  )  ;", "File   outputFile    =    cOutputFileNamingSchemeFactory . create (  )  . withObjectFileNameSuffix ( fileSuffix )  . withOutputBaseFolder ( objectFileDir )  . map ( sourceFile )  ;", "File   outputDirectory    =    outputFile . getParentFile (  )  ;", "GFileUtils . mkdirs ( outputDirectory )  ;", "return   windowsPathLimitation    ?    FileUtils . assertInWindowsPathLengthLimitation ( outputFile )     :    outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFileDir"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftCompiler"}, {"methodBody": ["METHOD_START", "{", "for    ( File   changedSource    :    changedSources )     {", "if    ( swiftDeps . inputs . containsKey ( changedSource . getAbsolutePath (  )  )  )     {", "swiftDeps . inputs . put ( changedSource . getAbsolutePath (  )  ,     . RESET _ TIMESTAMP )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["adjustTimestamps"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftDepsHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( moduleSwiftDeps . exists (  )  )     &  &     (  !  ( changedSources . isEmpty (  )  )  )  )     {", "try    {", ". SwiftDeps   swiftDeps    =    parse ( moduleSwiftDeps )  ;", "adjustTimestamps ( swiftDeps ,    changedSources )  ;", "write ( moduleSwiftDeps ,    swiftDeps )  ;", "}    catch    ( Exception   e )     {", ". LOGGER . debug (  \" could   not   update   module . swiftdeps \"  ,    e )  ;", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["adjustTimestampsFor"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftDepsHandler"}, {"methodBody": ["METHOD_START", "{", "return   IoActions . withResource ( new   FileInputStream ( moduleSwiftDeps )  ,    new   Transformer < SwiftDepsHandler . SwiftDeps ,    FileInputStream >  (  )     {", "@ Override", "public   SwiftDepsHandler . SwiftDeps   transform ( FileInputStream   fileInputStream )     {", "Yaml   yaml    =    new   Yaml ( new   Loader ( new   Constructor ( SwiftDepsHandler . SwiftDeps . class )  )  )  ;", "return    (  ( SwiftDepsHandler . SwiftDeps )     ( yaml . load ( fileInputStream )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftDepsHandler"}, {"methodBody": ["METHOD_START", "{", "IoActions . writeTextFile ( moduleSwiftDeps ,    new   Action < BufferedWriter >  (  )     {", "@ Override", "public   void   execute ( BufferedWriter   bufferedWriter )     {", "JavaBeanDumper   yaml    =    new   JavaBeanDumper ( false )  ;", "yaml . dump ( swiftDeps ,    bufferedWriter )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftDepsHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCommandLineToolInvocationWorker ( key . getToolName (  )  ,    toolSearchPath . locate ( key ,    exeName )  . getTool (  )  ,    execActionFactory )  ;", "}", "METHOD_END"], "methodName": ["commandLineTool"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "MutableCommandLineToolContext   baseInvocation    =    new   DefaultMutableCommandLineToolContext (  )  ;", "baseInvocation . setArgAction ( toolConfiguration . getArgAction (  )  )  ;", "return   baseInvocation ;", "}", "METHOD_END"], "methodName": ["context"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "CommandLineToolConfigurationInternal   swiftCompilerTool    =     (  ( CommandLineToolConfigurationInternal )     ( toolRegistry . getSwiftCompiler (  )  )  )  ;", "SwiftCompiler   swiftCompiler    =    new   SwiftCompiler ( buildOperationExecutor ,    compilerOutputFileNamingSchemeFactory ,    commandLineTool ( ToolType . SWIFT _ COMPILER ,     \" swiftc \"  )  ,    context ( swiftCompilerTool )  ,    getObjectFileExtension (  )  ,    workerLeaseService ,    swiftcMetaData . getVersion (  )  )  ;", "return   new   VersionAwareCompiler < compilespec . SwiftCompileSpec >  ( swiftCompiler ,    new   DefaultCompilerVersion (  \" swiftc \"  ,    swiftcMetaData . getVendor (  )  ,    swiftcMetaData . getVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createSwiftCompiler"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftPlatformToolProvider"}, {"methodBody": ["METHOD_START", "{", "toolChain . add ( instantiator . newInstance ( DefaultCommandLineToolConfiguration . class ,    ToolType . SWIFT _ COMPILER )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultCommandLineToolConfiguration . class ,    ToolType . LINKER )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultCommandLineToolConfiguration . class ,    ToolType . STATIC _ LIB _ ARCHIVER )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultCommandLineToolConfiguration . class ,    ToolType . SYMBOL _ EXTRACTOR )  )  ;", "toolChain . add ( instantiator . newInstance ( DefaultCommandLineToolConfiguration . class ,    ToolType . STRIPPER )  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultTools"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftcToolChain"}, {"methodBody": ["METHOD_START", "{", "DefaultSwiftcPlatformToolChain   configurableToolChain    =    instantiator . newInstance ( DefaultSwiftcPlatformToolChain . class ,    targetPlatform )  ;", "addDefaultTools ( configurableToolChain )  ;", "configureActions . execute ( configurableToolChain )  ;", "CommandLineToolSearchResult   compiler    =    toolSearchPath . locate ( ToolType . SWIFT _ COMPILER ,     \" swiftc \"  )  ;", "ToolChainAvailability   result    =    new   ToolChainAvailability (  )  ;", "result . mustBeAvailable ( compiler )  ;", "if    (  !  ( result . isAvailable (  )  )  )     {", "return   new   UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem (  )  ,    result )  ;", "}", "SearchResult < SwiftcMetadata >    swiftcMetaData    =    compilerMetaDataProvider . getCompilerMetaData ( compiler . getTool (  )  ,    ImmutableList .  < String > of (  )  )  ;", "result . mustBeAvailable ( swiftcMetaData )  ;", "if    (  !  ( result . isAvailable (  )  )  )     {", "return   new   UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem (  )  ,    result )  ;", "}", "return   new   SwiftPlatformToolProvider ( buildOperationExecutor ,    targetPlatform . getOperatingSystem (  )  ,    toolSearchPath ,    configurableToolChain ,    execActionFactory ,    compilerOutputFileNamingSchemeFactory ,    workerLeaseService ,    swiftcMetaData . getComponent (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPlatformToolProvider"], "fileName": "org.gradle.nativeplatform.toolchain.internal.swift.SwiftcToolChain"}, {"methodBody": ["METHOD_START", "{", "return   toolType ;", "}", "METHOD_END"], "methodName": ["getToolType"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration"}, {"methodBody": ["METHOD_START", "{", "List < File >    path    =     ( pathEntries . isEmpty (  )  )     ?    operatingSystem . getPath (  )     :    pathEntries ;", "String   exeName    =    operatingSystem . getExecutableName ( name )  ;", "try    {", "if    ( name . contains ( File . separator )  )     {", "return   maybeResolveFile ( operatingSystem ,    new   File ( name )  ,    new   File ( exeName )  )  ;", "}", "for    ( File   pathEntry    :    path )     {", "File   resolved    =    maybeResolveFile ( operatingSystem ,    new   File ( pathEntry ,    name )  ,    new   File ( pathEntry ,    exeName )  )  ;", "if    ( resolved    !  =    null )     {", "return   resolved ;", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findExecutable"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "return   pathEntries ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "File   executable    =    executables . get ( exeName )  ;", "if    ( executable    =  =    null )     {", "executable    =    findExecutable ( operatingSystem ,    exeName )  ;", "if    ( executable    !  =    null )     {", "executables . put ( exeName ,    executable )  ;", "}", "}", "return    ( executable    =  =    null )     |  |     (  !  ( executable . isFile (  )  )  )     ?    new    . MissingTool ( key ,    exeName ,    pathEntries )     :    new    . FoundTool ( executable )  ;", "}", "METHOD_END"], "methodName": ["locate"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( symlink . isFile (  )  )  )     {", "return   null ;", "}", "if    (  ( symlink . length (  )  )     <  =     1  1  )     {", "return   null ;", "}", "String   pStr ;", "DataInputStream   instr    =    new   DataInputStream ( new   BufferedInputStream ( new   FileInputStream ( symlink )  )  )  ;", "try    {", "byte [  ]    header    =    new   byte [  1  0  ]  ;", "instr . readFully ( header )  ;", "if    (  !  ( new   String ( header ,     \" utf -  8  \"  )  . equals (  \"  !  < symlink >  \"  )  )  )     {", "return   null ;", "}", "byte [  ]    pContent    =    new   byte [  (  ( int )     ( symlink . length (  )  )  )     -     1  1  ]  ;", "instr . readFully ( pContent )  ;", "pStr    =    new   String ( pContent ,     \" utf -  8  \"  )  ;", "}    finally    {", "instr . close (  )  ;", "}", "symlink    =    new   File ( symlink . getParentFile (  )  ,    pStr )  ;", "if    ( symlink . isFile (  )  )     {", "return   symlink . getCanonicalFile (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["maybeResolveCygwinSymlink"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "if    ( exeCandidate . isFile (  )  )     {", "return   exeCandidate ;", "}", "if    ( operngSystem . isWindows (  )  )     {", "File   symlink    =    maybeResolveCygwinSymlink ( symlinkCandidate )  ;", "if    ( symlink    !  =    null )     {", "return   symlink ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["maybeResolveFile"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "pathEntries . add ( pathEntry )  ;", "executables . clear (  )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "this . pathEntries . clear (  )  ;", "this . pathEntries . addAll ( pathEntries )  ;", "executables . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.nativeplatform.toolchain.internal.tools.ToolSearchPath"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "if    (  ( cachedion )     =  =    null )     {", "ByteArrayOutputStream   outputStream    =    new   ByteArrayOutputStream (  )  ;", "ExecAction   execAction    =    execActionFactory . newExecAction (  )  ;", "execAction . executable (  \" xcrun \"  )  ;", "execAction . workingDir ( System . getProperty (  \" user . dir \"  )  )  ;", "execAction . args ( getXcrunFlags (  )  )  ;", "execAction . setStandardOutput ( outputStream )  ;", "execAction . execute (  )  . assertNormalExitValue (  )  ;", "cachedion    =    new   File ( outputStream . toString (  )  . replace (  \"  \\ n \"  ,     \"  \"  )  )  ;", "}", "return   cachedion ;", "}", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.nativeplatform.toolchain.internal.xcode.AbstractLocator"}]