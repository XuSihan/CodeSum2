[{"methodBody": ["METHOD_START", "{", "ModelMap < ComponentSpec >    components    =    projectModel . find ( container ,    DefaultLocalLibraryResolver . COMPONENT _ MAP _ TYPE )  ;", "if    ( components    !  =    null )     {", "ModelMap <  ?    extends   VariantComponentSpec >    libraries    =    components . withType ( VariantComponentSpec . class )  ;", "librarySpecs . addAll ( libraries . values (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["collectLocalComponents"], "fileName": "org.gradle.api.internal.resolve.DefaultLocalLibraryResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   LibraryResolutionResult ( binaryType )  ;", "}", "METHOD_END"], "methodName": ["emptyResolutionResult"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "List < String >    list    =    Lists . transform ( libs ,    LibraryResolutionResult . QUOTE _ TRANSFORMER )  ;", "return   Ordering . natural (  )  . sortedCopy ( list )  ;", "}", "METHOD_END"], "methodName": ["formatLibraryNames"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return   Lists . newArrayList ( libsMatchingRequirements . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCandidateLibraries"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return   nonMatchingLibrary ;", "}", "METHOD_END"], "methodName": ["getNonMatchingLibrary"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return   selectedLibrary ;", "}", "METHOD_END"], "methodName": ["getSelectedLibrary"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "if    (  ( libsMatchingRequirements . size (  )  )     =  =     1  )     {", "return   libsMatchingRequirements . values (  )  . iator (  )  . next (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSingleMatchingLibrary"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( libsMatchingRequirements . isEmpty (  )  )  )     |  |     (  !  ( libsNotMatchingRequirements . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasLibraries"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return   projectNotFound ;", "}", "METHOD_END"], "methodName": ["isProjectNotFound"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "LibraryResolutionResult   result    =    new   LibraryResolutionResult ( binaryType )  ;", "for    ( VariantComponent   librarySpec    :    libraries )     {", "if    ( libraryFilter . apply ( librarySpec )  )     {", "result . libsMatchingRequirements . put ( librarySpec . getName (  )  ,    librarySpec )  ;", "} else    {", "result . libsNotMatchingRequirements . put ( librarySpec . getName (  )  ,    librarySpec )  ;", "}", "}", "result . resolve ( libraryName )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "LibraryResolutionResult   projectNotFoundResult    =    new   LibraryResolutionResult ( binaryType )  ;", "projectNotFoundResult . projectNotFound    =    true ;", "return   projectNotFoundResult ;", "}", "METHOD_END"], "methodName": ["projectNotFound"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "if    ( libraryName    =  =    null )     {", "VariantComponent   singleMatching    =    getSingleMatching (  )  ;", "if    ( singleMatching    =  =    null )     {", "return ;", "}", "libraryName    =    singleMatching . getName (  )  ;", "}", "selected    =    libsMatchingRequirements . get ( libraryName )  ;", "nonMatching    =    libsNotMatchingRequirements . get ( libraryName )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "List < String >    candidateLibraries    =    LibraryResolutionResult . formatLibraryNames ( getCandidateLibraries (  )  )  ;", "String   projectPath    =    selector . getProjectPath (  )  ;", "String   libraryName    =    selector . getLibraryName (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  \" Project    '  \"  )  . append ( projectPath )  . append (  \"  '  \"  )  ;", "if    (  ( libraryName    =  =    null )     |  |     (  !  ( hasLibraries (  )  )  )  )     {", "if    ( isProjectNotFound (  )  )     {", "sb . append (  \"    not   found .  \"  )  ;", "} else", "if    (  !  ( hasLibraries (  )  )  )     {", "sb . append (  \"    doesn ' t   define   any   library .  \"  )  ;", "} else    {", "sb . append (  \"    contains   more   than   one   library .    Please   select   one   of    \"  )  ;", "Joiner . on (  \"  ,     \"  )  . appendTo ( sb ,    candidateLibraries )  ;", "}", "} else    {", "VariantComponent   notMatchingRequirements    =    getNonMatchingLibrary (  )  ;", "if    ( notMatchingRequirements    !  =    null )     {", "sb . append (  \"    contains   a   library   named    '  \"  )  . append ( libraryName )  . append (  \"  '    but   it   doesn ' t   have   any   binary   of   type    \"  )  . append ( binaryType . getSimpleName (  )  )  ;", "} else    {", "sb . append (  \"    does   not   contain   library    '  \"  )  . append ( libraryName )  . append (  \"  '  .    Did   you   want   to   use    \"  )  ;", "if    (  ( candidateLibraries . size (  )  )     =  =     1  )     {", "sb . append ( candidateLibraries . get (  0  )  )  ;", "} else    {", "sb . append (  \" one   of    \"  )  ;", "Joiner . on (  \"  ,     \"  )  . appendTo ( sb ,    candidateLibraries )  ;", "}", "sb . append (  \"  ?  \"  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toResolutionErrorMessage"], "fileName": "org.gradle.api.internal.resolve.LibraryResolutionResult"}, {"methodBody": ["METHOD_START", "{", "return   variantSelector . selectVariants ( selectedLibrary ,    variant )  ;", "}", "METHOD_END"], "methodName": ["chooseMatchingVariants"], "fileName": "org.gradle.api.internal.resolve.LocalLibraryDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "ModelRegistry   projectModel    =    projectModelResolver . resolveProjectModel ( selectorProjectPath )  ;", "Collection < VariantComponent >    candidates    =    librar . resolveCandidates ( projectModel ,    libraryName )  ;", "if    ( candidates . isEmpty (  )  )     {", "return   LibraryResolutionResult . emptyResolutionResult ( binaryType )  ;", "}", "return   LibraryResolutionResult . of ( binaryType ,    candidates ,    libraryName ,    binaryPredicate )  ;", "}    catch    ( UnknownProjectException   e )     {", "return   LibraryResolutionResult . projectNotFound ( binaryType )  ;", "}", "}", "METHOD_END"], "methodName": ["doResolve"], "fileName": "org.gradle.api.internal.resolve.LocalLibraryDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "return   identifier   instanceof   LibraryBinaryIdentifier ;", "}", "METHOD_END"], "methodName": ["isLibrary"], "fileName": "org.gradle.api.internal.resolve.LocalLibraryDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "final   String   selectorProjectPath    =    selector . getProjectPath (  )  ;", "final   String   libraryName    =    selector . getLibraryName (  )  ;", "final   String   variant    =    selector . getVariant (  )  ;", "LibraryResolutionResult   resolutionResult    =    doResolve ( selectorProjectPath ,    libraryName )  ;", "VariantComponent   selectedLibrary    =    resolutionResult . getSelectedLibrary (  )  ;", "if    ( selectedLibrary    =  =    null )     {", "String   message    =    resolutionResult . toResolutionErrorMessage ( selector )  ;", "ModuleVersionResolveException   failure    =    new   ModuleVersionResolveException ( selector ,    new   LibraryResolveException ( message )  )  ;", "result . failed ( failure )  ;", "return ;", "}", "Collection <  ?    extends   Binary >    matchingVariants    =    chooseMatchingVariants ( selectedLibrary ,    variant )  ;", "if    ( matchingVariants . isEmpty (  )  )     {", "Iterable <  ?    extends   Binary >    values    =    selectedLibrary . getVariants (  )  ;", "result . failed ( new   ModuleVersionResolveException ( selector ,    errorMessageBuilder . noCompatibleVariantErrorMessage ( libraryName ,    values )  )  )  ;", "} else", "if    (  ( matchingVariants . size (  )  )     >     1  )     {", "result . failed ( new   ModuleVersionResolveException ( selector ,    errorMessageBuilder . multipleCompatibleVariantsErrorMessage ( libraryName ,    matchingVariants )  )  )  ;", "} else    {", "Binary   selectedBinary    =    matchingVariants . iterator (  )  . next (  )  ;", "internal . component . local . model . LocalComponentMetadata   metaData ;", "if    ( variant    =  =    null )     {", "metaData    =    libraryMetaDataAdapter . createLocalComponentMetaData ( selectedBinary ,    selectorProjectPath ,    false )  ;", "} else    {", "metaData    =    libraryMetaDataAdapter . createLocalComponentMetaData ( selectedBinary ,    selectorProjectPath ,    true )  ;", "}", "result . resolved ( metaData )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveLibraryAndChooseBinary"], "fileName": "org.gradle.api.internal.resolve.LocalLibraryDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "return   AbstractLanguageSourceSet . guessLanguageName ( getTypeName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLanguageName"], "fileName": "org.gradle.language.base.internal.AbstractLanguageSourceSet"}, {"methodBody": ["METHOD_START", "{", "String   language    =    AbstractLanguageSourceSet . LANGUAGES . get ( typeName )  ;", "if    ( language    !  =    null )     {", "return   language ;", "}", "language    =    typeName . replaceAll (  \" LanguageSourceSet $  \"  ,     \"  \"  )  . replaceAll (  \" SourceSet $  \"  ,     \"  \"  )  . replaceAll (  \" Source $  \"  ,     \"  \"  )  . replaceAll (  \" Set $  \"  ,     \"  \"  )  ;", "AbstractLanguageSourceSet . LANGUAGES . put ( typeName ,    language )  ;", "return   language ;", "}", "METHOD_END"], "methodName": ["guessLanguageName"], "fileName": "org.gradle.language.base.internal.AbstractLanguageSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   buildDir ;", "}", "METHOD_END"], "methodName": ["getBuildDir"], "fileName": "org.gradle.language.base.internal.ProjectLayout"}, {"methodBody": ["METHOD_START", "{", "return   projectIdentifier ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.language.base.internal.ProjectLayout"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Compiler < T >  )     ( compiler )  )  ;", "}", "METHOD_END"], "methodName": ["castCompiler"], "fileName": "org.gradle.language.base.internal.compile.CompilerUtil"}, {"methodBody": ["METHOD_START", "{", "return   compilerVersion ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.language.base.internal.compile.VersionAwareCompiler"}, {"methodBody": ["METHOD_START", "{", "Set < LanguageSourceSetInternal >    sourceSetsToCompile    =    getSourcesToCompile ( binary )  ;", "for    ( LanguageTransform <  ?  ,     ?  >    languageTransform    :    prioritizedTransforms )     {", "if    (  !  ( languageTransform . applyToBinary ( binary )  )  )     {", "continue ;", "}", "LanguageSourceSetInternal   sourceSetToCompile ;", "while    (  ( sourceSetToCompile    =    findSourceFor ( languageTransform ,    sourceSetsToCompile )  )     !  =    null )     {", "sourceSetsToCompile . remove ( sourceSetToCompile )  ;", "final   TaskConfig   taskConfig    =    languageTransform . getTransformTask (  )  ;", "String   taskName    =    getTransformTaskName ( languageTransform ,    taskConfig ,    binary ,    sourceSetToCompile )  ;", "Task   task    =    tasks . create ( taskName ,    taskConfig . getTaskType (  )  )  ;", "taskConfig . configureTask ( task ,    binary ,    sourceSetToCompile ,    serviceRegistry )  ;", "task . dependsOn ( sourceSetToCompile )  ;", "binary . getTasks (  )  . add ( task )  ;", "if    (  ( binary . hasCodependentSources (  )  )     &  &     ( taskConfig   instanceof   JointCompileTaskConfig )  )     {", "JointCompileTaskConfig   jointCompileTaskConfig    =     (  ( JointCompileTaskConfig )     ( taskConfig )  )  ;", "Iterator < LanguageSourceSetInternal >    candidateSourceSets    =    sourceSetsToCompile . iterator (  )  ;", "while    ( candidateSourceSets . hasNext (  )  )     {", "LanguageSourceSetInternal   candidate    =    candidateSourceSets . next (  )  ;", "if    ( jointCompileTaskConfig . canTransform ( candidate )  )     {", "jointCompileTaskConfig . configureAdditionalTransform ( task ,    candidate )  ;", "candidateSourceSets . remove (  )  ;", "}", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["createTasksFor"], "fileName": "org.gradle.language.base.internal.model.BinarySourceTransformations"}, {"methodBody": ["METHOD_START", "{", "for    ( LanguageSourceSetInternal   candidate    :    sourceSetsToCompile )     {", "if    ( languag . getSourceSetType (  )  . isInstance ( candidate )  )     {", "return   candidate ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSourceFor"], "fileName": "org.gradle.language.base.internal.model.BinarySourceTransformations"}, {"methodBody": ["METHOD_START", "{", "LinkedHashSet < LanguageSourceSetInternal >    sourceSets    =    Sets . newLinkedHashSet (  )  ;", "for    ( LanguageSourceSet   SourceSet    :    binary . getInputs (  )  )     {", "LanguageSourceSetInternal   SourceSetInternal    =     (  ( LanguageSourceSetInternal )     ( SourceSet )  )  ;", "if    ( SourceSetInternal . getMayHaveSources (  )  )     {", "sourceSets . add ( SourceSetInternal )  ;", "}", "}", "return   sourceSets ;", "}", "METHOD_END"], "methodName": ["getSourcesToCompile"], "fileName": "org.gradle.language.base.internal.model.BinarySourceTransformations"}, {"methodBody": ["METHOD_START", "{", "if    (  ( binary . hasCodependentSources (  )  )     &  &     ( taskConfig   instanceof   JointCompileTaskConfig )  )     {", "return    (  ( taskConfig . getTaskPrefix (  )  )     +     ( StringUtils . capitalize ( binary . getProjectScopedName (  )  )  )  )     +     ( StringUtils . capitalize ( t . getClass (  )  . getSimpleName (  )  )  )  ;", "}", "return    (  ( taskConfig . getTaskPrefix (  )  )     +     ( StringUtils . capitalize ( binary . getProjectScopedName (  )  )  )  )     +     ( StringUtils . capitalize ( sourceSetToCompile . getProjectScopedName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTransformTaskName"], "fileName": "org.gradle.language.base.internal.model.BinarySourceTransformations"}, {"methodBody": ["METHOD_START", "{", "List < LanguageTransform <  ?  ,     ?  >  >    prioritized    =    Lists . newArrayList ( languageTransforms )  ;", "Collections . sort ( prioritized ,    new   Comparator < LanguageTransform <  ?  ,     ?  >  >  (  )     {", "@ Override", "public   int   compare ( LanguageTransform <  ?  ,     ?  >    o 1  ,    LanguageTransform <  ?  ,     ?  >    o 2  )     {", "boolean   joint 1     =     ( o 1  . getTransformTask (  )  )    instanceof   JointCompileTaskConfig ;", "boolean   joint 2     =     ( o 2  . getTransformTask (  )  )    instanceof   JointCompileTaskConfig ;", "return   new   BooleanComparator ( true )  . compare ( joint 1  ,    joint 2  )  ;", "}", "}  )  ;", "return   prioritized ;", "}", "METHOD_END"], "methodName": ["prioritize"], "fileName": "org.gradle.language.base.internal.model.BinarySourceTransformations"}, {"methodBody": ["METHOD_START", "{", "for    ( DependencySpec   dependency    :    dependencies )     {", "addDependency ( dependency ,    projectPath ,    usConfigurationName )  ;", "}", "}", "METHOD_END"], "methodName": ["addDependencies"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Iterable < DependencySpec >  >    entry    :    dependencies . entrySet (  )  )     {", ". addDependenciesToMetadata ( metadata ,    defaultProject ,    entry . getValue (  )  ,    entry . getKey (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDependenciesToMetaData"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "metadata . addDependencies ( value ,    defaultProject ,    configuration )  ;", "}", "METHOD_END"], "methodName": ["addDependenciesToMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "LocalOriginDependencyMetadata   metadata    =     ( dependency   instanceof   ModuleDependencySpec )     ?    moduleDependencyMetadata (  (  ( ModuleDependencySpec )     ( dependency )  )  ,    usageConfigurationName )     :    dependency   instanceof   ProjectDependencySpec    ?    projectDependencyMetadata (  (  ( ProjectDependencySpec )     ( dependency )  )  ,    defaultProject ,    usageConfigurationName )     :    binaryDependencyMetadata (  (  ( LibraryBinaryDependencySpec )     ( dependency )  )  ,    usageConfigurationName )  ;", "getConfiguration ( usageConfigurationName )  . addDependency ( metadata )  ;", "}", "METHOD_END"], "methodName": ["addDependency"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "String   projectPath    =    binarySpec . getProjectPath (  )  ;", "String   libraryName    =    binarySpec . getLibraryName (  )  ;", "ComponentSelector   selector    =    new   ComponentSelector ( projectPath ,    libraryName ,    binarySpec . getVariant (  )  )  ;", "return   dependencyMetadataFor ( selector ,    usageConfigurationName ,    usageConfigurationName )  ;", "}", "METHOD_END"], "methodName": ["binaryDependencyMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "return   new   LocalComponentDependencyMetadata ( new   OpaqueComponentIdentifier (  \" TODO \"  )  ,    selector ,    usageConfigurationName ,    null ,    ImmutableAttributes . EMPTY ,    mappedUsageConfiguration ,    ImmutableList .  < IvyArtifactName > of (  )  ,    DefaultLibraryLocalComponentMetadata . EXCLUDE _ RULES ,    false ,    false ,    true ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["dependencyMetadataFor"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModuleVersionIdentifier ( componentId . getProjectPath (  )  ,    componentId . getLibraryName (  )  ,    DefaultLibraryLocalComponentMetadata . VERSION )  ;", "}", "METHOD_END"], "methodName": ["localModuleVersionIdentifierFor"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "return   DefaultModuleComponentSelector . newSelector ( module . getGroup (  )  ,    module . getName (  )  ,    DefaultModuleDependencySpec . effectiveVersionFor ( module . getVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["moduleComponentSelectorFrom"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "ModuleComponentSelector   selector    =    moduleComponentSelectorFrom ( moduleDependency )  ;", "return   dependencyMetadataFor ( selector ,    usageConfigurationName ,     . CONFIGURATION _ COMPILE )  ;", "}", "METHOD_END"], "methodName": ["moduleDependencyMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "DefaultLibraryLocalComponentMetadata   metaData    =    new   DefaultLibraryLocalComponentMetadata ( DefaultLibraryLocalComponentMetadata . localModuleVersionIdentifierFor ( componentId )  ,    componentId )  ;", "for    ( String   usage    :    usages )     {", "metaData . addConfiguration ( usage ,    String . format (  \" Request   metadata :     % s \"  ,    componentId . getDisplayName (  )  )  ,    Collections .  < String > emptySet (  )  ,    Collections . singleton ( usage )  ,    true ,    true ,    EMPTY ,    true ,    false ,    ImmutableCapabilities . EMPTY )  ;", "}", "return   metaData ;", "}", "METHOD_END"], "methodName": ["newDefaultLibraryLocalComponentMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "DefaultLibraryLocalComponentMetadata   metadata    =    DefaultLibraryLocalComponentMetadata . newDefaultLibraryLocalComponentMetadata ( componentId ,    dependencies . keySet (  )  )  ;", "DefaultLibraryLocalComponentMetadata . addDependenciesToMetaData ( dependencies ,    metadata ,    defaultProject )  ;", "return   metadata ;", "}", "METHOD_END"], "methodName": ["newResolvedLibraryMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "DefaultLibraryLocalComponentMetadata   metadata    =    DefaultLibraryLocalComponentMetadata . newDefaultLibraryLocalComponentMetadata ( componentId ,    Collections . singleton ( usage )  )  ;", "DefaultLibraryLocalComponentMetadata . addDependenciesToMetadata ( metadata ,    componentId . getProjectPath (  )  ,    dependencies ,    usage )  ;", "return   metadata ;", "}", "METHOD_END"], "methodName": ["newResolvingLocalComponentMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "String   projectPath    =    projectDependency . getProjectPath (  )  ;", "if    ( isNullOrEmpty ( projectPath )  )     {", "projectPath    =    defaultProject ;", "}", "String   libraryName    =    projectDependency . getLibraryName (  )  ;", "ComponentSelector   selector    =    new   ComponentSelector ( projectPath ,    libraryName )  ;", "return   dependencyMetadataFor ( selector ,    usageConfigurationName ,    usageConfigurationName )  ;", "}", "METHOD_END"], "methodName": ["projectDependencyMetadata"], "fileName": "org.gradle.language.base.internal.model.DefaultLibraryLocalComponentMetadata"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Class <  <  ?  ,     ?  >  >    rawType    =     (  ( Class <  <  ?  ,     ?  >  >  )     ( new   com . google . common . reflect . TypeToken <  <  ?  ,     ?  >  >  (  )     {  }  . getRawType (  )  )  )  ;", "return   rawType ;", "}", "METHOD_END"], "methodName": ["getLanguageTransformType"], "fileName": "org.gradle.language.base.internal.registry.DefaultLanguageTransformContainer"}, {"methodBody": ["METHOD_START", "{", "return   didWork ;", "}", "METHOD_END"], "methodName": ["getDidWork"], "fileName": "org.gradle.language.base.internal.tasks.SimpleStaleClassCleaner"}, {"methodBody": ["METHOD_START", "{", "return   destinationDir ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.language.base.internal.tasks.StaleClassCleaner"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.language.base.internal.tasks.StaleClassCleaner"}, {"methodBody": ["METHOD_START", "{", "this . destinationDir    =    destinationDir ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.language.base.internal.tasks.StaleClassCleaner"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.gradle.language.base.internal.tasks.StaleClassCleaner"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . createLater ( LifecycleBasePlugin . ASSEMBLE _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   assembleTask )     {", "assembleTask . setDescription (  \" Assembles   the   outputs   of   this   project .  \"  )  ;", "assembleTask . setGroup ( LifecycleBasePlugin . BUILD _ GROUP )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addAssemble"], "fileName": "org.gradle.language.base.plugins.LifecycleBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . createLater ( LifecycleBasePlugin . BUILD _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   buildTask )     {", "buildTask . setDescription (  \" Assembles   and   tests   this   project .  \"  )  ;", "buildTask . setGroup ( LifecycleBasePlugin . BUILD _ GROUP )  ;", "buildTask . dependsOn ( LifecycleBasePlugin . ASSEMBLE _ TASK _ NAME )  ;", "buildTask . dependsOn ( LifecycleBasePlugin . CHECK _ TASK _ NAME )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addBuild"], "fileName": "org.gradle.language.base.plugins.LifecycleBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . createLater ( LifecycleBasePlugin . CHECK _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   checkTask )     {", "checkTask . setDescription (  \" Runs   all   checks .  \"  )  ;", "checkTask . setGroup ( LifecycleBasePlugin . VERIFICATION _ GROUP )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addCheck"], "fileName": "org.gradle.language.base.plugins.LifecycleBasePlugin"}, {"methodBody": ["METHOD_START", "{", "final   Callable < File >    buildDir    =    new   Callable < File >  (  )     {", "public   File   call (  )     {", "return   project . getBuildDir (  )  ;", "}", "}  ;", "final   BuildOutputCleanupRegistry   buildOutputCleanupRegistry    =    project . getServices (  )  . get ( BuildOutputCleanupRegistry . class )  ;", "buildOutputCleanupRegistry . registerOutputs ( buildDir )  ;", "final   Provider < Delete >    clean    =    project . getTasks (  )  . createLater (  . CLEAN _ TASK _ NAME ,    Delete . class ,    new   Action < Delete >  (  )     {", "@ Override", "public   void   execute ( final   Delete   cleanTask )     {", "cleanTask . setDescription (  \" Deletes   the   build   directory .  \"  )  ;", "cleanTask . setGroup (  . BUILD _ GROUP )  ;", "cleanTask . delete ( buildDir )  ;", "}", "}  )  ;", "buildOutputCleanupRegistry . registerOutputs ( new   Callable < FileCollection >  (  )     {", "@ Override", "public   FileCollection   call (  )     {", "return   clean . get (  )  . getTargetFiles (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addClean"], "fileName": "org.gradle.language.base.plugins.LifecycleBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . addRule ( new   CleanRule ( project . getTasks (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addCleanRule"], "fileName": "org.gradle.language.base.plugins.LifecycleBasePlugin"}, {"methodBody": ["METHOD_START", "{", "BaseLanguageSourceSet . NEXT _ SOURCE _ SET _ INFO . set ( new   BaseLanguageSourceSet . SourceSetInfo ( componentId ,    publicType ,    sourceDirectorySetFactory )  )  ;", "try    {", "try    {", "return   INSTANCE . newInstance ( implementationType )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "throw   new   ModelInstantiationException ( String . format (  \" Could   not   create   LanguageSourceSet   of   type    % s \"  ,    publicType . getSimpleName (  )  )  ,    e . getCause (  )  )  ;", "}", "}    finally    {", "BaseLanguageSourceSet . NEXT _ SOURCE _ SET _ INFO . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.language.base.sources.BaseLanguageSourceSet"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )     {", "throw   new   ModelInstantiationException (  \" Direct   instantiation   of   a      is   not   permitted .    Use   a    @ ComponentType   rule   instead .  \"  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.language.base.sources.BaseLanguageSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   uncheckedCast ( collection . matching ( Specs . isInstance ( type )  )  )  ;", "}", "METHOD_END"], "methodName": ["toNonSubtype"], "fileName": "org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "DomainObjectCollection < S >    cast    =    toNonSubtype ( type )  ;", "Namer < S >    castNamer    =    Cast . uncheckedCast ( namer )  ;", "return    . wrap ( name ,    type ,    cast ,    NamedEntityInstantiators . nonSubtype ( type ,    elementType )  ,    castNamer ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["toNonSubtypeMap"], "fileName": "org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "NamedEntityInstantiator < S >    instantiator    =    uncheckedCast ( this . instantiator )  ;", "return    . wrap ( name ,    itemSubtype ,    collection . withType ( itemSubtype )  ,    instantiator ,    namer ,    onCreateAction )  ;", "}", "METHOD_END"], "methodName": ["toSubtypeMap"], "fileName": "org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "return   new   DomainObjectCollectionBackedModelMap < T >  ( name ,    elementType ,    domainObjectSet ,    instantiator ,    namer ,    onCreate )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap"}, {"methodBody": ["METHOD_START", "{", "BaseBinarySpec . NEXT _ BINARY _ INFO . set ( new   BaseBinarySpec . BinaryInfo ( componentId ,    publicType ,    modelNode ,    componentNode ,    taskFactory ,    instantiator )  )  ;", "try    {", "try    {", "return   INSTANCE . newInstance ( implementationType )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "throw   new   ModelInstantiationException ( String . format (  \" Could   not   create   binary   of   type    % s \"  ,    publicType . getSimpleName (  )  )  ,    e . getCause (  )  )  ;", "}", "}    finally    {", "BaseBinarySpec . NEXT _ BINARY _ INFO . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   new   FixedBuildAbility ( true )  ;", "}", "METHOD_END"], "methodName": ["getBinaryBuildAbility"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compontNod    =  =    null )     {", "rurn   null ;", "}", "ModTypT >    modTyp =    ModTypof ( compontTyp ;", "rurn   compontNodcanBiAs ( modTyp    ?    compontNodasImmutablmodTyp   compontNodgDcriptor (  )  )  . gInstanc )     :    null ;", "}", "METHOD_END"], "methodName": ["getComponentAs"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "ComponentSpec   component    =    getComponent (  )  ;", "return   component    !  =    null    ?    component . getName (  )     :    null ;", "}", "METHOD_END"], "methodName": ["parentComponentName"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "switch    ( dirs . size (  )  )     {", "c    0     :", "dirs . add ( dir )  ;", "break ;", "c    1     :", "dirs . clear (  )  ;", "dirs . add ( dir )  ;", "break ;", "default    :", "throw   new   IllegalStateException (  \" Can ' t   replace   multiple   directories .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceSingleDirectory"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )     {", "throw   new   ModelInstantiationException (  \" Direct   instantiation   of   a      is   not   permitted .    Use   a    @ ComponentType   rule   instead .  \"  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.platform.base.binary.BaseBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   publicType . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.gradle.platform.base.component.internal.AbstractComponentSpec"}, {"methodBody": ["METHOD_START", "{", "MutableModelNode   grandparentNode    =    modelNode . getParent (  )  . getParent (  )  ;", "if    (  ( grandparentNode    !  =    null )     &  &     ( grandparentNode . canBeViewedAs ( ModelType . of ( Internal . class )  )  )  )     {", "return   grandparentNode ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findOwner"], "fileName": "org.gradle.platform.base.component.internal.ComponentSpecFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( ownerNode    !  =    null )     {", "Internal   componentSpec    =    ownerNode . asImmutable ( ModelType . of ( Internal . class )  ,    null )  . getInstance (  )  ;", "return   componentSpec . getIdentifier (  )  . child ( name )  ;", "}", "return   new   DefaultIdentifier ( projectIdentifier . getPath (  )  ,    name )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.platform.base.component.internal.ComponentSpecFactory"}, {"methodBody": ["METHOD_START", "{", "DefaultComponentSpec . NEXT _ COMPONENT _ INFO . set ( new   DefaultComponentSpec . ComponentInfo ( identifier ,    modelNode ,    publicType )  )  ;", "try    {", "try    {", "return   INSTANCE . newInstance ( implementationType )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "throw   new   ModelInstantiationException ( String . format (  \" Could   not   create   component   of   type    % s \"  ,    publicType . getSimpleName (  )  )  ,    e . getCause (  )  )  ;", "}", "}    finally    {", "DefaultComponentSpec . NEXT _ COMPONENT _ INFO . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.platform.base.component.internal.DefaultComponentSpec"}, {"methodBody": ["METHOD_START", "{", "return   DefaultComponentSpec . NEXT _ COMPONENT _ INFO . get (  )  ;", "}", "METHOD_END"], "methodName": ["getInfo"], "fileName": "org.gradle.platform.base.component.internal.DefaultComponentSpec"}, {"methodBody": ["METHOD_START", "{", "if    ( info    =  =    null )     {", "throw   new   ModelInstantiationException (  \" Direct   instantiation   of   a   Base   is   not   permitted .    Use   a    @ ComponentType   rule   instead .  \"  )  ;", "}", "return   info ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.platform.base.component.internal.DefaultComponentSpec"}, {"methodBody": ["METHOD_START", "{", "DomainObjectSet < T >    tasks    =    withType ( type )  ;", "if    (  ( tasks . size (  )  )     =  =     0  )     {", "return   null ;", "}", "if    (  ( tasks . size (  )  )     >     1  )     {", "throw   new   UnknownDomainObjectException ( String . format (  \" Multiple   tasks   with   type    '  % s '    found .  \"  ,    type . getSimpleName (  )  )  )  ;", "}", "return   tasks . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["findSingleTaskWithType"], "fileName": "org.gradle.platform.base.internal.BinaryTasksCollectionWrapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( word . length (  )  )     =  =     0  )     {", "return ;", "}", "builder . append ( Character . toTitleC ( word . charAt (  0  )  )  )  . append ( word . substring (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["appendCapitalized"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "if    (  ( word . length (  )  )     =  =     0  )     {", "return ;", "}", "builder . append ( Character . toLowerC ( word . charAt (  0  )  )  )  . append ( word . substring (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["appendUncapitalized"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBinaryNamingScheme ( componentName ,    null ,    null ,    null ,    false ,    Collections .  < String > emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["component"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "if    ( dimensions . isEmpty (  )  )     {", "return    \"  \"  ;", "}", "return   makee ( dimensions . toArray ( new   String [  0  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["createPrefix"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   parentName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "List < String >    elements    =    Lists . newArrayList (  )  ;", "elements . add ( outputType )  ;", "elements . add ( parentName )  ;", "if    (  ( be )     !  =    null )     {", "elements . add ( be )  ;", "} else    {", "if    (  !  ( main )  )     {", "if    (  ( role )     !  =    null )     {", "elements . add ( role )  ;", "} else    {", "elements . add ( binaryType )  ;", "}", "}", "elements . addAll ( dimensions )  ;", "}", "return   makePath ( elements )  ;", "}", "METHOD_END"], "methodName": ["getOutputDirectoryBase"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "int   expectedLength    =     0  ;", "for    ( String   word    :    words )     {", "if    ( word    !  =    null )     {", "expectedLength    +  =    word . length (  )  ;", "}", "}", "StringBuilder   builder    =    new   StringBuilder ( expectedLength )  ;", "for    ( String   word    :    words )     {", "if    (  ( word    =  =    null )     |  |     (  ( word . length (  )  )     =  =     0  )  )     {", "continue ;", "}", "if    (  ( builder . length (  )  )     =  =     0  )     {", "appendUncapitalized ( builder ,    word )  ;", "} else    {", "appendCapitalized ( builder ,    word )  ;", "}", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["makeName"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "int   expectedLength    =     0  ;", "for    ( String   word    :    words )     {", "if    ( word    !  =    null )     {", "expectedLength    +  =     ( word . length (  )  )     +     1  ;", "}", "}", "StringBuilder   builder    =    new   StringBuilder ( expectedLength )  ;", "for    ( String   word    :    words )     {", "if    (  ( word    =  =    null )     |  |     (  ( word . length (  )  )     =  =     0  )  )     {", "continue ;", "}", "if    (  ( builder . length (  )  )     >     0  )     {", "builder . append (  '  /  '  )  ;", "}", "appendUncapitalized ( builder ,    word )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["makePath"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "int   expectedLength    =     0  ;", "for    ( String   word    :    words )     {", "if    ( word    !  =    null )     {", "expectedLength    +  =     ( word . length (  )  )     +     1  ;", "}", "}", "StringBuilder   builder    =    new   StringBuilder ( expectedLength )  ;", "for    ( String   word    :    words )     {", "if    (  ( word    =  =    null )     |  |     (  ( word . length (  )  )     =  =     0  )  )     {", "continue ;", "}", "if    (  ( builder . length (  )  )     >     0  )     {", "builder . append (  '  :  '  )  ;", "}", "appendUncapitalized ( builder ,    word )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["makeSeparated"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "DomainObjectSet < T >    tasks    =    withType ( type )  ;", "if    (  ( tasks . size (  )  )     =  =     0  )     {", "return   null ;", "}", "if    (  ( tasks . size (  )  )     >     1  )     {", "throw   new   UnknownDomainObjectException ( String . format (  \" Multiple   tasks   with   type    '  % s '    found .  \"  ,    type . getSimpleName (  )  )  )  ;", "}", "return   tasks . iterator (  )  . next (  )  ;", "}", "METHOD_END"], "methodName": ["findSingleTaskWithType"], "fileName": "org.gradle.platform.base.internal.DefaultBinaryTasksCollection"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     =  =    null    ?    name    :     (  ( parent . getQualifiedPath (  )  )     +     ( Project . PATH _ SEPARATOR )  )     +     ( name )  ;", "}", "METHOD_END"], "methodName": ["getQualifiedPath"], "fileName": "org.gradle.platform.base.internal.DefaultComponentSpecIdentifier"}, {"methodBody": ["METHOD_START", "{", "builders . add ( builder )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.platform.base.internal.DefaultDependencySpecContainer"}, {"methodBody": ["METHOD_START", "{", "ImmutableSet . Builder < DependencySpec >    specs    =    ImmutableSet . builder (  )  ;", "for    ( DependencySpecBuilder   specBuilder    :    builders )     {", "specs . add ( specBuilder . build (  )  )  ;", "}", "return   specs . build (  )  ;", "}", "METHOD_END"], "methodName": ["dependencySpecSet"], "fileName": "org.gradle.platform.base.internal.DefaultDependencySpecContainer"}, {"methodBody": ["METHOD_START", "{", "return   add ( new   DefaultModuleDependencySpec . Builder (  )  )  ;", "}", "METHOD_END"], "methodName": ["moduleDependency"], "fileName": "org.gradle.platform.base.internal.DefaultDependencySpecContainer"}, {"methodBody": ["METHOD_START", "{", "return   add ( new   DefaultProjectDependencySpec . Builder (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectDependency"], "fileName": "org.gradle.platform.base.internal.DefaultDependencySpecContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultLibraryBinaryDependencySpec ( id . getProjectPath (  )  ,    id . getLibraryName (  )  ,    id . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.platform.base.internal.DefaultLibraryBinaryDependencySpec"}, {"methodBody": ["METHOD_START", "{", "return   isNullOrEmpty ( version )     ?     \"  +  \"     :    version ;", "}", "METHOD_END"], "methodName": ["effectiveVersionFor"], "fileName": "org.gradle.platform.base.internal.DefaultModuleDependencySpec"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPlatformRequirement ( name )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.platform.base.internal.DefaultPlatformRequirement"}, {"methodBody": ["METHOD_START", "{", "final   String   target    =    platformRequirement . getPlatformName (  )  ;", "NamedDomainObjectSet < T >    allWithType    =    platforms . withType ( type )  ;", "T   matching    =    CollectionUtils . findFirst ( allWithType ,    new   api . specs . Spec < T >  (  )     {", "public   boolean   isSatisfiedBy ( T   element )     {", "return   element . getName (  )  . equals ( target )  ;", "}", "}  )  ;", "if    ( matching    =  =    null )     {", "throw   new   InvalidUserDataException ( String . format (  \" Invalid    % s :     % s \"  ,    type . getSimpleName (  )  ,    target )  )  ;", "}", "return   matching ;", "}", "METHOD_END"], "methodName": ["resolveFromContainer"], "fileName": "org.gradle.platform.base.internal.DefaultPlatformResolvers"}, {"methodBody": ["METHOD_START", "{", "return   dimensions ;", "}", "METHOD_END"], "methodName": ["getDimensions"], "fileName": "org.gradle.platform.base.internal.VariantAspect"}, {"methodBody": ["METHOD_START", "{", "return   new   InvalidManagedModelElementTypeException ( extractionContext ,    String . format (  \"  % s    ( invalid   property :     % s )  \"  ,    message ,    property . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidProperty"], "fileName": "org.gradle.platform.base.internal.VariantAspectExtractionStrategy"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isTestSuite"], "fileName": "org.gradle.platform.base.internal.dependents.AbstractDependentBinariesResolutionStrategy"}, {"methodBody": ["METHOD_START", "{", "DependentBinariesResolvedResult   first    =    results . iterator (  )  . next (  )  ;", "if    (  ( results . size (  )  )     =  =     1  )     {", "return   first ;", "}", "boolean   hasNotBuildables    =    false ;", "boolean   hasTestSuites    =    false ;", "LinkedListMultimap < LibraryBinaryIdentifier ,    DependentBinariesResolvedResult >    index    =    LinkedListMultimap . create (  )  ;", "List < DependentBinariesResolvedResult >    allChildren    =    Lists . newArrayList (  )  ;", "for    ( DependentBinariesResolvedResult   result    :    results )     {", "if    (  !  ( result . isBuildable (  )  )  )     {", "hasNotBuildables    =    true ;", "}", "if    ( result . isTestSuite (  )  )     {", "hasTestSuites    =    true ;", "}", "allChildren . addAll ( result . getChildren (  )  )  ;", "for    ( DependentBinariesResolvedResult   child    :    result . getChildren (  )  )     {", "index . put ( child . getId (  )  ,    child )  ;", "}", "}", "List < DependentBinariesResolvedResult >    children    =    Lists . newArrayList (  )  ;", "for    ( Collection < DependentBinariesResolvedResult >    childResults    :    index . asMap (  )  . values (  )  )     {", "children . add ( mergeResults ( childResults )  )  ;", "}", "return   new   dResult ( first . getId (  )  ,    first . getProjectScopedName (  )  ,     (  ! hasNotBuildables )  ,    hasTestSuites ,    children )  ;", "}", "METHOD_END"], "methodName": ["mergeResults"], "fileName": "org.gradle.platform.base.internal.dependents.DefaultDependentBinariesResolver"}, {"methodBody": ["METHOD_START", "{", "return   ModelType . of ( ModelMap . class )  . isAssignableFrom ( modelType )  ;", "}", "METHOD_END"], "methodName": ["isModelMap"], "fileName": "org.gradle.platform.base.internal.registry.AbstractAnnotationDrivenComponentModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ruleDefinition . getReferences (  )  . isEmpty (  )  )     &  &     ( problems . hasProblems (  )  )  )     {", "return ;", "}", "List < ModelReference <  ?  >  >    references    =    ruleDefinition . getReferences (  )  ;", "ModelType <  ?    extends   S >    dependency    =    null ;", "for    ( ModelReference <  ?  >    reference    :    references )     {", "if    ( expectedDependency . isAssignableFrom ( reference . getType (  )  )  )     {", "if    ( dependency    !  =    null )     {", "problems . add ( ruleDefinition ,    String . format (  \" A   method    % s   must   have   one   parameter   extending    % s .    Found   multiple   parameter   extending    % s .  \"  ,     . getDescription (  )  ,    expectedDependency . getDisplayName (  )  ,    expectedDependency . getDisplayName (  )  )  )  ;", "return ;", "}", "dependency    =    reference . getType (  )  . asSubtype ( expectedDependency )  ;", "}", "}", "if    ( dependency    =  =    null )     {", "problems . add ( ruleDefinition ,    String . format (  \" A   method    % s   must   have   one   parameter   extending    % s .    Found   no   parameter   extending    % s .  \"  ,     . getDescription (  )  ,    expectedDependency . getDisplayName (  )  ,    expectedDependency . getDisplayName (  )  )  )  ;", "return ;", "}", "dataCollector . put ( expectedDependency ,    dependency )  ;", "}", "METHOD_END"], "methodName": ["visitDependency"], "fileName": "org.gradle.platform.base.internal.registry.AbstractAnnotationDrivenComponentModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ruleDefinition . getReferences (  )  . size (  )  )     =  =     0  )     {", "problems . add ( ruleDefinition ,     (  (  \" A   method    \"     +     (  . getDescription (  )  )  )     +     \"    must   have   at   least   two   parameters .  \"  )  )  ;", "return ;", "}", "ModelType <  ?  >    subjectType    =    ruleDefinition . getSubjectReference (  )  . getType (  )  ;", "if    (  !  ( isModelMap ( subjectType )  )  )     {", "problems . add ( ruleDefinition ,    String . format (  \" The   first   parameter   of   a   method    % s   must   be   of   type    % s .  \"  ,     . getDescription (  )  ,    ModelMap . class . getName (  )  )  )  ;", "return ;", "}", "List < ModelType <  ?  >  >    typeVariables    =    subjectType . getTypeVariables (  )  ;", "if    (  ( typeVariables . size (  )  )     !  =     1  )     {", "problems . add ( ruleDefinition ,    String . format (  \" Parameter   of   type    % s   must   declare   a   type   parameter   extending    % s .  \"  ,    ModelMap . class . getSimpleName (  )  ,    typeParameter . getDisplayName (  )  )  )  ;", "return ;", "}", "ModelType <  ?  >    elementType    =    typeVariables . get (  0  )  ;", "if    ( elementType . isWildcard (  )  )     {", "problems . add ( ruleDefinition ,    String . format (  \"  % s   type    % s   cannot   be   a   wildcard   type    ( i . e .    cannot   use    ?    super ,     ?    extends   etc .  )  .  \"  ,    typeParameter . getDisplayName (  )  ,    elementType . getDisplayName (  )  )  )  ;", "return ;", "}", "dataCollector . parameterTypes . put ( typeParameter ,    elementType )  ;", "}", "METHOD_END"], "methodName": ["visitSubject"], "fileName": "org.gradle.platform.base.internal.registry.AbstractAnnotationDrivenComponentModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "AbstractAnnotationDrivenComponentModelRuleExtractor < BinaryTasks >  . RuleMethodDataCollector   dataCollector    =    new   RuleMethodDataCollector (  )  ;", "verifyMethodSignature ( dataCollector ,    ruleDefinition ,    problems )  ;", "if    ( problems . hasProblems (  )  )     {", "return   null ;", "}", "ModelType < S >    binaryType    =    dataCollector . getParameterType (  . BINARY _ SPEC )  ;", "return   new    . ExtractedBinaryTasksRule < S >  ( ruleDefinition ,    binaryType )  ;", "}", "METHOD_END"], "methodName": ["createRegistration"], "fileName": "org.gradle.platform.base.internal.registry.BinaryTasksModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "validateIsVoidMethod ( ruleDefinition ,    problems )  ;", "visitSubject ( taskDataCollector ,    ruleDefinition ,     . TASK ,    problems )  ;", "visitDependency ( taskDataCollector ,    ruleDefinition ,     . BINARY _ SPEC ,    problems )  ;", "}", "METHOD_END"], "methodName": ["verifyMethodSignature"], "fileName": "org.gradle.platform.base.internal.registry.BinaryTasksModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "AbstractAnnotationDrivenComponentModelRuleExtractor < ComponentBinaries >  . RuleMethodDataCollector   dataCollector    =    new   RuleMethodDataCollector (  )  ;", "visitAndVerifyMethodSignature ( dataCollector ,    ruleDefinition ,    problems )  ;", "if    ( problems . hasProblems (  )  )     {", "return   null ;", "}", "ModelType < S >    binaryType    =    dataCollector . getParameterType (  . BINARY _ SPEC )  ;", "ModelType < C >    componentType    =    dataCollector . getParameterType (  . COMPONENT _ SPEC )  ;", "return   new    . ExtractedComponentBinariesRule < S ,    C >  ( componentType ,    binaryType ,    ruleDefinition )  ;", "}", "METHOD_END"], "methodName": ["createRegistration"], "fileName": "org.gradle.platform.base.internal.registry.ComponentBinariesModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "validateIsVoidMethod ( ruleDefinition ,    problems )  ;", "visitSubject ( dataCollector ,    ruleDefinition ,     . BINARY _ SPEC ,    problems )  ;", "visitDependency ( dataCollector ,    ruleDefinition ,    ModelType . of ( VariantComponentSpec . class )  ,    problems )  ;", "}", "METHOD_END"], "methodName": ["visitAndVerifyMethodSignature"], "fileName": "org.gradle.platform.base.internal.registry.ComponentBinariesModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "if    ( ComponentTypeModelRuleExtractor . LANGUAGE _ SOURCE _ SET _ MODEL _ TYPE . isAssignableFrom ( builtType )  )     {", "return   new   ComponentTypeModelRuleExtractor . ComponentTypeRegistrationInfo (  \" language \"  ,    ComponentTypeModelRuleExtractor . LANGUAGE _ SOURCE _ SET _ MODEL _ TYPE ,    LanguageBasePlugin . class )  ;", "}", "if    ( ComponentTypeModelRuleExtractor . BINARY _ SPEC _ MODEL _ TYPE . isAssignableFrom ( builtType )  )     {", "return   new   ComponentTypeModelRuleExtractor . ComponentTypeRegistrationInfo (  \" binary \"  ,    ComponentTypeModelRuleExtractor . BINARY _ SPEC _ MODEL _ TYPE ,    BinaryBasePlugin . class )  ;", "}", "if    ( ComponentTypeModelRuleExtractor . COMPONENT _ SPEC _ MODEL _ TYPE . isAssignableFrom ( builtType )  )     {", "Class <  ?  >    requiredPlugin    =     (  ( ComponentTypeModelRuleExtractor . SOURCE _ COMPONENT _ SPEC _ MODEL _ TYPE . isAssignableFrom ( builtType )  )     |  |     ( ComponentTypeModelRuleExtractor . VARIANT _ COMPONENT _ SPEC _ MODEL _ TYPE . isAssignableFrom ( builtType )  )  )     ?    ComponentModelBasePlugin . class    :    ComponentBasePlugin . class ;", "return   new   ComponentTypeModelRuleExtractor . ComponentTypeRegistrationInfo (  \" component \"  ,    ComponentTypeModelRuleExtractor . COMPONENT _ SPEC _ MODEL _ TYPE ,    requiredPlugin )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["componentTypeRegistrationInfoFor"], "fileName": "org.gradle.platform.base.internal.registry.ComponentTypeModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "validateInternalViewsAreInterfaces ( builder )  ;", "Class <  ?  >    implementation    =    builder . getDefaultImplementation (  )  ;", "if    ( implementation    =  =    null )     {", "return   null ;", "}", "return   ModelType . of ( implementation )  ;", "}", "METHOD_END"], "methodName": ["determineImplementationType"], "fileName": "org.gradle.platform.base.internal.registry.ComponentTypeModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?  >    internalView    :    builder . getInternalViews (  )  )     {", "if    (  !  ( internalView . isInterface (  )  )  )     {", "throw   new   InvalidModelException ( String . format (  \" Internal   view    % s   must   be   an   interface .  \"  ,    internalView . getName (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateInternalViewsAreInterfaces"], "fileName": "org.gradle.platform.base.internal.registry.ComponentTypeModelRuleExtractor"}, {"methodBody": ["METHOD_START", "{", "Iterable < ModelReference <  ?  >  >    filteredReferences    =    Iterables . filter ( references ,    new   com . google . common . base . Predicate < ModelReference <  ?  >  >  (  )     {", "@ Override", "public   boolean   apply ( ModelReference <  ?  >    element )     {", "return    !  ( element . getType (  )  . equals ( baseType )  )  ;", "}", "}  )  ;", "ImmutableList . Builder < ModelReference <  ?  >  >    allInputs    =    ImmutableList . builder (  )  ;", "allInputs . addAll ( modelReferences )  ;", "allInputs . addAll ( filteredReferences )  ;", "return   allInputs . build (  )  ;", "}", "METHOD_END"], "methodName": ["calculateInputs"], "fileName": "org.gradle.platform.base.internal.registry.ModelMapBasedRule"}, {"methodBody": ["METHOD_START", "{", "List < Object >    ignoredInputsList    =    Arrays . asList ( ignoredInputs )  ;", "Object [  ]    args    =    new   Object [  (  ( inputs . size (  )  )     +     2  )     -     ( ignoredInputs . length )  ]  ;", "args [  0  ]     =    m ;", "args [ baseTypeParameterIndex ]     =    baseTypeParameter ;", "for    ( ModelView <  ?  >    view    :    inputs )     {", "Object   instance    =    view . getInstance (  )  ;", "if    ( ignoredInputsList . contains ( instance )  )     {", "continue ;", "}", "for    ( int   i    =     0  ;    i    <     ( args . length )  ;    i +  +  )     {", "if    (  ( args [ i ]  )     =  =    null )     {", "args [ i ]     =    instance ;", "break ;", "}", "}", "}", "ruleInvoker . invoke ( args )  ;", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.gradle.platform.base.internal.registry.ModelMapBasedRule"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.gradle.platform.base.internal.toolchain.ComponentFound"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "org.gradle.platform.base.internal.toolchain.ComponentFound"}, {"methodBody": ["METHOD_START", "{", "visitor . node ( message )  ;", "if    (  !  ( locations . isEmpty (  )  )  )     {", "visitor . startChildren (  )  ;", "( String   location    :    locations )     {", "visitor . node ( location )  ;", "}", "visitor . endChildren (  )  ;", "}", "}", "METHOD_END"], "methodName": ["explain"], "fileName": "org.gradle.platform.base.internal.toolchain.ComponentNotFound"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.gradle.platform.base.internal.toolchain.ComponentNotFound"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "org.gradle.platform.base.internal.toolchain.ComponentNotFound"}, {"methodBody": ["METHOD_START", "{", "TreeFormatter   formatter    =    new   TreeFormatter (  )  ;", "this . explain ( formatter )  ;", "return   formatter . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getUnavailableMessage"], "fileName": "org.gradle.platform.base.internal.toolchain.ToolChainAvailability"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( tool . isAvailable (  )  )  )     &  &     (  ( reason )     =  =    null )  )     {", "reason    =    tool ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["mustBeAvailable"], "fileName": "org.gradle.platform.base.internal.toolchain.ToolChainAvailability"}, {"methodBody": ["METHOD_START", "{", "if    (  ( reason )     =  =    null )     {", "reason    =    new    . FixedMessageToolSearchResult ( unavailableMessage )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["unavailable"], "fileName": "org.gradle.platform.base.internal.toolchain.ToolChainAvailability"}]