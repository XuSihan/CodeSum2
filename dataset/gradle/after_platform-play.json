[{"methodBody": ["METHOD_START", "{", "return   PlayPlatformNotationParser . BUILDER ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.gradle.play.internal.PlayPlatformNotationParser"}, {"methodBody": ["METHOD_START", "{", "return   PlayPlatformNotationParser . builder (  )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.play.internal.PlayPlatformNotationParser"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \" play -  \"  )  ;", "builder . append ( playVersion )  ;", "if    ( scalaVersion    !  =    null )     {", "builder . append (  \"  -  \"  )  ;", "builder . append ( scalaVersion )  ;", "}", "if    ( javaVersion    !  =    null )     {", "builder . append (  \"  _  \"  )  ;", "builder . append ( javaVersion )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createName"], "fileName": "org.gradle.play.internal.PlayPlatformRequirement"}, {"methodBody": ["METHOD_START", "{", "return   javaVersion ;", "}", "METHOD_END"], "methodName": ["getJavaVersion"], "fileName": "org.gradle.play.internal.PlayPlatformRequirement"}, {"methodBody": ["METHOD_START", "{", "return   playVersion ;", "}", "METHOD_END"], "methodName": ["getPlayVersion"], "fileName": "org.gradle.play.internal.PlayPlatformRequirement"}, {"methodBody": ["METHOD_START", "{", "return   scalaVersion ;", "}", "METHOD_END"], "methodName": ["getScalaVersion"], "fileName": "org.gradle.play.internal.PlayPlatformRequirement"}, {"methodBody": ["METHOD_START", "{", "String   latestVersion    =    PlayPlatformResolver . LATEST _ SCALA _ VERSIONS . get ( compatibilityVersion )  ;", "if    ( latestVersion    !  =    null )     {", "return   new   DefaultScalaPlatform ( latestVersion )  ;", "}", "throw   new   InvalidUserDataException ( String . format (  \" Not   a   supported   Scala   platform   identifier    % s .    Supported   values   are :     [  % s ]  .  \"  ,    compatibilityVersion ,    CollectionUtils . join (  \"  ,     \"  ,    PlayPlatformResolver . LATEST _ SCALA _ VERSIONS . keySet (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createScalaPlatform"], "fileName": "org.gradle.play.internal.PlayPlatformResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( preferredJavaVersion    !  =    null )     {", "return   new   jvm . platform . internal . DefaultJavaPlatform ( JavaVersion . toVersion ( preferredJavaVersion )  )  ;", "}", "return   new   jvm . platform . internal . DefaultJavaPlatform ( JavaVersion . current (  )  )  ;", "}", "METHOD_END"], "methodName": ["getJavaPlatform"], "fileName": "org.gradle.play.internal.PlayPlatformResolver"}, {"methodBody": ["METHOD_START", "{", "String   scalaVersion    =    GUtil . elvis ( preferredScalaVersion ,    playMajorVersion . getDefaultScalaPlatform (  )  )  ;", "ScalaPlatform   scalaPlatform    =    createScalaPlatform ( scalaVersion )  ;", "playMajorVersion . validateCompatible ( scalaPlatform )  ;", "return   scalaPlatform ;", "}", "METHOD_END"], "methodName": ["getScalaPlatform"], "fileName": "org.gradle.play.internal.PlayPlatformResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( playPlatformName . startsWith (  \" play -  \"  )  )     {", "return   playPlatformName . substring (  5  )  ;", "}", "throw   new   InvalidUserDataException ( String . format (  \" Not   a   valid   Play   platform :     % s .  \"  ,    playPlatformName )  )  ;", "}", "METHOD_END"], "methodName": ["parsePlayVersionFromPlatformName"], "fileName": "org.gradle.play.internal.PlayPlatformResolver"}, {"methodBody": ["METHOD_START", "{", "PlayMajorVersion   playMajorVersion    =    PlayMajorVersion . forPlayVersion ( playVersion )  ;", "JavaPlatform   javaPlatform    =    getJavaPlatform ( javaVersion )  ;", "ScalaPlatform   scalaPlatform    =    getScalaPlatform ( playMajorVersion ,    scalaVersion )  ;", "return   new   Default ( name ,    playVersion ,    scalaPlatform ,    javaPlatform )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.play.internal.PlayPlatformResolver"}, {"methodBody": ["METHOD_START", "{", "List < String >    errors    =    Lists . newArrayList (  )  ;", "loadCompilerClasses ( getClass (  )  . getClassLoader (  )  )  ;", "JavaMethod <  ?  ,    Object >    fromCodeJavaMethod    =    JavaReflectionUtil . staticMethod ( sourceFileClass ,    Object . class ,     \" fromCode \"  ,    String . class ,    String . class )  ;", "Object   extern    =    fromCodeJavaMethod . invokeStatic (  \"  / dev / null \"  ,     \"  \"  )  ;", "JavaMethod <  ?  ,    Object >    fromFileJavaMethod    =    JavaReflectionUtil . staticMethod ( sourceFileClass ,    Object . class ,     \" fromFile \"  ,    File . class )  ;", "Object   sourceFile    =    fromFileJavaMethod . invokeStatic ( File . getFile (  )  )  ;", "Object   compilerOptions    =    INSTANCE . newInstance ( compilerOptionsClass )  ;", "@ SuppressWarnings (  {     \" rawtypes \"  ,     \" unchecked \"     }  )", "Enum   simpleLevel    =    Enum . valueOf ( compilationLevelClass ,     \" SIMPLE _ OPTIMIZATIONS \"  )  ;", "@ SuppressWarnings (  \" rawtypes \"  )", "JavaMethod < Enum ,    Void >    setOptionsForCompilationLevelMethod    =    JavaReflectionUtil . method ( compilationLevelClass ,    Void . class ,     \" setOptionsForCompilationLevel \"  ,    compilerOptionsClass )  ;", "setOptionsForCompilationLevelMethod . invoke ( simpleLevel ,    compilerOptions )  ;", "Object   compiler    =    INSTANCE . newInstance ( compilerClass ,    getDummyPrintStream (  )  )  ;", "JavaMethod < Object ,    Object >    compileMethod    =    JavaReflectionUtil . method ( compilerClass ,    Object . class ,     \" compile \"  ,    sourceFileClass ,    sourceFileClass ,    compilerOptionsClass )  ;", "Object   result    =    compileMethod . invoke ( compiler ,    extern ,    sourceFile ,    compilerOptions )  ;", "PropertyAccessor < Object ,    Object [  ]  >    jsErrorsField    =    JavaReflectionUtil . readableField ( result ,    Object [  ]  . class ,     \" errors \"  )  ;", "Object [  ]    jsErrors    =    jsErrorsField . getValue ( result )  ;", "if    (  ( jsErrors . length )     =  =     0  )     {", "JavaMethod < Object ,    String >    toSourceMethod    =    JavaReflectionUtil . method ( compilerClass ,    String . class ,     \" toSource \"  )  ;", "String   compiledSource    =    toSourceMethod . invoke ( compiler )  ;", "GFileUtils . writeFile ( compiledSource ,    destinationCalculator . transform ( File )  )  ;", "} else    {", "for    ( Object   error    :    jsErrors )     {", "errors . add ( error . toString (  )  )  ;", "}", "}", "return   errors ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.play.internal.javascript.GoogleClosureCompiler"}, {"methodBody": ["METHOD_START", "{", "return   GoogleClosureCompiler . SHARED _ PACKAGES ;", "}", "METHOD_END"], "methodName": ["getClassLoaderPackages"], "fileName": "org.gradle.play.internal.javascript.GoogleClosureCompiler"}, {"methodBody": ["METHOD_START", "{", "return    \" com . google . javascript : closure - compiler :  \"     +     ( GoogleClosureCompiler . DEFAULT _ GOOGLE _ CLOSURE _ VERSION )  ;", "}", "METHOD_END"], "methodName": ["getDependencyNotation"], "fileName": "org.gradle.play.internal.javascript.GoogleClosureCompiler"}, {"methodBody": ["METHOD_START", "{", "OutputStream   os    =    new   OutputStream (  )     {", "@ Override", "public   void   write (    b )    throws   IOException    {", "}", "}  ;", "return   new   PrStream ( os )  ;", "}", "METHOD_END"], "methodName": ["getDummyPrintStream"], "fileName": "org.gradle.play.internal.javascript.GoogleClosureCompiler"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( sourceFileClass )     =  =    null )     {", "sourceFileClass    =    cl . loadClass (  \" com . googlejscomp . SourceFile \"  )  ;", "}", "if    (  ( compilerOptionsClass )     =  =    null )     {", "compilerOptionsClass    =    cl . loadClass (  \" com . googlejscomp . CompilerOptions \"  )  ;", "}", "if    (  ( compilationLevelClass )     =  =    null )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Class < Enum >    clazz    =     (  ( Class < Enum >  )     ( cl . loadClass (  \" com . googlejscomp . CompilationLevel \"  )  )  )  ;", "compilationLevelClass    =    clazz ;", "}", "if    (  ( compilerClass )     =  =    null )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Class < Object >    clazz    =     (  ( Class < Object >  )     ( cl . loadClass (  \" com . googlejscomp . Compiler \"  )  )  )  ;", "compilerClass    =    clazz ;", "}", "}    catch    ( ClassNotFoundException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["loadCompilerClasses"], "fileName": "org.gradle.play.internal.javascript.GoogleClosureCompiler"}, {"methodBody": ["METHOD_START", "{", "int   extIndex    =    fileName . lastIndexOf (  '  .  '  )  ;", "if    ( extIndex    =  =     (  -  1  )  )     {", "return   fileName    +     \"  . min \"  ;", "}", "String   prefix    =    fileName . substring (  0  ,    extIndex )  ;", "String   extension    =    fileName . substring ( extIndex )  ;", "return    ( prefix    +     \"  . min \"  )     +    extension ;", "}", "METHOD_END"], "methodName": ["getMinifiedFileName"], "fileName": "org.gradle.play.internal.javascript.JavaScriptCompileDestinationCalculator"}, {"methodBody": ["METHOD_START", "{", "String   playVersion    =    targetPlatform . getPlayVersion (  )  ;", "return    . forPlayVersion ( playVersion )  ;", "}", "METHOD_END"], "methodName": ["forPlatform"], "fileName": "org.gradle.play.internal.platform.PlayMajorVersion"}, {"methodBody": ["METHOD_START", "{", "VersionNumber   versionNumber    =    VersionNumber . parse ( playVersion )  ;", "if    (  ( versionNumber . getMajor (  )  )     =  =     2  )     {", "if    (  ( versionNumber . getMinor (  )  )     =  =     2  )     {", "DeprecationLogger . nagUserWith (  (  (  \" Play    2  .  2    support    \"     +     ( LoggingDeprecatedFeatureHandler . getDeprecationMessage (  )  )  )     +     \"  .    Please   upgrade   your   Play .  \"  )  )  ;", "}", "int   index    =     ( versionNumber . getMinor (  )  )     -     2  ;", "if    (  ( index    <     0  )     |  |     ( index    >  =     (  . values (  )  . length )  )  )     {", "throw    . invalidVersion ( playVersion )  ;", "}", "return    . values (  )  [ index ]  ;", "}", "throw    . invalidVersion ( playVersion )  ;", "}", "METHOD_END"], "methodName": ["forPlayVersion"], "fileName": "org.gradle.play.internal.platform.PlayMajorVersion"}, {"methodBody": ["METHOD_START", "{", "return   compatibleScalaVersions . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultScalaPlatform"], "fileName": "org.gradle.play.internal.platform.PlayMajorVersion"}, {"methodBody": ["METHOD_START", "{", "return   new   InvalidUserDataException ( String . format (  \" Not   a   supported   Play   version :     % s .    This   plugin   is   compatible   with :     [  % s ]  .  \"  ,    playVersion ,    CollectionUtils . join (  \"  ,     \"  ,    PlayMajorVersion . values (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["invalidVersion"], "fileName": "org.gradle.play.internal.platform.PlayMajorVersion"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( compatibleScalaVersions . contains ( scalaPlatform . getScalaCompatibilityVersion (  )  )  )  )     {", "throw   new   api . InvalidUserDataException ( String . format (  \" Play   versions    % s   are   not   compatible   with   Scala   platform    % s .    Compatible   Scala   platforms   are    % s .  \"  ,    name ,    scalaPlatform . getScalaCompatibilityVersion (  )  ,    compatibleScalaVersions )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateCompatible"], "fileName": "org.gradle.play.internal.platform.PlayMajorVersion"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isGenerateRefReverseRouter"], "fileName": "org.gradle.play.internal.routes.DefaultVersionedRoutesCompilerAdapter"}, {"methodBody": ["METHOD_START", "{", "try    {", "ClassLoader   cl    =    getClass (  )  . getClassLoader (  )  ;", "ScalaMethod   compile    =    adapter . getMethod ( cl )  ;", "Object   ret    =    compile . invoke ( adapter . createParameters ( cl ,    sourceFile ,    spec . getDestinationDir (  )  ,    spec . isJavaProject (  )  ,    spec . isNamespaceReverseRouter (  )  ,    spec . isGenerateReverseRoutes (  )  ,    spec . isInjectedRoutesGenerator (  )  ,    spec . getAdditionalImports (  )  )  )  ;", "if    (  ( ret    !  =    null )     &  &     ( ret   instanceof   Boolean )  )     {", "return    (  ( Boolean )     ( ret )  )  ;", "} else    {", "return   true ;", "}", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Error   invoking   the   Play   routes   compiler .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.play.internal.routes.RoutesCompiler"}, {"methodBody": ["METHOD_START", "{", "return   adapter . getClassLoaderPackages (  )  ;", "}", "METHOD_END"], "methodName": ["getClassLoaderPackages"], "fileName": "org.gradle.play.internal.routes.RoutesCompiler"}, {"methodBody": ["METHOD_START", "{", "return   adapter . getDependencyNotation (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyNotation"], "fileName": "org.gradle.play.internal.routes.RoutesCompiler"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isGenerateForwardsRouter"], "fileName": "org.gradle.play.internal.routes.RoutesCompilerAdapterV24X"}, {"methodBody": ["METHOD_START", "{", "return   new   RoutesCompiler ( RoutesCompilerFactory . createAdapter ( playPlatform )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.play.internal.routes.RoutesCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "String   playVersion    =    playPlatform . getPlayVersion (  )  ;", "String   scalaVersion    =    playPlatform . getScalaPlatform (  )  . getScalaCompatibilityVersion (  )  ;", "switch    ( PlayMajorVersion . forPlatform ( playPlatform )  )     {", "case   PLAY _  2  _  2  _ X    :", "return   new   RoutesCompilerAdapterV 2  2 X ( playVersion )  ;", "case   PLAY _  2  _  3  _ X    :", "return   new   RoutesCompilerAdapterV 2  3 X ( playVersion )  ;", "case   PLAY _  2  _  4  _ X    :", "if    (  ( VersionNumber . parse ( playVersion )  . getMicro (  )  )     <     6  )     {", ". LOGGER . warn (  (  (  \" Asked   to   use   scala   version    \"     +    scalaVersion )     +     \"    on   play    <     2  .  4  .  6  .    Will   have   to   use   the    2  .  1  0    routes   compiler \"  )  )  ;", "scalaVersion    =     \"  2  .  1  0  \"  ;", "}", "return   new   RoutesCompilerAdapterV 2  4 X ( playVersion ,    scalaVersion )  ;", "case   PLAY _  2  _  5  _ X    :", "return   new   RoutesCompilerAdapterV 2  4 X ( playVersion ,    scalaVersion )  ;", "case   PLAY _  2  _  6  _ X    :", "return   new   RoutesCompilerAdapterV 2  4 X ( playVersion ,    scalaVersion )  ;", "default    :", "throw   new   RuntimeException (  (  \" Could   not   create   routes   compile   spec   for   Play   version :     \"     +    playVersion )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAdapter"], "fileName": "org.gradle.play.internal.routes.RoutesCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . findFirst ( assetDirs ,    new   Spec < AssetsClassLoader . AssetDir >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( AssetsClassLoader . AssetDir   assetDir )     {", "return   assetDir . exists ( name )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findResourceInAssetDir"], "fileName": "org.gradle.play.internal.run.AssetsClassLoader"}, {"methodBody": ["METHOD_START", "{", "SoftReference < Closeable >    ref    =    loadersToClose . poll (  )  ;", "while    ( ref    !  =    null )     {", "Closeable   closeable    =    ref . get (  )  ;", "if    ( closeable    !  =    null )     {", "closeable . close (  )  ;", "}", "ref . clear (  )  ;", "ref    =    loadersToClose . poll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["closeOldLoaders"], "fileName": "org.gradle.play.internal.run.DefaultVersionedPlayRunAdapter"}, {"methodBody": ["METHOD_START", "{", "File   docJarFile    =    null ;", "for    ( File   file    :    classpath )     {", "if    ( file . getName (  )  . startsWith (  \"  - docs \"  )  )     {", "docJarFile    =    file ;", "break ;", "}", "}", "return   new   JarFile ( docJarFile )  ;", "}", "METHOD_END"], "methodName": ["findDocumentationJar"], "fileName": "org.gradle.play.internal.run.DefaultVersionedPlayRunAdapter"}, {"methodBody": ["METHOD_START", "{", "final   ClassLoader   previous    =    currentClassloader . getAndSet ( classLoader )  ;", "if    (  ( previous    !  =    null )     &  &     ( previous   instanceof   Closeable )  )     {", "loadersToClose . add ( new   SoftReference < Closeable >  ( Cast . cast ( Closeable . class ,    previous )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["storeClassLoader"], "fileName": "org.gradle.play.internal.run.DefaultVersionedPlayRunAdapter"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayAppStart ( exception )  ;", "}", "METHOD_END"], "methodName": ["failed"], "fileName": "org.gradle.play.internal.run.PlayAppLifecycleUpdate"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayAppReload (  )  ;", "}", "METHOD_END"], "methodName": ["reloadRequested"], "fileName": "org.gradle.play.internal.run.PlayAppLifecycleUpdate"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayAppStart ( address )  ;", "}", "METHOD_END"], "methodName": ["running"], "fileName": "org.gradle.play.internal.run.PlayAppLifecycleUpdate"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayAppStop (  )  ;", "}", "METHOD_END"], "methodName": ["stopped"], "fileName": "org.gradle.play.internal.run.PlayAppLifecycleUpdate"}, {"methodBody": ["METHOD_START", "{", "return   address ;", "}", "METHOD_END"], "methodName": ["getAddress"], "fileName": "org.gradle.play.internal.run.PlayAppStart"}, {"methodBody": ["METHOD_START", "{", "return   exception ;", "}", "METHOD_END"], "methodName": ["getException"], "fileName": "org.gradle.play.internal.run.PlayAppStart"}, {"methodBody": ["METHOD_START", "{", "return    ( exception )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isFailed"], "fileName": "org.gradle.play.internal.run.PlayAppStart"}, {"methodBody": ["METHOD_START", "{", "return    (  ( address )     !  =    null )     &  &     (  ( exception )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.gradle.play.internal.run.PlayAppStart"}, {"methodBody": ["METHOD_START", "{", "return   playAppAddress ;", "}", "METHOD_END"], "methodName": ["getPlayAppAddress"], "fileName": "org.gradle.play.internal.run.PlayApplication"}, {"methodBody": ["METHOD_START", "{", "return    !  ( stopped . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.gradle.play.internal.run.PlayApplication"}, {"methodBody": ["METHOD_START", "{", "workerServer . stop (  )  ;", "waitForEvent ( stopEvent )  ;", "process . waitForStop (  )  ;", "stopped . set ( true )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.play.internal.run.PlayApplication"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   queue . take (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForEvent"], "fileName": "org.gradle.play.internal.run.PlayApplication"}, {"methodBody": ["METHOD_START", "{", "PlayAppStart   playAppStart    =    waitForEvent ( startEvent )  ;", "if    ( playAppStart . isRunning (  )  )     {", "playAppAddress    =    playAppStart . getAddress (  )  ;", "} else    {", "throw   new   GradleException (  \" Unable   to   start   Play   a .  \"  ,    playAppStart . getException (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForRunning"], "fileName": "org.gradle.play.internal.run.PlayApplication"}, {"methodBody": ["METHOD_START", "{", "if    ( isRunning (  )  )     {", "return   p . getPlayAppAddress (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPlayAppAddress"], "fileName": "org.gradle.play.internal.run.PlayApplicationDeploymentHandle"}, {"methodBody": ["METHOD_START", "{", "WorkerProcessBuilder   builder    =    workerFactory . create ( new   PlayWorkerServer ( spec ,    adapter )  )  ;", "builder . setBaseName (  \" Gradle   Play   Worker \"  )  ;", "builder . sharedPackages (  \"  \"  )  ;", "JavaExecHandleBuilder   javaCommand    =    builder . getJavaCommand (  )  ;", "setWorkingDir ( workingDir )  ;", "setMinHeapSize ( spec . getForkOptions (  )  . getMemoryInitialSize (  )  )  ;", "setMaxHeapSize ( spec . getForkOptions (  )  . getMemoryMaximumSize (  )  )  ;", "setJvmArgs ( spec . getForkOptions (  )  . getJvmArgs (  )  )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["createWorkerProcess"], "fileName": "org.gradle.play.internal.run.PlayApplicationRunner"}, {"methodBody": ["METHOD_START", "{", "WorkerProcess   process    =    PlayApplicationRunner . createWorkerProcess ( spec . getProjectPath (  )  ,    workerFactory ,    spec ,    adapter )  ;", "process . start (  )  ;", "PlayRunWorkerServerProtocol   workerServer    =    process . getConnection (  )  . addOutgoing ( PlayRunWorkerServerProtocol . class )  ;", "PlayApplication   playApplication    =    new   PlayApplication ( new   PlayApplicationRunner . PlayClassloaderMonitorDeploymentDecorator ( deployment ,    spec ,    adapter )  ,    workerServer ,    process )  ;", "process . getConnection (  )  . addIncoming ( PlayRunWorkerClientProtocol . class ,    playApplication )  ;", "process . getConnection (  )  . connect (  )  ;", "playApplication . waitForRunning (  )  ;", "return   playApplication ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.play.internal.run.PlayApplicationRunner"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayApplicationRunner ( workerFactory ,    PlayApplicationRunnerFactory . createPlayRunAdapter ( playPlatform )  ,    snapshotter )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.play.internal.run.PlayApplicationRunnerFactory"}, {"methodBody": ["METHOD_START", "{", "switch    ( PlayMajorVersion . forPlatform ( playPlatform )  )     {", "case   PLAY _  2  _  2  _ X    :", "return   new   PlayRunAdapterV 2  2 X (  )  ;", "case   PLAY _  2  _  4  _ X    :", "return   new   PlayRunAdapterV 2  4 X (  )  ;", "case   PLAY _  2  _  5  _ X    :", "return   new   PlayRunAdapterV 2  5 X (  )  ;", "case   PLAY _  2  _  6  _ X    :", "return   new   PlayRunAdapterV 2  6 X (  )  ;", "case   PLAY _  2  _  3  _ X    :", "default    :", "return   new   PlayRunAdapterV 2  3 X (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createPlayRunAdapter"], "fileName": "org.gradle.play.internal.run.PlayApplicationRunnerFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URLClassLoer ( new   URL [  ]  {    assetsJar . toURI (  )  . toURL (  )     }  ,    classLoer )  ;", "}    catch    ( MalformedURLException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createAssetsClassLoader"], "fileName": "org.gradle.play.internal.run.PlayRunAdapterV22X"}, {"methodBody": ["METHOD_START", "{", "try    {", "InetSocketAddress   address    =    start (  )  ;", "return   PlayAppLifecycleUpdate . running ( address )  ;", "}    catch    ( Exception   e )     {", "Logging . getLogger ( this . getClass (  )  )  . error (  \" Failed   to   run   Play \"  ,    e )  ;", "return   PlayAppLifecycleUpdate . failed ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.play.internal.run.PlayWorkerServer"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderUtils . disableUrlConnectionCaching (  )  ;", "final   Thread   thread    =    Thread . currentThread (  )  ;", "final   ClassLoader   previousContextClassLoader    =    thread . getContextClassLoader (  )  ;", "final   ClassLoader   classLoader    =    new   URLClassLoader ( new   DefaultClassPath ( runSpec . getClasspath (  )  )  . getAsURLArray (  )  ,    null )  ;", "thread . setContextClassLoader ( classLoader )  ;", "try    {", "Object   buildDocHandler    =    runAdapter . getBuildDocHandler ( classLoader ,    runSpec . getClasspath (  )  )  ;", "Object   buildLink    =    runAdapter . getBuildLink ( classLoader ,    this ,    runSpec . getProjectPath (  )  ,    runSpec . getApplicationJar (  )  ,    runSpec . getChangingClasspath (  )  ,    runSpec . getAssetsJar (  )  ,    runSpec . getAssetsDirs (  )  )  ;", "return   runAdapter . runDevHttp ( classLoader ,    classLoader ,    buildLink ,    buildDocHandler ,    runSpec . getHttpPort (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    finally    {", "thread . setContextClassLoader ( previousContextClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["startServer"], "fileName": "org.gradle.play.internal.run.PlayWorkerServer"}, {"methodBody": ["METHOD_START", "{", "List < Dependency >    dependencies    =    CollectionUtils . collect ( dependencyNotations ,    new   Transformer < Dependency ,    Object >  (  )     {", "public   Dependency   transform ( Object   dependencyNotation )     {", "return   dependencyHandler . create ( dependencyNotation )  ;", "}", "}  )  ;", "Dependency [  ]    dependenciesArray    =    dependencies . toArray ( new   Dependency [  0  ]  )  ;", "return   configurationContainer . detachedConfiguration ( dependenciesArray )  ;", "}", "METHOD_END"], "methodName": ["resolveToolClasspath"], "fileName": "org.gradle.play.internal.toolchain.DefaultPlayToolChain"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "Compiler < T >    converted    =     (  ( Compiler < T >  )     ( raw )  )  ;", "return   converted ;", "}", "METHOD_END"], "methodName": ["cast"], "fileName": "org.gradle.play.internal.toolchain.DefaultPlayToolProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   adapter . createParameters ( cl ,    sourceFile . getFile (  )  ,    sourceFile . getBaseDir (  )  ,    spec . getDestinationDir (  )  ,    spec . getDefaultImports (  )  ,    format ,    spec . getAdditionalImports (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  \" Error   invoking   Play   Twirl   template   compiler .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["buildCompileArguments"], "fileName": "org.gradle.play.internal.twirl.TwirlCompiler"}, {"methodBody": ["METHOD_START", "{", "Spec < TwirlTemplateFormat >    hasExtension    =    new   Spec < TwirlTemplateFormat >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( TwirlTemplateFormat   format )     {", "return   FileUtils . hasExtensionIgnoresCase ( sourceFile . getName (  )  ,     (  \"  .  \"     +     ( format . getExtension (  )  )  )  )  ;", "}", "}  ;", "TwirlTemplateFormat   format    =    CollectionUtils . findFirst ( adapter . getDefaultTemplateFormats (  )  ,    hasExtension )  ;", "if    ( format    =  =    null )     {", "format    =    CollectionUtils . findFirst ( spec . getUserTemplateFormats (  )  ,    hasExtension )  ;", "}", "Preconditions . checkNotNull ( format ,     \" Twirl   c   could   not   find   a   matching   template   for    '  % s '  .  \"  ,    sourceFile . getName (  )  )  ;", "return   format ;", "}", "METHOD_END"], "methodName": ["findTemplateFormat"], "fileName": "org.gradle.play.internal.twirl.TwirlCompiler"}, {"methodBody": ["METHOD_START", "{", "return   adapter . getClassLoaderPackages (  )  ;", "}", "METHOD_END"], "methodName": ["getClassLoaderPackages"], "fileName": "org.gradle.play.internal.twirl.TwirlCompiler"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   adapter . getMethod ( cl )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RuntimeException (  \" Error   invoking   Play   Twirl   template   compiler .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getCompileMethod"], "fileName": "org.gradle.play.internal.twirl.TwirlCompiler"}, {"methodBody": ["METHOD_START", "{", "return   adapter . getDependencyNotation (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyNotation"], "fileName": "org.gradle.play.internal.twirl.TwirlCompiler"}, {"methodBody": ["METHOD_START", "{", "if    ( twirlImports    =  =     ( TwirlImports . JAVA )  )     {", "return   getDefaultJavaImports (  )  ;", "} else    {", "return   getDefaultScalaImports (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDefaultImports"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV10X"}, {"methodBody": ["METHOD_START", "{", "return   TwirlCompilerAdapterV 1  0 X . DEFAULT _ JAVA _ IMPORTS ;", "}", "METHOD_END"], "methodName": ["getDefaultJavaImports"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV10X"}, {"methodBody": ["METHOD_START", "{", "return   TwirlCompilerAdapterV 1  0 X . DEFAULT _ SCALA _ IMPORTS ;", "}", "METHOD_END"], "methodName": ["getDefaultScalaImports"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV10X"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isInclusiveDots"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV10X"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isUseOldParser"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV10X"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isInclusiveDots"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV13X"}, {"methodBody": ["METHOD_START", "{", "ScalaMethod   method    =    ScalaReflectionUtil . scalaMethod ( classLoader ,     \" scala . collection . JavaConversions \"  ,     \" asScalaBuffer \"  ,    List . class )  ;", "return   methodvoke ( list )  ;", "}", "METHOD_END"], "methodName": ["toScalaSeq"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerAdapterV13X"}, {"methodBody": ["METHOD_START", "{", "return   new   TwirlCompiler ( TwirlCompilerFactory . createAdapter ( playPlatform )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "String   playVersion    =    playPlatform . getPlayVersion (  )  ;", "String   scalaCompatibilityVersion    =    playPlatform . getScalaPlatform (  )  . getScalaCompatibilityVersion (  )  ;", "switch    ( PlayMajorVersion . forPlatform ( playPlatform )  )     {", "case   PLAY _  2  _  2  _ X    :", "return   new   AdapterV 2  2 X (  \"  2  .  2  .  6  \"  ,    scalaCompatibilityVersion )  ;", "case   PLAY _  2  _  3  _ X    :", "return   new   AdapterV 1  0 X (  \"  1  .  0  .  4  \"  ,    scalaCompatibilityVersion )  ;", "case   PLAY _  2  _  4  _ X    :", "case   PLAY _  2  _  5  _ X    :", "return   new   AdapterV 1  0 X (  \"  1  .  1  .  1  \"  ,    scalaCompatibilityVersion )  ;", "case   PLAY _  2  _  6  _ X    :", "return   new   AdapterV 1  3 X (  \"  1  .  3  .  1  3  \"  ,    scalaCompatibilityVersion )  ;", "default    :", "throw   new   RuntimeException (  (  \" Could   not   create   Twirl   compile   spec   for   Play   version :     \"     +    playVersion )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createAdapter"], "fileName": "org.gradle.play.internal.twirl.TwirlCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( String   importPackage    :    imports )     {", "sb . append (  \" import    \"  )  . append ( importPackage )  . append (  \"  ;  \\ n \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["addImports"], "fileName": "org.gradle.play.internal.twirl.VersionedTwirlCompilerAdapter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "addImports ( sb ,    defaultImports )  ;", "addImports ( sb ,    temteFormat . getTemteImports (  )  )  ;", "addImports ( sb ,    additionalImports )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getImportsFor"], "fileName": "org.gradle.play.internal.twirl.VersionedTwirlCompilerAdapter"}, {"methodBody": ["METHOD_START", "{", "return    (  \" coffeescript : coffee - script - js :  \"     +     ( PlayCoffeeScriptPlugin . DEFAULT _ COFFEESCRIPT _ VERSION )  )     +     \"  @ js \"  ;", "}", "METHOD_END"], "methodName": ["getDefaultCoffeeScriptDependencyNotation"], "fileName": "org.gradle.play.plugins.PlayCoffeeScriptPlugin"}, {"methodBody": ["METHOD_START", "{", "return    \" mozilla : rhino :  \"     +     ( PlayCoffeeScriptPlugin . DEFAULT _ RHINO _ VERSION )  ;", "}", "METHOD_END"], "methodName": ["getDefaultRhinoDependencyNotation"], "fileName": "org.gradle.play.plugins.PlayCoffeeScriptPlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( final   PlayDistribution   distribution    :    distributions . withType ( PlayDistribution . class )  )     {", "final   PlayApplicationBinarySpec   binary    =    distribution . getBinary (  )  ;", "if    ( binary    =  =    null )     {", "throw   new   InvalidUserCodeException ( String . format (  \" Play   Distribution    '  % s '    does   not   have   a   configured   Play   binary .  \"  ,    distribution . getName (  )  )  )  ;", "}", "final   File   distJarDir    =    new   File ( buildDir ,     (  \" distributionJars /  \"     +     ( distribution . getName (  )  )  )  )  ;", "final   String   jarTaskName    =     (  \" create \"     +     ( StringUtils . capitalize ( distribution . getName (  )  )  )  )     +     \" DistributionJar \"  ;", "tasks . create ( jarTaskName ,    Jar . class ,    new   Action < Jar >  (  )     {", "@ Override", "public   void   execute ( Jar   jar )     {", "jar . setDescription (  (  (  \" Assembles   an   application   jar   suitable   for   deployment   for   the    \"     +    binary )     +     \"  .  \"  )  )  ;", "jar . dependsOn ( binary . getTasks (  )  . withType ( Jar . class )  )  ;", "jar . from ( jar . getProject (  )  . zipTree ( binary . getJarFile (  )  )  )  ;", "jar . setDestinationDir ( distJarDir )  ;", "jar . setArchiveName ( binary . getJarFile (  )  . getName (  )  )  ;", "Map < String ,    Object >    classpath    =    Maps . newHashMap (  )  ;", "classpath . put (  \" Class - Path \"  ,    new    . PlayManifestClasspath ( configurations . getPlayRun (  )  ,    binary . getAssetsJarFile (  )  )  )  ;", "jar . getManifest (  )  . attributes ( classpath )  ;", "}", "}  )  ;", "final   Task   distributionJar    =    tasks . get ( jarTaskName )  ;", "final   File   scriptsDir    =    new   File ( buildDir ,     (  \" scripts /  \"     +     ( distribution . getName (  )  )  )  )  ;", "String   createStartScriptsTaskName    =     \" create \"     +     ( StringUtils . capitalize (  (  ( distribution . getName (  )  )     +     \" StartScripts \"  )  )  )  ;", "tasks . create ( createStartScriptsTaskName ,    CreateStartScripts . class ,    new   Action < CreateStartScripts >  (  )     {", "@ Override", "public   void   execute ( CreateStartScripts   createStartScripts )     {", "createStartScripts . setDescription (  (  (  \" Creates   OS   specific   scripts   to   run   the    \"     +    binary )     +     \"  .  \"  )  )  ;", "createStartScripts . setClasspath ( distributionJar . getOutputs (  )  . getFiles (  )  )  ;", "createStartScripts . setMainClassName ( getMainClass ( distribution )  )  ;", "createStartScripts . setApplicationName ( distribution . getName (  )  )  ;", "createStartScripts . setOutputDir ( scriptsDir )  ;", "}", "}  )  ;", "Task   createStartScripts    =    tasks . get ( createStartScriptsTaskName )  ;", "CopySpecInternal   distSpec    =     (  ( CopySpecInternal )     ( distribution . getContents (  )  )  )  ;", "CopySpec   libSpec    =    distSpec . addChild (  )  . into (  \" lib \"  )  ;", "libSpec . from ( distributionJar )  ;", "libSpec . from ( binary . getAssetsJarFile (  )  )  ;", "libSpec . from ( configurations . getPlayRun (  )  . getAllArtifacts (  )  )  ;", "libSpec . eachFile ( new    . PrefixArtifactFileNames ( configurations . getPlayRun (  )  )  )  ;", "CopySpec   binSpec    =    distSpec . addChild (  )  . into (  \" bin \"  )  ;", "binSpec . from ( createStartScripts )  ;", "binSpec . setFileMode (  4  9  3  )  ;", "CopySpec   confSpec    =    distSpec . addChild (  )  . into (  \" conf \"  )  ;", "confSpec . from (  \" conf \"  )  . exclude (  \" routes \"  )  ;", "distSpec . from (  \" README \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["createDistributionContentTasks"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( final   PlayDistribution   distribution    :    distributions . withType ( PlayDistribution . class )  )     {", "String   capitalizedDistName    =    StringUtils . capitalize ( distribution . getName (  )  )  ;", "final   String   stageTaskName    =     (  \" stage \"     +    capitalizedDistName )     +     \" Dist \"  ;", "final   File   stageDir    =    new   File ( buildDir ,     \" stage \"  )  ;", "final   String   baseName    =     ( StringUtils . isNotEmpty ( distribution . getBaseName (  )  )  )     ?    distribution . getBaseName (  )     :    distribution . getName (  )  ;", "tasks . create ( stageTaskName ,    Sync . class ,    new   Action < Sync >  (  )     {", "@ Override", "public   void   execute ( Sync   sync )     {", "sync . setDescription (  (  (  \" Copies   the    '  \"     +     ( distribution . getName (  )  )  )     +     \"  '    distribution   to   a   staging   directory .  \"  )  )  ;", "sync . setDestinationDir ( stageDir )  ;", "CopySpecInternal   baseSpec    =    sync . getRootSpec (  )  . addChild (  )  ;", "baseSpec . into ( baseName )  ;", "baseSpec . with ( distribution . getContents (  )  )  ;", "}", "}  )  ;", "tasks . named (  . STAGE _ LIFECYCLE _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "task . dependsOn ( stageTaskName )  ;", "}", "}  )  ;", "final   Task   stageTask    =    tasks . get ( stageTaskName )  ;", "final   String   distributionZipTaskName    =     (  \" create \"     +    capitalizedDistName )     +     \" ZipDist \"  ;", "tasks . create ( distributionZipTaskName ,    Zip . class ,    new   Action < Zip >  (  )     {", "@ Override", "public   void   execute ( final   Zip   zip )     {", "zip . setDescription (  (  (  \" Packages   the    '  \"     +     ( distribution . getName (  )  )  )     +     \"  '    distribution   as   a   zip   file .  \"  )  )  ;", "zip . setBaseName ( baseName )  ;", "zip . setDestinationDir ( new   File ( buildDir ,     \" distributions \"  )  )  ;", "zip . from ( stageTask )  ;", "}", "}  )  ;", "final   String   distributionTarTaskName    =     (  \" create \"     +    capitalizedDistName )     +     \" TarDist \"  ;", "tasks . create ( distributionTarTaskName ,    Tar . class ,    new   Action < Tar >  (  )     {", "@ Override", "public   void   execute ( final   Tar   tar )     {", "tar . setDescription (  (  (  \" Packages   the    '  \"     +     ( distribution . getName (  )  )  )     +     \"  '    distribution   as   a   tar   file .  \"  )  )  ;", "tar . setBaseName ( baseName )  ;", "tar . setDestinationDir ( new   File ( buildDir ,     \" distributions \"  )  )  ;", "tar . from ( stageTask )  ;", "}", "}  )  ;", "tasks . named ( distributionTarTaskName ,     . DistributionArchiveRules . class )  ;", "tasks . named ( distributionZipTaskName ,     . DistributionArchiveRules . class )  ;", "tasks . named (  . DIST _ LIFECYCLE _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "task . dependsOn ( distributionZipTaskName ,    distributionTarTaskName )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["createDistributionZipTasks"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "FileOperations   fileOperations    =    serviceRegistry . get ( FileOperations . class )  ;", "Instantiator   instantiator    =    serviceRegistry . get ( Instantiator . class )  ;", "for    ( PlayApplicationBinarySpecInternal   binary    :    playBinaries )     {", "distribution    =    instantiator . newInstance ( Default . class ,    binary . getProjectScopedName (  )  ,    fileOperations . copySpec (  )  ,    binary )  ;", "distribution . setBaseName ( binary . getProjectScopedName (  )  )  ;", "distributions . add ( distribution )  ;", "}", "}", "METHOD_END"], "methodName": ["createDistributions"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "tasks . create ( PlayDistributionPlugin . DIST _ LIFECYCLE _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "task . setDescription (  \" Assembles   all   Play   distributions .  \"  )  ;", "task . setGroup ( PlayDistributionPlugin . DISTRIBUTION _ GROUP )  ;", "}", "}  )  ;", "tasks . create ( PlayDistributionPlugin . STAGE _ LIFECYCLE _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "task . setDescription (  \" Stages   all   Play   distributions .  \"  )  ;", "task . setGroup ( PlayDistributionPlugin . DISTRIBUTION _ GROUP )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createLifecycleTasks"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPlayDistributionContainer ( instantiator )  ;", "}", "METHOD_END"], "methodName": ["distributions"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "PlayPlatform   playPlatform    =    distribution . getBinary (  )  . getTargetPlatform (  )  ;", "String   playVersion    =    playPlatform . getPlayVersion (  )  ;", "switch    ( PlayMajorVersion . forPlatform ( playPlatform )  )     {", "case   PLAY _  2  _  2  _ X    :", "case   PLAY _  2  _  3  _ X    :", "return    \" play . core . server . NettyServer \"  ;", "case   PLAY _  2  _  4  _ X    :", "case   PLAY _  2  _  5  _ X    :", "case   PLAY _  2  _  6  _ X    :", "return    \" play . core . server . ProdServerStart \"  ;", "default    :", "throw   new   RuntimeException (  (  \" Could   not   determine   main   class   for   Play   version :  \"     +    playVersion )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMainClass"], "fileName": "org.gradle.play.plugins.PlayDistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayPluginConfigurations . PlayConfiguration ( PlayPluginConfigurations . COMPILE _ CONFIGURATION )  ;", "}", "METHOD_END"], "methodName": ["getPlay"], "fileName": "org.gradle.play.plugins.PlayPluginConfigurations"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayPluginConfigurations . PlayConfiguration ( PlayPluginConfigurations . PLATFORM _ CONFIGURATION )  ;", "}", "METHOD_END"], "methodName": ["getPlayPlatform"], "fileName": "org.gradle.play.plugins.PlayPluginConfigurations"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayPluginConfigurations . PlayConfiguration ( PlayPluginConfigurations . RUN _ CONFIGURATION )  ;", "}", "METHOD_END"], "methodName": ["getPlayRun"], "fileName": "org.gradle.play.plugins.PlayPluginConfigurations"}, {"methodBody": ["METHOD_START", "{", "return   new   PlayPluginConfigurations . PlayConfiguration ( PlayPluginConfigurations . TEST _ COMPILE _ CONFIGURATION )  ;", "}", "METHOD_END"], "methodName": ["getPlayTest"], "fileName": "org.gradle.play.plugins.PlayPluginConfigurations"}, {"methodBody": ["METHOD_START", "{", "binaries . all ( new   Action < PlayApplicationBinarySpecInternal >  (  )     {", "@ Override", "public   void   execute ( PlayApplicationBinarySpecInternal   playApplicationBinarySpec )     {", "for    ( LanguageSourceSet   languageSourceSet    :    playApplicationBinarySpec . getInputs (  )  . withType ( RoutesSourceSet . class )  )     {", "playApplicationBinarySpec . addGeneratedScala ( languageSourceSet ,    sourceDirectorySetFactory )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createGeneratedScalaSourceSets"], "fileName": "org.gradle.play.plugins.PlayRoutesPlugin"}, {"methodBody": ["METHOD_START", "{", "languages . add ( new   PlayRoutesPlugin . Routes (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerLanguageTransform"], "fileName": "org.gradle.play.plugins.PlayRoutesPlugin"}, {"methodBody": ["METHOD_START", "{", "tasks . named ( CHECK _ TASK _ NAME ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   checkTask )     {", "for    ( PlayApplicationBinarySpec   binary    :    playBinaries )     {", "checkTask . dependsOn ( binary . getTasks (  )  . withType ( Test . class )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["attachTestSuitesToCheckTask"], "fileName": "org.gradle.play.plugins.PlayTestPlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( final   PlayApplicationBinarySpecInternal   binary    :    playBinaries )     {", "final   PlayToolProvider   playToolProvider    =    binary . getToolChain (  )  . select ( binary . getTargetPlatform (  )  )  ;", "final   FileCollection   testCompileClasspath    =    getTestCompileClasspath ( binary ,    playToolProvider ,    configurations )  ;", "final   String   testCompileTaskName    =    binary . getTasks (  )  . taskName (  \" compile \"  ,     \" tests \"  )  ;", "final   File   testSourceDir    =    fileResolver . resolve (  \" test \"  )  ;", "final   FileCollection   testSources    =    new   SimpleFileCollection ( testSourceDir )  . getAsFileTree (  )  . matching ( new   PatternSet (  )  . include (  \"  *  *  /  *  . scala \"  ,     \"  *  *  /  *  . java \"  )  )  ;", "final   File   testClassesDir    =    new   File ( buildDir ,     (  ( binary . getProjectScopedName (  )  )     +     \"  / testClasses \"  )  )  ;", "tasks . create ( testCompileTaskName ,    PlatformScalaCompile . class ,    new   api . Action < PlatformScalaCompile >  (  )     {", "public   void   execute ( PlatformScalaCompile   scalaCompile )     {", "scalaCompile . setDescription (  (  (  \" Compiles   the   scala   and   java   test   sources   for   the    \"     +     ( binary . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "scalaCompile . setClasspath ( testCompileClasspath )  ;", "scalaCompile . dependsOn ( binary . getBuildTask (  )  )  ;", "scalaCompile . setPlatform ( binary . getTargetPlatform (  )  . getScalaPlatform (  )  )  ;", "scalaCompile . setDestinationDir ( testClassesDir )  ;", "scalaCompile . setSource ( testSources )  ;", "String   targetCompatibility    =    binary . getTargetPlatform (  )  . getJavaPlatform (  )  . getTargetCompatibility (  )  . getMajorVersion (  )  ;", "scalaCompile . setSourceCompatibility ( targetCompatibility )  ;", "scalaCompile . setTargetCompatibility ( targetCompatibility )  ;", "IncrementalCompileOptions   incrementalOptions    =    scalaCompile . getScalaCompileOptions (  )  . getIncrementalOptions (  )  ;", "incrementalOptions . setAnalysisFile ( new   File ( buildDir ,     (  (  \" tmp / scala / compilerAnalysis /  \"     +    testCompileTaskName )     +     \"  . analysis \"  )  )  )  ;", "}", "}  )  ;", "final   String   testTaskName    =    binary . getTasks (  )  . taskName (  \" test \"  )  ;", "final   File   binaryBuildDir    =    new   File ( buildDir ,    binary . getProjectScopedName (  )  )  ;", "tasks . create ( testTaskName ,    Test . class ,    new   api . Action < Test >  (  )     {", "public   void   execute ( Test   test )     {", "test . setDescription (  (  \" Runs    \"     +     ( WordUtils . uncapitalize (  (  ( binary . getDisplayName (  )  )     +     \"  .  \"  )  )  )  )  )  ;", "test . setClasspath ( getRuntimeClasspath ( testClassesDir ,    testCompileClasspath )  )  ;", "test . setTestClassesDirs ( new   SimpleFileCollection ( testClassesDir )  )  ;", "test . setBinResultsDir ( new   File ( binaryBuildDir ,     (  (  \" results /  \"     +    testTaskName )     +     \"  / bin \"  )  )  )  ;", "test . getReports (  )  . getJunitXml (  )  . setDestination ( new   File ( binaryBuildDir ,     \" reports / test / xml \"  )  )  ;", "test . getReports (  )  . getHtml (  )  . setDestination ( new   File ( binaryBuildDir ,     \" reports / test \"  )  )  ;", "test . dependsOn ( testCompileTaskName )  ;", "test . setWorkingDir ( projectIdentifier . getProjectDir (  )  )  ;", "}", "}  )  ;", "binary . getTasks (  )  . add ( tasks . get ( testTaskName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createTestTasks"], "fileName": "org.gradle.play.plugins.PlayTestPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleFileCollection ( testClassesDir )  . plus ( testCompileClasspath )  ;", "}", "METHOD_END"], "methodName": ["getRuntimeClasspath"], "fileName": "org.gradle.play.plugins.PlayTestPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleFileCollection ( binary . getJarFile (  )  )  . plus ( configurations . getPlayTest (  )  . getAllArtifacts (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTestCompileClasspath"], "fileName": "org.gradle.play.plugins.PlayTestPlugin"}, {"methodBody": ["METHOD_START", "{", "binaries . beforeEach ( new   Action < PlayApplicationBinarySpecInternal >  (  )     {", "@ Override", "public   void   execute ( PlayApplicationBinarySpecInternal   binary )     {", "if    (  . hasTwirlSourceSetsWithJavaImports ( binary . getApplication (  )  )  )     {", "PlayPlatform   targetPlatform    =    binary . getTargetPlatform (  )  ;", "configurations . getPlay (  )  . addDependency (  (  ( PlayPlatformInternal )     ( targetPlatform )  )  . getDependencyNotation (  \" play - java \"  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addPlayJavaDependencyIfNeeded"], "fileName": "org.gradle.play.plugins.PlayTwirlPlugin"}, {"methodBody": ["METHOD_START", "{", "binaries . all ( new   Action < PlayApplicationBinarySpecInternal >  (  )     {", "@ Override", "public   void   execute ( PlayApplicationBinarySpecInternal   playApplicationBinarySpec )     {", "for    ( LanguageSourceSet   languageSourceSet    :    playApplicationBinarySpec . getInputs (  )  . withType ( TwirlSourceSet . class )  )     {", "playApplicationBinarySpec . addGeneratedScala ( languageSourceSet ,    sourceDirectorySetFactory )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createGeneratedScalaSourceSets"], "fileName": "org.gradle.play.plugins.PlayTwirlPlugin"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . any ( playApplicationSpec . getSources (  )  . withType ( TwirlSourceSet . class )  . values (  )  ,    new   Spec < TwirlSourceSet >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( TwirlSourceSet   twirlSourceSet )     {", "return    ( twirlSourceSet . getDefaultImports (  )  )     =  =     ( TwirlImports . JAVA )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["hasTwirlSourceSetsWithJavaImports"], "fileName": "org.gradle.play.plugins.PlayTwirlPlugin"}, {"methodBody": ["METHOD_START", "{", "languages . add ( new   PlayTwirlPlugin . Twirl (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerLanguageTransform"], "fileName": "org.gradle.play.plugins.PlayTwirlPlugin"}, {"methodBody": ["METHOD_START", "{", "builder . defaultImplementation ( DefaultTwirlSourceSet . class )  ;", "}", "METHOD_END"], "methodName": ["registerTwirlLanguageType"], "fileName": "org.gradle.play.plugins.PlayTwirlPlugin"}, {"methodBody": ["METHOD_START", "{", "StaleClassCleaner   cleaner    =    new   SimpleStaleClassCleaner ( getOutputs (  )  )  ;", "cleaner . setDestinationDir ( getDestinationDir (  )  )  ;", "cleaner . execute (  )  ;", ". MinifyFileVisitor   visitor    =    new    . MinifyFileVisitor (  )  ;", "getSource (  )  . visit ( visitor )  ;", "JavaScriptCompileSpec   spec    =    new   DefaultJavaScriptCompileSpec ( visitor . relativeFiles ,    getDestinationDir (  )  ,    getForkOptions (  )  )  ;", "getCompiler (  )  . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["compileJavaScriptSources"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "ToolProvider   select    =     (  ( PlayToolChainInternal )     ( getToolChain (  )  )  )  . select ( playPlatform )  ;", "return   select . newCompiler ( CompileSpec . class )  ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "return   destinationDir ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "if    (  ( forkOptions )     =  =    null )     {", "forkOptions    =    new   BaseForkOptions (  )  ;", "}", "return   forkOptions ;", "}", "METHOD_END"], "methodName": ["getForkOptions"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "this . destinationDir    =    destinationDir ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "this . playPlatform    =    playPlatform ;", "}", "METHOD_END"], "methodName": ["setPlayPlatform"], "fileName": "org.gradle.play.tasks.JavaScriptMinify"}, {"methodBody": ["METHOD_START", "{", "Dependency   dependency    =    getProject (  )  . getDependencies (  )  . create ( notation )  ;", "return   getProject (  )  . genfigurations (  )  . detachedConfiguration ( dependency )  ;", "}", "METHOD_END"], "methodName": ["getDetachedConfiguration"], "fileName": "org.gradle.play.tasks.PlayCoffeeScriptCompile"}, {"methodBody": ["METHOD_START", "{", "super . setCoffeeScriptJs ( getDetachedConfiguration ( notation )  )  ;", "}", "METHOD_END"], "methodName": ["setCoffeeScriptJsNotation"], "fileName": "org.gradle.play.tasks.PlayCoffeeScriptCompile"}, {"methodBody": ["METHOD_START", "{", "setRhinoClasspath ( getDetachedConfiguration ( notation )  )  ;", "}", "METHOD_END"], "methodName": ["setRhinoClasspathNotation"], "fileName": "org.gradle.play.tasks.PlayCoffeeScriptCompile"}, {"methodBody": ["METHOD_START", "{", "return   applicationJar ;", "}", "METHOD_END"], "methodName": ["getApplicationJar"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "return   assetsDirs ;", "}", "METHOD_END"], "methodName": ["getAssetsDirs"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "return   assetsJar ;", "}", "METHOD_END"], "methodName": ["getAssetsJar"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getDeploymentRegistry"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "if    (  ( forkOptions )     =  =    null )     {", "forkOptions    =    new   BaseForkOptions (  )  ;", "}", "return   forkOptions ;", "}", "METHOD_END"], "methodName": ["getForkOptions"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "return   httpPort ;", "}", "METHOD_END"], "methodName": ["getHttpPort"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "return   workingDir ;", "}", "METHOD_END"], "methodName": ["getWorkingDir"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "String   deploymentId    =    getPath (  )  ;", "DeploymentRegistry   deploymentRegistry    =    getDeploymentRegistry (  )  ;", "PlayApplicationDeploymentHandle   deploymentHandle    =    deploymentRegistry . get ( deploymentId ,    PlayApplicationDeploymentHandle . class )  ;", "if    ( deploymentHandle    =  =    null )     {", "Spec   spec    =    new   DefaultSpec ( runtimeClasspath ,    changingClasspath ,    applicationJar ,    assetsJar ,    assetsDirs ,    workingDir . get (  )  . getAsFile (  )  ,    getForkOptions (  )  ,    getHttpPort (  )  )  ;", "PlayApplicationRunner   playApplicationRunner    =    playToolProvider . get ( PlayApplicationRunner . class )  ;", "deploymentHandle    =    deploymentRegistry . start ( deploymentId ,    BLOCK ,    PlayApplicationDeploymentHandle . class ,    spec ,    playApplicationRunner )  ;", "InetSocketAddress   playAppAddress    =    deploymentHandle . getPlayAppAddress (  )  ;", "String   playUrl    =     (  \" http :  /  / localhost :  \"     +     ( playAppAddress . getPort (  )  )  )     +     \"  /  \"  ;", ". LOGGER . warn (  \" Running   Play   App    (  {  }  )    at    {  }  \"  ,    getPath (  )  ,    playUrl )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . applicationJar    =    applicationJar ;", "}", "METHOD_END"], "methodName": ["setApplicationJar"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . assetsDirs    =    assetsDirs ;", "}", "METHOD_END"], "methodName": ["setAssetsDirs"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . assetsJar    =    assetsJar ;", "}", "METHOD_END"], "methodName": ["setAssetsJar"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . changingClasspath    =    changingClasspath ;", "}", "METHOD_END"], "methodName": ["setChangingClasspath"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . httpPort    =    httpPort ;", "}", "METHOD_END"], "methodName": ["setHttpPort"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . playToolProvider    =    playToolProvider ;", "}", "METHOD_END"], "methodName": ["setPlayToolProvider"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "this . runtimeClasspath    =    runtimeClasspath ;", "}", "METHOD_END"], "methodName": ["setRuntimeClasspath"], "fileName": "org.gradle.play.tasks.PlayRun"}, {"methodBody": ["METHOD_START", "{", "RoutesCompileSpec   spec    =    new   DefaultRoutesCompileSpec ( getSource (  )  . getFiles (  )  ,    getOutputDirectory (  )  ,    getForkOptions (  )  ,    isJavaProject (  )  ,    isNamespaceReverseRouter (  )  ,    isGenerateReverseRoutes (  )  ,    getInjectedRoutesGenerator (  )  ,    getAdditionalImports (  )  )  ;", "new   internal . CleaningPlayToolCompiler < RoutesCompileSpec >  ( getCompiler (  )  ,    getOutputs (  )  )  . execute ( spec )  ;", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   additionalImports ;", "}", "METHOD_END"], "methodName": ["getAdditionalImports"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "ToolProvider   select    =     (  ( PlayToolChainInternal )     ( getToolChain (  )  )  )  . select ( platform )  ;", "return   select . newCompiler ( Spec . class )  ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( forkOptions )     =  =    null )     {", "forkOptions    =    new   BaseForkOptions (  )  ;", "}", "return   forkOptions ;", "}", "METHOD_END"], "methodName": ["getForkOptions"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   injectedRoutesGenerator ;", "}", "METHOD_END"], "methodName": ["getInjectedRoutesGenerator"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   outputDirectory ;", "}", "METHOD_END"], "methodName": ["getOutputDirectory"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   generateReverseRoutes ;", "}", "METHOD_END"], "methodName": ["isGenerateReverseRoutes"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isJavaProject"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "return   namespaceReverseRouter ;", "}", "METHOD_END"], "methodName": ["isNamespaceReverseRouter"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . additionalImports . addAll ( additionalImports )  ;", "}", "METHOD_END"], "methodName": ["setAdditionalImports"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . generateReverseRoutes    =    generateReverseRoutes ;", "}", "METHOD_END"], "methodName": ["setGenerateReverseRoutes"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . injectedRoutesGenerator    =    injectedRoutesGenerator ;", "}", "METHOD_END"], "methodName": ["setInjectedRoutesGenerator"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . namespaceReverseRouter    =    namespaceReverseRouter ;", "}", "METHOD_END"], "methodName": ["setNamespaceReverseRouter"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . outputDirectory    =    outputDirectory ;", "}", "METHOD_END"], "methodName": ["setOutputDirectory"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "this . platform    =    platform ;", "}", "METHOD_END"], "methodName": ["setPlatform"], "fileName": "org.gradle.play.tasks.RoutesCompile"}, {"methodBody": ["METHOD_START", "{", "userTemplateFormats . add ( new   DefaultTwirlTemplateFormat ( extension ,    templateType ,    Arrays . asList ( imports )  )  )  ;", "}", "METHOD_END"], "methodName": ["addUserTemplateFormat"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "TwirlCompile . RelativeFileCollector   relativeFileCollector    =    new   TwirlCompile . RelativeFileCollector (  )  ;", "getSource (  )  . visit ( relativeFileCollector )  ;", "TwirlCompileSpec   spec    =    new   DefaultTwirlCompileSpec ( relativeFileCollector . relativeFiles ,    getOutputDirectory (  )  ,    getForkOptions (  )  ,    getDefaultImports (  )  ,    userTemplateFormats ,    additionalImports )  ;", "if    (  !  ( inputs . isIncremental (  )  )  )     {", "new   internal . CleaningPlayToolCompiler < TwirlCompileSpec >  ( getCompiler (  )  ,    getOutputs (  )  )  . execute ( spec )  ;", "} else    {", "final   Set < File >    sourcesToCompile    =    new   HashSet < File >  (  )  ;", "inputs . outOfDate ( new   Action < InputFileDetails >  (  )     {", "public   void   execute ( InputFileDetails   inputFileDetails )     {", "sourcesToCompile . add ( inputFileDetails . getFile (  )  )  ;", "}", "}  )  ;", "final   Set < File >    staleOutputFiles    =    new   HashSet < File >  (  )  ;", "inputs . removed ( new   Action < InputFileDetails >  (  )     {", "public   void   execute ( InputFileDetails   inputFileDetails )     {", "staleOutputFiles . add ( inputFileDetails . getFile (  )  )  ;", "}", "}  )  ;", "if    (  ( cleaner )     =  =    null )     {", "cleaner    =    new   TwirlCompile . TwirlStaleOutputCleaner ( getOutputDirectory (  )  )  ;", "}", "cleaner . execute ( staleOutputFiles )  ;", "getCompiler (  )  . execute ( spec )  ;", "}", "}", "METHOD_END"], "methodName": ["compile"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "return   additionalImports ;", "}", "METHOD_END"], "methodName": ["getAdditionalImports"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "ToolProvider   toolProvider    =     (  ( PlayToolChainInternal )     ( getToolChain (  )  )  )  . select ( platform )  ;", "return   toolProvider . newCompiler ( Spec . class )  ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "return   defaultImports ;", "}", "METHOD_END"], "methodName": ["getDefaultImports"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "return   TwirlCompilerFactory . createAdapter ( platform )  . getDependencyNotation (  )  ;", "}", "METHOD_END"], "methodName": ["getDependencyNotation"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( forkOptions )     =  =    null )     {", "forkOptions    =    new   BaseForkOptions (  )  ;", "}", "return   forkOptions ;", "}", "METHOD_END"], "methodName": ["getForkOptions"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "return   outputDirectory ;", "}", "METHOD_END"], "methodName": ["getOutputDirectory"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "return   userTemplateFormats ;", "}", "METHOD_END"], "methodName": ["getUserTemplateFormats"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . additionalImports    =    additionalImports ;", "}", "METHOD_END"], "methodName": ["setAdditionalImports"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . cleaner    =    cleaner ;", "}", "METHOD_END"], "methodName": ["setCleaner"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . defaultImports    =    defaultImports ;", "}", "METHOD_END"], "methodName": ["setDefaultImports"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . outputDirectory    =    outputDirectory ;", "}", "METHOD_END"], "methodName": ["setOutputDirectory"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . platform    =    platform ;", "}", "METHOD_END"], "methodName": ["setPlatform"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["setToolChain"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "this . userTemplateFormats    =    userTemplateFormats ;", "}", "METHOD_END"], "methodName": ["setUserTemplateFormats"], "fileName": "org.gradle.play.tasks.TwirlCompile"}, {"methodBody": ["METHOD_START", "{", "ScalaMethod   method    =    ScalaReflectionUtil . scalaMethod ( cl ,    ScalaCodecMapper . getClassName (  )  ,     \" apply \"  ,    String . class )  ;", "return   method . invoke ( codec )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.scala.internal.reflect.ScalaCodecMapper"}, {"methodBody": ["METHOD_START", "{", "return    \" scala . io . Codec \"  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.scala.internal.reflect.ScalaCodecMapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    bufferClass    =    cl . loadClass (  \" scala . collection . mutable .  \"  )  ;", "Object   buffer    =    bufferClass . newInstance (  )  ;", "Method   bufferPlusEq    =    bufferClass . getMethod (  \"  $ plus $ eq \"  ,    Object . class )  ;", "for    ( T   elem    :    list )     {", "bufferPlusEq . invoke ( buffer ,    elem )  ;", "}", "return   buffer ;", "}    catch    ( Exception   exception )     {", "throw   new   RuntimeException ( exception )  ;", "}", "}", "METHOD_END"], "methodName": ["fromList"], "fileName": "org.gradle.scala.internal.reflect.ScalaListBuffer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   type . get ( methodName ,    typeParameters )  ;", "}    catch    ( NoSuchException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.gradle.scala.internal.reflect.ScalaMethod"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   m . invoke ( instance ,    args )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   invoke   Scala   m    % s .  \"  ,    description )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.gradle.scala.internal.reflect.ScalaMethod"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   classLoer . loClass (  ( typeName    +     \"  $  \"  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getClass"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "return   instance ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   s . get ( null )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   baseClassetField (  \" MODULE $  \"  )  ;", "}    catch    ( NoSuchFieldException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.scala.internal.reflect.ScalaObject"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   Cast . uncheckedCast ( obj . getClass (  )  . getMethod (  \" get \"  )  . invoke ( obj )  )  ;", "}    catch    ( Exce   e )     {", "throw   new   RuntimeExce ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.scala.internal.reflect.ScalaOptionInvocationWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "Method   resultIsDefined    =    obj . getClass (  )  . getMethod (  \" isDefined \"  )  ;", "return    (  ( Boolean )     ( resultIsDefined . invoke ( obj )  )  )  ;", "}    catch    ( Exce   e )     {", "throw   new   RuntimeExce ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["isDefined"], "fileName": "org.gradle.scala.internal.reflect.ScalaOptionInvocationWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   ScalaMethod ( classLoader ,    typeName ,    methodName ,    typeParameters )  ;", "}", "METHOD_END"], "methodName": ["scalaMethod"], "fileName": "org.gradle.scala.internal.reflect.ScalaReflectionUtil"}]