[{"methodBody": ["METHOD_START", "{", "action . execute ( contents )  ;", "return   contents ;", "}", "METHOD_END"], "methodName": ["contents"], "fileName": "org.gradle.api.distribution.internal.DefaultDistribution"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.distribution.internal.DefaultDistribution"}, {"methodBody": ["METHOD_START", "{", "return   contents ;", "}", "METHOD_END"], "methodName": ["getContents"], "fileName": "org.gradle.api.distribution.internal.DefaultDistribution"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.distribution.internal.DefaultDistribution"}, {"methodBody": ["METHOD_START", "{", "this . baseName    =    baseName ;", "}", "METHOD_END"], "methodName": ["setBaseName"], "fileName": "org.gradle.api.distribution.internal.DefaultDistribution"}, {"methodBody": ["METHOD_START", "{", "return   getInstantiator (  )  . newInstance ( DefaultDistribution . class ,    name ,    fileOperations . copySpec (  )  )  ;", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.api.distribution.internal.DefaultDistributionContainer"}, {"methodBody": ["METHOD_START", "{", "String   taskName    =    DistributionPlugin . TASK _ ASSEMBLE _ NAME ;", "if    (  !  ( DistributionPlugin . MAIN _ DISTRIBUTION _ NAME . equals ( distribution . getName (  )  )  )  )     {", "taskName    =     (  \" assemble \"     +     ( StringGroovyMethods . capitalize ( distribution . getName (  )  )  )  )     +     \" Dist \"  ;", "}", "Task   assembleTask    =    project . getTasks (  )  . create ( taskName )  ;", "assembleTask . setDescription (  (  (  \" Assembles   the    \"     +     ( distribution . getName (  )  )  )     +     \"    distributions \"  )  )  ;", "assembleTask . setGroup ( DistributionPlugin . DISTRIBUTION _ GROUP )  ;", "assembleTask . dependsOn (  (  ( Object [  ]  )     ( tasks )  )  )  ;", "}", "METHOD_END"], "methodName": ["addAssembleTask"], "fileName": "org.gradle.api.distribution.plugins.DistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "String   taskName    =    DistributionPlugin . TASK _ INSTALL _ NAME ;", "if    (  !  ( DistributionPlugin . MAIN _ DISTRIBUTION _ NAME . equals ( distribution . getName (  )  )  )  )     {", "taskName    =     (  \" install \"     +     ( StringGroovyMethods . capitalize ( distribution . getName (  )  )  )  )     +     \" Dist \"  ;", "}", "Sync   installTask    =    project . getTasks (  )  . create ( taskName ,    Sync . class )  ;", "installTask . setDescription (  \" Installs   the   project   as   a   distribution   as - is .  \"  )  ;", "installTask . setGroup ( DistributionPlugin . DISTRIBUTION _ GROUP )  ;", "installTask . with ( distribution . getContents (  )  )  ;", "installTask . into ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "return   project . file (  (  (  (  \"  \"     +     ( project . getBuildDir (  )  )  )     +     \"  / install /  \"  )     +     ( distribution . getBaseName (  )  )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addInstallTask"], "fileName": "org.gradle.api.distribution.plugins.DistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "final   T   archiveTask    =    project . getTasks (  )  . create ( taskName ,    type )  ;", "archiveTask . setDescription (  \" Bundles   the   project   as   a   distribution .  \"  )  ;", "archiveTask . setGroup (  . DISTRIBUTION _ GROUP )  ;", "archiveTask . getConventionMapping (  )  . map (  \" baseName \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "if    (  (  ( distribution . getBaseName (  )  )     =  =    null )     |  |     ( distribution . getBaseName (  )  . equals (  \"  \"  )  )  )     {", "throw   new   GradleException (  \" Distribution   baseName   must   not   be   null   or   empty !    Check   your   configuration   of   the   distribution   plugin .  \"  )  ;", "}", "return   distribution . getBaseName (  )  ;", "}", "}  )  ;", "Callable < String >    baseDir    =    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return   TextUtil . minus ( archiveTask . getArchiveName (  )  ,     (  \"  .  \"     +     ( archiveTask . getExtension (  )  )  )  )  ;", "}", "}  ;", "CopySpec   childSpec    =    project . copySpec (  )  ;", "childSpec . into ( baseDir )  ;", "childSpec . with ( distribution . getContents (  )  )  ;", "archiveTask . with ( childSpec )  ;", "ArchivePublishArtifact   archiveArtifact    =    new   ArchivePublishArtifact ( archiveTask )  ;", "project . getExtensions (  )  . getByType ( DefaultArtifactPublicationSet . class )  . addCandidate ( archiveArtifact )  ;", "return   archiveTask ;", "}", "METHOD_END"], "methodName": ["configureArchiveTask"], "fileName": "org.gradle.api.distribution.plugins.DistributionPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractTaskDependency (  )     {", "@ Override", "public   void   visitDependencies ( TaskDependencyResolveContext   context )     {", "context . add ( compileClasspath )  ;", "context . add ( get (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.java.DefaultJavaSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   compileClasspath ;", "}", "METHOD_END"], "methodName": ["getCompileClasspath"], "fileName": "org.gradle.api.internal.java.DefaultJavaSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   artifacts ;", "}", "METHOD_END"], "methodName": ["getArtifacts"], "fileName": "org.gradle.api.internal.java.JavaLibrary"}, {"methodBody": ["METHOD_START", "{", "return    \" java \"  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.java.JavaLibrary"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSet . of ( runtimeUsage ,    compileUsage )  ;", "}", "METHOD_END"], "methodName": ["getUsages"], "fileName": "org.gradle.api.internal.java.JavaLibrary"}, {"methodBody": ["METHOD_START", "{", "return   name . equals (  \" main \"  )     ?     \"  \"     :    name ;", "}", "METHOD_END"], "methodName": ["collapseMain"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBinaryName"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return    (  \" classes    '  \"     +     ( baseName )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getOutputDirectoryBase"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   getTaskName ( verb ,    null )  ;", "}", "METHOD_END"], "methodName": ["getTaskName"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "String   name    =    baseName ;", "if    ( target    !  =    null )     {", "name    =    collapsedName ;", "}", "return   GUtil . toLowerCamelCase (  (  (  (  (  ( nullToEmpty ( verb )  )     +     \"     \"  )     +    name )     +     \"     \"  )     +     ( nullToEmpty ( target )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getTaskName"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   input    =  =    null    ?     \"  \"     :    input ;", "}", "METHOD_END"], "methodName": ["nullToEmpty"], "fileName": "org.gradle.api.internal.jvm.ClassDirectoryBinaryNamingScheme"}, {"methodBody": ["METHOD_START", "{", "return   SingleMessageLogger . whileDisabled ( new   Factory < File >  (  )     {", "@ Override", "public   File   create (  )     {", "return   sourceSet . getOutput (  )  . getClassesDir (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getClassesDir"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   sourceSet . getOutput (  )  . getResourcesDir (  )  ;", "}", "METHOD_END"], "methodName": ["getResourcesDir"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   platform ;", "}", "METHOD_END"], "methodName": ["getTargetPlatform"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   tasks ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   toolChain ;", "}", "METHOD_END"], "methodName": ["getToolChain"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   getBuildAbility (  )  . isBuildable (  )  ;", "}", "METHOD_END"], "methodName": ["isBuildable"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isLegacyBinary"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "this . buildable    =    buildable ;", "}", "METHOD_END"], "methodName": ["setBuildable"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "SingleMessageLogger . whileDisabled ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "sourceSet . getOutput (  )  . seesDir ( classesDir )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setClassesDir"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "sourceSet . getOutput (  )  . setResourcesDir ( resourcesDir )  ;", "}", "METHOD_END"], "methodName": ["setResourcesDir"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["setTargetPlatform"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["setToolChain"], "fileName": "org.gradle.api.internal.jvm.DefaultClassDirectoryBinarySpec"}, {"methodBody": ["METHOD_START", "{", "if    ( taskName . startsWith ( BuildConfigurationRule . PREFIX )  )     {", "String   configurationName    =    StringUtils . uncapitalize ( taskName . substring ( BuildConfigurationRule . PREFIX . length (  )  )  )  ;", "Configuration   configuration    =    configurations . findByName ( configurationName )  ;", "if    ( configuration    !  =    null )     {", "Task   task    =    tasks . create ( taskName )  ;", "task . dependsOn ( configuration . getAllArtifacts (  )  )  ;", "task . setDescription (  (  (  \" Builds   the   artifacts   belonging   to    \"     +    configuration )     +     \"  .  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.BuildConfigurationRule"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Pattern :     \"     +     ( BuildConfigurationRule . PREFIX )  )     +     \"  < ConfigurationName >  :    Assembles   the   artifacts   of   a   configuration .  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.internal.plugins.BuildConfigurationRule"}, {"methodBody": ["METHOD_START", "{", "String   thisType    =    artifact . getType (  )  ;", "if    (  ( d )     =  =    null )     {", "artifacts . add ( artifact )  ;", "d    =    artifact ;", "return ;", "}", "String   currentType    =    d . getType (  )  ;", "if    ( thisType . equals (  \" ear \"  )  )     {", "replaceCurrent ( artifact )  ;", "} else", "if    ( thisType . equals (  \" war \"  )  )     {", "if    ( currentType . equals (  \" jar \"  )  )     {", "replaceCurrent ( artifact )  ;", "}", "} else", "if    (  !  ( thisType . equals (  \" jar \"  )  )  )     {", "artifacts . add ( artifact )  ;", "}", "}", "METHOD_END"], "methodName": ["addCandidate"], "fileName": "org.gradle.api.internal.plugins.DefaultArtifactPublicationSet"}, {"methodBody": ["METHOD_START", "{", "artifacts . remove ( defaultArtifact )  ;", "artifacts . add ( artifact )  ;", "defaultArtifact    =    artifact ;", "}", "METHOD_END"], "methodName": ["replaceCurrent"], "fileName": "org.gradle.api.internal.plugins.DefaultArtifactPublicationSet"}, {"methodBody": ["METHOD_START", "{", "return   appNameSystemProperty ;", "}", "METHOD_END"], "methodName": ["getAppNameSystemProperty"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   defaultJvmOpts ;", "}", "METHOD_END"], "methodName": ["getDefaultJvmOpts"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   exitEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["getExitEnvironmentVar"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   mainClassName ;", "}", "METHOD_END"], "methodName": ["getMainClassName"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   optsEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["getOptsEnvironmentVar"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "return   scriptRelPath ;", "}", "METHOD_END"], "methodName": ["getScriptRelPath"], "fileName": "org.gradle.api.internal.plugins.DefaultJavaAppStartScriptGenerationDetails"}, {"methodBody": ["METHOD_START", "{", "try    {", "Map < String ,    String >    binding    =    bindingFactory . transform ( details )  ;", "String   scriptContent    =    generateContentFromTemplate ( binding )  ;", "destination . write ( scriptContent )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["generateScript"], "fileName": "org.gradle.api.internal.plugins.DefaultTemplateBasedStartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return   IoUtils . get ( getTemplate (  )  . asReader (  )  ,    new   Transformer < String ,    Reader >  (  )     {", "@ Override", "public   String   transform ( Reader   reader )     {", "try    {", "SimpleTemplateEngine   engine    =    new   SimpleTemplateEngine (  )  ;", "Template   template    =    engine . createTemplate ( reader )  ;", "String   output    =    template . make ( binding )  . toString (  )  ;", "return   TextUtil . convertLineSeparators ( output ,    lineSeparator )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["generateStartScriptContentFromTemplate"], "fileName": "org.gradle.api.internal.plugins.DefaultTemplateBasedStartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return   template ;", "}", "METHOD_END"], "methodName": ["getTemplate"], "fileName": "org.gradle.api.internal.plugins.DefaultTemplateBasedStartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . template    =    template ;", "}", "METHOD_END"], "methodName": ["setTemplate"], "fileName": "org.gradle.api.internal.plugins.DefaultTemplateBasedStartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return   new   CharSourceBackedTextResource (  (  (  \" Classpath   resource    '  \"     +    filename )     +     \"  '  \"  )  ,    new   CharSource (  )     {", "@ Override", "public   Reader   openStream (  )    throws   IOException    {", "InputStream   stream    =    clazz . getResourceAsStream ( filename )  ;", "if    ( stream    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" Could   not   find   class   path   resource    \"     +    filename )     +     \"    relative   to    \"  )     +     ( clazz . getName (  )  )  )  )  ;", "}", "return   new   BufferedReader ( new   InputStreamReader ( stream ,    Charsets . UTF _  8  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["utf8ClassPathResource"], "fileName": "org.gradle.api.internal.plugins.DefaultTemplateBasedStartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "return   matcher . group (  1  )  ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "String   result    =     (  (  \" groovy :  \"     +     ( getBaseName (  )  )  )     +     \"  :  \"  )     +     ( getVersion (  )  )  ;", "if    ( isIndy (  )  )     {", "result    +  =     \"  : indy \"  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getDependencyNotation"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "return   VersionNumber . parse ( matcher . group (  2  )  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "return   getBaseName (  )  . equals (  \" groovy - all \"  )  ;", "}", "METHOD_END"], "methodName": ["isGroovyAll"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "return    ( matcher . group (  3  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isIndy"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    GroovyJarFile . FILE _ NAME _ PATTERN . matcher ( file . getName (  )  )  ;", "return   matcher . matches (  )     ?    new   GroovyJarFile ( file ,    matcher )     :    null ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.api.internal.plugins.GroovyJarFile"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultJavaAppStartScriptGenerationDetails ( applicationName ,    optsEnvironmentVar ,    exitEnvironmentVar ,    mainClassName ,    CollectionUtils . toStringList ( defaultJvmOpts )  ,    CollectionUtils . toStringList ( classpath )  ,    scriptRelPath ,    appNameSystemProperty )  ;", "}", "METHOD_END"], "methodName": ["createStartScriptGenerationDetails"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "IoActions . writeTextFile ( unixScript ,    new   StartScriptGenerator . Generate ( createStartScriptGenerationDetails (  )  ,    unixStartScriptGenerator )  )  ;", "unixFileOperation . createExecutablePermission ( unixScript )  ;", "}", "METHOD_END"], "methodName": ["generateUnixScript"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "IoActions . writeTextFile ( windowsScript ,    new   StartScriptGenerator . Generate ( createStartScriptGenerationDetails (  )  ,    windowsStartScriptGenerator )  )  ;", "}", "METHOD_END"], "methodName": ["generateWindowsScript"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . appNameSystemProperty    =    appNameSystemProperty ;", "}", "METHOD_END"], "methodName": ["setAppNameSystemProperty"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . applicationName    =    applicationName ;", "}", "METHOD_END"], "methodName": ["setApplicationName"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . defaultJvmOpts    =    defaultJvmOpts ;", "}", "METHOD_END"], "methodName": ["setDefaultJvmOpts"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . exitEnvironmentVar    =    exitEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["setExitEnvironmentVar"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . mainClassName    =    mainClassName ;", "}", "METHOD_END"], "methodName": ["setMainClassName"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . optsEnvironmentVar    =    optsEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["setOptsEnvironmentVar"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "this . scriptRelPath    =    scriptRelPath ;", "}", "METHOD_END"], "methodName": ["setScriptRelPath"], "fileName": "org.gradle.api.internal.plugins.StartScriptGenerator"}, {"methodBody": ["METHOD_START", "{", "int   depth    =    StringUtils . countMatches ( scriptRelPath ,     \"  /  \"  )  ;", "if    ( depth    =  =     0  )     {", "return    \"  \"  ;", "}", "List < String >    appHomeRelativePath    =    new   ArrayList < String >  ( depth )  ;", "for    ( int   i    =     0  ;    i    <    depth ;    i +  +  )     {", "appHomeRelativePath . add (  \"  .  .  \"  )  ;", "}", "return   Joiner . on (  ( windows    ?     \"  \\  \\  \"     :     \"  /  \"  )  )  . join ( appHomeRelativePath )  ;", "}", "METHOD_END"], "methodName": ["createJoinedAppHomeRelativePath"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( windows )     {", "return   Joiner . on (  \"  ;  \"  )  . join ( Iterables . transform ( classpath ,    new   com . google . common . base . Function < String ,    String >  (  )     {", "public   String   apply ( String   input )     {", "return    \"  % APP _ HOME %  \\  \\  \"     +     ( input . replace (  \"  /  \"  ,     \"  \\  \\  \"  )  )  ;", "}", "}  )  )  ;", "} else    {", "return   Joiner . on (  \"  :  \"  )  . join ( Iterables . transform ( classpath ,    new   com . google . common . base . Function < String ,    String >  (  )     {", "public   String   apply ( String   input )     {", "return    \"  $ APP _ HOME /  \"     +     ( input . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  )  ;", "}", "}  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createJoinedClasspath"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( windows )     {", "if    ( defaultJvmOpts    =  =    null )     {", "return    \"  \"  ;", "}", "Iterable < String >    quotedDefaultJvmOpts    =    Iterables . transform ( CollectionUtils . toStringList ( defaultJvmOpts )  ,    new   com . google . common . base . Function < String ,    String >  (  )     {", "public   String   apply ( String   jvmOpt )     {", "return    (  \"  \\  \"  \"     +     ( escapeWindowsJvmOpt ( jvmOpt )  )  )     +     \"  \\  \"  \"  ;", "}", "}  )  ;", "Joiner   spaceJoiner    =    Joiner . on (  \"     \"  )  ;", "return   spaceJoiner . join ( quotedDefaultJvmOpts )  ;", "} else    {", "if    ( defaultJvmOpts    =  =    null )     {", "return    \"  \"  ;", "}", "Iterable < String >    quotedDefaultJvmOpts    =    Iterables . transform ( CollectionUtils . toStringList ( defaultJvmOpts )  ,    new   com . google . common . base . Function < String ,    String >  (  )     {", "public   String   apply ( String   jvmOpt )     {", "jvmOpt    =    jvmOpt . replace (  \"  \\  \\  \"  ,     \"  \\  \\  \\  \\  \"  )  ;", "jvmOpt    =    jvmOpt . replace (  \"  \\  \"  \"  ,     \"  \\  \\  \\  \"  \"  )  ;", "jvmOpt    =    jvmOpt . replace (  \"  '  \"  ,     \"  \\  '  \\  \"  \\  '  \\  \"  \\  '  \"  )  ;", "jvmOpt    =    jvmOpt . replace (  \"  `  \"  ,     \"  \\  '  \\  \"  `  \\  \"  \\  '  \"  )  ;", "jvmOpt    =    jvmOpt . replace (  \"  $  \"  ,     \"  \\  \\  $  \"  )  ;", "return    (  \"  \\  \"  \"     +    jvmOpt )     +     \"  \\  \"  \"  ;", "}", "}  )  ;", "Joiner   spaceJoiner    =    Joiner . on (  \"     \"  )  ;", "if    (  ( Iterables . size ( quotedDefaultJvmOpts )  )     >     0  )     {", "return    (  \"  '  \"     +     ( spaceJoiner . join ( quotedDefaultJvmOpts )  )  )     +     \"  '  \"  ;", "}", "return    \"  \\  \"  \\  \"  \"  ;", "}", "}", "METHOD_END"], "methodName": ["createJoinedDefaultJvmOpts"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "boolean   wasOnBackslash    =    false ;", "StrBuilder   escapedJvmOpt    =    new   StrBuilder (  )  ;", "CharacterIterator   it    =    new   StrCharacterIterator ( jvmOpts )  ;", "for    ( char   ch    =    it . first (  )  ;    ch    !  =     ( CharacterIterator . DONE )  ;    ch    =    it . next (  )  )     {", "Str   repl    =    Character . toStr ( ch )  ;", "if    ( ch    =  =     '  %  '  )     {", "repl    =     \"  %  %  \"  ;", "} else", "if    ( ch    =  =     '  \"  '  )     {", "repl    =     ( wasOnBackslash    ?     '  \\  \\  '     :     \"  \"  )     +     \"  \\  \\  \\  \"  \"  ;", "}", "wasOnBackslash    =    ch    =  =     '  \\  \\  '  ;", "escapedJvmOpt . append ( repl )  ;", "}", "return   escapedJvmOpt . toStr (  )  ;", "}", "METHOD_END"], "methodName": ["escapeWindowsJvmOpt"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   StartScriptTemplateBindingFactory ( false )  ;", "}", "METHOD_END"], "methodName": ["unix"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   StartScriptTemplateBindingFactory ( true )  ;", "}", "METHOD_END"], "methodName": ["windows"], "fileName": "org.gradle.api.internal.plugins.StartScriptTemplateBindingFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( taskName . startsWith ( UploadRule . PREFIX )  )     {", "for    ( Configuration   configuration    :    project . getConfigurations (  )  )     {", "if    ( taskName . equals ( configuration . getUploadTaskName (  )  )  )     {", "createUploadTask ( configuration . getUploadTaskName (  )  ,    configuration ,    project )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.UploadRule"}, {"methodBody": ["METHOD_START", "{", "Upload   upload    =    project . getTasks (  )  . create ( name ,    Upload . class )  ;", "upload . setDescription (  (  \" Uploads   all   artifacts   belonging   to    \"     +    configuration )  )  ;", "upload . setGroup ( BasePlugin . UPLOAD _ GROUP )  ;", "upload . setConfiguration ( configuration )  ;", "upload . setUploadDescriptor ( true )  ;", "upload . getConventionMapping (  )  . map (  \" descriptorDestination \"  ,    new   Callable < File >  (  )     {", "public   File   call (  )    throws   Exception    {", "return   new   File ( project . getBuildDir (  )  ,     \" ivy . xml \"  )  ;", "}", "}  )  ;", "return   upload ;", "}", "METHOD_END"], "methodName": ["createUploadTask"], "fileName": "org.gradle.api.internal.plugins.UploadRule"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Pattern :     \"     +     ( UploadRule . PREFIX )  )     +     \"  < ConfigurationName >  :    Assembles   and   uploads   the   artifacts   belonging   to   a   configuration .  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.internal.plugins.UploadRule"}, {"methodBody": ["METHOD_START", "{", "registration . add ( JvmBinaryRenderer . class )  ;", "}", "METHOD_END"], "methodName": ["registerGlobalServices"], "fileName": "org.gradle.api.internal.tasks.CompileServices"}, {"methodBody": ["METHOD_START", "{", "registration . addProvider ( new   CompileServices . GradleScopeCompileServices (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerGradleServices"], "fileName": "org.gradle.api.internal.tasks.CompileServices"}, {"methodBody": ["METHOD_START", "{", "return   allGroovy ;", "}", "METHOD_END"], "methodName": ["getAllGroovy"], "fileName": "org.gradle.api.internal.tasks.DefaultGroovySourceSet"}, {"methodBody": ["METHOD_START", "{", "return   groovy ;", "}", "METHOD_END"], "methodName": ["getGroovy"], "fileName": "org.gradle.api.internal.tasks.DefaultGroovySourceSet"}, {"methodBody": ["METHOD_START", "{", "configure ( configureClosure ,    getGroovy (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["groovy"], "fileName": "org.gradle.api.internal.tasks.DefaultGroovySourceSet"}, {"methodBody": ["METHOD_START", "{", "output . builtBy ( taskPaths )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["compiledBy"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . uncapitalize (  (  ( getTaskBaseName (  )  )     +     ( StringUtils . capitalize ( baseName )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configurationNameOf"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   allJavaSource ;", "}", "METHOD_END"], "methodName": ["getAllJava"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   allSource ;", "}", "METHOD_END"], "methodName": ["getAllSource"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   getTaskName ( null ,     \" classes \"  )  ;", "}", "METHOD_END"], "methodName": ["getClassesTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   compileClasspath ;", "}", "METHOD_END"], "methodName": ["getCompileClasspath"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   configurationNameOf ( JavaPlugin . COMPILE _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getCompileConfigurationName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   getCompileTaskName (  \" java \"  )  ;", "}", "METHOD_END"], "methodName": ["getCompileJavaTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   configurationNameOf ( JavaPlugin . COMPILE _ ONLY _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getCompileOnlyConfigurationName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   getTaskName (  \" compile \"  ,    language )  ;", "}", "METHOD_END"], "methodName": ["getCompileTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   getTaskName ( null ,     \" jar \"  )  ;", "}", "METHOD_END"], "methodName": ["getJarTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   javaSource ;", "}", "METHOD_END"], "methodName": ["getJava"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   output ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   getTaskName (  \" process \"  ,     \" resources \"  )  ;", "}", "METHOD_END"], "methodName": ["getProcessResourcesTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   resources ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   runtimeClasspath ;", "}", "METHOD_END"], "methodName": ["getRuntimeClasspath"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   configurationNameOf ( JavaPlugin . RUNTIME _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["getRuntimeConfigurationName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getTaskBaseName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   namingScheme . getTaskName ( verb ,    target )  ;", "}", "METHOD_END"], "methodName": ["getTaskName"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "configure ( configureClosure ,    getJava (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["java"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "configure ( configureClosure ,    getResources (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["resources"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "this . output    =    classes ;", "}", "METHOD_END"], "methodName": ["setClasses"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "compileClasspath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setCompileClasspath"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "runtimeClasspath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setRuntimeClasspath"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSet"}, {"methodBody": ["METHOD_START", "{", "classesDirs . from ( classesDir )  ;", "}", "METHOD_END"], "methodName": ["addClassesDir"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSetOutput"}, {"methodBody": ["METHOD_START", "{", "outputDirectories . builtBy ( taskPaths )  ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.internal.tasks.DefaultSourceSetOutput"}, {"methodBody": ["METHOD_START", "{", "return   sourceSet . getCompileClasspath (  )  . getBuildDependencies (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.tasks.SourceSetCompileClasspath"}, {"methodBody": ["METHOD_START", "{", "return   sourceSet . getCompileClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getFiles"], "fileName": "org.gradle.api.internal.tasks.SourceSetCompileClasspath"}, {"methodBody": ["METHOD_START", "{", "CreateStartScripts   startScripts    =    project . getTasks (  )  . create ( ApplicationPlugin . TASK _ START _ SCRIPTS _ NAME ,    CreateStartScripts . class )  ;", "startScripts . setDescription (  \" Creates   OS   specific   scripts   to   run   the   project   as   a   JVM   application .  \"  )  ;", "startScripts . setClasspath ( project . getTasks (  )  . getAt ( JavaPlugin . JAR _ TASK _ NAME )  . getOutputs (  )  . getFiles (  )  . plus ( project . getConfigurations (  )  . getByName ( JavaPlugin . RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  )  )  ;", "startScripts . getConventionMapping (  )  . map (  \" mainClassName \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getMainClassName (  )  ;", "}", "}  )  ;", "startScripts . getConventionMapping (  )  . map (  \" applicationName \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getApplicationName (  )  ;", "}", "}  )  ;", "startScripts . getConventionMapping (  )  . map (  \" outputDir \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   new   File ( project . getBuildDir (  )  ,     \" scripts \"  )  ;", "}", "}  )  ;", "startScripts . getConventionMapping (  )  . map (  \" executableDir \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getExecutableDir (  )  ;", "}", "}  )  ;", "startScripts . getConventionMapping (  )  . map (  \" defaultJvmOpts \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getApplicationDefaultJvmArgs (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addCreateScriptsTask"], "fileName": "org.gradle.api.plugins.ApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "pluginConvention    =    new   ApplicationPluginConvention ( project )  ;", "pluginConvention . setApplicationName ( project . getName (  )  )  ;", "project . getConvention (  )  . getPlugins (  )  . put (  \" application \"  ,    pluginConvention )  ;", "}", "METHOD_END"], "methodName": ["addPluginConvention"], "fileName": "org.gradle.api.plugins.ApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "JavaExec   run    =    project . getTasks (  )  . create ( ApplicationPlugin . TASK _ RUN _ NAME ,    JavaExec . class )  ;", "run . setDescription (  \" Runs   this   project   as   a   JVM   application \"  )  ;", "run . setGroup ( ApplicationPlugin . APPLICATION _ GROUP )  ;", "JavaPluginConvention   javaPluginConvention    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  ;", "run . setClasspath ( getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  . getRuntimeClasspath (  )  )  ;", "run . getConventionMapping (  )  . map (  \" main \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getMainClassName (  )  ;", "}", "}  )  ;", "run . getConventionMapping (  )  . map (  \" jvmArgs \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getApplicationDefaultJvmArgs (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRunTask"], "fileName": "org.gradle.api.plugins.ApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "Task   jar    =    project . getTasks (  )  . getAt ( JavaPlugin . JAR _ TASK _ NAME )  ;", "Task   startScripts    =    project . getTasks (  )  . getAt (  . TASK _ START _ SCRIPTS _ NAME )  ;", "CopySpec   libChildSpec    =    project . copySpec (  )  ;", "libChildSpec . into (  \" lib \"  )  ;", "libChildSpec . from ( jar )  ;", "libChildSpec . from ( project . getConfigurations (  )  . getByName ( JavaPlugin . RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  )  ;", "CopySpec   binChildSpec    =    project . copySpec (  )  ;", "binChildSpec . into ( new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getExecutableDir (  )  ;", "}", "}  )  ;", "binChildSpec . from ( startScripts )  ;", "binChildSpec . setFileMode (  4  9  3  )  ;", "CopySpec   childSpec    =    project . copySpec (  )  ;", "childSpec . from ( project . file (  \" src / dist \"  )  )  ;", "childSpec . with ( libChildSpec )  ;", "childSpec . with ( binChildSpec )  ;", "distSpec . with ( childSpec )  ;", "distSpec . with ( pluginConvention . getApplicationDistribution (  )  )  ;", "return   distSpec ;", "}", "METHOD_END"], "methodName": ["configureDistSpec"], "fileName": "org.gradle.api.plugins.ApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "installTask . doFirst ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "Sync   sync    =     (  ( Sync )     ( task )  )  ;", "File   destinationDir    =    sync . getDestinationDir (  )  ;", "if    ( destinationDir . isDirectory (  )  )     {", "String [  ]    children    =    destinationDir . list (  )  ;", "if    ( children    =  =    null )     {", "throw   new   UncheckedIOException (  (  \" Could   not   list   directory    \"     +    destinationDir )  )  ;", "}", "if    (  ( children . length )     >     0  )     {", "if    (  (  !  ( new   File ( destinationDir ,     \" lib \"  )  . isDirectory (  )  )  )     |  |     (  !  ( new   File ( destinationDir ,    pluginConvention . getExecutableDir (  )  )  . isDirectory (  )  )  )  )     {", "throw   new   GradleException (  (  (  (  (  (  (  \" The   specified   installation   directory    \\  '  \"     +    destinationDir )     +     \"  \\  '    is   neither   empty   nor   does   it   contain   an   installation   for    \\  '  \"  )     +     ( pluginConvention . getApplicationName (  )  )  )     +     \"  \\  '  .  \\ n \"  )     +     \" If   you   really   want   to   install   to   this   directory ,    delete   it   and   run   the   install   task   again .  \\ n \"  )     +     \" Alternatively ,    choose   a   different   installation   directory .  \"  )  )  ;", "}", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureInstallTask"], "fileName": "org.gradle.api.plugins.ApplicationPlugin"}, {"methodBody": ["METHOD_START", "{", "return   applicationDefaultJvmArgs ;", "}", "METHOD_END"], "methodName": ["getApplicationDefaultJvmArgs"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   applicationDistribution ;", "}", "METHOD_END"], "methodName": ["getApplicationDistribution"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   executableDir ;", "}", "METHOD_END"], "methodName": ["getExecutableDir"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   mainClassName ;", "}", "METHOD_END"], "methodName": ["getMainClassName"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . applicationDefaultJvmArgs    =    applicationDefaultJvmArgs ;", "}", "METHOD_END"], "methodName": ["setApplicationDefaultJvmArgs"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . applicationDistribution    =    applicationDistribution ;", "}", "METHOD_END"], "methodName": ["setApplicationDistribution"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . applicationName    =    applicationName ;", "}", "METHOD_END"], "methodName": ["setApplicationName"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . executableDir    =    executableDir ;", "}", "METHOD_END"], "methodName": ["setExecutableDir"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . mainClassName    =    mainClassName ;", "}", "METHOD_END"], "methodName": ["setMainClassName"], "fileName": "org.gradle.api.plugins.ApplicationPluginConvention"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( LifecycleBasePlugin . class )  ;", "BasePluginConvention   convention    =    new   BasePluginConvention ( project )  ;", "project . getConvention (  )  . getPlugins (  )  . put (  \" base \"  ,    convention )  ;", "configureBuildConfigurationRule ( project )  ;", "configureUploadRules ( project )  ;", "configureUploadArchivesTask (  )  ;", "configureArchiveDefaults ( project ,    convention )  ;", "configureConfigurations ( project )  ;", "configureAssemble (  (  ( ProjectInternal )     ( project )  )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( AbstractArchiveTask . class ,    new   Action < AbstractArchiveTask >  (  )     {", "public   void   execute ( AbstractArchiveTask   task )     {", "ConventionMapping   taskConventionMapping    =    task . getConventionMapping (  )  ;", "Callable < File >    destinationDir ;", "if    ( task   instanceof   Jar )     {", "destinationDir    =    new   Callable < File >  (  )     {", "public   File   call (  )    throws   Exception    {", "return   pluginConvention . getLibsDir (  )  ;", "}", "}  ;", "} else    {", "destinationDir    =    new   Callable < File >  (  )     {", "public   File   call (  )    throws   Exception    {", "return   pluginConvention . getDistsDir (  )  ;", "}", "}  ;", "}", "taskConventionMapping . map (  \" destinationDir \"  ,    destinationDir )  ;", "taskConventionMapping . map (  \" version \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )    throws   Exception    {", "return    ( project . getVersion (  )  )     =  =     ( Project . DEFAULT _ VERSION )     ?    null    :    project . getVersion (  )  . toString (  )  ;", "}", "}  )  ;", "taskConventionMapping . map (  \" baseName \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )    throws   Exception    {", "return   pluginConvention . getArchivesBaseName (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureArchiveDefaults"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . getByName ( BasePlugin . ASSEMBLE _ TASK _ NAME )  . dependsOn ( project . getConfigurations (  )  . getByName ( ARCHIVES _ CONFIGURATION )  . getAllArtifacts (  )  . getBuildDependencies (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureAssemble"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . addRule ( new   BuildConfigurationRule ( project . getConfigurations (  )  ,    project . getTasks (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBuildConfigurationRule"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "project . setStatus (  \" integration \"  )  ;", "Configuration   archivesConfiguration    =    configurations . maybeCreate ( ARCHIVES _ CONFIGURATION )  . setDescription (  \" Configuration   for   archive   artifacts .  \"  )  ;", "configurations . maybeCreate ( DEFAULT _ CONFIGURATION )  . setDescription (  \" Configuration   for   default   artifacts .  \"  )  ;", "final   DefaultArtifactPublicationSet   defaultArtifacts    =    project . getExtensions (  )  . create (  \" defaultArtifacts \"  ,    DefaultArtifactPublicationSet . class ,    archivesConfiguration . getArtifacts (  )  )  ;", "configurations . all ( new   Action < Configuration >  (  )     {", "public   void   execute ( Configuration   configuration )     {", "configuration . getArtifacts (  )  . all ( new   Action < PublishArtifact >  (  )     {", "public   void   execute ( PublishArtifact   artifact )     {", "defaultArtifacts . addCandidate ( artifact )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureConfigurations"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "configurationActionContainer . add ( new   Action < Project >  (  )     {", "public   void   execute ( Project   project )     {", "Upload   uploadArchives    =    project . getTasks (  )  . withType ( Upload . class )  . findByName ( BasePlugin . UPLOAD _ ARCHIVES _ TASK _ NAME )  ;", "if    ( uploadArchives    =  =    null )     {", "return ;", "}", "boolean   hasIvyRepo    =     !  ( uploadArchives . getRepositories (  )  . withType ( IvyArtifactRepository . class )  . isEmpty (  )  )  ;", "if    (  ! hasIvyRepo )     {", "return ;", "}", "ConfigurationInternal   configuration    =     (  ( ConfigurationInternal )     ( uploadArchives . getConfiguration (  )  )  )  ;", "Module   module    =    configuration . getModule (  )  ;", "ModuleVersionIdentifier   publicationId    =    moduleIdentifierFactory . moduleWithVersion ( module . getGroup (  )  ,    module . getName (  )  ,    module . getVersion (  )  )  ;", "publicationRegistry . registerPublication ( module . getProjectPath (  )  ,    new   DefaultProjectPublication ( Describables . of (  \" Ivy   publication \"  )  ,    publicationId ,    true )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureUploadArchivesTask"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . addRule ( new   UploadRule ( project )  )  ;", "}", "METHOD_END"], "methodName": ["configureUploadRules"], "fileName": "org.gradle.api.plugins.BasePlugin"}, {"methodBody": ["METHOD_START", "{", "return   archivesBaseName ;", "}", "METHOD_END"], "methodName": ["getArchivesBaseName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "File   curProjectBuildDir    =    project . getBuildDir (  )  ;", "if    (  (  ( distsDir )     !  =    null )     &  &     ( curProjectBuildDir . equals ( buildDir )  )  )     {", "return   distsDir ;", "}", "buildDir    =    curProjectBuildDir ;", "File   dir    =    project . getServices (  )  . get ( FileLookup . class )  . getFileResolver ( curProjectBuildDir )  . resolve ( distsDirName )  ;", "distsDir    =    dir ;", "return   dir ;", "}", "METHOD_END"], "methodName": ["getDistsDir"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   distsDirName ;", "}", "METHOD_END"], "methodName": ["getDistsDirName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "File   curProjectBuildDir    =    project . getBuildDir (  )  ;", "if    (  (  ( libsDir )     !  =    null )     &  &     ( curProjectBuildDir . equals ( buildDir )  )  )     {", "return   libsDir ;", "}", "buildDir    =    curProjectBuildDir ;", "File   dir    =    project . getServices (  )  . get ( FileLookup . class )  . getFileResolver ( curProjectBuildDir )  . resolve ( libsDirName )  ;", "libsDir    =    dir ;", "return   dir ;", "}", "METHOD_END"], "methodName": ["getLibsDir"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   libsDirName ;", "}", "METHOD_END"], "methodName": ["getLibsDirName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . archivesBaseName    =    archivesBaseName ;", "}", "METHOD_END"], "methodName": ["setArchivesBaseName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . distsDirName    =    distsDirName ;", "this . distsDir    =    null ;", "}", "METHOD_END"], "methodName": ["setDistsDirName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . libsDirName    =    libsDirName ;", "this . libsDir    =    null ;", "}", "METHOD_END"], "methodName": ["setLibsDirName"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . project    =    project ;", "}", "METHOD_END"], "methodName": ["setProject"], "fileName": "org.gradle.api.plugins.BasePluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . project    =    project ;", "project . getPluginManager (  )  . apply ( Java . class )  ;", "configureGroovyRuntimeExtension (  )  ;", "configureCompileDefaults (  )  ;", "configureSourceSetDefaults (  )  ;", "configureGroovydoc (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( GroovyCompile . class ,    new   Action < GroovyCompile >  (  )     {", "public   void   execute ( final   GroovyCompile   compile )     {", "compile . getConventionMapping (  )  . map (  \" groovyClasspath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   groovyRuntime . inferGroovyClasspath ( compile . getClasspath (  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureCompileDefaults"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "groovyRuntime    =    project . getExtensions (  )  . create ( GroovyBasePlugin . GROOVY _ RUNTIME _ EXTENSION _ NAME ,    GroovyRuntime . class ,    project )  ;", "}", "METHOD_END"], "methodName": ["configureGroovyRuntimeExtension"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( Groovydoc . class ,    new   Action < Groovydoc >  (  )     {", "public   void   execute ( final   Groovydoc   groovydoc )     {", "groovydoc . getConventionMapping (  )  . map (  \" groovyClasspath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "FileCollection   groovyClasspath    =    groovyRuntime . inferGroovyClasspath ( groovydoc . getClasspath (  )  )  ;", "ConfigurableFileCollection   jansi    =    project . files ( moduleRegistry . getExternalModule (  \" jansi \"  )  . getImplementationClasspath (  )  . getAsFiles (  )  )  ;", "return   groovyClasspath . plus ( jansi )  ;", "}", "}  )  ;", "groovydoc . getConventionMapping (  )  . map (  \" destinationDir \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   new   File ( java ( project . getConvention (  )  )  . getDocsDir (  )  ,     \" groovydoc \"  )  ;", "}", "}  )  ;", "groovydoc . getConventionMapping (  )  . map (  \" docTitle \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . getApiDocTitle (  )  ;", "}", "}  )  ;", "groovydoc . getConventionMapping (  )  . map (  \" windowTitle \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . getApiDocTitle (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureGroovydoc"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . all ( new   Action < SourceSet >  (  )     {", "public   void   execute ( SourceSet   sourceSet )     {", "final   DefaultGroovySourceSet   groovySourceSet    =    new   DefaultGroovySourceSet (  \" groovy \"  ,     (  ( DefaultSourceSet )     ( sourceSet )  )  . getDisplayName (  )  ,    sourceDirectorySetFactory )  ;", "new   DslObject ( sourceSet )  . getConvention (  )  . getPlugins (  )  . put (  \" groovy \"  ,    groovySourceSet )  ;", "groovySourceSet . getGroovy (  )  . srcDir (  (  (  \" src /  \"     +     ( sourceSet . getName (  )  )  )     +     \"  / groovy \"  )  )  ;", "sourceSet . getResources (  )  . getFilter (  )  . exclude ( new   Spec < FileTreeElement >  (  )     {", "public   boolean   isSatisfiedBy ( FileTreeElement   element )     {", "return   groovySourceSet . getGroovy (  )  . contains ( element . getFile (  )  )  ;", "}", "}  )  ;", "sourceSet . getAllJava (  )  . source ( groovySourceSet . getGroovy (  )  )  ;", "sourceSet . getAllSource (  )  . source ( groovySourceSet . getGroovy (  )  )  ;", "String   compileTaskName    =    sourceSet . getCompileTaskName (  \" groovy \"  )  ;", "GroovyCompile   compile    =    project . getTasks (  )  . create ( compileTaskName ,    GroovyCompile . class )  ;", "SourceSetUtil . configureForSourceSet ( sourceSet ,    groovySourceSet . getGroovy (  )  ,    compile ,    compile . getOptions (  )  ,    project )  ;", "compile . dependsOn ( sourceSet . getCompileJavaTaskName (  )  )  ;", "compile . setDescription (  (  (  \" Compiles   the    \"     +     ( sourceSet . getName (  )  )  )     +     \"    Groovy   source .  \"  )  )  ;", "compile . setSource ( groovySourceSet . getGroovy (  )  )  ;", "project . getTasks (  )  . getByName ( sourceSet . getClassesTaskName (  )  )  . dependsOn ( compileTaskName )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureSourceSetDefaults"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "return   convention . getPlugin ( JavaPluginConvention . class )  ;", "}", "METHOD_END"], "methodName": ["java"], "fileName": "org.gradle.api.plugins.GroovyBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( GroovyBasePlugin . class )  ;", "project . getPluginManager (  )  . apply ( JavaPlugin . class )  ;", "configureGroovydoc ( project )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.GroovyPlugin"}, {"methodBody": ["METHOD_START", "{", "Groovydoc   groovyDoc    =    project . getTasks (  )  . create ( GroovyPlugin . GROOVYDOC _ TASK _ NAME ,    Groovydoc . class )  ;", "groovyDoc . setDescription (  \" Generates   Groovydoc   API   documentation   for   the   main   source   code .  \"  )  ;", "groovyDoc . setGroup ( JavaBasePlugin . DOCUMENTATION _ GROUP )  ;", "JavaPluginConvention   convention    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  ;", "SourceSet   sourceSet    =    convention . getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  ;", "groovyDoc . setClasspath ( sourceSet . getOutput (  )  . plus ( sourceSet . getCompileClasspath (  )  )  )  ;", "GroovySourceSet   groovySourceSet    =    new   DslObject ( sourceSet )  . getConvention (  )  . getPlugin ( GroovySourceSet . class )  ;", "groovyDoc . setSource ( groovySourceSet . getGroovy (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureGroovydoc"], "fileName": "org.gradle.api.plugins.GroovyPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( BasePlugin . class )  ;", "project . getPluginManager (  )  . apply ( ReportingBasePlugin . class )  ;", "project . getPluginManager (  )  . apply ( LanguageBasePlugin . class )  ;", "project . getPluginManager (  )  . apply ( BinaryBasePlugin . class )  ;", "JavaPluginConvention   javaConvention    =    new   JavaPluginConvention ( project ,    instantiator )  ;", "project . getConvention (  )  . getPlugins (  )  . put (  \" java \"  ,    javaConvention )  ;", "configureCompileDefaults ( project ,    javaConvention )  ;", ". BridgedBinaries   binaries    =    configureSourceSetDefaults ( javaConvention )  ;", "modelRegistry . register ( ModelRegistrations . bridgedInstance ( ModelReference . of (  \" bridgedBinaries \"  ,     . BridgedBinaries . class )  ,    binaries )  . descriptor (  \"  . apply (  )  \"  )  . hidden ( true )  . build (  )  )  ;", "configureJavaDoc ( project ,    javaConvention )  ;", "configureTest ( project ,    javaConvention )  ;", "configureBuildNeeded ( project )  ;", "configureBuildDependents ( project )  ;", "configureSchema ( project )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "binary . getTasks (  )  . addLater ( compileTask )  ;", "binary . getTasks (  )  . addLater ( resourcesTask )  ;", "binary . getTasks (  )  . addLater ( classesTask )  ;", "binary . builtBy ( classesTask )  ;", "}", "METHOD_END"], "methodName": ["attachTasksToBinary"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "String   singleTest    =    getTaskPrefixedProperty ( test ,     \" single \"  )  ;", "if    ( singleTest    =  =    null )     {", "test . getInputs (  )  . files ( test . getCandidateClassFiles (  )  )  . withPropertyName (  \" nonEmptyCandidateClassFiles \"  )  . withPathSensitivity ( RELATIVE )  . skipWhenEmpty (  )  ;", "return ;", "}", "test . prependParallelSafeAction ( new   Action < Task >  (  )     {", "public   void   execute ( Task   task )     {", "test . getLogger (  )  . info (  \" Running   single   tests   with   pattern :     {  }  \"  ,    test . getIncludes (  )  )  ;", "}", "}  )  ;", "test . setIncludes ( WrapUtil . toSet (  (  (  \"  *  *  /  \"     +    singleTest )     +     \"  *  . class \"  )  )  )  ;", "test . addTestListener ( new   NoMatchingTestsReporter (  (  \" Could   not   find   matching   test   for   pattern :     \"     +    singleTest )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureBasedOnSingleProperty"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "DefaultTask   buildTask    =    project . getTasks (  )  . create ( JavaBasePlugin . BUILD _ DEPENDENTS _ TASK _ NAME ,    DefaultTask . class )  ;", "buildTask . setDescription (  \" Assembles   and   tests   this   project   and   all   projects   that   depend   on   it .  \"  )  ;", "buildTask . setGroup ( BasePlugin . BUILD _ GROUP )  ;", "buildTask . dependsOn ( JavaBasePlugin . BUILD _ TASK _ NAME )  ;", "buildTask . doFirst ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "if    (  !  ( task . getProject (  )  . getGradle (  )  . getIncludedBuilds (  )  . isEmpty (  )  )  )     {", "task . getProject (  )  . getLogger (  )  . warn (  (  (  \"  [ composite - build ]    Warning :     `  \"     +     ( task . getPath (  )  )  )     +     \"  `    task   does   not   build   included   builds .  \"  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureBuildDependents"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "DefaultTask   buildTask    =    project . getTasks (  )  . create ( JavaBasePlugin . BUILD _ NEEDED _ TASK _ NAME ,    DefaultTask . class )  ;", "buildTask . setDescription (  \" Assembles   and   tests   this   project   and   all   projects   it   depends   on .  \"  )  ;", "buildTask . setGroup ( BasePlugin . BUILD _ GROUP )  ;", "buildTask . dependsOn ( JavaBasePlugin . BUILD _ TASK _ NAME )  ;", "}", "METHOD_END"], "methodName": ["configureBuildNeeded"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . configureEachLater ( AbstractCompile . class ,    new   Action < AbstractCompile >  (  )     {", "public   void   execute ( final   AbstractCompile   compile )     {", "ConventionMapping   conventionMapping    =    compile . getConventionMapping (  )  ;", "conventionMapping . map (  \" sourceCompatibility \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   getSourceCompatibility (  )  . toString (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" targetCompatibility \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   getTargetCompatibility (  )  . toString (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureCompileDefaults"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "SingleMessageLogger . nagUserOfDiscontinuedMethod (  \" configureForSourceSet ( SourceSet ,    AbstractCompile )  \"  )  ;", "ConventionMapping   conventionMapping ;", "compile . setDescription (  (  (  \" Compiles   the    \"     +     ( sourceSet . get (  )  )  )     +     \"  .  \"  )  )  ;", "conventionMapping    =    compile . getConventionMapping (  )  ;", "compile . setSource ( sourceSet . get (  )  )  ;", "conventionMapping . map (  \" classpath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   sourceSet . getCompileClasspath (  )  . plus ( compile . getProject (  )  . files ( sourceSet . get (  )  . getOutputDir (  )  )  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" destinationDir \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   sourceSet . getOutput (  )  . getClassesDir (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureForSourceSet"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( Javadoc . class ,    new   Action < Javadoc >  (  )     {", "public   void   execute ( Javadoc   javadoc )     {", "getConventionMapping (  )  . map (  \" destinationDir \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   new   File ( convention . getDocsDir (  )  ,     \" javadoc \"  )  ;", "}", "}  )  ;", "getConventionMapping (  )  . map (  \" title \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . getApiDocTitle (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureJavaDoc"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "AttributeMatchingStrategy < Usage >    matchingStrategy    =    project . getDependencies (  )  . getAttributesSchema (  )  . attribute ( USAGE _ ATTRIBUTE )  ;", "matchingStrategy . getCompatibilityRules (  )  . add ( JavaBasePlugin . UsageCompatibilityRules . class )  ;", "matchingStrategy . getDisambiguationRules (  )  . add ( JavaBasePlugin . UsageDisambiguationRules . class ,    new   Action < ActionConfiguration >  (  )     {", "@ Override", "public   void   execute ( ActionConfiguration   actionConfiguration )     {", "actionConfiguration . params ( objectFactory . named ( Usage . class ,    JAVA _ API )  )  ;", "actionConfiguration . params ( objectFactory . named ( Usage . class ,    JAVA _ API _ CLASSES )  )  ;", "actionConfiguration . params ( objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ JARS )  )  ;", "actionConfiguration . params ( objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ CLASSES )  )  ;", "actionConfiguration . params ( objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ RESOURCES )  )  ;", "}", "}  )  ;", "project . getDependencies (  )  . getArtifactTypes (  )  . create ( JAR _ TYPE )  . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ JARS )  )  ;", "}", "METHOD_END"], "methodName": ["configureSchema"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "final   Project   project    =    pluginConvention . getProject (  )  ;", "final   List < ClassDirectoryBinarySpecInternal >    binaries    =    Lists . newArrayList (  )  ;", "pluginConvention . getSourceSets (  )  . all ( new   Action < SourceSet >  (  )     {", "public   void   execute ( final   SourceSet   sourceSet )     {", "ConventionMapping   outputConventionMapping    =     (  ( IConventionAware )     ( sourceSet . getOutput (  )  )  )  . getConventionMapping (  )  ;", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "defineConfigurationsForSourceSet ( sourceSet ,    configurations )  ;", "definePathsForSourceSet ( sourceSet ,    outputConventionMapping ,    project )  ;", "SourceSetUtil . configureOutputDirectoryForSourceSet ( sourceSet ,    sourceSet . getJava (  )  ,    project )  ;", "Provider < ProcessResources >    resourcesTask    =    createProcessResourcesTaskForBinary ( sourceSet ,    sourceSet . getResources (  )  ,    project )  ;", "Provider < JavaCompile >    compileTask    =    createCompileJavaTaskForBinary ( sourceSet ,    sourceSet . getJava (  )  ,    project )  ;", "Provider < Task >    classesTask    =    createBinaryLifecycleTask ( sourceSet ,    project )  ;", "DefaultComponentSpecIdentifier   binaryId    =    new   DefaultComponentSpecIdentifier ( project . getPath (  )  ,    sourceSet . getName (  )  )  ;", "ClassDirectoryBinarySpecInternal   binary    =    instantiator . newInstance ( DefaultClassDirectoryBinarySpec . class ,    binaryId ,    sourceSet ,    javaToolChain ,    DefaultJavaPlatform . current (  )  ,    instantiator ,    taskFactory )  ;", "Classpath   compileClasspath    =    new   SourceSetCompileClasspath ( sourceSet )  ;", "DefaultJavaSourceSet   javaSourceSet    =    instantiator . newInstance ( DefaultJavaSourceSet . class ,    binaryId . child (  \" java \"  )  ,    sourceSet . getJava (  )  ,    compileClasspath )  ;", "JvmResourceSet   resourceSet    =    instantiator . newInstance ( DefaultJvmResourceSet . class ,    binaryId . child (  \" resources \"  )  ,    sourceSet . getResources (  )  )  ;", "binary . addSourceSet ( javaSourceSet )  ;", "binary . addSourceSet ( resourceSet )  ;", "attachTasksToBinary ( binary ,    compileTask ,    resourcesTask ,    classesTask )  ;", "binaries . add ( binary )  ;", "}", "}  )  ;", "return   new   JavaBasePlugin . BridgedBinaries ( binaries )  ;", "}", "METHOD_END"], "methodName": ["configureSourceSetDefaults"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( Test . class ,    new   Action < Test >  (  )     {", "public   void   execute ( final   Test   test )     {", "configureTestDefaults ( test ,    project ,    convention )  ;", "}", "}  )  ;", "project . getGradle (  )  . getTaskGraph (  )  . whenReady ( new   Action < TaskExecutionGraph >  (  )     {", "@ Override", "public   void   execute ( final   TaskExecutionGraph   taskExecutionGraph )     {", "project . getTasks (  )  . withType ( Test . class ,    new   Action < Test >  (  )     {", "@ Override", "public   void   execute ( Test   test )     {", "if    ( taskExecutionGraph . hasTask ( test )  )     {", "configureBasedOnSingleProperty ( test )  ;", "overwriteDebugIfDebugPropertyIsSet ( test )  ;", "}", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureTest"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "DslObject   htmlReport    =    new   DslObject ( test . getReports (  )  . getHtml (  )  )  ;", "DslObject   xmlReport    =    new   DslObject ( test . getReports (  )  . getJunitXml (  )  )  ;", "xmlReport . getConventionMapping (  )  . map (  \" destination \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   new   File ( convention . getTestResultsDir (  )  ,    test . getName (  )  )  ;", "}", "}  )  ;", "htmlReport . getConventionMapping (  )  . map (  \" destination \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   new   File ( convention . getTestReportDir (  )  ,    test . getName (  )  )  ;", "}", "}  )  ;", "test . getConventionMapping (  )  . map (  \" binResultsDir \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   new   File ( convention . getTestResultsDir (  )  ,     (  ( test . getName (  )  )     +     \"  / binary \"  )  )  ;", "}", "}  )  ;", "test . workingDir ( project . getProjectDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureTestDefaults"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "Provider < Task >    classesTask    =    target . getTasks (  )  . createLater ( sourceSet . getClassesTaskName (  )  ,    new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   classesTask )     {", "classesTask . setGroup ( BUILD _ GROUP )  ;", "classesTask . setDescription (  (  (  \" Assembles    \"     +     ( sourceSet . getOutput (  )  )  )     +     \"  .  \"  )  )  ;", "classesTask . dependsOn ( sourceSet . getOutput (  )  . getDirs (  )  )  ;", "classesTask . dependsOn ( sourceSet . getCompileJavaTaskName (  )  )  ;", "classesTask . dependsOn ( sourceSet . getProcessResourcesTaskName (  )  )  ;", "}", "}  )  ;", "sourceSet . compiledBy ( classesTask )  ;", "return   classesTask ;", "}", "METHOD_END"], "methodName": ["createBinaryLifecycleTask"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "return   target . getTasks (  )  . createLater ( sourceSet . getCompileJavaTaskName (  )  ,    JavaCompile . class ,    new   Action < JavaCompile >  (  )     {", "@ Override", "public   void   execute ( JavaCompile   compileTask )     {", "compileTask . setDescription (  (  (  \" Compiles    \"     +    sourceDirectorySet )     +     \"  .  \"  )  )  ;", "compileTask . setSource ( sourceDirectorySet )  ;", "ConventionMapping   conventionMapping    =    compileTask . getConventionMapping (  )  ;", "conventionMapping . map (  \" classpath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   sourceSet . getCompileClasspath (  )  ;", "}", "}  )  ;", "SourceSetUtil . configureAnnotationProcessorPath ( sourceSet ,    compileTask . getOptions (  )  ,    target )  ;", "compileTask . setDestinationDir ( target . provider ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )     {", "return   sourceDirectorySet . getOutputDir (  )  ;", "}", "}  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createCompileJavaTaskForBinary"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "return   target . getTasks (  )  . createLater ( sourceSet . getProcessResourcesTaskName (  )  ,    ProcessResources . class ,    new   Action < ProcessResources >  (  )     {", "@ Override", "public   void   execute ( ProcessResources   resourcesTask )     {", "resourcesTask . setDescription (  (  (  \" Processes    \"     +    resourceSet )     +     \"  .  \"  )  )  ;", "new   DslObject ( resourcesTask )  . getConventionMapping (  )  . map (  \" destinationDir \"  ,    new   Callable < File >  (  )     {", "public   File   call (  )     {", "return   sourceSet . getOutput (  )  . getResourcesDir (  )  ;", "}", "}  )  ;", "resourcesTask . from ( resourceSet )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createProcessResourcesTaskForBinary"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "String   compileConfigurationName    =    sourceSet . getCompileConfigurationName (  )  ;", "String   implementationConfigurationName    =    sourceSet . getImplementationConfigurationName (  )  ;", "String   runtimeConfigurationName    =    sourceSet . getRuntimeConfigurationName (  )  ;", "String   runtimeOnlyConfigurationName    =    sourceSet . getRuntimeOnlyConfigurationName (  )  ;", "String   compileOnlyConfigurationName    =    sourceSet . getCompileOnlyConfigurationName (  )  ;", "String   compileClasspathConfigurationName    =    sourceSet . getCompileClasspathConfigurationName (  )  ;", "String   annotationProcessorConfigurationName    =    sourceSet . getAnnotationProcessorConfigurationName (  )  ;", "String   runtimeClasspathConfigurationName    =    sourceSet . getRuntimeClasspathConfigurationName (  )  ;", "String   sourceSetName    =    sourceSet . toString (  )  ;", "Configuration   compileConfiguration    =    configurations . maybeCreate ( compileConfigurationName )  ;", "compileConfiguration . setVisible ( false )  ;", "compileConfiguration . setDescription (  (  (  (  (  \" Dependencies   for    \"     +    sourceSetName )     +     \"     ( deprecated ,    use    '  \"  )     +    implementationConfigurationName )     +     \"     '    instead )  .  \"  )  )  ;", "Configuration   implementationConfiguration    =    configurations . maybeCreate ( implementationConfigurationName )  ;", "implementationConfiguration . setVisible ( false )  ;", "implementationConfiguration . setDescription (  (  (  \" Implementation   only   dependencies   for    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "implementationConfiguration . setCanBeConsumed ( false )  ;", "implementationConfiguration . setCanBeResolved ( false )  ;", "implementationConfiguration . extendsFrom ( compileConfiguration )  ;", "Configuration   runtimeConfiguration    =    configurations . maybeCreate ( runtimeConfigurationName )  ;", "runtimeConfiguration . setVisible ( false )  ;", "runtimeConfiguration . extendsFrom ( compileConfiguration )  ;", "runtimeConfiguration . setDescription (  (  (  (  (  \" Runtime   dependencies   for    \"     +    sourceSetName )     +     \"     ( deprecated ,    use    '  \"  )     +    runtimeOnlyConfigurationName )     +     \"     '    instead )  .  \"  )  )  ;", "Configuration   compileOnlyConfiguration    =    configurations . maybeCreate ( compileOnlyConfigurationName )  ;", "compileOnlyConfiguration . setVisible ( false )  ;", "compileOnlyConfiguration . setDescription (  (  (  \" Compile   only   dependencies   for    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "Configuration   compileClasspathConfiguration    =    configurations . maybeCreate ( compileClasspathConfigurationName )  ;", "compileClasspathConfiguration . setVisible ( false )  ;", "compileClasspathConfiguration . extendsFrom ( compileOnlyConfiguration ,    implementationConfiguration )  ;", "compileClasspathConfiguration . setDescription (  (  (  \" Compile   classpath   for    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "compileClasspathConfiguration . setCanBeConsumed ( false )  ;", "compileClasspathConfiguration . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ API )  )  ;", "Configuration   annotationProcessorConfiguration    =    configurations . maybeCreate ( annotationProcessorConfigurationName )  ;", "annotationProcessorConfiguration . setVisible ( false )  ;", "annotationProcessorConfiguration . setDescription (  (  (  \" Annotation   processors   and   their   dependencies   for    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "annotationProcessorConfiguration . setCanBeConsumed ( false )  ;", "annotationProcessorConfiguration . setCanBeResolved ( true )  ;", "Configuration   runtimeOnlyConfiguration    =    configurations . maybeCreate ( runtimeOnlyConfigurationName )  ;", "runtimeOnlyConfiguration . setVisible ( false )  ;", "runtimeOnlyConfiguration . setCanBeConsumed ( false )  ;", "runtimeOnlyConfiguration . setCanBeResolved ( false )  ;", "runtimeOnlyConfiguration . setDescription (  (  (  \" Runtime   only   dependencies   for    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "Configuration   runtimeClasspathConfiguration    =    configurations . maybeCreate ( runtimeClasspathConfigurationName )  ;", "runtimeClasspathConfiguration . setVisible ( false )  ;", "runtimeClasspathConfiguration . setCanBeConsumed ( false )  ;", "runtimeClasspathConfiguration . setCanBeResolved ( true )  ;", "runtimeClasspathConfiguration . setDescription (  (  (  \" Runtime   classpath   of    \"     +    sourceSetName )     +     \"  .  \"  )  )  ;", "runtimeClasspathConfiguration . extendsFrom ( runtimeOnlyConfiguration ,    runtimeConfiguration ,    implementationConfiguration )  ;", "runtimeClasspathConfiguration . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ RUNTIME )  )  ;", "sourceSet . setCompileClasspath ( compileClasspathConfiguration )  ;", "sourceSet . setRuntimeClasspath ( sourceSet . getOutput (  ) s ( runtimeClasspathConfiguration )  )  ;", "sourceSet . setAnnotationProcessorPath ( annotationProcessorConfiguration )  ;", "}", "METHOD_END"], "methodName": ["defineConfigurationsForSourceSet"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "outputConventionMapping . map (  \" resourcesDir \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "String   classesDirName    =     \" resources /  \"     +     ( sourceSet . getName (  )  )  ;", "return   new   File ( project . getBuildDir (  )  ,    classesDirName )  ;", "}", "}  )  ;", "sourceSet . get (  )  . srcDir (  (  (  \" src /  \"     +     ( sourceSet . getName (  )  )  )     +     \"  / java \"  )  )  ;", "sourceSet . getResources (  )  . srcDir (  (  (  \" src /  \"     +     ( sourceSet . getName (  )  )  )     +     \"  / resources \"  )  )  ;", "}", "METHOD_END"], "methodName": ["definePathsForSourceSet"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "String   suffix    =     '  .  '     +    propertyName ;", "String   value    =    System . getProperty (  (  ( task . getPath (  )  )     +    suffix )  )  ;", "if    ( value    =  =    null )     {", "return   System . getProperty (  (  ( task . getName (  )  )     +    suffix )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["getTaskPrefixedProperty"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "String   debugProp    =    getTaskPrefixedProperty ( test ,     \" debug \"  )  ;", "if    ( debugProp    !  =    null )     {", "test . prependParallelSafeAction ( new   Action < Task >  (  )     {", "public   void   execute ( Task   task )     {", "task . getLogger (  )  . info (  \" Running   tests   for   remote   debugging .  \"  )  ;", "}", "}  )  ;", "test . setDebug ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["overwriteDebugIfDebugPropertyIsSet"], "fileName": "org.gradle.api.plugins.JavaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "SourceSet   sourceSet    =    convention . getSourceSets (  )  . getByName (  \" main \"  )  ;", "Configuration   apiConfiguration    =    configurations . maybeCreate ( sourceSet . getApiConfigurationName (  )  )  ;", "apiConfiguration . setVisible ( false )  ;", "apiConfiguration . setDescription (  (  (  \" API   dependencies   for    \"     +    sourceSet )     +     \"  .  \"  )  )  ;", "apiConfiguration . setCanBeResolved ( false )  ;", "apiConfiguration . setCanBeConsumed ( false )  ;", "Configuration   apiElementsConfiguration    =    configurations . getByName ( sourceSet . getApiElementsConfigurationName (  )  )  ;", "apiElementsConfiguration . extendsFrom ( apiConfiguration )  ;", "final   JavaCompile   javaCompile    =     (  ( JavaCompile )     ( project . getTasks (  )  . getByPath ( Java . COMPILE _ JAVA _ TASK _ NAME )  )  )  ;", "ConfigurationPublications   publications    =    apiElementsConfiguration . getOutgoing (  )  ;", "ConfigurationVariant   variant    =    publications . getVariants (  )  . create (  \" classes \"  )  ;", "variant . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ API _ CLASSES )  )  ;", "variant . artifact ( new   Java . IntermediateJavaArtifact ( ArtifactTypeDefinition . JVM _ CLASS _ DIRECTORY ,    javaCompile )     {", "@ Override", "public   File   getFile (  )     {", "return   getDestinationDir (  )  ;", "}", "}  )  ;", "Configuration   implementationConfiguration    =    configurations . getByName ( sourceSet . getImplementationConfigurationName (  )  )  ;", "implementationConfiguration . extendsFrom ( apiConfiguration )  ;", "Configuration   compileConfiguration    =    configurations . getByName ( sourceSet . getCompileConfigurationName (  )  )  ;", "apiConfiguration . extendsFrom ( compileConfiguration )  ;", "}", "METHOD_END"], "methodName": ["addApiToMainSourceSet"], "fileName": "org.gradle.api.plugins.JavaLibraryPlugin"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    task . getProject (  )  ;", "final   Configuration   configuration    =    project . getConfigurations (  )  . getByName ( configurationName )  ;", "task . dependsOn ( configuration . getTaskDependencyFromProjectDependency ( useDependedOn ,    otherProjectTaskName )  )  ;", "}", "METHOD_END"], "methodName": ["addDependsOnTaskInOtherProjects"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "ConfigurationPublicatiopublicatio =    configuration . getOutgoing (  )  ;", "publicatiogetArtifacts (  )  . add ( jarArtifact )  ;", "publicatiogetAttributes (  )  . attribute ( ARTIFACT _ FORMAT ,    JAR _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["addJar"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "ConfigurationPublications   publications    =    configuration . getOutgoing (  )  ;", "publications . getArtifacts (  )  . add ( jarArtifact )  ;", "publications . getAttributes (  )  . attribute ( ARTIFACT _ FORMAT ,    JAR _ TYPE )  ;", "NamedDomainObjectContainer < ConfigurationVariant >    runtimeVariants    =    publications . getVariants (  )  ;", "ConfigurationVariant   classesVariant    =    runtimeVariants . create (  \" classes \"  )  ;", "classesVariant . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ CLASSES )  )  ;", "classesVariant . artifact ( new    . IntermediateJavaArtifact ( ArtifactTypeDefinition . JVM _ CLASS _ DIRECTORY ,    javaCompile )     {", "@ Override", "public   File   getFile (  )     {", "return   get (  )  . getDestinationDir (  )  ;", "}", "}  )  ;", "ConfigurationVariant   resourcesVariant    =    runtimeVariants . create (  \" resources \"  )  ;", "resourcesVariant . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ RESOURCES )  )  ;", "resourcesVariant . artifact ( new    . IntermediateJavaArtifact ( ArtifactTypeDefinition . JVM _ RESOURCES _ DIRECTORY ,    processResources )     {", "@ Override", "public   File   getFile (  )     {", "return   processResources . get (  )  . getDestinationDir (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRuntimeVariants"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( JavaBasePlugin . class )  ;", "Convention   javaConvention    =    project . getConvention (  )  . getPlugin ( Convention . class )  ;", "project . getServices (  )  . get ( ComponentRegistry . class )  . setMainComponent ( new    . BuildableJavaComponentImpl ( javaConvention )  )  ;", "BuildOutputCleanupRegistry   buildOutputCleanupRegistry    =    project . getServices (  )  . get ( BuildOutputCleanupRegistry . class )  ;", "configureSourceSets ( javaConvention ,    buildOutputCleanupRegistry )  ;", "configureConfigurations ( project )  ;", "configureJavaDoc ( javaConvention )  ;", "configureTest ( project ,    javaConvention )  ;", "configureArchivesAndComponent ( project ,    javaConvention )  ;", "configureBuild ( project )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "Jar   jar    =    project . getTasks (  )  . create ( JavaPlugin . JAR _ TASK _ NAME ,    Jar . class )  ;", "jar . setDescription (  \" Assembles   a   jar   archive   containing   the   main   classes .  \"  )  ;", "jar . setGroup ( BasePlugin . BUILD _ GROUP )  ;", "jar . from ( pluginConvention . getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  . getOutput (  )  )  ;", "ArchivePublishArtifact   jarArtifact    =    new   ArchivePublishArtifact ( jar )  ;", "Configuration   apiElementConfiguration    =    project . getConfigurations (  )  . getByName ( JavaPlugin . API _ ELEMENTS _ CONFIGURATION _ NAME )  ;", "Configuration   runtimeConfiguration    =    project . getConfigurations (  )  . getByName ( JavaPlugin . RUNTIME _ CONFIGURATION _ NAME )  ;", "Configuration   runtimeElementsConfiguration    =    project . getConfigurations (  )  . getByName ( JavaPlugin . RUNTIME _ ELEMENTS _ CONFIGURATION _ NAME )  ;", "project . getExtensions (  )  . getByType ( DefaultArtifactPublicationSet . class )  . addCandidate ( jarArtifact )  ;", "Provider < JavaCompile >    javaCompile    =    project . getTasks (  )  . getByNameLater ( JavaCompile . class ,    JavaPlugin . COMPILE _ JAVA _ TASK _ NAME )  ;", "Provider < ProcessResources >    processResources    =    project . getTasks (  )  . getByNameLater ( ProcessResources . class ,    JavaPlugin . PROCESS _ RESOURCES _ TASK _ NAME )  ;", "addJar ( apiElementConfiguration ,    jarArtifact )  ;", "addJar ( runtimeConfiguration ,    jarArtifact )  ;", "addRuntimeVariants ( runtimeElementsConfiguration ,    jarArtifact ,    javaCompile ,    processResources )  ;", "project . getComponents (  )  . add ( objectFactory . newInstance ( JavaLibrary . class ,    project . getConfigurations (  )  ,    jarArtifact )  )  ;", "project . getComponents (  )  . add ( objectFactory . newInstance ( JavaLibraryPlatform . class ,    project . getConfigurations (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureArchivesAndComponent"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "addDependsOnTaskInOtherProjects ( project . getTasks (  )  . getByName ( JavaBasePlugin . BUILD _ NEEDED _ TASK _ NAME )  ,    true ,    JavaBasePlugin . BUILD _ NEEDED _ TASK _ NAME ,    JavaPlugin . TEST _ RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  ;", "addDependsOnTaskInOtherProjects ( project . getTasks (  )  . getByName ( JavaBasePlugin . BUILD _ DEPENDENTS _ TASK _ NAME )  ,    false ,    JavaBasePlugin . BUILD _ DEPENDENTS _ TASK _ NAME ,    JavaPlugin . TEST _ RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["configureBuild"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "Configuration   defaultConfiguration    =    configurations . getByName ( DEFAULT _ CONFIGURATION )  ;", "Configuration   compileConfiguration    =    configurations . getByName (  . COMPILE _ CONFIGURATION _ NAME )  ;", "Configuration   implementationConfiguration    =    configurations . getByName (  . IMPLEMENTATION _ CONFIGURATION _ NAME )  ;", "Configuration   runtimeConfiguration    =    configurations . getByName (  . RUNTIME _ CONFIGURATION _ NAME )  ;", "Configuration   runtimeOnlyConfiguration    =    configurations . getByName (  . RUNTIME _ ONLY _ CONFIGURATION _ NAME )  ;", "Configuration   compileTestsConfiguration    =    configurations . getByName (  . TEST _ COMPILE _ CONFIGURATION _ NAME )  ;", "Configuration   testImplementationConfiguration    =    configurations . getByName (  . TEST _ IMPLEMENTATION _ CONFIGURATION _ NAME )  ;", "Configuration   testRuntimeConfiguration    =    configurations . getByName (  . TEST _ RUNTIME _ CONFIGURATION _ NAME )  ;", "Configuration   testRuntimeOnlyConfiguration    =    configurations . getByName (  . TEST _ RUNTIME _ ONLY _ CONFIGURATION _ NAME )  ;", "compileTestsConfiguration . extendsFrom ( compileConfiguration )  ;", "testImplementationConfiguration . extendsFrom ( implementationConfiguration )  ;", "testRuntimeConfiguration . extendsFrom ( runtimeConfiguration )  ;", "testRuntimeOnlyConfiguration . extendsFrom ( runtimeOnlyConfiguration )  ;", "Configuration   apiElementsConfiguration    =    configurations . maybeCreate (  . API _ ELEMENTS _ CONFIGURATION _ NAME )  ;", "apiElementsConfiguration . setVisible ( false )  ;", "apiElementsConfiguration . setDescription (  \" API   elements   for   main .  \"  )  ;", "apiElementsConfiguration . setCanBeResolved ( false )  ;", "apiElementsConfiguration . setCanBeConsumed ( true )  ;", "apiElementsConfiguration . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ API )  )  ;", "apiElementsConfiguration . extendsFrom ( runtimeConfiguration )  ;", "Configuration   runtimeElementsConfiguration    =    configurations . maybeCreate (  . RUNTIME _ ELEMENTS _ CONFIGURATION _ NAME )  ;", "runtimeElementsConfiguration . setVisible ( false )  ;", "runtimeElementsConfiguration . setCanBeConsumed ( true )  ;", "runtimeElementsConfiguration . setCanBeResolved ( false )  ;", "runtimeElementsConfiguration . setDescription (  \" Elements   of   runtime   for   main .  \"  )  ;", "runtimeElementsConfiguration . getAttributes (  )  . attribute ( USAGE _ ATTRIBUTE ,    objectFactory . named ( Usage . class ,    JAVA _ RUNTIME _ JARS )  )  ;", "runtimeElementsConfiguration . extendsFrom ( implementationConfiguration ,    runtimeOnlyConfiguration ,    runtimeConfiguration )  ;", "defaultConfiguration . extendsFrom ( runtimeElementsConfiguration )  ;", "}", "METHOD_END"], "methodName": ["configureConfigurations"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    pluginConvention . getProject (  )  ;", "SourceSet   mainSourceSet    =    pluginConvention . getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  ;", "Javadoc   javadoc    =    project . getTasks (  )  . create (  . JAVADOC _ TASK _ NAME ,    Javadoc . class )  ;", "setDescription (  \" Generates   Javadoc   API   documentation   for   the   main   source   code .  \"  )  ;", "setGroup ( JavaBasePlugin . DOCUMENTATION _ GROUP )  ;", "setClasspath ( mainSourceSet . getOutput (  )  . plus ( mainSourceSet . getCompileClasspath (  )  )  )  ;", "setSource ( mainSourceSet . getAllJava (  )  )  ;", "addDependsOnTaskInOtherProjects ( javadoc ,    true ,     . JAVADOC _ TASK _ NAME ,     . COMPILE _ CONFIGURATION _ NAME )  ;", "}", "METHOD_END"], "methodName": ["configureJavaDoc"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    pluginConvention . getProject (  )  ;", "SourceSet   main    =    pluginConvention . getSourceSets (  )  . create ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  ;", "SourceSet   test    =    pluginConvention . getSourceSets (  )  . create ( SourceSet . TEST _ SOURCE _ SET _ NAME )  ;", "test . setCompileClasspath ( project . files ( main . getOutput (  )  ,    project . getConfigurations (  )  . getByName ( JavaPlugin . TEST _ COMPILE _ CLASSPATH _ CONFIGURATION _ NAME )  )  )  ;", "test . setRuntimeClasspath ( project . files ( test . getOutput (  )  ,    main . getOutput (  )  ,    project . getConfigurations (  )  . getByName ( JavaPlugin . TEST _ RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  )  )  ;", "pluginConvention . getSourceSets (  )  . all ( new   Action < SourceSet >  (  )     {", "@ Override", "public   void   execute ( SourceSet   sourceSet )     {", "buildOutputCleanupRegistry . registerOutputs ( sourceSet . getOutput (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureSourceSets"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( Test . class ,    new   Action < Test >  (  )     {", "public   void   execute ( final   Test   test )     {", "test . getConventionMapping (  )  . map (  \" testClassesDirs \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getSourceSets (  )  . getByName ( SourceSet . TEST _ SOURCE _ SET _ NAME )  . getOutput (  )  . getClassesDirs (  )  ;", "}", "}  )  ;", "test . getConventionMapping (  )  . map (  \" classpath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getSourceSets (  )  . getByName ( SourceSet . TEST _ SOURCE _ SET _ NAME )  . getRuntimeClasspath (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "Test   test    =    project . getTasks (  )  . create ( JavaPlugin . TEST _ TASK _ NAME ,    Test . class )  ;", "project . getTasks (  )  . getByName ( JavaBasePlugin . CHECK _ TASK _ NAME )  . dependsOn ( test )  ;", "test . setDescription (  \" Runs   the   unit   tests .  \"  )  ;", "test . setGroup ( JavaBasePlugin . VERIFICATION _ GROUP )  ;", "}", "METHOD_END"], "methodName": ["configureTest"], "fileName": "org.gradle.api.plugins.JavaPlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultManifest ( project . getFileResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["createManifest"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project . getServices (  )  . get ( FileLookup . class )  . getFileResolver ( project . getBuildDir (  )  )  . resolve ( docsDirName )  ;", "}", "METHOD_END"], "methodName": ["getDocsDir"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   docsDirName ;", "}", "METHOD_END"], "methodName": ["getDocsDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . getBaseDir (  )  ;", "}", "METHOD_END"], "methodName": ["getReportsDir"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return    ( srcCompat )     !  =    null    ?    srcCompat    :    JavaVersion . current (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   sourceSets ;", "}", "METHOD_END"], "methodName": ["getSourceSets"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return    ( targetCompat )     !  =    null    ?    targetCompat    :    getSourceCompatibility (  )  ;", "}", "METHOD_END"], "methodName": ["getTargetCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project . getServices (  )  . get ( FileLookup . class )  . getFileResolver ( getReportsDir (  )  )  . resolve ( testReportDirName )  ;", "}", "METHOD_END"], "methodName": ["getTestReportDir"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   testReportDirName ;", "}", "METHOD_END"], "methodName": ["getTestReportDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project . getServices (  )  . get ( FileLookup . class )  . getFileResolver ( project . getBuildDir (  )  )  . resolve ( testResultsDirName )  ;", "}", "METHOD_END"], "methodName": ["getTestResultsDir"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   testResultsDirName ;", "}", "METHOD_END"], "methodName": ["getTestResultsDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   manifest ( Actions .  < Manifest > doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["manifest"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   configure ( closure ,    createManifest (  )  )  ;", "}", "METHOD_END"], "methodName": ["manifest"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "Manifest   manifest    =    createManifest (  )  ;", "ac . execute ( manifest )  ;", "return   manifest ;", "}", "METHOD_END"], "methodName": ["manifest"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . docsDirName    =    docsDirName ;", "}", "METHOD_END"], "methodName": ["setDocsDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "setSourceCompatibility ( JavaVersion . toVersion ( value )  )  ;", "}", "METHOD_END"], "methodName": ["setSourceCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "srcCompat    =    value ;", "}", "METHOD_END"], "methodName": ["setSourceCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "setTargetCompatibility ( JavaVersion . toVersion ( value )  )  ;", "}", "METHOD_END"], "methodName": ["setTargetCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "targetCompat    =    value ;", "}", "METHOD_END"], "methodName": ["setTargetCompatibility"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . testReportDirName    =    testReportDirName ;", "}", "METHOD_END"], "methodName": ["setTestReportDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . testResultsDirName    =    testResultsDirName ;", "}", "METHOD_END"], "methodName": ["setTestResultsDirName"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   sourceSets . configure ( closure )  ;", "}", "METHOD_END"], "methodName": ["sourceSets"], "fileName": "org.gradle.api.plugins.JavaPluginConvention"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( JavaPlugin . class )  ;", "final   WarPluginConvention   pluginConvention    =    new   WarPluginConvention ( project )  ;", "project . getConvention (  )  . getPlugins (  )  . put (  \" war \"  ,    pluginConvention )  ;", "project . getTasks (  )  . withType ( War . class ,    new   Action < War >  (  )     {", "public   void   execute ( War   task )     {", "task . from ( new   Callable (  )     {", "public   Object   call (  )    throws   Exception    {", "return   pluginConvention . getWebAppDir (  )  ;", "}", "}  )  ;", "task . dependsOn ( new   Callable (  )     {", "public   Object   call (  )    throws   Exception    {", "return   project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  . getRuntimeClasspath (  )  ;", "}", "}  )  ;", "task . classpath ( new   Object [  ]  {    new   Callable (  )     {", "public   Object   call (  )    throws   Exception    {", "FileCollection   runtimeClasspath    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . getByName ( SourceSet . MAIN _ SOURCE _ SET _ NAME )  . getRuntimeClasspath (  )  ;", "Configuration   providedRuntime    =    project . getConfigurations (  )  . getByName ( WarPlugin . PROVIDED _ RUNTIME _ CONFIGURATION _ NAME )  ;", "return   runtimeClasspath . minus ( providedRuntime )  ;", "}", "}     }  )  ;", "}", "}  )  ;", "War   war    =    project . getTasks (  )  . create ( WarPlugin . WAR _ TASK _ NAME ,    War . class )  ;", "war . setDescription (  \" Generates   a   war   archive   with   all   the   compiled   classes ,    the   web - app   content   and   the   libraries .  \"  )  ;", "war . setGroup ( BasePlugin . BUILD _ GROUP )  ;", "ArchivePublishArtifact   warArtifact    =    new   ArchivePublishArtifact ( war )  ;", "project . getExtensions (  )  . getByType ( DefaultArtifactPublicationSet . class )  . addCandidate ( warArtifact )  ;", "configureConfigurations ( project . getConfigurations (  )  )  ;", "configureComponent ( project ,    warArtifact )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.WarPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getComponents (  )  . add ( objectFactory . newInstance ( WebApplication . class ,    warArtifact ,    objectFactory . named ( Usage . class ,     \" master \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["configureComponent"], "fileName": "org.gradle.api.plugins.WarPlugin"}, {"methodBody": ["METHOD_START", "{", "Configuration   provideCompileConfiguration    =    configurationContainer . create ( WarPlugin . PROVIDED _ COMPILE _ CONFIGURATION _ NAME )  . setVisible ( false )  . setDescription (  \" Additional   compile   classpath   for   libraries   that   should   not   be   part   of   the   WAR   archive .  \"  )  ;", "Configuration   provideRuntimeConfiguration    =    configurationContainer . create ( WarPlugin . PROVIDED _ RUNTIME _ CONFIGURATION _ NAME )  . setVisible ( false )  . extendsFrom ( provideCompileConfiguration )  . setDescription (  \" Additional   runtime   classpath   for   libraries   that   should   not   be   part   of   the   WAR   archive .  \"  )  ;", "configurationContainer . getByName ( JavaPlugin . COMPILE _ CONFIGURATION _ NAME )  . extendsFrom ( provideCompileConfiguration )  ;", "configurationContainer . getByName ( JavaPlugin . RUNTIME _ CONFIGURATION _ NAME )  . extendsFrom ( provideRuntimeConfiguration )  ;", "}", "METHOD_END"], "methodName": ["configureConfigurations"], "fileName": "org.gradle.api.plugins.WarPlugin"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.plugins.WarPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   project . file ( webAppDirName )  ;", "}", "METHOD_END"], "methodName": ["getWebAppDir"], "fileName": "org.gradle.api.plugins.WarPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   webAppDirName ;", "}", "METHOD_END"], "methodName": ["getWebAppDirName"], "fileName": "org.gradle.api.plugins.WarPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . webAppDirName    =    webAppDirName ;", "}", "METHOD_END"], "methodName": ["setWebAppDirName"], "fileName": "org.gradle.api.plugins.WarPluginConvention"}, {"methodBody": ["METHOD_START", "{", "new   DslObject ( options )  . getConventionMapping (  )  . map (  \" annotationProcessorPath \"  ,    new   Callable < Object >  (  )     {", "@ Override", "public   Object   call (  )    throws   Exception    {", "FileCollection   processorPath    =    sourceSet . getAnnotationProcessorPath (  )  ;", "if    ( processorPath    =  =     ( target . getConfigurations (  )  . getByName ( sourceSet . getAnnotationProcessorConfigurationName (  )  )  )  )     {", "return   new   DefaultProcessorPath (  (  ( Configuration )     ( processorPath )  )  )  ;", "} else    {", "return   processorPath ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureAnnotationProcessorPath"], "fileName": "org.gradle.api.plugins.internal.SourceSetUtil"}, {"methodBody": ["METHOD_START", "{", "compile . setDescription (  (  (  \" Compiles   the    \"     +     ( sourceDirectorySet . getDisplayName (  )  )  )     +     \"  .  \"  )  )  ;", "compile . setSource ( sourceSet . getJava (  )  )  ;", "compile . getConventionMapping (  )  . map (  \" classpath \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   sourceSet . getCompileClasspath (  )  . plus ( target . files ( sourceSet . getJava (  )  . getOutputDir (  )  )  )  ;", "}", "}  )  ;", "compile . setDestinationDir ( target . provider ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "return   sourceDirectorySet . getOutputDir (  )  ;", "}", "}  )  )  ;", ". configureOutputDirectoryForSourceSet ( sourceSet ,    sourceDirectorySet ,    target )  ;", "}", "METHOD_END"], "methodName": ["configureForSourceSet"], "fileName": "org.gradle.api.plugins.internal.SourceSetUtil"}, {"methodBody": ["METHOD_START", "{", "SourceSetUtil . configureForSourceSet ( sourceSet ,    sourceDirectorySet ,    compile ,    target )  ;", "SourceSetUtil . configureAnnotationProcessorPath ( sourceSet ,    options ,    target )  ;", "}", "METHOD_END"], "methodName": ["configureForSourceSet"], "fileName": "org.gradle.api.plugins.internal.SourceSetUtil"}, {"methodBody": ["METHOD_START", "{", "final   String   sourceSetChildPath    =     (  (  \" classes /  \"     +     ( sourceDirectorySet . getName (  )  )  )     +     \"  /  \"  )     +     ( sourceSet . getName (  )  )  ;", "sourceDirectorySet . setOutputDir ( target . provider ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "if    ( sourceSet . getOutput (  )  . isLegacyLayout (  )  )     {", "return   sourceSet . getOutput (  )  . getClassesDir (  )  ;", "}", "return   new   File ( target . getBuildDir (  )  ,    sourceSetChildPath )  ;", "}", "}  )  )  ;", "DefaultOutput   sourceSetOutput    =    Cast . cast ( DefaultOutput . class ,    sourceSet . getOutput (  )  )  ;", "sourceSetOutput . addClassesDir ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "return   sourceDirectorySet . getOutputDir (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureOutputDirectoryForSourceSet"], "fileName": "org.gradle.api.plugins.internal.SourceSetUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( classpath    =  =    null )     {", "return   null ;", "}", "for    ( File   file    :    classpath )     {", "JarFile   groovyJar    =    JarFile . parse ( file )  ;", "if    ( groovyJar    !  =    null )     {", "return   groovyJar ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findGroovyJarFile"], "fileName": "org.gradle.api.tasks.GroovyRuntime"}, {"methodBody": ["METHOD_START", "{", "return   new   LazilyInitializedFileCollection (  )     {", "@ Override", "public   String   getDisplayName (  )     {", "return    \"    runtime   classpath \"  ;", "}", "@ Override", "public   FileCollection   createDelegate (  )     {", "JarFile   groovyJar    =    findJarFile ( classpath )  ;", "if    ( groovyJar    =  =    null )     {", "throw   new   GradleException ( String . format (  \" Cannot   infer      class   path   because   no      Jar   was   found   on   class   path :     % s \"  ,    Iterables . toString ( classpath )  )  )  ;", "}", "if    ( groovyJar . isAll (  )  )     {", "return   Cast . cast ( FileCollectionInternal . class ,    project . files ( groovyJar . getFile (  )  )  )  ;", "}", "if    ( project . getRepositories (  )  . isEmpty (  )  )     {", "throw   new   GradleException (  \" Cannot   infer      class   path   because   no   repository   is   declared   for   the   project .  \"  )  ;", "}", "String   notation    =    groovyJar . getDependencyNotation (  )  ;", "List < Dependency >    dependencies    =    Lists . newArrayList (  )  ;", "dependencies . add ( project . getDependencies (  )  . create ( notation )  )  ;", "if    (  ( groovyJar . getVersion (  )  . getMajor (  )  )     >  =     2  )     {", "dependencies . add ( project . getDependencies (  )  . create ( notation . replace (  \"  : groovy :  \"  ,     \"  : groovy - ant :  \"  )  )  )  ;", "}", "return   project . getConfigurations (  )  . detachedConfiguration ( dependencies . toArray ( new   Dependency [  0  ]  )  )  ;", "}", "@ Override", "public   void   visitDependencies ( TaskDependencyResolveContext   context )     {", "if    ( classpath   instanceof   Buildable )     {", "context . add ( classpath )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["inferGroovyClasspath"], "fileName": "org.gradle.api.tasks.GroovyRuntime"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    getConfiguration (  )  ;", "return   configuration    =  =    null    ?    null    :    configuration . getAllArtifacts (  )  . getFiles (  )  ;", "}", "METHOD_END"], "methodName": ["getArtifacts"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "return   configuration ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "return   descriptorDestination ;", "}", "METHOD_END"], "methodName": ["getDescriptorDestination"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getPublicationServices"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "if    (  ( repositories )     =  =    null )     {", "repositories    =    getPublicationServices (  )  . createRepositoryHanr (  )  ;", "}", "return   repositories ;", "}", "METHOD_END"], "methodName": ["getRepositories"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "return   uploadDescriptor ;", "}", "METHOD_END"], "methodName": ["isUploadDescriptor"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "return   ConfigureUtil . configure ( configureClosure ,    getRepositories (  )  )  ;", "}", "METHOD_END"], "methodName": ["repositories"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "RepositoryHandler   repositories    =    getRepositories (  )  ;", "configureAction . execute ( repositories )  ;", "return   repositories ;", "}", "METHOD_END"], "methodName": ["repositories"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "this . descriptorDestination    =    descriptorDestination ;", "}", "METHOD_END"], "methodName": ["setDescriptorDestination"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "this . uploadDescriptor    =    uploadDescriptor ;", "}", "METHOD_END"], "methodName": ["setUploadDescriptor"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "getLogger (  )  . info (  (  \" Publishing   configuration :     \"     +     ( configuration )  )  )  ;", "Module   module    =     (  ( ConfigurationInternal )     ( configuration )  )  . getModule (  )  ;", "ArtifactPublisher   artifactPublisher    =    getPublicationServices (  )  . createArtifactPublisher (  )  ;", "File   descriptorDestination    =     ( isUploadDescriptor (  )  )     ?    getDescriptorDestination (  )     :    null ;", "List < PublicationAwareRepository >    publishRepositories    =    collect ( getRepositories (  )  ,    Transformers . cast ( PublicationAwareRepository . class )  )  ;", "try    {", "artifactPublisher . publish ( publishRepositories ,    module ,    configuration ,    descriptorDestination )  ;", "}    catch    ( Exception   e )     {", "throw   new   artifacts . PublishException ( String . format (  \" Could   not   publish   configuration    '  % s '  \"  ,    configuration . getName (  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["upload"], "fileName": "org.gradle.api.tasks.Upload"}, {"methodBody": ["METHOD_START", "{", "FileCollection   oldClasspath    =    getClasspath (  )  ;", "this . classpath    =    getProject (  )  . files (  ( oldClasspath    !  =    null    ?    oldClasspath    :    new   ArrayList (  )  )  ,    classpath )  ;", "}", "METHOD_END"], "methodName": ["classpath"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "return   webInf . addChild (  )  ;", "}", "METHOD_END"], "methodName": ["getWebInf"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "return   webXml ;", "}", "METHOD_END"], "methodName": ["getWebXml"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    getProject (  )  . files ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "setClasspath (  (  ( Object )     ( classpath )  )  )  ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "this . webXml    =    webXml ;", "}", "METHOD_END"], "methodName": ["setWebXml"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "return   ConfigureUtil . configure ( configureClosure ,    getWebInf (  )  )  ;", "}", "METHOD_END"], "methodName": ["webInf"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "CopySpec   webInf    =    getWebInf (  )  ;", "configureAction . execute ( webInf )  ;", "return   webInf ;", "}", "METHOD_END"], "methodName": ["webInf"], "fileName": "org.gradle.api.tasks.bundling.War"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "return   changeBehavior ;", "}", "METHOD_END"], "methodName": ["getChangeBehavior"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getDeploymentRegistry"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getExecActionFactory"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "return   mainClassName ;", "}", "METHOD_END"], "methodName": ["getMainClassName"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "this . arguments    =    arguments ;", "}", "METHOD_END"], "methodName": ["setArguments"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "this . changeBehavior    =    changeBehavior ;", "}", "METHOD_END"], "methodName": ["setChangeBehavior"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "this . mainClassName    =    mainClassName ;", "}", "METHOD_END"], "methodName": ["setMainClassName"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "DeploymentRegistry   registry    =    getDeploymentRegistry (  )  ;", "JavaHandle   handle    =    registry . get ( getPath (  )  ,    JavaHandle . class )  ;", "if    ( handle    =  =    null )     {", "JavaExecHandleBuilder   builder    =    getExecActionFactory (  )  . newJavaExec (  )  ;", "builder . setClasspath ( classpath )  ;", "builder . setMain ( mainClassName )  ;", "builder . setArgs ( arguments )  ;", "registry . start ( getPath (  )  ,    changeBehavior ,    JavaHandle . class ,    builder )  ;", "}", "}", "METHOD_END"], "methodName": ["startApplication"], "fileName": "org.gradle.internal.deployment.RunApplication"}, {"methodBody": ["METHOD_START", "{", "StartScriptGenerator   generator    =    new   StartScriptGenerator ( unixStartScriptGenerator ,    windowsStartScriptGenerator )  ;", "generator . setApplicationName ( getApplicationName (  )  )  ;", "generator . setMainClassName ( getMainClassName (  )  )  ;", "generator . setDefaultJvmOpts ( getDefaultJvmOpts (  )  )  ;", "generator . setOptsEnvironmentVar ( getOptsEnvironmentVar (  )  )  ;", "generator . setExitEnvironmentVar ( getExitEnvironmentVar (  )  )  ;", "generator . setClasspath ( getRelativeClasspath (  )  )  ;", "generator . setScriptRelPath (  (  (  ( getExecutableDir (  )  )     +     \"  /  \"  )     +     ( getUnixScript (  )  . getName (  )  )  )  )  ;", "generator . generateUnixScript ( getUnixScript (  )  )  ;", "generator . generateWindowsScript ( getWindowsScript (  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   applicationName ;", "}", "METHOD_END"], "methodName": ["getApplicationName"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   defaultJvmOpts ;", "}", "METHOD_END"], "methodName": ["getDefaultJvmOpts"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   executableDir ;", "}", "METHOD_END"], "methodName": ["getExecutableDir"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "if    ( GUtil . isTrue ( exitEnvironmentVar )  )     {", "return   exitEnvironmentVar ;", "}", "if    (  !  ( GUtil . isTrue ( getAName (  )  )  )  )     {", "return   null ;", "}", "return    ( GUtil . toConstant ( getAName (  )  )  )     +     \"  _ EXIT _ CONSOLE \"  ;", "}", "METHOD_END"], "methodName": ["getExitEnvironmentVar"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   mainClassName ;", "}", "METHOD_END"], "methodName": ["getMainClassName"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "if    ( GUtil . isTrue ( optsEnvironmentVar )  )     {", "return   optsEnvironmentVar ;", "}", "if    (  !  ( GUtil . isTrue ( getAName (  )  )  )  )     {", "return   null ;", "}", "return    ( GUtil . toConstant ( getAName (  )  )  )     +     \"  _ OPTS \"  ;", "}", "METHOD_END"], "methodName": ["getOptsEnvironmentVar"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   outputDir ;", "}", "METHOD_END"], "methodName": ["getOutputDir"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   Lists . newArrayList ( Iterables . transform ( getClasspath (  )  . getFiles (  )  ,    new   com . google . common . base . Function < File ,    String >  (  )     {", "@ Override", "public   String   apply ( File   input )     {", "return    \" lib /  \"     +     ( input . getName (  )  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeClasspath"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( getOutputDir (  )  ,    getApplicationName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUnixScript"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   unixStartScriptGenerator ;", "}", "METHOD_END"], "methodName": ["getUnixStartScriptGenerator"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( getOutputDir (  )  ,     (  ( getApplicationName (  )  )     +     \"  . bat \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getWindowsScript"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "return   windowsStartScriptGenerator ;", "}", "METHOD_END"], "methodName": ["getWindowsStartScriptGenerator"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . applicationName    =    applicationName ;", "}", "METHOD_END"], "methodName": ["setApplicationName"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . defaultJvmOpts    =    defaultJvmOpts ;", "}", "METHOD_END"], "methodName": ["setDefaultJvmOpts"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . executableDir    =    executableDir ;", "}", "METHOD_END"], "methodName": ["setExecutableDir"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . exitEnvironmentVar    =    exitEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["setExitEnvironmentVar"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . mainClassName    =    mainClassName ;", "}", "METHOD_END"], "methodName": ["setMainClassName"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . optsEnvironmentVar    =    optsEnvironmentVar ;", "}", "METHOD_END"], "methodName": ["setOptsEnvironmentVar"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . outputDir    =    outputDir ;", "}", "METHOD_END"], "methodName": ["setOutputDir"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . unixStartScriptGenerator    =    unixStartScriptGenerator ;", "}", "METHOD_END"], "methodName": ["setUnixStartScriptGenerator"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}, {"methodBody": ["METHOD_START", "{", "this . windowsStartScriptGenerator    =    windowsStartScriptGenerator ;", "}", "METHOD_END"], "methodName": ["setWindowsStartScriptGenerator"], "fileName": "org.gradle.jvm.application.tasks.CreateStartScripts"}]