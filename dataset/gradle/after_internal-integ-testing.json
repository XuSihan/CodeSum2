[{"methodBody": ["METHOD_START", "{", "if    (  !  ( previousVersion . worksWith ( Jvm . current (  )  )  )  )     {", "add ( new    . IgnoredVersion ( previousVersion ,     \" does   not   work   with   current   JVM \"  )  )  ;", "} else", "if    (  !  ( previousVersion . worksWith ( current (  )  )  )  )     {", "add ( new    . IgnoredVersion ( previousVersion ,     \" does   not   work   with   current   OS \"  )  )  ;", "} else    {", "this . previous . add ( previousVersion )  ;", "}", "}", "METHOD_END"], "methodName": ["addVersionIfCompatibleWithJvmAndOs"], "fileName": "org.gradle.integtests.fixtures.AbstractCompatibilityTestRunner"}, {"methodBody": ["METHOD_START", "{", "return   previous ;", "}", "METHOD_END"], "methodName": ["getPrevious"], "fileName": "org.gradle.integtests.fixtures.AbstractCompatibilityTestRunner"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( target . getSimpleName (  )  . contains (  \" CrossVersion \"  )  )  )     {", "throw   new   RuntimeException (  (  (  (  (  (  (  \" The      that   use    \"     +     ( this . getClass (  )  . getSimpleName (  )  )  )     +     \"    must   follow   a   certain   naming   convention ,    e . g .    name   must   contain    \\  ' CrossVersion \\  '    substring .  \\ n \"  )     +     \" This   way   we   can   include / exclude   those   test   nicely   and   it   is   easier   to   configure   the   CI .  \\ n \"  )     +     \" Please   include    ' CrossVersion '    in   the   name   of   the   test :     '  \"  )     +     ( target . getSimpleName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateTestName"], "fileName": "org.gradle.integtests.fixtures.AbstractCompatibilityTestRunner"}, {"methodBody": ["METHOD_START", "{", "GradleExecuter   gradleExecuter    =    getDistribution (  )  . executer ( testDirectoryProvider ,    getBuildContext (  )  )  ;", "gradleExecuter . withGradleUserHomeDir ( getExecuter (  )  . getGradleUserHomeDir (  )  )  ;", "return   new   GradleBackedArtifactBuilder ( gradleExecuter ,    getTestDirectory (  )  . file (  \" artifacts \"  )  )  ;", "}", "METHOD_END"], "methodName": ["artifactBuilder"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "executer . cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   getTestDirectory (  )  . file ( path )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getBuildContext"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   distribution ;", "}", "METHOD_END"], "methodName": ["getDistribution"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   executer ;", "}", "METHOD_END"], "methodName": ["getExecuter"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ivyRepo )     =  =    null )     {", "ivyRepo    =    new   test . fixtures . ivy . IvyFileRepository ( file (  \" ivy - repo \"  )  )  ;", "}", "return   ivyRepo ;", "}", "METHOD_END"], "methodName": ["getIvyRepo"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mavenRepo )     =  =    null )     {", "mavenRepo    =    new   test . fixtures . maven . MavenFileRepository ( file (  \" maven - repo \"  )  )  ;", "}", "return   mavenRepo ;", "}", "METHOD_END"], "methodName": ["getMavenRepo"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   getTestDirectoryProvider (  )  . getTestDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["getTestDirectory"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   testDirectoryProvider ;", "}", "METHOD_END"], "methodName": ["getTestDirectoryProvider"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   getExecuter (  )  . inDirectory ( directory )  ;", "}", "METHOD_END"], "methodName": ["inDirectory"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   inDirectory ( getTestDirectory (  )  )  ;", "}", "METHOD_END"], "methodName": ["inTestDirectory"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   new   IvyFileRepository ( file ( repo )  )  ;", "}", "METHOD_END"], "methodName": ["ivy"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   new   IvyFileRepository ( repo )  ;", "}", "METHOD_END"], "methodName": ["ivy"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   new   MavenFileRepository ( file ( repo )  )  ;", "}", "METHOD_END"], "methodName": ["maven"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   new   MavenFileRepository ( repo )  ;", "}", "METHOD_END"], "methodName": ["maven"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   RepoScriptBlockUtil . mavenCentralRepository (  )  ;", "}", "METHOD_END"], "methodName": ["mavenCentralRepository"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   file ( name )  ;", "}", "METHOD_END"], "methodName": ["testFile"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "action . execute ( executer )  ;", "return   executer ;", "}", "METHOD_END"], "methodName": ["using"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   getExecuter (  )  . usingBuildScript ( file )  ;", "}", "METHOD_END"], "methodName": ["usingBuildFile"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "return   getExecuter (  )  . usingProjectDirectory ( projectDir )  ;", "}", "METHOD_END"], "methodName": ["usingProjectDir"], "fileName": "org.gradle.integtests.fixtures.AbstractIntegrationTest"}, {"methodBody": ["METHOD_START", "{", "executions . add ( execution )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "RunnerBuilder   runnerBuilder    =    new   RunnerBuilder (  )     {", "@ Override", "public   Runner   runnerForClass ( Class <  ?  >    testClass )    throws   Throwable    {", "for    ( Class <  ?  >    candidate    =    testClass ;    candidate    !  =    null ;    candidate    =    candidate . getSuperclass (  )  )     {", "RunWith   runWith    =    candidate . getAnnotation ( RunWith . class )  ;", "if    (  ( runWith    !  =    null )     &  &     (  !  (  . class . isAssignableFrom ( runWith . value (  )  )  )  )  )     {", "try    {", "Runner   r    =     (  ( Runner )     ( runWith . value (  )  . getConstructors (  )  [  0  ]  . newInstance ( testClass )  )  )  ;", "return   filter ( r )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   e . getTargetException (  )  ;", "}", "}", "}", "return   filter ( new   BlockJUnit 4 ClassRunner ( testClass )  )  ;", "}", "private   Runner   filter ( Runner   r )     {", "for    ( Filter   filter    :    filters )     {", "try    {", "(  ( Filterable )     ( r )  )  . filter ( filter )  ;", "}    catch    ( NoTestsRemainException   e )     {", "}", "}", "return   r ;", "}", "}  ;", "return   new    . UnrollAwareSuite ( runnerBuilder ,    targetClasses . toArray ( new   Class <  ?  >  [  0  ]  )  ,    execution )  ;", "}", "METHOD_END"], "methodName": ["createRunnerFor"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "initExecutions (  )  ;", "for    (  . Execution   execution    :    executions )     {", "execution . filter ( filter )  ;", "}", "invalidateDescription (  )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "initExecutions (  )  ;", "if    (  ( description )     =  =    null )     {", "description    =    Description . createSuiteDescription ( target )  ;", "for    (  . Execution   execution    :    executions )     {", "execution . addDescriptions ( description )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["initDescription"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( executionsInitialized )  )     {", "try    {", ". UnrollAwareSuite   descriptionProvider    =     . createRunnerFor ( Collections . singletonList ( target )  ,    Collections .  < Filter > emptyList (  )  ,    null )  ;", "templateDescription    =    descriptionProvider . getDescription (  )  ;", "}    catch    ( InitializationError   initializationError )     {", "throw   UncheckedException . throwAsUncheckedException ( initializationError )  ;", "}", "createExecutions (  )  ;", "for    (  . Execution   execution    :    executions )     {", "execution . init ( target ,    templateDescription )  ;", "}", "executionsInitialized    =    true ;", "}", "}", "METHOD_END"], "methodName": ["initExecutions"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "description    =    null ;", "templateDescription    =    null ;", "}", "METHOD_END"], "methodName": ["invalidateDescription"], "fileName": "org.gradle.integtests.fixtures.AbstractMultiTestRunner"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . getFirst ( AvailableJavaHomes . getAvailableJdks ( filter )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["getAvailableJdk"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getAvailableJdks ( new   Spec < JvmInstallation >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( JvmInstallation   element )     {", "return   version . equals ( element . getJavaVersion (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableJdks"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   com . google . common . collect . FluentIterable . from ( AvailableJavaHomes . getJvms (  )  )  . filter ( new   Predicate < JvmInstallation >  (  )     {", "@ Override", "public   boolean   apply ( JvmInstallation   input )     {", "return    ( input . isJdk (  )  )     &  &     ( filter . isSatisfiedBy ( input )  )  ;", "}", "}  )  . transform ( new   com . google . common . base . Function < JvmInstallation ,    Jvm >  (  )     {", "@ Override", "public   Jvm   apply ( JvmInstallation   input )     {", "return   Jvm . discovered ( input . getJavaHome (  )  ,    input . getJavaVersion (  )  )  ;", "}", "}  )  . toList (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableJdks"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "Map < Jvm ,    JavaVersion >    result    =    new   HashMap < Jvm ,    JavaVersion >  (  )  ;", "for    ( JavaVersion   javaVersion    :    JavaVersion . values (  )  )     {", "for    ( Jvm   javaInfo    :     . getAvailableJdks ( javaVersion )  )     {", "result . put ( javaInfo ,    javaVersion )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAvailableJdksWithVersion"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   FluentIterable . from ( AvailableJavaHomes . getJvms (  )  )  . transform ( new   com . google . common . base . Function < JvmInstallation ,    Jvm >  (  )     {", "@ Override", "public   Jvm   apply ( JvmInstallation   input )     {", "return   Jvm . discovered ( input . getJavaHome (  )  ,    input . getJavaVersion (  )  )  ;", "}", "}  )  . toList (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableJvms"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "Jvm   jvm    =    Jvm . current (  )  ;", "Jre   jre    =    jvm . getStandaloneJre (  )  ;", "if    ( jre    !  =    null )     {", "return   jre . getDir (  )  ;", "}", "jre    =    jvm . getJre (  )  ;", "if    ( jre    !  =    null )     {", "return   jre . getDir (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getBestJre"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getAvailableJdk ( new   Spec < JvmInstallation >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( JvmInstallation   element )     {", "return    (  !  ( element . getJavaHome (  )  . equals ( Jvm . current (  )  . getJavaHome (  )  )  )  )     &  &     ( AvailableJavaHomes . isSupportedVersion ( element )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDifferentJdk"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getAvailableJdk ( new   Spec < JvmInstallation >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( JvmInstallation   jvm )     {", "return    (  (  !  ( jvm . getJavaHome (  )  . equals ( Jvm . current (  )  . getJavaHome (  )  )  )  )     &  &     ( AvailableJavaHomes . isSupportedVersion ( jvm )  )  )     &  &     (  ( Jvm . discovered ( jvm . getJavaHome (  )  ,    jvm . getJavaVersion (  )  )  . getJre (  )  )     !  =    null )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDifferentJdkWithValidJre"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getAvailableJdk ( new   Spec < JvmInstallation >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( JvmInstallation   element )     {", "return    (  !  ( element . getJavaVersion (  )  . equals ( Jvm . current (  )  . getJavaVersion (  )  )  )  )     &  &     ( AvailableJavaHomes . isSupportedVersion ( element )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDifferentVersion"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getJdk ( VERSION _  1  _  5  )  ;", "}", "METHOD_END"], "methodName": ["getJava5"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . getFirst ( AvailableJavaHomes . getAvailableJdks ( version )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["getJdk"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getJdk ( VERSION _  1  _  6  )  ;", "}", "METHOD_END"], "methodName": ["getJdk6"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getJdk ( VERSION _  1  _  7  )  ;", "}", "METHOD_END"], "methodName": ["getJdk7"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . getJdk ( VERSION _  1  _  8  )  ;", "}", "METHOD_END"], "methodName": ["getJdk8"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "List < JavaVersion >    javaVersions    =    Lists . transform ( Arrays . asList ( versions )  ,    new   com . google . common . base . Function < String ,    JavaVersion >  (  )     {", "@ Override", "public   JavaVersion   apply (  @ Nullable", "String   version )     {", "return   JavaVersion . toVersion ( version )  ;", "}", "}  )  ;", "return    . getJdks ( Iterables . toArray ( javaVersions ,    JavaVersion . class )  )  ;", "}", "METHOD_END"], "methodName": ["getJdks"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "final   Set < JavaVersion >    remaining    =    Sets . newHashSet ( versions )  ;", "return    . getAvailableJdks ( new   Spec < JvmInstallation >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( JvmInstallation   element )     {", "return   remaining . remove ( element . getJavaVersion (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getJdks"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "if    (  ( AvailableJavaHomes . jvms )     =  =    null )     {", "NativeServices   nativeServices    =    NativeServicesTestFixture . getInstance (  )  ;", "FileCanonicalizer   fileCanonicalizer    =    nativeServices . get ( FileCanonicalizer . class )  ;", "AvailableJavaHomes . jvms    =    new   ArrayList < JvmInstallation >  (  )  ;", "AvailableJavaHomes . jvms . addAll ( new   AvailableJavaHomes . DevInfrastructureJvmLocator ( fileCanonicalizer )  . findJvms (  )  )  ;", "InstalledJvmLocator   installedJvmLocator    =    new   InstalledJvmLocator ( OperatingSystem . current (  )  ,    Jvm . current (  )  ,    nativeServices . get ( WindowsRegistry . class )  ,    nativeServices . get ( SystemInfo . class )  ,    fileCanonicalizer )  ;", "AvailableJavaHomes . jvms . addAll ( installedJvmLocator . findJvms (  )  )  ;", "if    ( OperatingSystem . current (  )  . isLinux (  )  )     {", "AvailableJavaHomes . jvms . addAll ( new   AvailableJavaHomes . BaseDirJvmLocator ( fileCanonicalizer ,    new   File (  \"  / opt \"  )  )  . findJvms (  )  )  ;", "}", "AvailableJavaHomes . jvms . addAll ( new   AvailableJavaHomes . HomeDirJvmLocator ( fileCanonicalizer )  . findJvms (  )  )  ;", "Collections . sort ( AvailableJavaHomes . jvms ,    new   Comparator < JvmInstallation >  (  )     {", "public   int   compare ( JvmInstallation   o 1  ,    JvmInstallation   o 2  )     {", "return   o 2  . getVersion (  )  . compareTo ( o 1  . getVersion (  )  )  ;", "}", "}  )  ;", "}", "System . out . println (  \" Found   the   following   JVMs :  \"  )  ;", "for    ( JvmInstallation   jvm    :    AvailableJavaHomes . jvms )     {", "System . out . println (  (  \"              \"     +    jvm )  )  ;", "}", "return   AvailableJavaHomes . jvms ;", "}", "METHOD_END"], "methodName": ["getJvms"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "return   AvailableJavaHomes . underTest . worksWith ( Jvm . discovered ( jvmInstallation . getJavaHome (  )  ,    jvmInstallation . getJavaVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSupportedVersion"], "fileName": "org.gradle.integtests.fixtures.AvailableJavaHomes"}, {"methodBody": ["METHOD_START", "{", "sampleName    =    getSampleName ( method )  ;", "return   new   Statement (  )     {", "@ Override", "public   void   evaluate (  )    throws   Throwable    {", "if    (  ( sampleName )     !  =    null )     {", "String   hintForMissingSample    =    String . format (  \" If    '  % s '    is   a   new   sample ,    try   running    ' gradle   intTestImage '  .  \"  ,    sampleName )  ;", "TestFile   srcDir    =    new   IntegrationTestBuildContext (  )  . getSamplesDir (  )  . file ( sampleName )  . assertIsDir ( hintForMissingSample )  ;", "logger . debug (  \" Copying   sample    '  {  }  '    to   test   directory .  \"  ,    sampleName )  ;", "srcDir . copyTo ( getDir (  )  )  ;", "} else    {", "logger . debug (  \" No   sample   specified   for   this   test ,    skipping .  \"  )  ;", "}", "base . evaluate (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.integtests.fixtures.Sample"}, {"methodBody": ["METHOD_START", "{", "if    (  ( testSampleDirName )     !  =    null )     {", "return   testFile ( testSampleDirName )  ;", "}", "if    (  ( sampleName )     !  =    null )     {", "return   testFile ( sampleName )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["computeSampleDir"], "fileName": "org.gradle.integtests.fixtures.Sample"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sampleDir )     =  =    null )     {", "sampleDir    =    computeDir (  )  ;", "}", "return   sampleDir ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.integtests.fixtures.Sample"}, {"methodBody": ["METHOD_START", "{", "UsesSample   annotation    =    method . getAnnotation ( UsesSample . class )  ;", "return   annotation    !  =    null    ?    annotation . value (  )     :    defaultSampleName ;", "}", "METHOD_END"], "methodName": ["getSampleName"], "fileName": "org.gradle.integtests.fixtures.Sample"}, {"methodBody": ["METHOD_START", "{", "return   testDirectoryProvider . getTestDirectory (  )  . file ( testSampleDirName )  ;", "}", "METHOD_END"], "methodName": ["testFile"], "fileName": "org.gradle.integtests.fixtures.Sample"}, {"methodBody": ["METHOD_START", "{", "return   content ;", "}", "METHOD_END"], "methodName": ["getContent"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "return   Joiner . on (  '  /  '  )  . join ( basePath ,    path ,    name )  ;", "}", "METHOD_END"], "methodName": ["withPath"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "TestFile   file    =    base . file ( path ,    name )  ;", "writeToFile ( file )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["writeToDir"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "if    ( file . exists (  )  )     {", "file . write (  \"  \"  )  ;", "}", "file . write ( content )  ;", "}", "METHOD_END"], "methodName": ["writeToFile"], "fileName": "org.gradle.integtests.fixtures.SourceFile"}, {"methodBody": ["METHOD_START", "{", "final   Statement   statement    =    resources . apply ( base ,    method ,    target )  ;", "return   new   Statement (  )     {", "@ Override", "public   void   evaluate (  )    throws   Throwable    {", "String   className    =    method . getMethod (  )  . getDeclaringClass (  )  . getSimpleName (  )  ;", "maybeCopy ( String . format (  \"  % s / shared \"  ,    className )  )  ;", "maybeCopy ( String . format (  \"  % s /  % s \"  ,    className ,    method . getName (  )  )  )  ;", "for    ( String   extraResource    :    extra )     {", "maybeCopy ( extraResource )  ;", "}", "statement . evaluate (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.integtests.fixtures.TestResources"}, {"methodBody": ["METHOD_START", "{", "return   testWorkDirProvider . getTestDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.integtests.fixtures.TestResources"}, {"methodBody": ["METHOD_START", "{", "TestFile   dir    =    resources . findResource ( resource )  ;", "if    ( dir    !  =    null )     {", "logger . debug (  \" Copying   test   resource    '  {  }  '    from    {  }    to   test   directory .  \"  ,    resource ,    dir )  ;", "dir . copyTo ( getDir (  )  )  ;", "} else    {", "logger . debug (  \" Test   resource    '  {  }  '    not   found ,    skipping .  \"  ,    resource )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeCopy"], "fileName": "org.gradle.integtests.fixtures.TestResources"}, {"methodBody": ["METHOD_START", "{", "Pattern   pattern    =    Pattern . compile (  \"  ^  .  * DefaultDaemonContext \\  \\  [  ( uid =  [  ^  \\  \\ n ,  ]  +  )  ?  ,  ? javaHome =  (  [  ^  \\  \\ n ]  +  )  , daemonRegistryDir =  (  [  ^  \\  \\ n ]  +  )  , pid =  (  [  ^  \\  \\ n ]  +  )  , idleTimeout =  (  .  +  ?  )  , daemonOpts =  (  [  ^  \\  \\ n ]  +  )  ]  .  *  \"  ,     (  ( Pattern . MULTILINE )     +     ( Pattern . DOTALL )  )  )  ;", "Matcher   matcher    =    pattern . matcher ( source )  ;", "if    ( matcher . matches (  )  )     {", "String   uid    =     (  ( matcher . group (  1  )  )     =  =    null )     ?    null    :    matcher . group (  1  )  . substring (  \" uid =  \"  . length (  )  )  ;", "String   javaHome    =    matcher . group (  2  )  ;", "String   daemonRegistryDir    =    matcher . group (  3  )  ;", "String   pidStr    =    matcher . group (  4  )  ;", "Long   pid    =     ( pidStr . equals (  \" null \"  )  )     ?    null    :    Long . parseLong ( pidStr )  ;", "Integer   idleTimeout    =    Integer . decode ( matcher . group (  5  )  )  ;", "List < String >    jvmOpts    =    Lists . newArrayList ( Splitter . on (  '  ,  '  )  . split ( matcher . group (  6  )  )  )  ;", "return   new   DefaultDaemonContext ( uid ,    new   File ( javaHome )  ,    new   File ( daemonRegistryDir )  ,    pid ,    idleTimeout ,    jvmOpts )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["parseFrom"], "fileName": "org.gradle.integtests.fixtures.daemon.DaemonContextParser"}, {"methodBody": ["METHOD_START", "{", "try    {", "BufferedReader   reader    =    new   BufferedReader ( new   FileReader ( file )  )  ;", "for    ( String   line    =    reader . readLine (  )  ;    line    !  =    null ;    line    =    reader . readLine (  )  )     {", "DaemonContext   context    =     . parseFrom ( line )  ;", "if    ( context    !  =    null )     {", "return   context ;", "}", "}", "}    catch    ( FileNotFoundException   e )     {", "throw   new   IllegalStateException (  (  (  \" unable   to   parse   DefaultDaemonContext   from   source :     [  \"     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  .  \"  )  ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   new   IllegalStateException (  (  (  \" unable   to   parse   DefaultDaemonContext   from   source :     [  \"     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  .  \"  )  ,    e )  ;", "}", "throw   new   IllegalStateException (  (  (  \" unable   to   parse   DefaultDaemonContext   from   source :     [  \"     +     ( file . getAbsolutePath (  )  )  )     +     \"  ]  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["parseFromFile"], "fileName": "org.gradle.integtests.fixtures.daemon.DaemonContextParser"}, {"methodBody": ["METHOD_START", "{", "DaemonContext   context    =    DaemonContextParser . parseFrom ( source )  ;", "if    ( context    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" unable   to   parse   DefaultDaemonContext   from   source :     [  \"     +    source )     +     \"  ]  .  \"  )  )  ;", "}", "return   context ;", "}", "METHOD_END"], "methodName": ["parseFromString"], "fileName": "org.gradle.integtests.fixtures.daemon.DaemonContextParser"}, {"methodBody": ["METHOD_START", "{", "configureExecuter (  )  . assertCanExecute (  )  ;", "}", "METHOD_END"], "methodName": ["assertCanExecute"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractDelegatingGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "validateDaemonVisibility (  )  ;", ". GradleInvocation   gradleInvocation    =    new    . GradleInvocation (  )  ;", "gradleInvocation . environmentVars . putAll ( environmentVars )  ;", "gradleInvocation . buildJvmArgs . addAll ( buildJvmOpts )  ;", "if    (  !  ( useOnlyRequestedJvmOpts )  )     {", "gradleInvocation . buildJvmArgs . addAll ( getImplicitBuildJvmArgs (  )  )  ;", "}", "calculateLauncherJvmArgs ( gradleInvocation )  ;", "gradleInvocation . args . addAll ( getAllArgs (  )  )  ;", "transformInvocation ( gradleInvocation )  ;", "if    (  !  ( gradleInvocation . implicitLauncherJvmArgs . isEmpty (  )  )  )     {", "throw   new   IllegalStateException (  \" Implicit   JVM   args   have   not   been   handled .  \"  )  ;", "}", "return   gradleInvocation ;", "}", "METHOD_END"], "methodName": ["buildInvocation"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "gradleInvocation . launcherJvmArgs . addAll ( commandLineJvmOpts )  ;", "if    (  ( isUseDaemon (  )  )     &  &     (  !  ( gradleInvocation . buildJvmArgs . isEmpty (  )  )  )  )     {", "String   quotedArgs    =    join (  \"     \"  ,    collect ( gradleInvocation . buildJvmArgs ,    new   Transformer < String ,    String >  (  )     {", "public   String   transform ( String   input )     {", "return   String . format (  \"  '  % s '  \"  ,    input )  ;", "}", "}  )  )  ;", "gradleInvocation . implicitLauncherJvmArgs . add (  (  \"  - Djvmargs =  \"     +    quotedArgs )  )  ;", "} else    {", "gradleInvocation . launcherJvmArgs . addAll ( gradleInvocation . buildJvmArgs )  ;", "}", "for    ( Map . Entry < String ,    String >    entry    :    getImplicitJvmSystemProperties (  )  . entrySet (  )  )     {", "String   key    =    entry . getKey (  )  ;", "String   value    =    entry . getValue (  )  ;", "gradleInvocation . implicitLauncherJvmArgs . add ( String . format (  \"  - D % s =  % s \"  ,    key ,    value )  )  ;", "}", "if    ( isDebugLauncher (  )  )     {", "gradleInvocation . implicitLauncherJvmArgs . addAll (  . DEBUG _ ARGS )  ;", "}", "gradleInvocation . implicitLauncherJvmArgs . add (  \"  - ea \"  )  ;", "}", "METHOD_END"], "methodName": ["calculateLauncherJvmArgs"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "stopRunningBuilds (  )  ;", "cleanupIsolatedDaemons (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "for    ( File   baseDir    :    isolatedDaemonBaseDirs )     {", "try    {", "new   daemon . DaemonLogsAnalyzer ( baseDir ,    gradleVersion . getVersion (  )  )  . killAll (  )  ;", "}    catch    ( Exception   e )     {", "getLogger (  )  . warn (  (  (  (  \" Problem   killing   isolated   daemons   of   Gradle   version    \"     +     ( gradleVersion )  )     +     \"    in    \"  )     +    baseDir )  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupIsolatedDaemons"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isSharedDaemons (  )  )  )     {", "isolatedDaemonBaseDirs . add ( daemonBaseDir )  ;", "}", "}", "METHOD_END"], "methodName": ["collectStateBeforeExecution"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "try    {", "ren    ( stdinPipe )     =  =    null    ?    SafeStreams . emptyInput (  )     :    new   PipedInputStream ( stdinPipe )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["connectStdIn"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException ( String . format (  \"  % s   does   not   support   running   asynchronously .  \"  ,    getClass (  )  . getSimpleName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createGradleHandle"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "String   javaHomeInProperties    =    javaHomeInProperties (  )  ;", "if    ( javaHomeInProperties    !  =    null )     {", "return   isJava 7 Home ( javaHomeInProperties )  ;", "} else", "if    ( getJavaHome (  )  . equals ( rnal . jvm . Jvm . current (  )  . getJavaHome (  )  )  )     {", "return   current (  )  . isJava 7  (  )  ;", "} else    {", "return   isJava 7 Home ( getJavaHome (  )  . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["currentOrTargetIsJava7"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "try    {", "afterExecute ( this )  ;", "}    finally    {", "reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["finished"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "beforeExecute . execute ( this )  ;", "}", "METHOD_END"], "methodName": ["fireBeforeExecute"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "List < String >    allArgs    =    new   ArrayList < String >  (  )  ;", "if    (  ( buildScript )     !  =    null )     {", "allArgs . add (  \"  -  - build - file \"  )  ;", "allArgs . add ( buildScript . getAbsolutePath (  )  )  ;", "}", "if    (  ( projectDir )     !  =    null )     {", "allArgs . add (  \"  -  - project - dir \"  )  ;", "allArgs . add ( projectDir . getAbsolutePath (  )  )  ;", "}", "for    ( File   initScript    :    initScripts )     {", "allArgs . add (  \"  -  - init - script \"  )  ;", "allArgs . add ( initScript . getAbsolutePath (  )  )  ;", "}", "if    (  ( settingsFile )     !  =    null )     {", "allArgs . add (  \"  -  - settings - file \"  )  ;", "allArgs . add ( settingsFile . getAbsolutePath (  )  )  ;", "}", "if    ( quiet )     {", "allArgs . add (  \"  -  - quiet \"  )  ;", "}", "if    ( noDaemonArgumentGiven (  )  )     {", "if    ( isUseDaemon (  )  )     {", "allArgs . add (  \"  -  - daemon \"  )  ;", "} else    {", "allArgs . add (  \"  -  - no - daemon \"  )  ;", "}", "}", "if    ( showStacktrace )     {", "allArgs . add (  \"  -  - stacktrace \"  )  ;", "}", "if    ( taskList )     {", "allArgs . add (  \" tasks \"  )  ;", "}", "if    ( dependencyList )     {", "allArgs . add (  \" dependencies \"  )  ;", "}", "if    (  !  ( searchUpwards )  )     {", "if    (  (  !  ( isSettingsFileAvailable (  )  )  )     &  &     (  ( distribution . getVersion (  )  . getBaseVersion (  )  . compareTo ( GradleVersion . version (  \"  4  .  5  \"  )  )  )     <     0  )  )     {", "allArgs . add (  \"  -  - no - search - upward \"  )  ;", "}", "}", "if    (  ( geUserHomeDir (  )  )     !  =    null )     {", "allArgs . add (  \"  -  - gradle - user - home \"  )  ;", "allArgs . add ( geUserHomeDir (  )  . getAbsolutePath (  )  )  ;", "}", "if    (  ( consoleType )     !  =    null )     {", "allArgs . add (  (  \"  -  - console =  \"     +     ( consoleType . toString (  )  . toLowerCase (  )  )  )  )  ;", "}", "if    (  ( warningMode )     !  =    null )     {", "allArgs . add (  (  \"  -  - warning - mode =  \"     +     ( warningMode . toString (  )  . toLowerCase ( Locale . ENGLISH )  )  )  )  ;", "}", "allArgs . addAll ( args )  ;", "allArgs . addAll ( tasks )  ;", "return   allArgs ;", "}", "METHOD_END"], "methodName": ["getAllArgs"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( defaultCharacterEncoding )     =  =    null    ?    Charset . defaultCharset (  )  . name (  )     :    defaultCharacterEncoding ;", "}", "METHOD_END"], "methodName": ["getDefaultCharacterEncoding"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   defaultLocale ;", "}", "METHOD_END"], "methodName": ["getDefaultLocale"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   buildContext . getTmpDir (  )  . createDir (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultTmpDir"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   durationMeasurement ;", "}", "METHOD_END"], "methodName": ["getDurationMeasurement"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   executable ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "List < String >    buildJvmOpts    =    new   ArrayList < String >  (  )  ;", "buildJvmOpts . add (  \"  - ea \"  )  ;", "if    ( isDebug (  )  )     {", "buildJvmOpts . addAll (  . DEBUG _ ARGS )  ;", "}", "if    ( isProfile (  )  )     {", "buildJvmOpts . add ( profiler )  ;", "}", "return   buildJvmOpts ;", "}", "METHOD_END"], "methodName": ["getImplicitBuildJvmArgs"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    properties    =    new   LinkedHashMap < String ,    String >  (  )  ;", "if    (  ( getUserHomeDir (  )  )     !  =    null )     {", "properties . put (  \" user . home \"  ,    getUserHomeDir (  )  . getAbsolutePath (  )  )  ;", "}", "properties . put ( GRADLE _ PROPERTY ,     (  \"  \"     +     (  ( daemonIdleTimeoutSecs )     *     1  0  0  0  )  )  )  ;", "properties . put ( DaemonBuildOptions . BaseDirOption . GRADLE _ PROPERTY ,    daemonBaseDir . getAbsolutePath (  )  )  ;", "if    (  !  ( noExplicitNativeServicesDir )  )     {", "properties . put ( NATIVE _ DIR _ OVERRIDE ,    buildContext . getNativeServicesDir (  )  . getAbsolutePath (  )  )  ;", "}", "properties . put ( ORG _ GRADLE _ DEPRECATION _ TRACE _ PROPERTY _ NAME ,    Boolean . toString ( fullDeprecationStackTrace )  )  ;", "if    (  ( useOwnUserHomeServices )     |  |     (  (  ( gradleUserHomeDir )     !  =    null )     &  &     (  !  ( gradleUserHomeDir . equals ( buildContext . geUserHomeDir (  )  )  )  )  )  )     {", "properties . put ( DefaulUserHomeScopeServiceRegistry . REUSE _ USER _ HOME _ SERVICES ,     \" false \"  )  ;", "}", "if    (  !  ( noExplicitTmpDir )  )     {", "if    (  ( tmpDir )     =  =    null )     {", "tmpDir    =    getDefaultTmpDir (  )  ;", "}", "String   tmpDirPath    =    tmpDir . createDir (  )  . getAbsolutePath (  )  ;", "if    (  (  !  ( tmpDirPath . contains (  \"     \"  )  )  )     |  |     (  ( getDistribution (  )  . isSupportsSpacesInGradleAndJavaOpts (  )  )     &  &     ( supportsWhiteSpaceInEnvVars (  )  )  )  )     {", "properties . put (  \" tmpdir \"  ,    tmpDirPath )  ;", "}", "}", "properties . put (  \" file . encoding \"  ,    getDefaultCharacterEncoding (  )  )  ;", "Locale   locale    =    getDefaultLocale (  )  ;", "if    ( locale    !  =    null )     {", "properties . put (  \" user . language \"  ,    locale . getLanguage (  )  )  ;", "properties . put (  \" user . country \"  ,    locale . getCountry (  )  )  ;", "properties . put (  \" user . variant \"  ,    locale . getVariant (  )  )  ;", "}", "if    ( eagerClassLoaderCreationChecksOn )     {", "properties . put ( STRICT _ MODE _ PROPERTY ,     \" true \"  )  ;", "}", "if    ( interactive )     {", "properties . put ( INTERACTIVE _ TOGGLE ,     \" true \"  )  ;", "}", "if    (  !  ( searchUpwards )  )     {", "if    (  !  ( isSettingsFileAvailable (  )  )  )     {", "properties . put ( NO _ SEARCH _ UPWARDS _ PROPERTY _ KEY ,     \" true \"  )  ;", "}", "}", "properties . put ( WELCOME _ MESSAGE _ ENABLED _ SYSTEM _ PROPERTY ,    Boolean . toString ( renderWelcomeMessage )  )  ;", "return   properties ;", "}", "METHOD_END"], "methodName": ["getImplicitJvmSystemProperties"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( javaHome )     =  =    null    ?    Jvm . current (  )  . getJavaHome (  )     :    javaHome ;", "}", "METHOD_END"], "methodName": ["getJavaHome"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   logger ;", "}", "METHOD_END"], "methodName": ["getLogger"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   Action < ExecutionResult >  (  )     {", "int   expectedDeprecationWarnings    =     . this . expectedDeprecationWarnings ;", "boolean   expectStackTraces    =     !  (  . this . stackTraceChecksOn )  ;", "boolean   checkDeprecations    =     . this . checkDeprecations ;", "@ Override", "public   void   execute ( ExecutionResult   executionResult )     {", "String   normalizedOutput    =    executionResult . getNormalizedOutput (  )  ;", "String   error    =    executionResult . getError (  )  ;", "boolean   executionFailure    =    isExecutionFailure ( executionResult )  ;", "if    ( executionFailure )     {", "normalizedOutput    =    removeExceptionStackTraceForFailedExecution ( normalizedOutput )  ;", "}", "validate ( normalizedOutput ,     \" Standard   output \"  )  ;", "if    ( executionFailure )     {", "error    =    removeExceptionStackTraceForFailedExecution ( error )  ;", "}", "validate ( error ,     \" Standard   error \"  )  ;", "if    (  ( expectedDeprecationWarnings )     >     0  )     {", "throw   new   AssertionError ( String . format (  \" Expected    % d   more   deprecation   warnings \"  ,    expectedDeprecationWarnings )  )  ;", "}", "}", "private   boolean   isErrorOutEmpty ( String   error )     {", "return   Strings . isNullOrEmpty ( error . replaceAll (  \"  (  ? m )  ^ SLF 4 J :     .  *  \"  ,     \"  \"  )  . trim (  )  )  ;", "}", "private   boolean   isExecutionFailure ( ExecutionResult   executionResult )     {", "return   executionResult   instanceof   ExecutionFailure ;", "}", "private   String   removeExceptionStackTraceForFailedExecution ( String   text )     {", "int   pos    =    text . indexOf (  \"  *    Exception   is :  \"  )  ;", "if    ( pos    >  =     0  )     {", "text    =    text . substring (  0  ,    pos )  ;", "}", "return   text ;", "}", "private   void   validate ( String   output ,    String   displayName )     {", "List < String >    lines ;", "try    {", "lines    =    CharSource . wrap ( output )  . readLines (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "int   i    =     0  ;", "while    ( i    <     ( lines . size (  )  )  )     {", "String   line    =    lines . get ( i )  ;", "if    ( line . matches (  \"  .  * use ( s )  ?    or   override ( s )  ?    a   deprecated   API \\  \\  .  \"  )  )     {", "i +  +  ;", "} else", "if    ( line . contains ( UnsupportedJavaRuntimeException . JAVA 7  _ DEPRECATION _ WARNING )  )     {", "if    (  !  ( java 7 DeprecationWarningShouldExist (  )  )  )     {", "throw   new   AssertionError ( String . format (  \"  % s   line    % d   contains   unexpected   deprecation   warning :     % s % n =  =  =  =  =  % n % s % n =  =  =  =  =  % n \"  ,    displayName ,     ( i    +     1  )  ,    line ,    output )  )  ;", "}", "i +  +  ;", "while    (  ( i    <     ( lines . size (  )  )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( lines . get ( i )  )  . matches (  )  )  )     {", "i +  +  ;", "}", "} else", "if    ( isJava 7 DeprecationTruncatedDaemonLog ( lines ,    i ,    line )  )     {", "i +  +  ;", "while    (  ( i    <     ( lines . size (  )  )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( lines . get ( i )  )  . matches (  )  )  )     {", "i +  +  ;", "}", "} else", "if    ( isDeprecationMessageInHelpDescription ( line )  )     {", "i +  +  ;", "} else", "if    ( line . matches (  \"  .  *  \\  \\ s + deprecated .  *  \"  )  )     {", "if    (  ( checkDeprecations )     &  &     (  ( expectedDeprecationWarnings )     <  =     0  )  )     {", "throw   new   AssertionError ( String . format (  \"  % s   line    % d   contains   a   deprecation   warning :     % s % n =  =  =  =  =  % n % s % n =  =  =  =  =  % n \"  ,    displayName ,     ( i    +     1  )  ,    line ,    output )  )  ;", "}", "( expectedDeprecationWarnings )  -  -  ;", "i +  +  ;", "while    (  ( i    <     ( lines . size (  )  )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( lines . get ( i )  )  . matches (  )  )  )     {", "i +  +  ;", "}", "} else", "if    (  (  (  (  !  ( expectStackTraces )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( line )  . matches (  )  )  )     &  &     ( i    <     (  ( lines . size (  )  )     -     1  )  )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( lines . get (  ( i    +     1  )  )  )  . matches (  )  )  )     {", "throw   new   AssertionError ( String . format (  \"  % s   line    % d   contains   an   unexpected   stack   trace :     % s % n =  =  =  =  =  % n % s % n =  =  =  =  =  % n \"  ,    displayName ,     ( i    +     1  )  ,    line ,    output )  )  ;", "} else    {", "i +  +  ;", "}", "}", "}", "private   boolean   isDeprecationMessageInHelpDescription ( String   s )     {", "return   s . matches (  \"  .  *  \\  \\  [ deprecated .  *  ]  \"  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getResultAssertion"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   stdinPipe ;", "}", "METHOD_END"], "methodName": ["getStdinPipe"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   userHomeDir ;", "}", "METHOD_END"], "methodName": ["getUserHomeDir"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( workingDir )     =  =    null    ?    getTestDirectoryProvider (  )  . getTestDirectory (  )     :    workingDir ;", "}", "METHOD_END"], "methodName": ["getWorkingDir"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   allowExtraLogging ;", "}", "METHOD_END"], "methodName": ["isAllowExtraLogging"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( line . startsWith (  \"  -  -  -  -  -    Last       \"  )  )     &  &     ( i    <     (  ( lines . size (  )  )     -     1  )  )  )     &  &     ( OutputScrapingExecutionResult . STACK _ TRACE _ ELEMENT . matcher ( lines . get (  ( i    +     1  )  )  )  . matches (  )  )  ;", "}", "METHOD_END"], "methodName": ["isJava7DeprecationTruncatedDaemonLog"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "for    ( String   jdk 7 Path    :    AbstractGradleExecuter . JDK 7  _ PATHS )     {", "if    ( path . contains ( jdk 7 Path )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isJava7Home"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   quiet ;", "}", "METHOD_END"], "methodName": ["isQuiet"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   requiresGradleDistribution ;", "}", "METHOD_END"], "methodName": ["isRequiresGradleDistribution"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "boolean   settingsFoundAboveInTestDir    =    false ;", "TestFile   dir    =    new   TestFile ( getWorkingDir (  )  )  ;", "while    (  ( dir    !  =    null )     &  &     ( getTestDirectoryProvider (  )  . getTestDirectory (  )  . isSelfOrDescendent ( dir )  )  )     {", "if    ( dir . file (  \" settings \"  )  . isFile (  )  )     {", "settingsFoundAboveInTestDir    =    true ;", "break ;", "}", "dir    =    dir . getParentFile (  )  ;", "}", "return   settingsFoundAboveInTestDir ;", "}", "METHOD_END"], "methodName": ["isSettingsFileAvailable"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   daemonBaseDir . equals ( buildContext . getDaemonBaseDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSharedDaemons"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( CollectionUtils . containsAny ( args ,    AbstractGradleExecuter . LOW _ LEVELS )  )     {", "return   currentOrTargetIsJava 7  (  )  ;", "}", "if    ( CollectionUtils . containsAny ( args ,    AbstractGradleExecuter . HIGH _ LEVELS )  )     {", "return   false ;", "}", "return   currentOrTargetIsJava 7  (  )  ;", "}", "METHOD_END"], "methodName": ["java7DeprecationWarningShouldExist"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "File   gradleProperties    =    new   File ( getWorkingDir (  )  ,     \" gradle . properties \"  )  ;", "if    ( gradleProperties . isFile (  )  )     {", "Properties   properties    =    GUtil . loadProperties ( gradleProperties )  ;", "if    (  ( properties . getProperty (  \" home \"  )  )     !  =    null )     {", "return   properties . getProperty (  \" home \"  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["javaHomeInProperties"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "LoggingServiceRegistry   loggingServices    =    LoggingServiceRegistry . newEmbeddableLogging (  )  ;", "LoggingManagerInternal   rootLoggingManager    =    loggingServices . get ( DefaultLoggingManagerFactory . class )  . getRoot (  )  ;", "rootLoggingManager . attachSystemOutAndErr (  )  ;", "return   loggingServices ;", "}", "METHOD_END"], "methodName": ["newCommandLineProcessLogging"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( resolveCliDaemonArgument (  )  )     =  =     ( AbstractGradleExecuter . CliDaemonArgument . NOT _ DEFINED )  ;", "}", "METHOD_END"], "methodName": ["noDaemonArgumentGiven"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "AbstractGradleExecuter . PROPAGATED _ SYSTEM _ PROPERTIES . add ( name )  ;", "}", "METHOD_END"], "methodName": ["propagateSystemProperty"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( args . size (  )  )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "final   String   arg    =    args . get ( i )  ;", "if    ( arg . equals (  \"  -  - daemon \"  )  )     {", "return    . CliDaemonArgument . DAEMON ;", "}", "if    ( arg . equals (  \"  -  - no - daemon \"  )  )     {", "return    . CliDaemonArgument . NO _ DAEMON ;", "}", "if    ( arg . equals (  \"  -  - foreground \"  )  )     {", "return    . CliDaemonArgument . FOREGROUND ;", "}", "}", "return    . CliDaemonArgument . NOT _ DEFINED ;", "}", "METHOD_END"], "methodName": ["resolveCliDaemonArgument"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "fireBeforeExecute (  )  ;", "assertCanExecute (  )  ;", "collectStateBeforeExecution (  )  ;", "try    {", "GradleHandle   handle    =    createGradleHandle (  )  ;", "running . add ( handle )  ;", "return   handle ;", "}    finally    {", "reset (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startHandle"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( durationMeasurement )     !  =    null )     {", "durationMeasurement . start (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startMeasurement"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( durationMeasurement )     !  =    null )     {", "durationMeasurement . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopMeasurement"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "for    ( GradleHandle   handle    :    running )     {", "try    {", "handle . abort (  )  . waitForExit (  )  ;", "}    catch    ( Exception   e )     {", "getLogger (  )  . warn (  \" Problem   stopping   running   build \"  ,    e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopRunningBuilds"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsWhiteSpaceInEnvVars"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   result    =    new   StringBuilder (  )  ;", "for    ( String   jvmArg    :    jvmArgs )     {", "if    (  ( result . length (  )  )     >     0  )     {", "result . append (  \"     \"  )  ;", "}", "if    ( jvmArg . contains (  \"     \"  )  )     {", "assert    !  ( jvmArg . contains (  \"  \\  \"  \"  )  )     :     (  \" jvmArg    '  \"     +    jvmArg )     +     \"  \\  '    contains    \\  '  \\  \"  \\  '  \"  ;", "result . append (  '  \"  '  )  ;", "result . append ( jvmArg )  ;", "result . append (  '  \"  '  )  ;", "} else    {", "result . append ( jvmArg )  ;", "}", "}", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toJvmArgsString"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "gradleInvocation . launcherJvmArgs . addAll (  0  ,    gradleInvocation . implicitLauncherJvmArgs )  ;", "gradleInvocation . implicitLauncherJvmArgs . clear (  )  ;", "}", "METHOD_END"], "methodName": ["transformInvocation"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isUseDaemon (  )  )     &  &     ( isSharedDaemons (  )  )  )     {", "throw   new   IllegalStateException (  \" Daemon   that   will   be   visible   to   other      has   been   requested .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateDaemonVisibility"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "showStacktrace    =    false ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withStacktraceDisabled"], "fileName": "org.gradle.integtests.fixtures.executer.AbstractGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   NoDaemonGradleExecuter ( this ,    testDirectoryProvider ,    version ,    buildContext )  . withWarningMode ( null )  ;", "}", "METHOD_END"], "methodName": ["executer"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    ( isSameOrNewer (  \"  4  .  7  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  5  6  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  6  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  5  3  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  5  .  1  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  5  1  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  5  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  4  8  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  4  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  3  6  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  3  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  3  1  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  4  .  2  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  2  4  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  3  .  2  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  2  3  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  3  .  1  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  2  1  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  3  .  0  - milestone -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  7  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  2  .  8  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  6  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  2  .  4  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  5  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  2  .  2  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  4  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  2  .  1  - rc -  3  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  3  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  2  .  0  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  2  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  1  2  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  6  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  1  1  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  2  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  9  - rc -  2  \"  )  )     {", "ren   VersionNumber . parse (  \"  2  .  1  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  9  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  1  .  3  1  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  7  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  0  .  2  6  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  6  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  0  .  2  4  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  4  - rc -  1  \"  )  )     {", "ren   VersionNumber . parse (  \"  0  .  2  3  \"  )  ;", "} else", "if    ( isSameOrNewer (  \"  1  .  3  \"  )  )     {", "ren   VersionNumber . parse (  \"  0  .  1  5  \"  )  ;", "} else    {", "ren   VersionNumber . parse (  \"  0  .  1  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["getArtifactCacheLayoutVersion"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   binDistribution ;", "}", "METHOD_END"], "methodName": ["getBinDistribution"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   gradleHomeDir ;", "}", "METHOD_END"], "methodName": ["getGradleHomeDir"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  1  .  0  - milestone -  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["isDaemonIdleTimeoutConfigurable"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  1  .  0  - milestone -  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["isFullySupportsIvyRepository"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return    ( isSameOrNewer (  \"  0  .  9  - rc -  1  \"  )  )     &  &     (  !  ( isSameOrNewer (  \"  2  .  0  - rc -  1  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isOpenApiSupported"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return    ( isVersion ( otherVersion )  )     |  |     (  ( version . compareTo ( GradleVersion . version ( otherVersion )  )  )     >     0  )  ;", "}", "METHOD_END"], "methodName": ["isSameOrNewer"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return    ( isVersion ( otherVersion )  )     |  |     (  ( version . compareTo ( GradleVersion . version ( otherVersion )  )  )     <  =     0  )  ;", "}", "METHOD_END"], "methodName": ["isSameOrOlder"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  1  .  0  - milestone -  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["isSupportsSpacesInGradleAndJavaOpts"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  2  .  2  - rc -  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["isToolingApiDaemonBaseDirSupported"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    ( OperatingSystem . current (  )  . isWindows (  )  )     {", "return    (  (  !  ( isVersion (  \"  1  .  0  - milone -  7  \"  )  )  )     &  &     (  !  ( isVersion (  \"  1  .  0  - milone -  8  \"  )  )  )  )     &  &     (  !  ( isVersion (  \"  1  .  0  - milone -  8 a \"  )  )  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isToolingApiNonAsciiOutputSupported"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  1  .  0  - milestone -  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["isToolingApiSupported"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "GradleVersion   otherVersion    =    GradleVersion . version ( otherVersionString )  ;", "return    (  ( version . compareTo ( otherVersion )  )     =  =     0  )     |  |     (  ( version . isSnapshot (  )  )     &  &     ( version . getBaseVersion (  )  . equals ( otherVersion . getBaseVersion (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isVersion"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "return   isSameOrNewer (  \"  1  .  7  \"  )  ;", "}", "METHOD_END"], "methodName": ["isWrapperSupportsGradleUserHomeCommandLineOption"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isVersion (  \"  0  .  9  - rc -  1  \"  )  )     &  &     ( javaVersion    =  =     ( JavaVersion . VERSION _  1  _  5  )  )  )     {", "return   false ;", "}", "if    ( isSameOrOlder (  \"  1  .  1  2  \"  )  )     {", "return    (  ( compareTo ( VERSION _  1  _  5  )  )     >  =     0  )     &  &     (  ( compareTo ( VERSION _  1  _  8  )  )     <  =     0  )  ;", "}", "if    ( isSameOrOlder (  \"  3  .  0  - milestone -  1  \"  )  )     {", "return    (  ( compareTo ( VERSION _  1  _  6  )  )     >  =     0  )     &  &     (  ( compareTo ( VERSION _  1  _  8  )  )     <  =     0  )  ;", "}", "return    (  ( compareTo ( VERSION _  1  _  7  )  )     >  =     0  )     &  &     (  ( compareTo ( VERSION _  1  _  8  )  )     <  =     0  )  ;", "}", "METHOD_END"], "methodName": ["worksWith"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    (  ( jvm . isIbmJvm (  )  )     &  &     ( isVersion (  \"  1  .  0  - milestone -  4  \"  )  )  )     {", "return   false ;", "}", "JavaVersion   javaVersion    =    jvm . getJavaVersion (  )  ;", "if    ( javaVersion    =  =    null )     {", "throw   new   IllegalArgumentExcep (  )  ;", "}", "return   worksWith ( javaVersion )  ;", "}", "METHOD_END"], "methodName": ["worksWith"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    ( isVersion (  \"  1  .  0  - milestone -  5  \"  )  )     {", "return    (  ( os . isWindows (  )  )     |  |     ( os . isMacOsX (  )  )  )     |  |     ( os . isLinux (  )  )  ;", "} else    {", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["worksWith"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "if    (  ( version . equals ( GradleVersion . version (  \"  0  .  8  \"  )  )  )     |  |     ( isVersion (  \"  0  .  8  \"  )  )  )     {", "return   false ;", "}", "if    ( isVersion (  \"  0  .  9  .  1  \"  )  )     {", "return   version . getVersion (  )  . matches (  \"  .  *  +  \\  \\ d {  4  }  \"  )  ;", "}", "if    (  ( isSameOrNewer (  \"  0  .  9  .  2  \"  )  )     &  &     ( isSameOrOlder (  \"  1  .  0  - milestone -  2  \"  )  )  )     {", "if    ( version . getVersion (  )  . matches (  \"  1  .  0  - milestone -  \\  \\ d +  [ a - z ]  -  .  +  \"  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["wrapperCanExecute"], "fileName": "org.gradle.integtests.fixtures.executer.DefaultGradleDistribution"}, {"methodBody": ["METHOD_START", "{", "getExecHandle (  )  . abort (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["abort"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   execHandleFactory . create (  )  . setStandardOutput ( standardOutputCapturer . getOutputStream (  )  )  . setErrorOutput ( errorOutputCapturer . getOutputStream (  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildExecHandle"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   errorOutputCapturer . getOutputAsString (  )  ;", "}", "METHOD_END"], "methodName": ["getErrorOutput"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   handle    =    execHandleRef . get (  )  ;", "if    ( handle    =  =    null )     {", "throw   new   IllegalStateException (  \" you   must   call   start (  )    before   calling   this   method \"  )  ;", "}", "return   handle ;", "}", "METHOD_END"], "methodName": ["getExecHandle"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   standardOutputCapturer . getOutputAsString (  )  ;", "}", "METHOD_END"], "methodName": ["getStandardOutput"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    this . execHandleRef . get (  )  ;", "return    ( execHandle    !  =    null )     &  &     (  ( execHandle . getState (  )  )     =  =     ( ExecHandleState . STARTED )  )  ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   new   OutputCapturer (  ( durationMeasurement    =  =    null    ?    stream    :    NullOutputStream . INSTANCE )  ,    outputEncoding )  ;", "}", "METHOD_END"], "methodName": ["outputCapturerFor"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    getExecHandle (  )  ;", "Map < String ,    String >    environment    =    execHandle . getEnvironment (  )  ;", ". println (  (  (  (  \" Starting   build   with :     \"     +     ( execHandle . getCommand (  )  )  )     +     \"     \"  )     +     ( Joiner . on (  \"     \"  )  . join ( execHandle . getArguments (  )  )  )  )  )  ;", ". println (  (  \" Working   directory :     \"     +     ( execHandle . getDirectory (  )  )  )  )  ;", ". println (  \" Environment   vars :  \"  )  ;", ". println ( String . format (  \"             JAVA _ HOME :     % s \"  ,    environment . get (  \" JAVA _ HOME \"  )  )  )  ;", ". println ( String . format (  \"             GRADLE _ HOME :     % s \"  ,    environment . get (  \" GRADLE _ HOME \"  )  )  )  ;", ". println ( String . format (  \"             GRADLE _ USER _ HOME :     % s \"  ,    environment . get (  \" GRADLE _ USER _ HOME \"  )  )  )  ;", ". println ( String . format (  \"             JAVA _ OPTS :     % s \"  ,    environment . get (  \" JAVA _ OPTS \"  )  )  )  ;", ". println ( String . format (  \"             GRADLE _ OPTS :     % s \"  ,    environment . get (  \" GRADLE _ OPTS \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["printExecHandleSettings"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( s )  ;", "}", "METHOD_END"], "methodName": ["println"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stdinPipe )     =  =    null )     {", "throw   new   UnsupportedOperationException (  (  \" Handle   must   be   started   using   GradleEwithStdinPipe (  )    to   use    \"     +    method )  )  ;", "}", "}", "METHOD_END"], "methodName": ["requireStdinPipeFor"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    buildExecHandle (  )  ;", "if    (  ( this . execHandleRef . getAndSet ( execHandle )  )     !  =    null )     {", "throw   new   IllegalStateException (  \" you   have   already   called   start (  )    on   this   handle \"  )  ;", "}", "printExecHandleSettings (  )  ;", "execHandle . start (  )  ;", "if    (  ( durationMeasurement )     !  =    null )     {", "durationMeasurement . start (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    getExecHandle (  )  ;", "String   message    =    String . format (  (  \" Gradle   execution    % s   in    % s   with :     % s    % s % n \"     +     (  (  (  (  (  \" Process   ExecResult :  % n % s % n \"     +     \"  -  -  -  -  -  % n \"  )     +     \" Output :  % n % s % n \"  )     +     \"  -  -  -  -  -  % n \"  )     +     \" Error :  % n % s % n \"  )     +     \"  -  -  -  -  -  % n \"  )  )  ,    status ,    execHandle . getDirectory (  )  ,    execHandle . getCommand (  )  ,    execHandle . getArguments (  )  ,    execResult . toString (  )  ,    output ,    error )  ;", "Exception   exception    =     ( executionResult   instanceof   OutputScrapingExecutionFailure )     ?     (  ( OutputScrapingExecutionFailure )     ( executionResult )  )  . getException (  )     :    null ;", "return   exception    !  =    null    ?    new   UnexpectedBuildFailure ( message ,    exception )     :    new   UnexpectedBuildFailure ( message )  ;", "}", "METHOD_END"], "methodName": ["unexpectedBuildStatus"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ExecutionFailure )     ( waitForStop ( true )  )  )  ;", "}", "METHOD_END"], "methodName": ["waitForFailure"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   waitForStop ( false )  ;", "}", "METHOD_END"], "methodName": ["waitForFinish"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "ExecResult   execResult    =    getExecHandle (  )  . waitForFinish (  )  ;", "if    (  ( durationMeasurement )     !  =    null )     {", "durationMeasurement . stop (  )  ;", "}", "execResult . rethrowFailure (  )  ;", "String   output    =    getStandardOutput (  )  ;", "String   error    =    getErrorOutput (  )  ;", "boolean   buildFailed    =     (  ( execResult . getExitValue (  )  )     !  =     0  )     |  |     ( OutputScrapingExecutionFailure . hasFailure ( output )  )  ;", "ExecutionResult   executionResult    =     ( buildFailed )     ?    toExecutionFailure ( output ,    error )     :    toExecutionResult ( output ,    error )  ;", "if    ( expectFailure    &  &     (  ! buildFailed )  )     {", "throw   unexpectedBuildStatus ( execResult ,    output ,    error ,     \" did   not   fail \"  ,    executionResult )  ;", "}", "if    (  (  ! expectFailure )     &  &    buildFailed )     {", "throw   unexpectedBuildStatus ( execResult ,    output ,    error ,     \" failed \"  ,    executionResult )  ;", "}", "resultAssertion ( executionResult )  ;", "return   executionResult ;", "}", "METHOD_END"], "methodName": ["waitForStop"], "fileName": "org.gradle.integtests.fixtures.executer.ForkingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "buildJar ( jarFile ,    false )  ;", "}", "METHOD_END"], "methodName": ["buildJar"], "fileName": "org.gradle.integtests.fixtures.executer.GradleBackedArtifactBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( deleteIfExists    &  &     ( jarFile . exists (  )  )  )     {", "if    (  !  ( jarFile . delete (  )  )  )     {", "throw   new   IllegalStateException (  (  \" Couldn ' t   delete   file    \"     +    jarFile )  )  ;", "}", "}", "rootDir . file (  \" build . gradle \"  )  . writelns (  \" apply   plugin :     ' java '  \"  ,     \" dependencies    {    compile   gradleApi (  )     }  \"  ,    String . format (  \" jar . destinationDir    =    file (  '  % s '  )  \"  ,    FilenameUtils . separatorsToUnix ( jarFile . getParent (  )  )  )  ,    String . format (  \" jar . archiveName    =     '  % s '  \"  ,    jarFile . getName (  )  )  ,     \" new   URL (  \\  \" jar : file :  /  / valid _ jar _ url _ syntax . jar !  /  \\  \"  )  . openConnection (  )  . setDefaultUseCaches ( false )  \"  )  ;", "inDirectory ( rootDir )  . withTasks (  \" clean \"  ,     \" jar \"  )  . run (  )  ;", "}", "METHOD_END"], "methodName": ["buildJar"], "fileName": "org.gradle.integtests.fixtures.executer.GradleBackedArtifactBuilder"}, {"methodBody": ["METHOD_START", "{", "return   rootDir . file (  \" src / main / resources \"  ,    path )  ;", "}", "METHOD_END"], "methodName": ["resourceFile"], "fileName": "org.gradle.integtests.fixtures.executer.GradleBackedArtifactBuilder"}, {"methodBody": ["METHOD_START", "{", "return   rootDir . file (  \" src / main / java \"  ,    path )  ;", "}", "METHOD_END"], "methodName": ["sourceFile"], "fileName": "org.gradle.integtests.fixtures.executer.GradleBackedArtifactBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( getClass (  )  . desiredAssertionStatus (  )  )  )     {", "throw   new   RuntimeException (  \" Assertions   must   be   enabled   when   running   integration   tests .  \"  )  ;", "}", "if    (  ( gradle )     =  =    null )     {", "gradle    =    create ( executerType )  ;", "} else    {", "gradle . reset (  )  ;", "}", "configure ( gradle )  ;", "try    {", "gradle . assertCanExecute (  )  ;", "}    catch    ( AssertionError   assertionError )     {", "gradle    =    new   NoDaemonGradle ( getDistribution (  )  ,    getTestDirectoryProvider (  )  )  ;", "configure ( gradle )  ;", "}", "return   gradle ;", "}", "METHOD_END"], "methodName": ["configureExecuter"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "copyTo ( gradleExecuter )  ;", "}", "METHOD_END"], "methodName": ["configureExecuter"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "switch    ( executerType )     {", "case   embedded    :", "return   new   InProcessGradleExecuter ( getDistribution (  )  ,    getTestDirectoryProvider (  )  ,    gradleVersion ,    buildContext )  ;", "case   noDaemon    :", "return   new   NoDaemonGradleExecuter ( getDistribution (  )  ,    getTestDirectoryProvider (  )  ,    gradleVersion ,    buildContext )  ;", "case   parallel    :", "return   new   ParallelForkingGradleExecuter ( getDistribution (  )  ,    getTestDirectoryProvider (  )  ,    gradleVersion ,    buildContext )  ;", "case   forking    :", "return   new   DaemonGradleExecuter ( getDistribution (  )  ,    getTestDirectoryProvider (  )  ,    gradleVersion ,    buildContext )  ;", "default    :", "throw   new   RuntimeException (  (  \" Not   a   supported   executer   type :     \"     +    executerType )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createExecuter"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return   GradleContextualExecuter . Executer . valueOf ( System . getProperty ( GradleContextualExecuter . EXECUTER _ SYS _ PROP ,    GradleContextualExecuter . Executer . forking . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSystemPropertyExecuter"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return    !  (  ( GradleContextualExecuter . isNoDaemon (  )  )     |  |     ( GradleContextualExecuter . isEmbedded (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isDaemon"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return    !  ( GradleContextualExecuter . getSystemPropertyExecuter (  )  . forks )  ;", "}", "METHOD_END"], "methodName": ["isEmbedded"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return    !  ( GradleContextualExecuter . isNoDaemon (  )  )  ;", "}", "METHOD_END"], "methodName": ["isLongLivingProcess"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( GradleContextualExecuter . getSystemPropertyExecuter (  )  )     =  =     ( GradleContextualExecuter . Executer . noDaemon )  ;", "}", "METHOD_END"], "methodName": ["isNoDaemon"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "return   GradleContextualExecuter . getSystemPropertyExecuter (  )  . executeParallel ;", "}", "METHOD_END"], "methodName": ["isParallel"], "fileName": "org.gradle.integtests.fixtures.executer.GradleContextualExecuter"}, {"methodBody": ["METHOD_START", "{", "assertNull ( getExecutable (  )  )  ;", "String   defaultEncoding    =    getImplicitJvmSystemProperties (  )  . get (  \" file . encoding \"  )  ;", "if    ( defaultEncoding    !  =    null )     {", "assertEquals ( Charset . forName ( defaultEncoding )  ,    Charset . defaultCharset (  )  )  ;", "}", "Locale   defaultLocale    =    getDefaultLocale (  )  ;", "if    ( defaultLocale    !  =    null )     {", "assertEquals ( defaultLocale ,    Locale . getDefault (  )  )  ;", "}", "assertFalse ( isRequireDistribution (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCanExecute"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "getResultAssertion (  )  . execute ( result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["assertResult"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "List < File >    result    =    new   LinkedList < File >  (  )  ;", "String   prefix    =     ( Jvm . current (  )  . getJavaHome (  )  . getPath (  )  )     +     ( File . separator )  ;", "for    ( File   file    :    files )     {", "if    ( file . getPath (  )  . startsWith ( prefix )  )     {", "continue ;", "}", "result . add ( file )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildActionParameters ( System . getProperties (  )  ,    System . getenv (  )  ,    SystemProperties . getInstance (  )  . getCurrentDir (  )  ,    startParameter . getLogLevel (  )  ,    false ,    startParameter . isContinuous (  )  ,    interactive ,    ClassPath . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["createBuildActionParameters"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildRequestContext ( new   DefaultBuildRequestMetaData ( new   GradleLauncherMetaData (  )  )  ,    new   DefaultBuildCancellationToken (  )  ,    new   NoOpBuildEventConsumer (  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuildRequestContext"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "LoggingManagerInternal   loggingManager    =    AbstractGradleExecuter . GLOBAL _ SERVICES . getFactory ( LoggingManagerInternal . class )  . create (  )  ;", "loggingManager . captureSystemSources (  )  ;", "ConsoleOutput   consoleOutput    =    startParameter . getConsoleOutput (  )  ;", "if    ( consoleOutput    =  =     ( ConsoleOutput . Auto )  )     {", "consoleOutput    =    ConsoleOutput . Plain ;", "}", "loggingManager . attachConsole ( new   TeeOutputStream ( System . out ,    outputStream )  ,    new   TeeOutputStream ( System . err ,    errorStream )  ,    consoleOutput )  ;", "return   loggingManager ;", "}", "METHOD_END"], "methodName": ["createLoggingManager"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "InputStream   originalStdIn    =    System . in ;", "Properties   originalSysProperties    =    new   Properties (  )  ;", "originalSysProperties . putAll ( System . getProperties (  )  )  ;", "File   originalUserDir    =    new   File ( originalSysProperties . getProperty (  \" user . dir \"  )  )  . getAbsoluteFile (  )  ;", "Map < String ,    String >    originalEnv    =    new   HashMap < String ,    String >  ( System . getenv (  )  )  ;", "Abstract . GradleInvocation   invocation    =    buildInvocation (  )  ;", "Set < String >    changedEnvVars    =    new   HashSet < String >  ( invocation . environmentVars . keySet (  )  )  ;", "try    {", "return   executeBuild ( invocation ,    outputStream ,    errorStream ,    listener )  ;", "}    finally    {", "System . setProperties ( originalSysProperties )  ;", "resetTempDirLocation (  )  ;", "processEnvironment . maybeSetProcessDir ( originalUserDir )  ;", "for    ( String   envVar    :    changedEnvVars )     {", "String   oldValue    =    originalEnv . get ( envVar )  ;", "if    ( oldValue    !  =    null )     {", "processEnvironment . maybeSetEnvironmentVariable ( envVar ,    oldValue )  ;", "} else    {", "processEnvironment . maybeRemoveEnvironmentVariable ( envVar )  ;", "}", "}", "System . setProperty (  \" user . dir \"  ,    originalSysProperties . getProperty (  \" user . dir \"  )  )  ;", "System . setIn ( originalStdIn )  ;", "}", "}", "METHOD_END"], "methodName": ["doRun"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "System . setIn ( connectStdIn (  )  )  ;", "processEnvironment . maybeSetProcessDir ( getWorkingDir (  )  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    invocation . environmentVars . entrySet (  )  )     {", "processEnvironment . maybeSetEnvironmentVariable ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "Map < String ,    String >    implicitJvmSystemProperties    =    getImplicitJvmSystemProperties (  )  ;", "System . getProperties (  )  . putAll ( implicitJvmSystemProperties )  ;", "resetTempDirLocation (  )  ;", "StartParameterInternal   startParameter    =    new   StartParameterInternal (  )  ;", "startParameter . setCurrentDir ( getWorkingDir (  )  )  ;", "CommandLineParser   parser    =    new   CommandLineParser (  )  ;", "BuildLayoutFactory   buildLayoutFactory    =    new   BuildLayoutFactory (  )  ;", "ParametersConverter   parametersConverter    =    new   ParametersConverter ( buildLayoutFactory )  ;", "parametersConverter . configure ( parser )  ;", "final   Parameters   parameters    =    new   Parameters ( startParameter )  ;", "parametersConverter . convert ( parser . parse ( getAllArgs (  )  )  ,    parameters )  ;", "BuildActionExecuter < BuildActionParameters >    actionExecuter    =    Abstract . GLOBAL _ SERVICES . get ( BuildActionExecuter . class )  ;", "ListenerManager   listenerManager    =    Abstract . GLOBAL _ SERVICES . get ( ListenerManager . class )  ;", "listenerManager . addListener ( listener )  ;", "try    {", "BuildAction   action    =    new   ExecuteBuildAction ( startParameter )  ;", "BuildActionParameters   buildActionParameters    =    createBuildActionParameters ( startParameter )  ;", "BuildRequestContext   buildRequestContext    =    createBuildRequestContext (  )  ;", "LoggingManagerInternal   loggingManager    =    createLoggingManager ( startParameter ,    outputStream ,    errorStream )  ;", "loggingManager . start (  )  ;", "try    {", "startMeasurement (  )  ;", "try    {", "actionExecuter . execute ( action ,    buildRequestContext ,    buildActionParameters ,    Abstract . GLOBAL _ SERVICES )  ;", "}    finally    {", "stopMeasurement (  )  ;", "}", "}    finally    {", "loggingManager . stop (  )  ;", "}", "return   new   BuildResult ( null ,    null )  ;", "}    catch    ( ReportedException   e )     {", "return   new   BuildResult ( null ,    e . getCause (  )  )  ;", "}    finally    {", "listenerManager . removeListener ( listener )  ;", "}", "}", "METHOD_END"], "methodName": ["executeBuild"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   Factory < JavaExecHandleBuilder >  (  )     {", "public   JavaExecHandleBuilder   create (  )     {", "AbstractGradleExecuter . GradleInvocation   invocation    =    buildInvocation (  )  ;", "JavaExecHandleBuilder   builder    =    TestFiles . execFactory (  )  . newJavaExec (  )  ;", "builder . workingDir ( getWorkingDir (  )  )  ;", "builder . setExecutable ( new   File ( getJavaHome (  )  ,     \" bin / java \"  )  )  ;", "Collection < File >    classpath    =    cleanup ( AbstractGradleExecuter . GLOBAL _ SERVICES . get ( ModuleRegistry . class )  . getAdditionalClassPath (  )  . getAsFiles (  )  )  ;", "builder . classpath ( classpath )  ;", "builder . jvmArgs ( invocation . launcherJvmArgs )  ;", "builder . setMain ( Main . class . getName (  )  )  ;", "builder . args ( invocation . args )  ;", "builder . setStandardInput ( connectStdIn (  )  )  ;", "return   builder ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getJavaExecBuilder"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isUseDaemon (  )  )     |  |     (  !  ( getJavaHome (  )  . equals ( Jvm . current (  )  . getJavaHome (  )  )  )  )  )     {", "return   true ;", "}", "File   gradleProperties    =    new   File ( getWorkingDir (  )  ,     \" gradle . properties \"  )  ;", "if    ( gradleProperties . isFile (  )  )     {", "Properties   properties    =    GUtil . loadProperties ( gradleProperties )  ;", "if    (  (  ( properties . getProperty (  \" home \"  )  )     !  =    null )     |  |     (  ( properties . getProperty (  \" jvmargs \"  )  )     !  =    null )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isForkRequired"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "SetSystemProperties . resetTempDirLocation (  )  ;", "}", "METHOD_END"], "methodName": ["resetTempDirLocation"], "fileName": "org.gradle.integtests.fixtures.executer.InProcessGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( version . equals ( getVersion (  )  . getVersion (  )  )  )     {", "return   new   UnderDevelopmentGDistribution (  )  ;", "}", "TestFile   previousVersionDir    =    getGUserHomeDir (  )  . getParentFile (  )  . file (  \" previousVersion \"  )  ;", "if    ( version . startsWith (  \"  #  \"  )  )     {", "return   new   BuildServerGDistribution ( version ,    previousVersionDir . file ( version )  )  ;", "}", "return   new   ReleasedGDistribution ( version ,    previousVersionDir . file ( version )  )  ;", "}", "METHOD_END"], "methodName": ["distribution"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "String   defaultPath ;", "if    ( defaultFile    =  =    null )     {", "defaultPath    =    null ;", "} else", "if    ( new   File ( defaultFile )  . isAbsolute (  )  )     {", "defaultPath    =    defaultFile ;", "} else    {", "defaultPath    =     . TEST _ DIR . file ( defaultFile )  . getAbsolutePath (  )  ;", "}", "String   path    =    System . getProperty ( propertyName ,    defaultPath )  ;", "if    ( path    =  =    null )     {", "throw   new   RuntimeException ( String . format (  \" You   must   set   the    '  % s '    property   to   run   the   integration   tests .    The   default   passed   was :     '  % s '  \"  ,    propertyName ,    defaultFile )  )  ;", "}", "return   new   TestFile ( new   File ( path )  )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" registry \"  ,     \" build / daemon \"  )  ;", "}", "METHOD_END"], "methodName": ["getDaemonBaseDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   GradleVersion . version ( System . getProperty (  \" integTest . distZipVersion \"  ,    GradleVersion . current (  )  . getVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDistZipVersion"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . distsDir \"  ,     \" build / distributions \"  )  ;", "}", "METHOD_END"], "methodName": ["getDistributionsDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "TestFile   toolingApiShadedJarDir    =    IntegrationTestBuildContext . file (  \" integTest . toolingApiShadedJarDir \"  ,     \" subprojects / tooling - api / build / shaded - jar \"  )  ;", "TestFile   fatToolingApiJar    =    new   TestFile ( toolingApiShadedJarDir ,    String . format (  \" gradle - tooling - api - shaded -  % s . jar \"  ,    getVersion (  )  . getBaseVersion (  )  . getVersion (  )  )  )  ;", "if    (  !  ( fatToolingApiJar . exists (  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" The   fat   Tooling   API   JAR   file   does   not   exist :     % s \"  ,    fatToolingApiJar . getAbsolutePath (  )  )  )  ;", "}", "return   fatToolingApiJar ;", "}", "METHOD_END"], "methodName": ["getFatToolingApiJar"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . gradleHomeDir \"  ,    null )  ;", "}", "METHOD_END"], "methodName": ["getGradleHomeDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . gradleUserHomeDir \"  ,     \" intTestHomeDir \"  )  . file (  \" worker -  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["getGradleUserHomeDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . libsRepo \"  ,     \" build / repo \"  )  ;", "}", "METHOD_END"], "methodName": ["getLibsRepo"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   getGradleUserHomeDir (  )  . file (  \" native \"  )  ;", "}", "METHOD_END"], "methodName": ["getNativeServicesDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . samplesdir \"  ,    String . format (  \"  % s / samples \"  ,    getGradleHomeDir (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSamplesDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . tmpDir \"  ,     \" build / tmp \"  )  ;", "}", "METHOD_END"], "methodName": ["getTmpDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . userGuideInfoDir \"  ,     \" subprojects / docs / build / src \"  )  ;", "}", "METHOD_END"], "methodName": ["getUserGuideInfoDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   IntegrationTestBuildContext . file (  \" integTest . userGuideOutputDir \"  ,     \" subprojects / docs / src / samples / userguideOutput \"  )  ;", "}", "METHOD_END"], "methodName": ["getUserGuideOutputDir"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "return   GradleVersion . current (  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.integtests.fixtures.executer.IntegrationTestBuildContext"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "for    ( String   line    :    lines )     {", "if    ( pattern . matcher ( line )  . matches (  )  )     {", "count +  +  ;", "}", "}", "return   count ;", "}", "METHOD_END"], "methodName": ["countMatches"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   new   LogContent ( lines . subList ( i ,    lines . size (  )  )  ,    definitelyNoDebugPrefix ,    rawContent . lines ( i ,    lines . size (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["drop"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "for    ( String   line    :    lines )     {", "action ( line )  ;", "}", "}", "METHOD_END"], "methodName": ["eachLine"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   new   LogContent ( ImmutableList .  < String > of (  )  ,    true ,    null )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   lines ;", "}", "METHOD_END"], "methodName": ["getLines"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   rawContent ;", "}", "METHOD_END"], "methodName": ["getRawContent"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rawContent )     !  =     ( this )  )     {", "throw   new   UnsupportedOperationException (  \" not   implemented \"  )  ;", "}", "return   new    ( lines . subList ( startLine ,    endLine )  ,    definitelyNoDebugPrefix ,    null )  ;", "}", "METHOD_END"], "methodName": ["lines"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   new   LogContent ( LogContent . toLines ( LogContent . stripJavaIllegalAccessWarnings ( LogContent . stripWorkInProgressArea ( chars )  )  )  ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   new   LogContent ( ImmutableList . copyOf ( lines )  ,    false ,    null )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "if    ( lines . isEmpty (  )  )     {", "return   this ;", "}", "try    {", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "Writer   writer    =    new   OutputStreamWriter ( new   AnsiOutputStream ( baos )  )  ;", "for    ( int   i    =     0  ;    i    <     ( lines . size (  )  )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "writer . write (  \"  \\ n \"  )  ;", "}", "writer . write ( lines . get ( i )  )  ;", "}", "writer . flush (  )  ;", "return   new    (  . toLines ( baos . toString (  )  )  ,    definitelyNoDebugPrefix ,    rawContent )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["removeAnsiChars"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "if    ( definitelyNoDebugPrefix )     {", "return   this ;", "}", "List < String >    result    =    new   ArrayList < String >  ( lines . size (  )  )  ;", "for    ( String   line    :    lines )     {", "Matcher   matcher    =     . DEBUG _ PREFIX . matcher ( line )  ;", "if    ( matcher . lookingAt (  )  )     {", "result . add ( line . substring ( matcher . end (  )  )  )  ;", "} else    {", "result . add ( line )  ;", "}", "}", "return   new    ( ImmutableList . copyOf ( result )  ,    true ,    rawContent )  ;", "}", "METHOD_END"], "methodName": ["removeDebugPrefix"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( lines . size (  )  )  ;    i +  +  )     {", "String   line    =    lines . get ( i )  ;", "if    ( pattern . matcher ( line )  . matches (  )  )     {", "before    =    new    ( lines . subList (  0  ,    i )  ,    definitelyNoDebugPrefix ,    rawContent . lines (  0  ,    i )  )  ;", "after    =    new    ( lines . subList ( i ,    lines . size (  )  )  ,    definitelyNoDebugPrefix ,    rawContent . lines ( i ,    lines . size (  )  )  )  ;", "return   Pair . of ( before ,    after )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["splitOnFirstMatchingLine"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return   LogContent . JAVA _ ILLEGAL _ ACCESS _ WARNING _ PATTERN . matcher ( result )  . replaceAll (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["stripJavaIllegalAccessWarnings"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "String   result    =    output ;", "for    ( int   i    =     1  ;    i    <  =     1  0  ;     +  + i )     {", "result    =    result . replaceAll (  . workInProgressAreaScrollingPattern ( i )  ,     \"  \"  )  ;", "}", "return    . WORK _ IN _ PROGRESS _ AREA _ PATTERN . matcher ( result )  . replaceAll (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["stripWorkInProgressArea"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "List < String >    lines    =    new   ArrayList < String >  (  )  ;", "pos    =     0  ;", "while    ( pos    <     ( chars . length (  )  )  )     {", "next    =    chars . indexOf (  '  \\ n '  ,    pos )  ;", "if    ( next    <     0  )     {", "lines . add ( chars . substring ( pos )  )  ;", "pos    =    chars . length (  )  ;", "continue ;", "}", "if    (  ( next    >    pos )     &  &     (  ( chars . charAt (  ( next    -     1  )  )  )     =  =     '  \\ r '  )  )     {", "lines . add ( chars . substring ( pos ,     ( next    -     1  )  )  )  ;", "pos    =    next    +     1  ;", "} else    {", "lines . add ( chars . substring ( pos ,    next )  )  ;", "pos    =    next    +     1  ;", "}", "if    ( pos    =  =     ( chars . length (  )  )  )     {", "lines . add (  \"  \"  )  ;", "}", "}", "return   ImmutableList . copyOf ( lines )  ;", "}", "METHOD_END"], "methodName": ["toLines"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "if    ( lines . isEmpty (  )  )     {", "return    \"  \"  ;", "}", "return   Joiner . on (  '  \\ n '  )  . join ( lines )  ;", "}", "METHOD_END"], "methodName": ["withNormalizedEol"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \"  (  \\ u 0  0  1 b \\  \\  [  0 K \\  \\ n )  {  \"     +    scroll )     +     \"  }  \\ u 0  0  1 b \\  \\  [  \"  )     +    scroll )     +     \" A \"  ;", "}", "METHOD_END"], "methodName": ["workInProgressAreaScrollingPattern"], "fileName": "org.gradle.integtests.fixtures.executer.LogContent"}, {"methodBody": ["METHOD_START", "{", "for    ( String   propName    :    AbstractGradleExecuter . PROPAGATED _ SYSTEM _ PROPERTIES )     {", "String   propValue    =    System . getProperty ( propName )  ;", "if    ( propValue    !  =    null )     {", "args . add (  (  (  (  \"  - D \"     +    propName )     +     \"  =  \"  )     +    propValue )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addPropagatedSystemProperties"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( getDistribution (  )  . isSupportsSpacesInGradleAndJavaOpts (  )  )  )     {", "Map < String ,    String >    environmentVars    =    buildInvocation (  )  . environmentVars ;", "for    ( String   envVarName    :    Arrays . asList (  \" JAVA _ OPTS \"  ,     \" GRADLE _ OPTS \"  )  )     {", "String   envVarValue    =    environmentVars . get ( envVarName )  ;", "if    ( envVarValue    =  =    null )     {", "continue ;", "}", "for    ( String   arg    :    JvmOptions . fromString ( envVarValue )  )     {", "if    ( arg . contains (  \"     \"  )  )     {", "throw   new   AssertionError ( String . format (  \" Env   var    % s   contains   arg   with   space    (  % s )    which   is   not   supported   by   Gradle    % s \"  ,    envVarName ,    arg ,    getDistribution (  )  . getVersion (  )  . getVersion (  )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["assertCanExecute"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "TestFile   gradleHomeDir    =    getDistribution (  )  . getGradleHomeDir (  )  ;", "if    (  !  ( gradleHomeDir . isDirectory (  )  )  )     {", "fail (  (  ( gradleHomeDir    +     \"    is   not   a   directory .  \\ n \"  )     +     \" If   you   are   running   tests   from   IDE   make   sure   that   gradle   tasks   that   prepare   the   test   image   were   executed .    Last   time   it   was    ' intTestImage '    task .  \"  )  )  ;", "}", "NativeServicesTestFixture . initialize (  )  ;", "DefaultExecHandleBuilder   builder    =    new   DefaultExecHandleBuilder ( TestFiles . resolver (  )  ,    Executors . newCachedThreadPool (  )  )     {", "@ Override", "public   File   getWorkingDir (  )     {", "return    . this . getWorkingDir (  )  ;", "}", "}  ;", "builder . environment (  \" GRADLE _ HOME \"  ,     \"  \"  )  ;", "builder . environment (  \" JAVA _ HOME \"  ,     \"  \"  )  ;", "builder . environment (  \" GRADLE _ OPTS \"  ,     \"  \"  )  ;", "builder . environment (  \" JAVA _ OPTS \"  ,     \"  \"  )  ;", "AbstractGradleExecuter . GradleInvocation   invocation    =    buildInvocation (  )  ;", "builder . environment ( invocation . environmentVars )  ;", "builder . workingDir ( getWorkingDir (  )  )  ;", "builder . setStandardInput ( connectStdIn (  )  )  ;", "builder . args ( invocation . args )  ;", ". ExecHandlerConfigurer   configurer    =     ( OperatingSystem . current (  )  . isWindows (  )  )     ?    new    . WindowsConfigurer (  )     :    new    . UnixConfigurer (  )  ;", "configurer . configure ( builder )  ;", "getLogger (  )  . debug ( String . format (  \" Execute   in    % s   with :     % s    % s \"  ,    builder . getWorkingDir (  )  ,    builder . getExecutable (  )  ,    builder . getArgs (  )  )  )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["createExecHandleBuilder"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   ForkingGradleHandle ( getStdinPipe (  )  ,    isUseDaemon (  )  ,    resultAssertion ,    encoding ,    execHandleFactory ,    getDurationMeasurement (  )  )  ;", "}", "METHOD_END"], "methodName": ["createForkingGradleHandle"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   startHandle (  )  . waitForFinish (  )  ;", "}", "METHOD_END"], "methodName": ["doRun"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   start (  )  . waitForFailure (  )  ;", "}", "METHOD_END"], "methodName": ["doRunWithFailure"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "final   Jvm   current    =    Jvm . current (  )  ;", "if    ( getJavaHome (  )  . equals ( current . getJavaHome (  )  )  )     {", "ren   current . getJavaVersion (  )  . isJava 7 Compatible (  )  ;", "} else    {", "ren   false ;", "}", "}", "METHOD_END"], "methodName": ["supportsWhiteSpaceInEnvVars"], "fileName": "org.gradle.integtests.fixtures.executer.NoDaemonGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   buffer . toString ( oEncoding )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getOutputAsString"], "fileName": "org.gradle.integtests.fixtures.executer.OutputCapturer"}, {"methodBody": ["METHOD_START", "{", "return   outputStream ;", "}", "METHOD_END"], "methodName": ["getOutputStream"], "fileName": "org.gradle.integtests.fixtures.executer.OutputCapturer"}, {"methodBody": ["METHOD_START", "{", "assertThatCause ( startsWith ( description )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertHasCause"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThatDescription ( startsWith ( context )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertHasDescription"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . fileName ,    equalTo ( filename )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertHasFileName"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . lineNumber ,    equalTo ( String . valueOf ( lineNumber )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertHasLineNumber"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThat ( causes ,    isEmpty (  )  )  ;", "ren   this ;", "}", "METHOD_END"], "methodName": ["assertHasNoCause"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThat ( this . resolution ,    containsString ( resolution )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertHasResolution"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "return   new   DependencyResolutionFailure ( this ,    configurationPath )  ;", "}", "METHOD_END"], "methodName": ["assertResolutionFailure"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "new   DetailedExecutionFailure ( this )  . assertTestsFailed (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertTestsFailed"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "for    ( String   cause    :    causes )     {", "if    ( matcher . matches ( cause )  )     {", "return   this ;", "}", "}", "fail ( String . format (  \" No   matching   cause   found   in    % s .     :     [  % s ]  ,    Error :     [  % s ]  \"  ,    causes ,    get (  )  ,    getError (  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertThatCause"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "assertThat ( description ,    matcher )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertThatDescription"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    OutputScrapingExecutionFailure . CAUSE _ PATTERN . matcher ( problem )  ;", "String   description ;", "List < String >    causes    =    new   ArrayList < String >  (  )  ;", "if    (  !  ( matcher . find (  )  )  )     {", "description    =    TextUtil . normaliseLineSeparators ( problem . trim (  )  )  ;", "} else    {", "description    =    TextUtil . normaliseLineSeparators ( problem . substring (  0  ,    matcher . start (  )  )  . trim (  )  )  ;", "while    ( true )     {", "int   pos    =    matcher . end (  )  ;", "int   prefix    =    matcher . group (  1  )  . length (  )  ;", "String   prefixPattern    =    toPrefixPattern ( prefix )  ;", "if    ( matcher . find ( pos )  )     {", "String   cause    =    TextUtil . normaliseLineSeparators ( problem . substring ( pos ,    matcher . start (  )  )  . trim (  )  . replaceAll ( prefixPattern ,     \"  \"  )  )  ;", "causes . add ( cause )  ;", "} else    {", "String   cause    =    TextUtil . normaliseLineSeparators ( problem . substring ( pos )  . trim (  )  . replaceAll ( prefixPattern ,     \"  \"  )  )  ;", "causes . add ( cause )  ;", "break ;", "}", "}", "}", "return   new   OutputScrapingExecutionFailure . Problem ( description ,    causes )  ;", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "return   new   OutputScrapingExecutionFailure ( output ,    error )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "return   exception ;", "}", "METHOD_END"], "methodName": ["getException"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "return   OutputScrapingExecutionFailure . FAILURE _ PATTERN . matcher ( error )  . find (  )  ;", "}", "METHOD_END"], "methodName": ["hasFailure"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "Exception   causedBy    =    null ;", "if    ( exceptionCauseMatcher . find (  )  )     {", "String   causedByClass    =    exceptionCauseMatcher . group (  1  )  . trim (  )  ;", "String   causedByMessage    =    exceptionCauseMatcher . group (  2  )  . trim (  )  ;", "causedBy    =    recreateException ( causedByClass ,    causedByMessage ,    exceptionCauseMatcher )  ;", "}", "try    {", "if    ( causedBy    =  =    null )     {", "return    (  ( Exception )     ( Class . forName ( className )  . getConstructor ( String . class )  . newInstance ( message )  )  )  ;", "} else    {", "return    (  ( Exception )     ( Class . forName ( className )  . getConstructor ( String . class ,    Throwable . class )  . newInstance ( message ,    causedBy )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "return   new   Exception ( message )  ;", "}", "}", "METHOD_END"], "methodName": ["recreateException"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  \"  (  ? m )  ^  \"  )  ;", "for    ( int   i    =     0  ;    i    <    prefix ;    i +  +  )     {", "builder . append (  '     '  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toPrefixPattern"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionFailure"}, {"methodBody": ["METHOD_START", "{", "SequentialOutputMatcher   matcher    =     ( ignoreLineOrder )     ?    new   AnyOrderOutputMatcher (  )     :    new   SequentialOutputMatcher (  )  ;", "matcher . assertOutputMatches ( expectedOutput ,    getNormalizedOutput (  )  ,    ignoreExtraLines )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertOutputEquals"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "Set < String >    tasks    =    new   TreeSet < String >  ( getNotSkippedTasks (  )  )  ;", "if    (  !  ( tasks . contains ( taskPath )  )  )     {", "failOnMissingElement (  \" Build   o   does   not   contain   the   expected   non   skipped   task .  \"  ,    taskPath ,    tasks )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["assertTaskNotSkipped"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "Set < String >    tasks    =    new   TreeSet < String >  ( getSkippedTasks (  )  )  ;", "if    (  !  ( tasks . contains ( taskPath )  )  )     {", "failOnMissingElement (  \" Build   o   does   not   contain   the   expected   skipped   task .  \"  ,    taskPath ,    tasks )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["assertTaskSkipped"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "Set < String >    allTasks    =    TaskOrderSpecs . exact ( taskPaths )  . getTasks (  )  ;", "assertTasksed ( allTasks )  ;", "assertTaskOrder ( taskPaths )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["assertTasksExecutedInOrder"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError ( String . format (  \"  % s % nExpected :     % s % nActual :     % s % nOutput :  % n =  =  =  =  =  =  =  % n % s % nError :  % n =  =  =  =  =  =  % n % s \"  ,    message ,    expected ,    actual ,    getOutput (  )  ,    getError (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["failOnDifferentSets"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError ( String . format (  \"  % s % nExpected :     % s % nActual :     % s % nOutput :  % n =  =  =  =  =  =  =  % n % s % nError :  % n =  =  =  =  =  =  % n % s \"  ,    message ,    expected ,    actual ,    getOutput (  )  ,    getError (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["failOnMissingElement"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "throw   new   AssertionError ( String . format (  \"  % s % nExpected :     % s % n % n % s :  % n =  =  =  =  =  =  =  % n % s % nOutput :  % n =  =  =  =  =  =  =  % n % s % nError :  % n =  =  =  =  =  =  % n % s \"  ,    message ,    expected ,    type ,    actual ,    getOutput (  )  ,    getError (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["failOnMissingOutput"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tasks )     =  =    null )     {", "tasks    =    new   LinkedHashSet < String >  ( grepTasks (  . TASK _ PATTERN )  )  ;", "}", "return   tasks ;", "}", "METHOD_END"], "methodName": ["findExecutedTasksInOrderStarted"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . toStringList ( GUtil . flatten ( taskPaths ,    Lists . newArrayList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["flattenTaskPaths"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( output . contains (  \" BUILD   FAILED \"  )  )     |  |     ( output . contains (  \" FAILURE :    Build   failed   with   an   exception .  \"  )  )  )     |  |     ( error . contains (  \" BUILD   FAILED \"  )  )  )     {", "return   new   OutputScrapingExecutionFailure ( output ,    error )  ;", "}", "return   new    ( LogContent . of ( output )  ,    LogContent . of ( error )  )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   error . withNormalizedEol (  )  ;", "}", "METHOD_END"], "methodName": ["getError"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableList . copyOf ( findExecutedTasksInOrderStarted (  )  )  ;", "}", "METHOD_END"], "methodName": ["getExecutedTasks"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   mainContent ;", "}", "METHOD_END"], "methodName": ["getMainContent"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "Set < String >    all    =    new   TreeSet < String >  ( getExecutedTasks (  )  )  ;", "Set < String >    skipped    =    getSkippedTasks (  )  ;", "all . removeAll ( skipped )  ;", "return   all ;", "}", "METHOD_END"], "methodName": ["getNotSkippedTasks"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   output . withNormalizedEol (  )  ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   new   TreeSet < String >  ( grepTasks ( OutputScrapingExecutionResult . SKIPPED _ TASK _ PATTERN )  )  ;", "}", "METHOD_END"], "methodName": ["getSkippedTasks"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    tasks    =    Lists . newArrayList (  )  ;", "final   List < String >    taskStatusLines    =    Lists . newArrayList (  )  ;", "getMainContent (  )  . eachLine ( new   Action < String >  (  )     {", "public   void   execute ( String   line )     {", "Matcher   matcher    =    pattern . matcher ( line )  ;", "if    ( matcher . matches (  )  )     {", "String   taskStatusLine    =    matcher . group (  )  . replace (  . TASK _ PREFIX ,     \"  \"  )  ;", "String   taskName    =    matcher . group (  2  )  ;", "if    (  !  ( taskName . contains (  \"  : buildSrc :  \"  )  )  )     {", "String   previousTaskStatusLine    =     ( tasks . contains ( taskName )  )     ?    taskStatusLines . get ( tasks . lastIndexOf ( taskName )  )     :     \"  \"  ;", "if    (  ( previousTaskStatusLine . equals ( taskName )  )     &  &     (  !  ( taskStatusLine . equals ( taskName )  )  )  )     {", "return ;", "}", "taskStatusLines . add ( taskStatusLine )  ;", "tasks . add ( taskName )  ;", "}", "}", "}", "}  )  ;", "return   tasks ;", "}", "METHOD_END"], "methodName": ["grepTasks"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList < String >  (  )  ;", "List < String >    lines    =    output . getLines (  )  ;", "int   i    =     0  ;", "while    ( i    <     ( lines . size (  )  )  )     {", "String   line    =    lines . get ( i )  ;", "if    ( line . contains ( STARTING _ DAEMON _ MESSAGE )  )     {", "i +  +  ;", "} else", "if    ( line . contains ( DaemonStateCoordinator . DAEMON _ WILL _ STOP _ MESSAGE )  )     {", "i +  +  ;", "} else", "if    ( line . contains ( LowTenuredSpaceDaemonExpirationStrategy . EXPIRE _ DAEMON _ MESSAGE )  )     {", "i +  +  ;", "} else", "if    ( line . contains ( LoggingDeprecatedFeatureHandler . WARNING _ SUMMARY )  )     {", "i    +  =     2  ;", "} else", "if    ( line . contains ( UnsupportedJavaRuntimeException . JAVA 7  _ DEPRECATION _ WARNING )  )     {", "i +  +  ;", "while    (  ( i    <     ( lines . size (  )  )  )     &  &     (  . STACK _ TRACE _ ELEMENT . matcher ( lines . get ( i )  )  . matches (  )  )  )     {", "i +  +  ;", "}", "} else", "if    (  . BUILD _ RESULT _ PATTERN . matcher ( line )  . matches (  )  )     {", "result . add (  . BUILD _ RESULT _ PATTERN . matcher ( line )  . replaceFirst (  \" BUILD    $  1    in    0 s \"  )  )  ;", "i +  +  ;", "} else    {", "result . add ( line )  ;", "i +  +  ;", "}", "}", "return   LogContent . of ( result )  . withNormalizedEol (  )  ;", "}", "METHOD_END"], "methodName": ["normalize"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingExecutionResult"}, {"methodBody": ["METHOD_START", "{", "return   OutputScrapingExecutionFailure . from ( output ,    error )  ;", "}", "METHOD_END"], "methodName": ["toExecutionFailure"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "return   OutputScrapingExecutionResult . from ( output ,    error )  ;", "}", "METHOD_END"], "methodName": ["toExecutionResult"], "fileName": "org.gradle.integtests.fixtures.executer.OutputScrapingGradleHandle"}, {"methodBody": ["METHOD_START", "{", "for    ( String   arg    :    args )     {", "if    ( arg . startsWith (  \"  -  - max - workers \"  )  )     {", "return ;", "}", "}", "args . add (  \"  -  - max - workers =  4  \"  )  ;", "}", "METHOD_END"], "methodName": ["maybeSetMaxWorkers"], "fileName": "org.gradle.integtests.fixtures.executer.ParallelForkingGradleExecuter"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOrderSpecs . AnyOrderSpec ( Arrays . asList ( contraints )  )  ;", "}", "METHOD_END"], "methodName": ["any"], "fileName": "org.gradle.integtests.fixtures.executer.TaskOrderSpecs"}, {"methodBody": ["METHOD_START", "{", "List < Object >    flattenedConstraints    =    GUtil . flatten ( constraints ,    new   ArrayList < Object >  (  )  )  ;", "return   new    . ExactOrderSpec ( flattenedConstraints )  ;", "}", "METHOD_END"], "methodName": ["exact"], "fileName": "org.gradle.integtests.fixtures.executer.TaskOrderSpecs"}, {"methodBody": ["METHOD_START", "{", "Map < File ,    JvmInstallation >    installs    =    new   HashMap < File ,    JvmInstallation >  (  )  ;", "Collection < JvmInstallation >    jvms ;", "if    ( operatingSystem . isMacOsX (  )  )     {", "jvms    =    new   OsX ( TestFiles . execHandleFactory (  )  )  . findJvms (  )  ;", "} else", "if    ( operatingSystem . isWindows (  )  )     {", "jvms    =    new   WindowsOracleJvmLocator ( windowsRegistry ,    systemInfo )  . findJvms (  )  ;", "} else", "if    ( operatingSystem . isLinux (  )  )     {", "jvms    =    new   UbuntuJvmLocator ( fileCanonicalizer )  . findJvms (  )  ;", "} else    {", "jvms    =    Collections . emptySet (  )  ;", "}", "for    ( JvmInstallation   jvm    :    jvms )     {", "if    (  !  ( installs . containsKey ( jvm . getJavaHome (  )  )  )  )     {", "installs . put ( jvm . getJavaHome (  )  ,    jvm )  ;", "}", "}", "if    (  !  ( installs . containsKey ( currentJvm . getJavaHome (  )  )  )  )     {", "boolean   isJdk    =     (  ( currentJvm . getJre (  )  )     =  =    null )     |  |     (  !  ( currentJvm . getJre (  )  . getHomeDir (  )  . equals ( currentJvm . getJavaHome (  )  )  )  )  ;", "installs . put ( currentJvm . getJavaHome (  )  ,    new   JvmInstallation ( currentJvm . getJavaVersion (  )  ,    System . getProperty (  \" version \"  )  ,    currentJvm . getJavaHome (  )  ,    isJdk ,    toArch ( System . getProperty (  \" os . arch \"  )  )  )  )  ;", "}", "List < JvmInstallation >    result    =    new   ArrayList < JvmInstallation >  ( installs . values (  )  )  ;", "Collections . sort ( result ,    new   Comparator < JvmInstallation >  (  )     {", "public   int   compare ( JvmInstallation   o 1  ,    JvmInstallation   o 2  )     {", "return   o 2  . getVersion (  )  . compareTo ( o 1  . getVersion (  )  )  ;", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["findJvms"], "fileName": "org.gradle.integtests.fixtures.jvm.InstalledJvmLocator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( arch . equals (  \" amd 6  4  \"  )  )     |  |     ( arch . equals (  \" x 8  6  _  6  4  \"  )  )  )     {", "return   Jvmation . Arch . x 8  6  _  6  4  ;", "}", "if    ( arch . equals (  \" i 3  8  6  \"  )  )     {", "return   Jvmation . Arch . i 3  8  6  ;", "}", "return   Jvmation . Arch . Unknown ;", "}", "METHOD_END"], "methodName": ["toArch"], "fileName": "org.gradle.integtests.fixtures.jvm.InstalledJvmLocator"}, {"methodBody": ["METHOD_START", "{", "return   arch ;", "}", "METHOD_END"], "methodName": ["getArch"], "fileName": "org.gradle.integtests.fixtures.jvm.JvmInstallation"}, {"methodBody": ["METHOD_START", "{", "return   javaHome ;", "}", "METHOD_END"], "methodName": ["getJavaHome"], "fileName": "org.gradle.integtests.fixtures.jvm.JvmInstallation"}, {"methodBody": ["METHOD_START", "{", "return   javaVersion ;", "}", "METHOD_END"], "methodName": ["getJavaVersion"], "fileName": "org.gradle.integtests.fixtures.jvm.JvmInstallation"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.integtests.fixtures.jvm.JvmInstallation"}, {"methodBody": ["METHOD_START", "{", "return   jdk ;", "}", "METHOD_END"], "methodName": ["isJdk"], "fileName": "org.gradle.integtests.fixtures.jvm.JvmInstallation"}, {"methodBody": ["METHOD_START", "{", "try    {", "ExecHandleBuilder   execHandleBuilder    =    execHandleFactory . newExec (  )  ;", "execHandleBuilder . workingDir ( new   File (  \"  .  \"  )  . getAbsoluteFile (  )  )  ;", "execHandleBuilder . commandLine (  \"  / usr / libexec / java _ home \"  ,     \"  - V \"  )  ;", "ByteArrayOutputStream   outputStream    =    new   ByteArrayOutputStream (  )  ;", "execHandleBuilder . setErrorOutput ( outputStream )  ;", "execHandleBuilder . setStandardOutput ( new   ByteArrayOutputStream (  )  )  ;", "execHandleBuilder . build (  )  . start (  )  . waitForFinish (  )  . assertNormalExitValue (  )  ;", "return   new   OsXJavaHomeParser (  )  . parse ( new   InputStreamReader ( new   ByteArrayInputStream ( outputStream . toByteArray (  )  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException (  \" Could   not   locate   i   JVMs .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["findJvms"], "fileName": "org.gradle.integtests.fixtures.jvm.OsXInstalledJvmLocator"}, {"methodBody": ["METHOD_START", "{", "ArrayList < JvmInstallation >    result    =    new   ArrayList < JvmInstallation >  (  )  ;", "BufferedReader   reader    =    new   BufferedReader ( output )  ;", "for    ( String   line    =    reader . readLine (  )  ;    line    !  =    null ;    line    =    reader . readLine (  )  )     {", "Matcher   matcher    =     . NEW _ FORMAT _ PATTERN . matcher ( line )  ;", "if    ( matcher . matches (  )  )     {", "String   version    =    matcher . group (  1  )  ;", "String   arch    =    matcher . group (  2  )  ;", "String   javaHome    =    matcher . group (  3  )  ;", "result . add ( new   JvmInstallation ( JavaVersion . toVersion ( version )  ,    version ,    new   File ( javaHome )  ,    true ,    toArch ( arch )  )  )  ;", "} else    {", "matcher    =     . OLD _ FORMAT _ PATTERN . matcher ( line )  ;", "if    ( matcher . matches (  )  )     {", "String   version    =    matcher . group (  1  )  ;", "String   arch    =    matcher . group (  2  )  ;", "String   javaHome    =    matcher . group (  3  )  ;", "result . add ( new   JvmInstallation ( JavaVersion . toVersion ( version )  ,    version ,    new   File ( javaHome )  ,    true ,    toArch ( arch )  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.integtests.fixtures.jvm.OsXJavaHomeParser"}, {"methodBody": ["METHOD_START", "{", "if    ( arch . equals (  \" i 3  8  6  \"  )  )     {", "ren   JvmInstallation . Arch . i 3  8  6  ;", "} else", "if    ( arch . equals (  \" x 8  6  _  6  4  \"  )  )     {", "ren   JvmInstallation . Arch . x 8  6  _  6  4  ;", "}", "ren   JvmInstallation . Arch . Unknown ;", "}", "METHOD_END"], "methodName": ["toArch"], "fileName": "org.gradle.integtests.fixtures.jvm.OsXJavaHomeParser"}, {"methodBody": ["METHOD_START", "{", "List < JvmInstallation >    jvms    =    new   ArrayList < JvmInstallation >  (  )  ;", "if    ( libDir . isDirectory (  )  )     {", "for    ( File   javaHome    :    libDir . listFiles (  )  )     {", "Matcher   matcher    =     . JAVA _ HOME _ DIR _ PATTERN . matcher ( getName (  )  )  ;", "if    (  !  ( matcher . matches (  )  )  )     {", "continue ;", "}", "if    (  !  ( new   File ( javaHome ,     \" jre / bin / java \"  )  . isFile (  )  )  )     {", "continue ;", "}", "String   version    =    matcher . group (  1  )  ;", "String   arch    =    matcher . group (  2  )  ;", "boolean   jdk    =    new   File ( javaHome ,     \" bin / javac \"  )  . isFile (  )  ;", "jvms . add ( new   JvmInstallation ( JavaVersion . toVersion ( version )  ,    version ,    fileCanonicalizer . canonicalize ( javaHome )  ,    jdk ,    toArch ( arch )  )  )  ;", "}", "}", "return   jvms ;", "}", "METHOD_END"], "methodName": ["findJvms"], "fileName": "org.gradle.integtests.fixtures.jvm.UbuntuJvmLocator"}, {"methodBody": ["METHOD_START", "{", "if    ( arch . equals (  \" amd 6  4  \"  )  )     {", "ren   JvmInstallation . Arch . x 8  6  _  6  4  ;", "} else", "if    ( arch . equals (  \" i 3  8  6  \"  )  )     {", "ren   JvmInstallation . Arch . i 3  8  6  ;", "} else    {", "ren   JvmInstallation . Arch . Unknown ;", "}", "}", "METHOD_END"], "methodName": ["toArch"], "fileName": "org.gradle.integtests.fixtures.jvm.UbuntuJvmLocator"}, {"methodBody": ["METHOD_START", "{", "JvmInstallation . Arch   defaultArch    =     (  ( systemInfo . getArchitecture (  )  )     =  =     ( Architecture . i 3  8  6  )  )     ?    JvmInstallation . Arch . i 3  8  6     :    JvmInstallation . Arch . x 8  6  _  6  4  ;", "List < JvmInstallation >    jvms    =    new   ArrayList < JvmInstallation >  (  )  ;", "findJvms ( wRegistry ,     \" SOFTWARE \\  \\ JavaSoft \\  \\ Java   Development   Kit \"  ,    jvms ,    true ,    defaultArch )  ;", "findJvms ( wRegistry ,     \" SOFTWARE \\  \\ JavaSoft \\  \\ Java   Runtime   Environment \"  ,    jvms ,    false ,    defaultArch )  ;", "findJvms ( wRegistry ,     \" SOFTWARE \\  \\ Wow 6  4  3  2 Node \\  \\ JavaSoft \\  \\ Java   Development   Kit \"  ,    jvms ,    true ,    JvmInstallation . Arch . i 3  8  6  )  ;", "findJvms ( wRegistry ,     \" SOFTWARE \\  \\ Wow 6  4  3  2 Node \\  \\ JavaSoft \\  \\ Java   Runtime   Environment \"  ,    jvms ,    false ,    JvmInstallation . Arch . i 3  8  6  )  ;", "return   jvms ;", "}", "METHOD_END"], "methodName": ["findJvms"], "fileName": "org.gradle.integtests.fixtures.jvm.WindowsOracleJvmLocator"}, {"methodBody": ["METHOD_START", "{", "List < String >    versions ;", "try    {", "versions    =    wRegistry . getSubkeys ( HKEY _ LOCAL _ MACHINE ,    sdkSubkey )  ;", "}    catch    ( MissingRegistryEntryException   e )     {", "return ;", "}", "for    ( String   version    :    versions )     {", "if    ( version . matches (  \"  \\  \\ d +  \\  \\  .  \\  \\ d +  \"  )  )     {", "continue ;", "}", "String   javaHome    =    wRegistry . getStringValue ( HKEY _ LOCAL _ MACHINE ,     (  ( sdkSubkey    +     '  \\  \\  '  )     +    version )  ,     \" JavaHome \"  )  ;", "jvms . add ( new   JvmInstallation ( JavaVersion . toVersion ( version )  ,    version ,    new   File ( javaHome )  ,    jdk ,    arch )  )  ;", "}", "}", "METHOD_END"], "methodName": ["findJvms"], "fileName": "org.gradle.integtests.fixtures.jvm.WindowsOracleJvmLocator"}, {"methodBody": ["METHOD_START", "{", "return   strippedOutput ;", "}", "METHOD_END"], "methodName": ["getStrippedOutput"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "return   tasks . size (  )  ;", "}", "METHOD_END"], "methodName": ["getTaskCount"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "return   tasks . containsKey ( taskName )  ;", "}", "METHOD_END"], "methodName": ["hasTask"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "tasks    =    new   HashMap < String ,    GroupedTaskFixture >  (  )  ;", "String   strippedOutput    =    LogContent . of ( output )  . removeAnsiChars (  )  . withNormalizedEol (  )  ;", "Matcher   matcher    =     . TASK _ OUTPUT _ PATTERN . matcher ( strippedOutput )  ;", "while    ( matcher . find (  )  )     {", "String   taskName    =    matcher . group (  1  )  ;", "String   taskOutcome    =    matcher . group (  2  )  ;", "String   taskOutput    =    matcher . group (  3  )  . trim (  )  ;", "GroupedTaskFixture   task    =    tasks . get ( taskName )  ;", "if    ( task    =  =    null )     {", "task    =    new   GroupedTaskFixture ( taskName )  ;", "tasks . put ( taskName ,    task )  ;", "}", "task . addOutput ( taskOutput )  ;", "task . setOutcome ( taskOutcome )  ;", "}", "return   strippedOutput ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "boolean   foundTask    =    hasTask ( taskName )  ;", "if    (  ! foundTask )     {", "throw   new   AssertionError ( String . format (  \" The   g   output   for   task    '  % s '    could   not   be   found .  % nOutput :  % n % s \"  ,    taskName ,    originalOutput )  )  ;", "}", "return   tasks . get ( taskName )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "return   originalOutput ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedOutputFixture"}, {"methodBody": ["METHOD_START", "{", "outputs . add ( output )  ;", "}", "METHOD_END"], "methodName": ["addOutput"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedTaskFixture"}, {"methodBody": ["METHOD_START", "{", "return   taskName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedTaskFixture"}, {"methodBody": ["METHOD_START", "{", "return   taskOutcome ;", "}", "METHOD_END"], "methodName": ["getOutcome"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedTaskFixture"}, {"methodBody": ["METHOD_START", "{", "List < String >    nonEmptyOutputs    =    filter ( outputs ,    new   Spec < String >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( String   string )     {", "return    !  ( string . equals (  \"  \"  )  )  ;", "}", "}  )  ;", "return   join (  \"  \\ n \"  ,    nonEmptyOutputs )  ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedTaskFixture"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . taskOutcome )     !  =    null )     {", "throw   new   AssertionError (  (  ( taskName )     +     \"    task ' s   outcome   is   set   twice !  \"  )  )  ;", "}", "this . taskOutcome    =    taskOutcome ;", "}", "METHOD_END"], "methodName": ["setOutcome"], "fileName": "org.gradle.integtests.fixtures.logging.GroupedTaskFixture"}, {"methodBody": ["METHOD_START", "{", "URL   resource    =    classLoader . getResource ( resourceName )  ;", "if    ( resource    =  =    null )     {", "throw   new   RuntimeException (  (  (  (  (  (  \" Unable   to   find   the   released      information .  \\ n \"     +     \" The   resource    '  \"  )     +     ( resourceName )  )     +     \"  \\  '    was   not   found .  \\ n \"  )     +     \" Most   likely ,    you   haven \\  ' t   run   the    \\  ' prepareVersionsInfo \\  '    task .  \\ n \"  )     +     \" If   you   have   trouble   running   tests   from   your   IDE ,    please   run   gradlew   idea | eclipse   first .  \"  )  )  ;", "}", "try    {", "Properties   properties    =    new   Properties (  )  ;", "InputStream   stream    =    resource . openStream (  )  ;", "try    {", "properties . load ( stream )  ;", "}    finally    {", "stream . close (  )  ;", "}", "return   properties ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.integtests.fixtures.versions.ClasspathVersionSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( distributions )     =  =    null )     {", "distributions    =    CollectionUtils . collect ( getProperties (  )  . getProperty (  \" versions \"  )  . split (  \"  \\  \\ s +  \"  )  ,    new   Transformer < GradleDistribution ,    String >  (  )     {", "public   GradleDistribution   transform ( String   version )     {", "return   buildContext . distribution ( version )  ;", "}", "}  )  ;", "}", "return   distributions ;", "}", "METHOD_END"], "methodName": ["getAll"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "return   findFirst ( getAll (  )  ,    new   Spec < GradleDistribution >  (  )     {", "public   boolean   isSatisfiedBy ( GradleDistribution   element )     {", "return   element . getVersion (  )  . getVersion (  )  . equals ( gradleVersion )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDistribution"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "return   findFirst ( getAll (  )  ,    new   Spec < GradleDistribution >  (  )     {", "public   boolean   isSatisfiedBy ( GradleDistribution   element )     {", "return   element . getVersion (  )  . equals ( gradleVersion )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getDistribution"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "String   mostRecent    =    getProperties (  )  . getProperty (  \" mostRecent \"  )  ;", "if    ( mostRecent    =  =    null )     {", "throw   new   RuntimeException (  \" Unable   to   get   the   last   version \"  )  ;", "}", "return   buildContext . d ( mostRecent )  ;", "}", "METHOD_END"], "methodName": ["getMostRecentRelease"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "String   mostRecentSnapshot    =    getProperties (  )  . getProperty (  \" mostRecentSnapshot \"  )  ;", "if    ( mostRecentSnapshot    =  =    null )     {", "throw   new   RuntimeException (  \" Unable   to   get   the   last   snapshot   version \"  )  ;", "}", "return   buildContext . d ( mostRecentSnapshot )  ;", "}", "METHOD_END"], "methodName": ["getMostRecentReleaseSnapshot"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "GradleDistribution   distribution    =    getDistribution ( gradleVersion )  ;", "List < GradleDistribution >    sorted    =    sort ( distributions ,    new   Comparator < GradleDistribution >  (  )     {", "public   int   compare ( GradleDistribution   dist 1  ,    GradleDistribution   dist 2  )     {", "return   dist 1  . getVersion (  )  . compareTo ( dist 2  . getVersion (  )  )  ;", "}", "}  )  ;", "int   distributionIndex    =     ( sorted . indexOf ( distribution )  )     -     1  ;", "return   distributionIndex    >  =     0     ?    sorted . get ( distributionIndex )     :    null ;", "}", "METHOD_END"], "methodName": ["getPrevious"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( properties )     =  =    null )     {", "properties    =    Factory . create (  )  ;", "}", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "final   GradleVersion   firstSupported    =    GradleVersion . version (  \"  1  .  0  \"  )  ;", "return   CollectionUtils . filter ( getAll (  )  ,    new   Spec < Gradle >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( Gradle   element )     {", "return    ( element . getVersion (  )  . compareTo ( firstSupported )  )     >  =     0  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getSupported"], "fileName": "org.gradle.integtests.fixtures.versions.ReleasedVersionDistributions"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getSnapshotMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["getSnapshotMetaData"], "fileName": "org.gradle.test.fixtures.maven.DelegatingMavenModule"}, {"methodBody": ["METHOD_START", "{", "return    (  ( T )     ( this )  )  ;", "}", "METHOD_END"], "methodName": ["t"], "fileName": "org.gradle.test.fixtures.maven.DelegatingMavenModule"}, {"methodBody": ["METHOD_START", "{", "return   handler . addHandler ( new   ChainingHttpHandler . HandlerFactory < CyclicBarrierAnyOfRequestHandler >  (  )     {", "@ Override", "public   CyclicBarrierAnyOfRequestHandler   create ( WaitPrecondition   previous )     {", "return   new   CyclicBarrierAnyOfRequestHandler ( lock ,    serverId ,    timeoutMs ,    concurrent ,    previous ,    expectations )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addBlockingHandler"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   handler . addHandler ( new   ChainingHttpHandler . HandlerFactory < CyclicBarrierAnyOfRequestHandler >  (  )     {", "@ Override", "public   CyclicBarrierAnyOfRequestHandler   create ( WaitPrecondition   previous )     {", "return   new   CyclicBarrierAnyOfOptionalRequestHandler ( lock ,    serverId ,    timeoutMs ,    concurrent ,    previous ,    expectations )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addBlockingOptionalHandler"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "handler . addHandler ( new   ChainingHttpHandler . HandlerFactory (  )     {", "@ Override", "public   TraHandler   create ( WaitPrecondition   previous )     {", "return   new   CyclicBarrierRequestHandler ( lock ,    timeoutMs ,    previous ,    expectations )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addNonBlockingHandler"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    uri ( resource )  ;", "return    (  (  (  \" System . out . println (  \\  \" calling    \"     +    uri )     +     \"  \\  \"  )  ;    try    {    new   URL (  \\  \"  \"  )     +    uri )     +     \"  \\  \"  )  . openConnection (  )  . getContentLength (  )  ;     }    catch ( Exception   e )     {    throw   new   RuntimeException ( e )  ;     }  ;    System . out . println (  \\  \"  [ G ]    response   received \\  \"  )  ;  \"  ;", "}", "METHOD_END"], "methodName": ["callFromBuild"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "String   uriExpression    =     (  (  \"  \\  \"  \"     +     ( getUri (  )  )  )     +     \"  /  \\  \"     +     \"  )     +    expression ;", "return    (  (  (  \" System . out . println (  \\  \" calling    \\  \"     +     \"     +    uriExpression )     +     \"  )  ;    try    {    new   URL (  \"  )     +    uriExpression )     +     \"  )  . openConnection (  )  . getContentLength (  )  ;     }    catch ( Exception   e )     {    throw   new   RuntimeException ( e )  ;     }  ;    System . out . println (  \\  \"  [ G ]    response   received \\  \"  )  ;  \"  ;", "}", "METHOD_END"], "methodName": ["callFromBuildUsingExpression"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "addNonBlockingHandler ( Collections . singleton ( new   ExpectGetAndSendFixedContent ( expectedCall )  )  )  ;", "}", "METHOD_END"], "methodName": ["expect"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "addNonBlockingHandler ( Collections . singleton (  (  ( ResourceExpectation )     ( expectedRequest )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["expect"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   addBlockingHandler (  1  ,    Collections . singleton ( new   ExpectGetAndSendFixedContent ( expectedCall )  )  )  ;", "}", "METHOD_END"], "methodName": ["expectAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   addBlockingHandler (  1  ,    Collections . singleton (  (  ( ResourceExpectation )     ( expectedRequest )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["expectAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    ( String   call    :    expectedRequests )     {", "expectations . add ( new   ExpectGetAndSendFixedContent ( call )  )  ;", "}", "addNonandler ( expectations )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrent"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    ( String   call    :    expectedRequests )     {", "expectations . add ( new   ExpectGetAndSendFixedContent ( call )  )  ;", "}", "addNonandler ( expectations )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrent"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    (  . ExpectedRequest   call    :    expectedCalls )     {", "expectations . add (  (  ( ResourceExpectation )     ( call )  )  )  ;", "}", "addNonBlockingHandler ( expectations )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrent"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    ( String   call    :    expectedCalls )     {", "expectations . add ( new   ExpectGetAndSendFixedContent ( call )  )  ;", "}", "return   addandler ( concurrent ,    expectations )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrentAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    (  . ExpectedRequest   request    :    expectedRequests )     {", "expectations . add (  (  ( ResourceExpectation )     ( request )  )  )  ;", "}", "return   addBlockingHandler ( concurrent ,    expectations )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrentAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   expectConcurrentAndBlock ( expectedCalls . length ,    expectedCalls )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrentAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   expectConcurrentAndBlock ( expectedRequests . length ,    expectedRequests )  ;", "}", "METHOD_END"], "methodName": ["expectConcurrentAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "List < ResourceExpectation >    expectations    =    new   ArrayList < ResourceExpectation >  (  )  ;", "for    ( String   call    :    optionalExpectedCalls )     {", "expectations . add ( new   ExpectGetAndSendFixedContent ( call )  )  ;", "}", "return   addOptionalHandler ( concurrent ,    expectations )  ;", "}", "METHOD_END"], "methodName": ["expectOptionalAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectMethodAndRunAction (  \" GET \"  ,    path ,    new   ErroringAction < HttpExchange >  (  )     {", "@ Override", "protected   void   doExecute ( HttpExchange   httpExchange )    throws   Exception    {", "httpExchange . sendResponseHeaders (  2  0  0  ,    file . length (  )  )  ;", "Files . copy ( file ,    httpExchange . getResponseBody (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectMethodAndRunAction (  \" GET \"  ,    path ,    action )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( running )  )     {", "throw   new   IllegalStateException (  \" Cannot   get   HTTP   port   as   is   not   running .  \"  )  ;", "}", "return   getAddress (  )  . getPort (  )  ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URI (  (  \"  :  /  / localhost :  \"     +     ( getPort (  )  )  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectHead ( path )  ;", "}", "METHOD_END"], "methodName": ["head"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectMethodAndRunAction (  \" GET \"  ,    path ,    new   ErroringAction < HttpExchange >  (  )     {", "@ Override", "protected   void   doExecute ( HttpExchange   httpExchange )    throws   Exception    {", "httpExchange . sendResponseHeaders (  4  0  4  ,     0  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["missing"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectMethodAndRunAction (  \" POST \"  ,    path ,    action )  ;", "}", "METHOD_END"], "methodName": ["post"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectMethodAndRunAction (  \" PUT \"  ,    path ,    new   BlockingHttpServer . SendEmptyResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectGetAndSendFixedContent ( path )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   new   ExpectGetAndSendFixedContent ( path ,    content )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( content . length )     <     1  0  2  4  )     {", "throw   new   IllegalArgumentException (  \" Content   is   too   short .  \"  )  ;", "}", "return   new   SendPartialResponseThen ( lock ,    timeoutMs ,    path ,    content )  ;", "}", "METHOD_END"], "methodName": ["sendSomeAndBlock"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "server . start (  )  ;", "running    =    true ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "handler . assertComplete (  )  ;", "running    =    false ;", ". EXECUTOR _ SERVICE . execute ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "server . stop (  1  0  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URI (  \"  \"  ,    null ,     \" localhost \"  ,    getPort (  )  ,     (  \"  /  \"     +    resource )  ,    null ,    null )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "handler . waitForRequests ( requestCount )  ;", "}", "METHOD_END"], "methodName": ["waitForRequests"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "context . setAuthenticator ( new   BasicAuthenticator (  \" get \"  )     {", "@ Override", "public   boolean   checkCredentials ( String   u ,    String   pwd )     {", "return    ( u . equals ( username )  )     &  &     ( password . equals ( pwd )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["withBasicAuthentication"], "fileName": "org.gradle.test.fixtures.server.http.BlockingHttpServer"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "T   h    =    factory . create ( last )  ;", "hs . add ( h )  ;", "last    =    h . getWaitPrecondition (  )  ;", "return   h ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addHandler"], "fileName": "org.gradle.test.fixtures.server.http.ChainingHttpHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  !  ( completed )  )     {", "for    ( Track   handler    :    handlers )     {", "try    {", "handler . assertComplete (  )  ;", "}    catch    ( Throwable   t )     {", "failures . add ( t )  ;", "}", "}", "completed    =    true ;", "}", "if    (  !  ( failures . isEmpty (  )  )  )     {", "throw   new   DefaultMultiCauseException (  \" Failed   to   handle   all   HTTP   requests .  \"  ,    failures )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertComplete"], "fileName": "org.gradle.test.fixtures.server.http.ChainingHttpHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "( requestCount )  +  +  ;", "condition . signalAll (  )  ;", "if    ( completed )     {", "System . out . println ( String . format (  \"  [  % d ]    received   request    % s    % s   after   HTTP   server   has   stopped .  \"  ,    id ,    httpExchange . getRequestMethod (  )  ,    httpExchange . getRequestURI (  )  )  )  ;", "return   null ;", "}", "for    ( Track   handler    :    handlers )     {", "ResourceHandler   resourceHandler    =    handler . handle ( id ,    httpExchange )  ;", "if    ( resourceHandler    !  =    null )     {", "return   resourceHandler ;", "}", "}", "System . out . println ( String . format (  \"  [  % d ]    unexpected   request    % s    % s \"  ,    id ,    httpExchange . getRequestMethod (  )  ,    httpExchange . getRequestURI (  )  )  )  ;", "failures . add ( new   AssertionError ( String . format (  \" Received   unexpected   request    % s    % s \"  ,    httpExchange . getRequestMethod (  )  ,    httpExchange . getRequestURI (  )  . getPath (  )  )  )  )  ;", "}    catch    ( Throwable   t )     {", "System . out . println ( String . format (  \"  [  % d ]    error   during   handling   of   request    % s    % s \"  ,    id ,    httpExchange . getRequestMethod (  )  ,    httpExchange . getRequestURI (  )  )  )  ;", "failures . add ( new   AssertionError ( String . format (  \" Failed   to   handle    % s    % s \"  ,    httpExchange . getRequestMethod (  )  ,    httpExchange . getRequestURI (  )  . getPath (  )  )  ,    t )  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectHandler"], "fileName": "org.gradle.test.fixtures.server.http.ChainingHttpHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  ( this . requCount )     <    requCount )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForRequests"], "fileName": "org.gradle.test.fixtures.server.http.ChainingHttpHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( failure )     !  =    null )     {", "throw   failure ;", "}", "if    (  !  ( expected . isEmpty (  )  )  )     {", "throw   new   AssertionError ( String . format (  \" Did   not   handle   all   expected   rs .    Waiting   for    % d   further   rs ,    received    % s ,    released    % s ,    not   yet   received    % s .  \"  ,    waitingFor ,    received ,    released ,    expected . keySet (  )  )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertComplete"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierAnyOfRequestHandler"}, {"methodBody": ["METHOD_START", "{", "waitingFor    =    Math . min ( expected . size (  )  ,     (  ( waitingFor )     +    count )  )  ;", "System . out . println ( String . format (  \"  [  % d ]    now   expecting    % d   further   rs ,    received    % s ,    released    % s ,    not   yet   received    % s \"  ,    testId ,    waitingFor ,    received ,    released ,    expected . keySet (  )  )  )  ;", "condition . signalAll (  )  ;", "}", "METHOD_END"], "methodName": ["doRelease"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierAnyOfRequestHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "int   count    =     0  ;", "for    ( String   path    :    received )     {", "if    (  !  ( released . contains ( path )  )  )     {", "System . out . println ( String . format (  \"  [  % d ]    releasing    % s \"  ,    Id ,    path )  )  ;", "released . add ( path )  ;", "all . get ( path )  . released (  )  ;", "count +  +  ;", "}", "}", "doRelease ( count )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doReleaseAll"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierAnyOfRequestHandler"}, {"methodBody": ["METHOD_START", "{", "failure    =    new   AssertionError ( String . format (  \" Timeout   waiting   for   expected   requests .    Waiting   for    % d   further   requests ,    received    % s ,    released    % s ,    not   yet   received    % s .  \"  ,    waitingFor ,    received ,    released ,    expected . keySet (  )  )  )  ;", "condition . signalAll (  )  ;", "throw   failure ;", "}", "METHOD_END"], "methodName": ["timeoutWaitingForRequests"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierAnyOfRequestHandler"}, {"methodBody": ["METHOD_START", "{", "int   port    =    ocket . socket (  )  . getLocalPort (  )  ;", "if    ( port    <  =     0  )     {", "throw   new   IllegalStateException ( String . format (  \" Unexpected   port    % s   for   HTTP    \"  ,    port )  )  ;", "}", "try    {", "return   new   URI ( String . format (  \" http :  /  / localhost :  % s \"  ,    port )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "return    ( System . nanoTime (  )  )     /     1  0  0  0  0  0  0 L ;", "}", "METHOD_END"], "methodName": ["monotonicClockMillis"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "if    ( OperatingSystem . current (  )  . isWindows (  )  )     {", "try    {", "Thread . sleep (  2  0  0  0 L )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "synchronized ( lock )     {", "released    =    true ;", "lock . notifyAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["release"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "try    {", "Socket    =    ServerSocketChannel . open (  )  ;", "Socket . socket (  )  . bind ( new   InetSocketAddress (  0  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "executor    =    Executors . newCachedThreadPool (  )  ;", "executor . execute ( new   Runnable (  )     {", "public   void   run (  )     {", "int   i    =     0  ;", "while    ( true )     {", "try    {", "SocketChannel   connection ;", "try    {", "connection    =    Socket . accept (  )  ;", "}    catch    ( AsynchronousCloseException   e )     {", "return ;", "}    catch    ( ClosedChannelException   e )     {", "return ;", "}", "try    {", "OutputStream   outputStream    =    Channels . newOutputStream ( connection )  ;", "System . out . println (  (  \" Handle   connection   request   no .  \"     +     (  +  + i )  )  )  ;", "handleConnection ( outputStream )  ;", "outputStream . flush (  )  ;", "}    finally    {", "connection . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "}", "private   void   handleConnection ( OutputStream   outputStream )    throws   IOException    {", "System . out . println (  \" Handling   HTTP   request \"  )  ;", "synchronized ( lock )     {", "if    ( connected )     {", "System . out . println (  \" Received   unexpected   connection .  \"  )  ;", "outputStream . write (  \" HTTP /  1  .  1     5  0  0    Received   an   unexpected   connection .  \\ r \\ nConnection :    close \\ r \\ nContent - length :     0  \\ r \\ n \\ r \\ n \"  . getBytes (  )  )  ;", "return ;", "}", "System . out . println (  \" Connection   received \"  )  ;", "connected    =    true ;", "lock . notifyAll (  )  ;", "long   expiry    =     ( monotonicClockMillis (  )  )     +     3  0  0  0  0  ;", "while    (  (  !  ( released )  )     &  &     (  !  ( stopped )  )  )     {", "long   delay    =    expiry    -     ( monotonicClockMillis (  )  )  ;", "if    ( delay    <  =     0  )     {", "System . out . println (  \" Timeout   waiting   for   client   to   be   released .  \"  )  ;", "outputStream . write (  \" HTTP /  1  .  1     5  0  0    Timeout   waiting   for   client   to   be   released .  \\ r \\ nConnection :    close \\ r \\ nContent - length :     0  \\ r \\ n \\ r \\ n \"  . getBytes (  )  )  ;", "return ;", "}", "try    {", "lock . wait ( delay )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "if    ( stopped )     {", "System . out . println (  \" Releasing   client   on   stop .  \"  )  ;", "outputStream . write (  \" HTTP /  1  .  1     5  0  0    Server   stopped .  \\ r \\ nConnection :    close \\ r \\ nContent - length :     0  \\ r \\ n \\ r \\ n \"  . getBytes (  )  )  ;", "return ;", "}", "connected    =    false ;", "released    =    false ;", "lock . notifyAll (  )  ;", "}", "System . out . println (  \" Sending   response   to   client \"  )  ;", "outputStream . write (  \" HTTP /  1  .  1     2  0  0    Ok .  \\ r \\ nConnection :    close \\ r \\ nContent - length :     0  \\ r \\ n \\ r \\ n \"  . getBytes (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  \" Stopping   server \"  )  ;", "synchronized ( lock )     {", "stopped    =    true ;", "lock . notifyAll (  )  ;", "}", "try    {", "serverSocket . close (  )  ;", "executor . shutdown (  )  ;", "executor . awaitTermination (  3  0  ,    TimeUnit . SECONDS )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "sync (  2  0  )  ;", "}", "METHOD_END"], "methodName": ["sync"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "waitF ( timeoutSeconds )  ;", "release (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sync"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   waitFor ( true ,     2  0  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   waitFor ( failAtTimeout ,     2  0  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "long   expiry    =     ( monotonicClockMillis (  )  )     +     ( timeoutSeconds    *     1  0  0  0  )  ;", "synchronized ( lock )     {", "while    (  (  !  ( connected )  )     &  &     (  !  ( stopped )  )  )     {", "long   delay    =    expiry    -     ( monotonicClockMillis (  )  )  ;", "if    ( delay    <  =     0  )     {", "String   message    =    String . format (  \" Timeout   waiting   for   client   to   connect   to    % s .  \"  ,    getUri (  )  )  ;", "if    ( failAtTimeout )     {", "throw   new   AssertionFailedError ( message )  ;", "} else    {", "System . out . println ( message )  ;", "return   false ;", "}", "}", "System . out . println (  \" waiting   for   client   to   connect \"  )  ;", "try    {", "lock . wait ( delay )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "if    ( stopped )     {", "throw   new   AssertionFailedError ( String . format (  \"    was   stopped   while   waiting   for   client   to   connect   to    % s .  \"  ,    getUri (  )  )  )  ;", "}", "System . out . println (  \" client   connected    -    unblocking \"  )  ;", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "return   waitFor ( true ,    timeoutSeconds )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierHttpServer"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( failure )     !  =    null )     {", "throw   failure ;", "}", "if    (  !  ( pending . isEmpty (  )  )  )     {", "throw   new   AssertionError ( String . format (  \" Did   not   receive   expected   rs .    Waiting   for    % s ,    received    % s \"  ,    pending . keySet (  )  ,    received )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertComplete"], "fileName": "org.gradle.test.fixtures.server.http.CyclicBarrierRequestHandler"}, {"methodBody": ["METHOD_START", "{", "return   artifact ( Collections .  < String ,    Object > emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["artifact"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . artifact ( options )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["artifact"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . assertIvyAndJarFilePublished (  )  ;", "}", "METHOD_END"], "methodName": ["assertIvyAndJarFilePublished"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . configuration ( Collections .  < String ,    Object > emptyMap (  )  ,    name )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["configuration"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . configuration ( options ,    name )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["configuration"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . dependsOn ( organisation ,    module ,    revision )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["dependsOn"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . dependsOn ( attributes )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["dependsOn"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . extendsFrom ( attributes )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["extendsFrom"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getIvyFile (  )  ;", "}", "METHOD_END"], "methodName": ["getIvyFile"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getJarFile (  )  ;", "}", "METHOD_END"], "methodName": ["getJarFile"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getModule (  )  ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getOrganisation (  )  ;", "}", "METHOD_END"], "methodName": ["getOrganisation"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getParsedIvy (  )  ;", "}", "METHOD_END"], "methodName": ["getParsedIvy"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   backingModule . getRevision (  )  ;", "}", "METHOD_END"], "methodName": ["getRevision"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . publish (  )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["publish"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . publishWithChangedContent (  )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["publishWithChangedContent"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( this )  ;", "}", "METHOD_END"], "methodName": ["t"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . undeclaredArtifact ( Collections .  < String ,    Object > emptyMap (  )  )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["undeclaredArtifact"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . undeclaredArtifact ( options )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["undeclaredArtifact"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . variant ( variant ,    attributes )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["variant"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . withNoMetaData (  )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["withNoMetaData"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . withStatus ( status )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["withStatus"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "backingModule . withXml ( action )  ;", "return   t (  )  ;", "}", "METHOD_END"], "methodName": ["withXml"], "fileName": "org.gradle.test.fixtures.server.http.DelegatingIvyModule"}, {"methodBody": ["METHOD_START", "{", "if    ( path . startsWith (  \"  /  \"  )  )     {", "ren   path . substring (  1  )  ;", "}", "ren   path ;", "}", "METHOD_END"], "methodName": ["removeLeadingSlash"], "fileName": "org.gradle.test.fixtures.server.http.ExpectGetAndSendFixedContent"}, {"methodBody": ["METHOD_START", "{", "if    ( path . startsWith (  \"  /  \"  )  )     {", "ren   path . substring (  1  )  ;", "}", "ren   path ;", "}", "METHOD_END"], "methodName": ["removeLeadingSlash"], "fileName": "org.gradle.test.fixtures.server.http.ExpectMethodAndRunAction"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "arted    =    true ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["released"], "fileName": "org.gradle.test.fixtures.server.http.ResourceHandlerWrapper"}, {"methodBody": ["METHOD_START", "{", "description . appendValue ( expectedUserAgentString (  )  )  ;", "}", "METHOD_END"], "methodName": ["describeTo"], "fileName": "org.gradle.test.matchers.UserAgentMatcher"}, {"methodBody": ["METHOD_START", "{", "String   javaVendor    =    System . getProperty (  \" vendor \"  )  ;", "String   javaVion    =    System . getProperty (  \" vion \"  )  ;", "String   javaVendorVion    =    System . getProperty (  \" vion \"  )  ;", "String   osName    =    System . getProperty (  \" os . name \"  )  ;", "String   osVion    =    System . getProperty (  \" os . vion \"  )  ;", "String   osArch    =    System . getProperty (  \" os . arch \"  )  ;", "return   String . format (  \"  % s /  % s    (  % s ;  % s ;  % s )     (  % s ;  % s ;  % s )  \"  ,    applicationName ,    vion ,    osName ,    osVion ,    osArch ,    javaVendor ,    javaVion ,    javaVendorVion )  ;", "}", "METHOD_END"], "methodName": ["expectedUserAgentString"], "fileName": "org.gradle.test.matchers.UserAgentMatcher"}, {"methodBody": ["METHOD_START", "{", "String   testString    =    expectedUserAgentString (  )  ;", "return   Matchers . equalTo ( testString )  . matches ( o )  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.gradle.test.matchers.UserAgentMatcher"}, {"methodBody": ["METHOD_START", "{", "return   new   UserAgentMatcher ( applicationName ,    version )  ;", "}", "METHOD_END"], "methodName": ["matchesNameAndVersion"], "fileName": "org.gradle.test.matchers.UserAgentMatcher"}]