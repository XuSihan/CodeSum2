[{"methodBody": ["METHOD_START", "{", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . file ( projectReportDirName )  ;", "}", "METHOD_END"], "methodName": ["getProjectReportDir"], "fileName": "org.gradle.api.plugins.ProjectReportsPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   projectReportDirName ;", "}", "METHOD_END"], "methodName": ["getProjectReportDirName"], "fileName": "org.gradle.api.plugins.ProjectReportsPluginConvention"}, {"methodBody": ["METHOD_START", "{", "return   WrapUtil . toSet ( project )  ;", "}", "METHOD_END"], "methodName": ["getProjects"], "fileName": "org.gradle.api.plugins.ProjectReportsPluginConvention"}, {"methodBody": ["METHOD_START", "{", "this . projectReportDirName    =    projectReportDirName ;", "}", "METHOD_END"], "methodName": ["setProjectReportDirName"], "fileName": "org.gradle.api.plugins.ProjectReportsPluginConvention"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getBinaryRenderer"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getModelRegistry"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "return   getModelRegistry (  )  . find ( path ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["modelElement"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "return   getModelRegistry (  )  . find ( path ,    modelType )  ;", "}", "METHOD_END"], "methodName": ["modelElement"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    getProject (  )  ;", "StyledTextOutput   textOutput    =    getTextOutputFactory (  )  . create (  . class )  ;", "Renderer   renderer    =    new   Renderer ( getFileResolver (  )  ,    getBinaryRenderer (  )  )  ;", "renderer . setOutput ( textOutput )  ;", "renderer . startProject ( project )  ;", "Collection < ComponentSpec >    components    =    new   ArrayList < ComponentSpec >  (  )  ;", "ComponentSpecContainer   componentSpecs    =    modelElement (  \" components \"  ,    ComponentSpecContainer . class )  ;", "if    ( componentSpecs    !  =    null )     {", "components . addAll ( componentSpecs . values (  )  )  ;", "}", "ModelMap < ComponentSpec >    testSuites    =    modelElement (  \" testSuites \"  ,    modelMap ( ComponentSpec . class )  )  ;", "if    ( testSuites    !  =    null )     {", "components . addAll ( testSuites . values (  )  )  ;", "}", "renderer . renderComponents ( components )  ;", "ProjectSourceSet   sourceSets    =    modelElement (  \" sources \"  ,    ProjectSourceSet . class )  ;", "if    ( sourceSets    !  =    null )     {", "renderer . renderSourceSets ( sourceSets )  ;", "}", "BinaryContainer   binaries    =    modelElement (  \" binaries \"  ,    BinaryContainer . class )  ;", "if    ( binaries    !  =    null )     {", "renderer . renderBinaries ( binaries . values (  )  )  ;", "}", "renderer . completeProject ( project )  ;", "renderer . complete (  )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "org.gradle.api.reporting.components.ComponentReport"}, {"methodBody": ["METHOD_START", "{", "BinaryBuildAbility   buildAbility    =     (  ( BinarySpecInternal )     ( binary )  )  . getBuildAbility (  )  ;", "if    (  !  ( buildAbility . isBuildable (  )  )  )     {", "TreeFormatter   formatter    =    new   TreeFormatter (  )  ;", "buildAbility . explain ( formatter )  ;", "builder . item ( formatter . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderBuildAbility"], "fileName": "org.gradle.api.reporting.components.internal.AbstractBinaryRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( BinarySpecInternal )     ( binary )  )  . isLegacyBinary (  )  )     {", "return ;", "}", "ModelMap < LanguageSourceSet >    sources    =    binary . getSources (  )  ;", "if    (  !  ( sources . isEmpty (  )  )  )     {", "SourceSet   sourceSet    =    new   SourceSet (  )  ;", "builder . collection (  \" source   sets \"  ,    sources . values (  )  ,    sourceSet ,     \" source   sets \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderOwnedSourceSets"], "fileName": "org.gradle.api.reporting.components.internal.AbstractBinaryRenderer"}, {"methodBody": ["METHOD_START", "{", "ModelSchema <  ?  >    schema    =    schemaStore . getSchema (  (  ( BinarySpecInternal )     ( binary )  )  . getPublicType (  )  )  ;", "if    (  !  ( schema   instanceof   StructSchema )  )     {", "return ;", "}", "Map < String ,    Object >    variants    =    Maps . newTreeMap (  )  ;", "VariantAspect   variantAspect    =     (  ( StructSchema <  ?  >  )     ( schema )  )  . getAspect ( VariantAspect . class )  ;", "if    ( variantAspect    !  =    null )     {", "for    ( ModelProperty <  ?  >    property    :    variantAspect . getDimensions (  )  )     {", "variants . put ( property . getName (  )  ,    property . getPropertyValue ( binary )  )  ;", "}", "}", "for    ( Map . Entry < String ,    Object >    variant    :    variants . entrySet (  )  )     {", "String   variantName    =    GUtil . toWords ( variant . getKey (  )  )  ;", "builder . item ( variantName ,    Utils . displayValueOf ( variant . getValue (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderVariants"], "fileName": "org.gradle.api.reporting.components.internal.AbstractBinaryRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < BinarySpec >    result    =    Sets . newTreeSet ( TypeAwareBinaryRenderer . SORT _ ORDER )  ;", "result . addAll ( binaries )  ;", "result . removeAll ( binaryRenderer . getItems (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["collectAdditionalBinaries"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < LanguageSourceSet >    result    =    Sets . newTreeSet ( SourceSetRenderer . SORT _ ORDER )  ;", "result . addAll ( sourceSets )  ;", "result . removeAll ( sourceSetRenderer . getItems (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["collectAdditionalSourceSets"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( items . isEmpty (  )  )  )     {", "getBuilder (  )  . getOutput (  )  . println (  )  ;", "getBuilder (  )  . collection ( title ,    items ,    r ,    elementsPlural )  ;", "}", "}", "METHOD_END"], "methodName": ["outputCollection"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < BinarySpec >    additionalBinaries    =    collectAdditionalBinaries ( binaries )  ;", "outputCollection ( additionalBinaries ,     \" Additional   binaries \"  ,    binary ,     \" binaries \"  )  ;", "}", "METHOD_END"], "methodName": ["renderBinaries"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( components . isEmpty (  )  )     {", "getTextOutput (  )  . withStyle ( Info )  . println (  \" No   components   defined   for   this   project .  \"  )  ;", "return ;", "}", "boolean   seen    =    false ;", "for    ( ComponentSpec   component    :    components )     {", "if    ( seen )     {", "getBuilder (  )  . getOutput (  )  . println (  )  ;", "} else    {", "seen    =    true ;", "}", "getBuilder (  )  . item ( component ,    componentRenderer )  ;", "}", "}", "METHOD_END"], "methodName": ["renderComponents"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < LanguageSourceSet >    additionalSourceSets    =    collectAdditionalSourceSets ( sourceSets )  ;", "outputCollection ( additionalSourceSets ,     \" Additional   source   sets \"  ,    sourceSe ,     \" source   sets \"  )  ;", "}", "METHOD_END"], "methodName": ["renderSourceSets"], "fileName": "org.gradle.api.reporting.components.internal.ComponentReportRenderer"}, {"methodBody": ["METHOD_START", "{", "Strresult    =    null ;", "if    ( value    !  =    null )     {", "boolean   hasCustomToStr", "try    {", "Method   toStr =    value . getClass (  )  . getMethod (  \" toStr )  ;", "hasCustomToStr =     !  ( toStrgetDeclarlass (  )  . equals ( Object . class )  )  ;", "}    catch    ( NoSuchMethodException   ignore )     {", "hasCustomToStr =    false ;", "}", "if    (  (  ! hasCustomToStr    &  &     ( Named . class . isAssignableFrom ( value . getClass (  )  )  )  )     {", "result    =     (  ( Named )     ( value )  )  . getName (  )  ;", "} else    {", "result    =    value . toStr )  ;", "}", "}", "if    ( result    =  =    null )     {", "result    =     \" null \"  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["displayValueOf"], "fileName": "org.gradle.api.reporting.components.internal.RendererUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( sourceSet   instanceof   DependentSourceSet )     {", "DependencySpecContainer   dependencies    =     (  ( DependentSourceSet )     ( sourceSet )  )  . getDependencies (  )  ;", "if    (  !  ( dependencies . isEmpty (  )  )  )     {", "builder . collection (  \" dependencies \"  ,    dependencies . getDependencies (  )  ,    new   reporting . ReportRenderer < DependencySpec ,    TextReportBuilder >  (  )     {", "@ Override", "public   void   render ( DependencySpec   model ,    TextReportBuilder   output )    throws   IOException    {", "if    ( model   instanceof   ProjectDependencySpec )     {", "output . item ( model . getDisplayName (  )  )  ;", "}", "}", "}  ,     \" dependencies \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderSourceSetDependencies"], "fileName": "org.gradle.api.reporting.components.internal.SourceSetRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < File >    srcDirs    =    sourceSet . getSource (  )  . getSrcDirs (  )  ;", "if    ( srcDirs . isEmpty (  )  )     {", "builder . item (  \" No   source   directories \"  )  ;", "} else    {", "for    ( File   file    :    srcDirs )     {", "builder . item (  \" srcDir \"  ,    file )  ;", "}", "SourceDirectorySet   source    =    sourceSet . getSource (  )  ;", "Set < String >    includes    =    source . getIncludes (  )  ;", "if    (  !  ( includes . isEmpty (  )  )  )     {", "builder . item (  \" includes \"  ,    includes )  ;", "}", "Set < String >    excludes    =    source . getExcludes (  )  ;", "if    (  !  ( excludes . isEmpty (  )  )  )     {", "builder . item (  \" excludes \"  ,    excludes )  ;", "}", "Set < String >    filterIncludes    =    source . getFilter (  )  . getIncludes (  )  ;", "if    (  !  ( filterIncludes . isEmpty (  )  )  )     {", "builder . item (  \" limit   to \"  ,    filterIncludes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["renderSourceSetDirectories"], "fileName": "org.gradle.api.reporting.components.internal.SourceSetRenderer"}, {"methodBody": ["METHOD_START", "{", "return   items ;", "}", "METHOD_END"], "methodName": ["getItems"], "fileName": "org.gradle.api.reporting.components.internal.TrackingReportRenderer"}, {"methodBody": ["METHOD_START", "{", "ReportRenderer < BinarySpec ,    TextReportBuilder >    renderer    =    renderers . get ( type )  ;", "if    ( renderer    =  =    null )     {", "Class <  ?  >    bestType    =    null ;", "for    ( Map . Entry < Class <  ?  >  ,    ReportRenderer < BinarySpec ,    TextReportBuilder >  >    entry    :    renderers . entrySet (  )  )     {", "if    (  !  ( entry . getKey (  )  . isAssignableFrom ( type )  )  )     {", "continue ;", "}", "if    (  ( bestType    =  =    null )     |  |     ( bestType . isAssignableFrom ( entry . getKey (  )  )  )  )     {", "bestType    =    entry . getKey (  )  ;", "renderer    =    entry . getValue (  )  ;", "}", "}", "renderers . put ( type ,    renderer )  ;", "}", "return   renderer ;", "}", "METHOD_END"], "methodName": ["getRendererForType"], "fileName": "org.gradle.api.reporting.components.internal.TypeAwareBinaryRenderer"}, {"methodBody": ["METHOD_START", "{", "renderers . put ( renderer . getTargetType (  )  ,    renderer )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.api.reporting.components.internal.TypeAwareBinaryRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( reports . getHtml (  )  . isEnabled (  )  )  )     {", "setDidWork ( false )  ;", "return ;", "}", "er   reporter    =    new   er ( getVersionSelectorScheme (  )  ,    getVersionComparator (  )  )  ;", "reporter . render ( getProjects (  )  ,    reports . getHtml (  )  . getDestination (  )  )  ;", "getProject (  )  . getLogger (  )  . lifecycle (  \" See   the   report   at :     {  }  \"  ,    new   ConsoleRenderer (  )  . asClickableFileUrl ( reports . getHtml (  )  . getEntryPoint (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getObjectFactory"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "return   projects ;", "}", "METHOD_END"], "methodName": ["getProjects"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getVersionComparator"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getVersionSelectorScheme"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "this . projects    =    projects ;", "}", "METHOD_END"], "methodName": ["setProjects"], "fileName": "org.gradle.api.reporting.dependencies.HtmlDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "String   json    =    renderer . render ( project )  ;", "String   content    =     (  \" var   project    =     \"     +    json )     +     \"  ;  \"  ;", "GFileUtils . writeFile ( content ,    new   File ( outputDirectory ,    fileName )  ,     \" utf -  8  \"  )  ;", "}", "METHOD_END"], "methodName": ["generateJsFile"], "fileName": "org.gradle.api.reporting.dependencies.internal.HtmlDependencyReporter"}, {"methodBody": ["METHOD_START", "{", "return   new   Transformer < String ,    Project >  (  )     {", "public   String   transform ( Project   project )     {", "return   toFileName ( project ,     (  \"  .  \"     +    extension )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["projectNamingScheme"], "fileName": "org.gradle.api.reporting.dependencies.internal.HtmlDependencyReporter"}, {"methodBody": ["METHOD_START", "{", "String   name    =    project . getPath (  )  ;", "if    ( name . equals (  \"  :  \"  )  )     {", "return    \" root \"     +    extension ;", "}", "return    (  \" root \"     +     ( namelace (  \"  :  \"  ,     \"  .  \"  )  )  )     +    extension ;", "}", "METHOD_END"], "methodName": ["toFileName"], "fileName": "org.gradle.api.reporting.dependencies.internal.HtmlDependencyReporter"}, {"methodBody": ["METHOD_START", "{", "RenderableDependency   root ;", "if    ( configuration . isCanBeResolved (  )  )     {", "ResolutionResult   result    =    configuration . getIncoming (  )  . getResolutionResult (  )  ;", "root    =    new   RenderableModuleResult ( result . getRoot (  )  )  ;", "} else    {", "root    =    new   UnresolvableConfigurationResult ( configuration )  ;", "}", "Set < ModuleIdentifier >    modules    =    Sets . newHashSet (  )  ;", "Set < ComponentIdentifier >    visited    =    Sets . newHashSet (  )  ;", "populateModulesWithChildD ( root ,    visited ,    modules )  ;", "return   modules ;", "}", "METHOD_END"], "methodName": ["collectModules"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "Iterable < Configuration >    configurations    =    project . getConfigurations (  )  ;", "return   CollectionUtils . collect ( configurations ,    new   Transformer < Map ,    Configuration >  (  )     {", "@ Override", "public   Map   transform ( Configuration   configuration )     {", "LinkedHashMap < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  4  )  ;", "map . put (  \" name \"  ,    configuration . getName (  )  )  ;", "map . put (  \" description \"  ,    configuration . getDescription (  )  )  ;", "map . put (  \" dependencies \"  ,    createDependencies ( configuration )  )  ;", "map . put (  \" moduleInsights \"  ,    createModuleInsights ( configuration )  )  ;", "return   map ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createConfigurations"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( configuration . isCanBeResolved (  )  )     {", "ResolutionResult   result    =    configuration . getIncoming (  )  . getResolutionResult (  )  ;", "Renderable   root    =    new   RenderableModuleResult ( result . getRoot (  )  )  ;", "return   createChildren ( root ,    new   HashSet < Object >  (  )  )  ;", "} else    {", "return   createChildren ( new   UnresolvableConfigurationResult ( configuration )  ,    new   HashSet < Object >  (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createDependencies"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "Iterable <  ?    extends   RenderableDependency >    children    =    dependency . getChildren (  )  ;", "return   CollectionUtils . collect ( children ,    new   Transformer < Map ,    RenderableDependency >  (  )     {", "@ Override", "public   Map   transform ( RenderableDependency   childDependency )     {", "boolean   alreadyVisited    =     !  ( visited . add ( childDependency . getId (  )  )  )  ;", "boolean   alreadyRendered    =    alreadyVisited    &  &     (  !  ( childDependency . getChildren (  )  . isEmpty (  )  )  )  ;", "String   name    =    replaceArrow ( childDependency . getName (  )  )  ;", "boolean   hasConflict    =     !  ( name . equals ( childDependency . getName (  )  )  )  ;", "LinkedHashMap < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  6  )  ;", "ModuleIdentifier   moduleIdentifier    =    getModuleIdentifier ( childDependency )  ;", "map . put (  \" module \"  ,     ( moduleIdentifier    =  =    null    ?    null    :    moduleIdentifier . toString (  )  )  )  ;", "map . put (  \" name \"  ,    name )  ;", "map . put (  \" resolvable \"  ,    childDependency . getResolutionState (  )  )  ;", "map . put (  \" hasConflict \"  ,    hasConflict )  ;", "map . put (  \" alreadyRendered \"  ,    alreadyRendered )  ;", "map . put (  \" children \"  ,    Collections . emptyList (  )  )  ;", "if    (  ! alreadyRendered )     {", "map . put (  \" children \"  ,    createDependencyChildren ( childDependency ,    visited )  )  ;", "}", "return   map ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createDependencyChildren"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "final   Spec < DependencyResult >    dependencySpec    =    new   StrictDependencyResultSpec ( module )  ;", "ResolutionResult   result    =    configuration . getIncoming (  )  . getResolutionResult (  )  ;", "final   Set < DependencyResult >    selectedDependencies    =    new   LinkedHashSet < DependencyResult >  (  )  ;", "result . allDependencies ( new   Action < DependencyResult >  (  )     {", "@ Override", "public   void   execute ( DependencyResult   it )     {", "if    ( dependencySpec . isSatisfiedBy ( it )  )     {", "selectedDependencies . add ( it )  ;", "}", "}", "}  )  ;", "Collection < RenderableDependency >    sortedDeps    =    new   DependencyInsightReporter (  )  . prepare ( selectedDependencies ,    versionSelectorScheme ,    versionComparator )  ;", "return   CollectionUtils . collect ( sortedDeps ,    new   Transformer < Object ,    RenderableDependency >  (  )     {", "@ Override", "public   Object   transform ( RenderableDependency   dependency )     {", "String   name    =    replaceArrow ( dependency . getName (  )  )  ;", "LinkedHashMap < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  5  )  ;", "map . put (  \" name \"  ,    replaceArrow ( dependency . getName (  )  )  )  ;", "map . put (  \" description \"  ,    dependency . getDescription (  )  )  ;", "map . put (  \" resolvable \"  ,    dependency . getResolutionState (  )  )  ;", "map . put (  \" hasConflict \"  ,     (  !  ( name . equals ( dependency . getName (  )  )  )  )  )  ;", "map . put (  \" children \"  ,    createInsightDependencyChildren ( dependency ,    new   HashSet < Object >  (  )  ,    configuration )  )  ;", "return   map ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createInsight"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "Iterable <  ?    extends   RenderableDependency >    children    =    dependency . getChildren (  )  ;", "return   CollectionUtils . collect ( children ,    new   Transformer < Object ,    RenderableDependency >  (  )     {", "@ Override", "public   Object   transform ( RenderableDependency   childDependency )     {", "boolean   alreadyVisited    =     !  ( visited . add ( childDependency . getId (  )  )  )  ;", "boolean   leaf    =    childDependency . getChildren (  )  . isEmpty (  )  ;", "boolean   alreadyRendered    =    alreadyVisited    &  &     (  ! leaf )  ;", "String   childName    =    replaceArrow ( childDependency . getName (  )  )  ;", "boolean   hasConflict    =     !  ( childName . equals ( childDependency . getName (  )  )  )  ;", "String   name    =     ( leaf )     ?    configuration . getName (  )     :    childName ;", "LinkedHashMap < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  6  )  ;", "map . put (  \" name \"  ,    name )  ;", "map . put (  \" resolvable \"  ,    childDependency . getResolutionState (  )  )  ;", "map . put (  \" hasConflict \"  ,    hasConflict )  ;", "map . put (  \" alreadyRendered \"  ,    alreadyRendered )  ;", "map . put (  \" isLeaf \"  ,    leaf )  ;", "map . put (  \" children \"  ,    Collections . emptyList (  )  )  ;", "if    (  ! alreadyRendered )     {", "map . put (  \" children \"  ,    createInsightDependencyChildren ( childDependency ,    visited ,    configuration )  )  ;", "}", "return   map ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createInsightDependencyChildren"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "LinkedHashMap < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  2  )  ;", "map . put (  \" module \"  ,    module . toString (  )  )  ;", "map . put (  \" insight \"  ,    createInsight ( module ,    configuration )  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["createModuleInsight"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "Iterable < ModuleIdentifier >    modules    =    collectModules ( configuration )  ;", "return   CollectionUtils . collect ( modules ,    new   Transformer < Object ,    ModuleIdentifier >  (  )     {", "@ Override", "public   Object   transform ( ModuleIdentifier   moduleIdentifier )     {", "return   createModuleInsight ( moduleIdentifier ,    configuration )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createModuleInsights"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( renderableDependency . getId (  )  )    instanceof   ModuleComponentIdentifier )     {", "ModuleComponentIdentifier   id    =     (  ( ModuleComponentIdentifier )     ( renderableDependency . getId (  )  )  )  ;", "return   DefaultModuleIdentifier . newId ( id . getGroup (  )  ,    id . getModule (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getModuleIdentifier"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "for    ( RenderableDependency   childDependency    :    dependency . getChildren (  )  )     {", "ModuleIdentifier   moduleId    =    getModuleIdentifier ( childDependency )  ;", "if    ( moduleId    =  =    null )     {", "continue ;", "}", "modules . add ( moduleId )  ;", "boolean   alreadyVisited    =     !  ( visited . add (  (  ( ComponentIdentifier )     ( childDependency . getId (  )  )  )  )  )  ;", "if    (  ! alreadyVisited )     {", "populateModulesWithChildD ( childDependency ,    visited ,    modules )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["populateModulesWithChildDependencies"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "JsonBuilder   json    =    new   JsonBuilder (  )  ;", "render ( project ,    json )  ;", "return   json . toString (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    overall    =    Maps . newLinkedHashMap (  )  ;", "overall . put (  \" Version \"  ,    GradleVersion . current (  )  . toString (  )  )  ;", "overall . put (  \" generationDate \"  ,    new   Date (  )  . toString (  )  )  ;", "Map < String ,    Object >    projectOut    =    Maps . newLinkedHashMap (  )  ;", "projectOut . put (  \" name \"  ,    project . getName (  )  )  ;", "projectOut . put (  \" description \"  ,    project . getDescription (  )  )  ;", "projectOut . put (  \" configurations \"  ,    createConfigurations ( project )  )  ;", "overall . put (  \" project \"  ,    projectOut )  ;", "json . call ( overall )  ;", "}", "METHOD_END"], "methodName": ["renderProject"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "return   name . replace (  \"     -  >     \"  ,     \"     \\ u 2  7 a 1     \"  )  ;", "}", "METHOD_END"], "methodName": ["replaceArrow"], "fileName": "org.gradle.api.reporting.dependencies.internal.JsonProjectDependencyRenderer"}, {"methodBody": ["METHOD_START", "{", "return    \"  / org / gradle / api / tasks / diagnostics / htmldependencyreport /  \"     +    fileName ;", "}", "METHOD_END"], "methodName": ["getReportResourcePath"], "fileName": "org.gradle.api.reporting.dependencies.internal.ProjectPageRenderer"}, {"methodBody": ["METHOD_START", "{", "ComponentSelector   requested    =    candidate . getRequested (  )  ;", "if    (  (  ( moduleItifier )     !  =    null )     &  &     ( requested   instanceof   ModuleComponentSelector )  )     {", "ModuleComponentSelector   requestedSelector    =     (  ( ModuleComponentSelector )     ( requested )  )  ;", "return    ( requestedSelector . getGroup (  )  . equals ( moduleItifier . getGroup (  )  )  )     &  &     ( requestedSelector . getModule (  )  . equals ( moduleItifier . getName (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matchesRequested"], "fileName": "org.gradle.api.reporting.dependencies.internal.StrictDependencyResultSpec"}, {"methodBody": ["METHOD_START", "{", "ComponentIdentifier   selected    =    candidate . getSelected (  )  . getId (  )  ;", "if    (  (  ( moduleIdentifier )     !  =    null )     &  &     ( selected   instanceof   ModuleComponentIdentifier )  )     {", "ModuleComponentIdentifier   selectedModule    =     (  ( ModuleComponentIdentifier )     ( selected )  )  ;", "return    ( selectedModule . getGroup (  )  . equals ( moduleIdentifier . getGroup (  )  )  )     &  &     ( selectedModule . getModule (  )  . equals ( moduleIdentifier . getName (  )  )  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matchesSelected"], "fileName": "org.gradle.api.reporting.dependencies.internal.StrictDependencyResultSpec"}, {"methodBody": ["METHOD_START", "{", "return   components ;", "}", "METHOD_END"], "methodName": ["getComponents"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getModelRegistry"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( components )     =  =    null )     |  |     ( components . isEmpty (  )  )  )     {", "return   all ;", "}", "Set < ComponentSpec >    reported    =    Sets . newLinkedHashSet (  )  ;", "List < String >    notFound    =    Lists . newArrayList ( components )  ;", "for    ( ComponentSpec   candidate    :    all )     {", "String   candidateName    =    candidate . getName (  )  ;", "if    ( components . contains ( candidateName )  )     {", "reported . add ( candidate )  ;", "notFound . remove ( candidateName )  ;", "}", "}", "if    (  !  ( notFound . isEmpty (  )  )  )     {", "onNotFound ( notFound )  ;", "}", "return   reported ;", "}", "METHOD_END"], "methodName": ["getReportedComponents"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "return    ( showNonBuildable )     &  &     ( showTestSuites )  ;", "}", "METHOD_END"], "methodName": ["getShowAll"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "return   showNonBuildable ;", "}", "METHOD_END"], "methodName": ["isShowNonBuildable"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "return   showTestSuites ;", "}", "METHOD_END"], "methodName": ["isShowTestSuites"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   error    =    new   StringBuilder (  \" Component \"  )  ;", "if    (  ( notFound . size (  )  )     =  =     1  )     {", "error . append (  \"     '  \"  )  . append ( notFound . get (  0  )  )  ;", "} else    {", "String   last    =    notFound . remove (  (  ( notFound . size (  )  )     -     1  )  )  ;", "error . append (  \" s    '  \"  )  . append ( Joiner . on (  \"  '  ,     '  \"  )  . join ( notFound )  )  . append (  \"  '    and    '  \"  )  . append ( last )  ;", "}", "error . append (  \"  '    not   found .  \"  )  ;", "throw   new   InvalidUserDataException ( error . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["onComponentsNotFound"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "synchronized ( DependentComponentsReport . class )     {", "Project   project    =    getProject (  )  ;", "ModelRegistry   modelRegistry    =    getModelRegistry (  )  ;", "DependentBinariesResolver   dependentBinariesResolver    =    modelRegistry . find (  \" dependentBinariesResolver \"  ,    DependentBinariesResolver . class )  ;", "StyledTextOutput   textOutput    =    getTextOutputFactory (  )  . create ( DependentComponentsReport . class )  ;", "TextDependentComponentsReportRenderer   reportRenderer    =    new   TextDependentComponentsReportRenderer ( dependentBinariesResolver ,    showNonBuildable ,    showTestSuites )  ;", "reportRenderer . setOutput ( textOutput )  ;", "reportRenderer . startProject ( project )  ;", "Set < ComponentSpec >    allComponents    =    DependentComponentsUtils . getAllComponents ( modelRegistry )  ;", "if    ( showTestSuites )     {", "allComponents . addAll ( DependentComponentsUtils . getAllTestSuites ( modelRegistry )  )  ;", "}", "reportRenderer . renderComponents ( getReportedComponents ( allComponents )  )  ;", "reportRenderer . renderLegend (  )  ;", "reportRenderer . completeProject ( project )  ;", "reportRenderer . complete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["report"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "this . components    =    components ;", "}", "METHOD_END"], "methodName": ["setComponents"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "this . showNonBuildable    =    showAll ;", "this . showTestSuites    =    showAll ;", "}", "METHOD_END"], "methodName": ["setShowAll"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "this . showNonBuildable    =    showNonBuildable ;", "}", "METHOD_END"], "methodName": ["setShowNonBuildable"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "this . showTestSuites    =    showTestSuites ;", "}", "METHOD_END"], "methodName": ["setShowTestSuites"], "fileName": "org.gradle.api.reporting.dependents.DependentComponentsReport"}, {"methodBody": ["METHOD_START", "{", "renderer . visit ( new   Action < StyledTextOutput >  (  )     {", "public   void   execute ( StyledTextOutput   output )     {", "nodeRenderer . renderNode ( output ,    node ,    false )  ;", "}", "}  ,    last )  ;", "renderChildren ( getChildren ( node )  )  ;", "}", "METHOD_END"], "methodName": ["doRender"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   Sets . filter ( node . getChildren (  )  ,    showDependentPredicate )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   showDependentPredicate . hiddenNonBuildable ;", "}", "METHOD_END"], "methodName": ["hasHiddenNonBuildable"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   showDependentPredicate . hiddenTestSuite ;", "}", "METHOD_END"], "methodName": ["hasHiddenTestSuite"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   nodeRenderer . seenTestSuite ;", "}", "METHOD_END"], "methodName": ["hasSeenTestSuite"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "renderChildren ( getChildren ( root )  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . startChildren (  )  ;", "int   idx    =     0  ;", "for    ( Renderablecy   child    :    children )     {", "boolean   last    =     ( idx +  +  )     =  =     (  ( children . size (  )  )     -     1  )  ;", "doRender ( child ,    last )  ;", "}", "renderer . completeChildren (  )  ;", "}", "METHOD_END"], "methodName": ["renderChildren"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   buildable ;", "}", "METHOD_END"], "methodName": ["isBuildable"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderableDependency"}, {"methodBody": ["METHOD_START", "{", "return   testSuite ;", "}", "METHOD_END"], "methodName": ["isTestSuite"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderableDependency"}, {"methodBody": ["METHOD_START", "{", "return   DependentComponentsRenderableDependency . of ( componentSpec ,    internalProtocol ,    null )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderableDependency"}, {"methodBody": ["METHOD_START", "{", "ComponentSpecIdentifier   id    =    internalProtocol . getIdentifier (  )  ;", "String   name    =    DependentComponentsUtils . getBuildScopedTerseName ( id )  ;", "String   description    =    componentSpec . getDisplayName (  )  ;", "boolean   buildable    =    true ;", "if    ( componentSpec   instanceof   VariantComponentSpec )     {", "VariantComponentSpec   variantComponentSpec    =     (  ( VariantComponentSpec )     ( componentSpec )  )  ;", "buildable    =    Iterables . any ( variantComponentSpec . getBinaries (  )  . values (  )  ,    new   com . google . common . base . Predicate < BinarySpec >  (  )     {", "@ Override", "public   boolean   apply ( BinarySpec   binarySpec )     {", "return   binarySpec . isBuildable (  )  ;", "}", "}  )  ;", "}", "boolean   testSuite    =    false ;", "return   new    ( id ,    name ,    description ,    buildable ,    testSuite ,    children )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderableDependency"}, {"methodBody": ["METHOD_START", "{", "LibraryBinaryIdentifier   id    =    resolvedResult . getId (  )  ;", "String   name    =    DependentComponentsUtils . getBuildScopedTerseName ( id )  ;", "String   description    =    id . getDisplayName (  )  ;", "boolean   buildable    =    resolvedResult . isBuildable (  )  ;", "boolean   testSuite    =    resolvedResult . isTestSuite (  )  ;", "LinkedHashSet <  >    children    =    Sets . newLinkedHashSet (  )  ;", "for    ( DependentBinariesResolvedResult   childResolutionResult    :    resolvedResult . getChildren (  )  )     {", "children . add (  . of ( childResolutionResult )  )  ;", "}", "return   new    ( id ,    name ,    description ,    buildable ,    testSuite ,    children )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderableDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( resolver )     !  =    null )     &  &     ( componentSpec   instanceof   VariantComponentSpec )  )     {", "VariantComponentSpec   variantComponentSpec    =     (  ( VariantComponentSpec )     ( componentSpec )  )  ;", "LinkedHashSet < ableDependency >    children    =    Sets . newLinkedHashSet (  )  ;", "for    ( BinarySpecInternal   binarySpec    :    variantComponentSpec . getBinaries (  )  . withType ( BinarySpecInternal . class )  )     {", "DependentBinariesResolutionResult   resolvedBinary    =    resolver . resolve ( binarySpec )  ;", "children . add ( ableDependency . of ( resolvedBinary . getRoot (  )  )  )  ;", "}", "return   ableDependency . of ( componentSpec ,    internalProtocol ,    children )  ;", "} else    {", "return   ableDependency . of ( componentSpec ,    internalProtocol )  ;", "}", "}", "METHOD_END"], "methodName": ["getRenderableDependencyOf"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( seenTestSuite )     |  |     ( hiddenTestSuite )  )     |  |     ( hiddenNonBuildable )  )     {", "StyledTextOutput   output    =    builder . getOutput (  )  ;", "if    ( seenTestSuite )     {", "output . withStyle ( Info )  . println (  \"  ( t )     -    Test   suite   binary \"  )  ;", "if    ( hiddenNonBuildable )     {", "output . println (  )  ;", "}", "} else", "if    ( hiddenTestSuite )     {", "output . withStyle ( Info )  . println (  \" Some   test   suites   were   not   shown ,    use    -  - test - suites   or    -  - all   to   show   them .  \"  )  ;", "}", "if    ( hiddenNonBuildable )     {", "output . withStyle ( Info )  . println (  \" Some   non - buildable   c   were   not   shown ,    use    -  - non - buildable   or    -  - all   to   show   them .  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printLegend"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < ComponentSpec >    components    =    Sets . newLinkedHashSet (  )  ;", "ComponentSpecContainer   componentSpecs    =     . modelElement ( registry ,     \" components \"  ,    ComponentSpecContainer . class )  ;", "if    ( componentSpecs    !  =    null )     {", "components . addAll ( componentSpecs . values (  )  )  ;", "}", "return   components ;", "}", "METHOD_END"], "methodName": ["getAllComponents"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "Set < ComponentSpec >    components    =    Sets . newLinkedHashSet (  )  ;", "ModelMap < ComponentSpec >    testSuites    =     . modelElement ( registry ,     \" testSuites \"  ,    modelMap ( ComponentSpec . class )  )  ;", "if    ( testSuites    !  =    null )     {", "components . addAll ( testSuites . values (  )  )  ;", "}", "return   components ;", "}", "METHOD_END"], "methodName": ["getAllTestSuites"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( DependentComponentsUtils . getProjectPrefix ( id . getProjectPath (  )  )  )     +     ( id . getLibraryName (  )  )  )     +     ( Project . PATH _ SEPARATOR )  )     +     ( id . getVariant (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildScopedTerseName"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "return    ( DependentComponentsUtils . getProjectPrefix ( id . getProjectPath (  )  )  )     +     ( id . getProjectScopedName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildScopedTerseName"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( PATH _ SEPARATOR . equals ( projectPath )  )     {", "return    \"  \"  ;", "}", "return   projectPath    +     ( Project . PATH _ SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["getProjectPrefix"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "return   registry . find ( path ,    clazz )  ;", "}", "METHOD_END"], "methodName": ["modelElement"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "return   registry . find ( path ,    modelType )  ;", "}", "METHOD_END"], "methodName": ["modelElement"], "fileName": "org.gradle.api.reporting.dependents.internal.DependentComponentsUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( components . isEmpty (  )  )     {", "getTextOutput (  )  . withStyle ( Info )  . println (  \" No   components .  \"  )  ;", "return ;", "}", "for    ( ComponentSpec   component    :    components )     {", "getBuilder (  )  . item ( component ,    dnderer )  ;", "}", "}", "METHOD_END"], "methodName": ["renderComponents"], "fileName": "org.gradle.api.reporting.dependents.internal.TextDependentComponentsReportRenderer"}, {"methodBody": ["METHOD_START", "{", "dependentComponentsRenderer . printLegend ( getBuilder (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderLegend"], "fileName": "org.gradle.api.reporting.dependents.internal.TextDependentComponentsReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   format ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getModelRegistry"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "return   showHidden ;", "}", "METHOD_END"], "methodName": ["isShowHidden"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    getProject (  )  ;", "StyledTextOutput   textOutput    =    getTextOutputFactory (  )  . create (  . class )  ;", "ModelNodeRenderer   renderer    =    new   ModelNodeRenderer ( isShowHidden (  )  ,    getFormat (  )  )  ;", "TextRenderer   textRenderer    =    new   TextRenderer ( renderer )  ;", "textRenderer . setOutput ( textOutput )  ;", "textRenderer . startProject ( project )  ;", "ModelRegistry   modelRegistry    =    getModelRegistry (  )  ;", "ModelNode   rootNode    =    modelRegistry . realizeNode ( ROOT )  ;", "modelRegistry . bindAllReferences (  )  ;", "textRenderer . render ( rootNode )  ;", "textRenderer . completeProject ( project )  ;", "textRenderer . complete (  )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "this . format    =    ModelReport . Format . valueOf ( format . toUpperCase (  )  )  ;", "}", "METHOD_END"], "methodName": ["setFormat"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "this . showHidden    =    showHidden ;", "}", "METHOD_END"], "methodName": ["setShowHidden"], "fileName": "org.gradle.api.reporting.model.ModelReport"}, {"methodBody": ["METHOD_START", "{", "return   Strings . padEnd ( label ,    ModelNodeRenderer . LABEL _ LENGTH ,     '     '  )  ;", "}", "METHOD_END"], "methodName": ["attributeLabel"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( model . getLinkCount (  )  )     =  =     0  )     |  |     ( model   instanceof   ModelReferenceNode )  )     {", "return   model . getValueDescription (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getNodeValue"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( omitDetails (  )  )     {", "return ;", "}", "Iterable < ModelRuleDescriptor >    executedRules    =     . uniqueExecutedRulesExcludingCreator ( model )  ;", "if    (  !  ( Iterables . isEmpty ( executedRules )  )  )     {", "printNestedAttributeTitle ( styledTextoutput ,     \" Rules :  \"  )  ;", "for    ( ModelRuleDescriptor   ruleDescriptor    :    executedRules )     {", "printNestedAttribute ( styledTextoutput ,     (  \"  ?     \"     +     ( ruleDescriptor . toString (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["maybePrintRules"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( omitDetails (  )  )     {", "return ;", "}", "Optional < String >    typeDescription    =    getTypeDescription (  )  ;", "if    ( typeDescription . isPresent (  )  )     {", "printNodeAttribute ( styledTextoutput ,     \" Type :  \"  ,    typeDescription . get (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybePrintType"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( omitDetails (  )  )     {", "return ;", "}", "Optional < String >    value    =    getNodeValue (  )  ;", "if    (  ( value    !  =    null )     &  &     ( value . isPresent (  )  )  )     {", "printNodeAttribute ( styledTextoutput ,     \" Value :  \"  ,    value . get (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybePrintValue"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "return    ( ModelReport . Format . SHORT )     =  =     ( format )  ;", "}", "METHOD_END"], "methodName": ["omitDetails"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( omitDetails (  )  )     {", "return ;", "}", "ModelRuleDescriptor   descriptor    =    getDescriptor (  )  ;", "StringBuffer   buffer    =    new   StringBuffer (  )  ;", "descriptor . describeTo ( buffer )  ;", "printNodeAttribute ( styledTextoutput ,     \" Creator :  \"  ,    buffer . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["printCreator"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "styledTextoutput . withStyle ( Normal )  . format (  \"                             % s \"  ,    value )  ;", "styledTextoutput . prln (  )  ;", "}", "METHOD_END"], "methodName": ["printNestedAttribute"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "styledTextoutput . withStyle ( Identifier )  . format (  \"                    |     % s \"  ,    title )  ;", "styledTextoutput . prln (  )  ;", "}", "METHOD_END"], "methodName": ["printNestedAttributeTitle"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "styledTextoutput . withStyle ( Identifier )  . format (  \"                    |     % s \"  ,    attributeLabel ( label )  )  ;", "styledTextoutput . withStyle ( Description )  . format (  \"     \\ t % s \"  ,    value )  ;", "styledTextoutput . prln (  )  ;", "}", "METHOD_END"], "methodName": ["printNodeAttribute"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "Optional < String >    value    =    getNodeValue (  ;", "boolean   hasValue    =     ( value    !  =    null )     &  &     ( value . isPresent (  )  )  ;", "String   intro    =     (  (  ( omitDetails (  )  )     &  &     (  ( getLinkCount (  )  )     =  =     0  )  )     &  &    hasValue )     ?     \"  |  \"     :     \"  +  \"  ;", "styledTextoutput . withStyle ( Identifier )  . format (  \"  % s    % s \"  ,    intro ,    getPath (  )  . getName (  )  )  ;", "if    (  ( omitDetails (  )  )     &  &    hasValue )     {", "styledTextoutput . withStyle ( Description )  . format (  \"     =     % s \"  ,    value . get (  )  )  ;", "}", "styledTextoutput . println (  )  ;", "}", "METHOD_END"], "methodName": ["printNodeName"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "Iterable   filtered    =    Iterables . filter ( model . getExecutedRules (  )  ,    new   com . google . common . base . Predicate < ModelRuleDescriptor >  (  )     {", "@ Override", "public   boolean   apply ( ModelRuleDescriptor   input )     {", "return    !  ( input . equals ( model . getDescriptor (  )  )  )  ;", "}", "}  )  ;", "return   ImmutableSet . copyOf ( filtered )  ;", "}", "METHOD_END"], "methodName": ["uniqueExecutedRulesExcludingCreator"], "fileName": "org.gradle.api.reporting.model.internal.ModelNodeRenderer"}, {"methodBody": ["METHOD_START", "{", "modelNodeRenderer . render ( node ,    getBuilder (  )  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.api.reporting.model.internal.TextModelReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   configurations ;", "}", "METHOD_END"], "methodName": ["getConfigurations"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "return    ( configurations )     !  =    null    ?    configurations    :    getTaskConfigurations (  )  ;", "}", "METHOD_END"], "methodName": ["getReportConfigurations"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "this . configurations    =    Collections . singleton ( getTaskConfigurations (  )  . getByName ( configurationName )  )  ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "this . configurations    =    configurations ;", "}", "METHOD_END"], "methodName": ["setConfigurations"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "this . renderer    =    renderer ;", "}", "METHOD_END"], "methodName": ["setRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractDependencyReportTask"}, {"methodBody": ["METHOD_START", "{", "ProjectReportGenerator   projectReportGenerator    =    new   ProjectReportGenerator (  )     {", "@ Override", "public   void   generateReport ( Project   project )    throws   IOException    {", "generate ( project )  ;", "if    ( shouldCreateReportFile (  )  )     {", "project . getLogger (  )  . lifecycle (  \" See   the   report   at :     {  }  \"  ,    new   ConsoleRenderer (  )  . asClickableFileUrl ( getOutputFile (  )  )  )  ;", "}", "}", "}  ;", "ReportGenerator   reportGenerator    =    new   ReportGenerator ( getRenderer (  )  ,    getClientMetaData (  )  ,    getOutputFile (  )  ,    getTextOutputFactory (  )  ,    projectReportGenerator )  ;", "reportGenerator . generateReport ( new   TreeSet < Project >  ( getProjects (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getClientMetaData"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "return   projects ;", "}", "METHOD_END"], "methodName": ["getProjects"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "this . outputFile    =    outputFile ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "this . projects    =    projects ;", "}", "METHOD_END"], "methodName": ["setProjects"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "return    ( getOutputFile (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["shouldCreateReportFile"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTask"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "Sequence   sequence    =    context . sequence (  \" sequence \"  )  ;", "one ( renderer )  . setClientMetaData (  (  ( BuildClientMetaData )     ( with ( notNullValue (  )  )  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . setOutput (  (  ( StyledTextOutput )     ( with ( notNullValue (  )  )  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . startProject ( project )  ;", "inSequence ( sequence )  ;", "one ( generator )  . run (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeProject ( project )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . complete (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", ". generate (  )  ;", "}", "METHOD_END"], "methodName": ["completesRendererAtEndOfGeneration"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "final   Project   child 1     =    createChildProject ( project ,     \" child 1  \"  )  ;", "final   Project   child 2     =    createChildProject ( project ,     \" child 2  \"  )  ;", ". setProjects ( project . getAllprojects (  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "one ( renderer )  . setClientMetaData (  (  ( BuildClientMetaData )     ( with ( notNullValue (  )  )  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . setOutput (  (  ( StyledTextOutput )     ( with ( notNullValue (  )  )  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . startProject ( project )  ;", "inSequence ( sequence )  ;", "one ( generator )  . run (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeProject ( project )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . startProject ( child 1  )  ;", "inSequence ( sequence )  ;", "one ( generator )  . run (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeProject ( child 1  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . startProject ( child 2  )  ;", "inSequence ( sequence )  ;", "one ( generator )  . run (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeProject ( child 2  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . complete (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", ". generate (  )  ;", "}", "METHOD_END"], "methodName": ["passesEachProjectToRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "generator    =    context . mock ( Runnable . class )  ;", "renderer    =    context . mock ( ReportRenderer . class )  ;", "task    =    TestUtil . createTask (  . TestReportTask . class ,    project )  ;", "task . setGenerator ( generator )  ;", "task . setRenderer ( renderer )  ;", "task . setProjects ( WrapUtil .  < Project > toSet ( project )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    tmpDir . getTestDirectory (  )  . file (  \" report . txt \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "Sequence   sequence    =    context . sequence (  \" sequence \"  )  ;", "one ( renderer )  . setClientMetaData (  (  ( BuildClientMetaData )     ( with ( notNullValue (  )  )  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . setOutputFile ( file )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . startProject ( project )  ;", "inSequence ( sequence )  ;", "one ( generator )  . run (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeProject ( project )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . complete (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "task . setOutputFile ( file )  ;", "task . generate (  )  ;", "}", "METHOD_END"], "methodName": ["setsOutputFileNameOnRendererBeforeGeneration"], "fileName": "org.gradle.api.tasks.diagnostics.AbstractReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "ProjectReportGenerator   projectReportGenerator    =    new   ProjectReportGenerator (  )     {", "@ Override", "public   void   generateReport ( Project   project )    throws   IOException    {", "Configuration   configuration    =    getProject (  )  . getBuildscript (  )  . getConfigurations (  )  . getByName ( CLASSPATH _ CONFIGURATION )  ;", "renderer . startConfiguration ( configuration )  ;", "renderer . render ( configuration )  ;", "renderer . completeConfiguration ( configuration )  ;", "}", "}  ;", "ReportGenerator   reportGenerator    =    new   ReportGenerator ( renderer ,    getClientMetaData (  )  ,    null ,    getTextOutputFactory (  )  ,    projectReportGenerator )  ;", "reportGenerator . generateReport ( Collections . singleton ( getProject (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getClientMetaData"], "fileName": "org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask"}, {"methodBody": ["METHOD_START", "{", "this . renderer    =    dependencyReportRenderer ;", "}", "METHOD_END"], "methodName": ["setRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask"}, {"methodBody": ["METHOD_START", "{", "return   configuration ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "return   dependencySpec ;", "}", "METHOD_END"], "methodName": ["getDependencySpec"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getVersionComparator"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getVersionSelectorScheme"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute <  ?  >    requested    :    requestedAttributes . keySet (  )  )     {", "Object   requestedValue    =    requestedAttributes . getAttribute ( requested )  ;", "if    ( requested . getName (  )  . equals ( actualAttribute . getName (  )  )  )     {", "if    ( requested . equals ( actualAttribute )  )     {", "if    ( actualValue . equals ( requestedValue )  )     {", "return   new    . AttributeMatchDetails (  . MatchType . requested ,    requested ,    requestedValue )  ;", "}", "return   new    . AttributeMatchDetails (  . MatchType . different _ value ,    requested ,    requestedValue )  ;", "} else    {", "if    ( actualValue . toString (  )  . equals ( requestedValue . toString (  )  )  )     {", "return   new    . AttributeMatchDetails (  . MatchType . requested ,    requested ,    requestedValue )  ;", "}", "return   new    . AttributeMatchDetails (  . MatchType . different _ value ,    requested ,    requestedValue )  ;", "}", "}", "}", "return   new    . AttributeMatchDetails (  . MatchType . not _ requested ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["match"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "final   Configuration   configuration    =    getConfiguration (  )  ;", "if    ( configuration    =  =    null )     {", "throw   new   InvalidUserDataException (  (  (  (  \" Dependency   insight   report   cannot   be   generated   because   the   input   configuration   was   not   specified .     \"     +     \"  \\ nIt   can   be   specified   from   the   command   line ,    e . g :     \\  '  \"  )     +     ( getPath (  )  )  )     +     \"     -  - configuration   someConf    -  - dependency   someDep '  \"  )  )  ;", "}", "if    (  ( dependencySpec )     =  =    null )     {", "throw   new   InvalidUserDataException (  (  (  (  \" Dependency   insight   report   cannot   be   generated   because   the   dependency   to   show   was   not   specified .  \"     +     \"  \\ nIt   can   be   specified   from   the   command   line ,    e . g :     \\  '  \"  )     +     ( getPath (  )  )  )     +     \"     -  - dependency   someDep '  \"  )  )  ;", "}", "StyledTextOutput   output    =    getTextOutputFactory (  )  . create ( getClass (  )  )  ;", "final   GraphRenderer   renderer    =    new   GraphRenderer ( output )  ;", "ResolutionResult   result    =    configuration . getIncoming (  )  . getResolutionResult (  )  ;", "final   Set < DependencyResult >    selectedDependencies    =    new   LinkedHashSet < DependencyResult >  (  )  ;", "result . allDependencies ( new   Action < DependencyResult >  (  )     {", "@ Override", "public   void   execute ( DependencyResult   dependencyResult )     {", "if    ( dependencySpec . isSatisfiedBy ( dependencyResult )  )     {", "selectedDependencies . add ( dependencyResult )  ;", "}", "}", "}  )  ;", "if    ( selectedDependencies . isEmpty (  )  )     {", "output . println (  (  \" No   dependencies   matching   given   input   were   found   in    \"     +     ( String . valueOf ( configuration )  )  )  )  ;", "return ;", "}", "Collection < RenderableDependency >    sortedDeps    =    new   DependencyInsightReporter (  )  . prepare ( selectedDependencies ,    getVersionSelectorScheme (  )  ,    getVersionComparator (  )  )  ;", "NodeRenderer   nodeRenderer    =    new   NodeRenderer (  )     {", "public   void   renderNode ( StyledTextOutput   target ,    RenderableDependency   node ,    boolean   alreadyRendered )     {", "boolean   leaf    =    node . getChildren (  )  . isEmpty (  )  ;", "target . text (  ( leaf    ?    configuration . getName (  )     :    node . getName (  )  )  )  ;", "if    ( alreadyRendered    &  &     (  ! leaf )  )     {", "target . withStyle ( Info )  . text (  \"     (  *  )  \"  )  ;", "}", "}", "}  ;", "LegendRenderer   legendRenderer    =    new   LegendRenderer ( output )  ;", "DependencyGraphRenderer   dependencyGraphRenderer    =    new   DependencyGraphRenderer ( renderer ,    nodeRenderer ,    legendRenderer )  ;", "int   i    =     1  ;", "for    ( final   RenderableDependency   dependency    :    sortedDeps )     {", "renderer . visit ( new    . RenderDependencyAction ( dependency ,    configuration )  ,    true )  ;", "dependencyGraphRenderer . render ( dependency )  ;", "boolean   last    =     ( i +  +  )     =  =     ( sortedDeps . size (  )  )  ;", "if    (  ! last )     {", "output . println (  )  ;", "}", "}", "legendRenderer . printLegend (  )  ;", "output . println (  )  ;", "output . text (  \" A   web - based ,    searchable   dependency   report   is   available   by   adding   the    \"  )  ;", "output . withStyle ( UserInput )  . format (  \"  -  -  % s \"  ,    LONG _ OPTION )  ;", "output . println (  \"    option .  \"  )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    getProject (  )  . getConfigurations (  )  . getByName ( configurationName )  ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setConfiguration"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "NotationParser < Object ,    Spec < DependencyResult >  >    parser    =    DependencyResultSpecNotationConverter . parser (  )  ;", "this . dependencySpec    =    parser . parseNotation ( dNotation )  ;", "}", "METHOD_END"], "methodName": ["setDependencySpec"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "this . dependencySpec    =    dependencySpec ;", "}", "METHOD_END"], "methodName": ["setDependencySpec"], "fileName": "org.gradle.api.tasks.diagnostics.DependencyInsightReportTask"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . sort ( project . getChildProjects (  )  . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.api.tasks.diagnostics.ProjectReportTask"}, {"methodBody": ["METHOD_START", "{", "renderer . visit ( new   Action < StyledTextOutput >  (  )     {", "public   void   execute ( StyledTextOutput   styledTextOutput )     {", "styledTextOutput . text ( StringUtils . capitalize ( project . toString (  )  )  )  ;", "if    ( GUtil . isTrue ( project . getDescription (  )  )  )     {", "textOutput . withStyle ( Description )  . format (  \"     -     % s \"  ,    project . getDescription (  )  )  ;", "}", "}", "}  ,    lastChild )  ;", "renderer . startChildren (  )  ;", "List < Project >    children    =    getChildren ( project )  ;", "for    ( Project   child    :    children )     {", "render ( child ,    renderer ,     ( child    =  =     ( children . get (  (  ( children . size (  )  )     -     1  )  )  )  )  ,    textOutput )  ;", "}", "renderer . completeChildren (  )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.api.tasks.diagnostics.ProjectReportTask"}, {"methodBody": ["METHOD_START", "{", "this . renderer    =    renderer ;", "}", "METHOD_END"], "methodName": ["setRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.PropertyReportTask"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( project )  . getProperties (  )  ;", "will ( returnValue ( GUtil . map (  \" prop \"  ,     \" value \"  ,     \" properties \"  ,     \" prop \"  )  )  )  ;", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "oneOf ( renderer )  . add (  \" prop \"  ,     \" value \"  )  ;", "inSequence ( sequence )  ;", "oneOf ( renderer )  . add (  \" properties \"  ,     \"  {  .  .  .  }  \"  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "task . generate ( project )  ;", "}", "METHOD_END"], "methodName": ["doesNotShowContentsOfThePropertiesProperty"], "fileName": "org.gradle.api.tasks.diagnostics.PropertyReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( project )  . getProperties (  )  ;", "will ( returnValue ( GUtil . map (  \" b \"  ,     \" value 2  \"  ,     \" a \"  ,     \" value 1  \"  )  )  )  ;", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "oneOf ( renderer )  . add (  \" a \"  ,     \" value 1  \"  )  ;", "inSequence ( sequence )  ;", "oneOf ( renderer )  . add (  \" b \"  ,     \" value 2  \"  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "task . generate ( project )  ;", "}", "METHOD_END"], "methodName": ["passesEachProjectPropertyToRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.PropertyReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "context . setImposteriser ( INSTANCE )  ;", "project    =    context . mock ( ProjectInternal . class )  ;", "renderer    =    context . mock ( PropertyReportRenderer . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( project )  . absoluteProjectPath (  \" list \"  )  ;", "will ( returnValue (  \"  : path \"  )  )  ;", "allowing ( project )  . getConvention (  )  ;", "will ( returnValue ( null )  )  ;", "}", "}  )  ;", "task    =    TestUtil . create ( temporaryFolder )  . task (  . class )  ;", "task . setRenderer ( renderer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.gradle.api.tasks.diagnostics.PropertyReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectTaskLister"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTask"}, {"methodBody": ["METHOD_START", "{", "return   detail ;", "}", "METHOD_END"], "methodName": ["isDetail"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTask"}, {"methodBody": ["METHOD_START", "{", "this . renderer    =    renderer ;", "}", "METHOD_END"], "methodName": ["setRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTask"}, {"methodBody": ["METHOD_START", "{", "this . detail    =    detail ;", "}", "METHOD_END"], "methodName": ["setShowDetail"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTask"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "Task   task 1     =    task (  \" a \"  ,     \" group   a \"  )  ;", "Task   task 2     =    task (  \" b \"  ,     \" group   b \"  )  ;", "Task   task 3     =    task (  \" c \"  )  ;", "Task   task 4     =    task (  \" d \"  ,     \" group   b \"  ,    task 3  )  ;", "List < String >    testDefaultTasks    =    toList (  \" defaultTask 1  \"  ,     \" defaultTask 2  \"  )  ;", "allowing ( project )  . getDefaultTasks (  )  ;", "will ( returnValue ( testDefaultTasks )  )  ;", "allowing ( taskContainer )  . realize (  )  ;", "allowing ( taskContainer )  . size (  )  ;", "will ( returnValue (  4  )  )  ;", "allowing ( taskContainer )  . iterator (  )  ;", "will ( returnIterator ( toLinkedSet ( task 2  ,    task 3  ,    task 4  ,    task 1  )  )  )  ;", "allowing ( implicitTasks )  . iterator (  )  ;", "will ( returnIterator ( toLinkedSet (  )  )  )  ;", "allowing ( taskContainer )  . getRules (  )  ;", "will ( returnValue ( toList (  )  )  )  ;", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "one ( renderer )  . showDetail ( false )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addDefaultTasks ( testDefaultTasks )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . staGroup (  \" group   a \"  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addTask ( with ( isTask ( task 1  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . staGroup (  \" group   b \"  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addTask ( with ( isTask ( task 2  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addTask ( with ( isTask ( task 4  )  )  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeTasks (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "task . generate ( project )  ;", "}", "METHOD_END"], "methodName": ["groupsTasksByTaskGroupAndPassesTasksToTheRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < TaskDetails >  (  )     {", "public   boolean   matches ( Object   o )     {", "TaskDetails   other    =     (  ( TaskDetails )     ( o )  )  ;", "return   other . getPath (  )  . equals ( Path . path ( task . getName (  )  )  )  ;", "}", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" is    \"  )  . appendValue ( task )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["isTask"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "Rule   rule 1     =    context . mock ( Rule . class )  ;", "Rule   rule 2     =    context . mock ( Rule . class )  ;", "List < String >    defauls    =    toList (  )  ;", "allowing ( project )  . getDefauls (  )  ;", "will ( returnValue ( defauls )  )  ;", "allowing ( taskContainer )  . realize (  )  ;", "allowing ( taskContainer )  . size (  )  ;", "will ( returnValue (  0  )  )  ;", "allowing ( taskContainer )  . iterator (  )  ;", "will ( returnIterator ( toLinkedSet (  )  )  )  ;", "allowing ( implicis )  . iterator (  )  ;", "will ( returnIterator ( toLinkedSet (  )  )  )  ;", "one ( taskContainer )  . getRules (  )  ;", "will ( returnValue ( toList ( rule 1  ,    rule 2  )  )  )  ;", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "one ( renderer )  . showDetail ( false )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addDefauls ( defauls )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . completeTasks (  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addRule ( rule 1  )  ;", "inSequence ( sequence )  ;", "one ( renderer )  . addRule ( rule 2  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "task . generate ( project )  ;", "}", "METHOD_END"], "methodName": ["passesEachRuleToRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "allowing ( project )  . absoluteProjectPath (  \" list \"  )  ;", "will ( returnValue (  \"  : path \"  )  )  ;", "allowing ( project )  . getTasks (  )  ;", "will ( returnValue ( taskContainer )  )  ;", "allowing ( project )  . getConvention (  )  ;", "will ( returnValue ( null )  )  ;", "allowing ( project )  . getAllprojects (  )  ;", "will ( returnValue ( toSet ( project )  )  )  ;", "allowing ( project )  . getSubprojects (  )  ;", "will ( returnValue ( toSet (  )  )  )  ;", "}", "}  )  ;", "task    =    TestUtil . create ( temporaryFolder )  . task (  . class )  ;", "task . setRenderer ( renderer )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "return   task ( name ,    null )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "final   Task   task    =    context . mock ( Task . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( task )  . getName (  )  ;", "will ( returnValue ( name )  )  ;", "allowing ( task )  . getPath (  )  ;", "will ( returnValue (  (  '  :  '     +    name )  )  )  ;", "allowing ( task )  . getProject (  )  ;", "will ( returnValue ( project )  )  ;", "allowing ( project )  . relativeProjectPath (  (  '  :  '     +    name )  )  ;", "will ( returnValue ( name )  )  ;", "allowing ( task )  . getGroup (  )  ;", "will ( returnValue ( taskGroup )  )  ;", "allowing ( task )  . compareTo ( with ( Matchers . notNullValue ( Task . class )  )  )  ;", "will ( new   Action (  )     {", "public   Object   invoke ( Invocation   invocation )    throws   Throwable    {", "Task   other    =     (  ( Task )     ( invocation . getParameter (  0  )  )  )  ;", "return   name . compareTo ( other . getName (  )  )  ;", "}", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" compare   to \"  )  ;", "}", "}  )  ;", "TaskDependency   dependency    =    context . mock ( TaskDependency . class )  ;", "allowing ( task )  . geDependencies (  )  ;", "will ( returnValue ( dependency )  )  ;", "allowing ( dependency )  . getDependencies ( task )  ;", "will ( returnValue ( toSet ( dependencies )  )  )  ;", "}", "}  )  ;", "return   task ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.tasks.diagnostics.TaskReportTaskTest"}, {"methodBody": ["METHOD_START", "{", "projects . add ( project )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.tasks.diagnostics.internal.AggregateMultiProjectTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "groups    =    TreeMultimap . create ( new   Comparator < String >  (  )     {", "public   int   compare ( String   string 1  ,    String   string 2  )     {", "return   string 1  . compareToIgnoreCase ( string 2  )  ;", "}", "}  ,    new   Comparator < TaskDetails >  (  )     {", "public   int   compare ( TaskDetails   task 1  ,    TaskDetails   task 2  )     {", "return   task 1  . getPath (  )  . compareTo ( task 2  . getPath (  )  )  ;", "}", "}  )  ;", "for    ( TaskReportModel   project    :    projects )     {", "for    ( String   group    :    project . getGroups (  )  )     {", "if    ( isVisible ( group )  )     {", "for    ( final   TaskDetails   task    :    project . getTasksForGroup ( group )  )     {", "groups . put ( group ,     ( mergeTasksWithSameName    ?    new    . MergedTaskDetails ( task )     :    task )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.tasks.diagnostics.internal.AggregateMultiProjectTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "return    ( detail )     |  |     ( GUtil . isTrue ( group )  )  ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "org.gradle.api.tasks.diagnostics.internal.AggregateMultiProjectTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "Comparator < String >    keyComparator    =    GUtil . last ( GUtil . last ( DefaultGroupTaskReportModel . STRING _ COMPARATOR ,    DefaultGroupTaskReportModel . OTHER _ GROUP )  ,    TaskReportModel . DEFAULT _ GROUP )  ;", "Comparator < TaskDetails >    taskComparator    =    new   Comparator < TaskDetails >  (  )     {", "public   int   compare ( TaskDetails   task 1  ,    TaskDetails   task 2  )     {", "int   diff    =    DefaultGroupTaskReportModel . STRING _ COMPARATOR . compare ( task 1  . getPath (  )  . getName (  )  ,    task 2  . getPath (  )  . getName (  )  )  ;", "if    ( diff    !  =     0  )     {", "return   diff ;", "}", "Path   parent 1     =    task 1  . getPath (  )  . getParent (  )  ;", "Path   parent 2     =    task 2  . getPath (  )  . getParent (  )  ;", "if    (  ( parent 1     =  =    null )     &  &     ( parent 2     !  =    null )  )     {", "return    -  1  ;", "}", "if    (  ( parent 1     !  =    null )     &  &     ( parent 2     =  =    null )  )     {", "return    1  ;", "}", "if    ( parent 1     =  =    null )     {", "return    0  ;", "}", "return   parent 1  . compareTo ( parent 2  )  ;", "}", "}  ;", "groups    =    TreeMultimap . create ( keyComparator ,    taskComparator )  ;", "for    ( String   group    :    model . getGroups (  )  )     {", "groups . putAll ( group ,    model . getTasksForGroup ( group )  )  ;", "}", "String   otherGroupName    =    findOtherGroup ( groups . keySet (  )  )  ;", "if    (  ( otherGroupName    !  =    null )     &  &     ( groups . keySet (  )  . contains ( TaskReportModel . DEFAULT _ GROUP )  )  )     {", "groups . putAll ( otherGroupName ,    groups . removeAll ( TaskReportModel . DEFAULT _ GROUP )  )  ;", "}", "if    (  ( groups . keySet (  )  . contains ( TaskReportModel . DEFAULT _ GROUP )  )     &  &     (  ( groups . keySet (  )  . size (  )  )     >     1  )  )     {", "groups . putAll ( DefaultGroupTaskReportModel . OTHER _ GROUP ,    groups . removeAll ( TaskReportModel . DEFAULT _ GROUP )  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.tasks.diagnostics.internal.DefaultGroupTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "for    ( String   groupName    :    groupNames )     {", "if    ( groupName . equalsIgnoreCase (  . OTHER _ GROUP )  )     {", "return   groupName ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findOtherGroup"], "fileName": "org.gradle.api.tasks.diagnostics.internal.DefaultGroupTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "getTextOutput (  )  . formatln (  \"  % s :     % s \"  ,    name ,    value )  ;", "}", "METHOD_END"], "methodName": ["addProperty"], "fileName": "org.gradle.api.tasks.diagnostics.internal.PropertyReportRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . addProperty (  \" prop \"  ,     \" value \"  )  ;", "assert   containsLine ( out . toString (  )  ,     \" prop :    value \"  )  ;", "}", "METHOD_END"], "methodName": ["writesProperty"], "fileName": "org.gradle.api.tasks.diagnostics.internal.PropertyReportRendererTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "ReportRenderer   renderer    =    getRenderer (  )  ;", "renderer . setClientMetaData ( getClientMetaData (  )  )  ;", "File   outputFile    =    getOutputFile (  )  ;", "if    ( outputFile    !  =    null )     {", "renderer . setOutputFile ( outputFile )  ;", "} else    {", "renderer . setOutput ( getTextOutputFactory (  )  . create ( getClass (  )  )  )  ;", "}", "for    ( Project   project    :    projects )     {", "renderer . startProject ( project )  ;", "project . generateReport ( project )  ;", "renderer . completeProject ( project )  ;", "}", "renderer . complete (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["generateReport"], "fileName": "org.gradle.api.tasks.diagnostics.internal.ReportGenerator"}, {"methodBody": ["METHOD_START", "{", "return   buildClientMetaData ;", "}", "METHOD_END"], "methodName": ["getClientMetaData"], "fileName": "org.gradle.api.tasks.diagnostics.internal.ReportGenerator"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.api.tasks.diagnostics.internal.ReportGenerator"}, {"methodBody": ["METHOD_START", "{", "return   renderer ;", "}", "METHOD_END"], "methodName": ["getRenderer"], "fileName": "org.gradle.api.tasks.diagnostics.internal.ReportGenerator"}, {"methodBody": ["METHOD_START", "{", "return   textOutputFactory ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.api.tasks.diagnostics.internal.ReportGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( Task   task    :    tasks )     {", "String   group    =     ( GUtil . isTrue ( task . getGroup (  )  )  )     ?    task . getGroup (  )     :    TaskReportModel . DEFAULT _ GROUP ;", "groups . put ( group ,    new    . TaskDetailsImpl ( task ,    factory . create ( task )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.tasks.diagnostics.internal.SingleProjectTaskReportModel"}, {"methodBody": ["METHOD_START", "{", "final   String   path ;", "Project   project    =    task . getProject (  )  ;", "if    ( projects . contains ( project )  )     {", "path    =    this . project . relativeProjectPath ( task . getPath (  )  )  ;", "} else    {", "path    =    task . getPath (  )  ;", "}", "return   new    (  )     {", "public   Path   getPath (  )     {", "return   Path . path ( path )  ;", "}", "public   String   getDescription (  )     {", "return   task . getDescription (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskDetailsFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( defaultTaskNames . size (  )  )     >     0  )     {", "getTextOutput (  )  . formatln (  \" Default    :     % s \"  ,    CollectionUtils . join (  \"  ,     \"  ,    defaultTaskNames )  )  ;", "hasContent    =    true ;", "}", "}", "METHOD_END"], "methodName": ["addDefaultTasks"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( currentProjectHasRu )  )     {", "addSubheading (  \" Ru \"  )  ;", "}", "getTextOutput (  )  . println ( GUtil . elvis ( rugetDescription (  )  ,     \"  \"  )  )  ;", "currentProjectHasRu    =    true ;", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( hasContent )     {", "getTextOutput (  )  . println (  )  ;", "}", "hasContent    =    true ;", "getBuilder (  )  . subheading ( header )  ;", "}", "METHOD_END"], "methodName": ["addSubheading"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "writeTask ( task ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["addTask"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( currentProjectHasTasks )  )     {", "getTextOutput (  )  . withStyle ( Info )  . println (  \" No    \"  )  ;", "hasContent    =    true ;", "}", "}", "METHOD_END"], "methodName": ["completeTasks"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "this . detail    =    detail ;", "}", "METHOD_END"], "methodName": ["showDetail"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( GUtil . isTrue ( taskGroup )  )  )     {", "addSubheading (  \" Tasks \"  )  ;", "} else    {", "addSubheading (  (  ( StringUtils . capitalize ( taskGroup )  )     +     \"     \"  )  )  ;", "}", "currentProjectHasTasks    =    true ;", "}", "METHOD_END"], "methodName": ["startTaskGroup"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "getTextOutput (  )  . text ( prefix )  ;", "getTextOutput (  )  . withStyle ( Identifier )  . text (  . getPath (  )  )  ;", "if    ( GUtil . isTrue (  . getDescription (  )  )  )     {", "getTextOutput (  )  . withStyle ( Description )  . format (  \"     -     % s \"  ,     . getDescription (  )  )  ;", "}", "getTextOutput (  )  . println (  )  ;", "}", "METHOD_END"], "methodName": ["writeTask"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TaskReportRenderer"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    ( close )     {", "CompositeStoppabstoppabtextOutput )  . stop (  )  ;", "}", "}    finally    {", "textOutput    =    null ;", "}", "}", "METHOD_END"], "methodName": ["cleanupWriter"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "String   header ;", "if    (  ( project . getRootProject (  )  )     =  =    project )     {", "header    =     \" Root   project \"  ;", "} else    {", "header    =     \" Project    \"     +     ( project . getPath (  )  )  ;", "}", "if    ( GUtil . isTrue ( project . getDescription (  )  )  )     {", "header    =     ( header    +     \"     -     \"  )     +     ( project . getDescription (  )  )  ;", "}", "return   header ;", "}", "METHOD_END"], "methodName": ["createHeader"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   builder ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   clientMetaData ;", "}", "METHOD_END"], "methodName": ["getClientMetaData"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   textOutput ;", "}", "METHOD_END"], "methodName": ["getTextOutput"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "this . fileResolver    =    fileResolver ;", "}", "METHOD_END"], "methodName": ["setFileResolver"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "this . textOutput    =    styledTextOutput ;", "this . builder    =    new   DefaultBuilder ( textOutput ,    fileResolver )  ;", "this . close    =    close ;", "}", "METHOD_END"], "methodName": ["setWriter"], "fileName": "org.gradle.api.tasks.diagnostics.internal.TextReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . isTrue ( configuration . getDescription (  )  )     ?     \"     -     \"     +     ( configuration . getDescription (  )  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.tasks.diagnostics.internal.dependencies.AsciiDependencyReportRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( root . getChildren (  )  . isEmpty (  )  )     {", "getTextOutput (  )  . withStyle ( Info )  . text (  \" No    \"  )  ;", "getTextOutput (  )  . println (  )  ;", "return ;", "}", "dependencyGraphRenderer . render ( root )  ;", "}", "METHOD_END"], "methodName": ["renderNow"], "fileName": "org.gradle.api.tasks.diagnostics.internal.dependencies.AsciiDependencyReportRenderer"}, {"methodBody": ["METHOD_START", "{", "ComponentSetor   requested    =    candidate . getRequested (  )  ;", "if    ( requested   instanceof   ModuomponentSetor )     {", "ModuomponentSetor   requestedModu =     (  ( ModuomponentSetor )     ( requested )  )  ;", "String   requestedCandidate    =     (  (  (  ( requestedModugetGroup (  )  )     +     \"  :  \"  )     +     ( requestedModugetModu )  )  )     +     \"  :  \"  )     +     ( requestedModugetVersionConstraint (  )  . getPreferredVersion (  )  )  ;", "return   requestedCandidate . contains ( stringNotation )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["matchesRequested"], "fileName": "org.gradle.api.tasks.diagnostics.internal.dsl.DependencyResultSpec"}, {"methodBody": ["METHOD_START", "{", "ModuleVersionIdentifier   selected    =    candidate . getSelected (  )  . getModuleVersion (  )  ;", "String   selectedCandidate    =     (  (  (  ( selected . getGroup (  )  )     +     \"  :  \"  )     +     ( selected . getModule (  )  )  )     +     \"  :  \"  )     +     ( selected . getVersion (  )  )  ;", "return   selectedCandidate . contains ( stringNotation )  ;", "}", "METHOD_END"], "methodName": ["matchesSelected"], "fileName": "org.gradle.api.tasks.diagnostics.internal.dsl.DependencyResultSpec"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( new   TypeInfo < Spec < DependencyResult >  >  ( class )  )  . invalidNotationMessage (  \" Please   check   the   input   for   the   DependencyInsight . dependency   element .  \"  )  . fromType ( Closure . class ,    new   ClosureToSpecNotationConverter < DependencyResult >  ( DependencyResult . class )  )  . fromCharSequence ( new   DependencyResultSpecNotationConverter (  )  )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.api.tasks.diagnostics.internal.dsl.DependencyResultSpecNotationConverter"}, {"methodBody": ["METHOD_START", "{", "Set <  ?    extends   RenderableDependency >    children    =    node . getChildren (  )  ;", "final   boolean   alreadyRendered    =     !  ( visited . add ( node . getId (  )  )  )  ;", "if    ( alreadyRendered )     {", "legendRenderer . setHasCyclicDependencies ( true )  ;", "}", "renderer . visit ( new   Action < StyledTextOutput >  (  )     {", "public   void   execute ( StyledTextOutput   output )     {", "nodeRenderer . renderNode ( output ,    node ,    alreadyRendered )  ;", "}", "}  ,    last )  ;", "if    (  ! alreadyRendered )     {", "renderChildren ( children ,    visited )  ;", "}", "}", "METHOD_END"], "methodName": ["doRender"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.DependencyGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( root   instanceof   UnresolvableConfigurationResult )     {", "legend . setHasUnresolvableConfigurations ( true )  ;", "}", "HashSet < Object >    visited    =    Sets . newHashSet (  )  ;", "visited . add ( root . getId (  )  )  ;", "renderChildren ( root . getChildren (  )  ,    visited )  ;", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.DependencyGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "renderer . startChildren (  )  ;", "Integer   i    =     0  ;", "for    ( Renderable   child    :    children )     {", "boolean   last    =     ( i +  +  )     =  =     (  ( children . size (  )  )     -     1  )  ;", "doRender ( child ,    last ,    visited )  ;", "}", "renderer . completeChildren (  )  ;", "}", "METHOD_END"], "methodName": ["renderChildren"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.DependencyGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( hasCyclicDependencies )     {", "output . println (  )  ;", "output . withStyle ( Info )  . println (  \"  (  *  )     -    dependencies   omitted    ( listed   previously )  \"  )  ;", "}", "if    ( hasUnresolvableConfigurations )     {", "output . println (  )  ;", "output . withStyle ( Info )  . println (  \"  ( n )     -    Not   resolved    ( configuration   is   not   meant   to   be   resolved )  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["printLegend"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.LegendRenderer"}, {"methodBody": ["METHOD_START", "{", "this . hasCyclicDependencies    =    hasCyclicDependencies ;", "}", "METHOD_END"], "methodName": ["setHasCyclicDependencies"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.LegendRenderer"}, {"methodBody": ["METHOD_START", "{", "this . hasUnresolvableConfigurations    =    hasUnresolvableConfigurations ;", "}", "METHOD_END"], "methodName": ["setHasUnresolvableConfigurations"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.LegendRenderer"}, {"methodBody": ["METHOD_START", "{", "return   getRequested (  )  . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getSimpleName"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.AbstractRenderableDependencyResult"}, {"methodBody": ["METHOD_START", "{", "return    (  ( requested . getGroup (  )  . equals ( selected . getGroup (  )  )  )     &  &     ( requested . getModule (  )  . equals ( selected . getModule (  )  )  )  )     &  &     (  !  ( requested . getVersionConstraint (  )  . getPreferredVersion (  )  . equals ( selected . getVersion (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSameGroupAndModuleButDifferentVersion"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.AbstractRenderableDependencyResult"}, {"methodBody": ["METHOD_START", "{", "children . addAll ( child . getChildren (  )  )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.RequestedVersion"}, {"methodBody": ["METHOD_START", "{", "String   lastCustomReason    =    null ;", "for    ( ComponentDescriptor   descriptor    :    reason . getDescriptions (  )  )     {", "if    (  (  ( ComponentDescriptorInternal )     ( descriptor )  )  . hasCustomDescription (  )  )     {", "lastCustomReason    =    descriptor . getDescription (  )  ;", "}", "}", "return   lastCustomReason ;", "}", "METHOD_END"], "methodName": ["getLastCustomReason"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SelectionReasonHelper"}, {"methodBody": ["METHOD_START", "{", "ComponentSelectionReasonInternal   r    =     (  ( ComponentSelectionReasonInternal )     ( reason )  )  ;", "String   description    =     . getReasonDescription ( r )  ;", "if    ( reason . isConstrained (  )  )     {", "if    (  !  ( r . hasCustomDescriptions (  )  )  )     {", "return    \" via   constraint \"  ;", "} else    {", "return    \" via   constraint ,     \"     +    description ;", "}", "}", "return   description ;", "}", "METHOD_END"], "methodName": ["getReasonDescription"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SelectionReasonHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( reason . hasCustomDescriptions (  )  )  )     {", "return   reason . isExpected (  )     ?    null    :    Iterables . getLast ( reason . getDescriptions (  )  )  . getDescription (  )  ;", "}", "return    . getLastCustomReason ( reason )  ;", "}", "METHOD_END"], "methodName": ["getReasonDescription"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SelectionReasonHelper"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SimpleDependency"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SimpleDependency"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SimpleDependency"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SimpleDependency"}, {"methodBody": ["METHOD_START", "{", "return   resolvable    ?    RenderableDependency . ResolutionState . RESOLVED    :    RenderableDependency . ResolutionState . FAILED ;", "}", "METHOD_END"], "methodName": ["getResolutionState"], "fileName": "org.gradle.api.tasks.diagnostics.internal.graph.nodes.SimpleDependency"}, {"methodBody": ["METHOD_START", "{", "LinkedList < RenderableDependency >    out    =    new   LinkedList < RenderableDependency >  (  )  ;", "List < DependencyEdge >    dependencies    =    CollectionUtils . collect ( input ,    new   Transformer < DependencyEdge ,    DependencyResult >  (  )     {", "@ Override", "public   DependencyEdge   transform ( DependencyResult   result )     {", "if    ( result   instanceof   UnresolvedDependencyResult )     {", "return   new   UnresolvedDependencyEdge (  (  ( UnresolvedDependencyResult )     ( result )  )  )  ;", "} else    {", "return   new   ResolvedDependencyEdge (  (  ( ResolvedDependencyResult )     ( result )  )  )  ;", "}", "}", "}  )  ;", "Collection < DependencyEdge >    sorted    =    DependencyResultSorter . sort ( dependencies ,    versionSelectorScheme ,    versionComparator )  ;", "HashSet < ComponentIdentifier >    annotated    =    new   HashSet < ComponentIdentifier >  (  )  ;", "RequestedVersion   current    =    null ;", "for    ( DependencyEdge   dependency    :    sorted )     {", "ResolvedVariantResult   selectedVariant    =    dependency . getSelectedVariant (  )  ;", "if    ( annotated . add ( dependency . getActual (  )  )  )     {", "if    (  !  ( dependency . getRequested (  )  . matchesStrictly ( dependency . getActual (  )  )  )  )     {", "out . add ( new   DependencyReportHeader ( dependency ,    selectedVariant )  )  ;", "current    =    new   RequestedVersion ( dependency . getRequested (  )  ,    dependency . getActual (  )  ,    dependency . isResolvable (  )  ,    null ,    selectedVariant )  ;", "out . add ( current )  ;", "} else    {", "current    =    new   RequestedVersion ( dependency . getRequested (  )  ,    dependency . getActual (  )  ,    dependency . isResolvable (  )  ,    SelectionReasonHelper . getReasonDescription ( dependency . getReason (  )  )  ,    selectedVariant )  ;", "out . add ( current )  ;", "}", "} else", "if    (  !  ( current . getRequested (  )  . equals ( dependency . getRequested (  )  )  )  )     {", "current    =    new   RequestedVersion ( dependency . getRequested (  )  ,    dependency . getActual (  )  ,    dependency . isResolvable (  )  ,    null ,    selectedVariant )  ;", "out . add ( current )  ;", "}", "current . addChild ( dependency )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["prepare"], "fileName": "org.gradle.api.tasks.diagnostics.internal.insight.DependencyInsightReporter"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . sort ( input ,    new   DependencyResultSorter . DependencyComparator ( versionSelectorScheme ,    versionComparator )  )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "org.gradle.api.tasks.diagnostics.internal.insight.DependencyResultSorter"}, {"methodBody": ["METHOD_START", "{", "final   boolean   indent    =     (  ( depth )     >     1  )     |  |     ( hasTitledItems )  ;", "renderItem ( new   Action < TextReportBuilder >  (  )     {", "@ Override", "public   void   execute ( TextReportBuilder   textReportBuilder )     {", "if    ( indent )     {", "textOutput    =    new   LinePrefixingStyledTextOutput ( textOutput ,     . INDENT )  ;", "}", "( depth )  +  +  ;", "action . execute ( textReportBuilder )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["nested"], "fileName": "org.gradle.api.tasks.diagnostics.internal.text.DefaultTextReportBuilder"}, {"methodBody": ["METHOD_START", "{", "StyledTextOutput   original    =    textOutput ;", "int   originalDepth    =    depth ;", "boolean   originalItems    =    hasTitledItems ;", "try    {", "hasTitledItems    =    false ;", "action . execute ( this )  ;", "}    finally    {", "textOutput    =    original ;", "depth    =    originalDepth ;", "hasTitledItems    =    originalItems ;", "}", "}", "METHOD_END"], "methodName": ["renderItem"], "fileName": "org.gradle.api.tasks.diagnostics.internal.text.DefaultTextReportBuilder"}, {"methodBody": ["METHOD_START", "{", "Output . style ( Header )  . println ( heading )  ;", "for    ( int   i    =     0  ;    i    <     ( heading . length (  )  )  ;    i +  +  )     {", "Output (  \"  -  \"  )  ;", "}", "Output . style ( Normal )  . println (  )  ;", "}", "METHOD_END"], "methodName": ["writeSubheading"], "fileName": "org.gradle.api.tasks.diagnostics.internal.text.DefaultTextReportBuilder"}, {"methodBody": ["METHOD_START", "{", "StyledTextOutput   output    =    getTextOutputFactory (  )  . create ( Help . class )  ;", "BuildClientMetaData   metaData    =    getClientMetaData (  )  ;", "if    (  ( taskPath )     !  =    null )     {", "printTaskHelp ( output )  ;", "} else    {", "printDefaultHelp ( output ,    metaData )  ;", "}", "}", "METHOD_END"], "methodName": ["displayHelp"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getClientMetaData"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getOptionReader"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTaskSelector"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getTextOutputFactory"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "output . println (  )  ;", "output . formatln (  \" Welcome   to   Gradle    % s .  \"  ,    GradleVersion . current (  )  . getVersion (  )  )  ;", "output . println (  )  ;", "output . text (  \" To   run   a   build ,    run    \"  )  ;", "metaData . describeCommand ( output . withStyle ( UserInput )  ,     \"  < task >     .  .  .  \"  )  ;", "output . println (  )  ;", "output . println (  )  ;", "output . text (  \" To   see   a   list   of   available   tasks ,    run    \"  )  ;", "metaData . describeCommand ( output . withStyle ( UserInput )  ,     \" tasks \"  )  ;", "output . println (  )  ;", "output . println (  )  ;", "output . text (  \" To   see   a   list   of   command - line   options ,    run    \"  )  ;", "metaData . describeCommand ( output . withStyle ( UserInput )  ,     \"  -  - help \"  )  ;", "output . println (  )  ;", "output . println (  )  ;", "output . text (  \" To   see   more   detail   about   a   task ,    run    \"  )  ;", "metaData . describeCommand ( output . withStyle ( UserInput )  ,     \" help    -  - task    < task >  \"  )  ;", "output . println (  )  ;", "output . println (  )  ;", "output . text (  \" For   troubleshooting ,    visit    \"  )  ;", "output . withStyle ( UserInput )  . text (  \" https :  /  / helporg \"  )  ;", "output . println (  )  ;", "}", "METHOD_END"], "methodName": ["printDefaultHelp"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "TaskSelector   selector    =    getTaskSelector (  )  ;", "TaskSelector . TaskSelec   selec    =    selector . getSelec ( taskPath )  ;", "OpReader   opReader    =    getOpReader (  )  ;", "TaskDetailPrinter   taskDetailPrinter    =    new   TaskDetailPrinter ( taskPath ,    selec ,    opReader )  ;", "taskDetailPrinter . print ( output )  ;", "}", "METHOD_END"], "methodName": ["printTaskHelp"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "this . taskPath    =    taskPath ;", "}", "METHOD_END"], "methodName": ["setTaskPath"], "fileName": "org.gradle.configuration.Help"}, {"methodBody": ["METHOD_START", "{", "return   createIndentedOutput ( output ,    StringUtils . leftPad (  \"  \"  ,    offset ,     '     '  )  )  ;", "}", "METHOD_END"], "methodName": ["createIndentedOutput"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "return   new   LinePrefixingStyledTextOutput ( output ,    prefix ,    false )  ;", "}", "METHOD_END"], "methodName": ["createIndentedOutput"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "Class   clazz    =    new   DslObject ( original )  . getDeclaredType (  )  ;", "if    ( clazz . equals ( DefaultTask . class )  )     {", "return   Task . class ;", "} else    {", "return   clazz ;", "}", "}", "METHOD_END"], "methodName": ["getDeclaredTaskType"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "final   Set < Class >    taskTypes    =    new   TreeSet < Class >  ( new   Comparator < Class >  (  )     {", "public   int   compare ( Class   o 1  ,    Class   o 2  )     {", "return   o 1  . getSimpleName (  )  . compareTo ( o 2  . getSimpleName (  )  )  ;", "}", "}  )  ;", "taskTypes . addAll ( collect ( tasks ,    new   api . Transformer < Class ,    Task >  (  )     {", "public   Class   transform ( Task   original )     {", "return   getDeclaredTaskType ( original )  ;", "}", "}  )  )  ;", "ListMultimap < Class ,    Task >    tasksGroupedByType    =    ArrayListMultimap . create (  )  ;", "for    ( final   Class   taskType    :    taskTypes )     {", "tasksGroupedByType . putAll ( taskType ,    filter ( tasks ,    new   api . specs . Spec < Task >  (  )     {", "public   boolean   isSatisfiedBy ( Task   element )     {", "return   getDeclaredTaskType ( element )  . equals ( taskType )  ;", "}", "}  )  )  ;", "}", "return   tasksGroupedByType ;", "}", "METHOD_END"], "methodName": ["groupTasksByType"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Set < String >  >    result    =    new   LinkedHashMap < String ,    Set < String >  >  (  )  ;", "for    ( OptionDescriptor   optionDescriptor    :    allOptions )     {", "if    ( result . containsKey ( optionDescriptor . getName (  )  )  )     {", "Collection < String >    commonValues    =    CollectionUtils . section ( optionDescriptor . getAvailableValues (  )  ,    result . get ( optionDescriptor . getName (  )  )  )  ;", "result . put ( optionDescriptor . getName (  )  ,    new   TreeSet < String >  ( commonValues )  )  ;", "} else    {", "result . put ( optionDescriptor . getName (  )  ,    optionDescriptor . getAvailableValues (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["optionToAvailableValues"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    new   HashMap < String ,    String >  (  )  ;", "for    ( OpDescriptor   opDescriptor    :    allOps )     {", "result . put ( opDescriptor . getName (  )  ,    opDescriptor . getDescrip (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["optionToDescription"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "final   List < Task >    tasks    =    sort ( selection . getTasks (  )  )  ;", "output . text (  \" Detailed   task   information   for    \"  )  . withStyle ( UserInput )  . println ( taskPath )  ;", "final   ListMultimap < Class ,    Task >    classListMap    =    groupTasksByType ( tasks )  ;", "final   Set < Class >    classes    =    classListMap . keySet (  )  ;", "boolean   multipleClasses    =     ( classes . size (  )  )     >     1  ;", "final   List < Class >    sortedClasses    =    sort ( classes ,    new   Comparator < Class >  (  )     {", "public   int   compare ( Class   o 1  ,    Class   o 2  )     {", "return   o 1  . getSimpleName (  )  . compareTo ( o 2  . getSimpleName (  )  )  ;", "}", "}  )  ;", "for    ( Class   clazz    :    sortedClasses )     {", "output . println (  )  ;", "final   List < Task >    tasksByType    =    classListMap . get ( clazz )  ;", "final   LinePrefixingStyledTextOutput   pathOutput    =    createIndentedOutput ( output ,     . INDENT )  ;", "pathOutput . println (  (  ( tasksByType . size (  )  )     >     1     ?     \" Paths \"     :     \" Path \"  )  )  ;", "for    ( Task   task    :    tasksByType )     {", "pathOutput . withStyle ( UserInput )  . println ( task . getPath (  )  )  ;", "}", "output . println (  )  ;", "final   LinePrefixingStyledTextOutput   typeOutput    =    createIndentedOutput ( output ,     . INDENT )  ;", "typeOutput . println (  \" Type \"  )  ;", "typeOutput . withStyle ( UserInput )  . text ( clazz . getSimpleName (  )  )  ;", "typeOutput . println (  (  (  \"     (  \"     +     ( clazz . getName (  )  )  )     +     \"  )  \"  )  )  ;", "printlnCommandlineOptions ( output ,    tasksByType )  ;", "output . println (  )  ;", "printTaskDescription ( output ,    tasksByType )  ;", "output . println (  )  ;", "printTaskGroup ( output ,    tasksByType )  ;", "if    ( multipleClasses )     {", "output . println (  )  ;", "output . println (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["print"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "int   count    =    collect ( tasks ,    new   HashSet < String >  (  )  ,    transformer )  . size (  )  ;", "final   LinePrefixingStyledTextOutput   attributeOutput    =    createIndentedOutput ( output ,     . INDENT )  ;", "if    ( count    =  =     1  )     {", "attributeOutput . println ( attributeHeader )  ;", "final   Task   task    =    tasks . iterator (  )  . next (  )  ;", "String   value    =    transformer . transform ( task )  ;", "attributeOutput . println (  ( value    =  =    null    ?     \"  -  \"     :    value )  )  ;", "} else    {", "attributeOutput . println (  ( attributeHeader    +     \" s \"  )  )  ;", "for    ( Task   task    :    tasks )     {", "attributeOutput . withStyle ( UserInput )  . text (  (  (  \"  (  \"     +     ( task . getPath (  )  )  )     +     \"  )     \"  )  )  ;", "String   value    =    transformer . transform ( task )  ;", "attributeOutput . println (  ( value    =  =    null    ?     \"  -  \"     :    value )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printTaskAttribute"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "printTaskAttribute ( output ,     \" Description \"  ,    tasks ,    new   Transformer < String ,    Task >  (  )     {", "public   String   transform ( Task   task )     {", "return   task . getDescription (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["printTaskDescription"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "printTaskAttribute ( output ,     \" Group \"  ,    tasks ,    new   Transformer < String ,    Task >  (  )     {", "public   String   transform ( Task   task )     {", "return   task . getGroup (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["printTaskGroup"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}, {"methodBody": ["METHOD_START", "{", "List < OptionDescriptor >    allOptions    =    new   ArrayList < OptionDescriptor >  (  )  ;", "for    ( Task   task    :    tasks )     {", "allOptions . addAll ( optionReader . getOptions ( task )  )  ;", "}", "if    (  !  ( allOptions . isEmpty (  )  )  )     {", "output . println (  )  ;", "output . text (  \" Options \"  )  . println (  )  ;", "}", "Map < String ,    Set < String >  >    optionToAvailableOptionsValues    =    optionToAvailableValues ( allOptions )  ;", "Map < String ,    String >    optionToDescription    =    optionToDescription ( allOptions )  ;", "Iterator < String >    optionNames    =    optionToAvailableOptionsValues . keySet (  )  . iterator (  )  ;", "while    ( optionNames . hasNext (  )  )     {", "String   currentOption    =    optionNames . next (  )  ;", "Set < String >    availableValues    =    optionToAvailableOptionsValues . get ( currentOption )  ;", "String   optionString    =     \"  -  -  \"     +    currentOption ;", "output . text (  . INDENT )  . withStyle ( UserInput )  . text ( optionString )  ;", "output . text (  . INDENT )  . text ( optionToDescription . get ( currentOption )  )  ;", "if    (  !  ( availableValues . isEmpty (  )  )  )     {", "final   int   optionDescriptionOffset    =     (  2     *     (  . INDENT . length (  )  )  )     +     ( optionString . length (  )  )  ;", "final   LinePrefixingStyledTextOutput   prefixedOutput    =    createIndentedOutput ( output ,    optionDescriptionOffset )  ;", "prefixedOutput . println (  )  ;", "prefixedOutput . println (  \" Available   values   are :  \"  )  ;", "for    ( String   value    :    availableValues )     {", "prefixedOutput . text (  . INDENT )  ;", "prefixedOutput . withStyle ( UserInput )  . println ( value )  ;", "}", "} else    {", "output . println (  )  ;", "}", "if    ( optionNames . hasNext (  )  )     {", "output . println (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printlnCommandlineOptions"], "fileName": "org.gradle.configuration.TaskDetailPrinter"}]