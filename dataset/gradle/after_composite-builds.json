[{"methodBody": ["METHOD_START", "{", "if    ( artifact   instanceof   CompositeProjectComponentArtifactMetadata )     {", "CompositeProjectComponentArtifactMetadata   cArtifact    =     (  ( CompositeProjectComponentArtifactMetadata )     ( artifact )  )  ;", "BuildIdentifier   targetBuild    =    getBuildIdentifier ( cArtifact )  ;", "assert    !  ( requestingBuild . equals ( targetBuild )  )  ;", "Set < String >    tasks    =    cArtifact . getTasks (  )  ;", "for    ( String   taskName    :    tasks )     {", "includedBuildTaskGraph . addTask ( requestingBuild ,    targetBuild ,    taskName )  ;", "}", "for    ( String   taskName    :    tasks )     {", "includedBuildTaskGraph . awaitCompletion ( targetBuild ,    taskName )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.composite.internal.CompositeBuildClassPathInitializer"}, {"methodBody": ["METHOD_START", "{", "return   artifact . getComponentId (  )  . getBuild (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildIdentifier"], "fileName": "org.gradle.composite.internal.CompositeBuildClassPathInitializer"}, {"methodBody": ["METHOD_START", "{", "ModuleIdentifier   candidateId    =    moduleIdentifierFactory . module ( selector . getGroup (  )  ,    selector . getModule (  )  )  ;", "Collection < ProjectComponentIdentifier >    providingProjects    =    replacementMap . get ( candidateId )  ;", "if    ( providingProjects . isEmpty (  )  )     {", ". LOGGER . debug (  (  (  \" Found   no   composite   build   substitute   for   module    '  \"     +    candidateId )     +     \"  '  .  \"  )  )  ;", "return   null ;", "}", "if    (  ( providingProjects . size (  )  )     =  =     1  )     {", "ProjectComponentIdentifier   match    =    providingProjects . iterator (  )  . next (  )  ;", ". LOGGER . info (  (  (  (  (  \" Found   project    '  \"     +    match )     +     \"  '    as   substitute   for   module    '  \"  )     +    candidateId )     +     \"  '  .  \"  )  )  ;", "return   match ;", "}", "SortedSet < String >    sortedProjects    =    Sets . newTreeSet ( CollectionUtils . collect ( providingProjects ,    new   Transformer < String ,    ProjectComponentIdentifier >  (  )     {", "@ Override", "public   String   transform ( ProjectComponentIdentifier   projectComponentIdentifier )     {", "return   projectComponentIdentifier . getDisplayName (  )  ;", "}", "}  )  )  ;", "String   failureMessage    =    String . format (  \" Module   version    '  % s '    is   not   unique   in   composite :    can   be   provided   by    % s .  \"  ,    selector . getDisplayName (  )  ,    sortedProjects )  ;", "throw   new   ModuleVersionResolveException ( selector ,    failureMessage )  ;", "}", "METHOD_END"], "methodName": ["getReplacementFor"], "fileName": "org.gradle.composite.internal.CompositeBuildDependencySubstitutions"}, {"methodBody": ["METHOD_START", "{", "return   build ;", "}", "METHOD_END"], "methodName": ["getBuild"], "fileName": "org.gradle.composite.internal.CompositeBuildTaskDelegate"}, {"methodBody": ["METHOD_START", "{", "return   taskPath ;", "}", "METHOD_END"], "methodName": ["getTaskPath"], "fileName": "org.gradle.composite.internal.CompositeBuildTaskDelegate"}, {"methodBody": ["METHOD_START", "{", "this . build    =    build ;", "}", "METHOD_END"], "methodName": ["setBuild"], "fileName": "org.gradle.composite.internal.CompositeBuildTaskDelegate"}, {"methodBody": ["METHOD_START", "{", "this . taskPath    =    taskPath ;", "}", "METHOD_END"], "methodName": ["setTaskPath"], "fileName": "org.gradle.composite.internal.CompositeBuildTaskDelegate"}, {"methodBody": ["METHOD_START", "{", "return   tasks ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.composite.internal.CompositeProjectComponentArtifactMetadata"}, {"methodBody": ["METHOD_START", "{", "RegisteredProject   registeredProject    =    projectMetadata . get ( project )  ;", "BuildIdentifier   buildIdentifier    =    project . getBuild (  )  ;", "if    (  ( registeredProject    =  =    null )     &  &     (  !  ( configuredBuilds . contains ( buildIdentifier )  )  )  )     {", "configuredBuilds . add ( buildIdentifier )  ;", "IncludedBuildI   includedBuild    =    includedBuildRegistry . getBuild ( buildIdentifier )  ;", "if    ( includedBuild    !  =    null )     {", "projectMetadata . putAll ( dependencyMetadataBuilder . build ( includedBuild )  )  ;", "registeredProject    =    projectMetadata . get ( project )  ;", "if    ( registeredProject    =  =    null )     {", "throw   new   IllegalStateException (  ( project    +     \"    was   not   found .  \"  )  )  ;", "}", "}", "}", "return   registeredProject ;", "}", "METHOD_END"], "methodName": ["getRegisteredProject"], "fileName": "org.gradle.composite.internal.DefaultBuildableCompositeBuildContext"}, {"methodBody": ["METHOD_START", "{", "getGradleLauncher (  )  . scheduleTasks ( taskPaths )  ;", "}", "METHOD_END"], "methodName": ["addTasks"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( gradleLauncher )     !  =    null )     &  &     ( discardLauncher )  )     {", "try    {", "gradleLauncher . stop (  )  ;", "}    finally    {", "gradleLauncher    =    null ;", "discardLauncher    =    false ;", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupLauncherIfRequired"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "if    (  ( gradleLauncher )     =  =    null )     {", "gradleLauncher    =    gradleLauncherFactory . nestedInstance ( buildDefinition . newInstance (  )  )  ;", "}", "return   gradleLauncher ;", "}", "METHOD_END"], "methodName": ["getGradleLauncher"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectComponentIdentifier ( new   ForeignBuildIdentifier ( getName (  )  )  ,    projectPath )  ;", "}", "METHOD_END"], "methodName": ["idForProjectInThisBuild"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "discardLauncher    =    true ;", "}", "METHOD_END"], "methodName": ["markAsNotReusable"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "LocalComponentRegistry   localComponentRegistry    =    project . getServices (  )  . get ( LocalComponentRegistry . class )  ;", "ProjectComponentIdentifier   originalIdentifier    =    newProjectId ( project )  ;", "DefaultLocalComponentMetadata   originalComponent    =     (  ( DefaultLocalComponentMetadata )     ( localComponentRegistry . getComponent ( originalIdentifier )  )  )  ;", "ProjectComponentIdentifier   componentIdentifier    =    idForProjectInThisBuild ( project . getPath (  )  )  ;", "ModuleVersionIdentifier   moduleId    =    originalComponent . getModuleVersionId (  )  ;", ". LOGGER . info (  (  (  (  (  \" Registering    \"     +    project )     +     \"    in   composite   build .    Will   substitute   for   module    '  \"  )     +     ( moduleId . getModule (  )  )  )     +     \"  '  .  \"  )  )  ;", "availableModules . add ( Pair . of ( moduleId ,    componentIdentifier )  )  ;", "}", "METHOD_END"], "methodName": ["registerProject"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuild"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "for    ( String   task    :    tasksExecuted )     {", ". TaskState   taskState    =    tasks . get ( task )  ;", "if    (  ( taskState . status )     =  =     (  . TaskStatus . EXECUTING )  )     {", "taskState . status    =     . TaskStatus . FAILED ;", "taskState . failure    =    failure ;", "}", "}", "taskCompleted . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildFailed"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "if    ( tasksToExecute . isEmpty (  )  )     {", "return ;", "}", ". LOGGER . info (  (  (  (  \" Executing    \"     +     ( includedBuild . getName (  )  )  )     +     \"    tasks    \"  )     +    tasksToExecute )  )  ;", ". IncludedBuildExecutionListener   listener    =    new    . IncludedBuildExecutionListener ( tasksToExecute )  ;", "includedBuild . execute ( tasksToExecute ,    listener )  ;", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  !  ( stopRequested . get (  )  )  )     {", "Set < String >    tasksToExecute    =    Sets . newLinkedHashSet (  )  ;", "for    ( Map . Entry < String ,     . TaskState >    taskEntry    :    tasks . entrySet (  )  )     {", "if    (  ( taskEntry . getValue (  )  . status )     =  =     (  . TaskStatus . QUEUED )  )     {", "tasksToExecute . add ( taskEntry . getKey (  )  )  ;", "taskEntry . getValue (  )  . status    =     . TaskStatus . EXECUTING ;", "}", "}", "if    (  !  ( tasksToExecute . isEmpty (  )  )  )     {", "return   tasksToExecute ;", "}", "try    {", "taskQueued . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getQueuedTasks"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", ". TaskState   state    =    tasks . get ( taskPath )  ;", "if    ( state    =  =    null )     {", "throw   new   IllegalStateException (  (  (  \" Included   build   task    '  \"     +    taskPath )     +     \"  '    was   never   scheduled   for   execution .  \"  )  )  ;", "}", "if    (  ( state . status )     =  =     (  . TaskStatus . FAILED )  )     {", "throw   UncheckedException . throwAsUncheckedException ( state . failure )  ;", "}", "return    ( state . status )     =  =     (  . TaskStatus . SUCCESS )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "stopRequested . set ( true )  ;", "started . countDown (  )  ;", "lock . lock (  )  ;", "try    {", "taskQueued . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "try    {", "stopped . await (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", ". TaskState   taskState    =    tasks . get ( task )  ;", "taskState . status    =     ( failure    =  =    null )     ?     . TaskStatus . SUCCESS    :     . TaskStatus . FAILED ;", "taskState . failure    =    failure ;", "taskCompleted . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["taskCompleted"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildController"}, {"methodBody": ["METHOD_START", "{", "IncludedBuildController   buildController    =    buildControllers . get ( buildId )  ;", "if    ( buildController    !  =    null )     {", "return   buildController ;", "}", "IncludedBuildInternal   build    =    includedBuildRegistry . getBuild ( buildId )  ;", "newBuildController    =    new    ( build )  ;", "buildControllers . put ( buildId ,    newBuildController )  ;", "executorService . submit ( newBuildController )  ;", "return   newBuildController ;", "}", "METHOD_END"], "methodName": ["getBuildController"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildControllers"}, {"methodBody": ["METHOD_START", "{", "boolean   tasksDiscovered    =    true ;", "while    ( tasksDiscovered )     {", "tasksDiscovered    =    false ;", "for    (    buildController    :    ImmutableList . copyOf ( buildControllers . values (  )  )  )     {", "if    ( buildController . populateTaskGraph (  )  )     {", "tasksDiscovered    =    true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["populateTaskGraphs"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildControllers"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( dir . exists (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \"    build    '  % s '    does   not   exist .  \"  ,    dir )  )  ;", "}", "if    (  !  ( dir . isDirectory (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \"    build    '  % s '    is   not   a   directory .  \"  ,    dir )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateBuildDirectory"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildFactory"}, {"methodBody": ["METHOD_START", "{", "return    !  ( includedBuilds . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasIncludedBuilds"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "IncludedBuildInternal   includedBuild    =    includedBuilds . get ( buildDefinition . getBuildRootDir (  )  )  ;", "if    ( includedBuild    =  =    null )     {", "includedBuild    =    includedBuildFactory . createBuild ( buildDefinition ,    nestedBuildFactory )  ;", "includedBuilds . put ( buildDefinition . getBuildRootDir (  )  ,    includedBuild )  ;", "}", "return   includedBuild ;", "}", "METHOD_END"], "methodName": ["registerBuild"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( IncludedBuildInternal   includedBuild    :    includedBuilds )     {", "Path   rootProjectPath    =    ROOT . child ( includedBuild . getName (  )  )  ;", "BuildIdentifier   buildIdentifier    =    new   DefaultBuildIdentifier ( includedBuild . getName (  )  )  ;", "Set < DefaultProjectDescriptor >    allProjects    =    includedBuild . getLoadedSettings (  )  . getProjectRegistry (  )  . getAllProjects (  )  ;", "registerProjects ( rootProjectPath ,    buildIdentifier ,    allProjects ,    isImplicitBuild )  ;", "}", "}", "METHOD_END"], "methodName": ["registerProjects"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( DefaultProjectDescriptor   project    :    allProjects )     {", "Path   projectIdentityPath    =    rootPath . append ( project . path (  )  )  ;", "ProjectComponentIdentifier   projectComponentIdentifier    =    DefaultProjectComponentIdentifier . newProjectId ( buildIdentifier ,    project . getPath (  )  )  ;", "project . add ( projectIdentityPath ,    project . getName (  )  ,    projectComponentIdentifier ,    isImplicitBuild )  ;", "}", "}", "METHOD_END"], "methodName": ["registerProjects"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "ProjectRegistry < DefaultProjectDescriptor >    settingsProjectRegistry    =    settings . getProjectRegistry (  )  ;", "BuildIdentifier   buildIdentifier    =    DefaultBuildIdentifier . ROOT ;", "registerProjects ( ROOT ,    buildIdentifier ,    settingsProjectRegistry . getAllProjects (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["registerRootBuildProjects"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( IncludedBuildInternal   includedBuild    :    includedBuilds )     {", "dependencySubstitutionsBuilder . build ( includedBuild )  ;", "}", "}", "METHOD_END"], "methodName": ["registerSubstitutions"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < String >    names    =    Sets . newHashSet (  )  ;", "for    ( Internal   build    :    includedBuilds . values (  )  )     {", "String   buildName    =    build . getName (  )  ;", "if    (  !  ( names . add ( buildName )  )  )     {", "throw   new   GradleException (  (  (  \" Included   build    '  \"     +    buildName )     +     \"  '    is   not   unique   in   composite .  \"  )  )  ;", "}", "if    ( settings . getRootProject (  )  . getName (  )  . equals ( buildName )  )     {", "throw   new   GradleException (  (  (  \" Included   build    '  \"     +    buildName )     +     \"  '    collides   with   root   project   name .  \"  )  )  ;", "}", "if    (  ( settings . findProject (  (  \"  :  \"     +    buildName )  )  )     !  =    null )     {", "throw   new   GradleException (  (  (  \" Included   build    '  \"     +    buildName )     +     \"  '    collides   with   subproject   of   the   same   name .  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateIncludedBuilds"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildRegistry"}, {"methodBody": ["METHOD_START", "{", "candidateCycle . add ( targetBuild )  ;", "for    ( BuildIdentifier   nextTarget    :    buildDependencies . get ( targetBuild )  )     {", "if    ( sourceBuild . equals ( nextTarget )  )     {", "candidateCycle . add ( nextTarget )  ;", "ProjectComponentSelector   selector    =    DefaultProjectComponentSelector . newSelector ( candidateCycle . get (  0  )  ,    ROOT . getPath (  )  )  ;", "throw   new   internal . resolve . ModuleVersionResolveException ( selector ,     (  \" Included   build   dependency   cycle :     \"     +     ( reportCycle ( candidateCycle )  )  )  )  ;", "}", "checkNoCycles ( sourceBuild ,    nextTarget ,    candidateCycle )  ;", "}", "candidateCycle . remove ( targetBuild )  ;", "}", "METHOD_END"], "methodName": ["checkNoCycles"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildTaskGraph"}, {"methodBody": ["METHOD_START", "{", "return   includedBuilds . getBuildController ( buildId )  ;", "}", "METHOD_END"], "methodName": ["getBuildController"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildTaskGraph"}, {"methodBody": ["METHOD_START", "{", "IncludedBuildController   controller    =    getBuildController ( targetBuild )  ;", "return   controller . isComplete ( taskPath )  ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildTaskGraph"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   cycleReport    =    new   StringBuilder (  )  ;", "for    ( BuildIdentifier   buildIdentifier    :    cycle )     {", "cycleReport . append ( buildIdentifier )  ;", "cycleReport . append (  \"     -  >     \"  )  ;", "}", "cycleReport . append ( cycle . get (  0  )  )  ;", "return   cycleReport . toString (  )  ;", "}", "METHOD_END"], "methodName": ["reportCycle"], "fileName": "org.gradle.composite.internal.DefaultIncludedBuildTaskGraph"}, {"methodBody": ["METHOD_START", "{", "allProjects . put ( projectIdentityPath ,    new   DefaultProjectPathRegistry . ProjectPathEntry ( projectName ,    identifier ,    isImplicitBuild )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.composite.internal.DefaultProjectPathRegistry"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . collect ( CollectionUtils . filter ( allProjects . entrySet (  )  ,    new   Spec < Map . Entry < Path ,    DefaultProjectPathRegistry . ProjectPathEntry >  >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( Map . Entry < Path ,    DefaultProjectPathRegistry . ProjectPathEntry >    entry )     {", "return   isAddedImplicitly    =  =     ( entry . getValue (  )  . isAddedImplicitly )  ;", "}", "}  )  ,    new   Transformer < Path ,    Map . Entry < Path ,    DefaultProjectPathRegistry . ProjectPathEntry >  >  (  )     {", "@ Override", "public   Path   transform ( Map . Entry < Path ,    DefaultProjectPathRegistry . ProjectPathEntry >    entry )     {", "return   entry . getKey (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["filterProjectPaths"], "fileName": "org.gradle.composite.internal.DefaultProjectPathRegistry"}, {"methodBody": ["METHOD_START", "{", "Map < ProjectComponentIdentifier ,    RegisteredProject >    registeredProjects    =    Maps . newHashMap (  )  ;", "Gradle   gradle    =    build . getConfigur (  )  ;", "for    ( Project   project    :    gradle . getRootProject (  )  . getAllprojects (  )  )     {", "registerProject ( registeredProjects ,    build ,     (  ( ProjectInternal )     ( project )  )  )  ;", "}", "return   registeredProjects ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencyMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "return   originalComponentMetadata . copy ( componentIdentifier ,    new   Transformer < LocalComponentArtifactMetadata ,    LocalComponentArtifactMetadata >  (  )     {", "@ Override", "public   LocalComponentArtifactMetadata   transform ( LocalComponentArtifactMetadata   originalArtifact )     {", "File   artifactFile    =    originalArtifact . getFile (  )  ;", "Set < String >    targetTasks    =    getArtifactTasks ( originalArtifact )  ;", "return   new   CompositeProjectComponentArtifactMetadata ( componentIdentifier ,    originalArtifact . getName (  )  ,    artifactFile ,    targetTasks )  ;", "}", "}  ,    new   Transformer < LocalOrigin ,    LocalOrigin >  (  )     {", "@ Override", "public   LocalOrigin   transform ( LocalOrigin   originalDependency )     {", "if    (  ( originalDependency . getSelector (  )  )    instanceof   ProjectComponentSelector )     {", "ProjectComponentSelector   requested    =     (  ( ProjectComponentSelector )     ( originalDependency . getSelector (  )  )  )  ;", "return   originalDependency . withTarget ( DefaultProjectComponentSelector . newSelector ( build ,    requested )  )  ;", "}", "return   originalDependency ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createCompositeCopy"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencyMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "Set < String >    taskPaths    =    Sets . newLinkedHashSet (  )  ;", "Set <  ?    extends   Task >    tasks    =    artifactMetaData . geties (  )  . getDependencies ( null )  ;", "for    ( Task   task    :    tasks )     {", "taskPaths . add ( task . getPath (  )  )  ;", "}", "return   taskPaths ;", "}", "METHOD_END"], "methodName": ["getArtifactTasks"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencyMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "LocalComponentRegistry   localComponentRegistry    =    project . getServices (  )  . get ( LocalComponentRegistry . class )  ;", "ProjectComponentIdentifier   originalIdentifier    =    newProjectId ( project )  ;", "DefaultLocalComponentMetadata   originalComponent    =     (  ( DefaultLocalComponentMetadata )     ( localComponentRegistry . getComponent ( originalIdentifier )  )  )  ;", "ProjectComponentIdentifier   componentIdentifier    =    build . idForProjectInThisBuild ( project . getPath (  )  )  ;", "LocalComponentMetadata   Component    =    createCompositeCopy ( build . getModel (  )  ,    componentIdentifier ,    originalComponent )  ;", "registeredProjects . put ( componentIdentifier ,    new   RegisteredProject ( Component )  )  ;", "}", "METHOD_END"], "methodName": ["registerProject"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencyMetadataBuilder"}, {"methodBody": ["METHOD_START", "{", "DependencySubstitutionsInternal   substitutions    =    resolveDependencySubstitutions ( build )  ;", "if    (  !  ( substitutions . hasRules (  )  )  )     {", ". LOGGER . info (  (  \"  [ composite - build ]    Configuring   build :     \"     +     ( build . getModel (  )  . getProjectDir (  )  )  )  )  ;", "context . addAvailableModules ( build . getAvailableModules (  )  )  ;", "} else    {", "context . registerSubstitution ( substitutions . getRuleAction (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencySubstitutionsBuilder"}, {"methodBody": ["METHOD_START", "{", "DependencySubstitutionsInternal   dependencySubstitutions    =    DefaultDependencySubstitutions . forIncludedBuild ( build . getModel (  )  ,    moduleIdentifierFactory )  ;", "for    ( Action <  ?    super   DependencySubstitutions >    action    :    build . getRegistere (  )  )     {", "action . execute ( dependencySubstitutions )  ;", "}", "return   dependencySubstitutions ;", "}", "METHOD_END"], "methodName": ["resolveDependencySubstitutions"], "fileName": "org.gradle.composite.internal.IncludedBuildDependencySubstitutionsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   buildName ;", "}", "METHOD_END"], "methodName": ["getBuildName"], "fileName": "org.gradle.composite.internal.IncludedBuildTaskReference"}, {"methodBody": ["METHOD_START", "{", "return   taskPath ;", "}", "METHOD_END"], "methodName": ["getTaskPath"], "fileName": "org.gradle.composite.internal.IncludedBuildTaskReference"}]