[{"methodBody": ["METHOD_START", "{", "return   argument ;", "}", "METHOD_END"], "methodName": ["getArgument"], "fileName": "org.gradle.api.InvalidActionClosureException"}, {"methodBody": ["METHOD_START", "{", "return   closure ;", "}", "METHOD_END"], "methodName": ["getClosure"], "fileName": "org.gradle.api.InvalidActionClosureException"}, {"methodBody": ["METHOD_START", "{", "List < Object >    classNames    =    CollectionUtils . collect ( closure . getParameterTypes (  )  ,    new   Transformer < Object ,    Class >  (  )     {", "public   Object   transform ( Class   clazz )     {", "return   clazz . getName (  )  ;", "}", "}  )  ;", "return   String . format (  \" The   closure    '  % s '    is   not   valid   as   an   action   for   argument    '  % s '  .    It   should   accept   no   parameters ,    or   one   compatible   with   type    '  % s '  .    It   accepts    (  % s )  .  \"  ,    closure ,    argument ,    argument . getClass (  )  . getName (  )  ,    CollectionUtils . join (  \"  ,     \"  ,    classNames )  )  ;", "}", "METHOD_END"], "methodName": ["toMessage"], "fileName": "org.gradle.api.InvalidActionClosureException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( closure )     =  =    null )     {", "return ;", "}", "try    {", "if    (  ( configureableAware )     &  &     ( delegate   instanceof   Configurable )  )     {", "(  ( Configurable )     ( delegate )  )  . configure ( closure )  ;", "} else    {", "copy    =     (  (  )     ( closure . clone (  )  )  )  ;", "copy . setResolveStrategy ( resolveStrategy )  ;", "copy . setDelegate ( delegate )  ;", "if    (  ( copy . getMaximumNumberOfParameters (  )  )     =  =     0  )     {", "copy . call (  )  ;", "} else    {", "copy . call ( delegate )  ;", "}", "}", "}    catch    ( groovy   e )     {", "if    (  ( Objects . equal ( e . getType (  )  ,    closure . getClass (  )  )  )     &  &     ( Objects . equal ( e . getMethod (  )  ,     \" doCall \"  )  )  )     {", "throw   new   InvalidActionException ( closure ,    delegate )  ;", "}", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.ClosureBackedAction"}, {"methodBody": ["METHOD_START", "{", "new   ClosureBackedAction < T >  ( closure )  . execute ( delegate )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.ClosureBackedAction"}, {"methodBody": ["METHOD_START", "{", "return   closure ;", "}", "METHOD_END"], "methodName": ["getClosure"], "fileName": "org.gradle.api.internal.ClosureBackedAction"}, {"methodBody": ["METHOD_START", "{", "return   new   ClosureBackedAction < T >  ( closure )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.ClosureBackedAction"}, {"methodBody": ["METHOD_START", "{", "List < Spec < Object >  >    result    =    new   ArrayList < Spec < Object >  >  (  )  ;", "for    ( final   boolean   satisfy    :    satisfies )     {", "result . add ( new   Spec < Object >  (  )     {", "public   boolean   isSatisfiedBy ( Object   o )     {", "return   satisfy ;", "}", "}  )  ;", "}", "return   result . toArray ( new   Spec [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["createAtomicElements"], "fileName": "org.gradle.api.specs.AbstractCompositeSpecTest"}, {"methodBody": ["METHOD_START", "{", "assert   createCompositeSpec ( spec 1  )  . equals ( createCompositeSpec ( spec 1  )  )  ;", "assertFalse ( createCompositeSpec ( spec 1  )  . equals ( createCompositeSpec ( spec 2  )  )  )  ;", "assert   createCompositeSpec ( spec 1  ,    spec 2  )  . equals ( createCompositeSpec ( spec 1  ,    spec 2  )  )  ;", "assert   createCompositeSpec ( spec 2  ,    spec 1  )  . equals ( createCompositeSpec ( spec 2  ,    spec 1  )  )  ;", "assertFalse ( createCompositeSpec ( spec 1  ,    spec 2  )  . equals ( createCompositeSpec ( spec 2  ,    spec 1  )  )  )  ;", "assertFalse ( createCompositeSpec ( spec 1  )  . equals ( createOtherCompositeSpec ( spec 1  )  )  )  ;", "assertFalse ( createCompositeSpec ( spec 2  )  . equals ( createOtherCompositeSpec ( spec 2  )  )  )  ;", "assertFalse ( createCompositeSpec ( spec 1  ,    spec 2  )  . equals ( createOtherCompositeSpec ( spec 1  ,    spec 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equality"], "fileName": "org.gradle.api.specs.AbstractCompositeSpecTest"}, {"methodBody": ["METHOD_START", "{", "CompositeSpec < Object >    compositeSpec    =    createCompositeSpec ( spec 1  ,    spec 2  )  ;", "Assert . assertEquals ( CollectionUtils . flattenCollections ( spec 1  ,    spec 2  )  ,    compositeSpec . getSpecs (  )  )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.gradle.api.specs.AbstractCompositeSpecTest"}, {"methodBody": ["METHOD_START", "{", "spec 1     =    new   Spec < Object >  (  )     {", "public   boolean   isSatisfiedBy ( Object   o )     {", "return   false ;", "}", "}  ;", "spec 2     =    new   Spec < Object >  (  )     {", "public   boolean   isSatisfiedBy ( Object   o )     {", "return   false ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.specs.AbstractCompositeSpecTest"}, {"methodBody": ["METHOD_START", "{", "assert    ( createCompositeSpec ( spec 1  )  . hashCode (  )  )     =  =     ( createCompositeSpec ( spec 1  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 1  )  . hashCode (  )  )     !  =     ( createCompositeSpec ( spec 2  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )     =  =     ( createCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )     =  =     ( createCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )     !  =     ( createCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )     !  =     ( createOtherCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )     !  =     ( createOtherCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )  ;", "assert    ( createCompositeSpec ( spec 1  ,    spec 2  )  . hashCode (  )  )     !  =     ( createOtherCompositeSpec ( spec 2  ,    spec 1  )  . hashCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHashCode"], "fileName": "org.gradle.api.specs.AbstractCompositeSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   and ( new   ClosureSpec < T >  ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.gradle.api.specs.AndSpec"}, {"methodBody": ["METHOD_START", "{", "return   and ( new   Spec [  ]  {    spec    }  )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.gradle.api.specs.AndSpec"}, {"methodBody": ["METHOD_START", "{", "if    (  ( specs . length )     =  =     0  )     {", "return   this ;", "}", "Spec <  ?    super   T >  [  ]    thisSpecs    =     . getSpecsArray (  )  ;", "int   thisLength    =    thisSpecs . length ;", "if    ( thisLength    =  =     0  )     {", "return   new    < T >  ( specs )  ;", "}", "Spec <  ?    super   T >  [  ]    combinedSpecs    =    uncheckedCast ( ObjectArrays . newArray ( Spec . class ,     ( thisLength    +     ( specs . length )  )  )  )  ;", "System . arraycopy ( thisSpecs ,     0  ,    combinedSpecs ,     0  ,    thisLength )  ;", "System . arraycopy ( specs ,     0  ,    combinedSpecs ,    thisLength ,    specs . length )  ;", "return   new    < T >  ( combinedSpecs )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.gradle.api.specs.AndSpec"}, {"methodBody": ["METHOD_START", "{", "return   AndSpec . uncheckedCast ( AndSpec . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["empty"], "fileName": "org.gradle.api.specs.AndSpec"}, {"methodBody": ["METHOD_START", "{", "Spec <  ?    super   T >  [  ]    specs    =    AndSpec . getSpecsArray (  )  ;", "for    ( Spec <  ?    super   T >    spec    :    specs )     {", "if    (  !  ( spec . isSatisfiedBy ( object )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isSatisfiedBy"], "fileName": "org.gradle.api.specs.AndSpec"}, {"methodBody": ["METHOD_START", "{", "AndSpec < Object >    spec    =    new   AndSpec < Object >  ( createAtomicElements ( true )  )  ;", "spec    =    spec . and ( TestUtil . toClosure (  \"  {    false    }  \"  )  )  ;", "assertFalse ( spec . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddClosureAsASpec"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "AndSpec < Object >    spec    =    new   AndSpec < Object >  ( createAtomicElements ( true )  )  ;", "spec    =    spec . and ( createAtomicElements ( false )  )  ;", "assertFalse ( spec . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddSpecs"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   AndSpec < Object >  ( specs )  ;", "}", "METHOD_END"], "methodName": ["createCompositeSpec"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   OrSpec < Object >  ( specs )  ;", "}", "METHOD_END"], "methodName": ["createOtherCompositeSpec"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   AndSpec < Object >  ( createAtomicElements ( true ,    true ,    true )  )  . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedByWithAllTrue"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( new   AndSpec < Object >  ( createAtomicElements ( true ,    false ,    true )  )  . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedByWithOneFalse"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   AndSpec < Object >  (  )  . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedWhenNoSpecs"], "fileName": "org.gradle.api.specs.AndSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   Spec < Boolean >  (  )     {", "public   boolean   isSatisfiedBy ( Boolean   element )     {", "return   element ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createFilterSpec"], "fileName": "org.gradle.api.specs.NotSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( new   NotSpec ( createFilterSpec (  )  )  . isSatisfiedBy ( true )  ,    equalTo ( false )  )  ;", "assertThat ( new   NotSpec ( createFilterSpec (  )  )  . isSatisfiedBy ( false )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testIsSatisfiedBy"], "fileName": "org.gradle.api.specs.NotSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   OrSpec ( specs )  ;", "}", "METHOD_END"], "methodName": ["createCompositeSpec"], "fileName": "org.gradle.api.specs.OrSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   AndSpec < Object >  ( specs )  ;", "}", "METHOD_END"], "methodName": ["createOtherCompositeSpec"], "fileName": "org.gradle.api.specs.OrSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( new   OrSpec ( createAtomicElements ( false ,    false ,    false )  )  . isSatisfiedBy ( context . mock ( Dependency . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedByWithAllFalse"], "fileName": "org.gradle.api.specs.OrSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   OrSpec ( createAtomicElements ( false ,    true ,    false )  )  . isSatisfiedBy ( context . mock ( Dependency . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedByWithOneTrue"], "fileName": "org.gradle.api.specs.OrSpecTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( new   OrSpec (  )  . isSatisfiedBy ( new   Object (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedWhenNoSpecs"], "fileName": "org.gradle.api.specs.OrSpecTest"}, {"methodBody": ["METHOD_START", "{", "return   new   ClosureSpec < T >  ( closure )  ;", "}", "METHOD_END"], "methodName": ["convertClosureToSpec"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "List < Spec <  ?    super   T >  >    filtered    =    new   ArrayList < Spec <  ?    super   T >  >  ( specs . size (  )  )  ;", "for    ( Spec <  ?    super   T >    spec    :    specs )     {", "if    ( spec    =  =     ( Specs . SATISFIES _ NONE )  )     {", "return   Specs . satisfyNone (  )  ;", "}", "if    ( spec    !  =     ( Specs . SATISFIES _ ALL )  )     {", "filtered . add ( spec )  ;", "}", "}", "if    (  ( filtered . size (  )  )     =  =     0  )     {", "return   Specs . satisfyAll (  )  ;", "}", "if    (  ( filtered . size (  )  )     =  =     1  )     {", "return   Cast . uncheckedCast ( filtered . get (  0  )  )  ;", "}", "return   new   AndSpec < T >  ( filtered )  ;", "}", "METHOD_END"], "methodName": ["doIntersect"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "List < Spec <  ?    super   T >  >    filtered    =    new   ArrayList < Spec <  ?    super   T >  >  ( specs . size (  )  )  ;", "for    ( Spec <  ?    super   T >    spec    :    specs )     {", "if    ( spec    =  =     ( Specs . SATISFIES _ ALL )  )     {", "return   Specs . satisfyAll (  )  ;", "}", "if    ( spec    !  =     ( Specs . SATISFIES _ NONE )  )     {", "filtered . add ( spec )  ;", "}", "}", "if    (  ( filtered . size (  )  )     =  =     0  )     {", "return   Specs . satisfyNone (  )  ;", "}", "if    (  ( filtered . size (  )  )     =  =     1  )     {", "return   Cast . uncheckedCast ( filtered . get (  0  )  )  ;", "}", "return   new   OrSpec < T >  ( filtered )  ;", "}", "METHOD_END"], "methodName": ["doUnion"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( specs . size (  )  )     =  =     0  )     {", "return   Specs . satisfyAll (  )  ;", "}", "return   Specs . doIntersect ( specs )  ;", "}", "METHOD_END"], "methodName": ["intersect"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( specs . length )     =  =     0  )     {", "return   Specs . satisfyAll (  )  ;", "}", "if    (  ( specs . length )     =  =     1  )     {", "return   Cast . uncheckedCast ( specs [  0  ]  )  ;", "}", "return   Specs . doIntersect ( Arrays . asList ( specs )  )  ;", "}", "METHOD_END"], "methodName": ["intersect"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "if    ( spec    =  =     ( Specs . SATISFIES _ ALL )  )     {", "return   Specs . satisfyNone (  )  ;", "}", "if    ( spec    =  =     ( Specs . SATISFIES _ NONE )  )     {", "return   Specs . satisfyAll (  )  ;", "}", "if    ( spec   instanceof   NotSpec )     {", "NotSpec <  ?    super   T >    notSpec    =     (  ( NotSpec <  ?    super   T >  )     ( spec )  )  ;", "return   Cast . uncheckedCast ( notSpec . getSourceSpec (  )  )  ;", "}", "return   new   NotSpec < T >  ( spec )  ;", "}", "METHOD_END"], "methodName": ["negate"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( Specs . SATISFIES _ ALL )  ;", "}", "METHOD_END"], "methodName": ["satisfyAll"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( Specs . SATISFIES _ NONE )  ;", "}", "METHOD_END"], "methodName": ["satisfyNone"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( specs . size (  )  )     =  =     0  )     {", "return   Specs . satisfyAll (  )  ;", "}", "return   Specs . doUnion ( specs )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( specs . length )     =  =     0  )     {", "return   Specs . satisfyAll (  )  ;", "}", "if    (  ( specs . length )     =  =     1  )     {", "return   Cast . uncheckedCast ( specs [  0  ]  )  ;", "}", "return   Specs . doUnion ( Arrays . asList ( specs )  )  ;", "}", "METHOD_END"], "methodName": ["union"], "fileName": "org.gradle.api.specs.Specs"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    closure . call ( element )  ;", "return    (  ( Boolean )     ( InvokerHelper . invokeMethod ( value ,     \" asBoolean \"  ,    null )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedBy"], "fileName": "org.gradle.api.specs.internal.ClosureSpec"}, {"methodBody": ["METHOD_START", "{", "compilationUnit . addPhaseOperation ( this ,    getPhase (  )  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.groovy.scripts.internal.AbstractScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "MethodCallExpression   methodCall    =    AstUtils . extractBareMethodCall ( statement )  ;", "if    ( methodCall    =  =    null )     {", "return   null ;", "}", "String   methodName    =    AstUtils . extractConstantMethodName ( methodCall )  ;", "if    ( methodName    =  =    null )     {", "return   null ;", "}", "ClosureExpression   closureExpression    =    AstUtils . getSingleClosureArg ( methodCall )  ;", "return   closureExpression    =  =    null    ?    null    :    new   ScriptBlock ( methodName ,    closureExpression )  ;", "}", "METHOD_END"], "methodName": ["detectScriptBlock"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "ScriptBlock   scriptBlock    =    AstUtils . detectScriptBlock ( statement )  ;", "if    (  ( scriptBlock    !  =    null )     &  &     ( predicate . apply ( scriptBlock )  )  )     {", "return   scriptBlock ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["detectScriptBlock"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "return   AstUtils . detectScriptBlock ( statement ,    new   com . google . common . base . Predicate < ScriptBlock >  (  )     {", "public   boolean   apply ( ScriptBlock   input )     {", "return   names . contains ( input . getName (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["detectScriptBlock"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( statement   instanceof   ExpressionStatement )  )     {", "return   null ;", "}", "ExpressionStatement   expressionStatement    =     (  ( ExpressionStatement )     ( statement )  )  ;", "if    (  !  (  ( expressionStatement . getExpression (  )  )    instanceof   MethodCallExpression )  )     {", "return   null ;", "}", "MethodCallExpression   methodCall    =     (  ( MethodCallExpression )     ( expressionStatement . getExpression (  )  )  )  ;", "if    (  !  (  . targetIsThis ( methodCall )  )  )     {", "return   null ;", "}", "return   methodCall ;", "}", "METHOD_END"], "methodName": ["extractBareMethodCall"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  ( methodCall . getMethod (  )  )    instanceof   ConstantExpression )  )     {", "return   null ;", "}", "return   methodCall . getMethod (  )  . getText (  )  ;", "}", "METHOD_END"], "methodName": ["extractConstantMethodName"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "ListIterator < Statement >    statementIterator    =    source . getAST (  )  . getStatementBlock (  )  . getStatements (  )  . listIterator (  )  ;", "while    ( statementIterator . hasNext (  )  )     {", "Statement   originalStatement    =    statementIterator . next (  )  ;", "Statement   transformedStatement    =    transformer . transform ( source ,    originalStatement )  ;", "if    ( transformedStatement    =  =    null )     {", "statementIterator . remove (  )  ;", "} else", "if    ( transformedStatement    !  =    originalStatement )     {", "statementIterator . set ( transformedStatement )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["filterAndTransformStatements"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  ( methodCall . getArguments (  )  )    instanceof   ArgumentListExpression )  )     {", "return   null ;", "}", "ArgumentListExpression   args    =     (  ( ArgumentListExpression )     ( methodCall . getArguments (  )  )  )  ;", "if    (  (  (  ( args . getExpressions (  )  . size (  )  )     =  =     2  )     &  &     (  ( args . getExpression (  0  )  )    instanceof   ClassExpression )  )     &  &     (  ( args . getExpression (  1  )  )    instanceof   ClosureExpression )  )     {", "return   Pair . of (  (  ( ClassExpression )     ( args . getExpression (  0  )  )  )  ,     (  ( ClosureExpression )     ( args . getExpression (  1  )  )  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getClassAndClosureArgs"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  ( methodCall . getArguments (  )  )    instanceof   ArgumentListExpression )  )     {", "return   null ;", "}", "ArgumentListExpression   args    =     (  ( ArgumentListExpression )     ( methodCall . getArguments (  )  )  )  ;", "if    (  (  ( args . getExpressions (  )  . size (  )  )     =  =     1  )     &  &     (  ( args . getExpression (  0  )  )    instanceof   ClassExpression )  )     {", "return    (  ( ClassExpression )     ( args . getExpression (  0  )  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getClassArg"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( classNode . implementsInterface ( GENERATED _ CLOSURE _ Type )  )  )     {", "throw   new   IllegalArgumentException (  \" expecting   generated   closure   class   node \"  )  ;", "}", "List < MethodNode >    doCallMethods    =    classNode . getDeclaredMethods (  \" doCall \"  )  ;", "return   doCallMethods . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getGeneratedClosureImplMethod"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( source . getAST (  )  . getStatementBlock (  )  . getStatements (  )  . isEmpty (  )  )     &  &     ( source . getAST (  )  . getMethods (  )  . isEmpty (  )  )  )     {", "return   null ;", "}", "return   source . getAST (  )  . getClasses (  )  . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["getScriptClass"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  ( methodCall . getArguments (  )  )    instanceof   ArgumentListExpression )  )     {", "return   null ;", "}", "ArgumentListExpression   args    =     (  ( ArgumentListExpression )     ( methodCall . getArguments (  )  )  )  ;", "if    (  (  ( args . getExpressions (  )  . size (  )  )     =  =     1  )     &  &     (  ( args . getExpression (  0  )  )    instanceof   ClosureExpression )  )     {", "return    (  ( ClosureExpression )     ( args . getExpression (  0  )  )  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getSingleClosureArg"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "ArgumentListExpression   argumentList    =     (  ( ArgumentListExpression )     ( call . getArguments (  )  )  )  ;", "if    (  ( argumentList . getExpressions (  )  . size (  )  )     =  =     1  )     {", "Expression   argumentExpression    =    argumentList . getExpressions (  )  . get (  0  )  ;", "if    ( argumentExpression   instanceof   ConstantExpression )     {", "ConstantExpression   constantArgumentExpression    =     (  ( ConstantExpression )     ( argumentExpression )  )  ;", "if    (  . isOfType ( constantArgumentExpression ,    type )  )     {", "return   constantArgumentExpression ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["hasSingleConstantArgOfType"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "return   AstUtils . hasSingleConstantArgOfType ( call ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["hasSingleConstantStringArg"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "boolean   hasName    =     (  ( call . getMethod (  )  )    instanceof   ConstantExpression )     &  &     ( call . getMethod (  )  . getText (  )  . equals ( name )  )  ;", "return   hasName    &  &     (  . targetIsThis ( call )  )  ;", "}", "METHOD_END"], "methodName": ["isMethodOnThis"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "return   constantExpression . getType (  )  . getName (  )  . equals ( type . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["isOfType"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "try    {", "sourcetClassLoader (  )  . loadClass ( className )  ;", "return   true ;", "}    catch    ( ClassNotFoundException   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( statement   instanceof   ReturnStatement )     {", "ReturnStatement   returnStatement    =     (  ( ReturnStatement )     ( statement )  )  ;", "if    (  ( returnStatement . getExpression (  )  )    instanceof   ConstantExpression )     {", "return   false ;", "}", "} else", "if    ( statement   instanceof   ExpressionStatement )     {", "ExpressionStatement   expressionStatement    =     (  ( ExpressionStatement )     ( statement )  )  ;", "if    (  ( expressionStatement . getExpression (  )  )    instanceof   ConstantExpression )     {", "return   false ;", "}", "if    (  ( expressionStatement . getExpression (  )  )    instanceof   DeclarationExpression )     {", "DeclarationExpression   declarationExpression    =     (  ( DeclarationExpression )     ( expressionStatement . getExpression (  )  )  )  ;", "if    (  (  ( declarationExpression . getRightExpression (  )  )    instanceof   EmptyExpression )     |  |     (  ( declarationExpression . getRightExpression (  )  )    instanceof   ConstantExpression )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["mayHaveAnEffect"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "declaringClass . getMethods (  )  . remove ( methodNode )  ;", "declaringClass . getDeclaredMethods ( methodNodetName (  )  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["removeMethod"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "Expression   target    =    call . getObjectExpression (  )  ;", "return    ( target   instanceof   VariableExpression )     &  &     ( target . getText (  )  . equals (  \" this \"  )  )  ;", "}", "METHOD_END"], "methodName": ["targetIsThis"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( statement   instanceof   BlockStatement )     {", "return    (  ( BlockStatement )     ( statement )  )  . getStatements (  )  ;", "} else    {", "return   Collections . singleton ( statement )  ;", "}", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "source . getAST (  )  . getStatementBlock (  )  . visit ( transformer )  ;", "for    ( Object   method    :    source . getAST (  )  . getMethods (  )  )     {", "MethodNode   methodNode    =     (  ( MethodNode )     ( method )  )  ;", "methodNode . getCode (  )  . visit ( transformer )  ;", "}", "}", "METHOD_END"], "methodName": ["visitScriptCode"], "fileName": "org.gradle.groovy.scripts.internal.AstUtils"}, {"methodBody": ["METHOD_START", "{", "ListIterator < T >    iter    =    exprs . listIterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "iter . set (  (  ( T )     ( reExpr ( iter . next (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceAllExprs"], "fileName": "org.gradle.groovy.scripts.internal.ExpressionReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "replacementExpr    =    null ;", "expr . visit ( this )  ;", "result    =     (  ( replacementExpr )     =  =    null )     ?    expr    :    replacementExpr ;", "replacementExpr    =    null ;", "return   result ;", "}", "METHOD_END"], "methodName": ["replaceExpr"], "fileName": "org.gradle.groovy.scripts.internal.ExpressionReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "replacementExpr    =    other ;", "}", "METHOD_END"], "methodName": ["replaceVisitedExpressionWith"], "fileName": "org.gradle.groovy.scripts.internal.ExpressionReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "restrict ( astNode ,    message )  ;", "}", "METHOD_END"], "methodName": ["restrict"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "sourceUnit . getErrorCollector (  )  . addError ( new   SyntaxException ( message ,    astNode . getLineNumber (  )  ,    astNode . getColumnNumber (  )  )  ,    sourceUnit )  ;", "}", "METHOD_END"], "methodName": ["restrict"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitArgumentlistExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitArrayExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitAssertStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( attributeExpression )  ;", "}", "METHOD_END"], "methodName": ["visitAttributeExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitBinaryExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitBitwiseNegationExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitBlockStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitBooleanExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitBreakStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitBytecodeExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitCaseStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitCastExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitCatchStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitClassExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitClosureExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( closureListExpression )  ;", "}", "METHOD_END"], "methodName": ["visitClosureListExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitConstantExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitConstructorCallExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitContinueStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitDeclarationExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( loop )  ;", "}", "METHOD_END"], "methodName": ["visitDoWhileLoop"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitExpressionStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitFieldExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( forLoop )  ;", "}", "METHOD_END"], "methodName": ["visitForLoop"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitGStringExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( ifElse )  ;", "}", "METHOD_END"], "methodName": ["visitIfElse"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitListExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitMapEntryExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitMapExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( call )  ;", "}", "METHOD_END"], "methodName": ["visitMethodCallExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitMethodPointerExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitNotExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitPostfixExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitPrefixExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitPropertyExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitRangeExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitReturnStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitShortTernaryExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitSpreadExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitSpreadMapExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitStaticMethodCallExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitSwitch"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitSynchronizedStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitTernaryExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( statement )  ;", "}", "METHOD_END"], "methodName": ["visitThrowStatement"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( finally 1  )  ;", "}", "METHOD_END"], "methodName": ["visitTryCatchFinally"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitTupleExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitUnaryMinusExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitUnaryPlusExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( expression )  ;", "}", "METHOD_END"], "methodName": ["visitVariableExpression"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "restrict ( loop )  ;", "}", "METHOD_END"], "methodName": ["visitWhileLoop"], "fileName": "org.gradle.groovy.scripts.internal.RestrictiveCodeVisitor"}, {"methodBody": ["METHOD_START", "{", "return   closureExpression ;", "}", "METHOD_END"], "methodName": ["getClosureExpression"], "fileName": "org.gradle.groovy.scripts.internal.ScriptBlock"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.groovy.scripts.internal.ScriptBlock"}, {"methodBody": ["METHOD_START", "{", "replacement    =    null ;", "stat . visit ( this )  ;", "result    =     (  ( replacement )     =  =    null )     ?    stat    :    replacement ;", "replacement    =    null ;", "return   result ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.gradle.groovy.scripts.internal.StatementReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "ListIterator < T >    iter    =    stats . listIterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "iter . set (  (  ( T )     ( re ( iter . next (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["replaceAll"], "fileName": "org.gradle.groovy.scripts.internal.StatementReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "replacement    =    other ;", "}", "METHOD_END"], "methodName": ["replaceVisitedStatementWith"], "fileName": "org.gradle.groovy.scripts.internal.StatementReplacingVisitorSupport"}, {"methodBody": ["METHOD_START", "{", "return   OBJECT _ METHODS . contains ( Methods . SIGNATURE _ EQUIVALENCE . wrap ( method )  )  ;", "}", "METHOD_END"], "methodName": ["isObjectMethod"], "fileName": "org.gradle.internal.reflect.GroovyMethods"}]