[{"methodBody": ["METHOD_START", "{", "registration . addProvider ( new   PluginUsePluginServiceRegistry . BuildScopeServices (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerBuildServices"], "fileName": "org.gradle.plugin.internal.PluginUsePluginServiceRegistry"}, {"methodBody": ["METHOD_START", "{", "return   Lists . newArrayList ( Iterables . filter ( autoAppliedPlugins ,    new   com . google . common . base . Predicate < PluginRequestInternal >  (  )     {", "@ Override", "public   boolean   apply ( PluginRequestInternal   autoAppliedPlugin )     {", "return    !  (  . isAlreadyAppliedOrRequested ( autoAppliedPlugin ,    initialRequests ,    pluginContainer ,    scriptHandler )  )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["filterAlreadyAppliedOrRequested"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "return   pluginContainer . hasPlugin ( autoAppliedPlugin . getId (  )  . getId (  )  )  ;", "}", "METHOD_END"], "methodName": ["isAlreadyApplied"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DefaultAutoAppliedPluginHandler . isAlreadyApplied ( autoAppliedPlugin ,    pluginContainer )  )     |  |     ( DefaultAutoAppliedPluginHandler . isAlreadyRequestedInPluginsBlock ( autoAppliedPlugin ,    requests )  )  )     |  |     ( DefaultAutoAppliedPluginHandler . isAlreadyRequestedInBuildScriptBlock ( autoAppliedPlugin ,    scriptHandler )  )  ;", "}", "METHOD_END"], "methodName": ["isAlreadyAppliedOrRequested"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "ModuleVersionSelector   module    =    autoAppliedPlugin . getModule (  )  ;", "if    ( module    =  =    null )     {", "return   false ;", "}", "Configuration   classpathConfiguration    =    scriptHandler . getConfigurations (  )  . getByName ( CLASSPATH _ CONFIGURATION )  ;", "for    ( Dependency   dependency    :    classpathConfiguration . getDependencies (  )  )     {", "if    (  ( module . getGroup (  )  . equals ( dependency . getGroup (  )  )  )     &  &     ( module . getName (  )  . equals ( dependency . getName (  )  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAlreadyRequestedInBuildScriptBlock"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( PluginRequestInternal   request    :    requests )     {", "if    ( a . getId (  )  . equals ( request . getId (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAlreadyRequestedInPluginsBlock"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "List < PluginRequestInternal >    filteredAutoAppliedPlugins    =    filterAlreadyAppliedOrRequested ( autoAppliedPlugins ,    initialRequests ,    pluginContainer ,    scriptHandler )  ;", "List < PluginRequestInternal >    merged    =    new   ArrayList < PluginRequestInternal >  (  (  ( initialRequests . size (  )  )     +     ( autoAppliedPlugins . size (  )  )  )  )  ;", "merged . addAll ( filteredAutoAppliedPlugins )  ;", "merged . addAll ( ImmutableList . copyOf ( initialRequests )  )  ;", "return   new   DefaultPluginRequests ( merged )  ;", "}", "METHOD_END"], "methodName": ["mergePluginRequests"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginHandler"}, {"methodBody": ["METHOD_START", "{", "ModuleVersionSelector   artifact    =    DefaultModuleVersionSelector . newSelector ( GROUP ,    NAME ,    VERSION )  ;", "return   new   DefaultPluginRequest ( AutoAppliedBuildScanPlugin . ID ,    AutoAppliedBuildScanPlugin . VERSION ,    true ,    null ,    DefaultAutoAppliedPluginRegistry . getScriptDisplayName (  )  ,    artifact )  ;", "}", "METHOD_END"], "methodName": ["createScanPluginRequest"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" auto - applied   by   using    -  -  % s \"  ,    LONG _ OPTION )  ;", "}", "METHOD_END"], "methodName": ["getScriptDisplayName"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "StartParameter   startParameter    =    buildDefinition . getStartParameter (  )  ;", "return    (  ( startParameter . isBuildScan (  )  )     &  &     (  ( target . getParent (  )  )     =  =    null )  )     &  &     (  ( target . getG (  )  . getParent (  )  )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["shouldApplyScanPlugin"], "fileName": "org.gradle.plugin.management.internal.autoapply.DefaultAutoAppliedPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( repoUrls . isEmpty (  )  )     {", "return ;", "}", "fi   Set < String >    existingMavenUrls    =    existingMavenUrls ( repositories )  ;", "for    ( fi   String   repoUrl    :    repoUrls )     {", "if    (  !  ( existingMavenUrls . contains ( repoUrl )  )  )     {", "maven ( repositories ,    repoUrl )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addMissingMavenRepositories"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "repositories . addAll ( pluginRepositoriesProvider . getPluginRepositories (  )  )  ;", "}", "METHOD_END"], "methodName": ["addPluginArtifactRepositories"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "try    {", "try    {", "applicator . run (  )  ;", "}    catch    ( UnknownPluginException   e )     {", "throw   couldNotApply ( request ,    id ,    e )  ;", "}    catch    ( Exception   e )     {", "throw   exceptionOccurred ( request ,    e )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   internal . exceptions . LocationAwareException ( e ,    request . getScriptDisplayName (  )  ,    request . getLineNumber (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyPlugin"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( target    =  =    null )     |  |     ( requests . isEmpty (  )  )  )     {", "defineScriptHandlerClassScope ( scriptHandler ,    classLoaderScope ,    Collections .  < PluginImplementation <  ?  >  > emptyList (  )  )  ;", "return ;", "}", "final   PluginResolver   effectivePluginResolver    =    wrapInAlreadyInClasspathResolver ( classLoaderScope )  ;", "List <  . Result >    results    =    collect ( requests ,    new   Transformer <  . Result ,    PluginRequestInternal >  (  )     {", "public    . Result   transform ( PluginRequestInternal   request )     {", "PluginRequestInternal   configuredRequest    =    pluginResolutionStrategy . applyTo ( request )  ;", "return   resolveToFoundResult ( effectivePluginResolver ,    configuredRequest )  ;", "}", "}  )  ;", "final   Map <  . Result ,    PluginId >    legacyActualPluginIds    =    newLinkedHashMap (  )  ;", "final   Map <  . Result ,    PluginImplementation <  ?  >  >    pluginImpls    =    newLinkedHashMap (  )  ;", "final   Map <  . Result ,    PluginImplementation <  ?  >  >    pluginImplsFromOtherLoaders    =    newLinkedHashMap (  )  ;", "if    (  !  ( results . isEmpty (  )  )  )     {", "final   RepositoryHandler   repositories    =    scriptHandler . getRepositories (  )  ;", "addPluginArtifactRepositories ( repositories )  ;", "final   Set < String >    repoUrls    =    newLinkedHashSet (  )  ;", "for    ( final    . Result   result    :    results )     {", "applyPlugin ( result . request ,    result . found . getPluginId (  )  ,    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "result . found . execute ( new   PluginResolveContext (  )     {", "public   void   addLegacy ( PluginId   pluginId ,    final   String   m 2 RepoUrl ,    Object   dependencyNotation )     {", "repoUrls . add ( m 2 RepoUrl )  ;", "addLegacy ( pluginId ,    dependencyNotation )  ;", "}", "@ Override", "public   void   addLegacy ( PluginId   pluginId ,    Object   dependencyNotation )     {", "legacyActualPluginIds . put ( result ,    pluginId )  ;", "scriptHandler . addScriptClassPathDependency ( dependencyNotation )  ;", "}", "@ Override", "public   void   add ( PluginImplementation <  ?  >    plugin )     {", "pluginImpls . put ( result ,    plugin )  ;", "}", "@ Override", "public   void   addFromDifferentLoader ( PluginImplementation <  ?  >    plugin )     {", "pluginImplsFromOtherLoaders . put ( result ,    plugin )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "addMissingMavenRepositories ( repositories ,    repoUrls )  ;", "}", "defineScriptHandlerClassScope ( scriptHandler ,    classLoaderScope ,    pluginImplsFromOtherLoaders . values (  )  )  ;", "for    ( final   Map . Entry <  . Result ,    PluginId >    entry    :    legacyActualPluginIds . entrySet (  )  )     {", "final   PluginRequestInternal   request    =    entry . getKey (  )  . request ;", "final   PluginId   id    =    entry . getValue (  )  ;", "applyPlugin ( request ,    id ,    new   Runnable (  )     {", "public   void   run (  )     {", "if    ( request . isApply (  )  )     {", "target . apply ( id . toString (  )  )  ;", "}", "}", "}  )  ;", "}", "for    ( final   Map . Entry <  . Result ,    PluginImplementation <  ?  >  >    entry    :    Iterables . concat ( pluginImpls . entrySet (  )  ,    pluginImplsFromOtherLoaders . entrySet (  )  )  )     {", "final    . Result   result    =    entry . getKey (  )  ;", "applyPlugin ( result . request ,    result . found . getPluginId (  )  ,    new   Runnable (  )     {", "public   void   run (  )     {", "if    ( result . request . isApply (  )  )     {", "target . apply ( entry . getValue (  )  )  ;", "}", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyPlugins"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "if    ( result . notFoundList . isEmpty (  )  )     {", "return   String . format (  \" Plugin    % s   was   not   found \"  ,    pluginRequest . getDisplayName (  )  )  ;", "} else    {", "Formatter   sb    =    new   Formatter (  )  ;", "sb . format (  \" Plugin    % s   was   not   found   in   any   of   the   following   sources :  % n \"  ,    pluginRequest . getDisplayName (  )  )  ;", "for    (  . NotFound   notFound    :    result . notFoundList )     {", "sb . format (  \"  % n -     % s    (  % s )  \"  ,    notFound . source ,    notFound . message )  ;", "if    (  ( notFound . detail )     !  =    null )     {", "sb . format (  \"  % n % s \"  ,    TextUtil . indent ( notFound . detail ,     \"        \"  )  )  ;", "}", "}", "return   sb . toString (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildNotFoundMessage"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "return   new   InvalidPluginException ( String . format (  (  \" Could   not   apply   requested   plugin    % s   as   it   does   not   provide   a   plugin   with   id    '  % s '  .  \"     +     (  \"    This   is   caused   by   an   incorrect   plugin   implementation .  \"     +     \"    Please   contact   the   plugin   author ( s )  .  \"  )  )  ,    request ,    id )  ,    cause )  ;", "}", "METHOD_END"], "methodName": ["couldNotApply"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "ClassPath   classPath    =    scriptHandler . getScriptClassPath (  )  ;", "ClassPath   cachedJarClassPath    =    cachedClasspathTransformer . transform ( classPath )  ;", "classLoaderScope . export ( cachedJarClassPath )  ;", "for    ( PluginImplementation <  ?  >    Implementation    :    sFromOtherLoaders )     {", "classLoaderScope . export ( Implementation . asClass (  )  . getClassLoader (  )  )  ;", "}", "classLoaderScope . lock (  )  ;", "}", "METHOD_END"], "methodName": ["defineScriptHandlerClassScope"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "return   new   InvalidPluginException ( String . format (  \" An   exception   occurred   applying   plugin   request    % s \"  ,    request )  ,    e )  ;", "}", "METHOD_END"], "methodName": ["exceptionOccurred"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "Set < String >    mavenUrls    =    newHashSet (  )  ;", "for    ( ArtifactReposiy   repo    :    reposiies )     {", "if    ( repo   instanceof   MavenArtifactReposiy )     {", "mavenUrls . add (  (  ( MavenArtifactReposiy )     ( repo )  )  . getUrl (  )  . toString (  )  )  ;", "}", "}", "return   mavenUrls ;", "}", "METHOD_END"], "methodName": ["existingMavenUrls"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "repositories . maven ( new   Action < MavenArtifactRepository >  (  )     {", "public   void   execute ( MavenArtifactRepository   mavenArtifactRepository )     {", "mavenArtifactRepository . setUrl ( m 2 RepoUrl )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["maven"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "DefaultPluginRequestApplicator . Result   result    =    new   DefaultPluginRequestApplicator . Result ( request )  ;", "try    {", "effectivePluginResolver . resolve ( request ,    result )  ;", "}    catch    ( Exception   e )     {", "throw   new   LocationAwareException ( new   GradleException ( String . format (  \" Error   resolving   plugin    % s \"  ,    request . getDisplayName (  )  )  ,    e )  ,    request . getScriptDisplayName (  )  ,    request . getLineNumber (  )  )  ;", "}", "if    (  !  ( result . isFound (  )  )  )     {", "String   message    =    buildNotFoundMessage ( request ,    result )  ;", "Exception   exception    =    new   UnknownPluginException ( message )  ;", "throw   new   LocationAwareException ( exception ,    request . getScriptDisplayName (  )  ,    request . getLineNumber (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["resolveToFoundResult"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderScope   parentLoaderScope    =    classLoaderScope . getParent (  )  ;", "PluginDescriptorLocator   scriptClasspathPluginDescriptorLocator    =    new   api . internal . plugins . ClassloaderBackedPluginDescriptorLocator ( parentLoaderScope . getExportClassLoader (  )  )  ;", "PluginResolver   pluginResolver    =    pluginResolverFactory . create (  )  ;", "return   new   AlreadyOnClasspathPluginResolver ( pluginResolver ,    pluginRegistry ,    parentLoaderScope ,    scriptClasspathPluginDescriptorLocator ,    pluginInspector )  ;", "}", "METHOD_END"], "methodName": ["wrapInAlreadyInClasspathResolver"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginRequestApplicator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( dependencyResolutionServices )     =  =    null )     {", "dependencyResolutionServices    =    factory . create (  )  ;", "}", "return   dependencyResolutionServices ;", "}", "METHOD_END"], "methodName": ["getDependencyResolutionServices"], "fileName": "org.gradle.plugin.use.internal.PluginDependencyResolutionServices"}, {"methodBody": ["METHOD_START", "{", "return   new   PluginRepositoriesProvider (  )     {", "@ Override", "public   List < ArtifactRepository >    getPluginRepositories (  )     {", "RepositoryHandler   repositories    =    getResolveRepositoryHandler (  )  ;", "List < ArtifactRepository >    list    =    new   ArrayList < ArtifactRepository >  ( repositories . size (  )  )  ;", "for    ( ArtifactRepository   repository    :    repositories )     {", "list . add ( new    . PluginArtifactRepository ( repository )  )  ;", "}", "return   list ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPluginRepositoriesProvider"], "fileName": "org.gradle.plugin.use.internal.PluginDependencyResolutionServices"}, {"methodBody": ["METHOD_START", "{", "return   new   PluginRepositoryHandlerProvider (  )     {", "@ Override", "public   RepositoryHandler   getPluginRepositoryHandler (  )     {", "return   getResolveRepositoryHandler (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPluginRepositoryHandlerProvider"], "fileName": "org.gradle.plugin.use.internal.PluginDependencyResolutionServices"}, {"methodBody": ["METHOD_START", "{", "resolvers . add ( new   NoopPluginResolver ( pluginRegistry )  )  ;", "resolvers . add ( new   SelfResolvingRequestPluginResolver ( pluginInspector )  )  ;", "resolvers . add ( new   CorePluginResolver ( documentationRegistry ,    pluginRegistry )  )  ;", "if    (  !  ( injectedClasspathPluginResolver . isClasspathEmpty (  )  )  )     {", "resolvers . add ( injectedClasspathPluginResolver )  ;", "}", "resolvers . add ( ArtifactRepositoriesPluginResolver . createWithDefaults ( dependencyResolutionServices ,    versionSelectorScheme )  )  ;", "}", "METHOD_END"], "methodName": ["addDefaultResolvers"], "fileName": "org.gradle.plugin.use.internal.PluginResolverFactory"}, {"methodBody": ["METHOD_START", "{", "List < PluginResolver >    resolvers    =    new   LinkedList < PluginResolver >  (  )  ;", "addDefaultResolvers ( resolvers )  ;", "return   resolvers ;", "}", "METHOD_END"], "methodName": ["createDefaultResolvers"], "fileName": "org.gradle.plugin.use.internal.PluginResolverFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( pluginDescriptorLocator . findPluginDescriptor ( pluginId . toString (  )  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isAbsentFromTheClasspath"], "fileName": "org.gradle.plugin.use.resolve.internal.AlreadyOnClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "return    ( corePluginRegistry . lookup ( pluginId )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isCorePlugin"], "fileName": "org.gradle.plugin.use.resolve.internal.AlreadyOnClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "PluginId   pluginId    =    pluginRequest . getId (  )  ;", "if    (  ( isCorePlugin ( pluginId )  )     |  |     ( isAbsentFromTheClasspath ( pluginId )  )  )     {", "delegate . resolve ( pluginRequest ,    result )  ;", "} else", "if    (  ( pluginRequest . getOriginalRequest (  )  . getVersion (  )  )     !  =    null )     {", "throw   new   management . internal . InvalidPluginRequestException ( pluginRequest ,     \" Plugin   request   for   plugin   already   on   the   classpath   must   not   include   a   version \"  )  ;", "} else    {", "resolveAlreadyOnClasspath ( pluginId ,    result )  ;", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.plugin.use.resolve.internal.AlreadyOnClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "PluginResolution   pluginResolution    =    new   ClassPathPluginResolution ( pluginId ,    parentLoaderScope ,    AlreadyOnClasspathPluginResolver . EMPTY _ CLASSPATH _ FACTORY ,    pluginInspector )  ;", "result . found (  \" Already   on   classpath \"  ,    pluginResolution )  ;", "}", "METHOD_END"], "methodName": ["resolveAlreadyOnClasspath"], "fileName": "org.gradle.plugin.use.resolve.internal.AlreadyOnClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "RepositoryHandler   repositories    =    dependencyResolutionServices . getResolveRepositoryHandler (  )  ;", "if    ( repositories . isEmpty (  )  )     {", "repositories . gradlePluginPortal (  )  ;", "}", "return   new    ( dependencyResolutionServices ,    versionSelectorScheme )  ;", "}", "METHOD_END"], "methodName": ["createWithDefaults"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "ConfigurationContainer   configurations    =    resolution . getConfigurationContainer (  )  ;", "Configuration   configuration    =    configurations . detachedConfiguration ( dependency )  ;", "configuration . setTransitive ( false )  ;", "return    !  ( configuration . getdConfiguration (  )  . hasError (  )  )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "ModuleVersionSelector   selector    =    pluginRequest . getModule (  )  ;", "if    ( selector    =  =    null )     {", "String   id    =    pluginRequest . getId (  )  . getId (  )  ;", "return   new   DefaultExternalModuleDependency ( id ,     ( id    +     (  . PLUGIN _ MARKER _ SUFFIX )  )  ,    pluginRequest . getVersion (  )  )  ;", "} else    {", "return   new   DefaultExternalModuleDependency ( selector . getGroup (  )  ,    selector . getName (  )  ,    selector . getVersion (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMarkerDependency"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "return   Joiner . on (  '  :  '  )  . join ( dependency . getGroup (  )  ,    dependency . getName (  )  ,    dependency . getVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["getNotation"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "result . found (  \" Plugin   Repositories \"  ,    new   PluginResolution (  )     {", "@ Override", "public   PluginId   getPluginId (  )     {", "return   pluginRequest . getId (  )  ;", "}", "public   void   execute (  @ Nonnull", "Context   context )     {", "context . addLegacy ( pluginRequest . getId (  )  ,    markerDependency )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["handleFound"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   detail    =    new   StringBuilder (  \" Searched   in   the   following   repositories :  \\ n \"  )  ;", "for    ( Iterator < ArtifactRepository >    it    =    resolution . getResolveRepositoryHandler (  )  . iterator (  )  ;    it . hasNext (  )  ;  )     {", "detail . append (  \"        \"  )  . append (  (  ( ArtifactRepositoryInternal )     ( it . next (  )  )  )  . getDisplayName (  )  )  ;", "if    ( it . hasNext (  )  )     {", "detail . append (  \"  \\ n \"  )  ;", "}", "}", "result . notFound (  . SOURCE _ NAME ,    message ,    detail . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["handleNotFound"], "fileName": "org.gradle.plugin.use.resolve.internal.ArtifactRepositoriesPluginResolver"}, {"methodBody": ["METHOD_START", "{", "return   pluginId ;", "}", "METHOD_END"], "methodName": ["getPluginId"], "fileName": "org.gradle.plugin.use.resolve.internal.ClassPathPluginResolution"}, {"methodBody": ["METHOD_START", "{", "for    ( PluginResolver   repository    :    repositories )     {", "repository . resolve ( pluginRequest ,    result )  ;", "if    ( result . isFound (  )  )     {", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.plugin.use.resolve.internal.CompositePluginResolver"}, {"methodBody": ["METHOD_START", "{", "return    \" Gradle   Core   Plugins \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugin.use.resolve.internal.CorePluginResolver"}, {"methodBody": ["METHOD_START", "{", "String   namespace    =    id . getNamespace (  )  ;", "return    ( namespace    =  =    null )     |  |     ( namespace . equals ( CORE _ PLUGIN _ NAMESPACE )  )  ;", "}", "METHOD_END"], "methodName": ["isCorePluginRequest"], "fileName": "org.gradle.plugin.use.resolve.internal.CorePluginResolver"}, {"methodBody": ["METHOD_START", "{", "PluginId   id    =    pluginRequest . getId (  )  ;", "if    (  !  ( isCorePluginRequest ( id )  )  )     {", "result . notFound (  . getDescription (  )  ,    String . format (  \" plugin   is   not   in    '  % s '    namespace \"  ,    CORE _ PLUGIN _ NAMESPACE )  )  ;", "return ;", "}", "PluginImplementation <  ?  >    plugin    =    pluginRegistry . lookup ( id )  ;", "if    ( plugin    =  =    null )     {", "result . notFound (  . getDescription (  )  ,    String . format (  \" not   a   core   plugin ,    please   see    % s   for   available   core   plugins \"  ,    documentationRegistry . getDocumentationFor (  \" standard _ plugins \"  )  )  )  ;", "return ;", "}", "validate ( pluginRequest )  ;", "result . found (  . getDescription (  )  ,    new   SimplePluginResolution ( plugin )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.plugin.use.resolve.internal.CorePluginResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pluginRequest . getVersion (  )  )     !  =    null )     {", "throw   new   management . internal . InvalidPluginRequestException ( pluginRequest ,     (  (  (  \" Plugin    '  \"     +     ( pluginRequest . getId (  )  )  )     +     \"  '    is   a   core   Gradle   plugin ,    which   cannot   be   specified   with   a   version   number .     \"  )     +     \" Such   plugins   are   versioned   as   part   of   Gradle .    Please   remove   the   version   number   from   the   declaration .  \"  )  )  ;", "}", "if    (  ( pluginRequest . getModule (  )  )     !  =    null )     {", "throw   new   management . internal . InvalidPluginRequestException ( pluginRequest ,     (  (  (  \" Plugin    '  \"     +     ( pluginRequest . getId (  )  )  )     +     \"  '    is   a   core   Gradle   plugin ,    which   cannot   be   specified   with   a   custom   implementation   artifact .     \"  )     +     \" Such   plugins   are   versioned   as   part   of   Gradle .    Please   remove   the   custom   artifact   from   the   request .  \"  )  )  ;", "}", "if    (  !  ( pluginRequest . isApply (  )  )  )     {", "throw   new   management . internal . InvalidPluginRequestException ( pluginRequest ,     (  (  (  \" Plugin    '  \"     +     ( pluginRequest . getId (  )  )  )     +     \"  '    is   a   core   Gradle   plugin ,    which   is   already   on   the   classpath .     \"  )     +     \" Requesting   it   with   the    ' apply   false '    option   is   a   no - op .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.plugin.use.resolve.internal.CorePluginResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( pluginRequest . getId (  )  . equals ( NoopPluginResolver . NOOP _ PLUGIN _ ID )  )     {", "result . found (  \" noop   resolver \"  ,    new   SimplePluginResolution ( DefaultPotentialPluginWithId . of ( NoopPluginResolver . NOOP _ PLUGIN _ ID ,    pluginRegistry . inspect ( NoopPluginResolver . NoopPlugin . class )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.plugin.use.resolve.internal.NoopPluginResolver"}, {"methodBody": ["METHOD_START", "{", "return   plugin . getPluginId (  )  ;", "}", "METHOD_END"], "methodName": ["getPluginId"], "fileName": "org.gradle.plugin.use.resolve.internal.SimplePluginResolution"}, {"methodBody": ["METHOD_START", "{", "return    \" Gradle   TestKit \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugin.use.resolve.service.internal.InjectedClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "return   injectedClasspath . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isClasspathEmpty"], "fileName": "org.gradle.plugin.use.resolve.service.internal.InjectedClasspathPluginResolver"}, {"methodBody": ["METHOD_START", "{", "PluginImplementation <  ?  >    plugin    =    pluginRegistry . lookup ( pluginRequest . getId (  )  )  ;", "if    ( plugin    =  =    null )     {", "String   classpathStr    =    Joiner . on ( File . pathSeparator )  . join ( Iterables . transform ( injectedClasspath . getAsFiles (  )  ,    new   com . google . common . base . Function < File ,    String >  (  )     {", "@ Override", "public   String   apply ( File   input )     {", "return   input . getAbsolutePath (  )  ;", "}", "}  )  )  ;", "result . notFound ( getDescription (  )  ,     (  \" classpath :     \"     +    classpathStr )  )  ;", "} else    {", "result . found ( getDescription (  )  ,    new    . InjectedClasspathPluginResolution ( plugin )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.plugin.use.resolve.service.internal.InjectedClasspathPluginResolver"}]