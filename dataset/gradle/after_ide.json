[{"methodBody": ["METHOD_START", "{", "beforeMerged . add ( ConfigureUtil . configureUsing ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["beforeMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "beforeMerged . add ( action )  ;", "}", "METHOD_END"], "methodName": ["beforeMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "return   beforeMerged ;", "}", "METHOD_END"], "methodName": ["getBeforeMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "return   whenMerged ;", "}", "METHOD_END"], "methodName": ["getWhenMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "this . beforeMerged    =    beforeMerged ;", "}", "METHOD_END"], "methodName": ["setBeforeMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "this . whenMerged    =    whenMerged ;", "}", "METHOD_END"], "methodName": ["setWhenMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "whenMerged . add ( ConfigureUtil . configureUsing ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["whenMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "whenMerged . add ( action )  ;", "}", "METHOD_END"], "methodName": ["whenMerged"], "fileName": "org.gradle.plugins.ide.api.FileContentMerger"}, {"methodBody": ["METHOD_START", "{", "File   inputFile    =    getInputFileIfExists (  )  ;", "if    ( inputFile    !  =    null )     {", "try    {", "domainObject    =    g . read ( inputFile )  ;", "}    catch    ( RuntimeException   e )     {", "throw   new   GradleException ( String . format (  (  \" Cannot   parse   file    \\  '  % s \\  '  .  \\ n \"     +     \"                      Perhaps   this   file   was   tinkered   with ?    In   that   case   try   delete   this   file   and   then   retry .  \"  )  ,    inputFile )  ,    e )  ;", "}", "} else    {", "domainObject    =    g . defaultInstance (  )  ;", "}", "beforeConfigured . execute ( domainObject )  ;", "g . configure ( domainObject )  ;", "afterConfigured . execute ( domainObject )  ;", "g . write ( domainObject ,    getOutputFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["getIncremental"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "return    ( inputFile )     !  =    null    ?    inputFile    :    getOutputFile (  )  ;", "}", "METHOD_END"], "methodName": ["getInputFile"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "FiinputFi =    getInputFi )  ;", "if    (  ( inputFi !  =    null )     &  &     ( inputFiexists (  )  )  )     {", "return   inputFi", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getInputFileIfExists"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getInstantiator"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "this . inputFile    =    inputFile ;", "}", "METHOD_END"], "methodName": ["setInputFile"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "this . outputFile    =    outputFile ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.plugins.ide.api.GeneratorTask"}, {"methodBody": ["METHOD_START", "{", "return   transformer ;", "}", "METHOD_END"], "methodName": ["getTransformer"], "fileName": "org.gradle.plugins.ide.api.PropertiesFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "this . transformer    =    transformer ;", "}", "METHOD_END"], "methodName": ["setTransformer"], "fileName": "org.gradle.plugins.ide.api.PropertiesFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "withProperties ( new   ClosureBackedAction < Properties >  ( closure ,    Closure . OWNER _ FIRST )  )  ;", "}", "METHOD_END"], "methodName": ["withProperties"], "fileName": "org.gradle.plugins.ide.api.PropertiesFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "transformer . addAction ( action )  ;", "}", "METHOD_END"], "methodName": ["withProperties"], "fileName": "org.gradle.plugins.ide.api.PropertiesFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "return   transformer ;", "}", "METHOD_END"], "methodName": ["getTransformer"], "fileName": "org.gradle.plugins.ide.api.PropertiesGeneratorTask"}, {"methodBody": ["METHOD_START", "{", "return   xmlTransformer ;", "}", "METHOD_END"], "methodName": ["getXmlTransformer"], "fileName": "org.gradle.plugins.ide.api.XmlFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "this . xmlTransformer    =    xmlTransformer ;", "}", "METHOD_END"], "methodName": ["setXmlTransformer"], "fileName": "org.gradle.plugins.ide.api.XmlFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "xmlTransformer . addAction ( closure )  ;", "}", "METHOD_END"], "methodName": ["withXml"], "fileName": "org.gradle.plugins.ide.api.XmlFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "xmlTransformer . addAction ( action )  ;", "}", "METHOD_END"], "methodName": ["withXml"], "fileName": "org.gradle.plugins.ide.api.XmlFileContentMerger"}, {"methodBody": ["METHOD_START", "{", "return   xmlTransformer ;", "}", "METHOD_END"], "methodName": ["getXmlTransformer"], "fileName": "org.gradle.plugins.ide.api.XmlGeneratorTask"}, {"methodBody": ["METHOD_START", "{", "Action < Plugin < Project >  >    action    =    createActionApplyingEclipseWtpPlugin (  )  ;", "project . getPlugins (  )  . withType ( WarPlugin . class ,    action )  ;", "project . getPlugins (  )  . withType ( EarPlugin . class ,    action )  ;", "}", "METHOD_END"], "methodName": ["applyEclipseWtpPluginOnWebProjects"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "model . setClasspath ( instantiator . newInstance ( EclipseClasspath . class ,    project )  )  ;", "(  ( IConventionAware )     ( model . getClasspath (  )  )  )  . getConventionMapping (  )  . map (  \" defaultOutputDir \"  ,    new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )     {", "return   new   File ( project . getProjectDir (  )  ,    Constants . DEFAULT _ PROJECT _ OUTPUT _ PATH )  ;", "}", "}  )  ;", "final      eclipsePlugin    =    this ;", "project . getPlugins (  )  . withType ( JavaBasePlugin . class ,    new   Action < JavaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( JavaBasePlugin   javaBasePlugin )     {", ". maybeAddTask ( project ,    eclipsePlugin ,     . ECLIPSE _ CP _ TASK _ NAME ,    GenerateEclipseClasspath . class ,    new   Action < GenerateEclipseClasspath >  (  )     {", "@ Override", "public   void   execute ( final   GenerateEclipseClasspath   task )     {", "task . setDescription (  \" Generates   the   Eclipse   classpath   file .  \"  )  ;", "task . setInputFile ( project . file (  \"  . classpath \"  )  )  ;", "task . setOutputFile ( project . file (  \"  . classpath \"  )  )  ;", "task . setClasspath ( model . getClasspath (  )  )  ;", "task . getClasspath (  )  . setFile ( new   XmlFileContentMerger ( task . getXmlTransformer (  )  )  )  ;", "task . getClasspath (  )  . setSourceSets ( project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  )  ;", "AfterEvaluateHelper . afterEvaluateOrExecute ( project ,    new   Action < Project >  (  )     {", "@ Override", "public   void   execute ( Project   p )     {", "Set < String >    containers    =    Sets . newLinkedHashSet (  )  ;", "containers . add (  (  (  \" JRE _ CONTAINER / StandardVMType /  \"     +     ( model . getJdt (  )  . getJavaRuntimeName (  )  )  )     +     \"  /  \"  )  )  ;", "containers . addAll ( task . getClasspath (  )  . getContainers (  )  )  ;", "task . getClasspath (  )  . setContainers ( containers )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", ". configureJavaClasspath ( project ,    task )  ;", "}", "}  )  ;", ". configureScalaDependencies ( project ,    task )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "final   EclipsePlugin   eclipsePlugin    =    this ;", "project . getPlugins (  )  . withType ( JavaBasePlugin . class ,    new   Action < JavaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( JavaBasePlugin   javaBasePlugin )     {", "EclipsePlugin . maybeAddTask ( project ,    eclipsePlugin ,    EclipsePlugin . ECLIPSE _ JDT _ TASK _ NAME ,    GenerateEclipseJdt . class ,    new   Action < GenerateEclipseJdt >  (  )     {", "@ Override", "public   void   execute ( GenerateEclipseJdt   task )     {", "task . setDescription (  \" Generates   the   Eclipse   JDT   settings   file .  \"  )  ;", "task . setOutputFile ( project . file (  \"  . settings / prefs \"  )  )  ;", "task . setInputFile ( project . file (  \"  . settings / prefs \"  )  )  ;", "EclipseJdt   jdt    =    task . getJdt (  )  ;", "model . setJdt ( jdt )  ;", "ConventionMapping   conventionMapping    =     (  ( IConventionAware )     ( jdt )  )  . getConventionMapping (  )  ;", "conventionMapping . map (  \" sourceCompatibility \"  ,    new   Callable < JavaVersion >  (  )     {", "@ Override", "public   JavaVersion   call (  )     {", "return   project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceCompatibility (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" targetCompatibility \"  ,    new   Callable < JavaVersion >  (  )     {", "@ Override", "public   JavaVersion   call (  )     {", "return   project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getTargetCompatibility (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" javaRuntimeName \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   EclipsePlugin . eclipseJavaRuntimeNameFor ( project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getTargetCompatibility (  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseJdt"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "EclipsePlugin . maybeAddTask ( project ,    this ,    EclipsePlugin . ECLIPSE _ PROJECT _ TASK _ NAME ,    GenerateEclipseProject . class ,    new   Action < GenerateEclipseProject >  (  )     {", "@ Override", "public   void   execute ( GenerateEclipseProject   task )     {", "final   EclipseProject   projectModel    =    task . getProjectModel (  )  ;", "task . setDescription (  \" Generates   the   Eclipse   project   file .  \"  )  ;", "task . setInputFile ( project . file (  \"  . project \"  )  )  ;", "task . setOutputFile ( project . file (  \"  . project \"  )  )  ;", "model . setProject ( projectModel )  ;", "final   String   defaultModuleName    =    uniqueProjectNameProvider . getUniqueName ( project )  ;", "projectModel . setName ( defaultModuleName )  ;", "final   ConventionMapping   convention    =     (  ( IConventionAware )     ( projectModel )  )  . getConventionMapping (  )  ;", "convention . map (  \" comment \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   project . getDescription (  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( JavaBasePlugin . class ,    new   Action < JavaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( JavaBasePlugin   javaBasePlugin )     {", "if    (  !  ( project . getPlugins (  )  . hasPlugin ( EarPlugin . class )  )  )     {", "projectModel . buildCommand (  \" javabuilder \"  )  ;", "}", "projectModel . natures (  \" javanature \"  )  ;", "convention . map (  \" linkedResources \"  ,    new   Callable < Set < Link >  >  (  )     {", "@ Override", "public   Set < Link >    call (  )     {", "return   new   LinkedResourcesCreator (  )  . links ( project )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( GroovyBasePlugin . class ,    new   Action < GroovyBasePlugin >  (  )     {", "@ Override", "public   void   execute ( GroovyBasePlugin   groovyBasePlugin )     {", "projectModel . getNatures (  )  . add ( projectModel . getNatures (  )  . indexOf (  \" javanature \"  )  ,     \" groovyNature \"  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( ScalaBasePlugin . class ,    new   Action < ScalaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( ScalaBasePlugin   scalaBasePlugin )     {", "projectModel . getBuildCommands (  )  . set ( Iterables . indexOf ( projectModel . getBuildCommands (  )  ,    new   com . google . common . base . Predicate < BuildCommand >  (  )     {", "@ Override", "public   boolean   apply ( BuildCommand   buildCommand )     {", "return   buildCommand . getName (  )  . equals (  \" javabuilder \"  )  ;", "}", "}  )  ,    new   BuildCommand (  \" scala - ide . sdt . core . scalabuilder \"  )  )  ;", "projectModel . getNatures (  )  . add ( projectModel . getNatures (  )  . indexOf (  \" javanature \"  )  ,     \" scala - ide . sdt . core . scalanature \"  )  ;", "}", "}  )  ;", "artifactRegistry . registerIdeArtifact ( new   EclipseProjectMetadata ( projectModel ,    project . getProjectDir (  )  ,    task )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseProject"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "task . getClasspath (  )  . setPlusConfigurations ( Lists . newArrayList ( project . getConfigurations (  )  . getByName (  \" compileClasspath \"  )  ,    project . getConfigurations (  )  . getByName (  \" runtimeClasspath \"  )  ,    project . getConfigurations (  )  . getByName (  \" testCompileClasspath \"  )  ,    project . getConfigurations (  )  . getByName (  \" testRuntimeClasspath \"  )  )  )  ;", "(  ( IConventionAware )     ( task . getClasspath (  )  )  )  . getConventionMapping (  )  . map (  \" classFolders \"  ,    new   Callable < List < File >  >  (  )     {", "@ Override", "public   List < File >    call (  )     {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . get ( JavaConvention . class )  . getSourceSets (  )  ;", "return   Lists . newArrayList ( Iterables . concat ( sourceSets . getByName (  \" main \"  )  . getOutput (  )  . getDirs (  )  ,    sourceSets . getByName (  \" test \"  )  . getOutput (  )  . getDirs (  )  )  )  ;", "}", "}  )  ;", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . get ( JavaConvention . class )  . getSourceSets (  )  ;", "task . dependsOn ( sourceSets . getByName (  \" main \"  )  . getOutput (  )  . getDirs (  )  )  ;", "task . dependsOn ( sourceSets . getByName (  \" test \"  )  . getOutput (  )  . getDirs (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureJavaClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . withType ( ScalaBasePlugin . class ,    new   Action < ScalaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( ScalaBasePlugin   scalaBasePlugin )     {", "task . getClasspath (  )  . containers (  \" scala - ide . sdt . launching . SCALA _ CONTAINER \"  )  ;", "project . getGradle (  )  . addBuildListener ( new   BuildAdapter (  )     {", "@ Override", "public   void   projectsEvaluated ( Gradle   gradle )     {", "final   List < String >    provided    =    Lists . newArrayList (  \" scala - library \"  ,     \" scala - swing \"  ,     \" scala - dbc \"  )  ;", "Predicate < Dependency >    dependencyInProvided    =    new   Predicate < Dependency >  (  )     {", "@ Override", "public   boolean   apply ( Dependency   dependency )     {", "return   provided . contains ( dependency . getName (  )  )  ;", "}", "}  ;", "List < Dependency >    dependencies    =    Lists . newArrayList ( Iterables . filter ( Iterables . concat ( Iterables . transform ( task . getClasspath (  )  . getPlusConfigurations (  )  ,    new   com . google . common . base . Function < Configuration ,    Iterable < Dependency >  >  (  )     {", "@ Override", "public   Iterable < Dependency >    apply ( Configuration   config )     {", "return   config . getAllDependencies (  )  ;", "}", "}  )  )  ,    dependencyInProvided )  )  ;", "if    (  !  ( dependencies . isEmpty (  )  )  )     {", "task . getClasspath (  )  . getMinusConfigurations (  )  . add ( project . getConfigurations (  )  . detachedConfiguration ( dependencies . toArray ( new   Dependency [  0  ]  )  )  )  ;", "}", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureScalaDependencies"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "return   new   Action < Plugin < Project >  >  (  )     {", "@ Override", "public   void   execute ( Plugin < Project >    plugin )     {", "project . getPluginManager (  )  . apply ( EclipseWtpPlugin . class )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createActionApplyingEclipseWtpPlugin"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "String   eclipseJavaVersion    =    EclipseJavaVersionMapper . toEclipseJavaVersion ( version )  ;", "switch    ( version )     {", "case   VERSION _  1  _  1     :", "return    \" JRE -  1  .  1  \"  ;", "case   VERSION _  1  _  2     :", "case   VERSION _  1  _  3     :", "case   VERSION _  1  _  4     :", "case   VERSION _  1  _  5     :", "return    \" J 2 SE -  \"     +    eclipseJavaVersion ;", "default    :", "return    \" JavaSE -  \"     +    eclipseJavaVersion ;", "}", "}", "METHOD_END"], "methodName": ["eclipseJavaRuntimeNameFor"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "TaskContainer   tasks    =    project . getTasks (  )  ;", "if    (  ( tasks . findByName ( taskName )  )     !  =    null )     {", "return ;", "}", "T   task    =    tasks . create ( taskName ,    taskType )  ;", "action . execute ( task )  ;", ". addWorker ( task )  ;", "}", "METHOD_END"], "methodName": ["maybeAddTask"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "SingleMessageLogger . nagUserOfDiscontinuedMethod (  \" performPostEvaluationActions \"  )  ;", "}", "METHOD_END"], "methodName": ["performPostEvaluationActions"], "fileName": "org.gradle.plugins.ide.eclipse.EclipsePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", "AfterEvaluateHelper . afterEvaluateOrExecute ( project ,    new   Action < Project >  (  )     {", "@ Override", "public   void   execute ( Project   project )     {", "Collection < Configuration >    plusConfigurations    =    model . getClasspath (  )  . getPlusConfigurations (  )  ;", "EclipseWtpComponent   component    =    model . getWtp (  )  . getComponent (  )  ;", "plusConfigurations . addAll ( component . getRootConfigurations (  )  )  ;", "plusConfigurations . addAll ( component . getLibConfigurations (  )  )  ;", "}", "}  )  ;", "model . getClasspath (  )  . getFile (  )  . whenMerged ( new   Action < Classpath >  (  )     {", "@ Override", "public   void   execute ( Classpath   classpath )     {", "new   WtpClasspathAttributeSupport ( project ,    model )  . enhance ( classpath )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( WarPlugin . class ,    new   Action < WarPlugin >  (  )     {", "@ Override", "public   void   execute ( WarPlugin   warPlugin )     {", "model . getClasspath (  )  . containers (  . WEB _ LIBS _ CONTAINER )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "Action < Object >    action    =    new   Action < Object >  (  )     {", "@ Override", "public   void   execute ( Object   ignored )     {", "project . getTasks (  )  . withType ( GenerateEclipseProject . class ,    new   Action < GenerateEclipseProject >  (  )     {", "@ Override", "public   void   execute ( GenerateEclipseProject   task )     {", "task . getProjectModel (  )  . buildCommand (  \" builder \"  )  ;", "task . getProjectModel (  )  . buildCommand (  \" validationbuilder \"  )  ;", "task . getProjectModel (  )  . natures (  \" nature \"  )  ;", "task . getProjectModel (  )  . natures (  \" ModuleCoreNature \"  )  ;", "task . getProjectModel (  )  . natures (  \" JavaEMFNature \"  )  ;", "}", "}  )  ;", "}", "}  ;", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    action )  ;", "project . getPlugins (  )  . withType ( EarPlugin . class ,    action )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseProject"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "maybeAddTask ( project ,    this ,    EclipseWtpPlugin . ECLIPSE _ WTP _ COMPONENT _ TASK _ NAME ,    GenerateEclipseWtpComponent . class ,    new   Action < GenerateEclipseWtpComponent >  (  )     {", "@ Override", "public   void   execute ( final   GenerateEclipseWtpComponent   task )     {", "task . setDescription (  \" Generates   the   Eclipse   WTP   component   settings   file .  \"  )  ;", "task . setInputFile ( project . file (  \"  . settings / component \"  )  )  ;", "task . setOutputFile ( project . file (  \"  . settings / component \"  )  )  ;", "model . getWtp (  )  . setComponent ( task . getComponent (  )  )  ;", "(  ( IConventionAware )     ( task . getComponent (  )  )  )  . getConventionMapping (  )  . map (  \" deployName \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return   model . getProject (  )  . getName (  )  ;", "}", "}  )  ;", "final   Set < Configuration >    libConfigurations    =    task . getComponent (  )  . getLibConfigurations (  )  ;", "final   Set < Configuration >    rootConfigurations    =    task . getComponent (  )  . getRootConfigurations (  )  ;", "final   Set < Configuration >    minusConfigurations    =    task . getComponent (  )  . getMinusConfigurations (  )  ;", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", "if    ( hasWarOrEarPlugin ( project )  )     {", "return ;", "}", "libConfigurations . add ( project . getConfigurations (  )  . getByName (  \" runtime \"  )  )  ;", "task . getComponent (  )  . setClassesDeployPath (  \"  /  \"  )  ;", "(  ( IConventionAware )     ( task . getComponent (  )  )  )  . getConventionMapping (  )  . map (  \" libDeployPath \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return    \"  .  .  /  \"  ;", "}", "}  )  ;", "(  ( IConventionAware )     ( task . getComponent (  )  )  )  . getConventionMapping (  )  . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   getMainSourceDirs ( project )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( WarPlugin . class ,    new   Action < WarPlugin >  (  )     {", "@ Override", "public   void   execute ( WarPlugin   warPlugin )     {", "libConfigurations . add ( project . getConfigurations (  )  . getByName (  \" runtime \"  )  )  ;", "minusConfigurations . add ( project . getConfigurations (  )  . getByName (  \" providedRuntime \"  )  )  ;", "task . getComponent (  )  . setClassesDeployPath (  \"  / WEB - INF / classes \"  )  ;", "ConventionMapping   convention    =     (  ( IConventionAware )     ( task . getComponent (  )  )  )  . getConventionMapping (  )  ;", "convention . map (  \" libDeployPath \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return    \"  / WEB - INF / lib \"  ;", "}", "}  )  ;", "convention . map (  \" contextPath \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return    (  ( War )     ( project . getTasks (  )  . getByName (  \" war \"  )  )  )  . getBaseName (  )  ;", "}", "}  )  ;", "convention . map (  \" resources \"  ,    new   Callable < List < WbResource >  >  (  )     {", "@ Override", "public   List < WbResource >    call (  )    throws   Exception    {", "return   Lists . newArrayList ( new   WbResource (  \"  /  \"  ,    project . getConvention (  )  . getPlugin ( WarPluginConvention . class )  . getWebAppDirName (  )  )  )  ;", "}", "}  )  ;", "convention . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   getMainSourceDirs ( project )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( EarPlugin . class ,    new   Action < EarPlugin >  (  )     {", "@ Override", "public   void   execute ( EarPlugin   earPlugin )     {", "rootConfigurations . clear (  )  ;", "rootConfigurations . add ( project . getConfigurations (  )  . getByName (  \" deploy \"  )  )  ;", "libConfigurations . clear (  )  ;", "libConfigurations . add ( project . getConfigurations (  )  . getByName (  \" earlib \"  )  )  ;", "task . getComponent (  )  . setClassesDeployPath (  \"  /  \"  )  ;", "final   ConventionMapping   convention    =     (  ( IConventionAware )     ( task . getComponent (  )  )  )  . getConventionMapping (  )  ;", "convention . map (  \" libDeployPath \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "String   deployPath    =     (  ( Ear )     ( project . getTasks (  )  . findByName ( EAR _ TASK _ NAME )  )  )  . getLibDirName (  )  ;", "if    (  !  ( deployPath . startsWith (  \"  /  \"  )  )  )     {", "deployPath    =     \"  /  \"     +    deployPath ;", "}", "return   deployPath ;", "}", "}  )  ;", "convention . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   project . files ( project . getConvention (  )  . getPlugin ( EarPluginConvention . class )  . getAppDirName (  )  )  . getFiles (  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", "convention . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   getMainSourceDirs ( project )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseWtpComponent"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "maybeAddTask ( project ,    this ,    EclipseWtpPlugin . ECLIPSE _ WTP _ FACET _ TASK _ NAME ,    GenerateEclipseWtpFacet . class ,    new   Action < GenerateEclipseWtpFacet >  (  )     {", "@ Override", "public   void   execute ( final   GenerateEclipseWtpFacet   task )     {", "task . setDescription (  \" Generates   the   Eclipse   WTP   facet   settings   file .  \"  )  ;", "task . setInputFile ( project . file (  \"  . settings / xml \"  )  )  ;", "task . setOutputFile ( project . file (  \"  . settings / xml \"  )  )  ;", "eclipseModel . getWtp (  )  . setFacet ( task . getFacet (  )  )  ;", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", "if    ( hasWarOrEarPlugin ( project )  )     {", "return ;", "}", "(  ( IConventionAware )     ( task . getFacet (  )  )  )  . getConventionMapping (  )  . map (  \" facets \"  ,    new   Callable < List < Facet >  >  (  )     {", "@ Override", "public   List < Facet >    call (  )    throws   Exception    {", "return   Lists . newArrayList ( new   Facet ( Facet . FacetType . fixed ,     \" jst . java \"  ,    null )  ,    new   Facet ( Facet . FacetType . installed ,     \" jst . utility \"  ,     \"  1  .  0  \"  )  ,    new   Facet ( Facet . FacetType . installed ,     \" jst . java \"  ,    toJavaFacetVersion ( project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceCompatibility (  )  )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( WarPlugin . class ,    new   Action < WarPlugin >  (  )     {", "@ Override", "public   void   execute ( WarPlugin   warPlugin )     {", "(  ( IConventionAware )     ( task . getFacet (  )  )  )  . getConventionMapping (  )  . map (  \" facets \"  ,    new   Callable < List < Facet >  >  (  )     {", "@ Override", "public   List < Facet >    call (  )    throws   Exception    {", "return   Lists . newArrayList ( new   Facet ( Facet . FacetType . fixed ,     \" jst . java \"  ,    null )  ,    new   Facet ( Facet . FacetType . fixed ,     \" jst . web \"  ,    null )  ,    new   Facet ( Facet . FacetType . installed ,     \" jst . web \"  ,     \"  2  .  4  \"  )  ,    new   Facet ( Facet . FacetType . installed ,     \" jst . java \"  ,    toJavaFacetVersion ( project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceCompatibility (  )  )  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( EarPlugin . class ,    new   Action < EarPlugin >  (  )     {", "@ Override", "public   void   execute ( EarPlugin   earPlugin )     {", "(  ( IConventionAware )     ( task . getFacet (  )  )  )  . getConventionMapping (  )  . map (  \" facets \"  ,    new   Callable < List < Facet >  >  (  )     {", "@ Override", "public   List < Facet >    call (  )    throws   Exception    {", "return   Lists . newArrayList ( new   Facet ( Facet . FacetType . fixed ,     \" jst . ear \"  ,    null )  ,    new   Facet ( Facet . FacetType . installed ,     \" jst . ear \"  ,     \"  5  .  0  \"  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureEclipseWtpFacet"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "return   project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . getByName (  \" main \"  )  . getAllSource (  )  . getSrcDirs (  )  ;", "}", "METHOD_END"], "methodName": ["getMainSourceDirs"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( project . getPlugins (  )  . hasPlugin ( WarPlugin . class )  )     |  |     ( project . getPlugins (  )  . hasPlugin ( EarPlugin . class )  )  ;", "}", "METHOD_END"], "methodName": ["hasWarOrEarPlugin"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( project . getTasks (  )  . findByName ( taskName )  )     !  =    null )     {", "return ;", "}", "T   task    =    project . getTasks (  )  . create ( taskName ,    taskType )  ;", "action . execute ( task )  ;", ". addWorker ( task )  ;", "}", "METHOD_END"], "methodName": ["maybeAddTask"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( version . equals ( VERSION _  1  _  5  )  )     {", "return    \"  5  .  0  \"  ;", "}", "if    ( version . equals ( VERSION _  1  _  6  )  )     {", "return    \"  6  .  0  \"  ;", "}", "return   version . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toJavaFacetVersion"], "fileName": "org.gradle.plugins.ide.eclipse.EclipseWtpPlugin"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "EclipseJdt   jdtModel    =    getJdt (  )  ;", "jdtModel . getFile (  )  . getBeforeMerged (  )  . execute ( jdtContent )  ;", "jdtContent . setSourceCompatibility ( jdtModel . getSourceCompatibility (  )  )  ;", "jdtContent . setTargetCompatibility ( jdtModel . getTargetCompatibility (  )  )  ;", "jdtModel . getFile (  )  . getWhenMerged (  )  . execute ( jdtContent )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   new   Jdt ( getTransformer (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   jdt ;", "}", "METHOD_END"], "methodName": ["getJdt"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseJdt"}, {"methodBody": ["METHOD_START", "{", "this . jdt    =    jdt ;", "}", "METHOD_END"], "methodName": ["setJdt"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   projectModel ;", "}", "METHOD_END"], "methodName": ["getProjectModel"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . projectModel    =    projectModel ;", "}", "METHOD_END"], "methodName": ["setProjectModel"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . component    =    component ;", "}", "METHOD_END"], "methodName": ["setComponent"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   facet ;", "}", "METHOD_END"], "methodName": ["getFacet"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "this . facet    =    facet ;", "}", "METHOD_END"], "methodName": ["setFacet"], "fileName": "org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "if    ( project . getState (  )  . getExecuted (  )  )     {", "action . execute ( project )  ;", "} else    {", "project . a ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["afterEvaluateOrExecute"], "fileName": "org.gradle.plugins.ide.eclipse.internal.AfterEvaluateHelper"}, {"methodBody": ["METHOD_START", "{", "return   eclipseProject . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.internal.EclipseProjectMetadata"}, {"methodBody": ["METHOD_START", "{", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "EclipseClasspath   classpath    =    project . getExtensions (  )  . getByType ( EclipseModel . class )  . getClasspath (  )  ;", "File   defaultOutputDir    =     ( classpath    =  =    null )     ?    project . file ( EclipsePluginConstants . DEFAULT _ PROJECT _ OUTPUT _ PATH )     :    classpath . getDefaultOutputDir (  )  ;", "List < SourceFolder >    sourceFolders    =    new   SourceFolder (  )  . getBasicExternalSourceFolders ( sourceSets ,    new   com . google . common . base . Function < File ,    String >  (  )     {", "@ Override", "public   String   apply ( File   dir )     {", "return   project . relativePath ( dir )  ;", "}", "}  ,    defaultOutputDir )  ;", "Set < Link >    links    =    Sets . newLinkedHashSetWithExpectedSize ( sourceFolders . size (  )  )  ;", "for    ( SourceFolder   sourceFolder    :    sourceFolders )     {", "links . add ( new   Link ( sourceFolder . getName (  )  ,     \"  2  \"  ,    sourceFolder . getAbsolutePath (  )  ,    null )  )  ;", "}", "return   links ;", "}", "METHOD_END"], "methodName": ["links"], "fileName": "org.gradle.plugins.ide.eclipse.internal.LinkedResourcesCreator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    allAttributes    =    Maps . newLinkedHashMap (  )  ;", "for    ( String   key    :    attributes . keySet (  )  )     {", "Object   value    =    attributes . get ( key )  ;", "if    (  ( value    !  =    null )     &  &     (  !  ( String . valueOf ( value )  . isEmpty (  )  )  )  )     {", "allAttributes . put ( key ,    value )  ;", "}", "}", "allAttributes . put (  \" kind \"  ,    getKind (  )  )  ;", "allAttributes . put (  \" path \"  ,    path )  ;", "if    (  ( exported )     &  &     (  !  (  ( this )    instanceof   SourceFolder )  )  )     {", "allAttributes . put (  \" exported \"  ,    true )  ;", "}", "Node   entryNode    =    node . appendNode (  \" centry \"  ,    allAttributes )  ;", "writeAccessRules ( entryNode )  ;", "writeEntryAttributes ( entryNode )  ;", "return   entryNode ;", "}", "METHOD_END"], "methodName": ["addClasspathEntry"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   accessRules ;", "}", "METHOD_END"], "methodName": ["getAccessRules"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   entryAttributes ;", "}", "METHOD_END"], "methodName": ["getEntryAttributes"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return    (  ( String )     ( entryAttributes . get ( AbstractClasspathEntry . NATIVE _ LIBRARY _ ATTRIBUTE )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNativeLibraryLocation"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   exported ;", "}", "METHOD_END"], "methodName": ["isExported"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    node . attribute (  \" exported \"  )  ;", "if    ( value    =  =    null )     {", "return   false ;", "} else", "if    ( value   instanceof   Boolean )     {", "return    (  ( Boolean )     ( value )  )  . booleanValue (  )  ;", "} else    {", "return   Boolean . valueOf (  (  ( String )     ( value )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isNodeExported"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   PathUtil . normalizePath ( path )  ;", "}", "METHOD_END"], "methodName": ["normalizePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "Set < AccessRule >    accessRules    =    Sets . newLinkedHashSet (  )  ;", "Noist   accessRulesNo    =     (  ( Noist )     ( noget (  \" accessrules \"  )  )  )  ;", "for    ( Object   accessRulesNo :    accessRulesNo )     {", "Noist   accessRuleNo    =     (  ( Noist )     (  (  ( No    ( accessRulesNo )  . get (  \" accessrule \"  )  )  )  ;", "for    ( Object   accessRuleNo :    accessRuleNo )     {", "NoruleNo =     (  ( No    ( accessRuleNo )  ;", "accessRules . add ( new   AccessRule (  (  ( String )     ( ruleNoattribute (  \" kind \"  )  )  )  ,     (  ( String )     ( ruleNoattribute (  \" pattern \"  )  )  )  )  )  ;", "}", "}", "return   accessRules ;", "}", "METHOD_END"], "methodName": ["readAccessRules"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "NodeList   attributesNodes    =     (  ( NodeList )     ( node . get (  \" attributes \"  )  )  )  ;", "for    ( Object   attributes    :    attributesNodes )     {", "NodeList   attributeNodes    =     (  ( NodeList )     (  (  ( Node )     ( attributes )  )  . get (  \" attribute \"  )  )  )  ;", "for    ( Object   attribute    :    attributeNodes )     {", "Node   attributeNode    =     (  ( Node )     ( attribute )  )  ;", "attributes . put (  (  ( String )     ( attributeNode . attribute (  \" name \"  )  )  )  ,    attributeNode . attribute (  \" value \"  )  )  ;", "}", "}", "return   attributes ;", "}", "METHOD_END"], "methodName": ["readEntryAttributes"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "this . accessRules    =    accessRules ;", "}", "METHOD_END"], "methodName": ["setAccessRules"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "this . exported    =    exported ;", "}", "METHOD_END"], "methodName": ["setExported"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "entryAttributes . put ( AbstractClasspathEntry . NATIVE _ LIBRARY _ ATTRIBUTE ,    location )  ;", "}", "METHOD_END"], "methodName": ["setNativeLibraryLocation"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( accessRules )     =  =    null )     |  |     ( accessRules . isEmpty (  )  )  )     {", "return ;", "}", "Node   accessRulesNode ;", "NodeList   accessRulesNodes    =     (  ( NodeList )     ( node . get (  \" accessrules \"  )  )  )  ;", "if    (  ( accessRulesNodes . size (  )  )     =  =     0  )     {", "accessRulesNode    =    node . appendNode (  \" accessrules \"  )  ;", "} else    {", "accessRulesNode    =     (  ( Node )     ( accessRulesNodes . get (  0  )  )  )  ;", "}", "for    ( AccessRule   rule    :    accessRules )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" kind \"  ,    rule . getKind (  )  )  ;", "attributes . put (  \" pattern \"  ,    rule . getPattern (  )  )  ;", "accessRulesNode . appendNode (  \" accessrule \"  ,    attributes )  ;", "}", "}", "METHOD_END"], "methodName": ["writeAccessRules"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    effectiveEntryAttrs    =    Maps . newLinkedHashMap (  )  ;", "for    ( String   key    :    entryAttributes . keySet (  )  )     {", "Object   value    =    entryAttributes . get ( key )  ;", "if    ( value    !  =    null )     {", "effectiveEntryAttrs . put ( key ,    value )  ;", "}", "}", "if    ( effectiveEntryAttrs . isEmpty (  )  )     {", "return ;", "}", "Node   attributesNode ;", "NodeList   attributesNodes    =     (  ( NodeList )     ( node . get (  \" attributes \"  )  )  )  ;", "if    (  ( attributesNodes . size (  )  )     =  =     0  )     {", "attributesNode    =    node . appendNode (  \" attributes \"  )  ;", "} else    {", "attributesNode    =     (  ( Node )     ( attributesNodes . get (  0  )  )  )  ;", "}", "for    ( String   key    :    effectiveEntryAttrs . keySet (  )  )     {", "Object   value    =    effectiveEntryAttrs . get ( key )  ;", "Map < String ,    Object >    attrs    =    Maps . newLinkedHashMap (  )  ;", "attrs . put (  \" name \"  ,    key )  ;", "attrs . put (  \" value \"  ,    value )  ;", "attributesNode . appendNode (  \" attribute \"  ,    attrs )  ;", "}", "}", "METHOD_END"], "methodName": ["writeEntryAttributes"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   javadocPath ;", "}", "METHOD_END"], "methodName": ["getJavadocPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "return   library ;", "}", "METHOD_END"], "methodName": ["getLibrary"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "return   moduleVersion ;", "}", "METHOD_END"], "methodName": ["getModuleVersion"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "return   sourcePath ;", "}", "METHOD_END"], "methodName": ["getSourcePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "this . javadocPath    =    path ;", "if    ( path    !  =    null )     {", "String   location    =    path . getJarURL (  )  ;", "getEntryAttributes (  )  . put (  . ATTRIBUTE _ JAVADOC _ LOCATION ,    location )  ;", "} else    {", "getEntryAttributes (  )  . remove (  . ATTRIBUTE _ JAVADOC _ LOCATION )  ;", "}", "}", "METHOD_END"], "methodName": ["setJavadocPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "this . library    =    library ;", "setPath ( library . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["setLibrary"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "this . moduleVersion    =    moduleVersion ;", "}", "METHOD_END"], "methodName": ["setModuleVersion"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "this . sourcePath    =    sourcePath ;", "}", "METHOD_END"], "methodName": ["setSourcePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.AbstractLibrary"}, {"methodBody": ["METHOD_START", "{", "return   kind ;", "}", "METHOD_END"], "methodName": ["getKind"], "fileName": "org.gradle.plugins.ide.eclipse.model.AccessRule"}, {"methodBody": ["METHOD_START", "{", "return   pattern ;", "}", "METHOD_END"], "methodName": ["getPattern"], "fileName": "org.gradle.plugins.ide.eclipse.model.AccessRule"}, {"methodBody": ["METHOD_START", "{", "this . kind    =    kind ;", "}", "METHOD_END"], "methodName": ["setKind"], "fileName": "org.gradle.plugins.ide.eclipse.model.AccessRule"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "}", "METHOD_END"], "methodName": ["setPattern"], "fileName": "org.gradle.plugins.ide.eclipse.model.AccessRule"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.plugins.ide.eclipse.model.BuildCommand"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.BuildCommand"}, {"methodBody": ["METHOD_START", "{", "this . arguments    =    arguments ;", "}", "METHOD_END"], "methodName": ["setArguments"], "fileName": "org.gradle.plugins.ide.eclipse.model.BuildCommand"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.BuildCommand"}, {"methodBody": ["METHOD_START", "{", "Set < ClasspathEntry >    updatedEntries    =    Sets . newLinkedHashSet (  )  ;", "for    ( ClasspathEntry   entry    :    entries )     {", "if    (  (  (  !  ( isDependency ( entry )  )  )     &  &     (  !  ( isJreContainer ( entry )  )  )  )     &  &     (  !  ( isOutputLocation ( entry )  )  )  )     {", "updatedEntries . add ( entry )  ;", "}", "}", "updatedEntries . addAll ( newEntries )  ;", "return   entries    =    Lists . newArrayList ( updatedEntries )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "if    ( reference   instanceof   File )     {", "return   fileReferenceFactory . fromFile (  (  ( File )     ( reference )  )  )  ;", "} else", "if    ( reference   instanceof   String )     {", "return   fileReferenceFactory . fromVariablePath (  (  ( String )     ( reference )  )  )  ;", "} else    {", "String   type    =     ( reference    =  =    null )     ?     \" null \"     :    reference . get (  )  . getName (  )  ;", "throw   new   RuntimeException (  (  (  \" File   reference   can   only   be   created   from   File   or   String   instances   but    \"     +    type )     +     \"    was   passed \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fileReference"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "return   entries ;", "}", "METHOD_END"], "methodName": ["getEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "return    ( entry   instanceof   ProjectDependency )     |  |     ( entry   instanceof   AbstractLibrary )  ;", "}", "METHOD_END"], "methodName": ["isDependency"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "return    ( entry   instanceof   Container )     &  &     (  (  ( Container )     ( entry )  )  . getPath (  )  . startsWith (  \" JRE _ CONTAINER \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isJreContainer"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "return   entry   instanceof   Output ;", "}", "METHOD_END"], "methodName": ["isOutputLocation"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "this . entries    =    entries ;", "}", "METHOD_END"], "methodName": ["setEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.Classpath"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( containers )  ;", "this . containers . addAll ( Arrays . asList ( containers )  )  ;", "}", "METHOD_END"], "methodName": ["containers"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configure ( closure ,    file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "action . execute ( file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   classFolders ;", "}", "METHOD_END"], "methodName": ["getClassFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   containers ;", "}", "METHOD_END"], "methodName": ["getContainers"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   defaultOutputDir ;", "}", "METHOD_END"], "methodName": ["getDefaultOutputDir"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "FileReferenceFactory   referenceFactory    =    new   FileReferenceFactory (  )  ;", "for    ( Map . Entry < String ,    File >    entry    :    Variables . entrySet (  )  )     {", "referenceFactory . addPathVariable ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "return   referenceFactory ;", "}", "METHOD_END"], "methodName": ["getFileReferenceFactory"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   minusConfigurations ;", "}", "METHOD_END"], "methodName": ["getMinusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   pathVariables ;", "}", "METHOD_END"], "methodName": ["getPathVariables"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   plusConfigurations ;", "}", "METHOD_END"], "methodName": ["getPlusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   sourceSets ;", "}", "METHOD_END"], "methodName": ["getSourceSets"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   downloadJavadoc ;", "}", "METHOD_END"], "methodName": ["isDownloadJavadoc"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   downloadSources ;", "}", "METHOD_END"], "methodName": ["isDownloadSources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "return   projectDependenciesOnly ;", "}", "METHOD_END"], "methodName": ["isProjectDependenciesOnly"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "file . getBeforeMerged (  )  . execute ( xmlClasspath )  ;", "List < ClasspathEntry >    entries    =    resolveDependencies (  )  ;", "xmlClasspath . configure ( entries )  ;", "file . getWhenMerged (  )  . execute ( xmlClasspath )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "ClasspathFactory   classpathFactory    =    new   ClasspathFactory ( this ,     (  ( ProjectInternal )     ( project )  )  . getServices (  )  . get ( IdeArtifactRegistry . class )  )  ;", "return   classpathFactory . createEntries (  )  ;", "}", "METHOD_END"], "methodName": ["resolveDependencies"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . classFolders    =    classFolders ;", "}", "METHOD_END"], "methodName": ["setClassFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . containers    =    containers ;", "}", "METHOD_END"], "methodName": ["setContainers"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . defaultOutputDir    =    defaultOutputDir ;", "}", "METHOD_END"], "methodName": ["setDefaultOutputDir"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . downloadJavadoc    =    downloadJavadoc ;", "}", "METHOD_END"], "methodName": ["setDownloadJavadoc"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . downloadSources    =    downloadSources ;", "}", "METHOD_END"], "methodName": ["setDownloadSources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . file    =    file ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . minusConfigurations    =    minusConfigurations ;", "}", "METHOD_END"], "methodName": ["setMinusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . pathVariables    =    pathVariables ;", "}", "METHOD_END"], "methodName": ["setPathVariables"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . plusConfigurations    =    plusConfigurations ;", "}", "METHOD_END"], "methodName": ["setPlusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . projectDependenciesOnly    =    projectDependenciesOnly ;", "}", "METHOD_END"], "methodName": ["setProjectDependenciesOnly"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "this . sourceSets    =    sourceSets ;", "}", "METHOD_END"], "methodName": ["setSourceSets"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseClasspath"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configure ( closure ,    file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "action . execute ( file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   javaRuntimeName ;", "}", "METHOD_END"], "methodName": ["getJavaRuntimeName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   sourceCompatibility ;", "}", "METHOD_END"], "methodName": ["getSourceCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "return   targetCompatibility ;", "}", "METHOD_END"], "methodName": ["getTargetCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "this . javaRuntimeName    =    javaRuntimeName ;", "}", "METHOD_END"], "methodName": ["setJavaRuntimeName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "JavaVersion   version    =    JavaVersion . toVersion ( sourceCompatibility )  ;", "if    ( version    !  =    null )     {", "this . sourceCompatibility    =    version ;", "}", "}", "METHOD_END"], "methodName": ["setSourceCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "setSourceCompatibility (  (  ( Object )     ( sourceCompatibility )  )  )  ;", "}", "METHOD_END"], "methodName": ["setSourceCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "JavaVersion   version    =    JavaVersion . toVersion ( targetCompatibility )  ;", "if    ( version    !  =    null )     {", "this . targetCompatibility    =    version ;", "}", "}", "METHOD_END"], "methodName": ["setTargetCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "setTargetCompatibility (  (  ( Object )     ( targetCompatibility )  )  )  ;", "}", "METHOD_END"], "methodName": ["setTargetCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseJdt"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    classpath )  ;", "}", "METHOD_END"], "methodName": ["classpath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( classpath )  ;", "}", "METHOD_END"], "methodName": ["classpath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "return   jdt ;", "}", "METHOD_END"], "methodName": ["getJdt"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "return   wtp ;", "}", "METHOD_END"], "methodName": ["getWtp"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    jdt )  ;", "}", "METHOD_END"], "methodName": ["jdt"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( jdt )  ;", "}", "METHOD_END"], "methodName": ["jdt"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( pathVariables )  ;", "classpath . getPathVariables (  )  . putAll ( pathVariables )  ;", "if    (  (  ( wtp )     !  =    null )     &  &     (  ( wtp . getComponent (  )  )     !  =    null )  )     {", "wtp . getComponent (  )  . getPathVariables (  )  . putAll ( pathVariables )  ;", "}", "}", "METHOD_END"], "methodName": ["pathVariables"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    project )  ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( project )  ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "this . jdt    =    jdt ;", "}", "METHOD_END"], "methodName": ["setJdt"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "this . project    =    project ;", "}", "METHOD_END"], "methodName": ["setProject"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "this . wtp    =    wtp ;", "}", "METHOD_END"], "methodName": ["setWtp"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    wtp )  ;", "}", "METHOD_END"], "methodName": ["wtp"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( wtp )  ;", "}", "METHOD_END"], "methodName": ["wtp"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseModel"}, {"methodBody": ["METHOD_START", "{", "assert   buildCommand    !  =    null ;", "buildCommands . add ( new   BuildCommand ( buildCommand )  )  ;", "}", "METHOD_END"], "methodName": ["buildCommand"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "assert   buildCommand    !  =    null ;", "buildCommands . add ( new   BuildCommand ( buildCommand ,    args )  )  ;", "}", "METHOD_END"], "methodName": ["buildCommand"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "action . execute ( file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   buildCommands ;", "}", "METHOD_END"], "methodName": ["getBuildCommands"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   comment ;", "}", "METHOD_END"], "methodName": ["getComment"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   linkedResources ;", "}", "METHOD_END"], "methodName": ["getLinkedResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   natures ;", "}", "METHOD_END"], "methodName": ["getNatures"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   referencedProjects ;", "}", "METHOD_END"], "methodName": ["getReferencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   resourceFilters ;", "}", "METHOD_END"], "methodName": ["getResourceFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "Set < String >    illegalArgs    =    Sets . difference ( args . keySet (  )  ,    EclipseProject . VALID _ LINKED _ RESOURCE _ ARGS )  ;", "if    (  !  ( illegalArgs . isEmpty (  )  )  )     {", "throw   new   InvalidUserDataException (  (  (  (  \" You   provided   illegal   argument   for   a   link :     \"     +    illegalArgs )     +     \"  .    Valid   link   args   are :     \"  )     +     ( EclipseProject . VALID _ LINKED _ RESOURCE _ ARGS )  )  )  ;", "}", "linkedResources . add ( new   Link ( args . get (  \" name \"  )  ,    args . get (  \" type \"  )  ,    args . get (  \" location \"  )  ,    args . get (  \" locationUri \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["linkedResource"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "Project   decoratedProject    =    new   NonRenamableProject ( xmlProject )  ;", "file . getBeforeMerged (  )  . execute ( decoratedProject )  ;", "xmlProject . configure ( this )  ;", "file . getWhenMerged (  )  . execute ( decoratedProject )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlProject"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "assert   natures    !  =    null ;", "this . natures . addAll ( Arrays . asList ( natures )  )  ;", "}", "METHOD_END"], "methodName": ["natures"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "assert   referencedProjects    !  =    null ;", "this . referencedProjects . addAll ( Arrays . asList ( referencedProjects )  )  ;", "}", "METHOD_END"], "methodName": ["referencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   resourceFilter ( new   ClosureBackedAction < ResourceFilter >  ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["resourceFilter"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "ResourceFilter   f    =    new   DefaultResourceFilter (  )  ;", "configureAion . execute ( f )  ;", "resourceFilters . add ( f )  ;", "return   f ;", "}", "METHOD_END"], "methodName": ["resourceFilter"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . buildCommands    =    buildCommands ;", "}", "METHOD_END"], "methodName": ["setBuildCommands"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . comment    =    comment ;", "}", "METHOD_END"], "methodName": ["setComment"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . linkedResources    =    linkedResources ;", "}", "METHOD_END"], "methodName": ["setLinkedResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . natures    =    natures ;", "}", "METHOD_END"], "methodName": ["setNatures"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . referencedProjects    =    referencedProjects ;", "}", "METHOD_END"], "methodName": ["setReferencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseProject"}, {"methodBody": ["METHOD_START", "{", "configure ( action ,    component )  ;", "}", "METHOD_END"], "methodName": ["component"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "action . execute ( component )  ;", "}", "METHOD_END"], "methodName": ["component"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "configure ( action ,    facet )  ;", "}", "METHOD_END"], "methodName": ["facet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "action . execute ( facet )  ;", "}", "METHOD_END"], "methodName": ["facet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "return   component ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "return   facet ;", "}", "METHOD_END"], "methodName": ["getFacet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "this . component    =    component ;", "}", "METHOD_END"], "methodName": ["setComponent"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "this . facet    =    facet ;", "}", "METHOD_END"], "methodName": ["setFacet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtp"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "action . execute ( file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   classesDeployPath ;", "}", "METHOD_END"], "methodName": ["getClassesDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   contextPath ;", "}", "METHOD_END"], "methodName": ["getContextPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   deployName ;", "}", "METHOD_END"], "methodName": ["getDeployName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "FileReferenceFactory   referenceFactory    =    new   FileReferenceFactory (  )  ;", "for    ( Map . Entry < String ,    File >    pathVariable    :    pathVariables . rySet (  )  )     {", "referenceFactory . addPathVariable ( pathVariable . getKey (  )  ,    pathVariable . getValue (  )  )  ;", "}", "return   referenceFactory ;", "}", "METHOD_END"], "methodName": ["getFileReferenceFactory"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   libConfigurations ;", "}", "METHOD_END"], "methodName": ["getLibConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   libDeployPath ;", "}", "METHOD_END"], "methodName": ["getLibDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   minusConfigurations ;", "}", "METHOD_END"], "methodName": ["getMinusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   pathVariables ;", "}", "METHOD_END"], "methodName": ["getPathVariables"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   getLibConfigurations (  )  ;", "}", "METHOD_END"], "methodName": ["getPlusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   resources ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   rootConfigurations ;", "}", "METHOD_END"], "methodName": ["getRootConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   sourceDirs ;", "}", "METHOD_END"], "methodName": ["getSourceDirs"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "file . getBeforeMerged (  )  . execute ( xmlComponent )  ;", "new   Factory ( project )  . configure ( this ,    xmlComponent )  ;", "file . getWhenMerged (  )  . execute ( xmlComponent )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlComponent"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "properties    =    Lists . newArrayList ( Iterables . concat ( getProperties (  )  ,    Collections . singleton ( new   WbProperty ( args . get (  \" name \"  )  ,    args . get (  \" value \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "resources    =    Lists . newArrayList ( Iterables . concat ( getResources (  )  ,    Collections . singleton ( new   WbResource ( args . get (  \" deployPath \"  )  ,    args . get (  \" sourcePath \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resource"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . classesDeployPath    =    classesDeployPath ;", "}", "METHOD_END"], "methodName": ["setClassesDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . deployName    =    deployName ;", "}", "METHOD_END"], "methodName": ["setDeployName"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . libConfigurations    =    libConfigurations ;", "}", "METHOD_END"], "methodName": ["setLibConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . libDeployPath    =    libDeployPath ;", "}", "METHOD_END"], "methodName": ["setLibDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . minusConfigurations    =    minusConfigurations ;", "}", "METHOD_END"], "methodName": ["setMinusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . pathVariables    =    pathVariables ;", "}", "METHOD_END"], "methodName": ["setPathVariables"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "setLibConfigurations ( plusConfigurations )  ;", "}", "METHOD_END"], "methodName": ["setPlusConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . properties    =    properties ;", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . resources    =    resources ;", "}", "METHOD_END"], "methodName": ["setResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . rootConfigurations    =    rootConfigurations ;", "}", "METHOD_END"], "methodName": ["setRootConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . sourceDirs    =    sourceDirs ;", "}", "METHOD_END"], "methodName": ["setSourceDirs"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent"}, {"methodBody": ["METHOD_START", "{", "facets    =    Lists . newArrayList ( Iterables . concat ( getFacets (  )  ,    Collections . singleton ( ConfigureUtil . configureByMap ( args ,    new   Facet (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["facet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "action . execute ( file )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "return   facets ;", "}", "METHOD_END"], "methodName": ["getFacets"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "file . getBeforeMerged (  )  . execute ( xmlFacet )  ;", "xmlFacet . configure ( getFacets (  )  )  ;", "file . getWhenMerged (  )  . execute ( xmlFacet )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlFacet"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "this . facets    =    facets ;", "}", "METHOD_END"], "methodName": ["setFacets"], "fileName": "org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" facet \"  ,    name )  ;", "if    (  ( type )     =  =    Type . installed )  )     {", "attributes . put (  \" version \"  ,    version )  ;", "}", "node . appendNode ( type . name (  )  ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["appendNode"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "this . version    =    version ;", "}", "METHOD_END"], "methodName": ["setVersion"], "fileName": "org.gradle.plugins.ide.eclipse.model.Facet"}, {"methodBody": ["METHOD_START", "{", "this . sourceCompatibility    =    sourceCompatibility ;", "}", "METHOD_END"], "methodName": ["setSourceCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.Jdt"}, {"methodBody": ["METHOD_START", "{", "this . targetCompatibility    =    targetCompatibility ;", "}", "METHOD_END"], "methodName": ["setTargetCompatibility"], "fileName": "org.gradle.plugins.ide.eclipse.model.Jdt"}, {"methodBody": ["METHOD_START", "{", "return   location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "return   locationUri ;", "}", "METHOD_END"], "methodName": ["getLocationUri"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "this . location    =    location ;", "}", "METHOD_END"], "methodName": ["setLocation"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "this . locationUri    =    locationUri ;", "}", "METHOD_END"], "methodName": ["setLocationUri"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Link"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.Output"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.Output"}, {"methodBody": ["METHOD_START", "{", "Node   buildSpec    =    getXml (  )  . appendNode (  \" buildSpec \"  )  ;", "for    ( BuildCommand   command    :    buildCommands )     {", "Node   commandNode    =    buildSpec . appendNode (  \" buildCommand \"  )  ;", "commandNode . appendNode (  \" name \"  ,    command . getName (  )  )  ;", "Node   argumentsNode    =    commandNode . appendNode (  \" arguments \"  )  ;", "for    ( Map . Entry < String ,    String >    argument    :    command . getArguments (  )  . entrySet (  )  )     {", "Node   dictionaryNode    =    argumentsNode . appendNode (  \" dictionary \"  )  ;", "dictionaryNode . appendNode (  \" key \"  ,    argument . getKey (  )  )  ;", "dictionaryNode . appendNode (  \" value \"  ,    argument . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addBuildSpecToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   parent    =    getXml (  )  . appendNode (  \" linkedResources \"  )  ;", "for    ( Link   link    :    linkedResources )     {", "Node   linkNode    =    parent . appendNode (  \" link \"  )  ;", "linkNode . appendNode (  \" name \"  ,    link . getName (  )  )  ;", "linkNode . appendNode (  \" type \"  ,    link . getType (  )  )  ;", "if    (  !  ( isNullOrEmpty ( link . getLocation (  )  )  )  )     {", "linkNode . appendNode (  \" location \"  ,    link . getLocation (  )  )  ;", "}", "if    (  !  ( isNullOrEmpty ( link . getLocationUri (  )  )  )  )     {", "linkNode . appendNode (  \" locationURI \"  ,    link . getLocationUri (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addLinkedResourcesToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   naturesNode    =    getXml (  )  . appendNode (  \" natures \"  )  ;", "for    ( String   nature    :    natures )     {", "naturesNode . appendNode (  \" nature \"  ,    nature )  ;", "}", "}", "METHOD_END"], "methodName": ["addNaturesToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   referencedProjectsNode    =    getXml (  )  . appendNode (  \" projects \"  )  ;", "for    ( String   projectName    :    referencedProjects )     {", "referencedProjectsNode . appendNode (  \" project \"  ,    projectName )  ;", "}", "}", "METHOD_END"], "methodName": ["addReferencedProjectsToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   matcherNode    =    parent . appendNode (  \" matcher \"  )  ;", "matcherNode . appendNode (  \" id \"  ,    matcher . getId (  )  )  ;", "if    (  !  ( isNullOrEmpty ( matcher . getArguments (  )  )  )  )     {", "matcherNode . appendNode (  \" arguments \"  ,    matcher . getArguments (  )  )  ;", "} else", "if    (  !  ( matcher . getChildren (  )  . isEmpty (  )  )  )     {", "Node   argumentsNode    =    matcherNode . appendNode (  \" arguments \"  )  ;", "for    ( ResourceFilterMatcher   m    :    matcher . getChildren (  )  )     {", "addResourceFilterMatcherToXml ( argumentsNode ,    m )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addResourceFilterMatcherToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   parent    =    getXml (  )  . appendNode (  \" filteredResources \"  )  ;", "int   filterId    =     1  ;", "for    ( ResourceFilter   resourceFilter    :    resourceFilters )     {", "Node   filterNode    =    parent . appendNode (  \" filter \"  )  ;", "filterNode . appendNode (  \" id \"  ,     ( filterId +  +  )  )  ;", "int   type    =    getResourceFilterType ( resourceFilter )  ;", "filterNode . appendNode (  \" type \"  ,    type )  ;", "filterNode . appendNode (  \" name \"  )  ;", "addResourceFilterMatcherToXml ( filterNode ,    resourceFilter . getMatcher (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addResourceFiltersToXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "name    =    nullToEmpty ( eclipseProject . getName (  )  )  ;", "comment    =    nullToEmpty ( eclipseProject . getComment (  )  )  ;", "referencedProjects . addAll ( eclipseProject . getReferencedProjects (  )  )  ;", "natures . addAll ( eclipseProject . getNatures (  )  )  ;", "natures    =    Lists . newArrayList ( Sets . newLinkedHashSet ( natures )  )  ;", "buildCommands . addAll ( eclipseProject . getBuildCommands (  )  )  ;", "buildCommands    =    Lists . newArrayList ( Sets . newLinkedHashSet ( buildCommands )  )  ;", "resourceFilters . addAll ( eclipseProject . getResourceFilters (  )  )  ;", "return   linkedResources . addAll ( eclipseProject . getLinkedResources (  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   buildCommands ;", "}", "METHOD_END"], "methodName": ["getBuildCommands"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   comment ;", "}", "METHOD_END"], "methodName": ["getComment"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   linkedResources ;", "}", "METHOD_END"], "methodName": ["getLinkedResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   natures ;", "}", "METHOD_END"], "methodName": ["getNatures"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   referencedProjects ;", "}", "METHOD_END"], "methodName": ["getReferencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "int   type    =     0  ;", "switch    ( resourceFilter . getType (  )  )     {", "case   INCLUDE _ ONLY    :", "type    |  =     1  ;", "break ;", "case   EXCLUDE _ ALL    :", "type    |  =     2  ;", "break ;", "}", "switch    ( resourceFilter . getAppliesTo (  )  )     {", "case   FILES    :", "type    |  =     4  ;", "break ;", "case   FOLDERS    :", "type    |  =     8  ;", "break ;", "case   FILES _ AND _ FOLDERS    :", "type    |  =     1  2  ;", "break ;", "}", "if    ( resourceFilter . isRecursive (  )  )     {", "type    |  =     1  6  ;", "}", "return   type ;", "}", "METHOD_END"], "methodName": ["getResourceFilterType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   resourceFilters ;", "}", "METHOD_END"], "methodName": ["getResourceFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkArgument (  ( type    >  =     0  )  )  ;", "return    ( type    &     1  6  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isResourceFilterTypeBitmaskRecursive"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   commandNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( getXml (  )  ,     \" buildSpec \"  )  ,     \" buildCommand \"  )  )     {", "String   name    =    XmlPersistableConfigurationObject . findFirstChildNamed ( commandNode ,     \" name \"  )  . text (  )  ;", "Map < String ,    String >    arguments    =    Maps . newLinkedHashMap (  )  ;", "for    ( Node   dictionaryNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( commandNode ,     \" arguments \"  )  ,     \" dictionary \"  )  )     {", "String   key    =    XmlPersistableConfigurationObject . findFirstChildNamed ( dictionaryNode ,     \" key \"  )  . text (  )  ;", "String   value    =    XmlPersistableConfigurationObject . findFirstChildNamed ( dictionaryNode ,     \" value \"  )  . text (  )  ;", "arguments . put ( key ,    value )  ;", "}", "buildCommands . add ( new   BuildCommand ( name ,    arguments )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readBuildCommands"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   linkNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( getXml (  )  ,     \" linkedResources \"  )  ,     \" link \"  )  )     {", "Node   nameNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( linkNode ,     \" name \"  )  ;", "Node   typeNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( linkNode ,     \" type \"  )  ;", "Node   locationNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( linkNode ,     \" location \"  )  ;", "Node   locationUriNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( linkNode ,     \" locationURI \"  )  ;", "linkedResources . add ( new   Link (  ( nameNode    !  =    null    ?    nameNode . text (  )     :    null )  ,     ( typeNode    !  =    null    ?    typeNode . text (  )     :    null )  ,     ( locationNode    !  =    null    ?    locationNode . text (  )     :    null )  ,     ( locationUriNode    !  =    null    ?    locationUriNode . text (  )     :    null )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readLinkedResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   natureNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( getXml (  )  ,     \" natures \"  )  ,     \" nature \"  )  )     {", "natures . add ( natureNode . text (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readNatures"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   projectNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( getXml (  )  ,     \" projects \"  )  ,     \" project \"  )  )     {", "referenceds . add ( projectNode . text (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readReferencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "if    ( matcherNode    =  =    null )     {", "return   null ;", "}", "Node   idNode    =    XmlPersistableConfigurationOb . findFirstChildNamed ( matcherNode ,     \" id \"  )  ;", "Node   argumentsNode    =    XmlPersistableConfigurationOb . findFirstChildNamed ( matcherNode ,     \" arguments \"  )  ;", "String   arguments    =    null ;", "Set < ResourceFilterMatcher >    children    =    Sets . newLinkedHashSet (  )  ;", "if    (  ( argumentsNode    !  =    null )     &  &     (  ( XmlPersistableConfigurationOb . findFirstChildNamed ( argumentsNode ,     \" matcher \"  )  )     !  =    null )  )     {", "for    ( Node   childMatcherNode    :    XmlPersistableConfigurationOb . getChildren ( argumentsNode ,     \" matcher \"  )  )     {", "ResourceFilterMatcher   childMatcher    =    readResourceFilterMatcher ( childMatcherNode )  ;", "if    ( childMatcher    !  =    null )     {", "children . add ( childMatcher )  ;", "}", "}", "} else    {", "arguments    =     ( argumentsNode    !  =    null )     ?    argumentsNode . text (  )     :    null ;", "}", "return   new   DefaultResourceFilterMatcher (  ( idNode    !  =    null    ?    idNode . text (  )     :    null )  ,    arguments ,    children )  ;", "}", "METHOD_END"], "methodName": ["readResourceFilterMatcher"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   filterNode    :    XmlPersistableConfigurationObject . getChildren ( XmlPersistableConfigurationObject . findFirstChildNamed ( getXml (  )  ,     \" filteredResources \"  )  ,     \" filter \"  )  )     {", "Node   typeNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( filterNode ,     \" type \"  )  ;", "Node   matcherNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( filterNode ,     \" matcher \"  )  ;", "String   typeString    =     ( typeNode    !  =    null )     ?    typeNode . text (  )     :    null ;", "int   typeBitmask    =    Integer . parseInt ( typeString )  ;", "ResourceFilterAppliesTo   appliesTo    =    resourceFilterTypeBitmaskToAppliesTo ( typeBitmask )  ;", "ResourceFilterType   type    =    resourceFilterTypeBitmaskToType ( typeBitmask )  ;", "boolean   recursive    =    isResourceFilterTypeBitmaskRecursive ( typeBitmask )  ;", "ResourceFilterMatcher   matcher    =    readResourceFilterMatcher ( matcherNode )  ;", "resourceFilters . add ( new   DefaultResourceFilter ( appliesTo ,    type ,    recursive ,    matcher )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readResourceFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkArgument (  ( type    >  =     0  )  )  ;", "if    (  (  ( type    &     8  )     !  =     0  )     &  &     (  ( type    &     4  )     !  =     0  )  )     {", "return   ResourceFilterAppliesTo . FILES _ AND _ FOLDERS ;", "}", "if    (  ( type    &     8  )     !  =     0  )     {", "return   ResourceFilterAppliesTo . FOLDERS ;", "}", "if    (  ( type    &     4  )     !  =     0  )     {", "return   ResourceFilterAppliesTo . FILES ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resourceFilterTypeBitmaskToAppliesTo"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkArgument (  ( type    >  =     0  )  )  ;", "if    (  ( type    &     1  )     !  =     0  )     {", "return   ResourceFilterType . INCLUDE _ ONLY ;", "}", "if    (  ( type    &     2  )     !  =     0  )     {", "return   ResourceFilterType . EXCLUDE _ ALL ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resourceFilterTypeBitmaskToType"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . buildCommands    =    buildCommands ;", "}", "METHOD_END"], "methodName": ["setBuildCommands"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . comment    =    comment ;", "}", "METHOD_END"], "methodName": ["setComment"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . linkedResources    =    linkedResources ;", "}", "METHOD_END"], "methodName": ["setLinkedResources"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . natures    =    natures ;", "}", "METHOD_END"], "methodName": ["setNatures"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . referencedProjects    =    referencedProjects ;", "}", "METHOD_END"], "methodName": ["setReferencedProjects"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . resourceFilters    =    resourceFilters ;", "}", "METHOD_END"], "methodName": ["setResourceFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.Project"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkArgument ( path . startsWith (  \"  /  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["assertPathIsValid"], "fileName": "org.gradle.plugins.ide.eclipse.model.ProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   dir . getAbsolutePath (  )  ;", "}", "METHOD_END"], "methodName": ["getAbsolutePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   dir ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   excludes ;", "}", "METHOD_END"], "methodName": ["getExcludes"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   output ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "Object   attribute    =    node . attribute ( attributeName )  ;", "if    ( attribute    =  =    null )     {", "return   Collections . emptyList (  )  ;", "} else    {", "return   Arrays . asList (  (  ( String )     ( attribute )  )  . split (  \"  \\  \\  |  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseNodeListAttribute"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "this . dir    =    dir ;", "}", "METHOD_END"], "methodName": ["setDir"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "this . excludes    =    excludes ;", "}", "METHOD_END"], "methodName": ["setExcludes"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "this . includes    =    includes ;", "}", "METHOD_END"], "methodName": ["setIncludes"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "this . output    =    output ;", "}", "METHOD_END"], "methodName": ["setOutput"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" SourceFolder { path =  '  \"     +     ( path )  )     +     \"  '  ,    dir =  '  \"  )     +     ( dir )  )     +     \"  '  ,    nativeLibraryLocation =  '  \"  )     +     ( getNativeLibraryLocation (  )  )  )     +     \"  '  ,    exported =  \"  )     +     ( exported )  )     +     \"  ,    accessRules =  \"  )     +     ( accessRules )  )     +     \"  ,    output =  '  \"  )     +     ( output )  )     +     \"  '  ,    excludes =  \"  )     +     ( excludes )  )     +     \"  ,    includes =  \"  )     +     ( includes )  )     +     \"  }  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "trim ( null )  ;", "}", "METHOD_END"], "methodName": ["trim"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "if    ( prefix    !  =    null )     {", "name    =     ( prefix    +     \"  -  \"  )     +     ( name )  ;", "}", "path    =    name ;", "}", "METHOD_END"], "methodName": ["trim"], "fileName": "org.gradle.plugins.ide.eclipse.model.SourceFolder"}, {"methodBody": ["METHOD_START", "{", "return   deployPath ;", "}", "METHOD_END"], "methodName": ["getDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbDependentModule"}, {"methodBody": ["METHOD_START", "{", "return   handle ;", "}", "METHOD_END"], "methodName": ["getHandle"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbDependentModule"}, {"methodBody": ["METHOD_START", "{", "this . deployPath    =    deployPath ;", "}", "METHOD_END"], "methodName": ["setDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbDependentModule"}, {"methodBody": ["METHOD_START", "{", "this . handle    =    handle ;", "}", "METHOD_END"], "methodName": ["setHandle"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbDependentModule"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbProperty"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbProperty"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbProperty"}, {"methodBody": ["METHOD_START", "{", "this . value    =    value ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbProperty"}, {"methodBody": ["METHOD_START", "{", "return   deployPath ;", "}", "METHOD_END"], "methodName": ["getDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbResource"}, {"methodBody": ["METHOD_START", "{", "return   sourcePath ;", "}", "METHOD_END"], "methodName": ["getSourcePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbResource"}, {"methodBody": ["METHOD_START", "{", "this . deployPath    =    deployPath ;", "}", "METHOD_END"], "methodName": ["setDeployPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbResource"}, {"methodBody": ["METHOD_START", "{", "this . sourcePath    =    sourcePath ;", "}", "METHOD_END"], "methodName": ["setSourcePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WbResource"}, {"methodBody": ["METHOD_START", "{", "Iterable < WbModuleEntry >    toKeep    =    Iterables . filter ( wbModuleEntries ,    not ( instanceOf ( WbDependentModule . class )  )  )  ;", "this . wbModuleEntries    =    Lists . newArrayList ( Sets . newLinkedHashSet ( Iterables . concat ( toKeep ,    newEntries )  )  )  ;", "if    (  !  ( isNullOrEmpty ( deployName )  )  )     {", "this . deployName    =    deployName ;", "}", "if    (  !  ( isNullOrEmpty ( contextPath )  )  )     {", "this . contextPath    =    contextPath ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   contextPath ;", "}", "METHOD_END"], "methodName": ["getContextPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   deployName ;", "}", "METHOD_END"], "methodName": ["getDeployName"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "return   wbModuleEntries ;", "}", "METHOD_END"], "methodName": ["getWbModuleEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "Node   wbModule    =    XmlPersistableConfigurationObject . findFirstChildNamed ( xml ,     \" wb - module \"  )  ;", "Preconditions . checkNotNull ( wbModule )  ;", "return   wbModule ;", "}", "METHOD_END"], "methodName": ["getWbModuleNode"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "Node   wbModuleNode    =    WtpComponent . getWbModuleNode ( getXml (  )  )  ;", "for    ( String   elementName    :    Arrays . asList (  \" property \"  ,     \" wb - resource \"  ,     \" dependent - module \"  )  )     {", "for    ( Node   elementNode    :    XmlPersistableConfigurationObject . getChildren ( wbModuleNode ,    elementName )  )     {", "wbModuleNode . remove ( elementNode )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeConfigurableDataFromXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . contextPath    =    contextPath ;", "}", "METHOD_END"], "methodName": ["setContextPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . deployName    =    deployName ;", "}", "METHOD_END"], "methodName": ["setDeployName"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . wbModuleEntries    =    wbModuleEntries ;", "}", "METHOD_END"], "methodName": ["setWbModuleEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpComponent"}, {"methodBody": ["METHOD_START", "{", "this . facets . addAll ( facets )  ;", "removeDuplicates (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "return   facets ;", "}", "METHOD_END"], "methodName": ["getFacets"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "Node   xml    =    getXml (  )  ;", "NodeList   fixed    =     (  ( NodeList )     ( xml . get (  \" fixed \"  )  )  )  ;", "NodeList   installed    =     (  ( NodeList )     ( xml . get (  \" installed \"  )  )  )  ;", "for    ( Object   n    :    fixed )     {", "xml . remove (  (  ( Node )     ( n )  )  )  ;", "}", "for    ( Object   n    :    installed )     {", "xml . remove (  (  ( Node )     ( n )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeConfigurableDataFromXml"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "this . facets    =    Lists . newArrayList ( Sets . newLinkedHashSet ( facets )  )  ;", "}", "METHOD_END"], "methodName": ["removeDuplicates"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "this . facets    =    facets ;", "}", "METHOD_END"], "methodName": ["setFacets"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "return    (  \" WtpFacet { facets =  \"     +     ( facets )  )     +     \"  }  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.plugins.ide.eclipse.model.WtpFacet"}, {"methodBody": ["METHOD_START", "{", "List < Library >    out    =    new   LinkedList < Library >  (  )  ;", "FileReferenceFactory   fileReferenceFactory    =    classpath . getFileReferenceFactory (  )  ;", "if    (  ( classpath . get (  )  )     !  =    null )     {", "for    ( File   folder    :    classpath . get (  )  )     {", "Library   library    =    new   Library ( fileReferenceFactory . fromFile ( folder )  )  ;", "library . setExported ( true )  ;", "out . add ( library )  ;", "}", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClassFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "return   classpath . isProjectDependenciesOnly (  )     ?    Collections .  < ClasspathEntry > emptyList (  )     :    new   ClassFoldersCreator (  )  . create ( classpath )  ;", "}", "METHOD_END"], "methodName": ["createClassFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "List < ClasspathEntry >    containers    =    Lists . newArrayList (  )  ;", "for    ( String   container    :    classpath . getContainers (  )  )     {", "Container   entry    =    new   Container ( container )  ;", "containers . add ( entry )  ;", "}", "return   containers ;", "}", "METHOD_END"], "methodName": ["createContainers"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "return   dependenciesCreator . createDependencyEntries (  )  ;", "}", "METHOD_END"], "methodName": ["createDependencies"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "List < ClasspathEntry >    entries    =    Lists . newArrayList (  )  ;", "entries . add ( createOutput (  )  )  ;", "entries . addAll ( createSourceFolders (  )  )  ;", "entries . addAll ( createContainers (  )  )  ;", "entries . addAll ( createDependencies (  )  )  ;", "entries . addAll ( createClassFolders (  )  )  ;", "return   entries ;", "}", "METHOD_END"], "methodName": ["createEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   Output ( classpath . getProject (  )  . relativePath ( classpath . getDefaultOutputDir (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createOutput"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   SourceFoldersCreator (  )  . createSourceFolders ( classpath )  ;", "}", "METHOD_END"], "methodName": ["createSourceFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ClasspathFactory"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( new   ClosureBackedAction < ResourceFilterMatcher >  ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["matcher"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.DefaultResourceFilter"}, {"methodBody": ["METHOD_START", "{", "this . matcher    =    matcher ;", "}", "METHOD_END"], "methodName": ["setMatcher"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.DefaultResourceFilter"}, {"methodBody": ["METHOD_START", "{", "return   matcher ( new   ClosureBackedAction < ResourceFilterMatcher >  ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["matcher"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.DefaultResourceFilterMatcher"}, {"methodBody": ["METHOD_START", "{", "if    ( children    =  =    null )     {", "throw   new   InvalidUserDataException (  \" children   must   not   be   null \"  )  ;", "}", "this . children    =    children ;", "}", "METHOD_END"], "methodName": ["setChildren"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.DefaultResourceFilterMatcher"}, {"methodBody": ["METHOD_START", "{", "EclipseDependenciesCreator . EclipseDependenciesVisitor   visitor    =    new   EclipseDependenciesCreator . EclipseDependenciesVisitor (  )  ;", "new   IdeDependencySet ( classpath . getProject (  )  . getDependencies (  )  ,    classpath . getPlusConfigurations (  )  ,    classpath . getMinusConfigurations (  )  )  . visit ( visitor )  ;", "return   visitor . getDependencies (  )  ;", "}", "METHOD_END"], "methodName": ["createDependencyEntries"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.EclipseDependenciesCreator"}, {"methodBody": ["METHOD_START", "{", "switch    ( version )     {", "case   VERSION _  1  _  1     :", "case   VERSION _  1  _  2     :", "case   VERSION _  1  _  3     :", "case   VERSION _  1  _  4     :", "case   VERSION _  1  _  5     :", "case   VERSION _  1  _  6     :", "case   VERSION _  1  _  7     :", "case   VERSION _  1  _  8     :", "return   version . toString (  )  ;", "case   VERSION _  1  _  9     :", "case   VERSION _  1  _  1  0     :", "default    :", "return   version . getMajor (  )  ;", "}", "}", "METHOD_END"], "methodName": ["toEclipseJavaVersion"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.EclipseJavaVersionMapper"}, {"methodBody": ["METHOD_START", "{", "variables . put ( name ,    dir )  ;", "}", "METHOD_END"], "methodName": ["addPathVariable"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( file    =  =    null )     {", "return   null ;", "}", "String   path    =    null ;", "boolean   usedVar    =    false ;", "for    ( Map . Entry < String ,    File >    entry    :    variables . entrySet (  )  )     {", "String   rootDirPath    =    entry . getValue (  )  . getAbsolutePath (  )  ;", "String   filePath    =    file . getAbsolutePath (  )  ;", "if    ( filePath . equals ( rootDirPath )  )     {", "path    =    entry . getKey (  )  ;", "usedVar    =    true ;", "break ;", "}", "if    ( filePath . startsWith (  ( rootDirPath    +     ( File . separator )  )  )  )     {", "int   len    =    rootDirPath . length (  )  ;", "path    =     ( entry . getKey (  )  )     +     ( filePath . substring ( len )  )  ;", "usedVar    =    true ;", "break ;", "}", "}", "path    =    PathUtil . normalizePath (  ( path    !  =    null    ?    path    :    file . getAbsolutePath (  )  )  )  ;", "return   new    . FileReferenceImpl ( file ,    path ,    usedVar )  ;", "}", "METHOD_END"], "methodName": ["fromFile"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( jarURI    =  =    null )     {", "return   null ;", "}", "URI   fileURI    =    null ;", "try    {", "fileURI    =    new   URI ( jarURI . replace (  \" jar :  \"  ,     \"  \"  )  . replace (  \"  !  /  \"  ,     \"  \"  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "UncheckedException . throwAsUncheckedException ( e )  ;", "}", "File   file    =    new   File ( fileURI )  ;", "String   path    =    PathUtil . normalizePath ( file . getAbsolutePath (  )  )  ;", "return   new    . FileReferenceImpl ( file ,    path ,    false )  ;", "}", "METHOD_END"], "methodName": ["fromJarURI"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "}", "return   new    . FileReferenceImpl ( new   File ( path )  ,    path ,    false )  ;", "}", "METHOD_END"], "methodName": ["fromPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( path    =  =    null )     {", "return   null ;", "}", "for    ( Map . Entry < String ,    File >    entry    :    variables . entrySet (  )  )     {", "String   prefix    =     ( entry . getKey (  )  )     +     \"  /  \"  ;", "if    ( path . startsWith ( prefix )  )     {", "File   file    =    new   File ( entry . getValue (  )  ,    path . substring ( prefix . length (  )  )  )  ;", "return   new    . FileReferenceImpl ( file ,    path ,    true )  ;", "}", "}", "return   fromPath ( path )  ;", "}", "METHOD_END"], "methodName": ["fromVariablePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory"}, {"methodBody": ["METHOD_START", "{", "return   FilenameUtils . separatorsToUnix ( path )  ;", "}", "METHOD_END"], "methodName": ["normalizePath"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.PathUtil"}, {"methodBody": ["METHOD_START", "{", "return   buildProjectDependency ( determineTargetProjectPath ( id )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ProjectDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "final   ProjectDependency   out    =    new   ProjectDependency ( path )  ;", "out . setExported ( false )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["buildProjectDependency"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ProjectDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "EclipseProjectMetadata   eclipseProject    =    ideArtifactRegistry . getIdeArtifactMetadata ( EclipseProjectMetadata . class ,    id )  ;", "return   eclipseProject    =  =    null    ?    id . getProjectName (  )     :    eclipseProject . getName (  )  ;", "}", "METHOD_END"], "methodName": ["determineTargetProjectName"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ProjectDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "return    \"  /  \"     +     ( determineTargetProjectName ( id )  )  ;", "}", "METHOD_END"], "methodName": ["determineTargetProjectPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.ProjectDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "folder . getEntryAttributes (  )  . put ( EclipsePluginConstants . GRADLE _ SCOPE _ ATTRIBUTE _ NAME ,    sanitizeNameForAttribute ( sourceSet )  )  ;", "folder . getEntryAttributes (  )  . put ( EclipsePluginConstants . GRADLE _ USED _ BY _ SCOPE _ ATTRIBUTE _ NAME ,    Joiner . on (  '  ,  '  )  . join ( getUsingSourceSetNames ( sourceSet ,    sourceSetUsages )  )  )  ;", "}", "METHOD_END"], "methodName": ["addScopeAttributes"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "ArrayList < SourceFolder >    entries    =    Lists . newArrayList (  )  ;", "List < SourceSet >    sortedSourceSets    =    sortSourceSetsAsPerUsualConvention ( sourceSets )  ;", "for    ( SourceSet   sourceSet    :    sortedSourceSets )     {", "List < DirectoryTree >    sortedSourceDirs    =    sortSourceDirsAsPerUsualConvention ( sourceSet . getAllSource (  )  . getSrcDirTrees (  )  )  ;", "for    ( DirectoryTree   tree    :    sortedSourceDirs )     {", "File   dir    =    tree . getDir (  )  ;", "if    ( dir . isDirectory (  )  )     {", "SourceFolder   folder    =    new   SourceFolder ( provideRelativePath . apply ( dir )  ,    null )  ;", "folder . setDir ( dir )  ;", "folder . setName ( dir . getName (  )  )  ;", "entries . add ( folder )  ;", "}", "}", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["basicProjectRelativeFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "for    ( DirectoryTree   directoryTree    :    directoryTrees )     {", "if    ( directoryTree . getDir (  )  . equals ( targetDir )  )     {", "PatSet   pats    =    directoryTree . getPats (  )  ;", "return   collectFilters ( pats ,    filterOperation )  ;", "}", "}", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["collectFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "return   Cast .  < Set < String >  > uncheckedCast ( DynamicObjectUtil . asDynamicObject ( patterns )  . getProperty ( filterOperation )  )  ;", "}", "METHOD_END"], "methodName": ["collectFilters"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Pair < Collection < SourceFolder >  ,    Collection < SourceFolder >  >    partitionedFolders    =    CollectionUtils . partition ( sourceFolder ,    new   Spec < SourceFolder >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( SourceFolder   sourceFolder )     {", "return   sourceFolder . getPath (  )  . contains (  \"  .  .  \"  )  ;", "}", "}  )  ;", "Collection < SourceFolder >    external    =    partitionedFolders . getLeft (  )  ;", "Collection < SourceFolder >    regular    =    partitionedFolders . getRight (  )  ;", "List < String >    sources    =    Lists . newArrayList ( Collections 2  . transform ( regular ,    new   com . google . common . base . Function < SourceFolder ,    String >  (  )     {", "@ Override", "public   String   apply ( SourceFolder   sourceFolder )     {", "return   sourceFolder . getName (  )  ;", "}", "}  )  )  ;", "Collection < SourceFolder >    dedupedExternal    =    trimAndDedup ( external ,    sources )  ;", "return   collector . apply ( Pair . of ( regular ,    dedupedExternal )  )  ;", "}", "METHOD_END"], "methodName": ["collectRegularAndExternalSourceFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "String   path    =     (  \" bin /  \"     +    sourceSetName )     +    suffix ;", "return   existingPaths . contains ( path )     ?    collectSetOutputPath ( sourceSetName ,    existingPaths ,     ( suffix    +     \"  _  \"  )  )     :    path ;", "}", "METHOD_END"], "methodName": ["collectSourceSetOutputPath"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Set < String >    existingPaths    =    Sets . newHashSet ( defaultOutputPath )  ;", "Map < Set ,    String >    result    =    Maps . newHashMap (  )  ;", "for    ( Set   sourceSet    :    sourceSets )     {", "String   path    =    collectSetOutputPath ( sourceSet . getName (  )  ,    existingPaths ,     \"  \"  )  ;", "existingPaths . add ( path )  ;", "result . put ( sourceSet ,    path )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["collectSourceSetOutputPaths"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    second )     {", "if    (  !  ( first . conta ( file )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   containsAll ( sourceSet . getRuntimeClasspath (  )  ,    otherSet . getOutput (  )  )  ;", "}    catch    ( Exception   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["containsOutputOf"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Function < File ,    String >    provideRelativePath    =    new   Function < File ,    String >  (  )     {", "@ Override", "public   String   apply ( File   input )     {", "return   classpath . getProject (  )  . relativePath ( input )  ;", "}", "}  ;", "List < SourceFolder >    sourceFolders    =    projectRelativeFolders ( classpath . getSourceSets (  )  ,    provideRelativePath ,    classpath . getDefaultOutputDir (  )  )  ;", "return   collectRegularAndExternal ( sourceFolders ,    new   Function < Pair < Collection < SourceFolder >  ,    Collection < SourceFolder >  >  ,    List < SourceFolder >  >  (  )     {", "@ Override", "public   List < SourceFolder >    apply ( Pair < Collection < SourceFolder >  ,    Collection < SourceFolder >  >    sourceFolders )     {", "List < SourceFolder >    entries    =    Lists . newArrayListWithCapacity (  (  ( sourceFolders . getLeft (  )  . size (  )  )     +     ( sourceFolders . getRight (  )  . size (  )  )  )  )  ;", "entries . addAll ( sourceFolders . getLeft (  )  )  ;", "entries . addAll ( sourceFolders . getRight (  )  )  ;", "return   entries ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createSourceFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "List < SourceFolder >    basicSourceFolders    =    basicProjectRelativeFolders ( sourceSets ,    provideRelativePath ,    defaultOutputDir )  ;", "return   collectRegularAndExternalSourceFolders ( basicSourceFolders ,    new   Function < Pair < Collection < SourceFolder >  ,    Collection < SourceFolder >  >  ,    List < SourceFolder >  >  (  )     {", "@ Override", "public   List < SourceFolder >    apply ( Pair < Collection < SourceFolder >  ,    Collection < SourceFolder >  >    sourceFolders )     {", "return   Lists . newArrayList ( sourceFolders . right (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getBasicExternalSourceFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "List < Set < String >  >    excludesByType    =    getFiltersForTreeGroupedByType ( sourceSet ,    directoryTree ,     \" excludes \"  )  ;", "return   CollectionUtilssection ( excludesByType )  ;", "}", "METHOD_END"], "methodName": ["getExcludesForTree"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Set < File >    javaSrcDirs    =    sourceSet . getAllJava (  )  . getSrcDirs (  )  ;", "Set < File >    resSrcDirs    =    sourceSet . getResources (  )  . getSrcDirs (  )  ;", "List < File >    srcDirs    =    CollectionUtilssection ( Lists . newArrayList ( javaSrcDirs ,    resSrcDirs )  )  ;", "if    (  !  ( srcDirs . contains ( directoryTree . getDir (  )  )  )  )     {", "return   Lists .  < Set < String >  > newArrayList ( collectFilters ( directoryTree . getPatterns (  )  ,    filterOperation )  )  ;", "} else    {", "Set < String >    resourcesFilter    =    collectFilters ( sourceSet . getResources (  )  . getSrcDirTrees (  )  ,    directoryTree . getDir (  )  ,    filterOperation )  ;", "Set < String >    sourceFilter    =    collectFilters ( sourceSet . getAllJava (  )  . getSrcDirTrees (  )  ,    directoryTree . getDir (  )  ,    filterOperation )  ;", "return   Lists .  < Set < String >  > newArrayList ( resourcesFilter ,    sourceFilter )  ;", "}", "}", "METHOD_END"], "methodName": ["getFiltersForTreeGroupedByType"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "List < Set < String >  >    includesByType    =    getFiltersForTreeGroupedByType ( sourceSet ,    directoryTree ,     \" includes \"  )  ;", "for    ( Set < String >    it    :    includesByType )     {", "if    ( it . isEmpty (  )  )     {", "return   Collections . emptyList (  )  ;", "}", "}", "List < String >    allIncludes    =    CollectionUtils . flattenCollections ( String . class ,    includesByType )  ;", "return   ImmutableSet . copyOf ( allIncludes )  . asList (  )  ;", "}", "METHOD_END"], "methodName": ["getIncludesForTree"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Multimap < SourceSet ,    SourceSet >    usages    =    LinkedHashMultimap . create (  )  ;", "for    ( SourceSet   sourceSet    :    sourceSets )     {", "for    ( SourceSet   otherSourceSet    :    sourceSets )     {", "if    ( containsOutputOf ( sourceSet ,    otherSourceSet )  )     {", "usages . put ( otherSourceSet ,    sourceSet )  ;", "}", "}", "}", "return   usages ;", "}", "METHOD_END"], "methodName": ["getSourceSetUsages"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "Collection < SourceSet >    usingSourceSets    =    sourceSetUsages . get ( sourceSet )  ;", "List < String >    usingSourceSetNames    =    Lists . newArrayList (  )  ;", "for    ( SourceSet   usingSourceSet    :    usingSourceSets )     {", "usingSourceSetNames . add ( sanitizeNameForAttribute ( usingSourceSet )  )  ;", "}", "return   usingSourceSetNames ;", "}", "METHOD_END"], "methodName": ["getUsingSourceSetNames"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "String   defaultOutputPath    =    PathUtil . normalizePath ( provideRelativePath . apply ( defaultOutputDir )  )  ;", "ArrayList <  >    entries    =    Lists . newArrayList (  )  ;", "List < SourceSet >    sortedSourceSets    =    sortSourceSetsAsPerUsualConvention ( sourceSets )  ;", "Map < SourceSet ,    String >    sourceSetOutputPaths    =    collectSourceSetOutputPaths ( sortedSourceSets ,    defaultOutputPath )  ;", "Multimap < SourceSet ,    SourceSet >    sourceSetUsages    =    getSourceSetUsages ( sortedSourceSets )  ;", "for    ( SourceSet   sourceSet    :    sortedSourceSets )     {", "List < DirectoryTree >    sortedSourceDirs    =    sortSourceDirsAsPerUsualConvention ( sourceSet . getAllSource (  )  . getSrcDirTrees (  )  )  ;", "for    ( DirectoryTree   tree    :    sortedSourceDirs )     {", "File   dir    =    tree . getDir (  )  ;", "if    ( dir . isDirectory (  )  )     {", "String   relativePath    =    provideRelativePath . apply ( dir )  ;", "folder    =    new    ( relativePath ,    null )  ;", "folder . setDir ( dir )  ;", "folder . setName ( dir . getName (  )  )  ;", "folder . setIncludes ( getIncludesForTree ( sourceSet ,    tree )  )  ;", "folder . setExcludes ( getExcludesForTree ( sourceSet ,    tree )  )  ;", "folder . setOutput ( sourceSetOutputPaths . get ( sourceSet )  )  ;", "addScopeAttributes ( folder ,    sourceSet ,    sourceSetUsages )  ;", "entries . add ( folder )  ;", "}", "}", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["projectRelativeFolders"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "return   sourceSet . getName (  )  . replaceAll (  \"  ,  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["sanitizeNameForAttribute"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . sort ( sourceDirs ,    new   Comparator < DirectoryTree >  (  )     {", "@ Override", "public   int   compare ( DirectoryTree   left ,    DirectoryTree   right )     {", "return    . toComparable ( left )  . compareTo (  . toComparable ( right )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sortSourceDirsAsPerUsualConvention"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . sort ( sourceSets ,    new   Comparator < SourceSet >  (  )     {", "@ Override", "public   int   compare ( SourceSet   left ,    SourceSet   right )     {", "return    . toComparable ( left )  . compareTo (  . toComparable ( right )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["sortSourceSetsAsPerUsualConvention"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "String   path    =    tree . getDir (  )  . getPath (  )  ;", "if    ( path . endsWith (  \" java \"  )  )     {", "return    0  ;", "} else", "if    ( path . endsWith (  \" ress \"  )  )     {", "return    2  ;", "} else    {", "return    1  ;", "}", "}", "METHOD_END"], "methodName": ["toComparable"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "String   name    =    sourceSet . getName (  )  ;", "if    ( MAIN _ SOURCE _ SET _ NAME . equals ( name )  )     {", "return    0  ;", "} else", "if    ( Set . TEST _ SOURCE _ SET _ NAME . equals ( name )  )     {", "return    1  ;", "} else    {", "return    2  ;", "}", "}", "METHOD_END"], "methodName": ["toComparable"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "List < SourceFolder >    trimmedSourceFolders    =    Lists . newArrayList (  )  ;", "for    ( SourceFolder   folder    :    externalSourceFolders )     {", "folder . trim (  )  ;", "File   parentFile    =    folder . getDir (  )  . getParentFile (  )  ;", "while    (  ( givenSources . contains ( folder . getName (  )  )  )     &  &     ( parentFile    !  =    null )  )     {", "folder . trim ( parentFile . getName (  )  )  ;", "parentFile    =    parentFile . getParentFile (  )  ;", "}", "givenSources . add ( folder . getName (  )  )  ;", "trimmedSourceFolders . add ( folder )  ;", "}", "return   trimmedSourceFolders ;", "}", "METHOD_END"], "methodName": ["trimAndDedup"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.SourceFoldersCreator"}, {"methodBody": ["METHOD_START", "{", "WtpClasspathAttributeSupport . WtpClasspathAttributeDependencyVisitor   visitor    =    new   WtpClasspathAttributeSupport . WtpClasspathAttributeDependencyVisitor ( classpath )  ;", "new   IdeDependencySet ( classpath . getProject (  )  . getDependencies (  )  ,    configs ,    minusConfigs )  . visit ( visitor )  ;", "return   visitor . getFiles (  )  ;", "}", "METHOD_END"], "methodName": ["collectFilesFromConfigs"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "File   file    =    entry . getLibrary (  )  . getFile (  )  ;", "if    (  !  ( isUtilityProject )  )     {", "if    ( rootConfigFiles . contains ( file )  )     {", "return    . singleEntryMap ( AbstractClasspathEntry . COMPONENT _ DEPENDENCY _ ATTRIBUTE ,     \"  /  \"  )  ;", "} else", "if    ( libConfigFiles . contains ( file )  )     {", "return    . singleEntryMap ( AbstractClasspathEntry . COMPONENT _ DEPENDENCY _ ATTRIBUTE ,    libDirName )  ;", "}", "}", "return    . singleEntryMap ( AbstractClasspathEntry . COMPONENT _ NON _ DEPENDENCY _ ATTRIBUTE ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["createDeploymentAttribute"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( entry   instanceof   AbstractLibrary )     {", "return   createDeploymentAttribute (  (  ( AbstractLibrary )     ( entry )  )  )  ;", "} else", "if    ( entry   instanceof   ProjectDependency )     {", "return   createDeploymentAttribute (  (  ( ProjectDependency )     ( entry )  )  )  ;", "} else    {", "return   emptyMap (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createDeploymentAttribute"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "return   WtpClasspathAttributeSupport . singleEntryMap ( AbstractClasspathEntry . COMPONENT _ NON _ DEPENDENCY _ ATTRIBUTE ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["createDeploymentAttribute"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "for    ( ClasspathEntry   entry    :    classpath . getEntries (  )  )     {", "if    ( entry   instanceof   AbstractClasspathEntry )     {", "AbstractClasspathEntry   classpathEntry    =     (  ( AbstractClasspathEntry )     ( entry )  )  ;", "Map < String ,    Object >    wtpEntries    =    createDeploymentAttribute ( classpathEntry )  ;", "classpathEntry . getEntryAttributes (  )  . putAll ( wtpEntries )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["enhance"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableMap .  < String ,    Object > of ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["singleEntryMap"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpClasspathAttributeSupport"}, {"methodBody": ["METHOD_START", "{", "if    ( configuration    =  =    null )     {", "return   CollectioemptySet (  )  ;", "} else    {", "return   configuration ;", "}", "}", "METHOD_END"], "methodName": ["configOrEmptySet"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpComponentFactory"}, {"methodBody": ["METHOD_START", "{", "List < WbModuleEntry >    entries    =    Lists . newArrayList (  )  ;", "entries . addAll ( getEntriesFromSourceDirs ( wtp )  )  ;", "for    ( WbResource   element    :    wtp . getResources (  )  )     {", "if    ( wtp . getProject (  )  . file ( element . getSourcePath (  )  )  . isDirectory (  )  )     {", "entries . add ( element )  ;", "}", "}", "entries . addAll ( wtp . getProperties (  )  )  ;", "Project   project    =    wtp . getProject (  )  ;", "entries . addAll ( getEntriesFromConfigurations ( project ,    configOrEmptySet ( wtp . getRootConfigurations (  )  )  ,    configOrEmptySet ( wtp . getMinusConfigurations (  )  )  ,    wtp ,     \"  /  \"  )  )  ;", "entries . addAll ( getEntriesFromConfigurations ( project ,    configOrEmptySet ( wtp . getLibConfigurations (  )  )  ,    configOrEmptySet ( wtp . getMinusConfigurations (  )  )  ,    wtp ,    wtp . getLibDeployPath (  )  )  )  ;", "c . configure ( wtp . getDeployName (  )  ,    wtp . getContextPath (  )  ,    entries )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpComponentFactory"}, {"methodBody": ["METHOD_START", "{", "WtpComponentFactory . WtpDependenciesVisitor   visitor    =    new   WtpComponentFactory . WtpDependenciesVisitor ( project ,    wtp ,    deployPath )  ;", "new   IdeDependencySet ( project . getDependencies (  )  ,    plusConfigurations ,    minusConfigurations )  . visit ( visitor )  ;", "return   visitor . getEntries (  )  ;", "}", "METHOD_END"], "methodName": ["getEntriesFromConfigurations"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpComponentFactory"}, {"methodBody": ["METHOD_START", "{", "List < WbResource >    result    =    Lists . newArrayList (  )  ;", "if    (  ( wtp . getSourceDirs (  )  )     !  =    null )     {", "for    ( File   dir    :    wtp . getSourceDirs (  )  )     {", "if    ( dir . isDire (  )  )     {", "result . add ( new   WbResource ( wtp . getClassesDeployPath (  )  ,    wtp . getProject (  )  . relativePath ( dir )  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getEntriesFromSourceDirs"], "fileName": "org.gradle.plugins.ide.eclipse.model.internal.WtpComponentFactory"}, {"methodBody": ["METHOD_START", "{", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaModule"}, {"methodBody": ["METHOD_START", "{", "if    (  ( module )     =  =    null )     {", "return   super . getOutputFile (  )  ;", "}", "return   module . getOutputFile (  )  ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . module    =    module ;", "}", "METHOD_END"], "methodName": ["setModule"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaModule"}, {"methodBody": ["METHOD_START", "{", "module . setOutputFile ( newOutputFile )  ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   ideaProject ;", "}", "METHOD_END"], "methodName": ["getIdeaProject"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaProject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ideaProject )     =  =    null )     {", "return   super . getOutputFile (  )  ;", "}", "return   ideaProject . getOutputFile (  )  ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . ideaProject    =    ideaProject ;", "}", "METHOD_END"], "methodName": ["setIdeaProject"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaProject"}, {"methodBody": ["METHOD_START", "{", "ideaProject . setOutputFile ( newOutputFile )  ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   workspace ;", "}", "METHOD_END"], "methodName": ["getWorkspace"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "this . workspace    =    workspace ;", "}", "METHOD_END"], "methodName": ["setWorkspace"], "fileName": "org.gradle.plugins.ide.idea.GenerateIdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "List < TaskDependency >    dependencies    =    Lists . newArrayList (  )  ;", "ProjectComponentIdentifier   thisProjectId    =    projectPathRegistry . getProjectComponentIdentifier ( project . getIdentityPath (  )  )  ;", "for    ( IdeArtifactRegistry . Reference < ModuleMetadata >    reference    :    artifactRegistry . getIdeArtifactMetadata ( ModuleMetadata . class )  )     {", "BuildIdentifier   otherBuildId    =    reference . getOwningProject (  )  . getBuild (  )  ;", "if    ( thisProjectId . getBuild (  )  . equals ( otherBuildId )  )     {", "boolean   found    =    false ;", "for    ( Module   ideaModule    :    ideaProject . getModules (  )  )     {", "if    ( reference . get (  )  . getFile (  )  . equals ( ideaModule . getOutputFile (  )  )  )     {", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "continue ;", "}", "}", "dependencies . add ( reference . getBuildDependencies (  )  )  ;", "}", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["allImlArtifactsInComposite"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . withType ( JavaPlugin . class ,    new   Action < JavaPlugin >  (  )     {", "@ Override", "public   void   execute ( JavaPlugin   javaPlugin )     {", "configureIdeaModuleForJava ( project )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureForJavaPlugin"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . withType ( ScalaBasePlugin . class ,    new   Action < ScalaBasePlugin >  (  )     {", "@ Override", "public   void   execute ( ScalaBasePlugin   scalaBasePlugin )     {", "ideaModuleDependsOnRoot (  )  ;", "}", "}  )  ;", "project . getPlugins (  )  . withType ( ScalaLanguagePlugin . class ,    new   Action < ScalaLanguagePlugin >  (  )     {", "@ Override", "public   void   execute ( ScalaLanguagePlugin   scalaLanguagePlugin )     {", "ideaModuleDependsOnRoot (  )  ;", "}", "}  )  ;", "if    ( isRoot (  )  )     {", "new   IdeaScalaConfigurer ( project )  . configure (  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureForScalaPlugin"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPlugins (  )  . withType ( WarPlugin . class ,    new   Action < WarPlugin >  (  )     {", "@ Override", "public   void   execute ( WarPlugin   warPlugin )     {", "configureIdeaModuleForWar ( project )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureForWarPlugin"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "final   GenerateIdeaModule   task    =    project . getTasks (  )  . create (  \" ideaModule \"  ,    GenerateIdeaModule . class )  ;", "task . setDescription (  \" Generates   IDEA   module   files    ( IML )  \"  )  ;", "IdeaModuleIml   iml    =    new   IdeaModuleIml ( task . getXmlTransformer (  )  ,    project . getProjectDir (  )  )  ;", "final   IdeaModule   module    =    instantiator . newInstance ( IdeaModule . class ,    project ,    iml )  ;", "task . setModule ( module )  ;", "ideaModel . setModule ( module )  ;", "final   String   defaultModuleName    =    uniqueProjectNameProvider . getUniqueName ( project )  ;", "module . setName ( defaultModuleName )  ;", "ConventionMapping   conventionMapping    =     (  ( IConventionAware )     ( module )  )  . getConventionMapping (  )  ;", "conventionMapping . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )     {", "return   Sets . newLinkedHashSet (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" contentRoot \"  ,    new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )     {", "return   project . getProjectDir (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" testSourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )     {", "return   Sets . newLinkedHashSet (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" resourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   Sets . newLinkedHashSet (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" testResourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "return   Sets . newLinkedHashSet (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" excludeDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )     {", "Set < File >    defaultExcludes    =    Sets . newLinkedHashSet (  )  ;", "defaultExcludes . add ( project . file (  \"  \"  )  )  ;", "defaultExcludes . add ( project . getBuildDir (  )  )  ;", "return   defaultExcludes ;", "}", "}  )  ;", "conventionMapping . map (  \" pathFactory \"  ,    new   Callable < PathFactory >  (  )     {", "@ Override", "public   PathFactory   call (  )     {", "final   PathFactory   factory    =    new   PathFactory (  )  ;", "factory . addPathVariable (  \" MODULE _ DIR \"  ,    task . getOutputFile (  )  . getParentFile (  )  )  ;", "for    ( Map . Entry < String ,    File >    entry    :    module . getPathVariables (  )  . entrySet (  )  )     {", "factory . addPathVariable ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "return   factory ;", "}", "}  )  ;", "artifactRegistry . registerIdeArtifact ( new   IdeaModuleMetadata ( module ,    task )  )  ;", "addWorker ( task )  ;", "}", "METHOD_END"], "methodName": ["configureIdeaModule"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( GenerateIdeaModule . class ,    new   Action < GenerateIdeaModule >  (  )     {", "@ Override", "public   void   execute ( GenerateIdeaModule   ideaModule )     {", "setupScopes ( ideaModule )  ;", "ConventionMapping   convention    =     (  ( IConventionAware )     ( ideaModule . getModule (  )  )  )  . getConventionMapping (  )  ;", "convention . map (  \" sourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )     {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "return   sourceSets . getByName (  \" main \"  )  . getAllSource (  )  . getSrcDirs (  )  ;", "}", "}  )  ;", "convention . map (  \" testSourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )     {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "return   sourceSets . getByName (  \" test \"  )  . getAllSource (  )  . getSrcDirs (  )  ;", "}", "}  )  ;", "convention . map (  \" resourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "return   sourceSets . getByName (  \" main \"  )  . getResources (  )  . getSrcDirs (  )  ;", "}", "}  )  ;", "convention . map (  \" testResourceDirs \"  ,    new   Callable < Set < File >  >  (  )     {", "@ Override", "public   Set < File >    call (  )    throws   Exception    {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "return   sourceSets . getByName (  \" test \"  )  . getResources (  )  . getSrcDirs (  )  ;", "}", "}  )  ;", "convention . map (  \" singleEntryLibraries \"  ,    new   Callable < Map < String ,    FileCollection >  >  (  )     {", "@ Override", "public   Map < String ,    FileCollection >    call (  )     {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "LinkedHashMap < String ,    FileCollection >    map    =    new   LinkedHashMap < String ,    FileCollection >  (  2  )  ;", "map . put (  \" RUNTIME \"  ,    sourceSets . getByName (  \" main \"  )  . getOutput (  )  . getDirs (  )  )  ;", "map . put (  \" TEST \"  ,    sourceSets . getByName (  \" test \"  )  . getOutput (  )  . getDirs (  )  )  ;", "return   map ;", "}", "}  )  ;", "convention . map (  \" targetBytecodeVersion \"  ,    new   Callable < JavaVersion >  (  )     {", "@ Override", "public   JavaVersion   call (  )     {", "JavaVersion   moduleTargetBytecodeLevel    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getTargetCompatibility (  )  ;", "return   IdeaPlugin . includeModuleBytecodeLevelOverride ( project . getRootProject (  )  ,    moduleTargetBytecodeLevel )     ?    moduleTargetBytecodeLevel    :    null ;", "}", "}  )  ;", "convention . map (  \" languageLevel \"  ,    new   Callable < IdeaLanguageLevel >  (  )     {", "@ Override", "public   IdeaLanguageLevel   call (  )     {", "IdeaLanguageLevel   moduleLanguageLevel    =    new   IdeaLanguageLevel ( project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceCompatibility (  )  )  ;", "return   IdeaPlugin . includeModuleLanguageLevelOverride ( project . getRootProject (  )  ,    moduleLanguageLevel )     ?    moduleLanguageLevel    :    null ;", "}", "}  )  ;", "ideaModule . dependsOn ( new   Callable < FileCollection >  (  )     {", "@ Override", "public   FileCollection   call (  )     {", "SourceSetContainer   sourceSets    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  ;", "return   sourceSets . getByName (  \" main \"  )  . getOutput (  )  . getDirs (  )  . plus ( sourceSets . getByName (  \" test \"  )  . getOutput (  )  . getDirs (  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureIdeaModuleForJava"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( GenerateIdeaModule . class ,    new   Action < GenerateIdeaModule >  (  )     {", "@ Override", "public   void   execute ( GenerateIdeaModule   ideaModule )     {", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "Configuration   providedRuntime    =    configurations . getByName ( PROVIDED _ RUNTIME _ CONFIGURATION _ NAME )  ;", "Collection < Configuration >    providedPlus    =    ideaModule . getModule (  )  . getScopes (  )  . get ( GeneratedIdeaScope . PROVIDED . name (  )  )  . get ( IdeaDependenciesProvider . SCOPE _ PLUS )  ;", "providedPlus . add ( providedRuntime )  ;", "Collection < Configuration >    runtimeMinus    =    ideaModule . getModule (  )  . getScopes (  )  . get ( GeneratedIdeaScope . RUNTIME . name (  )  )  . get ( IdeaDependenciesProvider . SCOPE _ MINUS )  ;", "runtimeMinus . add ( providedRuntime )  ;", "Collection < Configuration >    testMinus    =    ideaModule . getModule (  )  . getScopes (  )  . get ( GeneratedIdeaScope . TEST . name (  )  )  . get ( IdeaDependenciesProvider . SCOPE _ MINUS )  ;", "testMinus . add ( providedRuntime )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureIdeaModuleForWar"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( isRoot (  )  )     {", "final   GenerateIdeaProject   projectTask    =    project . getTasks (  )  . create (  \" ideaProject \"  ,    GenerateIdeaProject . class )  ;", "projectTask . setDescription (  \" Generates   IDEA   project   file    ( IPR )  \"  )  ;", "XmlFileContentMerger   ipr    =    new   XmlFileContentMerger ( projectTask . getXmlTransformer (  )  )  ;", "IdeaProject   ideaProject    =    instantiator . newInstance ( IdeaProject . class ,    project ,    ipr )  ;", "projectTask . setIdeaProject ( ideaProject )  ;", "ideaModel . setProject ( ideaProject )  ;", "ideaProject . setOutputFile ( new   File ( project . getProjectDir (  )  ,     (  ( project . getName (  )  )     +     \"  . ipr \"  )  )  )  ;", "ConventionMapping   conventionMapping    =     (  ( IConventionAware )     ( ideaProject )  )  . getConventionMapping (  )  ;", "conventionMapping . map (  \" jdkName \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )     {", "return   JavaVersion . current (  )  . toString (  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" languageLevel \"  ,    new   Callable < IdeaLanguageLevel >  (  )     {", "@ Override", "public   IdeaLanguageLevel   call (  )     {", "JavaVersion   maxSourceCompatibility    =    getMaxJavaModuleCompatibilityVersionFor (  . SOURCE _ COMPATIBILITY )  ;", "return   new   IdeaLanguageLevel ( maxSourceCompatibility )  ;", "}", "}  )  ;", "conventionMapping . map (  \" targetBytecodeVersion \"  ,    new   Callable < JavaVersion >  (  )     {", "@ Override", "public   JavaVersion   call (  )     {", "return   getMaxJavaModuleCompatibilityVersionFor (  . TARGET _ COMPATIBILITY )  ;", "}", "}  )  ;", "ideaProject . getWildcards (  )  . addAll ( Arrays . asList (  \"  !  ?  *  . class \"  ,     \"  !  ?  *  . scala \"  ,     \"  !  ?  *  . groovy \"  ,     \"  !  ?  *  . java \"  )  )  ;", "conventionMapping . map (  \" modules \"  ,    new   Callable < List < IdeaModule >  >  (  )     {", "@ Override", "public   List < IdeaModule >    call (  )     {", "return   Lists . newArrayList ( Iterables . transform ( Sets . filter ( project . getRootProject (  )  . getAllprojects (  )  ,    new   com . google . common . base . Predicate < Project >  (  )     {", "@ Override", "public   boolean   apply ( Project   p )     {", "return   p . getPlugins (  )  . hasPlugin (  . class )  ;", "}", "}  )  ,    new   com . google . common . base . Function < Project ,    IdeaModule >  (  )     {", "@ Override", "public   IdeaModule   apply ( Project   p )     {", "return    . ideaModelFor ( p )  . getModule (  )  ;", "}", "}  )  )  ;", "}", "}  )  ;", "conventionMapping . map (  \" pathFactory \"  ,    new   Callable < PathFactory >  (  )     {", "@ Override", "public   PathFactory   call (  )     {", "return   new   PathFactory (  )  . addPathVariable (  \" PROJECT _ DIR \"  ,    projectTask . getOutputFile (  )  . getParentFile (  )  )  ;", "}", "}  )  ;", "addWorker ( projectTask )  ;", "addWorkspace ( ideaProject )  ;", "}", "}", "METHOD_END"], "methodName": ["configureIdeaProject"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( isRoot (  )  )     {", "GenerateIdeaWorkspace   task    =    project . getTasks (  )  . create (  \" Workspace \"  ,    GenerateIdeaWorkspace . class )  ;", "task . setDescription (  \" Generates   an   IDEA   workspace   file    ( IWS )  \"  )  ;", "IdeaWorkspace   workspace    =    new   IdeaWorkspace (  )  ;", "workspace . setIws ( new   XmlFileContentMerger ( task . getXmlTransformer (  )  )  )  ;", "task . setWorkspace ( workspace )  ;", "Model . setWorkspace ( task . getWorkspace (  )  )  ;", "task . setOutputFile ( new   File ( project . getProjectDir (  )  ,     (  ( project . getName (  )  )     +     \"  . iws \"  )  )  )  ;", "addWorker ( task ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["configureIdeaWorkspace"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( allJavaProjects )     !  =    null )     {", "return   allJavaProjects ;", "}", "allJavaProjects    =    Lists . newArrayList ( Iterables . filter ( project . getRootProject (  )  . getAllprojects (  )  ,     . HAS _ IDEA _ AND _ JAVA _ PLUGINS )  )  ;", "return   allJavaProjects ;", "}", "METHOD_END"], "methodName": ["getAllJavaProjects"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "List < Project >    allJavaProjects    =    getAllJavaProjects (  )  ;", "if    ( allJavaProjectsEmpty (  )  )     {", "return   JavaVersion . VERSION _  1  _  6  ;", "} else    {", "return   Collections . max ( Lists . transform ( allJavaProjects ,    toJavaVersion )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMaxJavaModuleCompatibilityVersionFor"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "return   ideaModel ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "return   project . getExtensions (  )  . getByType ( IdeaModel . class )  ;", "}", "METHOD_END"], "methodName": ["ideaModelFor"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . findByName (  \" ideaModule \"  )  . dependsOn ( project . getRootProject (  )  . getTasks (  )  . findByName (  \" ideaProject \"  )  )  ;", "}", "METHOD_END"], "methodName": ["ideaModuleDependsOnRoot"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootProject . getPlugins (  )  . hasPlugin ( IdeaPlugin . class )  )  )     {", "return   true ;", "}", "IdeaProject   ideaProject    =    IdeaPlugin . ideaModelFor ( rootProject )  . getProject (  )  ;", "return    !  ( moduleTargetBytecodeLevel . equals ( ideaProject . getTargetBytecodeVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["includeModuleBytecodeLevelOverride"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootProject . getPlugins (  )  . hasPlugin ( IdeaPlugin . class )  )  )     {", "return   true ;", "}", "IdeaProject   ideaProject    =    IdeaPlugin . ideaModelFor ( rootProject )  . getProject (  )  ;", "return    !  ( moduleLanguageLevel . equals ( ideaProject . getLanguageLevel (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["includeModuleLanguageLevelOverride"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "if    ( isRoot (  )  )     {", "getLifecycleTask (  )  . dependsOn ( new   Callable < List < TaskDependency >  >  (  )     {", "@ Override", "public   List < TaskDependency >    call (  )     {", "return   allImlArtifactsInComposite ( project ,    Model . getProject (  )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["linkCompositeBuildDependencies"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "SingleMessageLogger . nagUserOfDiscontinuedMethod (  \" performPostEvaluationActions \"  )  ;", "}", "METHOD_END"], "methodName": ["performPostEvaluationActions"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Map < String ,    Collection < Configuration >  >  >    scopes    =    Maps . newLinkedHashMap (  )  ;", "for    ( GeneratedScope   scope    :    GeneratedScope . values (  )  )     {", "Map < String ,    Collection < Configuration >  >    plusMinus    =    Maps . newLinkedHashMap (  )  ;", "plusMinus . put ( DependenciesProvider . SCOPE _ PLUS ,    Lists .  < Configuration > newArrayList (  )  )  ;", "plusMinus . put ( DependenciesProvider . SCOPE _ MINUS ,    Lists .  < Configuration > newArrayList (  )  )  ;", "scopes . put ( scope . name (  )  ,    plusMinus )  ;", "}", "Project   project    =    ideaModule . getProject (  )  ;", "ConfigurationContainer   configurations    =    project . getConfigurations (  )  ;", "Collection < Configuration >    provided    =    scopes . get ( GeneratedScope . PROVIDED . name (  )  )  . get ( DependenciesProvider . SCOPE _ PLUS )  ;", "provided . add ( configurations . getByName ( COMPILE _ CLASSPATH _ CONFIGURATION _ NAME )  )  ;", "Collection < Configuration >    runtime    =    scopes . get ( GeneratedScope . RUNTIME . name (  )  )  . get ( DependenciesProvider . SCOPE _ PLUS )  ;", "runtime . add ( configurations . getByName ( RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  )  ;", "Collection < Configuration >    test    =    scopes . get ( GeneratedScope . TEST . name (  )  )  . get ( DependenciesProvider . SCOPE _ PLUS )  ;", "test . add ( configurations . getByName ( TEST _ COMPILE _ CLASSPATH _ CONFIGURATION _ NAME )  )  ;", "test . add ( configurations . getByName ( TEST _ RUNTIME _ CLASSPATH _ CONFIGURATION _ NAME )  )  ;", "ideaModule . getModule (  )  . setScopes ( scopes )  ;", "}", "METHOD_END"], "methodName": ["setupScopes"], "fileName": "org.gradle.plugins.ide.idea.IdeaPlugin"}, {"methodBody": ["METHOD_START", "{", "return   ideaModule . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaModuleMetadata"}, {"methodBody": ["METHOD_START", "{", "rootProject . getGradle (  )  . addBuildListener ( new   BuildAdapter (  )     {", "public   void   projectsEvaluated ( Gradle   gradle )     {", "VersionNumber   ideaTargetVersion    =    findIdeaTargetVersion (  )  ;", "final   boolean   useScalaSdk    =     ( ideaTargetVersion    =  =    null )     |  |     (  (  . IDEA _ VERSION _ WHEN _ SCALA _ SDK _ WAS _ INTRODUCED . compareTo ( ideaTargetVersion )  )     <  =     0  )  ;", "final   Collection < Project >    scalaProjects    =    findProjectsApplyingIdeaAndScalaPlugins (  )  ;", "final   Map < String ,    ProjectLibrary >    scalaCompilerLibraries    =    Maps . newLinkedHashMap (  )  ;", "rootProject . getTasks (  )  . getByName (  \" ideaProject \"  )  . doFirst ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "if    (  ( scalaProjects . size (  )  )     >     0  )     {", "scalaCompilerLibraries . clear (  )  ;", "scalaCompilerLibraries . putAll (  . resolveScalaCompilerLibraries ( scalaProjects ,    useScalaSdk )  )  ;", "declareUniqueProjectLibraries ( Sets . newLinkedHashSet ( scalaCompilerLibraries . values (  )  )  )  ;", "}", "}", "}  )  ;", "rootProject . configure ( scalaProjects ,    new   Action < Project >  (  )     {", "@ Override", "public   void   execute ( final   Project   project )     {", "project . getExtensions (  )  . getByType ( IdeaModel . class )  . getModule (  )  . getIml (  )  . withXml ( new   Action < XmlProvider >  (  )     {", "@ Override", "public   void   execute ( XmlProvider   xmlProvider )     {", "if    ( useScalaSdk )     {", ". declareScalaSdk ( scalaCompilerLibraries . get ( project . getPath (  )  )  ,    xmlProvider . asNode (  )  )  ;", "} else    {", ". declareScalaFacet ( scalaCompilerLibraries . get ( project . getPath (  )  )  ,    xmlProvider . asNode (  )  )  ;", "}", "}", "}  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . any ( libraries ,    new   com . google . common . base . Predicate < ProjectLibrary >  (  )     {", "@ Override", "public   boolean   apply ( ProjectLibrary   library )     {", "return   Objects . equal ( library . getName (  )  ,    name )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["containsLibraryWithSameName"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "ProjectLibrary   projectLibrary    =    new   ProjectLibrary (  )  ;", "projectLibrary . setName ( name )  ;", "projectLibrary . setClasses ( Sets . newLinkedHashSet ( jars )  )  ;", "return   projectLibrary ;", "}", "METHOD_END"], "methodName": ["createProjectLibrary"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "String   version    =    platform . getScalaVersion (  )  ;", "if    ( useScalaSdk )     {", "return    . createScalaSdkLibrary (  (  \" scala - sdk -  \"     +    version )  ,    scalaClasspath )  ;", "}", "return    . createProjectLibrary (  (  \" scala - compiler -  \"     +    version )  ,    scalaClasspath )  ;", "}", "METHOD_END"], "methodName": ["createScalaSdkFromPlatform"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "ProjectLibrary   projectLibrary    =    new   ProjectLibrary (  )  ;", "projectLibrary . setName ( name )  ;", "projectLibrary . setType (  \"  \"  )  ;", "projectLibrary . setCompilerClasspath ( Sets . newLinkedHashSet ( jars )  )  ;", "return   projectLibrary ;", "}", "METHOD_END"], "methodName": ["createScalaSdkLibrary"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "ScalaRuntime   runtime    =    scalaProject . getExtensions (  )  . findByType ( ScalaRuntime . class )  ;", "if    ( runtime    !  =    null )     {", "FileCollection   scalaClasspath    =    runtime . inferScalaClasspath ( files )  ;", "File   compilerJar    =    runtime . findScalaJar ( scalaClasspath ,     \" compiler \"  )  ;", "ScalaPlatform   scalaPlatform    =     ( compilerJar    !  =    null )     ?    new   DefaultScalaPlatform ( runtime . getScalaVersion ( compilerJar )  )     :    new   DefaultScalaPlatform (  )  ;", "return    . createScalaSdkFromPlatform ( scalaPlatform ,    scalaClasspath ,    useScalaSdk )  ;", "} else", "if    (  ( ideaModule . getScalaPlatform (  )  )     !  =    null )     {", "return    . createScalaSdkFromPlatform ( ideaModule . getScalaPlatform (  )  ,    scalaProject . files ( files )  ,    useScalaSdk )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["createScalaSdkLibrary"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "Node   facetManager    =    XmlPersistableConfigurationObject . findOrCreateFirstChildWithAttributeValue ( iml ,     \" component \"  ,     \" name \"  ,     \" FacetManager \"  )  ;", "Node   scalaFacet    =    XmlPersistableConfigurationObject . findOrCreateFirstChildWithAttributeValue ( facetManager ,     \" facet \"  ,     \" type \"  ,     \" scala \"  )  ;", "scalaFacet . attributes (  )  . put (  \" name \"  ,     \" Scala \"  )  ;", "Node   configuration    =    XmlPersistableConfigurationObject . findOrCreateFirstChildNamed ( scalaFacet ,     \" configuration \"  )  ;", "Node   libraryLevel    =    XmlPersistableConfigurationObject . findOrCreateFirstChildWithAttributeValue ( configuration ,     \" option \"  ,     \" name \"  ,     \" compilerLibraryLevel \"  )  ;", "libraryLevel . attributes (  )  . put (  \" value \"  ,     \" Project \"  )  ;", "Node   libraryName    =    XmlPersistableConfigurationObject . findOrCreateFirstChildWithAttributeValue ( configuration ,     \" option \"  ,     \" name \"  ,     \" compilerLibraryName \"  )  ;", "libraryName . attributes (  )  . put (  \" value \"  ,    scalaCompilerLibrary . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["declareScalaFacet"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "if    ( scalaSdkLibrary    !  =    null )     {", "Node   newModuleRootManager    =    XmlPersistableationObject . findOrCreateFirstChildWithAttributeValue ( iml ,     \" component \"  ,     \" name \"  ,     \" NewModuleRootManager \"  )  ;", "Node   sdkLibrary    =    XmlPersistableationObject . findOrCreateFirstChildWithAttributeValue ( newModuleRootManager ,     \" orderEntry \"  ,     \" name \"  ,    scalaSdkLibrary . getName (  )  )  ;", "sdkLibrary . attributes (  )  . put (  \" type \"  ,     \" library \"  )  ;", "sdkLibrary . attributes (  )  . put (  \" level \"  ,     \" project \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["declareScalaSdk"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "Set < ProjectLibrary >    existingLibraries    =    rootProject . getExtensions (  )  . getByType ( IdeaModel . class )  . getProject (  )  . getProjectLibraries (  )  ;", "Set < ProjectLibrary >    newLibraries    =    Sets . difference ( projectLibraries ,    existingLibraries )  ;", "for    ( ProjectLibrary   newLibrary    :    newLibraries )     {", "String   originalName    =    newLibrary . getName (  )  ;", "int   suffix    =     1  ;", "while    (  . containsLibraryWithSameName ( existingLibraries ,    newLibrary . getName (  )  )  )     {", "newLibrary . setName (  (  ( originalName    +     \"  -  \"  )     +     ( suffix +  +  )  )  )  ;", "}", "existingLibraries . add ( newLibrary )  ;", "}", "}", "METHOD_END"], "methodName": ["declareUniqueProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "VersionNumber   targetVersion    =    null ;", "String   targetVersionString    =    rootProject . getExtensions (  )  . getByType ( IdeaModel . class )  . getTargetVersion (  )  ;", "if    ( targetVersionString    !  =    null )     {", "targetVersion    =    VersionNumber . parse ( targetVersionString )  ;", "if    ( targetVersion . equals ( UNKNOWN )  )     {", "throw   new   GScriptException (  (  (  \" String    \\  '  \"     +    targetVersionString )     +     \"  \\  '    is   not   a   valid   value   for   IdeaModel . targetVersion .  \"  )  ,    null )  ;", "}", "}", "return   targetVersion ;", "}", "METHOD_END"], "methodName": ["findIdeaTargetVersion"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   Collections 2  . filter ( rootProject . getAllprojects (  )  ,    new   com . google . common . base . Predicate < Project >  (  )     {", "@ Override", "public   boolean   apply ( Project   project )     {", "return    ( project . getP (  )  . hasPlugin ( IdeaPlugin . class )  )     &  &     (  ( project . getP (  )  . hasPlugin ( ScalaBasePlugin . class )  )     |  |     ( project . getP (  )  . hasPlugin ( ScalaLanguagePlugin . class )  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findProjectsApplyingIdeaAndScalaPlugins"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "Set < Dependency >    dependencies    =    ideaModule . resolveDependencies (  )  ;", "List < File >    files    =    Lists . newArrayList (  )  ;", "for    ( ModuleLibrary   moduleLibrary    :    Iterables . filter ( dependencies ,    ModuleLibrary . class )  )     {", "for    ( FilePath   filePath    :    Iterables . filter ( moduleLibrary . getClasses (  )  ,    FilePath . class )  )     {", "files . add ( filePath . getFile (  )  )  ;", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["getIdeaModuleLibraryDependenciesAsFiles"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ProjectLibrary >    scalaCompilerLibraries    =    Maps . newLinkedHashMap (  )  ;", "for    ( Project   scalaProject    :    scalaProjects )     {", "IdeaModule   ideaModule    =    scalaProject . getExtensions (  )  . getByType ( IdeaModel . class )  . getModule (  )  ;", "Iterable < File >    files    =     . getIdeaModuleLibraryDependenciesAsFiles ( ideaModule )  ;", "ProjectLibrary   library    =     . createScalaSdkLibrary ( scalaProject ,    files ,    useScalaSdk ,    ideaModule )  ;", "if    ( library    !  =    null )     {", "ProjectLibrary   duplicate    =    Iterables . find ( scalaCompilerLibraries . values (  )  ,    Predicates . equalTo ( library )  ,    null )  ;", "scalaCompilerLibraries . put ( scalaProject . getPath (  )  ,     ( duplicate    =  =    null    ?    library    :    duplicate )  )  ;", "}", "}", "return   scalaCompilerLibraries ;", "}", "METHOD_END"], "methodName": ["resolveScalaCompilerLibraries"], "fileName": "org.gradle.plugins.ide.idea.internal.IdeaScalaConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.idea.model.FilePath"}, {"methodBody": ["METHOD_START", "{", "return   level ;", "}", "METHOD_END"], "methodName": ["getLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "this . level    =    level ;", "}", "METHOD_END"], "methodName": ["setLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "return   targetVersion ;", "}", "METHOD_END"], "methodName": ["getTargetVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "return   workspace ;", "}", "METHOD_END"], "methodName": ["getWorkspace"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getModule (  )  )  ;", "}", "METHOD_END"], "methodName": ["module"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getModule (  )  )  ;", "}", "METHOD_END"], "methodName": ["module"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( pathVariables )  ;", "module . getPathVariables (  )  . putAll ( pathVariables )  ;", "}", "METHOD_END"], "methodName": ["pathVariables"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "this . module    =    module ;", "}", "METHOD_END"], "methodName": ["setModule"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "this . project    =    project ;", "}", "METHOD_END"], "methodName": ["setProject"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "this . targetVersion    =    targetVersion ;", "}", "METHOD_END"], "methodName": ["setTargetVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "this . workspace    =    workspace ;", "}", "METHOD_END"], "methodName": ["setWorkspace"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getWorkspace (  )  )  ;", "}", "METHOD_END"], "methodName": ["workspace"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getWorkspace (  )  )  ;", "}", "METHOD_END"], "methodName": ["workspace"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModel"}, {"methodBody": ["METHOD_START", "{", "return   Sets . filter ( files ,    new   com . google . common . base . Predicate < File >  (  )     {", "@ Override", "public   boolean   apply ( File   file )     {", "return   file . exists (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["existing"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   contentRoot ;", "}", "METHOD_END"], "methodName": ["getContentRoot"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   excludeDirs ;", "}", "METHOD_END"], "methodName": ["getExcludeDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   generatedSourceDirs ;", "}", "METHOD_END"], "methodName": ["getGeneratedSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   iml ;", "}", "METHOD_END"], "methodName": ["getIml"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   inheritOutputDirs ;", "}", "METHOD_END"], "methodName": ["getInheritOutputDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   jdkName ;", "}", "METHOD_END"], "methodName": ["getJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   languageLevel ;", "}", "METHOD_END"], "methodName": ["getLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   outputDir ;", "}", "METHOD_END"], "methodName": ["getOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( iml . getGenerateTo (  )  ,     (  ( getName (  )  )     +     \"  . iml \"  )  )  ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   pathFactory ;", "}", "METHOD_END"], "methodName": ["getPathFactory"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   pathVariables ;", "}", "METHOD_END"], "methodName": ["getPathVariables"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   resourceDirs ;", "}", "METHOD_END"], "methodName": ["getResourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   scalaPlatform ;", "}", "METHOD_END"], "methodName": ["getScalaPlatform"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   scopes ;", "}", "METHOD_END"], "methodName": ["getScopes"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   singleEntryLibraries ;", "}", "METHOD_END"], "methodName": ["getSingleEntryLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   sourceDirs ;", "}", "METHOD_END"], "methodName": ["getSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["getTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   testOutputDir ;", "}", "METHOD_END"], "methodName": ["getTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   testResourceDirs ;", "}", "METHOD_END"], "methodName": ["getTestResourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   testSourceDirs ;", "}", "METHOD_END"], "methodName": ["getTestSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getIml (  )  )  ;", "}", "METHOD_END"], "methodName": ["iml"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getIml (  )  )  ;", "}", "METHOD_END"], "methodName": ["iml"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   downloadJavadoc ;", "}", "METHOD_END"], "methodName": ["isDownloadJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   downloadSources ;", "}", "METHOD_END"], "methodName": ["isDownloadSources"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   offline ;", "}", "METHOD_END"], "methodName": ["isOffline"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "iml . getBeforeMerged (  )  . execute ( xmlModule )  ;", "Path   contentRoot    =    getPathFactory (  )  . path ( getContentRoot (  )  )  ;", "Set < Path >    sourceFolders    =    pathsOf ( existing ( getSourceDirs (  )  )  )  ;", "Set < Path >    generatedSourceFolders    =    pathsOf ( existing ( getGeneratedSourceDirs (  )  )  )  ;", "Set < Path >    testSourceFolders    =    pathsOf ( existing ( getTestSourceDirs (  )  )  )  ;", "Set < Path >    resourceFolders    =    pathsOf ( existing ( getResourceDirs (  )  )  )  ;", "Set < Path >    testResourceFolders    =    pathsOf ( existing ( getTestResourceDirs (  )  )  )  ;", "Set < Path >    excludeFolders    =    pathsOf ( getExcludeDirs (  )  )  ;", "Path   outputDir    =     (  ( getOutputDir (  )  )     !  =    null )     ?    getPathFactory (  )  . path ( getOutputDir (  )  )     :    null ;", "Path   testOutputDir    =     (  ( getTestOutputDir (  )  )     !  =    null )     ?    getPathFactory (  )  . path ( getTestOutputDir (  )  )     :    null ;", "Set < Dependency >    dependencies    =    resolveDependencies (  )  ;", "String   level    =     (  ( getLanguageLevel (  )  )     !  =    null )     ?    getLanguageLevel (  )  . getLevel (  )     :    null ;", "xmlModule . configure ( contentRoot ,    sourceFolders ,    testSourceFolders ,    resourceFolders ,    testResourceFolders ,    generatedSourceFolders ,    excludeFolders ,    getInheritOutputDirs (  )  ,    outputDir ,    testOutputDir ,    dependencies ,    getJdkName (  )  ,    level )  ;", "iml . getWhenMerged (  )  . execute ( xmlModule )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlModule"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   Sets . newLinkedHashSet ( Iterables . transform ( files ,    new   com . google . common . base . Function < File ,    Path >  (  )     {", "@ Override", "public   Path   apply ( File   file )     {", "return   getPathFactory (  )  . path ( file )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["pathsOf"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "ProjectInternal   projectInternal    =     (  ( ProjectInternal )     ( project )  )  ;", "IdeaDependenciesProvider   DependenciesProvider    =    new   IdeaDependenciesProvider ( projectInternal . getServices (  )  . get ( IdeArtifactRegistry . class )  )  ;", "return   DependenciesProvider . provide ( this )  ;", "}", "METHOD_END"], "methodName": ["resolveDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . contentRoot    =    contentRoot ;", "}", "METHOD_END"], "methodName": ["setContentRoot"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . downloadJavadoc    =    downloadJavadoc ;", "}", "METHOD_END"], "methodName": ["setDownloadJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . downloadSources    =    downloadSources ;", "}", "METHOD_END"], "methodName": ["setDownloadSources"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . excludeDirs    =    excludeDirs ;", "}", "METHOD_END"], "methodName": ["setExcludeDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . generatedSourceDirs    =    generatedSourceDirs ;", "}", "METHOD_END"], "methodName": ["setGeneratedSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . inheritOutputDirs    =    inheritOutputDirs ;", "}", "METHOD_END"], "methodName": ["setInheritOutputDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . jdkName    =    jdkName ;", "}", "METHOD_END"], "methodName": ["setJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "}", "METHOD_END"], "methodName": ["setLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . offline    =    offline ;", "}", "METHOD_END"], "methodName": ["setOffline"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . outputDir    =    outputDir ;", "}", "METHOD_END"], "methodName": ["setOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "setName ( newOutputFile . getName (  )  . replaceFirst (  \"  \\  \\  . iml $  \"  ,     \"  \"  )  )  ;", "iml . setGenerateTo ( newOutputFile . getParentFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . pathFactory    =    pathFactory ;", "}", "METHOD_END"], "methodName": ["setPathFactory"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . pathVariables    =    pathVariables ;", "}", "METHOD_END"], "methodName": ["setPathVariables"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . resourceDirs    =    resourceDirs ;", "}", "METHOD_END"], "methodName": ["setResourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . scalaPlatform    =    scalaPlatform ;", "}", "METHOD_END"], "methodName": ["setScalaPlatform"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . scopes    =    scopes ;", "}", "METHOD_END"], "methodName": ["setScopes"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . singleEntryLibraries    =    singleEntryLibraries ;", "}", "METHOD_END"], "methodName": ["setSingleEntryLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . sourceDirs    =    sourceDirs ;", "}", "METHOD_END"], "methodName": ["setSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . targetBytecodeVersion    =    targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["setTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . testOutputDir    =    testOutputDir ;", "}", "METHOD_END"], "methodName": ["setTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . testResourceDirs    =    testResourceDirs ;", "}", "METHOD_END"], "methodName": ["setTestResourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . testSourceDirs    =    testSourceDirs ;", "}", "METHOD_END"], "methodName": ["setTestSourceDirs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   generateTo ;", "}", "METHOD_END"], "methodName": ["getGenerateTo"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModuleIml"}, {"methodBody": ["METHOD_START", "{", "this . generateTo    =    generateTo ;", "}", "METHOD_END"], "methodName": ["setGenerateTo"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaModuleIml"}, {"methodBody": ["METHOD_START", "{", "ProjectComponentIdentifier   thisProjectId    =    projectPathRegistry . getProjectComponentIdentifier (  (  ( ProjectInternal )     ( project )  )  . getIdentityPath (  )  )  ;", "for    ( IdeArtifactRegistry . Reference < IdeaModuleMetadata >    reference    :    artifactRegistry . getIdeArtifactMetadata ( IdeaModuleMetadata . class )  )     {", "BuildIdentifier   otherBuildId    =    reference . getOwningProject (  )  . getBuild (  )  ;", "if    ( thisProjectId . getBuild (  )  . equals ( otherBuildId )  )     {", "continue ;", "}", "xmlProject . addModulePath ( reference . get (  )  . getFile (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureModulePaths"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   ipr ;", "}", "METHOD_END"], "methodName": ["getIpr"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   jdkName ;", "}", "METHOD_END"], "methodName": ["getJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   languageLevel ;", "}", "METHOD_END"], "methodName": ["getLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   modules ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   getOutputFile (  )  . getName (  )  . replaceFirst (  \"  \\  \\  . ipr $  \"  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   outputFile . get (  )  . getAsFile (  )  ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   pathFactory ;", "}", "METHOD_END"], "methodName": ["getPathFactory"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   projectLibraries ;", "}", "METHOD_END"], "methodName": ["getProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["getTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   vcs ;", "}", "METHOD_END"], "methodName": ["getVcs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   wildcards ;", "}", "METHOD_END"], "methodName": ["getWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getIpr (  )  )  ;", "}", "METHOD_END"], "methodName": ["ipr"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getIpr (  )  )  ;", "}", "METHOD_END"], "methodName": ["ipr"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "ipr . getBeforeMerged (  )  . execute ( xmlProject )  ;", "xmlProject . configure ( getModules (  )  ,    getJdkName (  )  ,    getLanguageLevel (  )  ,    getTargetBytecodeVersion (  )  ,    getWildcards (  )  ,    getProjectLibraries (  )  ,    getVcs (  )  )  ;", "configureModulePaths ( xmlProject )  ;", "ipr . getWhenMerged (  )  . execute ( xmlProject )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlProject"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . jdkName    =    jdkName ;", "}", "METHOD_END"], "methodName": ["setJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    new   IdeaLanguageLevel ( languageLevel )  ;", "}", "METHOD_END"], "methodName": ["setLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "}", "METHOD_END"], "methodName": ["setLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . modules    =    modules ;", "}", "METHOD_END"], "methodName": ["setModules"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . outputFile . set ( outputFile )  ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . pathFactory    =    pathFactory ;", "}", "METHOD_END"], "methodName": ["setPathFactory"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . projectLibraries    =    projectLibraries ;", "}", "METHOD_END"], "methodName": ["setProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . targetBytecodeVersion    =    targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["setTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . vcs    =    vcs ;", "}", "METHOD_END"], "methodName": ["setVcs"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . wildcards    =    wildcards ;", "}", "METHOD_END"], "methodName": ["setWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   iws ;", "}", "METHOD_END"], "methodName": ["getIws"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "configure ( closure ,    getIws (  )  )  ;", "}", "METHOD_END"], "methodName": ["iws"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "action . execute ( getIws (  )  )  ;", "}", "METHOD_END"], "methodName": ["iws"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "iws . getBeforeMerged (  )  . execute ( xmlWorkspace )  ;", "iws . getWhenMerged (  )  . execute ( xmlWorkspace )  ;", "}", "METHOD_END"], "methodName": ["mergeXmlWorkspace"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "this . iws    =    iws ;", "}", "METHOD_END"], "methodName": ["setIws"], "fileName": "org.gradle.plugins.ide.idea.model.IdeaWorkspace"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.idea.model.JarDirectory"}, {"methodBody": ["METHOD_START", "{", "return   recursive ;", "}", "METHOD_END"], "methodName": ["isRecursive"], "fileName": "org.gradle.plugins.ide.idea.model.JarDirectory"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.plugins.ide.idea.model.JarDirectory"}, {"methodBody": ["METHOD_START", "{", "this . recursive    =    recursive ;", "}", "METHOD_END"], "methodName": ["setRecursive"], "fileName": "org.gradle.plugins.ide.idea.model.JarDirectory"}, {"methodBody": ["METHOD_START", "{", "return   languageLevel ;", "}", "METHOD_END"], "methodName": ["getLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "return   projectJdkName ;", "}", "METHOD_END"], "methodName": ["getProjectJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "return   assertKeyword ;", "}", "METHOD_END"], "methodName": ["isAssertKeyword"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "return   jdk 1  5  ;", "}", "METHOD_END"], "methodName": ["isJdk15"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "this . assertKeyword    =    assertKeyword ;", "}", "METHOD_END"], "methodName": ["setAssertKeyword"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "this . jdk 1  5     =    jdk 1  5  ;", "}", "METHOD_END"], "methodName": ["setJdk15"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "}", "METHOD_END"], "methodName": ["setLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "this . projectJdkName    =    projectJdkName ;", "}", "METHOD_END"], "methodName": ["setProjectJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.Jdk"}, {"methodBody": ["METHOD_START", "{", "Node   moduleRoot    =    getNewModuleRootManager (  )  ;", "for    ( Dependency   dependency    :    dependencies )     {", "dependency . addToNode ( moduleRoot )  ;", "}", "}", "METHOD_END"], "methodName": ["addDependenciesToXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( jdkName )  ;", "List < Node >    orderEntries    =    findOrderEntries (  )  ;", "Node   moduleJdk    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( orderEntries ,     \" type \"  ,     \" jdk \"  )  ;", "Node   moduleRootManager    =    getNewRootManager (  )  ;", "if    (  !  ( jdkName . equals (  . INHERITED )  )  )     {", "Node   inheritedJdk    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( orderEntries ,     \" type \"  ,     \" inheritedJdk \"  )  ;", "if    ( inheritedJdk    !  =    null )     {", "inheritedJdk . parent (  )  . remove ( inheritedJdk )  ;", "}", "if    ( moduleJdk    !  =    null )     {", "moduleRootManager . remove ( moduleJdk )  ;", "}", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" type \"  ,     \" jdk \"  )  ;", "attributes . put (  \" jdkName \"  ,    jdkName )  ;", "attributes . put (  \" jdkType \"  ,     \" JavaSDK \"  )  ;", "moduleRootManager . appendNode (  \" orderEntry \"  ,    attributes )  ;", "} else", "if    (  ( XmlPersistableConfigurationObject . findFirstWithAttributeValue ( orderEntries ,     \" type \"  ,     \" inheritedJdk \"  )  )     =  =    null )     {", "if    ( moduleJdk    !  =    null )     {", "moduleRootManager . remove ( moduleJdk )  ;", "}", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" type \"  ,     \" inheritedJdk \"  )  ;", "moduleRootManager . appendNode (  \" orderEntry \"  ,    attributes )  ;", "}", "}", "METHOD_END"], "methodName": ["addJdkToXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "if    (  ( outputDir )     !  =    null )     {", "findOrCreateOutputDir (  )  . attributes (  )  . put (  \" url \"  ,    outputDir . getUrl (  )  )  ;", "}", "if    (  ( testOutputDir )     !  =    null )     {", "findOrCreateTestOutputDir (  )  . attributes (  )  . put (  \" url \"  ,    testOutputDir . getUrl (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addOutputDirsToXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   content    =    findOrCreateContentNode (  )  ;", "for    ( Path   path    :    sourceFolders )     {", "if    ( resourceFolders . contains ( path )  )     {", "continue ;", "}", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    path . getUrl (  )  )  ;", "attributes . put (  \" isTestSource \"  ,     \" false \"  )  ;", "if    ( generatedSourceFolders . contains ( path )  )     {", "attributes . put (  \" generated \"  ,     \" true \"  )  ;", "}", "content . appendNode (  \" sourceFolder \"  ,    attributes )  ;", "}", "for    ( Path   path    :    testSourceFolders )     {", "if    ( testResourceFolders . contains ( path )  )     {", "continue ;", "}", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    path . getUrl (  )  )  ;", "attributes . put (  \" isTestSource \"  ,     \" true \"  )  ;", "if    ( generatedSourceFolders . contains ( path )  )     {", "attributes . put (  \" generated \"  ,     \" true \"  )  ;", "}", "content . appendNode (  \" sourceFolder \"  ,    attributes )  ;", "}", "for    ( Path   path    :    resourceFolders )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    path . getUrl (  )  )  ;", "attributes . put (  \" type \"  ,     \" java - resource \"  )  ;", "if    ( generatedSourceFolders . contains ( path )  )     {", "attributes . put (  \" generated \"  ,     \" true \"  )  ;", "}", "content . appendNode (  \" sourceFolder \"  ,    attributes )  ;", "}", "for    ( Path   path    :    testResourceFolders )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    path . getUrl (  )  )  ;", "attributes . put (  \" type \"  ,     \" java - test - resource \"  )  ;", "if    ( generatedSourceFolders . contains ( path )  )     {", "attributes . put (  \" generated \"  ,     \" true \"  )  ;", "}", "content . appendNode (  \" sourceFolder \"  ,    attributes )  ;", "}", "for    ( Path   path    :    excludeFolders )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    path . getUrl (  )  )  ;", "content . appendNode (  \" excludeFolder \"  ,    attributes )  ;", "}", "}", "METHOD_END"], "methodName": ["addSourceAndExcludeFolderToXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "this . contentPath    =    contentPath ;", "this . sourceFolders . addAll ( sourceFolders )  ;", "this . testSourceFolders . addAll ( testSourceFolders )  ;", "this . resourceFolders . addAll ( resourceFolders )  ;", "this . testResourceFolders . addAll ( testResourceFolders )  ;", "this . generatedSourceFolders . addAll ( generatedSourceFolders )  ;", "this . excludeFolders . addAll ( excludeFolders )  ;", "if    ( inheritOutputDirs    !  =    null )     {", "this . inheritOutputDirs    =    inheritOutputDirs ;", "}", "if    ( outputDir    !  =    null )     {", "this . outputDir    =    outputDir ;", "}", "if    ( testOutputDir    !  =    null )     {", "this . testOutputDir    =    testOutputDir ;", "}", "this . dependencies    =    dependencies ;", "if    (  !  ( isNullOrEmpty ( jdkName )  )  )     {", "this . jdkName    =    jdkName ;", "} else    {", "this . jdkName    =     . INHERITED ;", "}", "return   this . jdkName ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . getChildren ( findOrCreateContentNode (  )  ,     \" excludeFolder \"  )  ;", "}", "METHOD_END"], "methodName": ["findExcludeFolder"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   newModuleRootManager    =    getNewModuleRootManager (  )  ;", "Node   contentNode    =    XmlPersistableConfigurationObject . findFirstChildNamed ( newModuleRootManager ,    Module . CONTENT )  ;", "if    ( contentNode    !  =    null )     {", "return   contentNode ;", "}", "return   newModuleRootManager . appendNode ( Module . CONTENT )  ;", "}", "METHOD_END"], "methodName": ["findOrCreateContentNode"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   outputDirNode    =    findOutputDir (  )  ;", "if    ( outputDirNode    !  =    null )     {", "return   outputDirNode ;", "}", "return   getNewRootManager (  )  . appendNode (  \" output \"  )  ;", "}", "METHOD_END"], "methodName": ["findOrCreateOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   testOutputDirNode    =    findTestOutputDir (  )  ;", "if    ( testOutputDirNode    !  =    null )     {", "return   testOutputDirNode ;", "}", "return   getNewRootManager (  )  . appendNode (  \" output - test \"  )  ;", "}", "METHOD_END"], "methodName": ["findOrCreateTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . getChildren ( getNewModuleRootManager (  )  ,     \" orderEntry \"  )  ;", "}", "METHOD_END"], "methodName": ["findOrderEntries"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . findFirstChildNamed ( getNewModuleRootManager (  )  ,     \" output \"  )  ;", "}", "METHOD_END"], "methodName": ["findOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . getChildren ( findOrCreateContentNode (  )  ,     \" sourceFolder \"  )  ;", "}", "METHOD_END"], "methodName": ["findSourceFolder"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . findFirstChildNamed ( getNewModuleRootManager (  )  ,     \" output - test \"  )  ;", "}", "METHOD_END"], "methodName": ["findTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   contentPath ;", "}", "METHOD_END"], "methodName": ["getContentPath"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   excludeFolders ;", "}", "METHOD_END"], "methodName": ["getExcludeFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   generatedSourceFolders ;", "}", "METHOD_END"], "methodName": ["getGeneratedSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   jdkName ;", "}", "METHOD_END"], "methodName": ["getJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   newModuleRootManager    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" NewModuleRootManager \"  )  ;", "Preconditions . checkNotNull ( newModuleRootManager )  ;", "return   newModuleRootManager ;", "}", "METHOD_END"], "methodName": ["getNewModuleRootManager"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   outputDir ;", "}", "METHOD_END"], "methodName": ["getOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   resourceFolders ;", "}", "METHOD_END"], "methodName": ["getResourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   sourceFolders ;", "}", "METHOD_END"], "methodName": ["getSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   testOutputDir ;", "}", "METHOD_END"], "methodName": ["getTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   testResourceFolders ;", "}", "METHOD_END"], "methodName": ["getTestResourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   testSourceFolders ;", "}", "METHOD_END"], "methodName": ["getTestSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList (  \" module - library \"  ,     \" module \"  )  . contains (  (  ( Node )     ( orderEntry )  )  . attribute (  \" type \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isDependencyOrderEntry"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   inheritOutputDirs ;", "}", "METHOD_END"], "methodName": ["isInheritOutputDirs"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   orderEntry    :    findOrderEntries (  )  )     {", "Object   orderEntryType    =    orderEntry . attribute (  \" type \"  )  ;", "if    (  \" module - library \"  . equals ( orderEntryType )  )     {", "Set < Path >    classes    =    Sets . newLinkedHashSet (  )  ;", "Set < Path >    javadoc    =    Sets . newLinkedHashSet (  )  ;", "Set < Path >    sources    =    Sets . newLinkedHashSet (  )  ;", "Set < JarDirectory >    jarDirectories    =    Sets . newLinkedHashSet (  )  ;", "for    ( Node   library    :    XmlPersistableConfigurationObject . getChildren ( orderEntry ,     \" library \"  )  )     {", "for    ( Node   classesNode    :    XmlPersistableConfigurationObject . getChildren ( library ,     \" CLASSES \"  )  )     {", "readDependenciesPathsFromXml ( classes ,    classesNode )  ;", "}", "for    ( Node   javadocNode    :    XmlPersistableConfigurationObject . getChildren ( library ,     \" JAVADOC \"  )  )     {", "readDependenciesPathsFromXml ( javadoc ,    javadocNode )  ;", "}", "for    ( Node   sourcesNode    :    XmlPersistableConfigurationObject . getChildren ( library ,     \" SOURCES \"  )  )     {", "readDependenciesPathsFromXml ( sources ,    sourcesNode )  ;", "}", "for    ( Node   jarDirNode    :    XmlPersistableConfigurationObject . getChildren ( library ,     \" jarDirectory \"  )  )     {", "jarDirectories . add ( new   JarDirectory ( pathFactory . path (  (  ( String )     ( jarDirNode . attribute (  \" url \"  )  )  )  )  ,    Boolean . parseBoolean (  (  ( String )     ( jarDirNode . attribute (  \" recursive \"  )  )  )  )  )  )  ;", "}", "}", "Library   moduleLibrary    =    new   Library ( classes ,    javadoc ,    sources ,    jarDirectories ,     (  ( String )     ( orderEntry . attribute (  \" scope \"  )  )  )  )  ;", "dependencies . add ( moduleLibrary )  ;", "} else", "if    (  \" module \"  . equals ( orderEntryType )  )     {", "dependencies . add ( new   Dependency (  (  ( String )     ( orderEntry . attribute (  \" module - name \"  )  )  )  ,     (  ( String )     ( orderEntry . attribute (  \" scope \"  )  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readDependenciesFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   classesRoot    :    XmlPersistableConfigurationObject . getChildren ( node ,     \" root \"  )  )     {", "paths . add ( pathFactory . path (  (  ( String )     ( classesRoot . attribute (  \" url \"  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readDependenciesPathsFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   inheritOutputDirs    =     \" true \"  . equals ( getNewModuleRootManager (  )  . attribute (  \" inherit - compiler - output \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readInheritOutputDirsFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   jdk    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( findOrderEntries (  )  ,     \" type \"  ,     \" jdk \"  )  ;", "jdkName    =     ( jdk    !  =    null )     ?     (  ( String )     ( jdk . attribute (  \" jdkName \"  )  )  )     :     . INHERITED ;", "}", "METHOD_END"], "methodName": ["readJdkFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   outputDirNode    =    findOutputDir (  )  ;", "Node   testOutputDirNode    =    findTestOutputDir (  )  ;", "String   outputDirUrl    =     ( outputDirNode    !  =    null )     ?     (  ( String )     ( outputDirNode . attribute (  \" url \"  )  )  )     :    null ;", "String   testOutputDirUrl    =     ( testOutputDirNode    !  =    null )     ?     (  ( String )     ( testOutputDirNode . attribute (  \" url \"  )  )  )     :    null ;", "outputDir    =     ( outputDirUrl    !  =    null )     ?    pathFactory . path ( outputDirUrl )     :    null ;", "return   testOutputDir    =     ( testOutputDirUrl    !  =    null )     ?    pathFactory . path ( testOutputDirUrl )     :    null ;", "}", "METHOD_END"], "methodName": ["readOutputDirsFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   sourceFolder    :    findSourceFolder (  )  )     {", "String   url    =     (  ( String )     ( sourceFolder . attribute (  \" url \"  )  )  )  ;", "String   isTestSource    =     (  ( String )     ( sourceFolder . attribute (  \" isTestSource \"  )  )  )  ;", "if    ( isTestSource    !  =    null )     {", "if    (  \" false \"  . equals ( isTestSource )  )     {", "sourceFolders . add ( pathFactory . path ( url )  )  ;", "} else    {", "testSourceFolders . add ( pathFactory . path ( url )  )  ;", "}", "}", "if    (  \" true \"  . equals ( sourceFolder . attribute (  \" generated \"  )  )  )     {", "generatedSourceFolders . add ( pathFactory . path ( url )  )  ;", "}", "String   type    =     (  ( String )     ( sourceFolder . attribute (  \" type \"  )  )  )  ;", "if    (  \" java - resource \"  . equals ( type )  )     {", "resourceFolders . add ( pathFactory . path ( url )  )  ;", "} else", "if    (  \" java - test - resource \"  . equals ( type )  )     {", "testResourceFolders . add ( pathFactory . path ( url )  )  ;", "}", "}", "for    ( Node   excludeFolder    :    findExcludeFolder (  )  )     {", "excludeFolders . add ( pathFactory . path (  (  ( String )     ( excludeFolder . attribute (  \" url \"  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readSourceAndExcludeFolderFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   moduleRoot    =    getNewModuleRootManager (  )  ;", "for    ( Node   orderEntry    :    findOrderEntries (  )  )     {", "if    ( isDependencyOrderEntry ( orderEntry )  )     {", "moduleRoot . remove ( orderEntry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["removeDependenciesFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "Node   content    =    findOrCreateContentNode (  )  ;", "for    ( Node   sourceFolder    :    findSourceFolder (  )  )     {", "content . remove ( sourceFolder )  ;", "}", "for    ( Node   excludeFolder    :    findExcludeFolder (  )  )     {", "content . remove ( excludeFolder )  ;", "}", "}", "METHOD_END"], "methodName": ["removeSourceAndExcludeFolderFromXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . contentPath    =    contentPath ;", "}", "METHOD_END"], "methodName": ["setContentPath"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "if    (  ( contentPath )     !  =    null )     {", "findOrCreateContentN (  )  . attributes (  )  . put (  \" url \"  ,    contentPath . getUrl (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setContentURL"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . dependencies    =    dependencies ;", "}", "METHOD_END"], "methodName": ["setDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . excludeFolders    =    excludeFolders ;", "}", "METHOD_END"], "methodName": ["setExcludeFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . generatedSourceFolders    =    generatedSourceFolders ;", "}", "METHOD_END"], "methodName": ["setGeneratedSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . inheritOutputDirs    =    inheritOutputDirs ;", "}", "METHOD_END"], "methodName": ["setInheritOutputDirs"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . jdkName    =    jdkName ;", "}", "METHOD_END"], "methodName": ["setJdkName"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . outputDir    =    outputDir ;", "}", "METHOD_END"], "methodName": ["setOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . resourceFolders    =    resourceFolders ;", "}", "METHOD_END"], "methodName": ["setResourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . sourceFolders    =    sourceFolders ;", "}", "METHOD_END"], "methodName": ["setSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . testOutputDir    =    testOutputDir ;", "}", "METHOD_END"], "methodName": ["setTestOutputDir"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . testResourceFolders    =    testResourceFolders ;", "}", "METHOD_END"], "methodName": ["setTestResourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "this . testSourceFolders    =    testSourceFolders ;", "}", "METHOD_END"], "methodName": ["setTestSourceFolders"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "getNewModuleRootManager (  )  . attributes (  )  . put (  \" inherit - compiler - output \"  ,    inheritOutputDirs )  ;", "}", "METHOD_END"], "methodName": ["writeInheritOutputDirsToXml"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "if    (  ( languageLevel )     !  =    null )     {", "getNewRootManager (  )  . attributes (  )  . put (  \" LANGUAGE _ LEVEL \"  ,    languageLevel )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSourceLanguageLevel"], "fileName": "org.gradle.plugins.ide.idea.model.Module"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( Strings . isNullOrEmpty ( scope )  )  )     &  &     (  !  ( scope . equals (  \" COMPILE \"  )  )  )     ?    scope . hashCode (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getScopeHash"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   exported ;", "}", "METHOD_END"], "methodName": ["isExported"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  \" COMPILE \"  . equals ( lhs )  )     {", "return    ( StringsNullOrEmpty ( rhs )  )     |  |     (  \" COMPILE \"  . equals ( rhs )  )  ;", "} else", "if    (  \" COMPILE \"  . equals ( rhs )  )     {", "return    ( StringsNullOrEmpty ( lhs )  )     |  |     (  \" COMPILE \"  . equals ( lhs )  )  ;", "} else    {", "return   com . google . common . base . Objects . equal ( lhs ,    rhs )  ;", "}", "}", "METHOD_END"], "methodName": ["scopeEquals"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . exported    =    exported ;", "}", "METHOD_END"], "methodName": ["setExported"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . scope    =    scope ;", "}", "METHOD_END"], "methodName": ["setScope"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleDependency"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Object >    builder    =    ImmutableMap . builder (  )  ;", "if    ( exported )     {", "builder . put (  \" exported \"  ,     \"  \"  )  ;", "}", "if    (  (  ( scope )     !  =    null )     &  &     (  !  (  \" COMPILE \"  . equals ( scope )  )  )  )     {", "builder . put (  \" scope \"  ,    scope )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getAttributeMapForScopeAndExported"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   classes ;", "}", "METHOD_END"], "methodName": ["getClasses"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   jarDirectories ;", "}", "METHOD_END"], "methodName": ["getJarDirectories"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   javadoc ;", "}", "METHOD_END"], "methodName": ["getJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( isNullOrEmpty ( scope )  )  )     &  &     (  !  ( scope . equals (  \" COMPILE \"  )  )  )     ?    scope . hashCode (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["getScopeHash"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   sources ;", "}", "METHOD_END"], "methodName": ["getSources"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   exported ;", "}", "METHOD_END"], "methodName": ["isExported"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "if    (  \" COMPILE \"  . equals ( lhs )  )     {", "return    ( isNullOrEmpty ( rhs )  )     |  |     (  \" COMPILE \"  . equals ( rhs )  )  ;", "} else", "if    (  \" COMPILE \"  . equals ( rhs )  )     {", "return    ( isNullOrEmpty ( lhs )  )     |  |     (  \" COMPILE \"  . equals ( lhs )  )  ;", "} else    {", "return   com . googcommon . base . Objects . equal ( lhs ,    rhs )  ;", "}", "}", "METHOD_END"], "methodName": ["scopeEquals"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . classes    =    classes ;", "}", "METHOD_END"], "methodName": ["setClasses"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . exported    =    exported ;", "}", "METHOD_END"], "methodName": ["setExported"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . jarDirectories    =    jarDirectories ;", "}", "METHOD_END"], "methodName": ["setJarDirectories"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . javadoc    =    javadoc ;", "}", "METHOD_END"], "methodName": ["setJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . scope    =    scope ;", "}", "METHOD_END"], "methodName": ["setScope"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . sources    =    sources ;", "}", "METHOD_END"], "methodName": ["setSources"], "fileName": "org.gradle.plugins.ide.idea.model.ModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   canonicalUrl ;", "}", "METHOD_END"], "methodName": ["getCanonicalUrl"], "fileName": "org.gradle.plugins.ide.idea.model.Path"}, {"methodBody": ["METHOD_START", "{", "return   relPath ;", "}", "METHOD_END"], "methodName": ["getRelPath"], "fileName": "org.gradle.plugins.ide.idea.model.Path"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.gradle.plugins.ide.idea.model.Path"}, {"methodBody": ["METHOD_START", "{", "variables . add ( new   PathFactory . Variable (  (  (  '  $  '     +    name )     +     '  $  '  )  ,     (  ( dir . getAbsolutePath (  )  )     +     ( File . separator )  )  ,    dir )  )  ;", "varsByName . put ( name ,    dir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addPathVariable"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "List < String >    list    =    Lists . newArrayList (  )  ;", "File   r    =    f . getCanonicalFile (  )  ;", "while    ( r    !  =    null )     {", "File   parent    =    r . getParentFile (  )  ;", "list . add (  ( parent    !  =    null    ?    r . getName (  )     :    r . getAbsolute (  )  )  )  ;", "r    =    parent ;", "}", "return   list ;", "}    catch    ( IOException   ex )     {", "throw   new   UncheckedIOException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getPathList"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "String   relpath    =    PathFactory . matchPathLists ( PathFactory . getPathList ( rootDir )  ,    PathFactory . getPathList ( file )  )  ;", "return   relpath    !  =    null    ?     ( rootDirString    +     \"  /  \"  )     +    relpath    :    file . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   s    =    new   StringBuilder (  )  ;", "int   i    =     ( r . size (  )  )     -     1  ;", "int   j    =     ( f . size (  )  )     -     1  ;", "if    (  !  ( r . get ( i )  . equals ( f . get ( j )  )  )  )     {", "return   null ;", "}", "while    (  (  ( i    >  =     0  )     &  &     ( j    >  =     0  )  )     &  &     ( Objects . equal ( r . get ( i )  ,    f . get ( j )  )  )  )     {", "i -  -  ;", "j -  -  ;", "}", "for    (  ;    i    >  =     0  ;    i -  -  )     {", "s . append (  \"  .  .  /  \"  )  ;", "}", "for    (  ;    j    >  =     1  ;    j -  -  )     {", "s . append ( f . get ( j )  )  . append (  \"  /  \"  )  ;", "}", "if    ( j    =  =     0  )     {", "s . append ( f . get ( j )  )  ;", "}", "return   s . toString (  )  ;", "}", "METHOD_END"], "methodName": ["matchPathLists"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "return   path ( file ,    false )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "PathFactory . Variable   match    =    null ;", "for    ( PathFactory . Variable   variable    :    variables )     {", "if    ( file . getAbsolutePath (  )  . equals ( variable . getDir (  )  . getAbsolutePath (  )  )  )     {", "match    =    variable ;", "break ;", "}", "if    ( file . getAbsolutePath (  )  . startsWith ( variable . getPrefix (  )  )  )     {", "if    (  ( match    =  =    null )     |  |     ( variable . getPrefix (  )  . startsWith ( match . getPrefix (  )  )  )  )     {", "match    =    variable ;", "}", "}", "}", "if    ( match    !  =    null )     {", "return   PathFactory . resolvePath ( match . getDir (  )  ,    match . getName (  )  ,    file )  ;", "}", "String   relPath    =    file . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  ;", "String   url    =    PathFactory . relativePathToURI ( relPath ,    useFileScheme )  ;", "return   new   FilePath ( file ,    url ,    url ,    relPath )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "return   path ( url ,    null )  ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   expandedUrl    =    url ;", "for    (  . Variable   variable    :    variables )     {", "expandedUrl    =    expandedUrl . replace ( variable . getName (  )  ,    variable . getPrefix (  )  )  ;", "}", "if    ( expandedUrl . toLowerCase (  )  . startsWith (  \" file :  /  /  \"  )  )     {", "expandedUrl    =     . toUrl (  \" file \"  ,    new   File ( expandedUrl . substring (  7  )  )  . getCanonicalFile (  )  )  ;", "} else", "if    ( expandedUrl . toLowerCase (  )  . startsWith (  \" jar :  /  /  \"  )  )     {", "String [  ]    parts    =    expandedUrl . substring (  6  )  . split (  \"  !  \"  )  ;", "if    (  ( parts . length )     =  =     2  )     {", "expandedUrl    =     (  (  . toUrl (  \" jar \"  ,    new   File ( parts [  0  ]  )  . getCanonicalFile (  )  )  )     +     \"  !  \"  )     +     ( parts [  1  ]  )  ;", "}", "}", "return   new   Path ( url ,    expandedUrl ,    relPath )  ;", "}    catch    ( IOException   ex )     {", "throw   new   UncheckedIOException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "return   PathFactory . resolvePath ( varsByName . get ( pathVar )  ,     (  (  \"  $  \"     +    pathVar )     +     \"  $  \"  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["relativePath"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "return   PathFactory . relativePathToURI ( relpath ,    false )  ;", "}", "METHOD_END"], "methodName": ["relativePathToURI"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( relpath . endsWith (  \"  . jar \"  )  )     &  &     (  ! useFileScheme )  )     {", "return    (  \" jar :  /  /  \"     +    relpath )     +     \"  !  /  \"  ;", "} else    {", "return    \" file :  /  /  \"     +    relpath ;", "}", "}", "METHOD_END"], "methodName": ["relativePathToURI"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "String   relPath    =    PathFactory . getRelativePath ( rootDir ,    rootDirName ,    file )  ;", "String   url    =    PathFactory . relativePathToURI ( relPath )  ;", "String   canonicalUrl    =    PathFactory . relativePathToURI ( file . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  )  ;", "return   new   FilePath ( file ,    url ,    canonicalUrl ,    relPath )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "return    ( scheme    +     \"  :  /  /  \"  )     +     ( file . getAbsolutePath (  )  . replace ( File . separatorChar ,     '  /  '  )  )  ;", "}", "METHOD_END"], "methodName": ["toUrl"], "fileName": "org.gradle.plugins.ide.idea.model.PathFactory"}, {"methodBody": ["METHOD_START", "{", "modulePaths . add ( pathFactory . relativePath (  \" PROJECT _ DIR \"  ,    moduleFile )  )  ;", "}", "METHOD_END"], "methodName": ["addModulePath"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Set < File >    files    =    Sets . newLinkedHashSet (  )  ;", "for    ( Node   node    :    nodes )     {", "for    ( Node   root    :    XmlPersistableConfigurationOb . getChildren ( node ,     \" root \"  )  )     {", "String   url    =     (  ( String )     ( root . attribute (  \" url \"  )  )  )  ;", "files . add ( new   File ( url )  )  ;", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["collectRootUrlAsFiles"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isNullOrEmpty ( jdkName )  )  )     {", "jdk    =    new   Jdk ( jdkName ,    languageLevel )  ;", "}", "this . bytecodeVersion    =    bytecodeVersion ;", "this . modules    =    modules ;", "for    ( IdeaModule   module    :    modules )     {", "addModulePath ( module . getOutputFile (  )  )  ;", "}", "this . wildcards . addAll ( wildcards )  ;", "this . pLibraries    =    Sets . newLinkedHashSet ( pLibraries )  ;", "this . vcs    =    vcs ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" CompilerConfiguration \"  )  ;", "}", "METHOD_END"], "methodName": ["findCompilerConfiguration"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   compilerConfiguration    =    findCompilerConfiguration (  )  ;", "if    ( compilerConfiguration    =  =    null )     {", "Map < String ,    Ob >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" name \"  ,     \" CompilerConfiguration \"  )  ;", "compilerConfiguration    =    getXml (  )  . appendNode (  \" component \"  ,    attributes )  ;", "}", "return   XmlPersistableConfigurationOb . findOrCreateFirstChildNamed ( compilerConfiguration ,     \" bytecodeTargetLevel \"  )  ;", "}", "METHOD_END"], "methodName": ["findOrCreateBytecodeLevelConfiguration"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   libraryTable    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" libraryTable \"  )  ;", "if    ( libraryTable    =  =    null )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" name \"  ,     \" libraryTable \"  )  ;", "libraryTable    =    getXml (  )  . appendNode (  \" component \"  ,    attributes )  ;", "}", "return   libraryTable ;", "}", "METHOD_END"], "methodName": ["findOrCreateLibraryTable"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   moduleManager    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" ProjectModuleManager \"  )  ;", "Preconditions . checkNotNull ( moduleManager )  ;", "Node   modules    =    XmlPersistableConfigurationObject . findFirstChildNamed ( moduleManager ,     \" modules \"  )  ;", "if    ( modules    =  =    null )     {", "modules    =    moduleManager . appendNode (  \" modules \"  )  ;", "}", "return   modules ;", "}", "METHOD_END"], "methodName": ["findOrCreateModules"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" ProjectRootManager \"  )  ;", "}", "METHOD_END"], "methodName": ["findProjectRootManager"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   vcsDirMappings    =    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( getXml (  )  ,     \" component \"  )  ,     \" name \"  ,     \" VcsDirectoryMappings \"  )  ;", "return   XmlPersistableConfigurationObject . findFirstChildNamed ( vcsDirMappings ,     \" mapping \"  )  ;", "}", "METHOD_END"], "methodName": ["findVcsDirectoryMappings"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   jdk ;", "}", "METHOD_END"], "methodName": ["getJdk"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   modulePaths ;", "}", "METHOD_END"], "methodName": ["getModulePaths"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   projectLibraries ;", "}", "METHOD_END"], "methodName": ["getProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   vcs ;", "}", "METHOD_END"], "methodName": ["getVcs"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "return   wildcards ;", "}", "METHOD_END"], "methodName": ["getWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   projectRoot    =    findProjectRootManager (  )  ;", "boolean   assertKeyword    =    Boolean . parseBoolean (  (  ( String )     ( projectRoot . attribute (  \" assert - keyword \"  )  )  )  )  ;", "boolean   jdk 1  5     =    Boolean . parseBoolean (  (  ( String )     ( projectRoot . attribute (  \" jdk -  1  5  \"  )  )  )  )  ;", "String   languageLevel    =     (  ( String )     ( projectRoot . attribute (  \" languageLevel \"  )  )  )  ;", "String   jdkName    =     (  ( String )     ( projectRoot . attribute (  \" project - jdk - name \"  )  )  )  ;", "jdk    =    new   Jdk ( assertKeyword ,    jdk 1  5  ,    languageLevel ,    jdkName )  ;", "}", "METHOD_END"], "methodName": ["loadJdk"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "for    ( Node   moduleNode    :    XmlPersistableConfigurationObject . getChildren ( findOrCreateModules (  )  ,     \" module \"  )  )     {", "String   fileurl    =     (  ( String )     ( moduleNode . attribute (  \" fileurl \"  )  )  )  ;", "String   filepath    =     (  ( String )     ( moduleNode . attribute (  \" filepath \"  )  )  )  ;", "modulePaths . add ( pathFactory . path ( fileurl ,    filepath )  )  ;", "}", "}", "METHOD_END"], "methodName": ["loadModulePaths"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   libraryTable    =    findOrCreateLibraryTable (  )  ;", "for    ( Node   library    :    XmlPersistableConfigurationObject . getChildren ( libraryTable ,     \" library \"  )  )     {", "Library   projectLibrary    =    new   Library (  )  ;", "projectLibrary . setName (  (  ( String )     ( library . attribute (  \" name \"  )  )  )  )  ;", "projectLibrary . setClasses ( collectRootUrlAsFiles ( XmlPersistableConfigurationObject . getChildren ( library ,     \" CLASSES \"  )  )  )  ;", "projectLibrary . setJavadoc ( collectRootUrlAsFiles ( XmlPersistableConfigurationObject . getChildren ( library ,     \" JAVADOC \"  )  )  )  ;", "projectLibrary . setSources ( collectRootUrlAsFiles ( XmlPersistableConfigurationObject . getChildren ( library ,     \" SOURCES \"  )  )  )  ;", "projectLibraries . add ( projectLibrary )  ;", "}", "}", "METHOD_END"], "methodName": ["loadProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "List < Node >    wildcardsNodes    =    XmlPersistableConfigurationObject . getChildren ( findCompilerConfiguration (  )  ,     \" wildcardResourcePatterns \"  )  ;", "for    ( Node   wildcardsNode    :    wildcardsNodes )     {", "for    ( Node   entry    :    XmlPersistableConfigurationObject . getChildren ( wildcardsNode ,     \" entry \"  )  )     {", "this . wildcards . add (  (  ( String )     ( entry . attribute (  \" name \"  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["loadWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . jdk    =    jdk ;", "}", "METHOD_END"], "methodName": ["setJdk"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . modulePaths    =    modulePaths ;", "}", "METHOD_END"], "methodName": ["setModulePaths"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . projectLibraries    =    projectLibraries ;", "}", "METHOD_END"], "methodName": ["setProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . vcs    =    vcs ;", "}", "METHOD_END"], "methodName": ["setVcs"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "this . wildcards    =    wildcards ;", "}", "METHOD_END"], "methodName": ["setWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   bytecodeLevelConfiguration    =    findOrCreateBytecodeLevelConfiguration (  )  ;", "bytecodeLevelConfiguration . attributes (  )  . put (  \" target \"  ,    bytecodeVersion . toString (  )  )  ;", "for    ( IdeaModule   module    :    modules )     {", "List < Node >    bytecodeLevelModules    =    XmlPersistableConfigurationOb . getChildren ( bytecodeLevelConfiguration ,     \" module \"  )  ;", "Node   moduleNode    =    XmlPersistableConfigurationOb . findFirstWithAttributeValue ( bytecodeLevelModules ,     \" name \"  ,    module . getName (  )  )  ;", "JavaVersion   moduleBytecodeVersionOverwrite    =    module . getTargetBytecodeVersion (  )  ;", "if    ( moduleBytecodeVersionOverwrite    =  =    null )     {", "if    ( moduleNode    !  =    null )     {", "bytecodeLevelConfiguration . remove ( moduleNode )  ;", "}", "} else    {", "if    ( moduleNode    =  =    null )     {", "moduleNode    =    bytecodeLevelConfiguration . appendNode (  \" module \"  )  ;", "moduleNode . attributes (  )  . put (  \" name \"  ,    module . getName (  )  )  ;", "}", "moduleNode . attributes (  )  . put (  \" target \"  ,    moduleBytecodeVersionOverwrite . toString (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["storeBytecodeLevels"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   projectRoot    =    findProjectRootManager (  )  ;", "projectRoot . attributes (  )  . put (  \" assert - keyword \"  ,    jdk . isAssertKeyword (  )  )  ;", "projectRoot . attributes (  )  . put (  \" assert - jdk -  1  5  \"  ,    jdk . isJdk 1  5  (  )  )  ;", "projectRoot . attributes (  )  . put (  \" languageLevel \"  ,    jdk . getLanguageLevel (  )  )  ;", "projectRoot . attributes (  )  . put (  \" project - jdk - name \"  ,    jdk . getProjectJdkName (  )  )  ;", "}", "METHOD_END"], "methodName": ["storeJdk"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   modulesNode    =    new   Node ( null ,     \" modules \"  )  ;", "for    ( Path   modulePath    :    modulePaths )     {", "Map < String ,    Ob >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" fileurl \"  ,    modulePath . getUrl (  )  )  ;", "attributes . put (  \" filepath \"  ,    modulePath . getRelPath (  )  )  ;", "modulesNode . appendNode (  \" module \"  ,    attributes )  ;", "}", "findOrCreateModules (  )  . replaceNode ( modulesNode )  ;", "}", "METHOD_END"], "methodName": ["storeModulePaths"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   libraryTable    =    findOrCreateLibraryTable (  )  ;", "if    ( projectLibraries . isEmpty (  )  )     {", "getXml (  )  . remove ( libraryTable )  ;", "return ;", "}", "libraryTable . setValue ( new   NodeList (  )  )  ;", "for    ( Library   library    :    projectLibraries )     {", "library . addToNode ( libraryTable ,    pathFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["storeProjectLibraries"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isNullOrEmpty ( vcs )  )  )     {", "findVcsDiroryMappings (  )  . attributes (  )  . put (  \" vcs \"  ,    vcs )  ;", "}", "}", "METHOD_END"], "methodName": ["storeVcs"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Node   compilerConfigNode    =    findCompilerConfiguration (  )  ;", "Node   existingNode    =    XmlPersistableConfigurationOb . findOrCreateFirstChildNamed ( compilerConfigNode ,     \" wildcardResourcePatterns \"  )  ;", "Node   wildcardsNode    =    new   Node ( null ,     \" wildcardResourcePatterns \"  )  ;", "for    ( String   wildcard    :    wildcards )     {", "Map < String ,    Ob >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" name \"  ,    wildcard )  ;", "wildcardsNode . appendNode (  \" entry \"  ,    attributes )  ;", "}", "existingNode . replaceNode ( wildcardsNode )  ;", "}", "METHOD_END"], "methodName": ["storeWildcards"], "fileName": "org.gradle.plugins.ide.idea.model.Project"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    libraryAttributes    =    Maps . newLinkedHashMap (  )  ;", "libraryAttributes . put (  \" name \"  ,    name )  ;", "if    (  ( type )     !  =    null )     {", "libraryAttributes . put (  \" type \"  ,    type )  ;", "}", "Node   libraryNode    =    parentNode . appendNode (  \" library \"  ,    libraryAttributes )  ;", "Node   classesNode    =    libraryNode . appendNode (  \" CLASSES \"  )  ;", "for    ( File   file    :    classes )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    pathFactory . path ( file )  . getUrl (  )  )  ;", "classesNode . appendNode (  \" root \"  ,    attributes )  ;", "}", "Node   javadocNode    =    libraryNode . appendNode (  \" JAVADOC \"  )  ;", "for    ( File   file    :    javadoc )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    pathFactory . path ( file )  . getUrl (  )  )  ;", "appendNode (  \" root \"  ,    attributes )  ;", "}", "Node   sourcesNode    =    libraryNode . appendNode (  \" SOURCES \"  )  ;", "for    ( File   file    :    sources )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    pathFactory . path ( file )  . getUrl (  )  )  ;", "sourcesNode . appendNode (  \" root \"  ,    attributes )  ;", "}", "if    (  ( compilerClasspath . size (  )  )     >     0  )     {", "Node   properties    =    libraryNode . appendNode (  \" properties \"  )  ;", "Node   compilerClasspathNode    =    properties . appendNode (  \" compiler - classpath \"  )  ;", "for    ( File   file    :    compilerClasspath )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put (  \" url \"  ,    pathFactory . path ( file ,    true )  . getUrl (  )  )  ;", "compilerClasspathNode . appendNode (  \" root \"  ,    attributes )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addToNode"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   classes ;", "}", "METHOD_END"], "methodName": ["getClasses"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   compilerClasspath ;", "}", "METHOD_END"], "methodName": ["getCompilerClasspath"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   javadoc ;", "}", "METHOD_END"], "methodName": ["getJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   sources ;", "}", "METHOD_END"], "methodName": ["getSources"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . classes    =    classes ;", "}", "METHOD_END"], "methodName": ["setClasses"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . compilerClasspath    =    compilerClasspath ;", "}", "METHOD_END"], "methodName": ["setCompilerClasspath"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . javadoc    =    javadoc ;", "}", "METHOD_END"], "methodName": ["setJavadoc"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . sources    =    sources ;", "}", "METHOD_END"], "methodName": ["setSources"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.plugins.ide.idea.model.ProjectLibrary"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getJavadoc (  )  . size (  )  )     >     0  )     {", "return    (  ( FilePath )     ( this . getJavadoc (  )  . iterator (  )  . next (  )  )  )  . getFile (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getJavadocFile"], "fileName": "org.gradle.plugins.ide.idea.model.SingleEntryModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return    (  ( FilePath )     ( this . getClasses (  )  . iterator (  )  . next (  )  )  )  . getFile (  )  ;", "}", "METHOD_END"], "methodName": ["getLibraryFile"], "fileName": "org.gradle.plugins.ide.idea.model.SingleEntryModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   moduleVersion ;", "}", "METHOD_END"], "methodName": ["getModuleVersion"], "fileName": "org.gradle.plugins.ide.idea.model.SingleEntryModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getSources (  )  . size (  )  )     >     0  )     {", "return    (  ( FilePath )     ( this . getSources (  )  . iterat (  )  . next (  )  )  )  . getFile (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getSourceFile"], "fileName": "org.gradle.plugins.ide.idea.model.SingleEntryModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "this . moduleVersion    =    moduleVersion ;", "}", "METHOD_END"], "methodName": ["setModuleVersion"], "fileName": "org.gradle.plugins.ide.idea.model.SingleEntryModuleLibrary"}, {"methodBody": ["METHOD_START", "{", "return   scope    =  =    null    ?    GeneratedIdeaScope . COMPILE    :    GeneratedIdeaScope . valueOf ( scope )  ;", "}", "METHOD_END"], "methodName": ["nullSafeValueOf"], "fileName": "org.gradle.plugins.ide.idea.model.internal.GeneratedIdeaScope"}, {"methodBody": ["METHOD_START", "{", "Dependency   dep    =    iterator . next (  )  ;", "Object   key    =    getKey ( dep )  ;", "Collection < GeneratedIdeaScope >    ideaScopes    =    scopesByDependencyKey . get ( key )  ;", "if    ( ideaScopes . isEmpty (  )  )     {", "iterator . remove (  )  ;", "} else    {", "GeneratedIdeaScope   scope    =    ideaScopes . iterator (  )  . next (  )  ;", "dep . setScope ( scope . name (  )  )  ;", "scopesByDependencyKey . remove ( key ,    scope )  ;", "}", "}", "METHOD_END"], "methodName": ["applyScopeToNextDependency"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "for    ( Iterator < Dependency >    iterator    =    deps . iterator (  )  ;    iterator . hasNext (  )  ;  )     {", "applyScopeToNextDependency ( iterator ,    scopesByDependencyKey )  ;", "}", "}", "METHOD_END"], "methodName": ["applyScopesToDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "Multimap < Object ,    GeneratedIdeaScope >    scopesByDependencyKey    =    MultimapBuilder . hashKeys (  )  . enumSetValues ( GeneratedIdeaScope . class )  . build (  )  ;", "for    ( Dependency   dep    :    deps )     {", "scopesByDependencyKey . put ( getKey ( dep )  ,    GeneratedIdeaScope . nullSafeValueOf ( dep . getScope (  )  )  )  ;", "}", "return   scopesByDependencyKey ;", "}", "METHOD_END"], "methodName": ["collectScopesByDependency"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "if    ( dep   instanceof   ModuleDependency )     {", "return    (  ( ModuleDependency )     ( dep )  )  . getName (  )  ;", "} else", "if    ( dep   instanceof   SingleEntryModuleLibrary )     {", "return    (  ( SingleEntryModuleLibrary )     ( dep )  )  . getLibraryFile (  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Unsupported   type :     \"     +     ( dep . getClass (  )  . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "Multimap < Object ,    GeneratedIdeaScope >    scopesByDependencyKey    =    collectScopesByDependency ( deps )  ;", "optimizeScopes ( scopesByDependencyKey )  ;", "applyScopesTo ( deps ,    scopesByDependencyKey )  ;", "}", "METHOD_END"], "methodName": ["optimizeDeps"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < Object ,    Collection < GeneratedIdeaScope >  >    entry    :    scopesByDependencyKey . asMap (  )  . entrySet (  )  )     {", "optimizeScopes ( entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["optimizeScopes"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "boolean   isRuntime    =    ideaScopes . contains ( GeneratedIdeaScope . RUNTIME )  ;", "boolean   isProvided    =    ideaScopes . contains ( GeneratedIdeaScope . PROVIDED )  ;", "boolean   isCompile    =    ideaScopes . contains ( GeneratedIdeaScope . COMPILE )  ;", "if    ( isProvided )     {", "ideaScopes . remove ( GeneratedIdeaScope . TEST )  ;", "}", "if    ( isRuntime    &  &    isProvided )     {", "ideaScopes . add ( GeneratedIdeaScope . COMPILE )  ;", "isCompile    =    true ;", "}", "if    ( isCompile )     {", "ideaScopes . remove ( GeneratedIdeaScope . TEST )  ;", "ideaScopes . remove ( GeneratedIdeaScope . RUNTIME )  ;", "ideaScopes . remove ( GeneratedIdeaScope . PROVIDED )  ;", "}", "}", "METHOD_END"], "methodName": ["optimizeScopes"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesOptimizer"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Collection < Configuration >  >    plusMinusConfigurations    =    getPlusMinusConfigurations ( ideaModule ,    scope )  ;", "return   plusMinusConfigurations . containsKey ( plusMinus )     ?    plusMinusConfigurations . get ( plusMinus )     :    Collections .  < Configuration > emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigurations"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "Set < Dependency >    dependencies    =    Sets . newLinkedHashSet (  )  ;", "Map < ComponentSelector ,    UnresolvedDependencyResult >    unresolvedDependencies    =    Maps . newLinkedHashMap (  )  ;", "for    ( GeneratedIdeaScope   scope    :    GeneratedIdeaScope . values (  )  )     {", ". IdeaDependenciesVisitor   visitor    =    visitDependencies ( ideaModule ,    scope )  ;", "dependencies . addAll ( visitor . getDependencies (  )  )  ;", "unresolvedDependencies . putAll ( visitor . getUnresolvedDependencies (  )  )  ;", "}", "optimizer . optimizeDeps ( dependencies )  ;", "new   UnresolvedIdeDependencyHandler (  )  . log ( unresolvedDependencies . values (  )  )  ;", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "return   getConfigurations ( ideaModule ,    scope ,    IdeaDependenciesProvider . SCOPE _ MINUS )  ;", "}", "METHOD_END"], "methodName": ["getMinusConfigurations"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ideaModule . getSingleEntryLibraries (  )  )     =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "Set < SingleEntryModuleLibrary >    outputLocations    =    Sets . newLinkedHashSet (  )  ;", "for    ( Map . Entry < String ,    Iterable < File >  >    outputLocation    :    ideaModule . getSingleEntryLibraries (  )  . entrySet (  )  )     {", "String   scope    =    outputLocation . getKey (  )  ;", "for    ( File   file    :    outputLocation . getValue (  )  )     {", "if    (  ( file    !  =    null )     &  &     ( file . isDirectory (  )  )  )     {", "outputLocations . add ( new   SingleEntryModuleLibrary ( toPath ( ideaModule ,    file )  ,    scope )  )  ;", "}", "}", "}", "return   outputLocations ;", "}", "METHOD_END"], "methodName": ["getOutputLocations"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "return   getConfigurations ( ideaModule ,    scope ,    IdeaDependenciesProvider . SCOPE _ PLUS )  ;", "}", "METHOD_END"], "methodName": ["getPlusConfigurations"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Collection < Configuration >  >    plusMinusConfigurations    =    ideaModule . getScopes (  )  . get ( scope . name (  )  )  ;", "return   plusMinusConfigurations    !  =    null    ?    plusMinusConfigurations    :    Collections .  < String ,    Collection < Configuration >  > emptyMap (  )  ;", "}", "METHOD_END"], "methodName": ["getPlusMinusConfigurations"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "Set < Dependency >    result    =    Sets . newLinkedHashSet (  )  ;", "result . addAll ( getOutputLocations ( ideaModule )  )  ;", "result . addAll ( get ( ideaModule )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["provide"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "return   file    !  =    null    ?    ideaModule . getPathFactory (  )  . path ( file )     :    null ;", "}", "METHOD_END"], "methodName": ["toPath"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "DependencyHandler   handler    =    ideaModule . getProject (  )  . getDependencies (  )  ;", "Collection < Configuration >    plusConfigurations    =    getPlusConfigurations ( ideaModule ,    scope )  ;", "Collection < Configuration >    minusConfigurations    =    getMinusConfigurations ( ideaModule ,    scope )  ;", ". IdeaDependenciesVisitor   visitor    =    new    . IdeaDependenciesVisitor ( ideaModule ,    scope . name (  )  )  ;", "new   IdeDependencySet ( handler ,    plusConfigurations ,    minusConfigurations )  . visit ( visitor )  ;", "return   visitor ;", "}", "METHOD_END"], "methodName": ["visitDependencies"], "fileName": "org.gradle.plugins.ide.idea.model.internal.IdeaDependenciesProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   ModuleDependency ( determineProjectName ( id )  ,    scope )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.plugins.ide.idea.model.internal.ModuleDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "IdeaModuleMetadata   moduleMetadata    =    ideArtifactRegistry . getIdeArtifactMetadata ( IdeaModuleMetadata . class ,    id )  ;", "return   moduleMetadata    =  =    null    ?    id . getProjectName (  )     :    moduleMetadata . getName (  )  ;", "}", "METHOD_END"], "methodName": ["determineProjectName"], "fileName": "org.gradle.plugins.ide.idea.model.internal.ModuleDependencyBuilder"}, {"methodBody": ["METHOD_START", "{", "return   metadata . get ( project )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.plugins.ide.internal.IdeArtifactStore"}, {"methodBody": ["METHOD_START", "{", "metadata . put ( projectId ,    ideProjectMetadata )  ;", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.gradle.plugins.ide.internal.IdeArtifactStore"}, {"methodBody": ["METHOD_START", "{", "addWorker ( worker ,    true )  ;", "}", "METHOD_END"], "methodName": ["addWorker"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "lifecycleTask . dependsOn ( worker )  ;", "Delete   cleanWorker    =    project . getTasks (  )  . create ( cleanName ( worker . getName (  )  )  ,    Delete . class )  ;", "cleanWorker . delete ( worker . getOutputs (  )  . getFiles (  )  )  ;", "if    ( includeInClean )     {", "cleanTask . dependsOn ( cleanWorker )  ;", "}", "}", "METHOD_END"], "methodName": ["addWorker"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "lifecycleTask . doLast ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "System . out . println ( String . format (  \" Generated    % s   at    % s \"  ,    workspace . getDisplayName (  )  ,    new   ConsoleRenderer (  )  . asClickableFileUrl ( workspace . getLocation (  )  . get (  )  . getAsFile (  )  )  )  )  ;", "}", "}  )  ;", "Task   openTask    =    project . getTasks (  )  . create (  (  \" open \"     +     ( StringUtils . capitalize ( getLifecycleTaskName (  )  )  )  )  )  ;", "openTask . dependsOn ( lifecycleTask )  ;", "openTask . setGroup (  \" IDE \"  )  ;", "openTask . setDescription (  (  \" Opens   the    \"     +     ( workspace . getDisplayName (  )  )  )  )  ;", "openTask . doLast ( new   Action < Task >  (  )     {", "@ Override", "public   void   execute ( Task   task )     {", "if    ( OperatingSystem . current (  )  . isMacOsX (  )  )     {", "project . exec ( new   Action < ExecSpec >  (  )     {", "@ Override", "public   void   execute ( ExecSpec   execSpec )     {", "execSpec . commandLine (  \" open \"  ,    workspace . getLocation (  )  . get (  )  )  ;", "}", "}  )  ;", "} else    {", "try    {", "Desktop . getDesktop (  )  . open ( workspace . getLocation (  )  . get (  )  . getAsFile (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addWorkspace"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" clean % s \"  ,    StringUtils . capitalize ( taskName )  )  ;", "}", "METHOD_END"], "methodName": ["cleanName"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "return   cleanTask ;", "}", "METHOD_END"], "methodName": ["getCleanTask"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "return   lifecycleTask ;", "}", "METHOD_END"], "methodName": ["getLifecycleTask"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "return    ( project . getParent (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isRoot"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "Gradle    =    project . getGradle (  )  ;", "Optional < String >    rapperPath    =    Optional . absent (  )  ;", "Project   rootProject    =    project . getRootProject (  )  ;", "String   Extension    =     ( OperatingSystem . current (  )  . isWindows (  )  )     ?     \"  . bat \"     :     \"  \"  ;", "File   File    =    rootProject . file (  (  \"  \"     +    Extension )  )  ;", "if    ( File . exists (  )  )     {", "rapperPath    =    Optional . of ( File . getAbsolutePath (  )  )  ;", "}", "if    (  ( getGradleHomeDir (  )  )     !  =    null )     {", "if    (  ( rapperPath . isPresent (  )  )     &  &     ( getGradleHomeDir (  )  . getAbsolutePath (  )  . startsWith ( getGradleUserHomeDir (  )  . getAbsolutePath (  )  )  )  )     {", "return   rapperPath . get (  )  ;", "}", "return    ( getGradleHomeDir (  )  . getAbsolutePath (  )  )     +     \"  / bin /  ;", "}", "return   rapperPath . or (  \"  )  ;", "}", "METHOD_END"], "methodName": ["toGradleCommand"], "fileName": "org.gradle.plugins.ide.internal.IdePlugin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( deduplicated )     =  =    null )     {", "HierarchicalElementDeduplicator < Path >    deduplicator    =    new   HierarchicalElementDeduplicator < Path >  ( new    . ProjectPathDeduplicationAdapter (  )  )  ;", "this . deduplicated    =    deduplicator . deduplicate ( projectRegistry . getAllProjectPaths (  )  )  ;", "}", "return   deduplicated ;", "}", "METHOD_END"], "methodName": ["getDeduplicatedNames"], "fileName": "org.gradle.plugins.ide.internal.configurer.DefaultUniqueProjectNameProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   StatefulDeduplicator ( elements )  . getNewNames (  )  ;", "}", "METHOD_END"], "methodName": ["deduplicate"], "fileName": "org.gradle.plugins.ide.internal.configurer.HierarchicalElementDeduplicator"}, {"methodBody": ["METHOD_START", "{", "transformAction ( configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["transformAction"], "fileName": "org.gradle.plugins.ide.internal.generator.PropertiesPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "transformer . addAction ( action )  ;", "}", "METHOD_END"], "methodName": ["transformAction"], "fileName": "org.gradle.plugins.ide.internal.generator.PropertiesPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "return   root    =  =    null    ?    null    :    Iterables . getFirst ( XmlPersistableConfigurationObject . getChildren ( root ,    name )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findFirstChildNamed"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "return   root    =  =    null    ?    null    :    XmlPersistableConfigurationObject . findFirstWithAttributeValue ( XmlPersistableConfigurationObject . getChildren ( root ,    childName )  ,    attribute ,    value )  ;", "}", "METHOD_END"], "methodName": ["findFirstChildWithAttributeValue"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "return   nodes    =  =    null    ?    null    :    Iterables . getFirst ( Iterables . filter ( nodes ,    new   com . google . common . base . Predicate < Node >  (  )     {", "@ Override", "public   boolean   apply ( Node   node )     {", "return   value . equals ( node . attribute ( attribute )  )  ;", "}", "}  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["findFirstWithAttributeValue"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "Node   child    =    XmlPersistableConfigurationObject . findFirstChildNamed ( root ,    name )  ;", "if    ( child    =  =    null )     {", "child    =    root . appendNode ( name )  ;", "}", "return   child ;", "}", "METHOD_END"], "methodName": ["findOrCreateFirstChildNamed"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "Node   child    =    XmlPersistableConfigurationObject . findFirstChildWithAttributeValue ( root ,    childName ,    attribute ,    value )  ;", "if    ( child    =  =    null )     {", "Map < String ,    Object >    attributes    =    Maps . newLinkedHashMap (  )  ;", "attributes . put ( attribute ,    value )  ;", "child    =    root . appendNode ( childName ,    attributes )  ;", "}", "return   child ;", "}", "METHOD_END"], "methodName": ["findOrCreateFirstChildWithAttributeValue"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "return   root    =  =    null    ?    Collections .  < Node > emptyList (  )     :    Cast .  < List < Node >  > uncheckedCast ( root . get ( name )  )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "return   xml ;", "}", "METHOD_END"], "methodName": ["getXml"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "transformAction ( configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["transformAction"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "xmlTransformer . addAction ( action )  ;", "}", "METHOD_END"], "methodName": ["transformAction"], "fileName": "org.gradle.plugins.ide.internal.generator.XmlPersistableConfigurationObject"}, {"methodBody": ["METHOD_START", "{", "Set < ResolvedArtifactResult >    artifacts    =    configuration . getIncoming (  )  . artifactView ( new   Action < ArtifactView . ViewConfiguration >  (  )     {", "@ Override", "public   void   execute ( ArtifactView . ViewConfiguration   viewConfiguration )     {", "viewConfiguration . lenient ( true )  ;", "viewConfiguration . componentFilter (  . IS _ A _ MODULE _ ID )  ;", "}", "}  )  . getArtifacts (  )  . getArtifacts (  )  ;", "List < IdeExtendedRepoFileDependency >    externalDependencies    =    new   ArrayList < IdeExtendedRepoFileDependency >  ( artifacts . size (  )  )  ;", "for    ( ResolvedArtifactResult   artifact    :    artifacts )     {", "ModuleComponentIdentifier   moduleId    =     (  ( ModuleComponentIdentifier )     ( artifact . getId (  )  . getComponentIdentifier (  )  )  )  ;", "IdeExtendedRepoFileDependency   ideRepoFileDependency    =    new   IdeExtendedRepoFileDependency (  )  ;", "ideRepoFileDependency . setId ( new   DefaultModuleVersionIdentifier ( moduleId . getGroup (  )  ,    moduleId . getModule (  )  ,    moduleId . getVersion (  )  )  )  ;", "externalDependencies . add ( ideRepoFileDependency )  ;", "}", "return   externalDependencies ;", "}", "METHOD_END"], "methodName": ["getIdeRepoFileDependencies"], "fileName": "org.gradle.plugins.ide.internal.resolver.DefaultIdeDependencyResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( plusConfigurations . isEmpty (  )  )     {", "return ;", "}", "new    . IdeDependencyResult (  )  . visit ( visitor )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.plugins.ide.internal.resolver.IdeDependencySet"}, {"methodBody": ["METHOD_START", "{", "return   new   File (  (  \" unresolved   dependency    -     \"     +     ( dep . getAttempted (  )  . getDisplayName (  )  . replaceAll (  \"  :  \"  ,     \"     \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asFile"], "fileName": "org.gradle.plugins.ide.internal.resolver.UnresolvedIdeDependencyHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( UnresolvedDependencyResult   dep    :    deps )     {", "log ( dep )  ;", "}", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.gradle.plugins.ide.internal.resolver.UnresolvedIdeDependencyHandler"}, {"methodBody": ["METHOD_START", "{", "logger . warn (  (  \" Could   not   resolve :     \"     +     ( dep . getAttempted (  )  )  )  )  ;", "logger . debug (  (  \" Could   not   resolve :     \"     +     ( dep . getAttempted (  )  )  )  ,    dep . getFailure (  )  )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.gradle.plugins.ide.internal.resolver.UnresolvedIdeDependencyHandler"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.plugins.ide.internal.resolver.model.IdeExtendedRepoFileDependency"}, {"methodBody": ["METHOD_START", "{", "this . id    =    id ;", "}", "METHOD_END"], "methodName": ["setId"], "fileName": "org.gradle.plugins.ide.internal.resolver.model.IdeExtendedRepoFileDependency"}, {"methodBody": ["METHOD_START", "{", "for    ( Project   child    :    project . getChildProjects (  )  . values (  )  )     {", "findTasks ( child ,    taskSelectors ,    visibleTasks )  ;", "}", "for    ( Task   task    :    taskLister . listProjectTasks ( project )  )     {", "if    (  !  ( taskSelectors . containsKey ( task . getName (  )  )  )  )     {", "LaunchableGTaskSelector   taskSelector    =    new   LaunchableGTaskSelector (  )  . setDescription ( task . getDescription (  )  )  . setPath ( task . getPath (  )  )  ;", "taskSelectors . put ( task . getName (  )  ,    taskSelector )  ;", "} else    {", "LaunchableGTaskSelector   taskSelector    =    taskSelectors . get ( task . getName (  )  )  ;", "if    ( hasPathWithLowerOrdering ( task ,    taskSelector )  )     {", "taskSelector . setDescription ( task . getDescription (  )  )  . setPath ( task . getPath (  )  )  ;", "}", "}", "if    ( INSTANCE . isSatisfiedBy ( task )  )     {", "visibleTasks . add ( task . getName (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["findTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.BuildInvocationsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectIdentifier ( project . getRootDir (  )  ,    project . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.BuildInvocationsBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( taskNameComparator . compare ( task . getPath (  )  ,    referenceTaskSelector . getPath (  )  )  )     <     0  ;", "}", "METHOD_END"], "methodName": ["hasPathWithLowerOrdering"], "fileName": "org.gradle.plugins.ide.internal.tooling.BuildInvocationsBuilder"}, {"methodBody": ["METHOD_START", "{", "List < LaunchableGradleTask >    tasks    =    Lists . newArrayList (  )  ;", "for    ( Task   task    :    taskLister . listProjectTasks ( project )  )     {", "tasks . add ( ToolingModelSupport . buildFromTask ( new   LaunchableGradleTask (  )  ,    task )  )  ;", "}", "return   tasks ;", "}", "METHOD_END"], "methodName": ["tasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.BuildInvocationsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( project    =  =     ( currentProject )  )     {", "result    =    eProject ;", "}", "eProjects . add ( eProject )  ;", "}", "METHOD_END"], "methodName": ["addProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Set < Project >    allProjects    =    root . getAllprojects (  )  ;", "for    ( Project   p    :    allProjects )     {", "p . getPluginManager (  )  . apply ( EclipsePlugin . class )  ;", "}", "for    ( IncludedBuild   includedBuild    :    root . getGradle (  )  . getIncludedBuilds (  )  )     {", "IncludedBuildIincludedBuildI =     (  ( IncludedBuildI    ( includedBuild )  )  ;", "applyEclipsePlugin ( includedBuildIgetConfiguredBuild (  )  . getRootProject (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyEclipsePlugin"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < DefaultEclipseProject >    children    =    new   ArrayList < DefaultEclipseProject >  (  )  ;", "for    ( Project   child    :    project . getChildProjects (  )  . values (  )  )     {", "children . add ( buildHierarchy ( child )  )  ;", "}", "eclipseModel    =    project . getExtensions (  )  . getByType (  . class )  ;", "EclipseProject   internalProject    =    eclipseModel . getProject (  )  ;", "String   name    =    internalProject . getName (  )  ;", "String   description    =    GUtil . elvis ( internalProject . getComment (  )  ,    null )  ;", "DefaultEclipseProject   eclipseProject    =    new   DefaultEclipseProject ( name ,    project . getPath (  )  ,    description ,    project . getProjectDir (  )  ,    children )  . setGradleProject ( rootGradleProject . findByPath ( project . getPath (  )  )  )  ;", "for    ( DefaultEclipseProject   child    :    children )     {", "child . setParent ( eclipseProject )  ;", "}", "addProject ( project ,    eclipseProject )  ;", "return   eclipseProject ;", "}", "METHOD_END"], "methodName": ["buildHierarchy"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   original . toString (  )  ;", "}", "METHOD_END"], "methodName": ["convertGString"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "int   kindCode ;", "String   kind    =    accessRule . getKind (  )  ;", "if    (  ( kind . equals (  \" accessible \"  )  )     |  |     ( kind . equals (  \"  0  \"  )  )  )     {", "kindCode    =     0  ;", "} else", "if    (  ( kind . equals (  \" nonaccessible \"  )  )     |  |     ( kind . equals (  \"  1  \"  )  )  )     {", "kindCode    =     1  ;", "} else", "if    (  ( kind . equals (  \" discouraged \"  )  )     |  |     ( kind . equals (  \"  2  \"  )  )  )     {", "kindCode    =     2  ;", "} else    {", "kindCode    =     0  ;", "}", "return   new   DefaultAccessRule ( kindCode ,    accessRule . getPat (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAccessRule"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < DefaultAccessRule >    result    =    Lists . newArrayList (  )  ;", "for    ( AccessRule   accessRule    :    classpathEntry . getAccessRules (  )  )     {", "result . add (  . createAccessRule ( accessRule )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["createAccessRules"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < DefaultClasspathAttribute >    result    =    Lists . newArrayList (  )  ;", "Map < String ,    Object >    attributes    =    classpathEntry . getEntryAttributes (  )  ;", "for    ( Map . Entry < String ,    Object >    entry    :    attributes . entrySet (  )  )     {", "Object   value    =    entry . getValue (  )  ;", "result . add ( new   DefaultClasspathAttribute (  . convertGString ( entry . getKey (  )  )  ,     ( value    =  =    null    ?     \"  \"     :    value . toString (  )  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["createAttributes"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . findFirst ( eclipseProjects ,    new   Spec < DefaultEclipseProject >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DefaultEclipseProject   element )     {", "return   element . getGradleProject (  )  . getPath (  )  . equals ( project . getPath (  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findEclipseProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . findFirst ( eclipseProjects ,    new   Spec < DefaultEclipseProject >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( DefaultEclipseProject   element )     {", "return   element . getName (  )  . equals ( eclipseProjectName )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findEclipseProjectByName"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "EclipseModel   eclipseModel    =    project . getExtensions (  )  . getByType ( EclipseModel . class )  ;", "EclipseClasspath   eclipseClasspath    =    eclipseModel . getClasspath (  )  ;", "eclipseClasspath . setProjectDependenciesOnly ( projectDependenciesOnly )  ;", "List < ClasspathEntry >    classpathEntries ;", "if    (  ( eclipseClasspath . getFile (  )  )     =  =    null )     {", "classpathEntries    =    eclipseClasspath . resolveDependencies (  )  ;", "} else    {", "Classpath   classpath    =    new   Classpath ( eclipseClasspath . getFileReferenceFactory (  )  )  ;", "eclipseClasspath . mergeXmlClasspath ( classpath )  ;", "classpathEntries    =    classpath . getEntries (  )  ;", "}", "final   List < DefaultEclipseExternalDependency >    externalDependencies    =    new   LinkedList < DefaultEclipseExternalDependency >  (  )  ;", "final   List < DefaultEclipseProjectDependency >    projectDependencies    =    new   LinkedList < DefaultEclipseProjectDependency >  (  )  ;", "final   List < DefaultEclipseSourceDirectory >    sourceDirectories    =    new   LinkedList < DefaultEclipseSourceDirectory >  (  )  ;", "final   List < DefaultEclipseClasspathContainer >    classpathContainers    =    new   LinkedList < DefaultEclipseClasspathContainer >  (  )  ;", "DefaultEclipseOutputLocation   outputLocation    =    null ;", "for    ( ClasspathEntry   entry    :    classpathEntries )     {", "if    ( entry   instanceof   Library )     {", "AbstractLibrary   library    =     (  ( AbstractLibrary )     ( entry )  )  ;", "final   File   file    =    library . getLibrary (  )  . getFile (  )  ;", "final   File   source    =     (  ( library . getSourcePath (  )  )     =  =    null )     ?    null    :    library . getSourcePath (  )  . getFile (  )  ;", "final   File   javadoc    =     (  ( library . getJavadocPath (  )  )     =  =    null )     ?    null    :    library . getJavadocPath (  )  . getFile (  )  ;", "DefaultEclipseExternalDependency   dependency    =    new   DefaultEclipseExternalDependency ( file ,    javadoc ,    source ,    library . getModuleVersion (  )  ,    library . isExported (  )  ,    EclipseModelBuilder . createAttributes ( library )  ,    EclipseModelBuilder . createAccessRules ( library )  )  ;", "externalDependencies . add ( dependency )  ;", "} else", "if    ( entry   instanceof   eclipse . model . ProjectDependency )     {", "final   eclipse . model . ProjectDependency   projectDependency    =     (  ( eclipse . model . ProjectDependency )     ( entry )  )  ;", "final   String   path    =    removeStart ( projectDependency . getPath (  )  ,     \"  /  \"  )  ;", "DefaultEclipseProjectDependency   dependency    =    new   DefaultEclipseProjectDependency ( path ,    projectDependency . isExported (  )  ,    EclipseModelBuilder . createAttributes ( projectDependency )  ,    EclipseModelBuilder . createAccessRules ( projectDependency )  )  ;", "dependency . setTargetProject ( findEclipseProjectByName ( path )  )  ;", "projectDependencies . add ( dependency )  ;", "} else", "if    ( entry   instanceof   eclipse . model . SourceFolder )     {", "final   eclipse . model . SourceFolder   sourceFolder    =     (  ( eclipse . model . SourceFolder )     ( entry )  )  ;", "String   path    =    sourceFolder . getPath (  )  ;", "List < String >    excludes    =    sourceFolder . getExcludes (  )  ;", "List < String >    includes    =    sourceFolder . getIncludes (  )  ;", "String   output    =    sourceFolder . getOutput (  )  ;", "sourceDirectories . add ( new   DefaultEclipseSourceDirectory ( path ,    sourceFolder . getDir (  )  ,    excludes ,    includes ,    output ,    EclipseModelBuilder . createAttributes ( sourceFolder )  ,    EclipseModelBuilder . createAccessRules ( sourceFolder )  )  )  ;", "} else", "if    ( entry   instanceof   eclipse . model . Container )     {", "final   eclipse . model . Container   container    =     (  ( eclipse . model . Container )     ( entry )  )  ;", "classpathContainers . add ( new   DefaultEclipseClasspathContainer ( container . getPath (  )  ,    container . isExported (  )  ,    EclipseModelBuilder . createAttributes ( container )  ,    EclipseModelBuilder . createAccessRules ( container )  )  )  ;", "} else", "if    ( entry   instanceof   eclipse . model . Output )     {", "outputLocation    =    new   DefaultEclipseOutputLocation (  (  ( eclipse . model . Output )     ( entry )  )  . getPath (  )  )  ;", "}", "}", "DefaultEclipseProject   eclipseProject    =    findEclipseProject ( project )  ;", "eclipseProject . setClasspath ( externalDependencies )  ;", "eclipseProject . setProjectDependencies ( projectDependencies )  ;", "eclipseProject . setSourceDirectories ( sourceDirectories )  ;", "List < DefaultEclipseLinkedResource >    linkedResources    =    new   LinkedList < DefaultEclipseLinkedResource >  (  )  ;", "for    ( Link   r    :    eclipseModel . getProject (  )  . getLinkedResources (  )  )     {", "linkedResources . add ( new   DefaultEclipseLinkedResource ( r . getName (  )  ,    r . getType (  )  ,    r . getLocation (  )  ,    r . getLocationUri (  )  )  )  ;", "}", "eclipseProject . setLinkedResources ( linkedResources )  ;", "List < DefaultEclipseTask >    tasks    =    new   ArrayList < DefaultEclipseTask >  (  )  ;", "for    ( Task   t    :    tasksFactory . getTasks ( project )  )     {", "tasks . add ( new   DefaultEclipseTask ( eclipseProject ,    t . getPath (  )  ,    t . getName (  )  ,    t . getDescription (  )  )  )  ;", "}", "eclipseProject . setTasks ( tasks )  ;", "List < DefaultEclipseProjectNature >    natures    =    new   ArrayList < DefaultEclipseProjectNature >  (  )  ;", "for    ( String   n    :    eclipseModel . getProject (  )  . getNatures (  )  )     {", "natures . add ( new   DefaultEclipseProjectNature ( n )  )  ;", "}", "eclipseProject . setProjectNatures ( natures )  ;", "List < DefaultEclipseBuildCommand >    buildCommands    =    new   ArrayList < DefaultEclipseBuildCommand >  (  )  ;", "for    ( BuildCommand   b    :    eclipseModel . getProject (  )  . getBuildCommands (  )  )     {", "Map < String ,    String >    arguments    =    Maps . newLinkedHashMap (  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    b . getArguments (  )  . entrySet (  )  )     {", "arguments . put ( EclipseModelBuilder . convertGString ( entry . getKey (  )  )  ,    EclipseModelBuilder . convertGString ( entry . getValue (  )  )  )  ;", "}", "buildCommands . add ( new   DefaultEclipseBuildCommand ( b . getName (  )  ,    arguments )  )  ;", "}", "eclipseProject . setBuildCommands ( buildCommands )  ;", "EclipseJdt   jdt    =    eclipseModel . getJdt (  )  ;", "if    ( jdt    !  =    null )     {", "eclipseProject . setJavaSourceSettings ( new   DefaultEclipseJavaSourceSettings (  )  . setSourceLanguageLevel ( jdt . getSourceCompatibility (  )  )  . setTargetBytecodeVersion ( jdt . getTargetCompatibility (  )  )  . setJdk ( DefaultInstalledJdk . current (  )  )  )  ;", "}", "eclipseProject . setClasspathContainers ( classpathContainers )  ;", "eclipseProject . setOutputLocation (  ( outputLocation    !  =    null    ?    outputLocation    :    new   DefaultEclipseOutputLocation (  \" bin \"  )  )  )  ;", "for    ( Project   childProject    :    project . getChildProjects (  )  . values (  )  )     {", "populate ( childProject )  ;", "}", "}", "METHOD_END"], "methodName": ["populate"], "fileName": "org.gradle.plugins.ide.internal.tooling.EclipseModelBuilder"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectIdentifier   id    =    new   DefaultProjectIdentifier ( project . getRootDir (  )  ,    project . getPath (  )  )  ;", "BasicProject   converted    =    new   BasicProject (  )  . setName ( project . getName (  )  )  . setProjectIdentifier ( id )  ;", "converted . setProjectDirectory ( project . getProjectDir (  )  )  ;", "if    (  ( project . getParent (  )  )     !  =    null )     {", "converted . setParent ( convertedProjects . get ( project . getParent (  )  )  )  ;", "}", "convertedProjects . put ( project ,    converted )  ;", "for    ( Project   child    :    project . getChildProjects (  )  . values (  )  )     {", "converted . addChild ( convert ( child ,    convertedProjects )  )  ;", "}", "return   converted ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.plugins.ide.internal.tooling.GradleBuildBuilder"}, {"methodBody": ["METHOD_START", "{", "DefaultGradleBuild   model    =    new   DefaultGradleBuild (  )  ;", "Map < Project ,    BasicGradleProject >    convertedProjects    =    new   LinkedHashMap < Project ,    BasicGradleProject >  (  )  ;", "Project   rootProject    =    gradle . getRootProject (  )  ;", "BasicGradleProject   convertedRootProject    =    convert ( rootProject ,    convertedProjects )  ;", "model . setRootProject ( convertedRootProject )  ;", "for    ( Project   project    :    rootProject . getAllprojects (  )  )     {", "model . addProject ( convertedProjects . get ( project )  )  ;", "}", "for    ( IncludedBuild   includedBuild    :    gradle . getIncludedBuilds (  )  )     {", "Gradle   includedGradle    =     (  ( IncludedBuildInternal )     ( includedBuild )  )  . getConfiguredBuild (  )  ;", "DefaultGradleBuild   convertedIncludedBuild    =    convert ( includedGradle )  ;", "model . addIncludedBuild ( convertedIncludedBuild )  ;", "}", "return   model ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.plugins.ide.internal.tooling.GradleBuildBuilder"}, {"methodBody": ["METHOD_START", "{", "return   buildHierarchy ( project . getRootProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildAll"], "fileName": "org.gradle.plugins.ide.internal.tooling.GradleProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "List < DefaultGradleProject < LaunchableGradleTask >  >    children    =    new   ArrayList < DefaultGradleProject < LaunchableGradleTask >  >  (  )  ;", "for    ( Project   child    :    project . getChildProjects (  )  . values (  )  )     {", "children . add ( buildHierarchy ( child )  )  ;", "}", "DefaultGradleProject < LaunchableGradleTask >    gradleProject    =    new   DefaultGradleProject < LaunchableGradleTask >  (  )  . setProjectIdentifier ( new   DefaultProjectIdentifier ( project . getRootDir (  )  ,    project . getPath (  )  )  )  . setName ( project . getName (  )  )  . setDescription ( project . getDescription (  )  )  . setBuildDirectory ( project . getBuildDir (  )  )  . setProjectDirectory ( project . getProjectDir (  )  )  . setChildren ( children )  ;", "gradleProject . getBuildScript (  )  . setSourceFile ( project . getBuildFile (  )  )  ;", "gradleProject . setTasks (  . tasks ( gradleProject ,     (  ( TaskContainerInternal )     ( project . getTasks (  )  )  )  )  )  ;", "for    ( DefaultGradleProject   child    :    children )     {", "child . setParent ( gradleProject )  ;", "}", "return   gradleProject ;", "}", "METHOD_END"], "methodName": ["buildHierarchy"], "fileName": "org.gradle.plugins.ide.internal.tooling.GradleProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "tasks . realize (  )  ;", "SortedSet < String >    taskNames    =    tasks . getNames (  )  ;", "List < LaunchableGradleTask >    out    =    new   ArrayList < LaunchableGradleTask >  ( taskNames . size (  )  )  ;", "for    ( String   taskName    :    taskNames )     {", "Task   t    =    tasks . findByName ( taskName )  ;", "if    ( t    !  =    null )     {", "out . add ( ToolingModelBuilderSupport . buildFromTask ( new   LaunchableTask (  )  ,    t )  . setProject ( owner )  . setProjectIdentifier ( owner . getProjectIdentifier (  )  )  )  ;", "}", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["tasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.GradleProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "DefaultIdeaContentRoot   contentRoot    =    new   DefaultIdeaContentRoot (  )  . setRootDirectory ( ideaModule . getContentRoot (  )  )  . setSourceDirectories ( srcDirs ( ideaModule . getSourceDirs (  )  ,    ideaModule . getGeneratedSourceDirs (  )  )  )  . setTestDirectories ( srcDirs ( ideaModule . getTestSourceDirs (  )  ,    ideaModule . getGeneratedSourceDirs (  )  )  )  . setResourceDirectories ( srcDirs ( ideaModule . getResourceDirs (  )  ,    ideaModule . getGeneratedSourceDirs (  )  )  )  . setTestResourceDirectories ( srcDirs ( ideaModule . getTestResourceDirs (  )  ,    ideaModule . getGeneratedSourceDirs (  )  )  )  . setExcludeDirectories ( ideaModule . getExcludeDirs (  )  )  ;", "Project   project    =    ideaModule . getProject (  )  ;", "Defaultule   defaultule    =    new   Defaultule (  )  . setName ( ideaModule . getName (  )  )  . setParent ( ideaProject )  . setGradleProject ( rootGradleProject . findByPath ( ideaModule . getProject (  )  . getPath (  )  )  )  . setContentRoots ( Collections . singletonList ( contentRoot )  )  . setJdkName ( ideaModule . getJdkName (  )  )  . setCompilerOutput ( new   DefaultIdeaCompilerOutput (  )  . setInheritOutputDirs (  (  ( ideaModule . getInheritOutputDirs (  )  )     !  =    null    ?    ideaModule . getInheritOutputDirs (  )     :    false )  )  . setOutputDir ( ideaModule . getOutputDir (  )  )  . setTestOutputDir ( ideaModule . getTestOutputDir (  )  )  )  ;", "JavaPluginConvention   javaPluginConvention    =    project . getConvention (  )  . findPlugin ( JavaPluginConvention . class )  ;", "if    ( javaPluginConvention    !  =    null )     {", "final   IdeaLanguageLevel   ideaModuleLanguageLevel    =    ideaModule . getLanguageLevel (  )  ;", "JavaVersion   moduleSourceLanguageLevel    =    convertIdeaLanguageLevelToJavaVersion ( ideaModuleLanguageLevel )  ;", "JavaVersion   moduleTargetBytecodeVersion    =    ideaModule . getTargetBytecodeVersion (  )  ;", "defaultule . setJavaLanguageSettings ( new   DefaultIdeaJavaLanguageSettings (  )  . setSourceLanguageLevel ( moduleSourceLanguageLevel )  . setTargetBytecodeVersion ( moduleTargetBytecodeVersion )  )  ;", "}", "modules . put ( ideaModule . getName (  )  ,    defaultule )  ;", "}", "METHOD_END"], "methodName": ["appendModule"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Set < Project >    allProjects    =    root . getAllprojects (  )  ;", "for    ( Project   p    :    allProjects )     {", "p . getPluginManager (  )  . apply ( IdeaPlugin . class )  ;", "}", "for    ( IncludedBuild   includedBuild    :    root . getGradle (  )  . getIncludedBuilds (  )  )     {", "IncludedBuildIincludedBuildI =     (  ( IncludedBuildI    ( includedBuild )  )  ;", "applyIdeaPlugin ( includedBuildIgetConfiguredBuild (  )  . getRootProject (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyIdeaPlugin"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "IdeaModel   ideaModel    =    ideaPluginFor ( project )  . getModel (  )  ;", "IdeaProject   projectModel    =    ideaModel . getProject (  )  ;", "JavaVersion   projectSourceLanguageLevel    =    convertIdeaLanguageLevelToJavaVersion ( projectModel . getLanguageLevel (  )  )  ;", "JavaVersion   projectTargetBytecodeLevel    =    projectModel . getTargetBytecodeVersion (  )  ;", "DefaultIdeaProject   out    =    new   DefaultIdeaProject (  )  . setName ( projectModel . getName (  )  )  . setJdkName ( projectModel . getJdkName (  )  )  . setLanguageLevel ( new   DefaultIdeaLanguageLevel ( projectModel . getLanguageLevel (  )  . getLevel (  )  )  )  . setJavaLanguageSettings ( new   DefaultIdeaJavaLanguageSettings (  )  . setSourceLanguageLevel ( projectSourceLanguageLevel )  . setTargetBytecodeVersion ( projectTargetBytecodeLevel )  . setJdk ( DefaultInstalledJdk . current (  )  )  )  ;", "Map < String ,    DefaultIdeaModule >    modules    =    new   LinkedHashMap < String ,    DefaultIdeaModule >  (  )  ;", "for    ( IdeaModule   module    :    projectModel . getModules (  )  )     {", "appendModule ( modules ,    module ,    out ,    rootGradleProject )  ;", "}", "for    ( IdeaModule   module    :    projectModel . getModules (  )  )     {", "buildDependencies ( modules ,    module )  ;", "}", "final   Collection < DefaultIdeaModule >    ideaModules    =    modules . values (  )  ;", "out . setChildren ( new   LinkedList < DefaultIdeaModule >  ( ideaModules )  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "ideaModule . setOffline ( offlineDependencyResolution )  ;", "Set < Dependency >    resolved    =    ideaModule . resolveDependencies (  )  ;", "List < DefaultIdeaDependency >    dependencies    =    new   LinkedList < DefaultIdeaDependency >  (  )  ;", "for    ( Dependency   dependency    :    resolved )     {", "if    ( dependency   instanceof   SingleEntryModuleLibrary )     {", "SingleEntryModuleLibrary   d    =     (  ( SingleEntryModuleLibrary )     ( dependency )  )  ;", "DefaultIdeaSingleEntryLibraryDependency   defaultDependency    =    new   DefaultIdeaSingleEntryLibraryDependency (  )  . setFile ( d . getLibraryFile (  )  )  . setSource ( d . getSourceFile (  )  )  . setJavadoc ( d . getJavadocFile (  )  )  . setScope ( new   DefaultIdeaDependencyScope ( d . getScope (  )  )  )  . setExported ( d . isExported (  )  )  ;", "if    (  ( d . getModuleVersion (  )  )     !  =    null )     {", "defaultDependency . setGradleModuleVersion ( new   DefaultGradleModuleVersion ( d . getModuleVersion (  )  )  )  ;", "}", "dependencies . add ( defaultDependency )  ;", "} else", "if    ( dependency   instanceof   ModuleDependency )     {", "ModuleDependency   moduleDependency    =     (  ( ModuleDependency )     ( dependency )  )  ;", "idea . DefaultIdeaModuleDependency   ideaModuleDependency    =    new   idea . DefaultIdeaModuleDependency ( moduleDependency . getName (  )  )  . setExported ( moduleDependency . isExported (  )  )  . setScope ( new   DefaultIdeaDependencyScope ( moduleDependency . getScope (  )  )  )  ;", "DefaultIdeaModule   targetModule    =    modules . get ( moduleDependency . getName (  )  )  ;", "ideaModuleDependency . setDependencyModule ( targetModule )  ;", "dependencies . add ( ideaModuleDependency )  ;", "}", "}", "modules . get ( ideaModule . getName (  )  )  . setDependencies ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["buildDependencies"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( ideaLanguageLevel    =  =    null )     {", "return   null ;", "}", "String   languageLevel    =    ideaLanguageLevel . getLevel (  )  ;", "return   JavaVersion . valueOf ( languageLevel . replaceFirst (  \" JDK \"  ,     \" VERSION \"  )  )  ;", "}", "METHOD_END"], "methodName": ["convertIdeaLanguageLevelToJavaVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "return   project . getPlugins (  )  . getPlugin ( IdeaPlugin . class )  ;", "}", "METHOD_END"], "methodName": ["ideaPluginFor"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "this . offlineDependencyResolution    =    offlineDependencyResolution ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOfflineDependencyResolution"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "Set < DefaultIdeaSourceDirectory >    out    =    new   LinkedHashSet < DefaultIdeaSourceDirectory >  (  )  ;", "for    ( File   s    :    sourceDirs )     {", "DefaultIdeaSourceDirectory   sourceDirectory    =    new   DefaultIdeaSourceDirectory (  )  . setDirectory ( s )  ;", "if    ( generatedSourceDirs . contains ( s )  )     {", "sourceDirectory . setGenerated ( true )  ;", "}", "out . add ( sourceDirectory )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["srcDirs"], "fileName": "org.gradle.plugins.ide.internal.tooling.IdeaModelBuilder"}, {"methodBody": ["METHOD_START", "{", "List < DefaultGradlePublication >    gradlePublications    =    Lists . newArrayList (  )  ;", "Set < ProjectPublication >    projectPublications    =    publicationRegistry . getPublications ( projectIdentifier . getProjectPath (  )  )  ;", "for    ( ProjectPublication   projectPublication    :    projectPublications )     {", "ModuleVersionIdentifier   id    =    projectPublication . getCoordinates ( ModuleVersionIdentifier . class )  ;", "if    ( id    !  =    null )     {", "gradlePublications . add ( new   DefaultGradlePublication (  )  . setId ( new   DefaultGradleModuleVersion ( id )  )  . setProjectIdentifier ( projectIdentifier )  )  ;", "}", "}", "return   gradlePublications ;", "}", "METHOD_END"], "methodName": ["publications"], "fileName": "org.gradle.plugins.ide.internal.tooling.PublicationsBuilder"}, {"methodBody": ["METHOD_START", "{", "allTasks    =    root . getAllTasks ( true )  ;", "}", "METHOD_END"], "methodName": ["collectTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.TasksFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( includeTasks )     {", "return   allTasks . get ( project )  ;", "} else    {", "return   Collections . emptySet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.TasksFactory"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    task . getProject (  )  ;", "target . setPath ( task . getPath (  )  )  . setName ( task . getName (  )  )  . setGroup ( task . getGroup (  )  )  . setDisplayName ( task . toString (  )  )  . setDescription ( task . getDescription (  )  )  . setPublic ( INSTANCE . isSatisfiedBy ( task )  )  . setProjectIdentifier ( new   tooling . internal . gradle . DefaultProjectIdentifier ( project . getRootDir (  )  ,    project . getPath (  )  )  )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["buildFromTask"], "fileName": "org.gradle.plugins.ide.internal.tooling.ToolingModelBuilderSupport"}, {"methodBody": ["METHOD_START", "{", "return   kind ;", "}", "METHOD_END"], "methodName": ["getKind"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultAccessRule"}, {"methodBody": ["METHOD_START", "{", "return   pattern ;", "}", "METHOD_END"], "methodName": ["getPattern"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultAccessRule"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultClasspathAttribute"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultClasspathAttribute"}, {"methodBody": ["METHOD_START", "{", "return   arguments ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseBuildCommand"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseBuildCommand"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseClasspathContainer"}, {"methodBody": ["METHOD_START", "{", "return   isExported ;", "}", "METHOD_END"], "methodName": ["isExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseClasspathContainer"}, {"methodBody": ["METHOD_START", "{", "return   accessRules ;", "}", "METHOD_END"], "methodName": ["getAccessRules"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   classpathAttributes ;", "}", "METHOD_END"], "methodName": ["getClasspathAttributes"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseClasspathEntry"}, {"methodBody": ["METHOD_START", "{", "return   isExported ;", "}", "METHOD_END"], "methodName": ["isExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseDependency"}, {"methodBody": ["METHOD_START", "{", "return   moduleVersion ;", "}", "METHOD_END"], "methodName": ["getGradleModuleVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseExternalDependency"}, {"methodBody": ["METHOD_START", "{", "return   identifier ;", "}", "METHOD_END"], "methodName": ["getModuleVersionIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseExternalDependency"}, {"methodBody": ["METHOD_START", "{", "return   jdk ;", "}", "METHOD_END"], "methodName": ["getJdk"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "return   sourceLanguageLevel ;", "}", "METHOD_END"], "methodName": ["getSourceLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "return   targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["getTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "this . jdk    =    targetRuntime ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJdk"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "this . sourceLanguageLevel    =    sourceLanguageLevel ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSourceLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "this . targetBytecodeVersion    =    targetBytecodeLevel ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseJavaSourceSettings"}, {"methodBody": ["METHOD_START", "{", "return   location ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseLinkedResource"}, {"methodBody": ["METHOD_START", "{", "return   locationUri ;", "}", "METHOD_END"], "methodName": ["getLocationUri"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseLinkedResource"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseLinkedResource"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseLinkedResource"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseOutputLocation"}, {"methodBody": ["METHOD_START", "{", "return   buildCommands ;", "}", "METHOD_END"], "methodName": ["getBuildCommands"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   classpathContainers ;", "}", "METHOD_END"], "methodName": ["getClasspathContainers"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   gradleProject ;", "}", "METHOD_END"], "methodName": ["getGradleProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   javaSourceSettings ;", "}", "METHOD_END"], "methodName": ["getJavaSourceSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   linkedResources ;", "}", "METHOD_END"], "methodName": ["getLinkedResources"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   outputLocation ;", "}", "METHOD_END"], "methodName": ["getOutputLocation"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   projectDependencies ;", "}", "METHOD_END"], "methodName": ["getProjectDependencies"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   projectDirectory ;", "}", "METHOD_END"], "methodName": ["getProjectDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   gradleProject . getProjectIdentifier (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   projectNatures ;", "}", "METHOD_END"], "methodName": ["getProjectNatures"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   sourceDirectories ;", "}", "METHOD_END"], "methodName": ["getSourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   tasks ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . buildCommands    =    buildCommands ;", "}", "METHOD_END"], "methodName": ["setBuildCommands"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . classpathContainers    =    classpathContainers ;", "}", "METHOD_END"], "methodName": ["setClasspathContainers"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . gradleProject    =    gradleProject ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setGradleProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . javaSourceSettings    =    javaSourceSettings ;", "}", "METHOD_END"], "methodName": ["setJavaSourceSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . linkedResources    =    linkedResources ;", "}", "METHOD_END"], "methodName": ["setLinkedResources"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . outputLocation    =    outputLocation ;", "}", "METHOD_END"], "methodName": ["setOutputLocation"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . parent    =    parent ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . projectDependencies    =    projectDependencies ;", "}", "METHOD_END"], "methodName": ["setProjectDependencies"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . projectNatures    =    projectNatures ;", "}", "METHOD_END"], "methodName": ["setProjectNatures"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . sourceDirectories    =    sourceDirectories ;", "}", "METHOD_END"], "methodName": ["setSourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "this . tasks    =    tasks ;", "}", "METHOD_END"], "methodName": ["setTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProject"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   targetProject ;", "}", "METHOD_END"], "methodName": ["getTargetProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProjectDependency"}, {"methodBody": ["METHOD_START", "{", "this . targetProject    =    targetProject ;", "}", "METHOD_END"], "methodName": ["setTargetProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   this . id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseProjectNature"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   excludes ;", "}", "METHOD_END"], "methodName": ["getExcludes"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   includes ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   output ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseTask"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseTask"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseTask"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.eclipse.DefaultEclipseTask"}, {"methodBody": ["METHOD_START", "{", "this . inheritOutputDirs    =    inheritOutputDirs ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setInheritOutputDirs"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaCompilerOutput"}, {"methodBody": ["METHOD_START", "{", "this . outputDir    =    outputDir ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOutputDir"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaCompilerOutput"}, {"methodBody": ["METHOD_START", "{", "this . testOutputDir    =    testOutputDir ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTestOutputDir"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaCompilerOutput"}, {"methodBody": ["METHOD_START", "{", "Set < DefaultIdeaSourceDirectory >    generated    =    new   LinkedHashSet < DefaultIdeaSourceDirectory >  (  )  ;", "for    ( DefaultIdeaSourceDirectory   sourceDirectory    :    directories )     {", "if    ( sourceDirectory . isGenerated (  )  )     {", "generated . add ( sourceDirectory )  ;", "}", "}", "return   generated ;", "}", "METHOD_END"], "methodName": ["generated"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   excludeDirectories ;", "}", "METHOD_END"], "methodName": ["getExcludeDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   generated ( sourceDirectories )  ;", "}", "METHOD_END"], "methodName": ["getGeneratedSourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   generated ( testDirectories )  ;", "}", "METHOD_END"], "methodName": ["getGeneratedTestDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   resourceDirectories ;", "}", "METHOD_END"], "methodName": ["getResourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   rootDirectory ;", "}", "METHOD_END"], "methodName": ["getRootDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   sourceDirectories ;", "}", "METHOD_END"], "methodName": ["getSourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   testDirectories ;", "}", "METHOD_END"], "methodName": ["getTestDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   testResourceDirectories ;", "}", "METHOD_END"], "methodName": ["getTestResourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . excludeDirectories    =    excludeDirectories ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExcludeDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . resourceDirectories    =    resourceDirectories ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setResourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . rootDirectory    =    rootDirectory ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRootDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . sourceDirectories    =    sourceDirectories ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . testDirectories    =    testDirectories ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTestDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "this . testResourceDirectories    =    testResourceDirectories ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTestResourceDirectories"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaContentRoot"}, {"methodBody": ["METHOD_START", "{", "return   jdk ;", "}", "METHOD_END"], "methodName": ["getJdk"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "return   languageLevel ;", "}", "METHOD_END"], "methodName": ["getLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "return   targetBytecodeVersion ;", "}", "METHOD_END"], "methodName": ["getTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "this . jdk    =    jdk ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJdk"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSourceLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "this . targetBytecodeVersion    =    targetBytecodeVersion ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTargetBytecodeVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaJavaLanguageSettings"}, {"methodBody": ["METHOD_START", "{", "return    \" JDK _  1  _  4  \"  . equals ( level )  ;", "}", "METHOD_END"], "methodName": ["isJDK_1_4"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return    \" JDK _  1  _  5  \"  . equals ( level )  ;", "}", "METHOD_END"], "methodName": ["isJDK_1_5"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return    \" JDK _  1  _  6  \"  . equals ( level )  ;", "}", "METHOD_END"], "methodName": ["isJDK_1_6"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return    \" JDK _  1  _  7  \"  . equals ( level )  ;", "}", "METHOD_END"], "methodName": ["isJDK_1_7"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return    \" JDK _  1  _  8  \"  . equals ( level )  ;", "}", "METHOD_END"], "methodName": ["isJDK_1_8"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaLanguageLevel"}, {"methodBody": ["METHOD_START", "{", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   compilerOutput ;", "}", "METHOD_END"], "methodName": ["getCompilerOutput"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   contentRoots ;", "}", "METHOD_END"], "methodName": ["getContentRoots"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   dependencies ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   gradleProject ;", "}", "METHOD_END"], "methodName": ["getGradleProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   javaLanguageSettings ;", "}", "METHOD_END"], "methodName": ["getJavaLanguageSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   jdkName ;", "}", "METHOD_END"], "methodName": ["getJdkName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   gradleProject . getProjectIdentifier (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . compilerOutput    =    compilerOutput ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCompilerOutput"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . contentRoots    =    contentRoots ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setContentRoots"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . dependencies    =    dependencies ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDependencies"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . gradleProject    =    gradleProject ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setGradleProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . javaLanguageSettings    =    javaLanguageSettings ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJavaLanguageSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . jdkName    =    jdkName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJdkName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "this . parent    =    parent ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModule"}, {"methodBody": ["METHOD_START", "{", "return   dependencyModule ;", "}", "METHOD_END"], "methodName": ["getDependencyModule"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   exported ;", "}", "METHOD_END"], "methodName": ["getExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   targetModuleName ;", "}", "METHOD_END"], "methodName": ["getTargetModuleName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . dependencyModule    =    dependencyModule ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDependencyModule"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . exported    =    exported ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . scope    =    scope ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScope"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   javaLanguageSettings ;", "}", "METHOD_END"], "methodName": ["getJavaLanguageSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   jdkName ;", "}", "METHOD_END"], "methodName": ["getJdkName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   languageLevel ;", "}", "METHOD_END"], "methodName": ["getLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . children . clear (  )  ;", "this . children . addAll ( children )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setChildren"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . javaLanguageSettings    =    javaLanguageSettings ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJavaLanguageSettings"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . jdkName    =    jdkName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJdkName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . languageLevel    =    languageLevel ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setLanguageLevel"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaProject"}, {"methodBody": ["METHOD_START", "{", "return   exported ;", "}", "METHOD_END"], "methodName": ["getExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   moduleVersion ;", "}", "METHOD_END"], "methodName": ["getGradleModuleVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   javadoc ;", "}", "METHOD_END"], "methodName": ["getJavadoc"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   scope ;", "}", "METHOD_END"], "methodName": ["getScope"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . exported    =    exported ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExported"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . file    =    file ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . moduleVersion    =    moduleVersion ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setGradleModuleVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . javadoc    =    javadoc ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJavadoc"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . scope    =    scope ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScope"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSingleEntryLibraryDependency"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "return   generated ;", "}", "METHOD_END"], "methodName": ["isGenerated"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "this . directory    =    directory ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDirectory"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "this . generated    =    generated ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setGenerated"], "fileName": "org.gradle.plugins.ide.internal.tooling.idea.DefaultIdeaSourceDirectory"}, {"methodBody": ["METHOD_START", "{", "Jvm   current    =    Jvm . current (  )  ;", "return   new    ( current . getJavaHome (  )  ,    current . getJavaVersion (  )  )  ;", "}", "METHOD_END"], "methodName": ["current"], "fileName": "org.gradle.plugins.ide.internal.tooling.java.DefaultInstalledJdk"}, {"methodBody": ["METHOD_START", "{", "return   javaHome ;", "}", "METHOD_END"], "methodName": ["getJavaHome"], "fileName": "org.gradle.plugins.ide.internal.tooling.java.DefaultInstalledJdk"}, {"methodBody": ["METHOD_START", "{", "return   javaVersion ;", "}", "METHOD_END"], "methodName": ["getJavaVersion"], "fileName": "org.gradle.plugins.ide.internal.tooling.java.DefaultInstalledJdk"}, {"methodBody": ["METHOD_START", "{", "return   projectIdentifier ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "return   selectors ;", "}", "METHOD_END"], "methodName": ["getTaskSelectors"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "return   tasks ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "this . projectIdentifier    =    projectIdentifier ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "this . selectors    =    selectors ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSelectors"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "this . tasks    =    tasks ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTasks"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.DefaultBuildInvocations"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleProjectTask"}, {"methodBody": ["METHOD_START", "{", "this . project    =    project ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setProject"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleProjectTask"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( path )  ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   group ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   projectIdentifier ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getProjectPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   isPublic ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . displayName    =    displayName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDisplayName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . group    =    group ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . projectIdentifier    =    projectIdentifier ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "this . isPublic    =    isPublic ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPublic"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTask"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( taskName )  ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   projectIdentifier ;", "}", "METHOD_END"], "methodName": ["getProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   projectIdentifier . getProjectPath (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   isPublic ;", "}", "METHOD_END"], "methodName": ["isPublic"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . description    =    description ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . displayName    =    displayName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDisplayName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . projectIdentifier    =    projectIdentifier ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setProjectIdentifier"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . isPublic    =    isPublic ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPublic"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}, {"methodBody": ["METHOD_START", "{", "this . taskName    =    taskName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTaskName"], "fileName": "org.gradle.plugins.ide.internal.tooling.model.LaunchableGradleTaskSelector"}]