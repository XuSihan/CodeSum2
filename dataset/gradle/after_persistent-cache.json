[{"methodBody": ["METHOD_START", "{", "return   lockDisplayName ;", "}", "METHOD_END"], "methodName": ["getLockDisplayName"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "return   lockFile ;", "}", "METHOD_END"], "methodName": ["getLockFile"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "return   ownerOperation ;", "}", "METHOD_END"], "methodName": ["getOwnerOperation"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "return   ownerPid ;", "}", "METHOD_END"], "methodName": ["getOwnerPid"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "return   requestingOperation ;", "}", "METHOD_END"], "methodName": ["getRequestingOperation"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "return   requestingPid ;", "}", "METHOD_END"], "methodName": ["getRequestingPid"], "fileName": "org.gradle.cache.LockTimeoutException"}, {"methodBody": ["METHOD_START", "{", "assertDecorator    !  =    null ;", "thisDecorator    = Decorator ;", "return   this ;", "}", "METHOD_END"], "methodName": ["cacheDecorator"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "return   cacheDecorator ;", "}", "METHOD_END"], "methodName": ["getCacheDecorator"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "return   cacheName ;", "}", "METHOD_END"], "methodName": ["getCacheName"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "return   keySerializer ;", "}", "METHOD_END"], "methodName": ["getKeySerializer"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "return   valueSerializer ;", "}", "METHOD_END"], "methodName": ["getValueSerializer"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "return   new   PersistentIndexedCacheParameters < K ,    V >  ( cacheName ,    keySerializer ,    valueSerializer )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.cache.PersistentIndexedCacheParameters"}, {"methodBody": ["METHOD_START", "{", "long   removedSize    =    AbstractCacheCleanup . deleteFiles ( filesForDeletion )  ;", "AbstractCacheCleanup . LOGGER . info (  \"  {  }    removing    {  }    cache   entries    (  {  }    reclaimed )  .  \"  ,    persistentCache ,    filesForDeletion . size (  )  ,    FileUtils . byteCountToDisplaySize ( removedSize )  )  ;", "}", "METHOD_END"], "methodName": ["cleanupFiles"], "fileName": "org.gradle.cache.internal.AbstractCacheCleanup"}, {"methodBody": ["METHOD_START", "{", "long   removedSize    =     0  ;", "for    ( File   file    :    files )     {", "try    {", "long   size    =    file . length (  )  ;", "if    ( GFileUtils . deleteQuietly ( file )  )     {", "removedSize    +  =    size ;", "}", "}    catch    ( Exception   e )     {", ". LOGGER . debug (  (  \" Could   not   clean   up   cache    \"     +    file )  ,    e )  ;", "}", "}", "return   removedSize ;", "}", "METHOD_END"], "methodName": ["deleteFiles"], "fileName": "org.gradle.cache.internal.AbstractCacheCleanup"}, {"methodBody": ["METHOD_START", "{", "return   persistentCache . getBaseDir (  )  . listFiles ( new   FileFilter (  )     {", "@ Override", "public   boolean   accept ( File   file )     {", "return    !  (  . isReserved ( persistentCache ,    file )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["findEligibleFiles"], "fileName": "org.gradle.cache.internal.AbstractCacheCleanup"}, {"methodBody": ["METHOD_START", "{", "return   persistentCache . getReservedCacheFiles (  )  . contains ( file )  ;", "}", "METHOD_END"], "methodName": ["isReserved"], "fileName": "org.gradle.cache.internal.AbstractCacheCleanup"}, {"methodBody": ["METHOD_START", "{", "return   readFile ( new   Factory < T >  (  )     {", "public   T   create (  )     {", "return   uncheckedCall ( action )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["readFile"], "fileName": "org.gradle.cache.internal.AbstractFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   synchronizer . synchronize ( new   Factory < V >  (  )     {", "public   V   create (  )     {", "return   cache . get ( key ,    factory )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.CacheAccessSerializer"}, {"methodBody": ["METHOD_START", "{", "if    ( closed )     {", "throw   new   IllegalStateException (  \" The   w   has   already   been   closed .    Cannot   add   more   work   to   queue .  \"  )  ;", "}", "try    {", "workQueue . put ( task )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["addToQueue"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "final   List < CacheAccessWorker . FlushOperationsCommand >    flushOperations    =    new   ArrayList < CacheAccessWorker . FlushOperationsCommand >  (  )  ;", "try    {", "cacheAccess . useCache ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "CountdownTimer   timer    =    Time . startCountdownTimer ( maximumLockingTimeMillis ,    TimeUnit . MILLISECONDS )  ;", "if    ( updateOperation    !  =    null )     {", "failureHandler . onExecute ( updateOperation )  ;", "}", "Runnable   otherOperation ;", "try    {", "while    (  ( otherOperation    =    workQueue . poll ( batchWindowMillis ,    TimeUnit . MILLISECONDS )  )     !  =    null )     {", "failureHandler . onExecute ( otherOperation )  ;", "final   Class <  ?    extends   Runnable >    runnableClass    =    otherOperation . getClass (  )  ;", "if    ( runnableClass    =  =     ( CacheAccessWorker . FlushOperationsCommand . class )  )     {", "flushOperations . add (  (  ( CacheAccessWorker . FlushOperationsCommand )     ( otherOperation )  )  )  ;", "}", "if    ( runnableClass    =  =     ( CacheAccessWorker . ShutdownOperationsCommand . class )  )     {", "stopSeen    =    true ;", "}", "if    (  (  ( runnableClass    =  =     ( CacheAccessWorker . ShutdownOperationsCommand . class )  )     |  |     ( runnableClass    =  =     ( CacheAccessWorker . FlushOperationsCommand . class )  )  )     |  |     ( timer . hasExpired (  )  )  )     {", "break ;", "}", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}  )  ;", "}    finally    {", "for    ( CacheAccessWorker . FlushOperationsCommand   flushOperation    :    flushOperations )     {", "flushOperation . completed (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["flushOperations"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "FutureTask < T >    futureTask    =    new   FutureTask < T >  ( new   Callable < T >  (  )     {", "@ Override", "public   T   call (  )    throws   Exception    {", "return   task . create (  )  ;", "}", "}  )  ;", "addToQueue ( futureTask )  ;", "try    {", "return   futureTask . get (  )  ;", "}    catch    ( ExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}    catch    ( IruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "failureHandler . onStop (  )  ;", "}", "METHOD_END"], "methodName": ["rethrowFailure"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( closed )  )     &  &     (  !  ( workerCompleted )  )  )     {", "closed    =    true ;", "try    {", "workQueue . put ( new    . ShutdownOperationsCommand (  )  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "try    {", "doneSignal . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "rethrowFailure (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "return   workQueue . take (  )  ;", "}", "METHOD_END"], "methodName": ["takeFromQueue"], "fileName": "org.gradle.cache.internal.CacheAccessWorker"}, {"methodBody": ["METHOD_START", "{", "V   value    =    doGet ( key )  ;", "if    ( value    =  =    null )     {", "value    =    factory . create (  )  ;", "do ( key ,    value )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.CacheSupport"}, {"methodBody": ["METHOD_START", "{", "return   new   CleanupActionFactory . BuildOperationCacheCleanupDecorator ( action ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.cache.internal.CleanupActionFactory"}, {"methodBody": ["METHOD_START", "{", "assert    ( this . fileLock )     =  =    null ;", "this . fileLock    =    fileLock ;", "this . stateAtOpen    =    fileLock . getState (  )  ;", "takeOwnershipNow (  )  ;", "try    {", "for    (  . IndexedCacheEntry <  ?  ,     ?  >    entry    :    caches . values (  )  )     {", "entry . getCache (  )  . afterLockAcquire ( stateAtOpen )  ;", "}", "}    finally    {", "releaseOwnership (  )  ;", "}", "}", "METHOD_END"], "methodName": ["afterLockAcquire"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "assert    ( this . fileLock )     =  =    fileLock ;", "try    {", "( cacheClosedCount )  +  +  ;", "takeOwnershipNow (  )  ;", "try    {", "for    (  . IndexedCacheEntry <  ?  ,     ?  >    entry    :    caches . values (  )  )     {", "entry . getCache (  )  . finishWork (  )  ;", "}", "FileLock . State   state    =    fileLock . getState (  )  ;", "for    (  . IndexedCacheEntry <  ?  ,     ?  >    entry    :    caches . values (  )  )     {", "entry . getCache (  )  . beforeLockRelease ( state )  ;", "}", "}    finally    {", "releaseOwnership (  )  ;", "}", "}    finally    {", "this . fileLock    =    null ;", "this . stateAtOpen    =    null ;", "}", "}", "METHOD_END"], "methodName": ["beforeLockRelease"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "return   new   BTreePersistentIndexedCache < K ,    V >  ( cacheFile ,    keySerializer ,    valueSerializer )  ;", "}", "METHOD_END"], "methodName": ["doCreateCache"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cacheAccessWorker )     =  =    null )     {", "cacheAccessWorker    =    new   Worker ( cacheDisplayName ,    this )  ;", "cacheUpdateExecutor    =    executorFactory . create (  (  \" Cache   worker   for    \"     +     ( cacheDisplayName )  )  )  ;", "cacheUpdateExecutor . execute ( cacheAccessWorker )  ;", "}", "return   cacheAccessWorker ;", "}", "METHOD_END"], "methodName": ["getCacheAccessWorker"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "return   fileAccess ;", "}", "METHOD_END"], "methodName": ["getFileAccess"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "stateLock . lock (  )  ;", "try    {", "if    (  ( Thread . currentThread (  )  )     !  =     ( owner )  )     {", "throw   new   IllegalStateException ( String . format (  \" The    % s   has   not   been   locked   for   this   thread .    File   lock :     % s ,    owner :     % s \"  ,    DisplayName ,     (  ( fileLock )     !  =    null )  ,    owner )  )  ;", "}", "}    finally    {", "stateLock . unlock (  )  ;", "}", "return   fileLock ;", "}", "METHOD_END"], "methodName": ["getFileLock"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "return   owner ;", "}", "METHOD_END"], "methodName": ["getOwner"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileLockHeldByOwner )     =  =    null )     {", "return   false ;", "}", "try    {", "fileLockHeldByOwner . run (  )  ;", "}    fily    {", "fileLockHeldByOwner    =    null ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["onEndWork"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileLockHeldByOwner )     !  =    null )     {", "return   false ;", "}", "fileLockHeldByOwner    =    crossProcess . acquireFileLock (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["onStartWork"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "operations . popCacheAction (  )  ;", "if    (  !  ( operations . isInCacheAction (  )  )  )     {", "owner    =    null ;", "condition . signalAll (  )  ;", "}", "}", "METHOD_END"], "methodName": ["releaseOwnership"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "while    (  (  ( owner )     !  =    null )     &  &     (  ( owner )     !  =     ( Thread . currentThread (  )  )  )  )     {", "try    {", "condition . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "owner    =    Thread . currentThread (  )  ;", "operations . pushtion (  )  ;", "}", "METHOD_END"], "methodName": ["takeOwnership"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( owner )     !  =    null )     &  &     (  ( owner )     !  =     ( Thread . currentThread (  )  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   take   ownership   of    % s   as   it   is   currently   being   used   by   another   thread .  \"  ,    cacheDisplayName )  )  ;", "}", "owner    =    Thread . currentThread (  )  ;", "operations . pushtion (  )  ;", "}", "METHOD_END"], "methodName": ["takeOwnershipNow"], "fileName": "org.gradle.cache.internal.DefaultCacheAccess"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "CompositeStoppable . stoppable ( dirs . values (  )  )  . stop (  )  ;", "}    finally    {", "dirs . clear (  )  ;", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.DefaultCacheFactory"}, {"methodBody": ["METHOD_START", "{", "File   canonicalDir    =    FileUtils . canonicalize ( cacheDir )  ;", ". DirCacheReference   dirCacheReference    =    dirCaches . get ( canonicalDir )  ;", "if    ( dirCacheReference    =  =    null )     {", "ReferencablePersistentCache   cache ;", "if    (  (  (  (  !  ( properties . isEmpty (  )  )  )     |  |     ( validator    !  =    null )  )     |  |     ( initializer    !  =    null )  )     |  |     ( cleanup    !  =    null )  )     {", "cache    =    new   DefaultPersistentDirectoryCache ( canonicalDir ,    displayName ,    validator ,    properties ,    lockTarget ,    lockOptions ,    initializer ,    cleanup ,    lockManager ,    executorFactory )  ;", "} else    {", "cache    =    new   DefaultPersistentDirectoryStore ( canonicalDir ,    displayName ,    lockTarget ,    lockOptions ,    lockManager ,    executorFactory )  ;", "}", "cache . open (  )  ;", "dirCacheReference    =    new    . DirCacheReference ( cache ,    properties ,    lockTarget ,    lockOptions )  ;", "dirCaches . put ( canonicalDir ,    dirCacheReference )  ;", "} else    {", "if    (  !  ( lockOptions . equals ( dirCacheReference . lockOptions )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cache    '  % s '    is   already   open   with   different   lock   options .  \"  ,    cacheDir )  )  ;", "}", "if    ( lockTarget    !  =     ( dirCacheReference . lockTarget )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cache    '  % s '    is   already   open   with   different   lock   target .  \"  ,    cacheDir )  )  ;", "}", "if    (  !  ( properties . equals ( dirCacheReference . properties )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cache    '  % s '    is   already   open   with   different   properties .  \"  ,    cacheDir )  )  ;", "}", "}", "return   new    . ReferenceTrackingCache ( dirCacheReference )  ;", "}", "METHOD_END"], "methodName": ["doOpen"], "fileName": "org.gradle.cache.internal.DefaultCacheFactory"}, {"methodBody": ["METHOD_START", "{", "Hasher   hasher    =    hashFunction . newHasher (  )  ;", "for    ( Object   component    :    components )     {", "hasher . putHash ( hashOf ( component )  )  ;", "}", "return   hasher . hash (  )  ;", "}", "METHOD_END"], "methodName": ["combinedHashOf"], "fileName": "org.gradle.cache.internal.DefaultCacheKeyBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( component   instanceof   String )     {", "return   hashFunction . hashString (  (  ( String )     ( component )  )  )  ;", "}", "if    ( component   instanceof   File )     {", "return   fileHasher . hash (  (  ( File )     ( component )  )  )  ;", "}", "if    ( component   instanceof   ClassLoader )     {", "return   strictHashOf (  (  ( ClassLoader )     ( component )  )  )  ;", "}", "if    ( component   instanceof   ClassPath )     {", "return   classpathHasher . hash (  (  ( ClassPath )     ( component )  )  )  ;", "}", "throw   new   IllegalStateException (  (  \" Unsupported      key   component   type :     \"     +     ( component . getClass (  )  . getName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hashOf"], "fileName": "org.gradle.cache.internal.DefaultCacheKeyBuilder"}, {"methodBody": ["METHOD_START", "{", "HashCode   strictHash    =    classLoaderHierarchyHasher . getClassLoaderHash ( classLoader )  ;", "if    ( strictHash    =  =    null )     {", "throw   new   IllegalArgumentException (  (  \" Unknown   classloader :     \"     +    classLoader )  )  ;", "}", "return   strictHash ;", "}", "METHOD_END"], "methodName": ["strictHashOf"], "fileName": "org.gradle.cache.internal.DefaultCacheKeyBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheRepository . PersistentCacheBuilder ( baseDir )  ;", "}", "METHOD_END"], "methodName": ["cache"], "fileName": "org.gradle.cache.internal.DefaultCacheRepository"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheRepository . PersistentCacheBuilder ( scope ,    key )  ;", "}", "METHOD_END"], "methodName": ["cache"], "fileName": "org.gradle.cache.internal.DefaultCacheRepository"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheRepository . PersistentCacheBuilder ( null ,    key )  ;", "}", "METHOD_END"], "methodName": ["cache"], "fileName": "org.gradle.cache.internal.DefaultCacheRepository"}, {"methodBody": ["METHOD_START", "{", "if    ( target . isDirectory (  )  )     {", "return   new   File ( target ,     (  ( target . getName (  )  )     +     \"  . lock \"  )  )  ;", "} else    {", "return   new   File ( target . getParen (  )  ,     (  ( target . getName (  )  )     +     \"  . lock \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["determineLockTargetFile"], "fileName": "org.gradle.cache.internal.DefaultFileLockManager"}, {"methodBody": ["METHOD_START", "{", "return   lock ( target ,    options ,    targetDisplayName ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["lock"], "fileName": "org.gradle.cache.internal.DefaultFileLockManager"}, {"methodBody": ["METHOD_START", "{", "return   lock ( target ,    options ,    targetDisplayName ,    operationDisplayName ,    null )  ;", "}", "METHOD_END"], "methodName": ["lock"], "fileName": "org.gradle.cache.internal.DefaultFileLockManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( options . getMode (  )  )     =  =     ( FileLockManager . LockMode . None )  )     {", "throw   new   UnsupportedOperationException ( String . format (  \" No    % s   mode   lock   implementation   available .  \"  ,    options )  )  ;", "}", "File   canonicalTarget    =    FileUtils . canonicalize ( target )  ;", "if    (  !  ( lockedFiles . add ( canonicalTarget )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   lock    % s   as   it   has   already   been   locked   by   this   process .  \"  ,    targetDisplayName )  )  ;", "}", "try    {", "int   port    =    fileLockContentionHandler . reservePort (  )  ;", "return   new    . DefaultFileLock ( canonicalTarget ,    options ,    targetDisplayName ,    operationDisplayName ,    port ,    whenContended )  ;", "}    catch    ( Throwable   t )     {", "lockedFiles . remove ( canonicalTarget )  ;", "throw   UncheckedException . throwAsUncheckedException ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["lock"], "fileName": "org.gradle.cache.internal.DefaultFileLockManager"}, {"methodBody": ["METHOD_START", "{", "if    (  ( cache )     =  =    null )     {", "fileAccess . writeFile ( new   Runnable (  )     {", "public   void   run (  )     {", "cache    =    factory . create (  )  ;", "}", "}  )  ;", "}", "return   cache ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.gradle.cache.internal.DefaultMultiProcessSafePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "return   properties ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryCache"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheAccess ( displayName ,    getLockTarget (  )  ,    lockOptions ,    dir ,    lockManager ,    getInitAction (  )  ,    getCleanupAction (  )  ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createCacheAccess"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryStore"}, {"methodBody": ["METHOD_START", "{", "if    ( target . isDirectory (  )  )     {", "return   new   File ( target ,     (  ( target . getName (  )  )     +     \"  . lock \"  )  )  ;", "} else    {", "return   new   File ( target . getParentFile (  )  ,     (  ( target . getName (  )  )     +     \"  . lock \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["determineLockTargetFile"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryStore"}, {"methodBody": ["METHOD_START", "{", "return   new   CacheCleanupAction (  )     {", "@ Override", "public   boolean   requiresCleanup (  )     {", "return   false ;", "}", "@ Override", "public   void   cleanup (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getCleanupAction"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryStore"}, {"methodBody": ["METHOD_START", "{", "return   new   CacheInitializationAction (  )     {", "public   boolean   requiresInitialization ( FileLock   fileLock )     {", "return   false ;", "}", "public   void   initialize ( FileLock   fileLock )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getInitAction"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryStore"}, {"methodBody": ["METHOD_START", "{", "switch    ( lockTarget )     {", "case   Cache    :", "case   DefaultTarget    :", "return   dir ;", "case   CachePropertiesFile    :", "return   propertiesFile ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unsupported   lock   target :     \"     +     ( lockTarget )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getLockTarget"], "fileName": "org.gradle.cache.internal.DefaultPersistentDirectoryStore"}, {"methodBody": ["METHOD_START", "{", "return    \" gradle \"  ;", "}", "METHOD_END"], "methodName": ["getProcessDisplayName"], "fileName": "org.gradle.cache.internal.DefaultProcessMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "Long   pid    =    environment . maybeGetPid (  )  ;", "return   pid    =  =    null    ?     \"  \"     :    String . valueOf ( pid )  ;", "}", "METHOD_END"], "methodName": ["getProcessIdentifier"], "fileName": "org.gradle.cache.internal.DefaultProcessMetaDataProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   work . create (  )  ;", "}    catch    ( Exception   e )     {", "T   newValue    =    updateAction . update ( null )  ;", "set ( newValue )  ;", "return   newValue ;", "}", "}", "METHOD_END"], "methodName": ["doUpdate"], "fileName": "org.gradle.cache.internal.FileIntegrityViolationSuppressingPersistentStateCacheDecorator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   delegate . get (  )  ;", "}    catch    ( Exception   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.FileIntegrityViolationSuppressingPersistentStateCacheDecorator"}, {"methodBody": ["METHOD_START", "{", "delegate . set ( newValue )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.cache.internal.FileIntegrityViolationSuppressingPersistentStateCacheDecorator"}, {"methodBody": ["METHOD_START", "{", "return   doUpdate ( updateAction ,    new   Factory < T >  (  )     {", "@ Override", "public   T   create (  )     {", "return   delegate . update ( updateAction )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.gradle.cache.internal.FileIntegrityViolationSuppressingPersistentStateCacheDecorator"}, {"methodBody": ["METHOD_START", "{", "return   new   UnsupportedOperationException (  \" Cannot   escalate   a   shared   lock   to   an   exclusive   lock .    This   is   not   yet   supported .  \"  )  ;", "}", "METHOD_END"], "methodName": ["failure"], "fileName": "org.gradle.cache.internal.FixedSharedModeCrossProcessCacheAccess"}, {"methodBody": ["METHOD_START", "{", "return    (  ( int )     (  ( Runtime . getRuntime (  )  . maxMemory (  )  )     /     (  1  0  2  4     *     1  0  2  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["calculateMaxHeapMB"], "fileName": "org.gradle.cache.internal.HeapProportionalCacheSizer"}, {"methodBody": ["METHOD_START", "{", "double   defaultAvailableHeapSpace    =     ( HeapProportionalCacheSizer . DEFAULT _ SIZES _ MAX _ HEAP _ MB )     -     ( HeapProportionalCacheSizer . ASSUMED _ USED _ HEAP )  ;", "double   availableHeapSpace    =     ( maxHeapMB )     -     ( reservedHeap )  ;", "double   ratioToDefaultAvailableHeap    =    availableHeapSpace    /    defaultAvailableHeapSpace ;", "return   Math . max ( ratioToDefaultAvailableHeap ,    HeapProportionalCacheSizer . MIN _ RATIO )  ;", "}", "METHOD_END"], "methodName": ["calculateRatioToDefaultAvailableHeap"], "fileName": "org.gradle.cache.internal.HeapProportionalCacheSizer"}, {"methodBody": ["METHOD_START", "{", "return   scaleCacheSize ( referenceValue ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["scaleCacheSize"], "fileName": "org.gradle.cache.internal.HeapProportionalCacheSizer"}, {"methodBody": ["METHOD_START", "{", "if    ( referenceValue    <    granularity )     {", "throw   new   IllegalArgumentExcep (  \" reference   value   must   be   larger   than   granularity \"  )  ;", "}", "int   scaledValue    =     (  (  ( int )     (  (  ( double )     ( referenceValue )  )     *     ( sizingRatio )  )  )     /    granularity )     *    granularity ;", "return   Math . max ( scaledValue ,    granularity )  ;", "}", "METHOD_END"], "methodName": ["scaleCacheSize"], "fileName": "org.gradle.cache.internal.HeapProportionalCacheSizer"}, {"methodBody": ["METHOD_START", "{", "stateLock . lock (  )  ;", "try    {", "if    (  (  ( lockCount )     <  =     0  )     |  |     (  ( fileLock )     =  =    null )  )     {", "throw   new   IllegalStateException (  \" Mismatched   lock   count .  \"  )  ;", "}", "( lockCount )  -  -  ;", "if    (  (  ( lockCount )     =  =     0  )     &  &     ( contended )  )     {", "releaseLockIfHeld (  )  ;", "}", "}    finally    {", "stateLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["decrementLockCount"], "fileName": "org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess"}, {"methodBody": ["METHOD_START", "{", "stateLock . lock (  )  ;", "try    {", "if    (  ( fileLock )     =  =    null )     {", "if    (  ( lockCount )     !  =     0  )     {", "throw   new   IllegalStateException (  \" Mismatched   lock   count .  \"  )  ;", "}", "if    (  . LOGGER . isDebugEnabled (  )  )     {", ". LOGGER . debug (  \" Acquiring   file   lock   for    {  }  \"  ,    cacheDisplayName )  ;", "}", "fileLock    =    lockManager . lock ( lockTarget ,    lockOptions ,    cacheDisplayName ,     \"  \"  ,    whenContended )  ;", "try    {", "if    ( initAction . requiresInitialization ( fileLock )  )     {", "fileLock . writeFile ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "initAction . initialize ( fileLock )  ;", "}", "}  )  ;", "}", "onOpen . execute ( fileLock )  ;", "}    catch    ( Exception   e )     {", "fileLock . close (  )  ;", "fileLock    =    null ;", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "( lockCount )  +  +  ;", "}    finally    {", "stateLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["incrementLockCount"], "fileName": "org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileLock )     =  =    null )     {", "return ;", "}", "if    (  . LOGGER . isDebugEnabled (  )  )     {", ". LOGGER . debug (  \" Releasing   file   lock   for    {  }  \"  ,    cacheDisplayName )  ;", "}", "try    {", "onClose . execute ( fileLock )  ;", "}    finally    {", "fileLock . close (  )  ;", "fileLock    =    null ;", "contended    =    false ;", "}", "}", "METHOD_END"], "methodName": ["releaseLockIfHeld"], "fileName": "org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess"}, {"methodBody": ["METHOD_START", "{", "map . put ( key ,    value )  ;", "}", "METHOD_END"], "methodName": ["doCache"], "fileName": "org.gradle.cache.internal.MapBackedCache"}, {"methodBody": ["METHOD_START", "{", "return   map . get ( key )  ;", "}", "METHOD_END"], "methodName": ["doGet"], "fileName": "org.gradle.cache.internal.MapBackedCache"}, {"methodBody": ["METHOD_START", "{", "return   cache . get ( value )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.MinimalPersistentCache"}, {"methodBody": ["METHOD_START", "{", "FileLock   lock    =    manager . lock ( targetFile ,    LockOptionsBuilder . mode ( FileLockManager . LockMode . Shared )  ,    displayName )  ;", "try    {", "return   lock . rea ( action )  ;", "}    finally    {", "lock . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readFile"], "fileName": "org.gradle.cache.internal.OnDemandFileAccess"}, {"methodBody": ["METHOD_START", "{", "FileLock   lock    =    manager . lock ( targetFile ,    LockOptionsBuilder . mode ( FileLockManager . LockMode . Exclusive )  ,    displayName )  ;", "try    {", "lock . updateFile ( action )  ;", "}    finally    {", "lock . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateFile"], "fileName": "org.gradle.cache.internal.OnDemandFileAccess"}, {"methodBody": ["METHOD_START", "{", "FileLock   lock    =    manager . lock ( targetFile ,    LockOptionsBuilder . mode ( FileLockManager . LockMode . Exclusive )  ,    displayName )  ;", "try    {", "lock . writeFile ( action )  ;", "}    finally    {", "lock . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFile"], "fileName": "org.gradle.cache.internal.OnDemandFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   new   ProducerGuard . AdaptiveProducerGuard < T >  (  )  ;", "}", "METHOD_END"], "methodName": ["adaptive"], "fileName": "org.gradle.cache.internal.ProducerGuard"}, {"methodBody": ["METHOD_START", "{", "return   new   ProducerGuard . SerialProducerGuard < T >  (  )  ;", "}", "METHOD_END"], "methodName": ["serial"], "fileName": "org.gradle.cache.internal.ProducerGuard"}, {"methodBody": ["METHOD_START", "{", "return   new   ProducerGuard . StripedProducerGuard < T >  (  )  ;", "}", "METHOD_END"], "methodName": ["striped"], "fileName": "org.gradle.cache.internal.ProducerGuard"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( cacheFile . isFile (  )  )  )     {", "return   null ;", "}", "try    {", "InputStreamBackedDecoder   decoder    =    new   InputStreamBackedDecoder ( new   BufferedInputStream ( new   FileInputStream ( cacheFile )  )  )  ;", "try    {", "return   serializer . read ( decoder )  ;", "}    finally    {", "decoder . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   read   cache   value   from    '  % s '  .  \"  ,    cacheFile )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["deserialize"], "fileName": "org.gradle.cache.internal.SimpleStateCache"}, {"methodBody": ["METHOD_START", "{", "return   fileAccess . readFile ( new   Factory < T >  (  )     {", "public   T   create (  )     {", "return   deserialize (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.SimpleStateCache"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  !  ( File . isFile (  )  )  )     {", "File . createNewFile (  )  ;", "}", "chmod . chmod ( File . getParentFile (  )  ,     4  4  8  )  ;", "chmod . chmod ( File ,     3  8  4  )  ;", "OutputStreamBackedEncoder   encoder    =    new   OutputStreamBackedEncoder ( new   BufferedOutputStream ( new   FileOutputStream ( File )  )  )  ;", "try    {", "serializer . write ( encoder ,    newValue )  ;", "}    finally    {", "encoder . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   write      value   to    '  % s '  .  \"  ,    File )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.gradle.cache.internal.SimpleStateCache"}, {"methodBody": ["METHOD_START", "{", "fileAccess . writeFile ( new   Runnable (  )     {", "public   void   run (  )     {", "serialize ( newValue )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.cache.internal.SimpleStateCache"}, {"methodBody": ["METHOD_START", "{", "class   Updater   implements   Runnable    {", "private   final   Persistent . UpdateAction < T >    updateAction ;", "private   T   result ;", "private   Updater ( Persistent . UpdateAction < T >    updateAction )     {", "this . updateAction    =    updateAction ;", "}", "public   void   run (  )     {", "T   oldValue    =    deserialize (  )  ;", "result    =    updateAction . update ( oldValue )  ;", "serialize ( result )  ;", "}", "}", "Updater   updater    =    new   Updater ( updateAction )  ;", "fileAccess . updateFile ( updater )  ;", "return   updater . result ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.gradle.cache.internal.SimpleStateCache"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache . LOGGER . debug (  \" Closing    {  }  \"  ,    this )  ;", "try    {", "store . close (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "BlockStore . Factory   factory    =    new   BlockStore . Factory (  )     {", "public   Object   create ( Class <  ?    extends   BlockPayload >    type )     {", "if    ( type    =  =     (  . HeaderBlock . class )  )     {", "return   new   HeaderBlock (  )  ;", "}", "if    ( type    =  =     (  . IndexBlock . class )  )     {", "return   new   IndexBlock (  )  ;", "}", "if    ( type    =  =     (  . DataBlock . class )  )     {", "return   new   DataBlock (  )  ;", "}", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "Runnable   initAction    =    new   Runnable (  )     {", "public   void   run (  )     {", "header    =    new   HeaderBlock (  )  ;", "store . write ( header )  ;", "header . index . newRoot (  )  ;", "store . flush (  )  ;", "}", "}  ;", "store . open ( initAction ,    factory )  ;", "header    =    store . readFirst (  . HeaderBlock . class )  ;", "}", "METHOD_END"], "methodName": ["doOpen"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "List < BlockPayload >    blocks    =    new   ArrayList < BlockPayload >  (  )  ;", "< K ,    V >  . HeaderBlock   header    =    store . readFirst (  . HeaderBlock . class )  ;", "blocks . add ( header )  ;", "verifyTree ( header . getRoot (  )  ,     \"  \"  ,    blocks ,    Long . MAX _ VALUE ,    true )  ;", "Collections . sort ( blocks ,    new   Comparator < BlockPayload >  (  )     {", "public   int   compare ( BlockPayload   block ,    BlockPayload   block 1  )     {", "return   block . getPos (  )  . compareTo ( block 1  . getPos (  )  )  ;", "}", "}  )  ;", "for    ( int   i    =     0  ;    i    <     (  ( blocks . size (  )  )     -     1  )  ;    i +  +  )     {", "Block   b 1     =    blocks . get ( i )  . getBlock (  )  ;", "Block   b 2     =    blocks . get (  ( i    +     1  )  )  . getBlock (  )  ;", "if    (  (  ( b 1  . getPos (  )  . getPos (  )  )     +     ( b 1  . getSize (  )  )  )     >     ( b 2  . getPos (  )  . getPos (  )  )  )     {", "throw   new   IOException ( String . format (  \"  % s   overlaps   with    % s \"  ,    b 1  ,    b 2  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doVerify"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "try    {", "try    {", "< K ,    V >  . DataBlock   block    =    header . getRoot (  )  . get ( key )  ;", "if    ( block    !  =    null )     {", "return   block . getValue (  )  ;", "}", "return   null ;", "}    catch    ( CorruptedCacheException   e )     {", "rebuild (  )  ;", "return   null ;", "}", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Could   not   read   entry    '  % s '    from    % s .  \"  ,    key ,    this )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "return   store . isOpen (  )  ;", "}", "METHOD_END"], "methodName": ["isOpen"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < K ,    V >  . IndexBlock   block    =    store . read ( pos ,    BTreePersistentIndexedCache . IndexBlock . class )  ;", "block . root    =    root ;", "block . parent    =    parent ;", "block . parentEntryIndex    =    index ;", "return   block ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache . LOGGER . debug (  \" Opening    {  }  \"  ,    this )  ;", "try    {", "doOpen (  )  ;", "}    catch    ( CorruptedCacheException   e )     {", "rebuild (  )  ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   hashCode    =    keyHasher . getHashCode ( key )  ;", "< K ,    V >  . Lookup   lookup    =    header . getRoot (  )  . find ( hashCode )  ;", "< K ,    V >  . DataBlock   newBlock    =    null ;", "if    (  ( lookup . entry )     !  =    null )     {", "< K ,    V >  . DataBlock   block    =    store . read ( lookup . entry . dataBlock ,     . DataBlock . class )  ;", ". DataBlockUpdateResult   updateResult    =    block . useNewValue ( value )  ;", "if    ( updateResult . isFailed (  )  )     {", "store . remove ( block )  ;", "newBlock    =    new   DataBlock ( value ,    updateResult . getSerializedValue (  )  )  ;", "}", "} else    {", "newBlock    =    new   DataBlock ( value )  ;", "}", "if    ( newBlock    !  =    null )     {", "store . write ( newBlock )  ;", "lookup . indexBlock . put ( hashCode ,    newBlock . getPos (  )  )  ;", "}", "store . flush (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Could   not   add   entry    '  % s '    to    % s .  \"  ,    key ,    this )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["put"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache . LOGGER . warn (  \"  {  }    is   corrupt .    Discarding .  \"  ,    this )  ;", "store . clear (  )  ;", "close (  )  ;", "doOpen (  )  ;", "}", "METHOD_END"], "methodName": ["rebuild"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "try    {", "< K ,    V >  . Lookup   lookup    =    header . getRoot (  )  . find ( key )  ;", "if    (  ( lookup . entry )     =  =    null )     {", "return ;", "}", "lookup . indexBlock . remove ( lookup . entry )  ;", "< K ,    V >  . DataBlock   block    =    store . read ( lookup . entry . dataBlock ,     . DataBlock . class )  ;", "store . remove ( block )  ;", "store . flush (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Could   not   remove   entry    '  % s '    from    % s .  \"  ,    key ,    this )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "close (  )  ;", "try    {", "open (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UnckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "try    {", "doVerify (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Some   problems   were   found   when   checking   the   grity   of    % s .  \"  ,    this )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "blocks . add ( current )  ;", "if    (  (  !  ( prefix . equals (  \"  \"  )  )  )     &  &     (  ( current . entries . size (  )  )     <     (  ( maxChildIndexEntries )     /     2  )  )  )     {", "throw   new   IOException ( String . format (  \" Too   few   entries   found   in    % s \"  ,    current )  )  ;", "}", "if    (  ( current . entries . size (  )  )     >     ( maxChildIndexEntries )  )     {", "throw   new   IOException ( String . format (  \" Too   many   entries   found   in    % s \"  ,    current )  )  ;", "}", "boolean   isLeaf    =     (  ( current . entries . size (  )  )     =  =     0  )     |  |     ( current . entries . get (  0  )  . childIndexBlock . isNull (  )  )  ;", "if    ( isLeaf    ^     ( current . tailPos . isNull (  )  )  )     {", "throw   new   IOException ( String . format (  \" Mismatched   leaf / tail - node   in    % s \"  ,    current )  )  ;", "}", "long   min    =    Long . MIN _ VALUE ;", "for    (  . IndexEntry   entry    :    current . entries )     {", "if    ( isLeaf    ^     ( entry . childIndexBlock . isNull (  )  )  )     {", "throw   new   IOException ( String . format (  \" Mismatched   leaf / non - leaf   entry   in    % s \"  ,    current )  )  ;", "}", "if    (  (  ( entry . hashCode )     >  =    maxValue )     |  |     (  ( entry . hashCode )     <  =    min )  )     {", "throw   new   IOException ( String . format (  \" Out - of - order   key   in    % s \"  ,    current )  )  ;", "}", "min    =    entry . hashCode ;", "if    (  !  ( entry . childIndexBlock . isNull (  )  )  )     {", "< K ,    V >  . IndexBlock   child    =    store . read ( entry . childIndexBlock ,     . IndexBlock . class )  ;", "verifyTree ( child ,     (  \"           \"     +    prefix )  ,    blocks ,    entry . hashCode ,    loadData )  ;", "}", "if    ( loadData )     {", "< K ,    V >  . DataBlock   block    =    store . read ( entry . dataBlock ,     . DataBlock . class )  ;", "blocks . add ( block )  ;", "}", "}", "if    (  !  ( current . tailPos . isNull (  )  )  )     {", "< K ,    V >  . IndexBlock   tail    =    store . read ( current . tailPos ,     . IndexBlock . class )  ;", "verifyTree ( tail ,     (  \"           \"     +    prefix )  ,    blocks ,    maxValue ,    loadData )  ;", "}", "}", "METHOD_END"], "methodName": ["verifyTree"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCache"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "int   count    =     2  0  0  0  ;", "List < Integer >    values    =    new   ArrayList < Integer >  (  )  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "values . add ( i )  ;", "}", "checkAddsAndRemoves ( null ,    values )  ;", "long   len    =    ile . length (  )  ;", "checkAddsAndRemoves ( Collections .  < Integer > reverseOrder (  )  ,    values )  ;", "assertThat ( ile . length (  )  ,    lessThan (  (  ( long )     (  1  .  4     *    len )  )  )  )  ;", "checkAdds ( values )  ;", "assertThat ( ile . length (  )  ,    lessThan (  (  ( long )     (  (  1  .  4     *     1  .  4  )     *    len )  )  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["canHandleLargeNumberOfEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < File ,    Integer >    cache    =    new   BTreePersistentIndexedCache < File ,    Integer >  ( cacheFile ,    new   DefaultSerializer < File >  (  )  ,    integerSerializer )  ;", "cache . put ( new   File (  \" file \"  )  ,     1  )  ;", "cache . put ( new   File (  \" dir / file \"  )  ,     2  )  ;", "cache . put ( new   File (  \" File \"  )  ,     3  )  ;", "assertThat ( cache . get ( new   File (  \" file \"  )  )  ,    equalTo (  1  )  )  ;", "assertThat ( cache . get ( new   File (  \" dir / file \"  )  )  ,    equalTo (  2  )  )  ;", "assertThat ( cache . get ( new   File (  \" File \"  )  )  ,    equalTo (  3  )  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["canUseFileAsKey"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "checkAdds ( Arrays . asList ( values )  )  ;", "}", "METHOD_END"], "methodName": ["checkAdds"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    added    =    new   LinkedHashMap < String ,    Integer >  (  )  ;", "for    ( Integer   value    :    values )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "put ( key ,    value )  ;", "added . put ( String . format (  \" key _  % d \"  ,    value )  ,    value )  ;", "}", "for    ( Map . Entry < String ,    Integer >    entry    :    added . entrySet (  )  )     {", "assertThat ( get ( entry . getKey (  )  )  ,    equalTo ( entry . getValue (  )  )  )  ;", "}", "reset (  )  ;", "for    ( Map . Entry < String ,    Integer >    entry    :    added . entrySet (  )  )     {", "assertThat ( get ( entry . getKey (  )  )  ,    equalTo ( entry . getValue (  )  )  )  ;", "}", "return   added ;", "}", "METHOD_END"], "methodName": ["checkAdds"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "checkAddsAndRemoves ( null ,    values )  ;", "}", "METHOD_END"], "methodName": ["checkAddsAndRemoves"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "checkAddsAndRemoves ( comparator ,    Arrays . asList ( values )  )  ;", "}", "METHOD_END"], "methodName": ["checkAddsAndRemoves"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "checkAdds ( values )  ;", "List < Integer >    deleteValues    =    new   ArrayList < Integer >  ( values )  ;", "Collections . sort ( deleteValues ,    comparator )  ;", "for    ( Integer   value    :    deleteValues )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "assertThat ( get ( key )  ,    notNullValue (  )  )  ;", "remove ( key )  ;", "assertThat ( get ( key )  ,    nullValue (  )  )  ;", "}", "reset (  )  ;", "verify (  )  ;", "for    ( Integer   value    :    deleteValues )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "assertThat ( get ( key )  ,    nullValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkAddsAndRemoves"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < Integer ,    List < Integer >  >    entry    :    updated . entrySet (  )  )     {", "String   key    =    String . format (  \" key _  % d \"  ,    entry . getKey (  )  )  ;", "assertThat ( get ( key )  ,    equalTo ( entry . getValue (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkListEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "checkUpdates ( Arrays . asList ( values )  )  ;", "}", "METHOD_END"], "methodName": ["checkUpdates"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "Map < Integer ,    Integer >    updated    =    new   LinkedHashMap < Integer ,    Integer >  (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "for    ( Integer   value    :    values )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "int   newValue    =    value    +     ( i    *     1  0  0  )  ;", "put ( key ,    newValue )  ;", "updated . put ( value ,    newValue )  ;", "}", "for    ( Map . Entry < Integer ,    Integer >    entry    :    updated . entrySet (  )  )     {", "String   key    =    String . format (  \" key _  % d \"  ,    entry . getKey (  )  )  ;", "assertThat ( get ( key )  ,    equalTo ( entry . getValue (  )  )  )  ;", "}", "}", "reset (  )  ;", "for    ( Map . Entry < Integer ,    Integer >    entry    :    updated . entrySet (  )  )     {", "String   key    =    String . format (  \" key _  % d \"  ,    entry . getKey (  )  )  ;", "assertThat ( get ( key )  ,    equalTo ( entry . getValue (  )  )  )  ;", "}", "return   updated ;", "}", "METHOD_END"], "methodName": ["checkUpdates"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "cache    =    new   BTreePersistentIndexedCache < String ,    Integer >  ( cacheFile ,    stringSerializer ,    integerSerializer ,     (  ( short )     (  4  )  )  ,     1  0  0  )  ;", "}", "METHOD_END"], "methodName": ["createCache"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "assertNull ( get (  \" unknown \"  )  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["getReturnsNullWhenEntryDoesNotExist"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "String   key 1     =    new   String ( new   byte [  ]  {     2  ,     3  1     }  )  ;", "String   key 2     =    new   String ( new   byte [  ]  {     1  ,     6  2     }  )  ;", "put ( key 1  ,     1  )  ;", "put ( key 2  ,     2  )  ;", "assertThat ( get ( key 1  )  ,    equalTo (  1  )  )  ;", "assertThat ( get ( key 2  )  ,    equalTo (  2  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["handlesKeysWithSameHashCode"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "cacheFile . createNewFile (  )  ;", "cacheFile . write (  \" some   junk \"  )  ;", "< String ,    Integer >    cache    =    new    < String ,    Integer >  ( cacheFile ,    stringSerializer ,    integerSerializer )  ;", "assertNull ( cache . get (  \" key _  1  \"  )  )  ;", "cache . put (  \" key _  1  \"  ,     9  9  )  ;", "cache . reset (  )  ;", "assertThat ( cache . get (  \" key _  1  \"  )  ,    equalTo (  9  9  )  )  ;", "cache . verify (  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["handlesOpeningACacheFileThatIsBadlyFormed"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < String ,    Integer >    cache    =    new   BTreePersistentIndexedCache < String ,    Integer >  ( cacheFile ,    stringSerializer ,    integerSerializer )  ;", "assertNull ( cache . get (  \" key _  1  \"  )  )  ;", "cache . put (  \" key _  1  \"  ,     9  9  )  ;", "RandomAccessFile   file    =    new   RandomAccessFile ( cacheFile ,     \" rw \"  )  ;", "file . setLength (  (  ( file . length (  )  )     -     1  0  )  )  ;", "file . close (  )  ;", "cache . reset (  )  ;", "assertNull ( cache . get (  \" key _  1  \"  )  )  ;", "cache . verify (  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["handlesOpeningATruncatedCacheFile"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < String ,    List < Integer >  >    cache    =    new   BTreePersistentIndexedCache < String ,    List < Integer >  >  ( tmpDir . file (  \" listcache . bin \"  )  ,    stringSerializer ,    new   DefaultSerializer < List < Integer >  >  (  )  ,     (  ( short )     (  4  )  )  ,     1  0  0  )  ;", "List < Integer >    values    =    Arrays . asList (  3  ,     2  ,     1  1  ,     5  ,     7  ,     1  ,     1  0  ,     8  ,     9  ,     4  ,     6  ,     0  )  ;", "Map < Integer ,    List < Integer >  >    updated    =    new   LinkedHashMap < Integer ,    List < Integer >  >  (  )  ;", "for    ( int   i    =     1  0  ;    i    >     0  ;    i -  -  )     {", "for    ( Integer   value    :    values )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "List < Integer >    newValue    =    new   ArrayList < Integer >  ( i )  ;", "for    ( int   j    =     0  ;    j    <     ( i    *     2  )  ;    j +  +  )     {", "newValue . add ( j )  ;", "}", "cache . put ( key ,    newValue )  ;", "updated . put ( value ,    newValue )  ;", "}", "checkListEntries ( cache ,    updated )  ;", "}", "cache . reset (  )  ;", "checkListEntries ( cache ,    updated )  ;", "cache . verify (  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["handlesUpdatesWhenBlockSizeDecreases"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < String ,    List < Integer >  >    cache    =    new   BTreePersistentIndexedCache < String ,    List < Integer >  >  ( tmpDir . file (  \" listcache . bin \"  )  ,    stringSerializer ,    new   DefaultSerializer < List < Integer >  >  (  )  ,     (  ( short )     (  4  )  )  ,     1  0  0  )  ;", "List < Integer >    values    =    Arrays . asList (  3  ,     2  ,     1  1  ,     5  ,     7  ,     1  ,     1  0  ,     8  ,     9  ,     4  ,     6  ,     0  )  ;", "Map < Integer ,    List < Integer >  >    updated    =    new   LinkedHashMap < Integer ,    List < Integer >  >  (  )  ;", "for    ( int   i    =     1  ;    i    <     1  0  ;    i +  +  )     {", "for    ( Integer   value    :    values )     {", "String   key    =    String . format (  \" key _  % d \"  ,    value )  ;", "List < Integer >    newValue    =    new   ArrayList < Integer >  ( i )  ;", "for    ( int   j    =     0  ;    j    <     ( i    *     2  )  ;    j +  +  )     {", "newValue . add ( j )  ;", "}", "cache . put ( key ,    newValue )  ;", "updated . put ( value ,    newValue )  ;", "}", "checkListEntries ( cache ,    updated )  ;", "}", "cache . reset (  )  ;", "checkListEntries ( cache ,    updated )  ;", "cache . verify (  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["handlesUpdatesWhenBlockSizeIncreases"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     3  ,     4  ,     5  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsAddedEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     3  ,     4  )  ;", "reset (  )  ;", "checkAdds (  5  ,     6  ,     7  ,     8  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsAddedEntriesAfterReopen"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  5  ,     4  ,     3  ,     2  ,     1  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsAddedEntriesInReverseOrder"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  3  ,     2  ,     1  1  ,     5  ,     7  ,     1  ,     1  0  ,     8  ,     9  ,     4  ,     6  ,     0  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsAddedEntriesOverMultipleIndexBlocks"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAddsAndRemoves (  1  ,     2  ,     3  ,     4  ,     5  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsRemovalOfEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAddsAndRemoves ( Collections .  < Integer > reverseOrder (  )  ,     1  ,     2  ,     3  ,     4  ,     5  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsRemovalOfEntriesInReverse"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAddsAndRemoves (  4  ,     1  2  ,     9  ,     1  ,     3  ,     1  0  ,     1  1  ,     7  ,     8  ,     2  ,     5  ,     6  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsRemovalOfEntriesOverMultipleIndexBlocks"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "put (  \" key _  1  \"  ,     1  )  ;", "put (  \" key _  2  \"  ,     2  )  ;", "put (  \" key _  3  \"  ,     3  )  ;", "put (  \" key _  4  \"  ,     4  )  ;", "put (  \" key _  5  \"  ,     5  )  ;", "put (  \" key _  1  \"  ,     1  )  ;", "put (  \" key _  4  \"  ,     1  2  )  ;", "assertThat ( get (  \" key _  1  \"  )  ,    equalTo (  1  )  )  ;", "assertThat ( get (  \" key _  2  \"  )  ,    equalTo (  2  )  )  ;", "assertThat ( get (  \" key _  3  \"  )  ,    equalTo (  3  )  )  ;", "assertThat ( get (  \" key _  4  \"  )  ,    equalTo (  1  2  )  )  ;", "assertThat ( get (  \" key _  5  \"  )  ,    equalTo (  5  )  )  ;", "reset (  )  ;", "assertThat ( get (  \" key _  1  \"  )  ,    equalTo (  1  )  )  ;", "assertThat ( get (  \" key _  2  \"  )  ,    equalTo (  2  )  )  ;", "assertThat ( get (  \" key _  3  \"  )  ,    equalTo (  3  )  )  ;", "assertThat ( get (  \" key _  4  \"  )  ,    equalTo (  1  2  )  )  ;", "assertThat ( get (  \" key _  5  \"  )  ,    equalTo (  5  )  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsReplacedEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkUpdates (  3  ,     2  ,     1  1  ,     5  ,     7  ,     1  ,     1  0  ,     8  ,     9  ,     4  ,     6  ,     0  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["persistsUpdates"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     4  ,     5  ,     3  )  ;", "verify (  )  ;", "remove (  \" key _  4  \"  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["removalMergesRemainingEntriesIntoLeftSibling"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     4  ,     5  ,     3  )  ;", "verify (  )  ;", "remove (  \" key _  2  \"  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["removalMergesRemainingEntriesIntoRightSibling"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     5  ,     6  ,     4  ,     3  )  ;", "verify (  )  ;", "remove (  \" key _  5  \"  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["removalRedistributesRemainingEntriesWithLeftSibling"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "createCache (  )  ;", "checkAdds (  1  ,     2  ,     4  ,     5  ,     3  ,     6  )  ;", "verify (  )  ;", "remove (  \" key _  2  \"  )  ;", "verifyAndCloseCache (  )  ;", "}", "METHOD_END"], "methodName": ["removalRedistributesRemainingEntriesWithRightSibling"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "BTreePersistentIndexedCache < String ,    String >    cache    =    new   BTreePersistentIndexedCache < String ,    String >  ( cacheFile ,    stringSerializer ,    stringSerializer ,     (  ( short )     (  4  )  )  ,     1  0  0  )  ;", "cache . put (  \" key _  1  \"  ,     \" abcd \"  )  ;", "cache . put (  \" key _  2  \"  ,     \" abcd \"  )  ;", "cache . put (  \" key _  3  \"  ,     \" abcd \"  )  ;", "cache . put (  \" key _  4  \"  ,     \" abcd \"  )  ;", "cache . put (  \" key _  5  \"  ,     \" abcd \"  )  ;", "long   len    =    cacheFile . length (  )  ;", "assertThat ( len ,    greaterThan (  0 L )  )  ;", "cache . put (  \" key _  1  \"  ,     \"  1  2  3  4  \"  )  ;", "assertThat ( cacheFile . length (  )  ,    equalTo ( len )  )  ;", "cache . remove (  \" key _  1  \"  )  ;", "cache . put (  \" key _ new \"  ,     \" a 1 b 2  \"  )  ;", "assertThat ( cacheFile . length (  )  ,    equalTo ( len )  )  ;", "cache . put (  \" key _ new \"  ,     \" longer   value \"  )  ;", "assertThat ( cacheFile . length (  )  ,    greaterThan ( len )  )  ;", "len    =    cacheFile . length (  )  ;", "cache . put (  \" key _  1  \"  ,     \"  1  2  3  4  \"  )  ;", "assertThat ( cacheFile . length (  )  ,    equalTo ( len )  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["reusesEmptySpaceWhenPuttingEntries"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "cacheFile    =    tmpDir . file (  \" cache . bin \"  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "cache . verify (  )  ;", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["verifyAndCloseCache"], "fileName": "org.gradle.cache.internal.btree.BTreePersistentIndexedCacheTest"}, {"methodBody": ["METHOD_START", "{", "payload . setBlock ( null )  ;", "payload    =    null ;", "}", "METHOD_END"], "methodName": ["detach"], "fileName": "org.gradle.cache.internal.btree.Block"}, {"methodBody": ["METHOD_START", "{", "return   BlockPointer . pos (  (  ( getPos (  )  . getPos (  )  )     +     ( getSize (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getNextPos"], "fileName": "org.gradle.cache.internal.btree.Block"}, {"methodBody": ["METHOD_START", "{", "return   payload ;", "}", "METHOD_END"], "methodName": ["getPayload"], "fileName": "org.gradle.cache.internal.btree.Block"}, {"methodBody": ["METHOD_START", "{", "return   getBlock (  )  . blockCorruptedException (  )  ;", "}", "METHOD_END"], "methodName": ["blockCorruptedException"], "fileName": "org.gradle.cache.internal.btree.BlockPayload"}, {"methodBody": ["METHOD_START", "{", "return   block ;", "}", "METHOD_END"], "methodName": ["getBlock"], "fileName": "org.gradle.cache.internal.btree.BlockPayload"}, {"methodBody": ["METHOD_START", "{", "return   getBlock (  )  . getNextPos (  )  ;", "}", "METHOD_END"], "methodName": ["getNextPos"], "fileName": "org.gradle.cache.internal.btree.BlockPayload"}, {"methodBody": ["METHOD_START", "{", "return   getBlock (  )  . getPos (  )  ;", "}", "METHOD_END"], "methodName": ["getPos"], "fileName": "org.gradle.cache.internal.btree.BlockPayload"}, {"methodBody": ["METHOD_START", "{", "this . block    =    block ;", "}", "METHOD_END"], "methodName": ["setBlock"], "fileName": "org.gradle.cache.internal.btree.BlockPayload"}, {"methodBody": ["METHOD_START", "{", "return   Longs . compare ( pos ,    o . pos )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.gradle.cache.internal.btree.BlockPointer"}, {"methodBody": ["METHOD_START", "{", "return   pos ;", "}", "METHOD_END"], "methodName": ["getPos"], "fileName": "org.gradle.cache.internal.btree.BlockPointer"}, {"methodBody": ["METHOD_START", "{", "return    ( pos )     <     0  ;", "}", "METHOD_END"], "methodName": ["isNull"], "fileName": "org.gradle.cache.internal.btree.BlockPointer"}, {"methodBody": ["METHOD_START", "{", "if    ( pos    <     (  -  1  )  )     {", "throw   new   CorruptedCacheException (  (  \" block   pointer   must   be    >  =     -  1  ,    but   was \"     +    pos )  )  ;", "}", "if    ( pos    =  =     (  -  1  )  )     {", "return    . NULL ;", "}", "return   new    ( pos )  ;", "}", "METHOD_END"], "methodName": ["pos"], "fileName": "org.gradle.cache.internal.btree.BlockPointer"}, {"methodBody": ["METHOD_START", "{", "return   BlockPointer . NULL ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.cache.internal.btree.BlockPointer"}, {"methodBody": ["METHOD_START", "{", "countingInputStream    =    null ;", "}", "METHOD_END"], "methodName": ["done"], "fileName": "org.gradle.cache.internal.btree.ByteInput"}, {"methodBody": ["METHOD_START", "{", "return   countingInputStream . getCount (  )  ;", "}", "METHOD_END"], "methodName": ["getBytesRead"], "fileName": "org.gradle.cache.internal.btree.ByteInput"}, {"methodBody": ["METHOD_START", "{", "file . seek ( offset )  ;", "bufferedStream . clear (  )  ;", "countingStream    =    new   CountingStream ( bufferedStream )  ;", "return   new   DataStream ( countingStream )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.cache.internal.btree.ByteInput"}, {"methodBody": ["METHOD_START", "{", "countingOutputStream . flush (  )  ;", "countingOutputStream    =    null ;", "}", "METHOD_END"], "methodName": ["done"], "fileName": "org.gradle.cache.internal.btree.ByteOutput"}, {"methodBody": ["METHOD_START", "{", "return   countingOutputStream . getCount (  )  ;", "}", "METHOD_END"], "methodName": ["getBytesWritten"], "fileName": "org.gradle.cache.internal.btree.ByteOutput"}, {"methodBody": ["METHOD_START", "{", "file . seek ( offset )  ;", "bufferedStream . clear (  )  ;", "countingStream    =    new   CountingStream ( bufferedStream )  ;", "return   new   DataStream ( countingStream )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.cache.internal.btree.ByteOutput"}, {"methodBody": ["METHOD_START", "{", "store . attach ( block )  ;", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "dirty . clear (  )  ;", "indexCache . clear (  )  ;", "store . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "flush (  )  ;", "indexCache . clear (  )  ;", "store . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "Iterator < BlockPayload >    iterator    =    dirty . values (  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "BlockPayload   block    =    iterator . next (  )  ;", "iterator . remove (  )  ;", "store . write ( block )  ;", "}", "store . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "return   cacheableBlockTypes . contains ( block . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["isCacheable"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "if    ( isCble ( block )  )     {", "indexBlockCput ( block . getPos (  )  ,    block )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeCache"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "if    ( cacheableBlockTypes . contains ( payloadType )  )     {", "return   payloadType . cast ( indexBlockCache . get ( pos )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["maybeGetFromCache"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "store . open ( initAction ,    factory )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "T   block    =    payloadType . cast ( dirty . get ( pos )  )  ;", "if    ( block    !  =    null )     {", "return   block ;", "}", "block    =    maybeGetFromCache ( pos ,    payloadType )  ;", "if    ( block    !  =    null )     {", "return   block ;", "}", "block    =    store . read ( pos ,    payloadType )  ;", "maybeCache ( block )  ;", "return   block ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "T   block    =    store . readFirst ( payloadType )  ;", "maybeCache ( block )  ;", "return   block ;", "}", "METHOD_END"], "methodName": ["readFirst"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "dirty . remove ( block . getPos (  )  )  ;", "if    ( isCacheable ( block )  )     {", "indexCache . remove ( block . getPos (  )  )  ;", "}", "store . remove ( block )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "store . attach ( block )  ;", "maybeCache ( block )  ;", "dirty . put ( block . getPos (  )  ,    block )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.btree.CachingBlockStore"}, {"methodBody": ["METHOD_START", "{", "long   pos    =    nextBlock ;", "nextBlock    +  =    length ;", "return   pos ;", "}", "METHOD_END"], "methodName": ["alloc"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( block . getBlock (  )  )     =  =    null )     {", "block . setBlock ( new    . BlockImpl ( block )  )  ;", "}", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "try    {", "file . setLength (  0  )  ;", "currentFileSize    =     0  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "next    =     0  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "try    {", "filose (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "this . factory    =    factory ;", "try    {", "File . getParentFile (  )  . mkdirs (  )  ;", "file    =    new   RandomAccessFile ( File ,     \" rw \"  )  ;", "output    =    new   ByteOutput ( file )  ;", "input    =    new   ByteInput ( file )  ;", "currentFileSize    =    file . length (  )  ;", "nextBlock    =    currentFileSize ;", "if    (  ( currentFileSize )     =  =     0  )     {", "runnable . run (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( pos . isNull (  )  )  ;", "try    {", "T   payload    =    payloadType . cast ( factory . create ( payloadType )  )  ;", ". BlockImpl   block    =    new    . BlockImpl ( payload ,    pos )  ;", "block . read (  )  ;", "return   payload ;", "}    catch    ( CorruptedCacheException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "return   read ( BlockPointer . pos (  0  )  ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["readFirst"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "FileBackedBlockStore . BlockImpl   blockImpl    =     (  ( FileBackedBlockStore . BlockImpl )     ( block . getBlock (  )  )  )  ;", "blockImpl . detach (  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "FileBackedBlockStore . BlockImpl   blockImpl    =     (  ( FileBackedBlockStore . BlockImpl )     ( block . getBlock (  )  )  )  ;", "try    {", "blockImpl . write (  )  ;", "}    catch    ( CorruptedCacheException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.btree.FileBackedBlockStore"}, {"methodBody": ["METHOD_START", "{", "store . attach ( block )  ;", "f . alloc ( block . getBlock (  )  )  ;", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "store . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "freeListBlock    =    null ;", "store . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "store . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "Runnable   freeListInitAction    =    new   Runnable (  )     {", "public   void   run (  )     {", "freeListBlock    =    new    . FreeListBlock (  )  ;", "store . write ( freeListBlock )  ;", "store . flush (  )  ;", "initAction . run (  )  ;", "}", "}  ;", "BlockStore . Factory   freeListFactory    =    new   BlockStore . Factory (  )     {", "public   Object   create ( Class <  ?    extends   BlockPayload >    type )     {", "if    ( type    =  =     (  . FreeListBlock . class )  )     {", "return   new    . FreeListBlock (  )  ;", "}", "return   factory . create ( type )  ;", "}", "}  ;", "store . open ( freeListInitAction ,    freeListFactory )  ;", "freeListBlock    =    store . readFirst (  . FreeListBlock . class )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "return   store . read ( pos ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "return   store . read ( freeListBlock . getNextPos (  )  ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["readFirst"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "Block   container    =    block . getBlock (  )  ;", "store . remove ( block )  ;", "f . add ( container . getPos (  )  ,    container . getSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "FreeListBlockStore . FreeListBlock   block    =    store . readFirst ( FreeListBlockStore . FreeListBlock . class )  ;", "verify ( block ,    Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( block . largestInNextBlock )     >    maxValue )     {", "throw   new   RuntimeException (  \" corrupt   free   list \"  )  ;", "}", "int   current    =     0  ;", "for    (  . FreeListEntry   entry    :    block . entries )     {", "if    (  ( entry . size )     >    maxValue )     {", "throw   new   RuntimeException (  \" corrupt   free   list \"  )  ;", "}", "if    (  ( entry . size )     <     ( block . largestInNextBlock )  )     {", "throw   new   RuntimeException (  \" corrupt   free   list \"  )  ;", "}", "if    (  ( entry . size )     <    current )     {", "throw   new   RuntimeException (  \" corrupt   free   list \"  )  ;", "}", "current    =    entry . size ;", "}", "if    (  !  ( block . nextBlock . isNull (  )  )  )     {", "verify ( store . read ( block . nextBlock ,     . FreeListBlock . class )  ,    block . largestInNextBlock )  ;", "}", "}", "METHOD_END"], "methodName": ["verify"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "attach ( block )  ;", "store . write ( block )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.btree.FreeListBlockStore"}, {"methodBody": ["METHOD_START", "{", "serializer . write ( encoder ,    key )  ;", "encoder . flush (  )  ;", "return   digestSam . getChecksum (  )  ;", "}", "METHOD_END"], "methodName": ["getHashCode"], "fileName": "org.gradle.cache.internal.btree.KeyHasher"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "b . attach ( block )  ;", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "b . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( open )  )     {", "return ;", "}", "open    =    false ;", "b . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "b . flush (  )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "return   open ;", "}", "METHOD_END"], "methodName": ["isOpen"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( open )  ;", "open    =    true ;", "b . open ( initAction ,    factory )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "return   b . read ( pos ,    payloadType )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "return   b . readFirst ( payloadType )  ;", "}", "METHOD_END"], "methodName": ["readFirst"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "b . remove ( block )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "assert   open ;", "b . write ( block )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.btree.StateCheckBlockStore"}, {"methodBody": ["METHOD_START", "{", "CacheOperationStack   stack    =    stackForThread . get (  )  ;", "if    ( stack    =  =    null )     {", "stack    =    new   CacheOperationStack (  )  ;", "stackForThread . set ( stack )  ;", "}", "return   stack ;", "}", "METHOD_END"], "methodName": ["getOrCreateStack"], "fileName": "org.gradle.cache.internal.cacheops.CacheAccessOperationsStack"}, {"methodBody": ["METHOD_START", "{", "CacheOperationStack   stack    =    stackForThread . get (  )  ;", "return    ( stack    !  =    null )     &  &     ( stack . isInCacheAction (  )  )  ;", "}", "METHOD_END"], "methodName": ["isInCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheAccessOperationsStack"}, {"methodBody": ["METHOD_START", "{", "CacheOperationStack   stack    =    stackForThread . get (  )  ;", "if    ( stack    =  =    null )     {", "throw   new   IllegalStateException (  \" Operation   stack   is   empty .  \"  )  ;", "}", "stack . popCacheAction (  )  ;", "if    ( stack . isEmpty (  )  )     {", "stackForThread . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["popCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheAccessOperationsStack"}, {"methodBody": ["METHOD_START", "{", "CacheOperationStack   stack    =    getOrCreateStack (  )  ;", "stack . pushCacheAction (  )  ;", "}", "METHOD_END"], "methodName": ["pushCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheAccessOperationsStack"}, {"methodBody": ["METHOD_START", "{", "if    (  ( operationCount )     =  =     0  )     {", "throw   new   IllegalStateException (  \"    stack   is   empty .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkNotEmpty"], "fileName": "org.gradle.cache.internal.cacheops.CacheOperationStack"}, {"methodBody": ["METHOD_START", "{", "return    ( operationCount )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.cache.internal.cacheops.CacheOperationStack"}, {"methodBody": ["METHOD_START", "{", "return    ( operationCount )     >     0  ;", "}", "METHOD_END"], "methodName": ["isInCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheOperationStack"}, {"methodBody": ["METHOD_START", "{", "checkNotEmpty (  )  ;", "( oCount )  -  -  ;", "}", "METHOD_END"], "methodName": ["popCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheOperationStack"}, {"methodBody": ["METHOD_START", "{", "( operationCount )  +  +  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["pushCacheAction"], "fileName": "org.gradle.cache.internal.cacheops.CacheOperationStack"}, {"methodBody": ["METHOD_START", "{", "long   creationNumber    =    new   Random (  )  . nextLong (  )  ;", "return   new    . SequenceNumberLockState ( creationNumber ,     (  -  1  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["createInitialState"], "fileName": "org.gradle.cache.internal.filelock.DefaultLockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "return    1  6  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.gradle.cache.internal.filelock.DefaultLockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "return    3  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.cache.internal.filelock.DefaultLockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "long   creationNumber    =    dataInput . readLong (  )  ;", "long   sequenceNumber    =    dataInput . readLong (  )  ;", "return   new    . SequenceNumberLockState ( creationNumber ,    sequenceNumber ,    sequenceNumber )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.filelock.DefaultLockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "DefaultLockStateSerializer . SequenceNumberLockState   state    =     (  ( DefaultLockStateSerializer . SequenceNumberLockState )     ( lockState )  )  ;", "dataOutput . writeLong ( state . creationNumber )  ;", "dataOutput . writeLong ( state . sequenceNumber )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.filelock.DefaultLockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "lockInfoAccess . clearLockInfo ( lockFileAccess )  ;", "}", "METHOD_END"], "methodName": ["clearLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "lockFileAccess . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   lockStateAccess . ensureLockState ( lockFileAccess )  ;", "}", "METHOD_END"], "methodName": ["ensureLockState"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "LockState   newState    =    lockState . completeUpdate (  )  ;", "lockStateAccess . writeState ( l ,    newState )  ;", "return   newState ;", "}", "METHOD_END"], "methodName": ["markClean"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "LockState   newState    =    lockState . beforeUpdate (  )  ;", "lockStateAccess . writeState ( l ,    newState )  ;", "return   newState ;", "}", "METHOD_END"], "methodName": ["markDirty"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   lockInfoAccess . readLockInfo ( lockFileAccess )  ;", "}", "METHOD_END"], "methodName": ["readLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   lockStateAccess . readState ( lockFileAccess )  ;", "}", "METHOD_END"], "methodName": ["readLockState"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   lockInfoAccess . tryLock ( lockFileAccess ,    shared )  ;", "}", "METHOD_END"], "methodName": ["tryLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "return   lockStateAccess . tryLock ( lockFileAccess ,    shared )  ;", "}", "METHOD_END"], "methodName": ["tryLockState"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "LockInfo   lockInfo    =    new   LockInfo (  )  ;", "lockInfo . port    =    port ;", "lockInfo . lockId    =    lockId ;", "lockInfo . pid    =    pid ;", "lockInfo . operation    =    operation ;", "lockInfoAccess . writeLockInfo ( l ,    lockInfo )  ;", "}", "METHOD_END"], "methodName": ["writeLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockFileAccess"}, {"methodBody": ["METHOD_START", "{", "lockFileAccess . setLength ( Math . min ( lockFileAccess . length (  )  ,    infoRegionPos )  )  ;", "}", "METHOD_END"], "methodName": ["clearLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockInfoAccess"}, {"methodBody": ["METHOD_START", "{", "if    (  ( lockFileAccess . length (  )  )     <  =     ( infoRegionPos )  )     {", "return   new    (  )  ;", "} else    {", "lockFileAccess . seek ( infoRegionPos )  ;", "DataInputStream   inputStream    =    new   DataInputStream ( new   BufferedInputStream ( new   RandomAccessFileInputStream ( lockFileAccess )  )  )  ;", "byte   protocolVersion    =    inputStream . readByte (  )  ;", "if    ( protocolVersion    !  =     ( lockInfoSerializer . getVersion (  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Unexpected   lock   protocol   found   in   lock   file .    Expected    % s ,    found    % s .  \"  ,    lockInfoSerializer . getVersion (  )  ,    protocolVersion )  )  ;", "}", "return   lockInfoSerializer . read ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["readLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockInfoAccess"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   lockFileAccess . getChannel (  )  . tryLock ( infoRegionPos ,     (  (  . INFORMATION _ REGION _ SIZE )     -     ( infoRegionPos )  )  ,    shared )  ;", "}    catch    ( OverlappingFileLockException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["tryLock"], "fileName": "org.gradle.cache.internal.filelock.LockInfoAccess"}, {"methodBody": ["METHOD_START", "{", "lockFileAccess . seek ( infoRegionPos )  ;", "DataOutputStream   outstr    =    new   DataOutputStream ( new   BufferedOutputStream ( new   RandomAccessFileOutputStream ( lockFileAccess )  )  )  ;", "outstr . writeByte ( lSerializer . getVersion (  )  )  ;", "lSerializer . write ( outstr ,    l )  ;", "outstr . flush (  )  ;", "lockFileAccess . setLength ( lockFileAccess . getFilePointer (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeLockInfo"], "fileName": "org.gradle.cache.internal.filelock.LockInfoAccess"}, {"methodBody": ["METHOD_START", "{", "return    3  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.cache.internal.filelock.LockInfoSerializer"}, {"methodBody": ["METHOD_START", "{", "LockInfo   out    =    new   LockInfo (  )  ;", "out . port    =    dataInput . readInt (  )  ;", "out . lockId    =    dataInput . readLong (  )  ;", "out . pid    =    dataInput . readUTF (  )  ;", "out . operation    =    dataInput . readUTF (  )  ;", "return   out ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.filelock.LockInfoSerializer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( inputString . length (  )  )     >     ( LockInfoSerializer . INFORMATION _ REGION _ DESCR _ CHUNK _ LIMIT )  )     {", "return   inputString . substring (  0  ,    LockInfoSerializer . INFORMATION _ REGION _ DESCR _ CHUNK _ LIMIT )  ;", "} else    {", "return   inputString ;", "}", "}", "METHOD_END"], "methodName": ["trimIfNecessary"], "fileName": "org.gradle.cache.internal.filelock.LockInfoSerializer"}, {"methodBody": ["METHOD_START", "{", "dataOutput . writeInt ( lockInfo . port )  ;", "dataOutput . writeLong ( lockInfo . lockId )  ;", "dataOutput . writeUTF ( trimIfNecessary ( lockInfo . pid )  )  ;", "dataOutput . writeUTF ( trimIfNecessary ( lockInfo . operation )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.filelock.LockInfoSerializer"}, {"methodBody": ["METHOD_START", "{", "return   mode ;", "}", "METHOD_END"], "methodName": ["getMode"], "fileName": "org.gradle.cache.internal.filelock.LockOptionsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   crossVersion ;", "}", "METHOD_END"], "methodName": ["isUseCrossVersionImplementation"], "fileName": "org.gradle.cache.internal.filelock.LockOptionsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   LockOptionsBuilder ( lockMode ,    false )  ;", "}", "METHOD_END"], "methodName": ["mode"], "fileName": "org.gradle.cache.internal.filelock.LockOptionsBuilder"}, {"methodBody": ["METHOD_START", "{", "crossVersion    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["useCrossVersionImplementation"], "fileName": "org.gradle.cache.internal.filelock.LockOptionsBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   LockOptionsBuilder ( mode ,    crossVersion )  ;", "}", "METHOD_END"], "methodName": ["withMode"], "fileName": "org.gradle.cache.internal.filelock.LockOptionsBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( lockFileAccess . length (  )  )     =  =     0  )     {", "state    =    protocol . createInitialState (  )  ;", "writeState ( lockFileAccess ,    state )  ;", "return   state ;", "} else    {", "return   readState ( lockFileAccess )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureLockState"], "fileName": "org.gradle.cache.internal.filelock.LockStateAccess"}, {"methodBody": ["METHOD_START", "{", "return   stateRegionSize ;", "}", "METHOD_END"], "methodName": ["getRegionEnd"], "fileName": "org.gradle.cache.internal.filelock.LockStateAccess"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    buffer    =    new   byte [ stateRegionSize ]  ;", "lockFileAccess . seek (  . REGION _ START )  ;", "int   readPos    =     0  ;", "while    ( readPos    <     ( buffer . length )  )     {", "int   nread    =    lockFileAccess . read ( buffer ,    readPos ,     (  ( buffer . length )     -    readPos )  )  ;", "if    ( nread    <     0  )     {", "break ;", "}", "readPos    +  =    nread ;", "}", "ByteArrayInputStream   inputStream    =    new   ByteArrayInputStream ( buffer ,     0  ,    readPos )  ;", "DataInputStream   dataInput    =    new   DataInputStream ( inputStream )  ;", "byte   protocolVersion    =    dataInput . readByte (  )  ;", "if    ( protocolVersion    !  =     ( protocol . getVersion (  )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Unexpected   lock   protocol   found   in   lock   file .    Expected    % s ,    found    % s .  \"  ,    protocol . getVersion (  )  ,    protocolVersion )  )  ;", "}", "return   protocol . read ( dataInput )  ;", "}    catch    ( EOFException   e )     {", "return   protocol . createInitialState (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readState"], "fileName": "org.gradle.cache.internal.filelock.LockStateAccess"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   lockFileAccess . getChannel (  )  . tryLock (  . REGION _ START ,    stateRegionSize ,    shared )  ;", "}    catch    ( OverlappingFileLockException   e )     {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["tryLock"], "fileName": "org.gradle.cache.internal.filelock.LockStateAccess"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   outstr    =    new   ByteArrayOutputStream (  )  ;", "DataOutputStream   dataOutput    =    new   DataOutputStream ( outstr )  ;", "dataOutput . writeByte ( protocol . getVersion (  )  )  ;", "protocol . write ( dataOutput ,    lockState )  ;", "dataOutput . flush (  )  ;", "lockFileAccess . seek (  . REGION _ START )  ;", "lockFileAccess . write ( outstr . toByteArray (  )  )  ;", "assert    ( lockFileAccess . getFilePointer (  )  )     =  =     ( stateRegionSize )  ;", "}", "METHOD_END"], "methodName": ["writeState"], "fileName": "org.gradle.cache.internal.filelock.LockStateAccess"}, {"methodBody": ["METHOD_START", "{", "return   new   Version 1 LockStateSerializer . DirtyFlagLockState ( true )  ;", "}", "METHOD_END"], "methodName": ["createInitialState"], "fileName": "org.gradle.cache.internal.filelock.Version1LockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.gradle.cache.internal.filelock.Version1LockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "return    1  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.cache.internal.filelock.Version1LockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "return   new   Version 1 LockStateSerializer . DirtyFlagLockState (  (  !  ( dataInput . readBoolean (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.cache.internal.filelock.Version1LockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "Version 1 LockStateSerializer . DirtyFlagLockState   state    =     (  ( Version 1 LockStateSerializer . DirtyFlagLockState )     ( lockState )  )  ;", "dataOutput . writeBoolean (  (  !  ( state . dirty )  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.cache.internal.filelock.Version1LockStateSerializer"}, {"methodBody": ["METHOD_START", "{", "unlocksConfirmedFrom . put ( lockId ,    port )  ;", ". LOGGER . debug (  \" Gradle   process   at   port    {  }    confirmed   unlock   request   for   lock   with   id    {  }  .  \"  ,    port ,    lockId )  ;", "}", "METHOD_END"], "methodName": ["acceptConfirmationAsLockRequester"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( stopped )     {", "throw   new   IllegalStateException (  \" Cannot   start   managing   file   c   because   this   handler   has   been   closed .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotStopped"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "assertNotStopped (  )  ;", "if    (  ( communicator )     =  =    null )     {", "communicator    =    new   mmunicator ( addressFactory )  ;", "}", "return   communicator ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCommunicator"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   Runnable (  )     {", "public   void   run (  )     {", "try    {", ". LOGGER . debug (  \" Starting   file   lock   listener   thread .  \"  )  ;", "doRun (  )  ;", "}    catch    ( Throwable   t )     {", ". LOGGER . error (  \" Problems   handling   incoming   cache   access   requests .  \"  ,    t )  ;", "}    finally    {", ". LOGGER . debug (  \" File   lock   listener   thread   completed .  \"  )  ;", "}", "}", "private   void   doRun (  )     {", "while    ( true )     {", "DatagramPacket   packet ;", "long   lockId ;", "try    {", "packet    =    communicator . receive (  )  ;", "lockId    =    communicator . decodeLockId ( packet )  ;", "}    catch    ( GracefullyStoppedException   e )     {", "return ;", "}", "lock . lock (  )  ;", ". ContendedAction   contendedAction    =    contendedActions . get ( lockId )  ;", "if    ( contendedAction    =  =    null )     {", "acceptConfirmationAsLockRequester ( lockId ,    packet . getPort (  )  )  ;", "} else    {", "if    (  !  ( contendedAction . running )  )     {", "startLockReleaseAsLockHolder ( contendedAction )  ;", "}", "communicator . confirmUnlockRequest ( packet )  ;", "}", "lock . unlock (  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["listener"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( Integer . valueOf ( port )  . equals ( unlocksConfirmedFrom . get ( lockId )  )  )     {", "return   false ;", "}", "if    (  ( Integer . valueOf ( port )  . equals ( unlocksRequestedFrom . get ( lockId )  )  )     &  &     ( timeElapsed    <     (  . PING _ DELAY )  )  )     {", "return   false ;", "}", "boolean   pingSentSuccessfully    =    getCommunicator (  )  . pingOwner ( port ,    lockId ,    displayName )  ;", "if    ( pingSentSuccessfully )     {", "lock . lock (  )  ;", "unlocksRequestedFrom . put ( lockId ,    port )  ;", "lock . unlock (  )  ;", "}", "return   pingSentSuccessfully ;", "}", "METHOD_END"], "methodName": ["maybePingOwner"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "return   getCommunicator (  )  . getPort (  )  ;", "}", "METHOD_END"], "methodName": ["reservePort"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "unlocksRequestedFrom . remove ( lockId )  ;", "unlocksConfirmedFrom . remove ( lockId )  ;", "try    {", "assertNotStopped (  )  ;", "if    (  ( communicator )     =  =    null )     {", "throw   new   IllegalStateException (  \" Must   initialize   the   handler   by   reserving   the   port   first .  \"  )  ;", "}", "if    (  ( fileLockRequestListener )     =  =    null )     {", "fileLockRequestListener    =    executorFactory . create (  \" File   lock   request   listener \"  )  ;", "fileLockRequestListener . execute ( listener (  )  )  ;", "}", "if    (  ( unlockActionExecutor )     =  =    null )     {", "unlockActionExecutor    =    executorFactory . create (  \" File   lock   release   action   executor \"  )  ;", "}", "if    ( contendedActions . containsKey ( lockId )  )     {", "throw   new   UnsupportedOperationException (  \" Multiple   contention   actions   for   a   given   lock   are   currently   not   supported .  \"  )  ;", "}", "contendedActions . put ( lockId ,    new    . ContendedAction ( whenContended )  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "contendedAction . running    =    true ;", "unlockActionExecutor . execute ( contendedAction . action )  ;", "}", "METHOD_END"], "methodName": ["startLockReleaseAsLockHolder"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "stopped    =    true ;", "contendedActions . clear (  )  ;", "if    (  ( communicator )     !  =    null )     {", "communicator . stop (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "if    (  ( fileLockRequestL    !  =    null )     {", "fileLockRequestLstop (  )  ;", "}", "if    (  ( unlockActionExecutor )     !  =    null )     {", "unlockActionExecutor . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "contendedActions . remove ( lockId )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.cache.internal.locklistener.DefaultFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    bytes    =    receivedPacket . getData (  )  ;", "DatamPacket   confirmPacket    =    new   DatamPacket ( bytes ,    bytes . length ,    receivedPacket . getAddress (  )  ,    receivedPacket . getPort (  )  )  ;", "socket . send ( confirmPacket )  ;", "}    catch    ( IOException   e )     {", "if    (  !  ( stopped )  )     {", "throw   new   RuntimeException ( e )  ;", "}", "throw   new   GracefullyStoppedException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["confirmUnlockRequest"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "DataInputStream   dataInput    =    new   DataInputStream ( new   ByteArrayInputStream ( bytes )  )  ;", "byte   version    =    dataInput . readByte (  )  ;", "if    ( version    !  =     (  . PROTOCOL _ VERSION )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Unexpected   protocol   version    % s   received   in   lock   contention   notification   message \"  ,    version )  )  ;", "}", "return   dataInput . readLong (  )  ;", "}", "METHOD_END"], "methodName": ["decode"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . decode ( receivedPacket . getData (  )  )  ;", "}    catch    ( IOException   e )     {", "if    (  !  ( stopped )  )     {", "throw   new   RuntimeException ( e )  ;", "}", "throw   new   GracefullyStoppedException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["decodeLockId"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   packet    =    new   ByteArrayOutputStream (  )  ;", "DataOutputStream   dataOutput    =    new   DataOutputStream ( packet )  ;", "dataOutput . writeByte (  . PROTOCOL _ VERSION )  ;", "dataOutput . writeLong ( lockId )  ;", "dataOutput . flush (  )  ;", "return   packet . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["encode"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "return   socket . getLocalPort (  )  ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    bytesToSend    =     . encode ( lockId )  ;", "for    ( InetAddress   address    :    addressFactory . getCommunicationAddresses (  )  )     {", "try    {", "socket . send ( new   DatagramPacket ( bytesToSend ,    bytesToSend . length ,    address ,    ownerPort )  )  ;", "}    catch    ( IOException   e )     {", "if    (  (  ( e . getMessage (  )  )     !  =    null )     &  &     ( e . getMessage (  )  . startsWith (  . SOCKET _ OPERATION _ NOT _ PERMITTED _ ERROR _ MESSAGE )  )  )     {", ". LOGGER . debug (  \" Failed   attempt   to   ping   owner   of   lock   for    {  }     ( lock   id :     {  }  ,    port :     {  }  ,    address :     {  }  )  \"  ,    displayName ,    lockId ,    ownerPort ,    address )  ;", "return   false ;", "} else    {", "throw   e ;", "}", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( String . format (  \" Failed   to   ping   owner   of   lock   for    % s    ( lock   id :     % s ,    port :     % s )  \"  ,    displayName ,    lockId ,    ownerPort )  ,    e )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["pingOwner"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "try    {", "byte [  ]    bytes    =    new   byte [  9  ]  ;", "DatamPacket   packet    =    new   DatamPacket ( bytes ,    bytes . length )  ;", "socket . receive ( packet )  ;", "return   packet ;", "}    catch    ( IOException   e )     {", "if    (  !  ( stopped )  )     {", "throw   new   RuntimeException ( e )  ;", "}", "throw   new   GracefullyStoppedException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["receive"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}, {"methodBody": ["METHOD_START", "{", "stopped    =    true ;", "set . close (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.cache.internal.locklistener.FileLockCommunicator"}]