[{"methodBody": ["METHOD_START", "{", "executingDsl . set ( true )  ;", "try    {", "ClosureedAction . execute ( this ,    action )  ;", "}    finally    {", "executingDsl . set ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "ModelPath   path    =     (  ( modelPath )     =  =    null )     ?    ModelPath . path ( name )     :    modelPath . child ( name )  ;", "return   new    ( executingDsl ,    path ,    modelRegistry )  ;", "}", "METHOD_END"], "methodName": ["getChildPath"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    args    =     (  ( Object [  ]  )     ( argsObj )  )  ;", "if    (  !  ( executingDsl . get (  )  )  )     {", "if    ( name . equals (  \"  $  \"  )  )     {", "throw   new   GradleException (  . ATTEMPTED _ INPUT _ SYNTAX _ USED _ MESSAGE )  ;", "} else    {", "throw   new   MissingMethodException ( name ,    getClass (  )  ,    args )  ;", "}", "} else    {", "if    (  (  ( args . length )     =  =     1  )     &  &     (  ( args [  0  ]  )    instanceof   Closure )  )     {", "Closure <  ?  >    closure    =     (  ( Closure )     ( args [  0  ]  )  )  ;", "getChildPath ( name )  . registerConfigurationAction ( closure )  ;", "return   null ;", "} else", "if    (  (  (  ( args . length )     =  =     2  )     &  &     (  ( args [  0  ]  )    instanceof   Class )  )     &  &     (  ( args [  1  ]  )    instanceof   Closure )  )     {", "Class <  ?  >    clazz    =     (  ( Class <  ?  >  )     ( args [  0  ]  )  )  ;", "Closure <  ?  >    closure    =     (  ( Closure <  ?  >  )     ( args [  1  ]  )  )  ;", "getChildPath ( name )  . register ( clazz ,    closure )  ;", "return   null ;", "} else", "if    (  (  ( args . length )     =  =     1  )     &  &     (  ( args [  0  ]  )    instanceof   Class )  )     {", "Class <  ?  >    clazz    =     (  ( Class <  ?  >  )     ( args [  0  ]  )  )  ;", "getChildPath ( name )  . register ( clazz ,    doNothing (  )  )  ;", "return   null ;", "} else    {", "throw   new   MissingMethodException ( name ,    getClass (  )  ,    args )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["methodMissing"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( executingDsl . get (  )  )  )     {", "throw   new   MissingPropertyException ( name ,    getClass (  )  )  ;", "}", "return   getChildPath ( name )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "register ( type ,    new   ClosureBackedAction < T >  ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "ModelRuleDescriptor   descriptor    =    new   SimpleModelRuleDescriptor (  (  \" model .  \"     +     ( modelPath )  )  )  ;", "NodeInitializerRegistry   nodeInitializerRegistry    =    modelRegistry . realize ( DEFAULT _ REFERENCE . getPath (  )  ,    DEFAULT _ REFERENCE . getType (  )  )  ;", "ModelType < T >    modelType    =    ModelType . of ( type )  ;", "NodeInitializer   nodeInitializer    =    nodeInitializerRegistry . getNodeInitializer ( forType ( modelType )  )  ;", "modelRegistry . register ( of ( modelPath ,    nodeInitializer )  . descriptor ( descriptor )  . action ( ModelActionRole . Initialize ,    of ( of ( modelPath ,    modelType )  ,    descriptor ,    action )  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "modelRegistry . configure ( Mutate ,    new   NoInputsModelAction < Object >  ( ModelReference . untyped ( modelPath )  ,    new   SimpleModelRuleDescriptor (  (  \" model .  \"     +     ( modelPath )  )  )  ,    new   ClosureBackedAction < Object >  ( action )  )  )  ;", "}", "METHOD_END"], "methodName": ["registerConfigurationAction"], "fileName": "org.gradle.model.dsl.internal.NonTransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "ModelPath   modelPath    =    ModelPath . path ( modelPathString )  ;", "DeferrAction   modelAction    =    ruleFactory . toAction ( Object . class ,    closure )  ;", "registerAction ( modelPath ,    UNTYPED ,    Mutate ,    modelAction )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.model.dsl.internal.TransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "ModelPath   modelPath    =    ModelPath . path ( modelPathString )  ;", "DeferredModelAction   modelAction    =    ruleFactory . toAction ( type ,    closure )  ;", "ModelRuleDescriptor   descriptor    =    modelAction . getDescriptor (  )  ;", "ModelType < T >    modelType    =    ModelType . of ( type )  ;", "try    {", "NodeInitializerRegistry   nodeInitializerRegistry    =    modelRegistry . realize ( DEFAULT _ REFERENCE . getPath (  )  ,    DEFAULT _ REFERENCE . getType (  )  )  ;", "NodeInitializer   nodeInitializer    =    nodeInitializerRegistry . getNodeInitializer ( forType ( modelType )  )  ;", "modelRegistry . register ( ModelRegistrations . of ( modelPath ,    nodeInitializer )  . descriptor ( descriptor )  . build (  )  )  ;", "}    catch    ( ModelTypeInitializationException   e )     {", "throw   new   InvalidModelRuleDeclarationException ( descriptor ,    e )  ;", "}", "registerAction ( modelPath ,    modelType ,    Initialize ,    modelAction )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.model.dsl.internal.TransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    closureClass    =    closure . getClass (  )  ;", "RulesBlock   annotation    =    closureClass . getAnnotation ( RulesBlock . class )  ;", "return   annotation    !  =    null ;", "}", "METHOD_END"], "methodName": ["isTransformedBlock"], "fileName": "org.gradle.model.dsl.internal.TransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "ModelReference < T >    reference    =    ModelReference . of ( modelPath ,    viewType )  ;", "modelRegistry . configure ( Initialize ,    DirectNodeNoInputsModelAction . of ( reference ,    action . getDescriptor (  )  ,    new   api . Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   node )     {", "action . execute ( node ,    role )  ;", "}", "}  )  )  ;", "}", "METHOD_END"], "methodName": ["registerAction"], "fileName": "org.gradle.model.dsl.internal.TransformedModelDslBacking"}, {"methodBody": ["METHOD_START", "{", "return   views . get ( inputIndex )  . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.dsl.internal.inputs.PotentialInput"}, {"methodBody": ["METHOD_START", "{", "PotentialInput   potentialInput    =    inputs . get ( path )  ;", "if    ( potentialInput    =  =    null )     {", "throw   new   IllegalStateException (  (  \" no   input   for    \"     +    path )  )  ;", "}", "return   potentialInput . get ( modelViews )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.model.dsl.internal.inputs.PotentialInputs"}, {"methodBody": ["METHOD_START", "{", "return   factory    =  =    null    ?    closure    :    factory . toAction ( Object . class ,    closure )  ;", "}", "METHOD_END"], "methodName": ["decorate"], "fileName": "org.gradle.model.dsl.internal.transform.ClosureBackedRuleFactory"}, {"methodBody": ["METHOD_START", "{", "final   TransformedClosure   transformedClosure    =     (  ( TransformedClosure )     ( closure )  )  ;", "SourceLocation   sourceLocation    =    ruleLocationExtractor . transform ( transformedClosure )  ;", "final   ModelRuleDescriptor   descriptor    =    sourceLocation . asDescriptor (  )  ;", "return   new   DeferredModelAction (  )     {", "@ Override", "public   ModelRuleDescriptor   getDescriptor (  )     {", "return   descriptor ;", "}", "@ Override", "public   void   execute ( MutableModelNode   node ,    ModelActionRole   role )     {", "final   boolean   supportsNestedRules    =    node . canBeViewedAs (  . MANAGED _ INSTANCE _ TYPE )  ;", "InputReferences   inputs    =    transformedClosure . inputReferences (  )  ;", "List < InputReference >    inputReferences    =     ( supportsNestedRules )     ?    inputs . getOwnReferences (  )     :    inputs . getAllReferences (  )  ;", "final   Map < String ,    PotentialInput >    inputValues    =    Maps . newLinkedHashMap (  )  ;", "List < ModelReference <  ?  >  >    inputModelReferences    =    Lists . newArrayList (  )  ;", "for    ( InputReference   inputReference    :    inputReferences )     {", "String   description    =     \"  @    line    \"     +     ( inputReference . getLineNumber (  )  )  ;", "String   path    =    inputReference . getPath (  )  ;", "if    (  !  ( inputValues . containsKey ( path )  )  )     {", "inputValues . put ( path ,    new   PotentialInput ( inputModelReferences . size (  )  )  )  ;", "inputModelReferences . add ( ModelReference . untyped ( ModelPath . path ( path )  ,    description )  )  ;", "}", "}", "node . applyToSelf ( role ,    InputUsingModelAction . of ( ModelReference . of ( node . getPath (  )  ,    subjectType )  ,    descriptor ,    inputModelReferences ,    new   BiAction < T ,    List < ModelView <  ?  >  >  >  (  )     {", "@ Override", "public   void   execute ( T   t ,    List < ModelView <  ?  >  >    modelViews )     {", "Closure <  ?  >    cloned    =    closure . rehydrate ( null ,    closure . getThisObject (  )  ,    closure . getThisObject (  )  )  ;", "(  ( TransformedClosure )     ( cloned )  )  . makeRule ( new   PotentialInputs ( modelViews ,    inputValues )  ,     ( supportsNestedRules    ?     . this    :    null )  )  ;", "ClosureBackedAction . execute ( t ,    cloned )  ;", "}", "}  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["toAction"], "fileName": "org.gradle.model.dsl.internal.transform.ClosureBackedRuleFactory"}, {"methodBody": ["METHOD_START", "{", "return   lineNumber ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.gradle.model.dsl.internal.transform.InputReference"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.model.dsl.internal.transform.InputReference"}, {"methodBody": ["METHOD_START", "{", "nestedReferences . addAll ( inputReferences . getOwnReferences (  )  )  ;", "nestedReferences . addAll ( inputReferences . getNestedReferences (  )  )  ;", "}", "METHOD_END"], "methodName": ["addNestedReferences"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "List < InputReference >    result    =    new   ArrayList < InputReference >  (  (  ( ownReferences . size (  )  )     +     ( nestedReferences . size (  )  )  )  )  ;", "result . addAll ( ownReferences )  ;", "result . addAll ( nestedReferences )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllReferences"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "return   nestedReferences ;", "}", "METHOD_END"], "methodName": ["getNestedReferences"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "return   ownReferences ;", "}", "METHOD_END"], "methodName": ["getOwnReferences"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "return    ( ownReferences . isEmpty (  )  )     &  &     ( nestedReferences . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "nestedReferences . add ( new   InputReference ( path ,    lineNumber )  )  ;", "}", "METHOD_END"], "methodName": ["nestedReference"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "ownReferences . add ( new   InputReference ( path ,    lineNumber )  )  ;", "}", "METHOD_END"], "methodName": ["ownReference"], "fileName": "org.gradle.model.dsl.internal.transform.InputReferences"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "if    (  !  ( expression . isImplicitThis (  )  )  )     {", "builder . append ( expression . getObjectExpression (  )  . getText (  )  )  ;", "builder . append (  '  .  '  )  ;", "}", "builder . append ( expression . getMethodAsString (  )  )  ;", "if    (  ( expression . getArguments (  )  )    instanceof   ArgumentListExpression )     {", "ArgumentListExpression   arguments    =     (  ( ArgumentListExpression )     ( expression . getArguments (  )  )  )  ;", "boolean   hasTrailingClosure    =     (  !  ( arguments . getExpressions (  )  . isEmpty (  )  )  )     &  &     (  ( arguments . getExpression (  (  ( arguments . getExpressions (  )  . size (  )  )     -     1  )  )  )    instanceof   ClosureExpression )  ;", "List < Expression >    otherArgs    =     ( hasTrailingClosure )     ?    arguments . getExpressions (  )  . subList (  0  ,     (  ( arguments . getExpressions (  )  . size (  )  )     -     1  )  )     :    arguments . getExpressions (  )  ;", "if    (  (  !  ( otherArgs . isEmpty (  )  )  )     |  |     (  ! hasTrailingClosure )  )     {", "builder . append (  \"  (  \"  )  ;", "builder . append ( Joiner . on (  \"  ,     \"  )  . join ( CollectionUtils . collect ( otherArgs ,    new   api . Transformer < Object ,    Expression >  (  )     {", "@ Override", "public   Object   transform ( Expression   expression )     {", "return   expression . getText (  )  ;", "}", "}  )  )  )  ;", "builder . append (  \"  )  \"  )  ;", "}", "if    ( hasTrailingClosure )     {", "builder . append (  \"     {     .  .  .     }  \"  )  ;", "}", "} else    {", "builder . append (  \"  (  )  \"  )  ;", "}", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["displayName"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "SyntaxException   syntaxException    =    new   SyntaxException ( message ,    call . getLineNumber (  )  ,    call . getColumnNumber (  )  )  ;", "sourceUnit . getErrorCollec (  )  . addError ( syntaxException ,    sourceUnit )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "return   new   MethodCallExpression ( new   VariableExpression ( inputsVariable )  ,    new   ConstantExpression ( RuleVisitor . GET )  ,    new   ArgumentListExpression ( new   ConstantExpression ( modelPath )  )  )  ;", "}", "METHOD_END"], "methodName": ["inputReferenceExpression"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( expr . isSafe (  )  )     |  |     ( expr . isSpreadSafe (  )  )  )     {", "return   null ;", "}", "if    (  ( expr . getObjectExpression (  )  )    instanceof   VariableExpression )     {", "VariableExpression   objectExpression    =     (  ( VariableExpression )     ( expr . getObjectExpression (  )  )  )  ;", "if    ( objectExpression . getName (  )  . equals (  . DOLLAR )  )     {", "return   expr . getPropertyAsString (  )  ;", "} else    {", "return   null ;", "}", "}", "if    (  ( expr . getObjectExpression (  )  )    instanceof   PropertyExpression )     {", "PropertyExpression   objectExpression    =     (  ( PropertyExpression )     ( expr . getObjectExpression (  )  )  )  ;", "String   path    =    isDollarPathExpression ( objectExpression )  ;", "if    ( path    !  =    null )     {", "return    ( path    +     '  .  '  )     +     ( expr . getPropertyAsString (  )  )  ;", "} else    {", "return   null ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["isDollarPathExpression"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "MethodNode   closureCallMethod    =    AstUtils . getGeneratedClosureImplMethod ( node )  ;", "Statement   closureCode    =    closureCallMethod . getCode (  )  ;", "InputReferences   inputs    =    closureCode . getNodeMetaData (  . AST _ NODE _ METADATA _ INPUTS _ KEY )  ;", "if    ( inputs    !  =    null )     {", "SourceLocation   sourceLocation    =    closureCode . getNodeMetaData (  . AST _ NODE _ METADATA _ LOCATION _ KEY )  ;", "node . addInterface (  . TRANSFORMED _ CLOSURE )  ;", "FieldNode   inputsField    =    new   FieldNode (  . INPUTS _ FIELD _ NAME ,    Modifier . PRIVATE ,     . POTENTIAL _ INPUTS ,    node ,    null )  ;", "FieldNode   ruleFactoryField    =    new   FieldNode (  . RULE _ FACTORY _ FIELD _ NAME ,    Modifier . PRIVATE ,     . RULE _ FACTORY ,    node ,    null )  ;", "node . addField ( inputsField )  ;", "node . addField ( ruleFactoryField )  ;", "List < Statement >    statements    =    new   ArrayList < Statement >  (  )  ;", "statements . add ( new   ExpressionStatement ( new   BinaryExpression ( new   FieldExpression ( inputsField )  ,     . ASSIGN ,    new   VariableExpression (  \" inputs \"  )  )  )  )  ;", "statements . add ( new   ExpressionStatement ( new   BinaryExpression ( new   FieldExpression ( ruleFactoryField )  ,     . ASSIGN ,    new   VariableExpression (  \" ruleFactory \"  )  )  )  )  ;", "node . addMethod ( new   MethodNode (  \" makeRule \"  ,    Modifier . PUBLIC ,    ClassHelper . VOID _ TYPE ,    new   Parameter [  ]  {    new   Parameter (  . POTENTIAL _ INPUTS ,     \" inputs \"  )  ,    new   Parameter (  . RULE _ FACTORY ,     \" ruleFactory \"  )     }  ,    new   ClassNode [  0  ]  ,    new   BlockStatement ( statements ,    new   VariableScope (  )  )  )  )  ;", "VariableExpression   inputsVar    =    new   VariableExpression (  \" inputs \"  ,     . INPUT _ REFERENCES )  ;", "VariableScope   methodVarScope    =    new   VariableScope (  )  ;", "methodVarScope . putDeclaredVariable ( inputsVar )  ;", "statements    =    new   ArrayList < Statement >  (  )  ;", "statements . add ( new   ExpressionStatement ( new   DeclarationExpression ( inputsVar ,     . ASSIGN ,    new   ConstructorCallExpression (  . INPUT _ REFERENCES ,    new   ArgumentListExpression (  )  )  )  )  )  ;", "for    ( InputReference   inputReference    :    inputs . getOwnReferences (  )  )     {", "statements . add ( new   ExpressionStatement ( new   MethodCallExpression ( inputsVar ,     \" ownReference \"  ,    new   ArgumentListExpression ( new   ConstantExpression ( inputReference . getPath (  )  )  ,    new   ConstantExpression ( inputReference . getLineNumber (  )  )  )  )  )  )  ;", "}", "for    ( InputReference   inputReference    :    inputs . getNestedReferences (  )  )     {", "statements . add ( new   ExpressionStatement ( new   MethodCallExpression ( inputsVar ,     \" nestedReference \"  ,    new   ArgumentListExpression ( new   ConstantExpression ( inputReference . getPath (  )  )  ,    new   ConstantExpression ( inputReference . getLineNumber (  )  )  )  )  )  )  ;", "}", "statements . add ( new   ReturnStatement ( inputsVar )  )  ;", "node . addMethod ( new   MethodNode (  \" inputReferences \"  ,    Modifier . PUBLIC ,     . INPUT _ REFERENCES ,    new   Parameter [  0  ]  ,    new   ClassNode [  0  ]  ,    new   BlockStatement ( statements ,    methodVarScope )  )  )  ;", "statements    =    new   ArrayList < Statement >  (  )  ;", "statements . add ( new   ReturnStatement ( new   ConstructorCallExpression (  . SOURCE _ LOCATION ,    new   ArgumentListExpression ( Arrays .  < Expression > asList ( new   ConstantExpression (  . SOURCE _ URI _ TOKEN )  ,    new   ConstantExpression (  . SOURCE _ DESC _ TOKEN )  ,    new   ConstantExpression ( sourceLocation . getExpression (  )  )  ,    new   ConstantExpression ( sourceLocation . getLineNumber (  )  )  ,    new   ConstantExpression ( sourceLocation . getColumnNumber (  )  )  )  )  )  )  )  ;", "node . addMethod ( new   MethodNode (  \" sourceLocation \"  ,    Modifier . PUBLIC ,     . SOURCE _ LOCATION ,    new   Parameter [  0  ]  ,    new   ClassNode [  0  ]  ,    new   BlockStatement ( statements ,    new   VariableScope (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitGeneratedClosure"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "ConstantExpression   argExpression    =    AstUtils . hasSingleConstantStringArg ( call )  ;", "if    ( argExpression    =  =    null )     {", "error ( call ,     . INVALID _ ARGUMENT _ LIST )  ;", "} else    {", "String   modelPath    =    argExpression . getText (  )  ;", "if    ( modelPath . isEmpty (  )  )     {", "error ( argExpression ,     . INVALID _ ARGUMENT _ LIST )  ;", "return ;", "}", "try    {", "ModelPath . validatePath ( modelPath )  ;", "}    catch    ( ModelPath   e )     {", "String   message    =     (  (  \" Invalid   model   path   given   as   rule   input .  \"     +     ( SystemProperties . getInstance (  )  . getLineSeparator (  )  )  )     +     \"        >     \"  )     +     ( e . getMessage (  )  )  ;", "if    (  ( e . getCause (  )  )     !  =    null )     {", "message    +  =     (  ( SystemProperties . getInstance (  )  . getLineSeparator (  )  )     +     \"              >     \"  )     +     ( e . getCause (  )  . getMessage (  )  )  ;", "}", "error ( argExpression ,    message )  ;", "return ;", "}", "inputs . ownReference ( modelPath ,    call . getLineNumber (  )  )  ;", "replaceVisitedExpressionWith ( inputReferenceExpression ( modelPath )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitInputMethod"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "InputReferences   parentInputs    =    inputs ;", "VariableExpression   parentInputsVariable    =    inputsVariable ;", "try    {", "inputs    =    new   InputReferences (  )  ;", "inputsVariable    =    new   VariableExpression (  (  \"  _  _ rule _ inputs _ var _  \"     +     (  ( counter )  +  +  )  )  ,     . POTENTIAL _ INPUTS )  ;", "inputsVariable . setClosureSharedVariable ( true )  ;", "super . visitClosureExpression ( expression )  ;", "BlockStatement   code    =     (  ( BlockStatement )     ( expression . getCode (  )  )  )  ;", "code . setNodeMetaData (  . AST _ NODE _ METADATA _ LOCATION _ KEY ,    new   SourceLocation ( location ,    scriptSourceDescription ,    invocationDisplayName ,    invocation . getLineNumber (  )  ,    invocation . getColumnNumber (  )  )  )  ;", "code . setNodeMetaData (  . AST _ NODE _ METADATA _ INPUTS _ KEY ,    inputs )  ;", "if    ( parentInputsVariable    !  =    null )     {", "expression . getVariableScope (  )  . putReferencedLocalVariable ( parentInputsVariable )  ;", "}", "code . getVariableScope (  )  . putDeclaredVariable ( inputsVariable )  ;", "if    ( parentInputsVariable    =  =    null )     {", "DeclarationExpression   variableDeclaration    =    new   DeclarationExpression ( inputsVariable ,     . ASSIGN ,    new   VariableExpression (  . INPUTS _ FIELD _ NAME )  )  ;", "code . getStatements (  )  . add (  0  ,    new   ExpressionStatement ( variableDeclaration )  )  ;", "} else    {", "DeclarationExpression   variableDeclaration    =    new   DeclarationExpression ( inputsVariable ,     . ASSIGN ,    new   ElvisOperatorExpression ( new   VariableExpression (  . INPUTS _ FIELD _ NAME )  ,    parentInputsVariable )  )  ;", "code . getStatements (  )  . add (  0  ,    new   ExpressionStatement ( variableDeclaration )  )  ;", "}", "for    ( Parameter   parameter    :    expression . getParameters (  )  )     {", "if    ( parameter . hasInitialExpression (  )  )     {", "code . getStatements (  )  . add (  1  ,    new   ExpressionStatement ( new   BinaryExpression ( new   VariableExpression ( parameter . getName (  )  )  ,     . ASSIGN ,    parameter . getInitialExpression (  )  )  )  )  ;", "parameter . setInitialExpression ( NULL )  ;", "}", "}", "}    finally    {", "if    ( parentInputs    !  =    null )     {", "parentInputs . addNestedReferences ( inputs )  ;", "}", "inputs    =    parentInputs ;", "inputsVariable    =    parentInputsVariable ;", "}", "}", "METHOD_END"], "methodName": ["visitRuleClosure"], "fileName": "org.gradle.model.dsl.internal.transform.RuleVisitor"}, {"methodBody": ["METHOD_START", "{", "Expression   target    =    call . getMethod (  )  ;", "List < String >    names    =    Lists . newLinkedList (  )  ;", "while    ( true )     {", "if    ( target   instanceof   ConstantExpression )     {", "if    ( target . getType (  )  . equals ( STRING _ TYPE )  )     {", "String   name    =    target . getText (  )  ;", "names . add (  0  ,    name )  ;", "if    ( call . isImplicitThis (  )  )     {", "break ;", "} else    {", "target    =    call . getObjectExpression (  )  ;", "continue ;", "}", "}", "} else", "if    ( target   instanceof   codehaus . groovy . ast . expr . PropertyExpression )     {", "codehaus . groovy . ast . expr . PropertyExpression   propertyExpression    =     (  ( codehaus . groovy . ast . expr . PropertyExpression )     ( target )  )  ;", "Expression   property    =    propertyExpression . getProperty (  )  ;", "if    ( property   instanceof   ConstantExpression )     {", "ConstantExpression   constantProperty    =     (  ( ConstantExpression )     ( property )  )  ;", "if    ( constantProperty . getType (  )  . equals ( STRING _ TYPE )  )     {", "String   name    =    constantProperty . getText (  )  ;", "names . add (  0  ,    name )  ;", "target    =    propertyExpression . getObjectExpression (  )  ;", "continue ;", "}", "}", "} else", "if    ( target   instanceof   codehaus . groovy . ast . expr . VariableExpression )     {", "names . add (  0  ,     (  ( codehaus . groovy . ast . expr . VariableExpression )     ( target )  )  . getName (  )  )  ;", "break ;", "}", "restrict ( call )  ;", "return   null ;", "}", "return   ModelPath . pathString ( Iterables . toArray ( names ,    String . class )  )  ;", "}", "METHOD_END"], "methodName": ["extractModelPathFromMethodTarget"], "fileName": "org.gradle.model.dsl.internal.transform.RulesVisitor"}, {"methodBody": ["METHOD_START", "{", "ConstantExpression   modelPathArgument    =    new   ConstantExpression ( modelPath )  ;", "ArgumentListExpression   replacedArgumentList    =    new   ArgumentListExpression ( modelPathArgument ,    closureExpression )  ;", "call . setMethod ( new   ConstantExpression (  \" configure \"  )  )  ;", "call . setArguments ( replacedArgumentList )  ;", "call . setImplicitThis ( true )  ;", "call . setObjectExpression ( new   MethodCallExpression ( VariableExpression . THIS _ EXPRESSION ,     \" getDelegate \"  ,    ArgumentListExpression . EMPTY _ ARGUMENTS )  )  ;", "rule . visitRuleClosure ( closureExpression ,    call ,    displayName )  ;", "}", "METHOD_END"], "methodName": ["rewriteAction"], "fileName": "org.gradle.model.dsl.internal.transform.RulesVisitor"}, {"methodBody": ["METHOD_START", "{", "ConstantExpression   modelPathArgument    =    new   ConstantExpression ( modelPath )  ;", "ArgumentListExpression   replacedArgumentList    =    new   ArgumentListExpression ( modelPathArgument ,    typeExpression ,    closureExpression )  ;", "call . setMethod ( new   ConstantExpression (  \" create \"  )  )  ;", "call . setArguments ( replacedArgumentList )  ;", "call . setImplicitThis ( true )  ;", "call . setObjectExpression ( new   MethodCallExpression ( VariableExpression . THIS _ EXPRESSION ,     \" getDelegate \"  ,    ArgumentListExpression . EMPTY _ ARGUMENTS )  )  ;", "rule . visitRuleClosure ( closureExpression ,    call ,    displayName )  ;", "}", "METHOD_END"], "methodName": ["rewriteCreator"], "fileName": "org.gradle.model.dsl.internal.transform.RulesVisitor"}, {"methodBody": ["METHOD_START", "{", "MethodNode   method    =    AstUtils . getGeneratedClosureImplMethod ( node )  ;", "Boolean   isRulesBlock    =    method . getCode (  )  . getNodeMetaData (  . AST _ NODE _ METADATA _ KEY )  ;", "if    ( isRulesBlock    !  =    null )     {", "AnnotationNode   markerAnnotation    =    new   AnnotationNode (  . ANNOTATION _ CLASS _ NODE )  ;", "node . addAnnotation ( markerAnnotation )  ;", "}", "}", "METHOD_END"], "methodName": ["visitGeneratedClosure"], "fileName": "org.gradle.model.dsl.internal.transform.RulesVisitor"}, {"methodBody": ["METHOD_START", "{", "return   new   SimpleModelRuleDescriptor (  (  (  ( expression )     +     \"     @     \"  )     +     ( toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asDescriptor"], "fileName": "org.gradle.model.dsl.internal.transform.SourceLocation"}, {"methodBody": ["METHOD_START", "{", "return   columnNumber ;", "}", "METHOD_END"], "methodName": ["getColumnNumber"], "fileName": "org.gradle.model.dsl.internal.transform.SourceLocation"}, {"methodBody": ["METHOD_START", "{", "return   expression ;", "}", "METHOD_END"], "methodName": ["getExpression"], "fileName": "org.gradle.model.dsl.internal.transform.SourceLocation"}, {"methodBody": ["METHOD_START", "{", "return   lineNumber ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.gradle.model.dsl.internal.transform.SourceLocation"}, {"methodBody": ["METHOD_START", "{", "return   uri ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.gradle.model.dsl.internal.transform.SourceLocation"}]