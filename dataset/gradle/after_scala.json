[{"methodBody": ["METHOD_START", "{", "return   allScala ;", "}", "METHOD_END"], "methodName": ["getAllScala"], "fileName": "org.gradle.api.internal.tasks.DefaultScalaSourceSet"}, {"methodBody": ["METHOD_START", "{", "return   scala ;", "}", "METHOD_END"], "methodName": ["getScala"], "fileName": "org.gradle.api.internal.tasks.DefaultScalaSourceSet"}, {"methodBody": ["METHOD_START", "{", "configure ( configureClosure ,    getScala (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["scala"], "fileName": "org.gradle.api.internal.tasks.DefaultScalaSourceSet"}, {"methodBody": ["METHOD_START", "{", "antBuilder . withClasspath ( scalaClasspath )  . execute ( new   groovy . lang . Closure < Object >  ( this )     {", "@ SuppressWarnings (  \" unused \"  )", "public   Object   doCall ( final   AntBuilderDelegate   ant )     {", "ant . invokeMethod (  \" taskdef \"  ,    Collections . singletonMap (  \" resource \"  ,     \" scala / tools / ant / antlib . xml \"  )  )  ;", "Builder < String ,    Object >    optionsBuilder    =    ImmutableMap . builder (  )  ;", "optionsBuilder . put (  \" destDir \"  ,    targetDir )  ;", "optionsBuilder . putAll ( docOptions . optionMap (  )  )  ;", "ImmutableMap < String ,    Object >    options    =    optionsBuilder . build (  )  ;", "return   ant . invokeMethod (  \" scaladoc \"  ,    new   Object [  ]  {    options ,    new   groovy . lang . Closure < Void >  ( this )     {", "public   void   doCall (  )     {", "source . addToAntBuilder ( ant ,     \" src \"  ,    MatchingTask )  ;", "for    ( File   file    :    bootclasspathFiles )     {", "ant . invokeMethod (  \" bootclasspath \"  ,    Collections . singletonMap (  \" location \"  ,    file )  )  ;", "}", "for    ( File   dir    :    extensionDirs )     {", "ant . invokeMethod (  \" extdirs \"  ,    Collections . singletonMap (  \" location \"  ,    dir )  )  ;", "}", "for    ( File   file    :    classpathFiles )     {", "ant . invokeMethod (  \" classpath \"  ,    Collections . singletonMap (  \" location \"  ,    file )  )  ;", "}", "}", "}     }  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.scala.AntScalaDoc"}, {"methodBody": ["METHOD_START", "{", "Set < File >    scalaClasspathFiles    =    scalaClasspath . getFiles (  )  ;", "Set < File >    zincClasspathFiles    =    zincClasspath . getFiles (  )  ;", "Compiler < ScalaJavaJointCompileSpec >    scalaCompiler    =    new   Daemon < ScalaJavaJointCompileSpec >  ( daemonWorkingDir ,    new   Zinc ( scalaClasspathFiles ,    zincClasspathFiles ,    gradleUserHomeDir )  ,    workerDaemonFactory ,    zincClasspathFiles ,    fileResolver )  ;", "return   new   Normalizing ( scalaCompiler )  ;", "}", "METHOD_END"], "methodName": ["newCompiler"], "fileName": "org.gradle.api.internal.tasks.scala.ScalaCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( JavaBasePlugin . class )  ;", ". configureConfigurations ( project )  ;", "ScalaRuntime   scalaRuntime    =     . configureScalaRuntimeExtension ( project )  ;", ". configureCompileDefaults ( project ,    scalaRuntime )  ;", ". configureSourceSetDefaults ( project ,    sourceDirectorySetFactory )  ;", ". configureScaladoc ( project ,    scalaRuntime )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( ScalaCompile . class ,    new   Action < ScalaCompile >  (  )     {", "@ Override", "public   void   execute ( final   ScalaCompile   compile )     {", "compile . getConventionMapping (  )  . map (  \" scalaClasspath \"  ,    new   Callable < FileCollection >  (  )     {", "@ Override", "public   FileCollection   call (  )    throws   Exception    {", "return   scalaRuntime . inferScalaClasspath ( compile . getClasspath (  )  )  ;", "}", "}  )  ;", "compile . getConventionMapping (  )  . map (  \" zincClasspath \"  ,    new   Callable < Configuration >  (  )     {", "@ Override", "public   Configuration   call (  )    throws   Exception    {", "Configuration   config    =    project . getConfigurations (  )  . getAt ( ScalaBasePlugin . ZINC _ CONFIGURATION _ NAME )  ;", "if    ( config . getDependencies (  )  . isEmpty (  )  )     {", "project . getDependencies (  )  . add (  \" zinc \"  ,     (  \" com . typesafe . zinc : zinc :  \"     +     ( DefaultScalaToolProvider . DEFAULT _ ZINC _ VERSION )  )  )  ;", "}", "return   config ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureCompileDefaults"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getConfigurations (  )  . create ( ScalaBasePlugin . ZINC _ CONFIGURATION _ NAME )  . setVisible ( false )  . setDescription (  \" The   Zinc   incremental   compiler   to   be   used   for   this   Scala   project .  \"  )  ;", "}", "METHOD_END"], "methodName": ["configureConfigurations"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "String   taskName    =    sourceSet . getCompileTaskName (  \" scala \"  )  ;", "final   ScalaCompile   scalaCompile    =    project . getTasks (  )  . create ( taskName ,    ScalaCompile . class )  ;", "scalaCompile . dependsOn ( sourceSet . getCompileJavaTaskName (  )  )  ;", "Convention   scalaConvention    =     (  ( Convention )     ( InvokerHelper . getProperty ( sourceSet ,     \" convention \"  )  )  )  ;", "ScalaSourceSet   scalaSourceSet    =    scalaConvention . find ( ScalaSourceSet . class )  ;", "SourceSetUtil . configureForSourceSet ( sourceSet ,    scalaSourceSet . getScala (  )  ,    scalaCompile ,    scalaCompile . getOptions (  )  ,    project )  ;", "scalaCompile . setDescription (  (  (  \" Compiles   the    \"     +     ( scalaSourceSet . getScala (  )  )  )     +     \"  .  \"  )  )  ;", "scalaCompile . setSource ( scalaSourceSet . getScala (  )  )  ;", "project . getTasks (  )  . getByName ( sourceSet . getClassesTaskName (  )  )  . dependsOn ( taskName )  ;", "project . getGradle (  )  . addBuildListener ( new   BuildAdapter (  )     {", "@ Override", "public   void   projectsEvaluated ( Gradle   gradle )     {", "IncrementalCompileOptions   incrementalOptions    =    scalaCompile . getScalaCompileOptions (  )  . getIncrementalOptions (  )  ;", "if    (  ( incrementalOptions . getAnalysisFile (  )  )     =  =    null )     {", "String   analysisFilePath    =     (  (  ( project . getBuildDir (  )  . getPath (  )  )     +     \"  / tmp / scala / compilerAnalysis /  \"  )     +     ( scalaCompile . getName (  )  )  )     +     \"  . analysis \"  ;", "incrementalOptions . setAnalysisFile ( new   File ( analysisFilePath )  )  ;", "}", "if    (  ( incrementalOptions . getPublishedCode (  )  )     =  =    null )     {", "Jar   jarTask    =     (  ( Jar )     ( project . getTasks (  )  . findByName ( sourceSet . getJarTaskName (  )  )  )  )  ;", "incrementalOptions . setPublishedCode (  ( jarTask    =  =    null    ?    null    :    jarTask . getArchivePath (  )  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureScalaCompile"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "return   project . getExtensions (  )  . create ( ScalaBasePlugin . SCALA _ RUNTIME _ EXTENSION _ NAME ,    ScalaRuntime . class ,    project )  ;", "}", "METHOD_END"], "methodName": ["configureScalaRuntimeExtension"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( ScalaDoc . class ,    new   Action < ScalaDoc >  (  )     {", "@ Override", "public   void   execute ( final   ScalaDoc   scalaDoc )     {", "scalaDoc . getConventionMapping (  )  . map (  \" destinationDir \"  ,    new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "File   docsDir    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getDocsDir (  )  ;", "return   project . file (  (  ( docsDir . getPath (  )  )     +     \"  / scaladoc \"  )  )  ;", "}", "}  )  ;", "scalaDoc . getConventionMapping (  )  . map (  \" title \"  ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "return   project . getExtensions (  )  . getByType ( ReportingExtension . class )  . getApiDocTitle (  )  ;", "}", "}  )  ;", "scalaDoc . getConventionMapping (  )  . map (  \" scalaClasspath \"  ,    new   Callable < FileCollection >  (  )     {", "@ Override", "public   FileCollection   call (  )    throws   Exception    {", "return   scalaRuntime . inferScalaClasspath ( scalaDoc . getClasspath (  )  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureScaladoc"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . all ( new   Action < SourceSet >  (  )     {", "@ Override", "public   void   execute ( final   SourceSet   sourceSet )     {", "String   displayName    =     (  ( String )     ( InvokerHelper . invokeMethod ( sourceSet ,     \" getDisplayName \"  ,    null )  )  )  ;", "Convention   sourceSetConvention    =     (  ( Convention )     ( InvokerHelper . getProperty ( sourceSet ,     \" convention \"  )  )  )  ;", "DefaultScalaSourceSet   scalaSourceSet    =    new   DefaultScalaSourceSet ( displayName ,    sourceDirectorySetFactory )  ;", "sourceSetConvention . getPlugins (  )  . put (  \" scala \"  ,    scalaSourceSet )  ;", "final   SourceDirectorySet   scalaDirectorySet    =    scalaSourceSet . getScala (  )  ;", "scalaDirectorySet . srcDir ( new   Callable < File >  (  )     {", "@ Override", "public   File   call (  )    throws   Exception    {", "return   project . file (  (  (  \" src /  \"     +     ( sourceSet . getName (  )  )  )     +     \"  / scala \"  )  )  ;", "}", "}  )  ;", "sourceSet . getAllJava (  )  . source ( scalaDirectorySet )  ;", "sourceSet . getAllSource (  )  . source ( scalaDirectorySet )  ;", "sourceSet . getResources (  )  . getFilter (  )  . exclude ( new   Spec < FileTreeElement >  (  )     {", "@ Override", "public   boolean   isSatisfiedBy ( FileTreeElement   element )     {", "return   scalaDirectorySet . contains ( element . getFile (  )  )  ;", "}", "}  )  ;", "ScalaBasePlugin . configureScalaCompile ( project ,    sourceSet )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureSourceSetDefaults"], "fileName": "org.gradle.api.plugins.scala.ScalaBasePlugin"}, {"methodBody": ["METHOD_START", "{", "project . getPluginManager (  )  . apply ( ScalaBasePlugin . class )  ;", "project . getPluginManager (  )  . apply ( JavaPlugin . class )  ;", ". configureScaladoc ( project )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.plugins.scala.ScalaPlugin"}, {"methodBody": ["METHOD_START", "{", "project . getTasks (  )  . withType ( ScalaDoc . class ,    new   Action < ScalaDoc >  (  )     {", "@ Override", "public   void   execute ( ScalaDoc   scalaDoc )     {", "final   SourceSet   main    =    project . getConvention (  )  . getPlugin ( JavaPluginConvention . class )  . getSourceSets (  )  . getByName (  \" main \"  )  ;", "scalaDoc . getConventionMapping (  )  . map (  \" classpath \"  ,    new   Callable < FileCollection >  (  )     {", "@ Override", "public   FileCollection   call (  )    throws   Exception    {", "ConfigurableFileCollection   files    =    project . files (  )  ;", "files . from ( main . getOutput (  )  )  ;", "files . from ( main . getCompileClasspath (  )  )  ;", "return   files ;", "}", "}  )  ;", "scalaDoc . setSource ( InvokerHelper . invokeMethod ( main ,     \" getScala \"  ,    null )  )  ;", "}", "}  )  ;", "ScalaDoc   scalaDoc    =    project . getTasks (  )  . create ( ScalaPlugin . SCALA _ DOC _ TASK _ NAME ,    ScalaDoc . class )  ;", "scalaDoc . setDescription (  \" Generates   Scaladoc   for   the   main   source   code .  \"  )  ;", "scalaDoc . setGroup ( DOCUMENTATION _ GROUP )  ;", "}", "METHOD_END"], "methodName": ["configureScaladoc"], "fileName": "org.gradle.api.plugins.scala.ScalaPlugin"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    classpath )     {", "Matcher   matcher    =     . SCALA _ JAR _ PATTERN . matcher ( file . getName (  )  )  ;", "if    (  ( matcher . matches (  )  )     &  &     ( matcher . group (  1  )  . equals ( appendix )  )  )     {", "return   file ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findScalaJar"], "fileName": "org.gradle.api.tasks.ScalaRuntime"}, {"methodBody": ["METHOD_START", "{", "Matcher   matcher    =    ScalaRuntime . SCALA _ JAR _ PATTERN . matcher ( scalaJar . getName (  )  )  ;", "return   matcher . matches (  )     ?    matcher . group (  2  )     :    null ;", "}", "METHOD_END"], "methodName": ["getScalaVersion"], "fileName": "org.gradle.api.tasks.ScalaRuntime"}, {"methodBody": ["METHOD_START", "{", "return   new   LazilyInitializedFileCollection (  )     {", "@ Override", "public   String   getDisplayName (  )     {", "return    \" Scala   runtime   classpath \"  ;", "}", "@ Override", "public   FileCollection   createDelegate (  )     {", "if    ( project . getRepositories (  )  . isEmpty (  )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   infer   Scala   class   path   because   no   repository   is   declared   in    % s \"  ,    project )  )  ;", "}", "File   scalaLibraryJar    =    findScalaJar ( classpath ,     \" library \"  )  ;", "if    ( scalaLibraryJar    =  =    null )     {", "throw   new   GradleException ( String . format (  (  \" Cannot   infer   Scala   class   path   because   no   Scala   library   Jar   was   found .     \"     +     \" Does    % s   declare   dependency   to   scala - library ?    Searched   classpath :     % s .  \"  )  ,    project ,    classpath )  )  ;", "}", "String   scalaVersion    =    getScalaVersion ( scalaLibraryJar )  ;", "if    ( scalaVersion    =  =    null )     {", "throw   new   AssertionError ( String . format (  \" Unexpectedly   failed   to   parse   version   of   Scala   Jar   file :     % s   in    % s \"  ,    scalaLibraryJar ,    project )  )  ;", "}", "return   project . getConfigurations (  )  . detachedConfiguration ( new   DefaultExternalModuleDependency (  \" scala - lang \"  ,     \" scala - compiler \"  ,    scalaVersion )  )  ;", "}", "@ Override", "public   void   visitDependencies ( TaskDependencyResolveContext   context )     {", "if    ( classpath   instanceof   Buildable )     {", "context . add ( classpath )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["inferScalaClasspath"], "fileName": "org.gradle.api.tasks.ScalaRuntime"}, {"methodBody": ["METHOD_START", "{", "if    ( getScalaClasspath (  )  . isEmpty (  )  )     {", "throw   new   InvalidUserDataException (  (  (  (  \"  '  \"     +     ( getName (  )  )  )     +     \"  . scalaClasspath '    must   not   be   empty .    If   a   Scala   compile   dependency   is   provided ,     \"  )     +     \" the    ' scala - base '    plugin   will   attempt   to   configure    ' scalaClasspath '    automatically .    Alternatively ,    you   may   configure    ' scalaClasspath '    explicitly .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertScalaClasspathIsNonEmpty"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "assertScalaClasspathIsNonEmpty (  )  ;", "if    (  ( compiler )     =  =    null )     {", "WorkerDaemonFactory   workerDaemonFactory    =    getServices (  )  . get ( WorkerDaemonFactory . class )  ;", "FileResolver   fileResolver    =    getServices (  )  . get ( FileResolver . class )  ;", "rFactory   scalaCompilerFactory    =    new   rFactory ( getServices (  )  . get ( WorkerDirectoryProvider . class )  . getIdleWorkingDirectory (  )  ,    workerDaemonFactory ,    getScalaClasspath (  )  ,    getZincClasspath (  )  ,    getProject (  )  . getGradle (  )  . getGradleUserHomeDir (  )  ,    fileResolver )  ;", "compiler    =    scalaCompilerFactory . newCompiler ( spec )  ;", "}", "return   compiler ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "return   scalaClasspath ;", "}", "METHOD_END"], "methodName": ["getScalaClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "return   zincClasspath ;", "}", "METHOD_END"], "methodName": ["getZincClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "this . compiler    =    compiler ;", "}", "METHOD_END"], "methodName": ["setCompiler"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "this . scalaClasspath    =    scalaClasspath ;", "}", "METHOD_END"], "methodName": ["setScalaClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "this . zincClasspath    =    zincClasspath ;", "}", "METHOD_END"], "methodName": ["setZincClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaCompile"}, {"methodBody": ["METHOD_START", "{", "ScalaDocOptions   options    =    getScalaDocOptions (  )  ;", "if    (  !  ( GUtil . isTrue ( options . getDocTitle (  )  )  )  )     {", "options . setDocTitle ( getTitle (  )  )  ;", "}", "AntScalaDoc   antScalaDoc    =    new   AntScalaDoc ( getAntBuilder (  )  )  ;", "antScalaDoc . execute ( getSource (  )  ,    getDestinationDir (  )  ,    getClasspath (  )  ,    getScalaClasspath (  )  ,    options )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getAntBuilder"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   destinationDir ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   scalaClasspath ;", "}", "METHOD_END"], "methodName": ["getScalaClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   scalaDocOptions ;", "}", "METHOD_END"], "methodName": ["getScalaDocOptions"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   title ;", "}", "METHOD_END"], "methodName": ["getTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "this . destinationDir    =    destinationDir ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "this . scalaClasspath    =    scalaClasspath ;", "}", "METHOD_END"], "methodName": ["setScalaClasspath"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "this . scalaDocOptions    =    scalaDocOptions ;", "}", "METHOD_END"], "methodName": ["setScalaDocOptions"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "this . title    =    title ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDoc"}, {"methodBody": ["METHOD_START", "{", "return   additionalParameters ;", "}", "METHOD_END"], "methodName": ["getAdditionalParameters"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   bottom ;", "}", "METHOD_END"], "methodName": ["getBottom"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   docTitle ;", "}", "METHOD_END"], "methodName": ["getDocTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   footer ;", "}", "METHOD_END"], "methodName": ["getFooter"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   header ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . nagUserOfDiscontinuedMethod (  \" ScalaDocOptions . getStyleSheet \"  )  ;", "return   styleSheet ;", "}", "METHOD_END"], "methodName": ["getStyleSheet"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   top ;", "}", "METHOD_END"], "methodName": ["getTop"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   windowTitle ;", "}", "METHOD_END"], "methodName": ["getWindowTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   deprecation ;", "}", "METHOD_END"], "methodName": ["isDeprecation"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   unchecked ;", "}", "METHOD_END"], "methodName": ["isUnchecked"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . additionalParameters    =    additionalParameters ;", "}", "METHOD_END"], "methodName": ["setAdditionalParameters"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . bottom    =    bottom ;", "}", "METHOD_END"], "methodName": ["setBottom"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . deprecation    =    deprecation ;", "}", "METHOD_END"], "methodName": ["setDeprecation"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . docTitle    =    docTitle ;", "}", "METHOD_END"], "methodName": ["setDocTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . footer    =    footer ;", "}", "METHOD_END"], "methodName": ["setFooter"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . header    =    header ;", "}", "METHOD_END"], "methodName": ["setHeader"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "DeprecationLogger . nagUserOfDiscontinuedMethod (  \" ScalaDocOptions . setStyleSheet \"  )  ;", "this . styleSheet    =    styleSheet ;", "}", "METHOD_END"], "methodName": ["setStyleSheet"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . top    =    top ;", "}", "METHOD_END"], "methodName": ["setTop"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . unchecked    =    unchecked ;", "}", "METHOD_END"], "methodName": ["setUnchecked"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "this . windowTitle    =    windowTitle ;", "}", "METHOD_END"], "methodName": ["setWindowTitle"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}, {"methodBody": ["METHOD_START", "{", "return   value    ?     \" on \"     :     \" off \"  ;", "}", "METHOD_END"], "methodName": ["toOnOffString"], "fileName": "org.gradle.api.tasks.scala.ScalaDocOptions"}]