[{"methodBody": ["METHOD_START", "{", "BuildResult   result    =    new   BuildResult ( null ,    null )  ;", "result . rethrowFailure (  )  ;", "}", "METHOD_END"], "methodName": ["rethrowDoesNothingWhenNoBuildFailure"], "fileName": "org.gradle.BuildResultTest"}, {"methodBody": ["METHOD_START", "{", "Throwable   failure    =    new   RuntimeException (  )  ;", "result    =    new    ( null ,    failure )  ;", "try    {", "result . rethrowFailure (  )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Build   aborted   because   of   an   internal   error .  \"  )  )  ;", "assertThat ( e . getCause (  )  ,    sameInstance ( failure )  )  ;", "}", "}", "METHOD_END"], "methodName": ["rethrowWrapsOtherExceptions"], "fileName": "org.gradle.BuildResultTest"}, {"methodBody": ["METHOD_START", "{", "Throwable   failure    =    new   GradleException (  )  ;", "result    =    new    ( null ,    failure )  ;", "try    {", "result . rethrowFailure (  )  ;", "fail (  )  ;", "}    catch    ( Exception   e )     {", "assertThat ( e ,    sameInstance ( failure )  )  ;", "}", "}", "METHOD_END"], "methodName": ["rethrowsGradleException"], "fileName": "org.gradle.BuildResultTest"}, {"methodBody": ["METHOD_START", "{", "return   getServices (  )  . get ( TaskFileVarFactory . class )  . newInputDirectory ( this )  ;", "}", "METHOD_END"], "methodName": ["newInputDirectory"], "fileName": "org.gradle.api.DefaultTask"}, {"methodBody": ["METHOD_START", "{", "return   getServices (  )  . get ( TaskFileVarFactory . class )  . newInputFile ( this )  ;", "}", "METHOD_END"], "methodName": ["newInputFile"], "fileName": "org.gradle.api.DefaultTask"}, {"methodBody": ["METHOD_START", "{", "return   getServices (  )  . get ( TaskFileVarFactory . class )  . newOutputDirectory ( this )  ;", "}", "METHOD_END"], "methodName": ["newOutputDirectory"], "fileName": "org.gradle.api.DefaultTask"}, {"methodBody": ["METHOD_START", "{", "return   getServices (  )  . get ( TaskFileVarFactory . class )  . newOutputFile ( this )  ;", "}", "METHOD_END"], "methodName": ["newOutputFile"], "fileName": "org.gradle.api.DefaultTask"}, {"methodBody": ["METHOD_START", "{", "return   task ;", "}", "METHOD_END"], "methodName": ["getTask"], "fileName": "org.gradle.api.execution.internal.ExecuteTaskBuildOperationDetails"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < T >  (  )     {", "public   boolean   matches ( Object   o )     {", "actual    =     (  (  )     ( o )  )  ;", "List <  ?    extends    >    actualCollections    =    unpack ( actual )  ;", "List <  ?    extends    >    expectedCollections    =    unpack ( expected )  ;", "boolean   equals    =    actualCollections . equals ( expectedCollections )  ;", "if    (  ! equals )     {", "System . out . println (  (  \" expected :     \"     +    expectedCollections )  )  ;", "System . out . println (  (  \" actual :     \"     +    actualCollections )  )  ;", "}", "return   equals ;", "}", "private   List <  ?    extends    >    unpack (    expected )     {", "if    ( expected   instanceof   Union )     {", "Union   collection    =     (  ( Union )     ( expected )  )  ;", "return   new   ArrayList <  >  ( collection . getSources (  )  )  ;", "}", "if    ( expected   instanceof   DefaultConfigurable )     {", "DefaultConfigurable   collection    =     (  ( DefaultConfigurable )     ( expected )  )  ;", "return   new   ArrayList <  >  (  (  ( Set )     ( collection . getFrom (  )  )  )  )  ;", "}", "if    ( expected   instanceof   Composite )     {", "Composite   collection    =     (  ( Composite )     ( expected )  )  ;", "DefaultResolveContext   context    =    new   DefaultResolveContext ( TestFiles . resolver (  )  )  ;", "collection . visitContents ( context )  ;", "return   context . resolveAss (  )  ;", "}", "throw   new   RuntimeException (  (  \" Cannot   get   children   of    \"     +    expected )  )  ;", "}", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" same   file   collection   as    \"  )  . appendValue ( expected )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["sameCollection"], "fileName": "org.gradle.api.file.FileCollectionMatchers"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    classMetaData . setMethods )     {", ". PropertyMetaData   property    =    classMetaData . getProperty ( method . getName (  )  )  ;", "if    ( property    !  =    null )     {", "property . addSetMethod ( method )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["attachSetMethods"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   candidate    :    candidates )     {", "if    (  ( candidate . getParameTypes (  )  . length )     !  =     ( method . getParameTypes (  )  . length )  )     {", "continue ;", "}", "boolean   matches    =    true ;", "for    ( int   i    =     0  ;    matches    &  &     ( i    <     (  ( candidate . getParameTypes (  )  . length )     -     1  )  )  ;    i +  +  )     {", "if    (  !  ( candidate . getParameTypes (  )  [ i ]  . equals ( method . getParameTypes (  )  [ i ]  )  )  )     {", "matches    =    false ;", "}", "}", "if    ( matches )     {", "return   candidate ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClosureOverload"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "for    ( Method   method    :    classMetaData . actionMethods )     {", "Method   overload    =    findClosureOverload ( method ,    classMetaData . closureMethods . get ( method . getName (  )  )  )  ;", "if    ( overload    =  =    null )     {", "classMetaData . actionMethodRequiresOverload ( method )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["findMissingClosureOverloads"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "try    {", ". CACHE _ LOCK . lock (  )  ;", "return   generateUnderLock ( type )  ;", "}    finally    {", ". CACHE _ LOCK . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "Map < Class <  ?  >  ,    Class <  ?  >  >    cache    =    AbstractClassGenerator . GENERATED _ CLASSES . get ( getClass (  )  )  ;", "if    ( cache    =  =    null )     {", "cache    =    new   ReferenceMap ( AbstractReferenceMap . WEAK ,    AbstractReferenceMap . WEAK )  ;", "AbstractClassGenerator . GENERATED _ CLASSES . put ( getClass (  )  ,    cache )  ;", "}", "Class <  ?  >    generatedClass    =    cache . get ( type )  ;", "if    ( generatedClass    !  =    null )     {", "return   generatedClass . asSubclass ( type )  ;", "}", "int   modifiers    =    type . getModifiers (  )  ;", "if    ( Modifier . isPrivate ( modifiers )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   create   a   proxy   class   for   private   class    '  % s '  .  \"  ,    type . getSimpleName (  )  )  )  ;", "}", "if    ( Modifier . isAbstract ( modifiers )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   create   a   proxy   class   for   abstract   class    '  % s '  .  \"  ,    type . getSimpleName (  )  )  )  ;", "}", "if    ( Modifier . isFinal ( modifiers )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   create   a   proxy   class   for   final   class    '  % s '  .  \"  ,    type . getSimpleName (  )  )  )  ;", "}", "Class <  ?    extends   T >    subclass ;", "try    {", "AbstractClassGenerator . ClassMetaData   classMetaData    =    inspectType ( type )  ;", "AbstractClassGenerator . ClassBuilder < T >    builder    =    start ( type ,    classMetaData )  ;", "builder . startClass ( classMetaData . isShouldImplementWithServiceRegistry (  )  )  ;", "if    (  !  ( DynamicObjectAware . class . isAssignableFrom ( type )  )  )     {", "if    ( ExtensionAware . class . isAssignableFrom ( type )  )     {", "throw   new   UnsupportedOperationException (  \" A   type   that   implements   ExtensionAware   must   currently   also   implement   DynamicObjectAware .  \"  )  ;", "}", "builder . mixInDynamicAware (  )  ;", "}", "if    (  !  ( GroovyObject . class . isAssignableFrom ( type )  )  )     {", "builder . mixInGroovyObject (  )  ;", "}", "builder . addDynamicMethods (  )  ;", "if    (  ( classMetaData . conventionAware )     &  &     (  !  ( IConventionAware . class . isAssignableFrom ( type )  )  )  )     {", "builder . mixInConventionAware (  )  ;", "}", "Class   noMappingClass    =    Object . class ;", "for    ( Class <  ?  >    c    =    type ;     ( c    !  =    null )     &  &     ( noMappingClass    =  =     ( Object . class )  )  ;    c    =    c . getSuperclass (  )  )     {", "if    (  ( c . getAnnotation ( NoConventionMapping . class )  )     !  =    null )     {", "noMappingClass    =    c ;", "}", "}", "if    ( classMetaData . isShouldImplementWithServiceRegistry (  )  )     {", "builder . generateServiceRegistrySupportMethods (  )  ;", "}", "Set < AbstractClassGenerator . PropertyMetaData >    conventionProperties    =    new   HashSet < AbstractClassGenerator . PropertyMetaData >  (  )  ;", "for    ( AbstractClassGenerator . PropertyMetaData   property    :    classMetaData . properties . values (  )  )     {", "if    ( AbstractClassGenerator . SKIP _ PROPERTIES . contains ( property . name )  )     {", "continue ;", "}", "if    (  (  !  ( property . getters . isEmpty (  )  )  )     &  &     (  ( Property . class . isAssignableFrom ( property . getType (  )  )  )     |  |     ( HasMultipleValues . class . isAssignableFrom ( property . getType (  )  )  )  )  )     {", "builder . addPropertySetters ( property ,    property . getters . get (  0  )  )  ;", "continue ;", "}", "if    ( property . injector )     {", "builder . addInjectorProperty ( property )  ;", "for    ( Method   getter    :    property . getters )     {", "builder . applyServiceInjectionToGetter ( property ,    getter )  ;", "}", "for    ( Method   setter    :    property . setters )     {", "builder . applyServiceInjectionToSetter ( property ,    setter )  ;", "}", "continue ;", "}", "boolean   needsConventionMapping    =    false ;", "if    ( classMetaData . isExtensible (  )  )     {", "for    ( Method   getter    :    property . getters )     {", "if    (  (  !  ( Modifier . isFinal ( getter . getModifiers (  )  )  )  )     &  &     (  !  ( getter . getDeclaringClass (  )  . isAssignableFrom ( noMappingClass )  )  )  )     {", "needsConventionMapping    =    true ;", "break ;", "}", "}", "}", "if    ( needsConventionMapping )     {", "conventionProperties . add ( property )  ;", "builder . addConventionProperty ( property )  ;", "for    ( Method   getter    :    property . getters )     {", "builder . applyConventionMappingToGetter ( property ,    getter )  ;", "}", "for    ( Method   setter    :    property . setters )     {", "if    (  !  ( Modifier . isFinal ( setter . getModifiers (  )  )  )  )     {", "builder . applyConventionMappingToSetter ( property ,    setter )  ;", "}", "}", "}", "}", "Set < Method >    actionMethods    =    classMetaData . missingOverloads ;", "for    ( Method   method    :    actionMethods )     {", "builder . addActionMethod ( method )  ;", "}", "for    ( AbstractClassGenerator . PropertyMetaData   property    :    classMetaData . properties . values (  )  )     {", "if    ( property . setters . isEmpty (  )  )     {", "continue ;", "}", "if    ( Iterable . class . isAssignableFrom ( property . getType (  )  )  )     {", "continue ;", "}", "if    ( property . setMethods . isEmpty (  )  )     {", "for    ( Method   setter    :    property . setters )     {", "builder . addSetMethod ( property ,    setter )  ;", "}", "} else", "if    ( conventionProperties . contains ( property )  )     {", "for    ( Method   setMethod    :    property . setMethods )     {", "builder . applyConventionMappingToSetMethod ( property ,    setMethod )  ;", "}", "}", "}", "for    ( Constructor <  ?  >    constructor    :    type . getConstructors (  )  )     {", "if    ( Modifier . isPublic ( constructor . getModifiers (  )  )  )     {", "builder . addConstructor ( constructor )  ;", "}", "}", "subclass    =    builder . generate (  )  ;", "}    catch    ( Throwable   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   generate   a   proxy   class   for   class    % s .  \"  ,    type . getName (  )  )  ,    e )  ;", "}", "cache . put ( type ,    subclass )  ;", "cache . put ( subclass ,    subclass )  ;", "return   subclass ;", "}", "METHOD_END"], "methodName": ["generateUnderLock"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "boolean   isConventionAware    =     ( type . getAnnotation ( NoConventionMapping . class )  )     =  =    null ;", "boolean   extensible    =     ( JavaReflectionUtil . getAnnotation ( type ,    NonExtensible . class )  )     =  =    null ;", ". ClassMetaData   classMetaData    =    new    . ClassMetaData ( extensible ,    isConventionAware )  ;", "inspectType ( type ,    classMetaData )  ;", "attachSetMethods ( classMetaData )  ;", "findMissingClosureOverloads ( classMetaData )  ;", "classMetaData . complete (  )  ;", "return   classMetaData ;", "}", "METHOD_END"], "methodName": ["inspectType"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "ClassDetails   classDetails    =    ClassInspector . inspect ( type )  ;", "boolean   hasGetServicesMethod    =    false ;", "for    ( Method   method    :    classDetails . getAllMethods (  )  )     {", "if    (  ( method . getAnnotation ( Inject . class )  )     !  =    null )     {", "if    (  (  !  ( Modifier . isPublic ( method . getModifiers (  )  )  )  )     &  &     (  !  ( Modifier . isProtected ( method . getModifiers (  )  )  )  )  )     {", "throw   new   UnsupportedOperationException ( String . format (  \" Cannot   attach    @ Inject   to   method    % s .  % s (  )    as   it   is   not   public   or   protected .  \"  ,    method . getDeclaringClass (  )  . getSimpleName (  )  ,    method . getName (  )  )  )  ;", "}", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   UnsupportedOperationException ( String . format (  \" Cannot   attach    @ Inject   to   method    % s .  % s (  )    as   it   is   static .  \"  ,    method . getDeclaringClass (  )  . getSimpleName (  )  ,    method . getName (  )  )  )  ;", "}", "}", "if    (  (  (  \" getServices \"  . equals ( method . getName (  )  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     &  &     ( ServiceRegistry . class . equals ( method . getReturnType (  )  )  )  )     {", "hasGetServicesMethod    =    true ;", "}", "}", "for    ( PropertyDetails   property    :    classDetails . getProperties (  )  )     {", ". PropertyMetaData   propertyMetaData    =    classMetaData . property ( property . getName (  )  )  ;", "for    ( Method   method    :    property . getGetters (  )  )     {", "propertyMetaData . addGetter ( method )  ;", "}", "for    ( Method   method    :    property . getSetters (  )  )     {", "propertyMetaData . addSetter ( method )  ;", "}", "}", "for    ( Method   method    :    classDetails . getInstanceMethods (  )  )     {", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "if    (  ( parameterTypes . length )     =  =     1  )     {", "classMetaData . addCandidateSetMethod ( method )  ;", "}", "if    (  (  ( parameterTypes . length )     >     0  )     &  &     ( parameterTypes [  (  ( parameterTypes . length )     -     1  )  ]  . equals ( Action . class )  )  )     {", "classMetaData . addActionMethod ( method )  ;", "} else", "if    (  (  ( parameterTypes . length )     >     0  )     &  &     ( parameterTypes [  (  ( parameterTypes . length )     -     1  )  ]  . equals ( groovy . lang . Closure . class )  )  )     {", "classMetaData . addClosureMethod ( method )  ;", "}", "}", "if    (  ! hasGetServicesMethod )     {", "for    (  . PropertyMetaData   metaData    :    classMetaData . properties . values (  )  )     {", "if    ( metaData . injector )     {", "classMetaData . shouldImplementWithServiceRegistry    =    true ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["inspectType"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "return   DirectInstantiator . instantiate ( generate ( type )  ,    parameters )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.gradle.api.internal.AbstractClassGenerator"}, {"methodBody": ["METHOD_START", "{", "ConfigureDelegate   delegate    =    createConfigureDelegate ( configureClosure )  ;", "ConfigureUtil . configureSelf ( configureClosure ,    this ,    delegate )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( name ,    Actions . doNothing (  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( name ,    ConfigureUtil . configureUsing ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "assertCanAdd ( name )  ;", "T   o    =    doCreate ( name )  ;", "add ( o )  ;", "configureAction . execute ( o )  ;", "return   o ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   NamedDomainObjectContainerConfigureDelegate ( configureClosure ,    this )  ;", "}", "METHOD_END"], "methodName": ["createConfigureDelegate"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTypeDisplayName (  )  )     +     \"    container \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "T   item    =    findByName ( name )  ;", "if    ( item    !  =    null )     {", "return   item ;", "}", "return   create ( name )  ;", "}", "METHOD_END"], "methodName": ["maybeCreate"], "fileName": "org.gradle.api.internal.AbstractNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   getInstantiator (  )  . newInstance ( TypedDomainObjectContainerWrapper . class ,    type ,    this )  ;", "}", "METHOD_END"], "methodName": ["containerWithType"], "fileName": "org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( name ,    type ,    null )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "assertCanAdd ( name )  ;", "U   o    =    doCreate ( name ,    type )  ;", "add ( o )  ;", "if    ( configuration    !  =    null )     {", "configuration . execute ( o )  ;", "}", "return   o ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "T   item    =    findByName ( name )  ;", "if    ( item    !  =    null )     {", "return   Transformers . cast ( type )  . nsform ( item )  ;", "}", "return   create ( name ,    type )  ;", "}", "METHOD_END"], "methodName": ["maybeCreate"], "fileName": "org.gradle.api.internal.AbstractPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( extensibleDynamicObject )     =  =    null )     {", "extensibleDynamicObject    =    new   ExtensibleDynamicObject ( this ,    publicType ,    services . get ( Instantiator . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertDynamicObject"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   new   AbstractTask . ClosureTaskAction ( actionClosure ,    actionName )  ;", "}", "METHOD_END"], "methodName": ["convertClosureToAction"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   new   AndSpec < Task >  ( new   Spec < Task >  (  )     {", "public   boolean   isSatisfiedBy ( Task   element )     {", "return    ( element    =  =     ( AbstractTask . this )  )     &  &     ( enabled )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createNewOnlyIfSpec"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "if    ( action   instanceof   ScriptOrigin )     {", "ScriptOrigin   origin    =     (  ( ScriptOrigin )     ( action )  )  ;", "return    (  ( origin . getOriginalClassName (  )  )     +     \"  _  \"  )     +     ( origin . getContentHash (  )  )  ;", "} else    {", "return   action . getClass (  )  . getName (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getActionClassName"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "String   reuseTaskLogicUrl    =    services . get ( DocumentationRegistry . class )  . getDocumentationFor (  \" custom _ tasks \"  ,     \" sec : reusing _ task _ logic \"  )  ;", "return    (  \" There   are   better   ways   to   re - use   task   logic ,    see    \"     +    reuseTaskLogicUrl )     +     \"  .  \"  ;", "}", "METHOD_END"], "methodName": ["getReuseTaskLogicAdvice"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   services ;", "}", "METHOD_END"], "methodName": ["getServices"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "AbstractTask . NEXT _ INSTANCE . set ( new   AbstractTask . TaskInfo ( project ,    name ,    publicType )  )  ;", "try    {", "return   GUtil . uncheckedCall ( factory )  ;", "}    finally    {", "AbstractTask . NEXT _ INSTANCE . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["injectIntoNewInstance"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   enabled ;", "}", "METHOD_END"], "methodName": ["isEnabled"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   AbstractTask . NEXT _ INSTANCE . get (  )  ;", "}", "METHOD_END"], "methodName": ["taskInfo"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "return   wrap ( action ,     \" unnamed   action \"  )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "if    ( action   instanceof   ContextAwareTaskAction )     {", "return    (  ( ContextAwareTaskAction )     ( action )  )  ;", "}", "return   new    . TaskActionWrapper ( action ,    actionName )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.api.internal.AbstractTask"}, {"methodBody": ["METHOD_START", "{", "NameValidator . validate ( name ,     \" name \"  ,     \"  \"  )  ;", "return   super . create ( name ,    configureAction )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.AbstractValidatingNamedDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithMultiArgDslMethods   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithMultiArgDslMethods . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["addsInsteadOfOverridesSetValueMethodIfOnlyMultiArgMethods"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "DefaultProviderFactory   providerFactory    =    new   DefaultProviderFactory (  )  ;", ". BeanWithProperty   bean    =    generator . newInstance (  . BeanWithProperty . class ,    TestUtil . objectFactory (  )  )  ;", "DynamicObject   dynamicObject    =     (  ( DynamicObjectAware )     ( bean )  )  . getAsDynamicObject (  )  ;", "dynamicObject . setProperty (  \" prop \"  ,     \" value \"  )  ;", "assertEquals (  \" value \"  ,    bean . getProp (  )  . get (  )  )  ;", "dynamicObject . setProperty (  \" prop \"  ,    providerFactory . provider ( new   Callable < String >  (  )     {", "int   count ;", "@ Override", "public   String   call (  )    throws   Exception    {", "return    (  \"  [  \"     +     ( String . valueOf (  (  +  +  ( count )  )  )  )  )     +     \"  ]  \"  ;", "}", "}  )  )  ;", "assertEquals (  \"  [  1  ]  \"  ,    bean . getProp (  )  . get (  )  )  ;", "assertEquals (  \"  [  2  ]  \"  ,    bean . getProp (  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["addsSetterMethodsForPropertyWhoseTypeIsProperty"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . CollectionBean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . CollectionBean . class )  ;", "AsmBackedClassGeneratorTest . CollectionBean   bean    =    generatedClass . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "final   List < String >    conventionValue    =    WrapUtil . toList (  \" value \"  )  ;", "assertThat ( bean . getProp (  )  ,    Matchers . isEmpty (  )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" prop \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   conventionValue ;", "}", "}  )  ;", "assertThat ( bean . getProp (  )  ,    sameInstance ( conventionValue )  )  ;", "bean . setProp ( WrapUtil . toList (  \" other \"  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo ( WrapUtil . toList (  \" other \"  )  )  )  ;", "bean . setProp ( Collections .  < String > emptyList (  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo ( Collections .  < String > emptyList (  )  )  )  ;", "bean . setProp ( null )  ;", "assertThat ( bean . getProp (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToCollectionGetter"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "assertThat ( bean . getProp (  )  ,    nullValue (  )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" prop \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" conventionValue \"  )  )  ;", "bean . setProp (  \" value \"  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "bean . setProp ( null )  ;", "assertThat ( bean . getProp (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToEachProperty"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AbstractClassGeneratorTestGroovy . BeanWithGroovyBoolean   bean    =    generator . generate ( AbstractClassGeneratorTestGroovy . BeanWithGroovyBoolean . class )  . newInstance (  )  ;", "assertTrue (  ( bean   instanceof   IConventionAware )  )  ;", "assertThat ( bean . getSmallB (  )  ,    equalTo ( false )  )  ;", "assertThat ( bean . getBigB (  )  ,    nullValue (  )  )  ;", "assertThat ( bean . getMixedB (  )  ,    equalTo ( false )  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" smallB \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   true ;", "}", "}  )  ;", "assertThat ( bean . isSmallB (  )  ,    equalTo ( true )  )  ;", "assertThat ( bean . getSmallB (  )  ,    equalTo ( true )  )  ;", "bean . setSmallB ( false )  ;", "assertThat ( bean . isSmallB (  )  ,    equalTo ( false )  )  ;", "assertThat ( bean . getSmallB (  )  ,    equalTo ( false )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" bigB \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   Boolean . TRUE ;", "}", "}  )  ;", "assertThat ( bean . getBigB (  )  ,    equalTo ( Boolean . TRUE )  )  ;", "bean . setBigB ( Boolean . FALSE )  ;", "assertThat ( bean . getBigB (  )  ,    equalTo ( Boolean . FALSE )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" mixedB \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   Boolean . TRUE ;", "}", "}  )  ;", "assertThat ( bean . getMixedB (  )  ,    equalTo ( true )  )  ;", "assertThat ( bean . isMixedB (  )  ,    equalTo ( Boolean . TRUE )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToGroovyBoolean"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . CovariantPropertyTypes   bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . CovariantPropertyTypes . class )  ;", "new   DslObject ( bean )  . getConventionMapping (  )  . map (  \" value \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertThat ( bean . getValue (  )  ,    equalTo (  \" conventionValue \"  )  )  ;", "bean . setValue (  1  2  )  ;", "assertThat ( bean . getValue (  )  ,    equalTo (  \"  1  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToPropertyWithGetterCovariantType"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters   bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters . class )  ;", "new   DslObject ( bean )  . getConventionMapping (  )  . map (  \" overloaded \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" conventionValue \"  )  )  ;", "bean . setOverloaded (  \" value \"  )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" chars    =    value \"  )  )  ;", "bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters . class )  ;", "new   DslObject ( bean )  . getConventionMapping (  )  . map (  \" overloaded \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" conventionValue \"  )  )  ;", "bean . setOverloaded (  1  2  )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" number    =     1  2  \"  )  )  ;", "bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters . class )  ;", "new   DslObject ( bean )  . getConventionMapping (  )  . map (  \" overloaded \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" conventionValue \"  )  )  ;", "bean . setOverloaded ( true )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" object    =    true \"  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToPropertyWithMultipleSetters"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithNonPublicProperties   bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithNonPublicProperties . class )  ;", "assertThat ( bean . getPackageProtected (  )  ,    equalTo (  \" package - protected \"  )  )  ;", "assertThat ( bean . getProtected (  )  ,    equalTo (  \" protected \"  )  )  ;", "assertThat ( bean . getPrivate (  )  ,    equalTo (  \" private \"  )  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" packageProtected \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \"  1  \"  ;", "}", "}  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" protected \"  ,    new   Callable < String >  (  )     {", "public   String   call (  )     {", "return    \"  2  \"  ;", "}", "}  )  ;", "assertThat ( bean . getPackageProtected (  )  ,    equalTo (  \"  1  \"  )  )  ;", "assertThat ( bean . getProtected (  )  ,    equalTo (  \"  2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["appliesConventionMappingToProtectedMethods"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "assertSame ( generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ,    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  )  ;", "}", "METHOD_END"], "methodName": ["cachesGeneratedSubclass"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "TestDecoratedGroovyBean   bean    =    generator . generate ( TestDecoratedGroovyBean . class )  . newInstance (  )  ;", "DynamicObjectAware   dynamicObjectAware    =     (  ( DynamicObjectAware )     ( bean )  )  ;", ". ConventionObject   conventionObject    =    new    . ConventionObject (  )  ;", "new   DslObject ( dynamicObjectAware )  . getConvention (  )  . getPlugins (  )  . put (  \" plugin \"  ,    conventionObject )  ;", "TestUtil . call (  \"  {    it . conventionProperty    =     ' value '     }  \"  ,    bean )  ;", "assertThat ( conventionObject . getConventionProperty (  )  ,    equalTo (  \" value \"  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . hasProperty (  ' conventionProperty '  )     }  \"  ,    bean )  ,    notNullValue (  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionProperty    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionMethod (  ' value '  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \"  [ value ]  \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . invokeMethod (  ' conventionMethod '  ,     ' value '  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \"  [ value ]  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddDynamicPropertiesAndMethodsToGroovyObject"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . Bean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . newInstance (  )  ;", "DynamicObjectAware   dynamicObjectAware    =     (  ( DynamicObjectAware )     ( bean )  )  ;", "AsmBackedClassGeneratorTest . ConventionObject   conventionObject    =    new   AsmBackedClassGeneratorTest . ConventionObject (  )  ;", "new   DslObject ( dynamicObjectAware )  . getConvention (  )  . getPlugins (  )  . put (  \" plugin \"  ,    conventionObject )  ;", "TestUtil . call (  \"  {    it . conventionProperty    =     ' value '     }  \"  ,    bean )  ;", "assertThat ( conventionObject . getConventionProperty (  )  ,    equalTo (  \" value \"  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . hasProperty (  ' conventionProperty '  )     }  \"  ,    bean )  ,    notNullValue (  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionProperty    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionMethod (  ' value '  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \"  [ value ]  \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . invokeMethod (  ' conventionMethod '  ,     ' value '  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \"  [ value ]  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddDynamicPropertiesAndMethodsToJavaObject"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . Bean   bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithConstructor . class ,     \" value \"  )  ;", "assertThat ( bean . getClass (  )  ,    sameInstance (  (  ( Object )     ( generator . generate ( AsmBackedClassGeneratorTest . BeanWithConstructor . class )  )  )  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithConstructor . class )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" default   value \"  )  )  ;", "bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanWithConstructor . class ,     1  2  7  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  1  2  7  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canConstructInstance"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanUsesPropertiesInConstructor   bean    =    generator . newInstance ( AsmBackedClassGeneratorTest . BeanUsesPropertiesInConstructor . class )  ;", "assertThat ( bean . name ,    equalTo (  \" default - name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["constructorCanCallGetter"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "DefaultProviderFactory   providerFactory    =    new   DefaultProviderFactory (  )  ;", ". BeanWithProperty   bean    =    generator . newInstance (  . BeanWithProperty . class ,    TestUtil . objectFactory (  )  )  ;", "DynamicObject   dynamicObject    =     (  ( DynamicObjectAware )     ( bean )  )  . getAsDynamicObject (  )  ;", "dynamicObject . setProperty (  \" prop 2  \"  ,     \" value \"  )  ;", "assertEquals (  \"  [ value ]  \"  ,    bean . getProp 2  (  )  . get (  )  )  ;", "dynamicObject . setProperty (  \" prop 2  \"  ,     1  2  )  ;", "assertEquals (  \"  [  1  2  ]  \"  ,    bean . getProp 2  (  )  . get (  )  )  ;", "dynamicObject . setProperty (  \" prop 2  \"  ,    providerFactory . provider ( new   Callable < String >  (  )     {", "int   count ;", "@ Override", "public   String   call (  )    throws   Exception    {", "return    (  \"  [  \"     +     ( String . valueOf (  (  +  +  ( count )  )  )  )  )     +     \"  ]  \"  ;", "}", "}  )  )  ;", "assertEquals (  \"  [  1  ]  \"  ,    bean . getProp 2  (  )  . get (  )  )  ;", "assertEquals (  \"  [  2  ]  \"  ,    bean . getProp 2  (  )  . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotAddSetterMethodsForPropertyWhoseTypeIsPropertyWhenTheSetterMethodsAlreadyExist"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertSame ( generatedClass ,    generator . generate ( generatedClass )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotDecorateAlreadyDecoratedClass"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . NoMappingBean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . NoMappingBean . class )  . newInstance (  )  ;", "assertFalse (  ( bean   instanceof   IConventionAware )  )  ;", "assertNull ( bean . getInterfaceProperty (  )  )  ;", "assertTrue (  ( bean   instanceof   DynamicObjectAware )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotMixInConventionMappingToClassWithAnnotation"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . CollectionBean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . CollectionBean . class )  . newInstance (  )  ;", "try    {", "TestUtil . call (  \"  {    def   val    =     [  ' value '  ]  ;    it . prop   val }  \"  ,    bean )  ;", "fail (  )  ;", "}    catch    ( MissingMethodException   e )     {", "assertThat ( e . getMethod (  )  ,    equalTo (  \" prop \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotMixInSetValueMethodForMultiValueProperty"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithReadOnlyProperties   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithReadOnlyProperties . class )  . newInstance (  )  ;", "try    {", "TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ;", "fail (  )  ;", "}    catch    ( MissingMethodException   e )     {", "assertThat ( e . getMethod (  )  ,    equalTo (  \" prop \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotMixInSetValueMethodForReadOnlyProperty"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithDslMethods   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithDslMethods . class )  . newInstance (  )  ;", "bean . prop    =     \" value \"  ;", "assertThat ( TestUtil . call (  \"  { def   value ;    it . doStuff    {    value    =    it    }  ;    return   value    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \"  [ value ]  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverrideExistingClosureOverload"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . ConventionAwareBean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . ConventionAwareBean . class )  ;", "assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . ConventionAwareBean   bean    =    generatedClass . newInstance (  )  ;", "assertSame ( bean ,    bean . getConventionMapping (  )  )  ;", "bean . setProp (  \" value \"  )  ;", "assertEquals (  \"  [ value ]  \"  ,    bean . getProp (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverrideMethodsFromConventionAwareInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . DynamicObjectAwareBean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . DynamicObjectAwareBean . class )  . newInstance (  )  ;", "assertThat ( bean . getConvention (  )  ,    sameInstance ( bean . conv )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  ,    sameInstance ( bean . conv . getExtensionsAsDynamicObject (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverrideMethodsFromDynamicObjectAwareInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanSubClass   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanSubClass . class )  . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" property \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" interfaceProperty \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" overriddenProperty \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" otherProperty \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return    \" conventionValue \"  ;", "}", "}  )  ;", "assertEquals ( null ,    bean . getProperty (  )  )  ;", "assertEquals ( null ,    bean . getInterfaceProperty (  )  )  ;", "assertEquals (  \" conventionValue \"  ,    bean . getOverriddenProperty (  )  )  ;", "assertEquals (  \" conventionValue \"  ,    bean . getOtherProperty (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverrideMethodsFromSuperclassesMarkedWithAnnotation"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithMultiArgDslMethodsAndNoConventionMapping   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithMultiArgDslMethodsAndNoConventionMapping . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  ( value )  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverrideSetValueMethodForPropertyThatIsNotConventionMappingAware"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . Bean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" prop \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return    \"  [ default ]  \"  ;", "}", "}  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  [ default ]  \"  )  )  ;", "TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotUseConventionValueOnceSetValueMethodHasBeenCalled"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . isSynthetic (  )  )  ;", "}", "METHOD_END"], "methodName": ["generatedTypeIsMarkedSynthetic"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "DslObject   dslObject    =    new   DslObject ( generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . newInstance (  )  )  ;", "assertEquals ( AsmBackedClassGeneratorTest . Bean . class ,    dslObject . getDeclaredType (  )  )  ;", "assertNotNull ( dslObject . getConventionMapping (  )  )  ;", "assertNotNull ( dslObject . getConvention (  )  )  ;", "assertNotNull ( dslObject . getExtensions (  )  )  ;", "assertNotNull ( dslObject . getAsDynamicObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["generatesDslObjectCompatibleObject"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithVariousPropertyTypes   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithVariousPropertyTypes . class )  . newInstance (  )  ;", "assertThat ( bean . getArrayProperty (  )  ,    notNullValue (  )  )  ;", "assertThat ( bean . getBooleanProperty (  )  ,    equalTo ( false )  )  ;", "assertThat ( bean . getLongProperty (  )  ,    equalTo (  1  2 L )  )  ;", "assertThat ( bean . setReturnValueProperty (  \" p \"  )  ,    sameInstance ( bean )  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" booleanProperty \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return   true ;", "}", "}  )  ;", "assertThat ( bean . getBooleanProperty (  )  ,    equalTo ( true )  )  ;", "bean . setBooleanProperty ( false )  ;", "assertThat ( bean . getBooleanProperty (  )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["handlesVariousPropertyTypes"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithAnnotatedConstructor . class )  ;", "Constructor <  ?  >    constructor    =    generatedClass . getDeclaredConstructors (  )  [  0  ]  ;", "assertThat ( constructor . getAnnotation ( Inject . class )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["includesAnnotationInformationForOverriddenConstructor"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithComplexConstructor . class )  ;", "Constructor <  ?  >    constructor    =    generatedClass . getDeclaredConstructors (  )  [  0  ]  ;", "assertThat ( constructor . getTypeParameters (  )  . length ,    equalTo (  3  )  )  ;", "assertThat ( constructor . getGenericParameterTypes (  )  . length ,    equalTo (  1  2  )  )  ;", "Type   paramType    =    constructor . getGenericParameterTypes (  )  [  0  ]  ;", "assertThat ( paramType ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  1  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "ParameterizedType   parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  2  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "WildcardType   wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  0  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  3  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  4  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  0  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  5  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  0  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( wildcard . getUpperBounds (  )  [  0  ]  )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  0  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  6  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( TypeVariable . class )  )  ;", "TypeVariable   typeVariable    =     (  ( TypeVariable )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( typeVariable . getName (  )  ,    equalTo (  \" S \"  )  )  ;", "assertThat ( typeVariable . getBounds (  )  [  0  ]  ,    instanceOf ( ParameterizedType . class )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  7  ]  ;", "assertThat ( paramType ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( paramType )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( Callable . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "wildcard    =     (  ( WildcardType )     ( parameterizedType . getActualTypeArguments (  )  [  0  ]  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( wildcard . getLowerBounds (  )  . length ,    equalTo (  0  )  )  ;", "assertThat ( wildcard . getUpperBounds (  )  [  0  ]  ,    instanceOf ( TypeVariable . class )  )  ;", "typeVariable    =     (  ( TypeVariable )     ( wildcard . getUpperBounds (  )  [  0  ]  )  )  ;", "assertThat ( typeVariable . getName (  )  ,    equalTo (  \" T \"  )  )  ;", "assertThat ( typeVariable . getBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( IOException . class )  )  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  8  ]  ;", "assertThat ( paramType ,    instanceOf ( TypeVariable . class )  )  ;", "typeVariable    =     (  ( TypeVariable )     ( paramType )  )  ;", "assertThat ( typeVariable . getName (  )  ,    equalTo (  \" V \"  )  )  ;", "assertThat ( typeVariable . getBounds (  )  [  0  ]  ,    equalTo (  (  ( Type )     ( Object . class )  )  )  )  ;", "GenericArrayType   arrayType ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  9  ]  ;", "assertThat ( paramType ,    equalTo (  (  ( Type )     ( String [  ]  . class )  )  )  )  ;", "assertThat (  (  ( Class <  ?  >  )     ( paramType )  )  . getComponentType (  )  ,    equalTo (  (  ( Type )     ( String . class )  )  )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  1  0  ]  ;", "assertThat ( paramType ,    instanceOf ( GenericArrayType . class )  )  ;", "arrayType    =     (  ( GenericArrayType )     ( paramType )  )  ;", "assertThat ( arrayType . getGenericComponentType (  )  ,    instanceOf ( ParameterizedType . class )  )  ;", "parameterizedType    =     (  ( ParameterizedType )     ( arrayType . getGenericComponentType (  )  )  )  ;", "assertThat ( parameterizedType . getRawType (  )  ,    equalTo (  (  ( Type )     ( List . class )  )  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  . length ,    equalTo (  1  )  )  ;", "assertThat ( parameterizedType . getActualTypeArguments (  )  [  0  ]  ,    instanceOf ( WildcardType . class )  )  ;", "paramType    =    constructor . getGenericParameterTypes (  )  [  1  1  ]  ;", "assertThat ( paramType ,    equalTo (  (  ( Type )     ( Boolean . TYPE )  )  )  )  ;", "assertThat ( constructor . getGenericExceptionTypes (  )  . length ,    equalTo (  2  )  )  ;", "Type   exceptionType    =    constructor . getGenericExceptionTypes (  )  [  0  ]  ;", "assertThat ( exceptionType ,    equalTo (  (  ( Type )     ( Exception . class )  )  )  )  ;", "exceptionType    =    constructor . getGenericExceptionTypes (  )  [  1  ]  ;", "assertThat ( exceptionType ,    instanceOf ( TypeVariable . class )  )  ;", "typeVariable    =     (  ( TypeVariable )     ( exceptionType )  )  ;", "assertThat ( typeVariable . getName (  )  ,    equalTo (  \" T \"  )  )  ;", "}", "METHOD_END"], "methodName": ["includesGenericTypeInformationForOverriddenConstructor"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . AnnotatedBean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . AnnotatedBean . class )  ;", "AsmBackedClassGeneratorTest . BeanAnnotation   annotation    =    generatedClass . getAnnotation ( AsmBackedClassGeneratorTest . BeanAnnotation . class )  ;", "assertThat ( annotation ,    notNullValue (  )  )  ;", "assertThat ( annotation . value (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( annotation . values (  )  ,    equalTo ( new   String [  ]  {     \"  1  \"  ,     \"  2  \"     }  )  )  ;", "assertThat ( annotation . enumValue (  )  ,    equalTo ( AsmBackedClassGeneratorTest . AnnotationEnum . A )  )  ;", "assertThat ( annotation . enumValues (  )  ,    equalTo ( new   AsmBackedClassGeneratorTest . AnnotationEnum [  ]  {    AsmBackedClassGeneratorTest . AnnotationEnum . A ,    AsmBackedClassGeneratorTest . AnnotationEnum . B    }  )  )  ;", "assertThat ( annotation . number (  )  ,    equalTo (  1  )  )  ;", "assertThat ( annotation . numbers (  )  ,    equalTo ( new   int [  ]  {     1  ,     2     }  )  )  ;", "assertThat ( annotation . clazz (  )  . equals ( Integer . class )  ,    equalTo ( true )  )  ;", "assertThat ( annotation . classes (  )  ,    equalTo ( new   Class <  ?  >  [  ]  {    Integer . class    }  )  )  ;", "assertThat ( annotation . annotation (  )  . value (  )  ,    equalTo (  \" nested \"  )  )  ;", "assertThat ( annotation . annotations (  )  [  0  ]  . value (  )  ,    equalTo (  \" nested   array \"  )  )  ;", "}", "METHOD_END"], "methodName": ["includesNotInheritedTypeAnnotations"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . Bean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . newInstance (  )  ;", "bean . prop    =     \" value \"  ;", "TestUtil . call (  \"  { def   value ;    it . doStuff    {    value    =    it    }  ;    assert   value    =  =     \\  ' value \\  '     }  \"  ,    bean )  ;", "AsmBackedClassGeneratorTest . BeanWithOverriddenMethods   subBean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithOverriddenMethods . class )  . newInstance (  )  ;", "TestUtil . call (  \"  { def   value ;    it . doStuff    {    value    =    it    }  ;    assert   value    =  =     \\  ' overloaded \\  '     }  \"  ,    subBean )  ;", "}", "METHOD_END"], "methodName": ["mixesInClosureOverloadForActionMethod"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "assertThat ( conventionAware . getConventionMapping (  )  ,    instanceOf ( ConventionAwareHelper . class )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" prop \"  ,    TestUtil . TEST _ CLOSURE )  ;", "}", "METHOD_END"], "methodName": ["mixesInConventionAwareInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( DynamicObjectAware . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . newInstance (  )  ;", "DynamicObjectAware   dynamicBean    =     (  ( DynamicObjectAware )     ( bean )  )  ;", "dynamicBean . getAsDynamicObject (  )  . setProperty (  \" prop \"  ,     \" value \"  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "assertThat ( bean . doStuff (  \" some   value \"  )  ,    equalTo (  \"  { some   value }  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mixesInDynamicObjectAwareInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( ExtensionAware . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . newInstance (  )  ;", "ExtensionAware   dynamicBean    =     (  ( ExtensionAware )     ( bean )  )  ;", "assertThat ( dynamicBean . getExtensions (  )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["mixesInExtensionAwareInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( GeneratedSubclasses . is ( generatedClass )  )  ;", "assertEquals ( AsmBackedClassGeneratorTest . Bean . class ,    GeneratedSubclasses . unpack ( generatedClass )  )  ;", "}", "METHOD_END"], "methodName": ["mixesInGeneratedSubclassInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  ;", "assertTrue ( GroovyObject . class . isAssignableFrom ( generatedClass )  )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . newInstance (  )  ;", "GroovyObject   groovyObject    =     (  ( GroovyObject )     ( bean )  )  ;", "assertThat ( groovyObject . getMetaClass (  )  ,    notNullValue (  )  )  ;", "groovyObject . setProperty (  \" prop \"  ,     \" value \"  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "assertThat ( groovyObject . getProperty (  \" prop \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( groovyObject . invokeMethod (  \" doStuff \"  ,    new   Object [  ]  {     \" some   value \"     }  )  ,    equalTo (  (  ( Object )     (  \"  { some   value }  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["mixesInGroovyObjectInterface"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithVariousGettersAndSetters . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "TestUtil . call (  \"  {    it . finalGetter    ' another '  }  \"  ,    bean )  ;", "assertThat ( bean . getFinalGetter (  )  ,    equalTo (  \" another \"  )  )  ;", "TestUtil . call (  \"  {    it . writeOnly    1  2  }  \"  ,    bean )  ;", "assertThat ( bean . writeOnly ,    equalTo (  1  2  )  )  ;", "TestUtil . call (  \"  {    it . primitive    1  2  }  \"  ,    bean )  ;", "assertThat ( bean . getPrimitive (  )  ,    equalTo (  1  2  )  )  ;", "TestUtil . call (  \"  {    it . bool   true }  \"  ,    bean )  ;", "assertThat ( bean . isBool (  )  ,    equalTo ( true )  )  ;", "TestUtil . call (  \"  {    it . overloaded    ' value '  }  \"  ,    bean )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" chars    =    value \"  )  )  ;", "TestUtil . call (  \"  {    it . overloaded    1  2  }  \"  ,    bean )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" number    =     1  2  \"  )  )  ;", "TestUtil . call (  \"  {    it . overloaded   true }  \"  ,    bean )  ;", "assertThat ( bean . getOverloaded (  )  ,    equalTo (  \" object    =    true \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mixesInSetValueMethodForSingleValuedProperty"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . BeanWithDslMethods   bean    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithDslMethods . class )  . newInstance (  )  ;", "IConventionAware   conventionAware    =     (  ( IConventionAware )     ( bean )  )  ;", "conventionAware . getConventionMapping (  )  . map (  \" prop \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "return    \"  [ default ]  \"  ;", "}", "}  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  [ default ]  \"  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . prop    ' value '  }  \"  ,    bean )  ,    sameInstance (  (  ( Object )     ( bean )  )  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  [ value ]  \"  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . prop    1  .  2  }  \"  ,    bean )  ,    sameInstance (  (  ( Object )     ( bean )  )  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  <  1  .  2  >  \"  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . prop    1  }  \"  ,    bean )  ,    nullValue (  )  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \"  <  1  >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overridesExistingSetValueMethod"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   AsmBackedClassGeneratorTest . Bean >    generatedClass    =    generator . generate ( AsmBackedClassGeneratorTest . BeanWithConstructor . class )  ;", "AsmBackedClassGeneratorTest . Bean   bean    =    generatedClass . getConstructor ( String . class )  . newInstance (  \" value \"  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" value \"  )  )  ;", "bean    =    generatedClass . getConstructor (  )  . newInstance (  )  ;", "assertThat ( bean . getProp (  )  ,    equalTo (  \" default   value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["overridesPublicConstructors"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "generator . newInstance (  . UnconstructibleBean . class )  ;", "fail (  )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "assertThat ( e . getCause (  )  ,    sameInstance (  . UnconstructibleBean . failure )  )  ;", "}", "try    {", "generator . newInstance (  . Bean . class ,     \" arg 1  \"  ,     2  )  ;", "fail (  )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "}", "try    {", "generator . newInstance (  . AbstractBean . class )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Cannot   create   a   proxy   class   for   abstract   class    ' AbstractBean '  .  \"  )  )  ;", "}", "try    {", "generator . newInstance (  . PrivateBean . class )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Cannot   create   a   proxy   class   for   private   class    ' PrivateBean '  .  \"  )  )  ;", "}", "try    {", "generator . newInstance (  . FinalBean . class )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Cannot   create   a   proxy   class   for   final   class    ' FinalBean '  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["reportsConstructionFailure"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "TestDecoratedGroovyBean   bean    =    generator . generate ( TestDecoratedGroovyBean . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . metaClass . getConventionProperty    =     {     -  >     ' value '  }     }  \"  ,    bean )  ;", "assertThat ( TestUtil . call (  \"  {    it . hasProperty (  ' conventionProperty '  )     }  \"  ,    bean )  ,    notNullValue (  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . getConventionProperty (  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionProperty    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["respectsPropertiesAddedToMetaClassOfGroovyObject"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . Bean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . Bean . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . metaClass . getConventionProperty    =     {     -  >     ' value '  }     }  \"  ,    bean )  ;", "assertThat ( TestUtil . call (  \"  {    it . hasProperty (  ' conventionProperty '  )     }  \"  ,    bean )  ,    notNullValue (  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . getConventionProperty (  )     }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . conventionProperty    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["respectsPropertiesAddedToMetaClassOfJavaObject"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AsmBackedClassGeneratorTest . DynamicObjectBean   bean    =    generator . generate ( AsmBackedClassGeneratorTest . DynamicObjectBean . class )  . newInstance (  )  ;", "TestUtil . call (  \"  {    it . prop    =     ' value '     }  \"  ,    bean )  ;", "assertThat ( TestUtil . call (  \"  {    it . prop    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . getAsDynamicObject (  )  . setProperty (  \" prop \"  ,     \" value 2  \"  )  ;", "assertThat ( TestUtil . call (  \"  {    it . prop    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  \" value 2  \"  )  )  )  )  ;", "TestUtil . call (  \"  {    it . ext . anotherProp    =     1  2     }  \"  ,    bean )  ;", "assertThat ( bean . getAsDynamicObject (  )  . getProperty (  \" anotherProp \"  )  ,    equalTo (  (  ( Object )     (  1  2  )  )  )  )  ;", "assertThat ( TestUtil . call (  \"  {    it . anotherProp    }  \"  ,    bean )  ,    equalTo (  (  ( Object )     (  1  2  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesExistingGetAsDynamicObjectMethod"], "fileName": "org.gradle.api.internal.AsmBackedClassGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildDefinition ( null ,    startParameter ,    DefaultPluginRequests . EMPTY )  ;", "}", "METHOD_END"], "methodName": ["fromStartParameter"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "StartParameter   includedBuildStartParam    =    startParameter . newBuild (  )  ;", "includedBuildStartParam . setCurrentDir ( buildRootDir )  ;", "includedBuildStartParam . setSearchUpwards ( false )  ;", "includedBuildStartParam . setConfigureOnDemand ( false )  ;", "includedBuildStartParam . setInitScripts ( startParameter . getInitScripts (  )  )  ;", "return   new    ( buildRootDir ,    includedBuildStartParam ,    pluginRequests )  ;", "}", "METHOD_END"], "methodName": ["fromStartParameterForBuild"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "return   buildRootDir ;", "}", "METHOD_END"], "methodName": ["getBuildRootDir"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "return   injectedSettingsPlugins ;", "}", "METHOD_END"], "methodName": ["getInjectedPluginRequests"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["getStartParameter"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildDefinition ( buildRootDir ,    startParameter . newInstance (  )  ,    injectedSettingsPlugins )  ;", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.gradle.api.internal.BuildDefinition"}, {"methodBody": ["METHOD_START", "{", "transformers . add ( new   Transformer < T ,    T >  (  )     {", "public   T   transform ( T   original )     {", "transformer . setDelegate ( original )  ;", "transformer . setResolveStrategy ( DELEGATE _ FIRST )  ;", "Object   value    =    transformer . call ( original )  ;", "if    ( type . isInstance ( value )  )     {", "return   type . cast ( value )  ;", "}", "if    (  (  ( type )     =  =     ( String . class )  )     &  &     ( value   instanceof   GString )  )     {", "return   type . cast ( value . toString (  )  )  ;", "}", "return   original ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.ChainingTransformer"}, {"methodBody": ["METHOD_START", "{", "transformers . add ( transformer )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.ChainingTransformer"}, {"methodBody": ["METHOD_START", "{", "return    !  ( transformers . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasTransformers"], "fileName": "org.gradle.api.internal.ChainingTransformer"}, {"methodBody": ["METHOD_START", "{", "T   value    =    original ;", "for    (  < T ,    T >    transformer    :    transformers )     {", "value    =    type . cast ( transformer . transform ( value )  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.ChainingTransformer"}, {"methodBody": ["METHOD_START", "{", "ThreadGlobalInstantiator . set ( this )  ;", "try    {", "return   instantiator . newInstance ( c . generate ( type )  ,    parameters )  ;", "}    finally    {", "ThreadGlobalInstantiator . set ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.gradle.api.internal.ClassGeneratorBackedInstantiator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( getStore (  )  . containsCollection ( collection )  )  )     {", "getStore (  )  . addd ( collection )  ;", "collection . all ( backingSet . getEventRegister (  )  . getAddAction (  )  )  ;", "collection . whenObjectRemoved ( backingSet . getEventRegister (  )  . getRemoveAction (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addCollection"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "whenObjectAdded ( action )  ;", "for    ( T   t    :    this )     {", "action . execute ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "DefaultDomainObjectSet < T >    backingSet    =    new   DefaultDomainObjectSet < T >  ( type ,    new   CompositeDomainObjectSet . DomainObjectCompositeCollection < T >  (  )  )  ;", "CompositeDomainObjectSet < T >    out    =    new   CompositeDomainObjectSet < T >  ( backingSet )  ;", "for    ( DomainObjectCollection <  ?    extends   T >    c    :    collections )     {", "out . addCollection ( c )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return    (  ( CompositeDomainObjectSet . DomainObjectCompositeCollection )     ( this . backingSet . getStore (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getStore"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "getStore (  )  . removeComposited ( collection )  ;", "Action <  ?    super   T >    action    =    this . backingSet . getEventRegister (  )  . getRemoveAction (  )  ;", "for    ( T   item    :    collection )     {", "action . execute ( item )  ;", "}", "}", "METHOD_END"], "methodName": ["removeCollection"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   getStore (  )  . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   super . whenObjectAdded ( Actions . filter ( action ,    uniqueSpec )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   super . whenObjectRemoved ( Actions . filter ( action ,    notInSpec )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.CompositeDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "ConfigureUtil . configureByMap ( properties ,    thing ,    mandatoryProperties )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.ConfigureByMapAction"}, {"methodBody": ["METHOD_START", "{", "return    _ convention ;", "}", "METHOD_END"], "methodName": ["getConvention"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( isExplicitValue )     {", "return   actualValue ;", "}", "T   returnValue    =    actualValue ;", "if    (  _ mappings . containsKey ( propertyName )  )     {", "boolean   useMapping    =    true ;", "if    (  ( actualValue   instanceof   Collection )     &  &     (  !  (  (  ( Collection <  ?  >  )     ( actualValue )  )  . isEmpty (  )  )  )  )     {", "useMapping    =    false ;", "} else", "if    (  ( actualValue   instanceof   Map )     &  &     (  !  (  (  ( Map <  ?  ,     ?  >  )     ( actualValue )  )  . isEmpty (  )  )  )  )     {", "useMapping    =    false ;", "}", "if    ( useMapping )     {", "returnValue    =     (  ( T )     (  _ mappings . get ( propertyName )  . getValue (  _ c ,     _ source )  )  )  ;", "}", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["getConventionValue"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "return   map ( propertyName ,    new   ConventionAwareHelper . MappedPropertyImpl (  )     {", "public   Object   doGetValue ( Convention   convention ,    IConventionAware   conventionAwareObject )     {", "switch    ( value . getMaximumNumberOfParameters (  )  )     {", "case    0     :", "return   value . call (  )  ;", "case    1     :", "return   value . call ( convention )  ;", "default    :", "return   value . call ( convention ,    conventionAwareObject )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "return   map ( propertyName ,    new   ConventionAwareHelper . MappedPropertyImpl (  )     {", "public   Object   doGetValue ( Convention   convention ,    IConventionAware   conventionAwareObject )     {", "return   GUtil . uncheckedCall ( value )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "if    (  !  (  _ propertyNames . contains ( propertyName )  )  )     {", "throw   new   InvalidUserDataExcep (  (  \" You   can ' t   map   a   property   that   does   not   exist :    propertyName =  \"     +    propertyName )  )  ;", "}", "_ mappings . put ( propertyName ,    mapping )  ;", "return   mapping ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Closure )     {", "map ( name ,     (  ( Closure )     ( value )  )  )  ;", "} else    {", "throw   new   MissingPropertyExcep ( name ,    getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.ConventionAwareHelper"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" list 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   WrapUtil . toList (  \" a \"  )  ;", "}", "}  )  . cache (  )  ;", "assertSame ( conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["canEnableCachingOfPropertyValue"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "Callable   callable    =    new   Callable (  )     {", "public   Object   call (  )    throws   Exception    {", "return   WrapUtil . toList (  \" a \"  )  ;", "}", "}  ;", "c . map (  \" list 1  \"  ,    callable )  ;", "assertThat ( c . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList (  \" a \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canMapPropertiesUsingCallable"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" list 1  \"  ,    TestUtil . toClosure (  \"  {     [  ' a '  ]     }  \"  )  )  ;", "assertThat ( conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList (  \" a \"  )  )  )  )  )  ;", "conventionAware . map (  \" list 1  \"  ,    TestUtil . toClosure (  \"  {    convention    -  >     [ convention ]     }  \"  )  )  ;", "assertThat ( conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList ( conventionAware . getConvention (  )  )  )  )  )  )  ;", "conventionAware . map (  \" list 1  \"  ,    TestUtil . toClosure (  \"  {    convention ,    object    -  >     [ convention ,    object ]     }  \"  )  )  ;", "assertThat ( conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList ( conventionAware . getConvention (  )  ,    testTask )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canMapPropertiesUsingClosure"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "final   List   conventionList 1     =    WrapUtil . toList (  \" a \"  )  ;", "c . map (  \" list 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   conventionList 1  ;", "}", "}  )  ;", "assertSame ( conventionList 1  ,    c . getConventionValue ( null ,     \" list 1  \"  ,    false )  )  ;", "List   expectedList 1     =    WrapUtil . toList (  \" b \"  )  ;", "assertSame ( expectedList 1  ,    c . getConventionValue ( expectedList 1  ,     \" list 1  \"  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["canOverwriteProperties"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "TestUtil . call (  \"  {    it . list 1     =     {     [  ' a '  ]     }     }  \"  ,    conventionAware )  ;", "assertThat ( conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList (  \" a \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canSetMappingUsingDynamicProperty"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" unknownProp \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )    throws   Exception    {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["cannotMapUnknownProperty"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" list 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  )  ;", "List < Object >    value    =    Collections . emptyList (  )  ;", "assertThat ( conventionAware . getConventionValue ( value ,     \" list 1  \"  ,    true )  ,    sameInstance ( value )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotUseMappingWhenExplicitValueProvided"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" list 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   WrapUtil . toList (  \" a \"  )  ;", "}", "}  )  ;", "Object   value 1     =    conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ;", "Object   value 2     =    conventionAware . getConventionValue ( null ,     \" list 1  \"  ,    false )  ;", "assertEquals ( value 1  ,    value 2  )  ;", "assertNotSame ( value 1  ,    value 2  )  ;", "}", "METHOD_END"], "methodName": ["notCachesPropertyValuesByDefault"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "testTask    =    TestUtil . create ( temporaryFolder )  . task ( TestTask . class )  ;", "conventionAware    =    new    ( testTask )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" list 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   WrapUtil . toList (  \" a \"  )  ;", "}", "}  )  ;", "assertThat ( conventionAware . getConventionValue ( Collections . emptyList (  )  ,     \" list 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toList (  \" a \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesConventionValueForEmptyCollection"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "conventionAware . map (  \" map 1  \"  ,    new   Callable < Object >  (  )     {", "public   Object   call (  )     {", "return   WrapUtil . toMap (  \" a \"  ,     \" b \"  )  ;", "}", "}  )  ;", "assertThat ( conventionAware . getConventionValue ( Collections . emptyMap (  )  ,     \" map 1  \"  ,    false )  ,    equalTo (  (  ( Object )     ( WrapUtil . toMap (  \" a \"  ,     \" b \"  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesConventionValueForEmptyMap"], "fileName": "org.gradle.api.internal.ConventionAwareHelperTest"}, {"methodBody": ["METHOD_START", "{", "getConventionMapping (  )  . map ( property ,    mapping )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["conventionMapping"], "fileName": "org.gradle.api.internal.ConventionTask"}, {"methodBody": ["METHOD_START", "{", "getConventionMapping (  )  . map ( property ,    mapping )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["conventionMapping"], "fileName": "org.gradle.api.internal.ConventionTask"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" GRADLE _ RUNTIME \"  )  )     {", "classpath    =     . EMPTY ;", "for    ( Module   module    :    moduleRegistry . getModule (  \" gradle - launcher \"  )  . getAllRequiredModules (  )  )     {", "classpath    =    classpath . plus ( module . getClasspath (  )  )  ;", "}", "return   classpath ;", "}", "if    ( name . equals (  \" GRADLE _ INSTALLATION _ BEACON \"  )  )     {", "return   moduleRegistry . getModule (  \" gradle - installation - beacon \"  )  . getImplementationClasspath (  )  ;", "}", "if    ( name . equals (  \" COMMONS _ CLI \"  )  )     {", "return   moduleRegistry . getExternalModule (  \" commons - cli \"  )  . getClasspath (  )  ;", "}", "if    ( name . equals (  \" ANT \"  )  )     {", "classpath    =     . EMPTY ;", "classpath    =    classpath . plus ( moduleRegistry . getExternalModule (  \" ant \"  )  . getClasspath (  )  )  ;", "classpath    =    classpath . plus ( moduleRegistry . getExternalModule (  \" ant - launcher \"  )  . getClasspath (  )  )  ;", "return   classpath ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClassPath"], "fileName": "org.gradle.api.internal.DefaultClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( ClassPathProvider   provider    :    providers )     {", "ClassPath   classpath    =    provider . findClassPath ( name )  ;", "if    ( classpath    !  =    null )     {", "return   classpath ;", "}", "}", "throw   new   IllegalArgumentException ( String . format (  \" unknown   classpath    '  % s '    requested .  \"  ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["getClassPath"], "fileName": "org.gradle.api.internal.DefaultClassPathRegistry"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "return   doAdd ( toAdd )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "boolean   changed    =    false ;", "for    ( T   o    :    c )     {", "if    ( doAdd ( o )  )     {", "changed    =    true ;", "}", "}", "return   changed ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "all ( toAction ( action )  )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "action    =    whenObjectAdded ( action )  ;", "if    ( store . constantTimeIsEmpty (  )  )     {", "return ;", "}", "< T >    copied    =    null ;", "for    ( T   t    :    this )     {", "if    ( copied    =  =    null )     {", "copied    =    Lists . newArrayListWithExpectedSize ( estimatedSize (  )  )  ;", "}", "copied . add ( t )  ;", "}", "if    ( copied    !  =    null )     {", "for    ( T   t    :    copied )     {", "action . execute ( t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "mutateAction . execute ( null )  ;", "}", "METHOD_END"], "methodName": ["assertMutable"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "mutateAction    =    mutateAction . add ( action )  ;", "}", "METHOD_END"], "methodName": ["beforeChange"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "if    ( store . constantTimeIsEmpty (  )  )     {", "return ;", "}", "[  ]    c    =    toArray (  )  ;", "getStore (  )  . clear (  )  ;", "for    (    o    :    c )     {", "eventRegister . getRemoveAction (  )  . execute (  (  ( T )     ( o )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "flushPending (  )  ;", "return   getStore (  )  . conts ( o )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   getStore (  )  . containsAll ( c )  ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   CollectionFilter < S >  ( type )  ;", "}", "METHOD_END"], "methodName": ["createFilter"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   CollectionFilter < S >  ( type ,    spec )  ;", "}", "METHOD_END"], "methodName": ["createFilter"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   createFilter ( getType (  )  ,    filter )  ;", "}", "METHOD_END"], "methodName": ["createFilter"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( getStore (  )  . add ( toAdd )  )     {", "didAdd ( toAdd )  ;", "eventRegister . getAddA (  )  . execute ( toAdd )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["doAdd"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( getStore (  )  . remove ( o )  )     {", "@ SuppressWarnings (  \" unchecked \"  )", "T   cast    =     (  ( T )     ( o )  )  ;", "didRemove ( cast )  ;", "eventRegister . getRemoveA (  )  . execute ( cast )  ;", "return   true ;", "} else    {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["doRemove"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDomainObjectCollection < S >  ( this ,    filter )  ;", "}", "METHOD_END"], "methodName": ["filtered"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   FlushingEventRegister < S >  ( filter ,    getEventRegister (  )  )  ;", "}", "METHOD_END"], "methodName": ["filteredEvents"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   filteredStore ( filter ,    new   FlushingElementSource ( filter )  )  ;", "}", "METHOD_END"], "methodName": ["filteredStore"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   FilteredCollection < T ,    S >  ( elementSource ,    filter )  ;", "}", "METHOD_END"], "methodName": ["filteredStore"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   findAll ( cl ,    new   ArrayList < T >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["findAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( store . constantTimeIsEmpty (  )  )     {", "return   matches ;", "}", "for    ( T   t    :    filteredStore ( createFilter ( Specs .  <  > convertClosureToSpec ( cl )  )  )  )     {", "matches . add ( t )  ;", "}", "return   matches ;", "}", "METHOD_END"], "methodName": ["findAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pending )     !  =    null )     {", "for    ( ProviderI <  ?    extends   T >    provider    :    pending )     {", "doAdd ( provider . get (  )  )  ;", "}", "pending . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["flushPending"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pending )     !  =    null )     {", "ListIterator < ProviderI <  ?    extends   T >  >    iterator    =    pending . listIterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "ProviderI <  ?    extends   T >    provider    =    iterator . next (  )  ;", "if    (  (  ( provider . getType (  )  )     =  =    null )     |  |     ( type . isAssignableFrom ( provider . getType (  )  )  )  )     {", "doAdd ( provider . get (  )  )  ;", "iterator . remove (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["flushPending"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   eventRegister ;", "}", "METHOD_END"], "methodName": ["getEventRegister"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   store ;", "}", "METHOD_END"], "methodName": ["getStore"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return    ( getStore (  )  . isEmpty (  )  )     &  &     (  (  ( pending )     =  =    null )     |  |     ( pending . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "flushPending (  )  ;", "return   iatorNoFlush (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( store . constantTimeIsEmpty (  )  )     {", "return   Iators . emptyIator (  )  ;", "}", "return   new   IatorImpl ( store . iator (  )  )  ;", "}", "METHOD_END"], "methodName": ["iteratorNoFlush"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   matching ( Specs .  < T > convertClosureToSpec ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "return   doRemove ( o )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "if    ( store . constantTimeIsEmpty (  )  )     {", "return   false ;", "}", "boolean   changed    =    false ;", "for    (    o    :    c )     {", "if    ( doRemove ( o )  )     {", "changed    =    true ;", "}", "}", "return   changed ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "[  ]    existingItems    =    toArray (  )  ;", "boolean   changed    =    false ;", "for    (    existingItem    :    existingItems )     {", "if    (  !  ( target . contains ( existingItem )  )  )     {", "doRemove ( existingItem )  ;", "changed    =    true ;", "}", "}", "return   changed ;", "}", "METHOD_END"], "methodName": ["retainAll"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return    ( store . size (  )  )     +     (  ( pending )     =  =    null    ?     0     :    pending . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   ConfigureUtil . configureUsing ( action )  ;", "}", "METHOD_END"], "methodName": ["toAction"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "whenObjectAdded ( toAction ( action )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "eventRegister . registerEagerAddAction ( type ,    action )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "whenObjectRemoved ( toAction ( action )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "eventRegister . registerRemoveAction ( type ,    action )  ;", "return   action ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( type )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "DomainObjectCollection < S >    result    =    withType ( type )  ;", "result . all ( configureClosure )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "DomainObjectCollection < S >    result    =    withType ( type )  ;", "result . all ( configureAction )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DefaultDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   addRule ( new   DefaultNamedDomainObjectCollection . RuleAdapter ( description )     {", "@ Override", "public   void   apply ( String   domainObjectName )     {", "ruleAction . call ( domainObjectName )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "rules . add ( rule )  ;", "return   rule ;", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( rules . isEmpty (  )  )     |  |     ( applyingRulesFor . contains ( name )  )  )     {", "return   false ;", "}", "applyingRulesFor . add ( name )  ;", "try    {", "for    ( Rule   rule    :    rules )     {", "ruply ( name )  ;", "}", "}    finally    {", "applyingRulesFor . remove ( name )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["applyRules"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertCanAdd ( getNamer (  )  . determineName ( t )  )  ;", "}", "METHOD_END"], "methodName": ["assertCanAdd"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( hasWithName ( name )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   add   a    % s   with   name    '  % s '    as   a    % s   with   that   name   already   exists .  \"  ,    getTypeDisplayName (  )  ,    name ,    getTypeDisplayName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertCanAdd"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   UnknownDomainObjectException ( String . format (  \"  % s   with   name    '  % s '    not   found .  \"  ,    getTypeDisplayName (  )  ,    name )  )  ;", "}", "METHOD_END"], "methodName": ["createNotFoundException"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   instantiator . newInstance ( DefaultNamedDomainObjectCollection . class ,    this ,    filter ,    instantiator ,    namer )  ;", "}", "METHOD_END"], "methodName": ["filtered"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   index . filter ( filter )  ;", "}", "METHOD_END"], "methodName": ["filteredIndex"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "T   value    =    findByNameWithoutRules ( name )  ;", "if    ( value    !  =    null )     {", "return   value ;", "}", "if    (  ( pending )     !  =    null )     {", "Provider <  ?    extends   T >    provider    =    pending . remove ( name )  ;", "if    ( provider    !  =    null )     {", "return   provider . get (  )  ;", "}", "}", "if    (  !  ( applyRules ( name )  )  )     {", "return   null ;", "}", "return   findByNameWithoutRules ( name )  ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   index . get ( name )  ;", "}", "METHOD_END"], "methodName": ["findByNameWithoutRules"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   index . asMap (  )  ;", "}", "METHOD_END"], "methodName": ["getAsMap"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   getByName ( name )  ;", "}", "METHOD_END"], "methodName": ["getAt"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "T   t    =    findByName ( name )  ;", "if    ( t    =  =    null )     {", "throw   createNotFoundException ( name )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "T   t    =    getByName ( name )  ;", "ConfigureUtil . configure ( configureClosure ,    t )  ;", "return   t ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return    ( getTypeDisplayName (  )  )     +     \"    container \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   elementsDynamicObject ;", "}", "METHOD_END"], "methodName": ["getElementsAsDynamicObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   instantiator ;", "}", "METHOD_END"], "methodName": ["getInstantiator"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Namer )     ( this . namer )  )  ;", "}", "METHOD_END"], "methodName": ["getNamer"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "NavigableSet < String >    realizedNames    =    index . asMap (  )  . navigableKeySet (  )  ;", "if    (  (  ( pending )     =  =    null )     |  |     ( pending . isEmpty (  )  )  )     {", "return   realizedNames ;", "}", "TreeSet < String >    allNames    =    new   TreeSet < String >  ( realizedNames )  ;", "allNames . addAll ( pending . keySet (  )  )  ;", "return   allNames ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( rules )  ;", "}", "METHOD_END"], "methodName": ["getRules"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   getType (  )  . getSimpleName (  )  ;", "}", "METHOD_END"], "methodName": ["getTypeDisplayName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return    (  ( index . get ( name )  )     !  =    null )     |  |     (  (  ( pending )     !  =    null )     &  &     ( pending . containsKey ( name )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasWithName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "for    ( T   t    :    getStore (  )  )     {", "index . put ( namer . determine ( t )  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["index"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   matching ( Specs .  < T > convertClosureToSpec ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "T   it    =    getByName ( name )  ;", "if    ( it    !  =    null )     {", "if    ( remove ( it )  )     {", "return   it ;", "} else    {", "throw   new   IllegalStateException ( String . format (  \" found    '  % s '    with   name    '  % s '    but   remove (  )    returned   false \"  ,    it ,    name )  )  ;", "}", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["removeByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "whenKnown    =    whenKnown . add ( action )  ;", "Iterator < T >    iterator    =    iteratorNoFlush (  )  ;", "while    ( iterator . hasNext (  )  )     {", "T   next    =    iterator . next (  )  ;", "whenKnown . execute ( new    . ObjectBackedElementInfo < T >  ( namer . determineName ( next )  ,    next )  )  ;", "}", "if    (  ( pending )     !  =    null )     {", "for    ( Map . Entry < String ,    Provider <  ?    extends   T >  >    entry    :    pending . entrySet (  )  )     {", "whenKnown . execute ( new    . ProviderBackedElementInfo < T >  ( entry . getKey (  )  ,    entry . getValue (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["whenElementKnown"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( type )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectCollection"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "assertCanAdd ( element )  ;", "getStore (  )  . add ( index ,    element )  ;", "didAdd ( element )  ;", "getEventRegis (  )  . getAddAction (  )  . execute ( element )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "boolean   changed    =    false ;", "int   current    =    index ;", "for    ( T   t    :    c )     {", "if    (  !  ( hasWithName ( ger (  )  . determineName ( t )  )  )  )     {", "getStore (  )  . add ( current ,    t )  ;", "didAdd ( t )  ;", "getEventRegister (  )  . getAddAction (  )  . execute ( t )  ;", "changed    =    true ;", "current +  +  ;", "}", "}", "return   changed ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   getStore (  )  . get ( index )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   getStore (  )  . indexOf ( o )  ;", "}", "METHOD_END"], "methodName": ["indexOf"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   getStore (  )  . lastIndexOf ( o )  ;", "}", "METHOD_END"], "methodName": ["lastIndexOf"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   new   ListIteratorImpl ( getStore (  )  . listIterator (  )  )  ;", "}", "METHOD_END"], "methodName": ["listIterator"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   new   ListIteratorImpl ( getStore (  )  . listIterator ( index )  )  ;", "}", "METHOD_END"], "methodName": ["listIterator"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "T   element    =    getStore (  )  . remove ( index )  ;", "if    ( element    !  =    null )     {", "didRemove ( element )  ;", "}", "getEventRegis (  )  . getRemoveAction (  )  . execute ( element )  ;", "return   element ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "assertMutable (  )  ;", "assertCanAdd ( element )  ;", "T   oldElement    =    getStore (  )  . set ( index ,    element )  ;", "if    ( oldElement    !  =    null )     {", "didRemove ( oldElement )  ;", "}", "getEventRegis (  )  . getRemoveAction (  )  . execute ( oldElement )  ;", "didAdd ( element )  ;", "getEventRegis (  )  . getAddAction (  )  . execute ( element )  ;", "return   oldElement ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( getStore (  )  . subList ( fromIndex ,    toIndex )  )  ;", "}", "METHOD_END"], "methodName": ["subList"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectList"}, {"methodBody": ["METHOD_START", "{", "final   String   testPropertyKey    =     \" addRuleByAction \"  ;", "final   String   expectedTaskName    =     \" someTaskName \"  ;", "container . addRule (  \" description \"  ,    new   Action < String >  (  )     {", "@ Override", "public   void   execute ( String   taskName )     {", "System . setProperty ( testPropertyKey ,    taskName )  ;", "}", "}  )  ;", "container . getRules (  )  . get (  0  )  . apply ( expectedTaskName )  ;", "assertThat ( System . getProperty ( testPropertyKey )  ,    equalTo ( expectedTaskName )  )  ;", "System . clearProperty ( testPropertyKey )  ;", "}", "METHOD_END"], "methodName": ["addRuleByAction"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "String   testPropertyKey    =     \" addRuleByClosure \"  ;", "String   expectedTaskName    =     \" someTaskName \"  ;", "container . addRule (  \" description \"  ,    TestUtil . toClosure ( String . format (  \"  {    taskName    -  >    System . setProperty (  '  % s '  ,    taskName )     }  \"  ,    testPropertyKey )  )  )  ;", "container . getRules (  )  . get (  0  )  . apply ( expectedTaskName )  ;", "assertThat ( System . getProperty ( testPropertyKey )  ,    equalTo ( expectedTaskName )  )  ;", "System . clearProperty ( testPropertyKey )  ;", "}", "METHOD_END"], "methodName": ["addRuleByClosure"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "container . addRule ( new   Rule (  )     {", "public   String   getDescription (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "public   void   apply ( String   task )     {", "container . add ( bean )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addRuleFor"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "}", "}  )  ;", "container . add ( bean )  ;", "container . all ( action )  ;", "}", "METHOD_END"], "methodName": ["allCallsActionForEachExistingObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "}", "}  )  ;", "container . all ( action )  ;", "container . add ( bean )  ;", "}", "METHOD_END"], "methodName": ["allCallsActionForEachNewObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   TestClosure   closure    =    context . mock ( TestClosure . class )  ;", "final    . Bean   bean    =    new    . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( closure )  . call ( bean )  ;", "}", "}  )  ;", "container . add ( bean )  ;", "container . all ( TestUtil . toClosure ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["allCallsClosureForEachExistingObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   TestClosure   closure    =    context . mock ( TestClosure . class )  ;", "final    . Bean   bean    =    new    . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( closure )  . call ( bean )  ;", "}", "}  )  ;", "container . all ( TestUtil . toClosure ( closure )  )  ;", "container . add ( bean )  ;", "}", "METHOD_END"], "methodName": ["allCallsClosureForEachNewObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "}", "}  )  ;", "container . whenObjectAdded ( action )  ;", "container . add ( bean )  ;", "}", "METHOD_END"], "methodName": ["callsActionWhenObjectAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "}", "}  )  ;", "container . whenObjectRemoved ( action )  ;", "container . add ( bean )  ;", "container . removeByName (  \" bean \"  )  ;", "}", "METHOD_END"], "methodName": ["callsActionWhenObjectRemoved"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" other \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "one ( action )  . execute ( bean 2  )  ;", "}", "}  )  ;", "container . whenObjectAdded ( action )  ;", "container . addAll ( WrapUtil . toList ( bean ,    bean 2  )  )  ;", "}", "METHOD_END"], "methodName": ["callsActionWhenObjectsAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   TestClosure   closure    =    context . mock ( TestClosure . class )  ;", "final    . Bean   bean    =    new    . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( closure )  . call ( bean )  ;", "}", "}  )  ;", "container . whenObjectAdded ( TestUtil . toClosure ( closure )  )  ;", "container . add ( bean )  ;", "}", "METHOD_END"], "methodName": ["callsClosureWhenObjectAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "container . add ( bean )  ;", "assertThat ( container . getByName (  \" a \"  ,    new   Action < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "@ Override", "public   void   execute ( DefaultNamedDomainObjectSetTest . Bean   bean )     {", "bean . setBeanProperty (  \" hi \"  )  ;", "}", "}  )  ,    sameInstance ( bean )  )  ;", "assertThat ( bean . getBeanProperty (  )  ,    equalTo (  \" hi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canApplyActionToDomainObjectByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b 1  \"  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b 2  \"  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b 3  \"  )  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    !  =    bean ;", "}", "}  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec 2     =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    !  =    bean 2  ;", "}", "}  ;", "container . add ( bean )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 3  )  ;", "DomainObjectCollection < DefaultNamedDomainObjectSetTest . Bean >    collection    =    container . matching ( spec )  . matching ( spec 2  )  ;", "assertThat ( WrapUtil . toList ( collection )  ,    equalTo ( WrapUtil . toList ( bean 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canChainFilteredCollections"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "container . add ( bean )  ;", "assertThat ( container . getByName (  \" a \"  ,    TestUtil . toClosure (  \"  {    beanProperty    =     ' hi '     }  \"  )  )  ,    sameInstance ( bean )  )  ;", "assertThat ( bean . getBeanProperty (  )  ,    equalTo (  \" hi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canConfigureDomainObjectByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "class   OtherBean   extends   DefaultNamedDomainObjectSetTest . Bean    {", "public   OtherBean ( String   name )     {", "super ( name )  ;", "}", "public   OtherBean (  )     {", "}", "}", "final   Action < OtherBean >    action    =    context . mock ( Action . class )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b 1  \"  )  ;", "final   OtherBean   bean 2     =    new   OtherBean (  \" b 2  \"  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 2  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean 2  )  ;", "}", "}  )  ;", "container . withType ( OtherBean . class ,    action )  ;", "}", "METHOD_END"], "methodName": ["canExecuteActionForAllElementsInATypeFilteredCollection"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "class   OtherBean   extends   DefaultNamedDomainObjectSetTest . Bean    {", "public   OtherBean ( String   name )     {", "super ( name )  ;", "}", "public   OtherBean (  )     {", "}", "}", "final   TestClosure   closure    =    context . mock ( TestClosure . class )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b 1  \"  )  ;", "final   OtherBean   bean 2     =    new   OtherBean (  \" b 2  \"  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 2  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( closure )  . call ( bean 2  )  ;", "}", "}  )  ;", "container . withType ( OtherBean . class ,    TestUtil . toClosure ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["canExecuteClosureForAllElementsInATypeFilteredCollection"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "container . add ( bean )  ;", "assertThat ( container . findByName (  \" a \"  )  ,    sameInstance ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["canFindDomainObjectByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 3  )  ;", "assertThat ( container . getAsMap (  )  ,    equalTo ( GUtil . map (  \" a \"  ,    bean 1  ,     \" b \"  ,    bean 2  ,     \" c \"  ,    bean 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllDomainObjectsAsMap"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( container . getAsMap (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllDomainObjectsAsMapForEmptyContainer"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( container . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllDomainObjectsForEmptyContainer"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 3  )  ;", "assertThat ( WrapUtil . toList ( container )  ,    equalTo ( WrapUtil . toList ( bean 1  ,    bean 2  ,    bean 3  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllDomainObjectsOrderedByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    =  =    bean 2  ;", "}", "}  ;", "container . add ( bean 1  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 3  )  ;", "assertThat ( WrapUtil . toList ( container . matching ( spec )  )  ,    equalTo ( WrapUtil . toList ( bean 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllMatchingDomainObjectsOrderedByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "container . add ( bean )  ;", "assertThat ( container . getByName (  \" a \"  )  ,    sameInstance ( bean )  )  ;", "assertThat ( container . getAt (  \" a \"  )  ,    sameInstance ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["canGetDomainObjectByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "class   OtherBean   extends   DefaultNamedDomainObjectSetTest . Bean    {", "public   OtherBean ( String   name )     {", "super ( name )  ;", "}", "}", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "OtherBean   bean 2     =    new   OtherBean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 3  )  ;", "assertThat ( WrapUtil . toList ( container . withType ( DefaultNamedDomainObjectSetTest . Bean . class )  )  ,    equalTo ( WrapUtil . toList ( bean 1  ,    bean 2  ,    bean 3  )  )  )  ;", "assertThat ( WrapUtil . toList ( container . withType ( OtherBean . class )  )  ,    equalTo ( WrapUtil . toList ( bean 2  )  )  )  ;", "assertThat ( container . withType ( OtherBean . class )  . findByName (  \" a \"  )  ,    nullValue (  )  )  ;", "assertThat ( container . withType ( OtherBean . class )  . findByName (  \" b \"  )  ,    sameInstance ( bean 2  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetFilteredCollectionContainingAllObjectsWhichHaveType"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    !  =    bean 1  ;", "}", "}  ;", "TestClosure   testClosure    =    new   TestClosure (  )     {", "public   Object   call ( Object   param )     {", "return   param    !  =    bean 1  ;", "}", "}  ;", "container . add ( bean 1  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 3  )  ;", "assertThat ( WrapUtil . toList ( container . matching ( spec )  )  ,    equalTo ( WrapUtil . toList ( bean 2  ,    bean 3  )  )  )  ;", "assertThat ( WrapUtil . toList ( container . matching ( TestUtil . toClosure ( testClosure )  )  )  ,    equalTo ( WrapUtil . toList ( bean 2  ,    bean 3  )  )  )  ;", "assertThat ( container . matching ( spec )  . findByName (  \" a \"  )  ,    nullValue (  )  )  ;", "assertThat ( container . matching ( spec )  . findByName (  \" b \"  )  ,    sameInstance ( bean 2  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetFilteredCollectionContainingAllObjectsWhichMeetSpec"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 1  )  ;", "container . add ( bean 3  )  ;", "Iterator < DefaultNamedDomainObjectSetTest . Bean >    iterator    =    container . iterator (  )  ;", "assertThat ( iterator . next (  )  ,    sameInstance ( bean 1  )  )  ;", "assertThat ( iterator . next (  )  ,    sameInstance ( bean 2  )  )  ;", "assertThat ( iterator . next (  )  ,    sameInstance ( bean 3  )  )  ;", "assertFalse ( iterator . hasNext (  )  )  ;", "}", "METHOD_END"], "methodName": ["canIterateOverDomainObjectsOrderedByName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "Iterator < DefaultNamedDomainObjectSetTest . Bean >    iterator    =    container . iterator (  )  ;", "assertFalse ( iterator . hasNext (  )  )  ;", "}", "METHOD_END"], "methodName": ["canIterateOverEmptyContainer"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "addRuleFor ( bean )  ;", "assertThat ( container . getByName (  \" bean \"  ,    TestUtil . toClosure (  \"  {    beanProperty    =     ' hi '     }  \"  )  )  ,    sameInstance ( bean )  )  ;", "assertThat ( bean . getBeanProperty (  )  ,    equalTo (  \" hi \"  )  )  ;", "}", "METHOD_END"], "methodName": ["configureDomainObjectInvokesRuleForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "container . add ( bean )  ;", "container . whenObjectAdded ( action )  ;", "container . add ( bean )  ;", "}", "METHOD_END"], "methodName": ["doesNotCallActionWhenDuplicateObjectAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" other \"  )  ;", "container . add ( bean )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean 2  )  ;", "}", "}  )  ;", "container . whenObjectAdded ( action )  ;", "container . addAll ( WrapUtil . toList ( bean ,    bean 2  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotCallActionWhenDuplicateObjectsAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "container . whenObjectRemoved ( action )  ;", "container . remove ( new   DefaultNamedDomainObjectSetTest . Bean (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotCallActionWhenUnknownObjectRemoved"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" child \"  )  ;", "container . add ( bean )  ;", "assertThat ( TestUtil . call (  \"  {    it [  ' child '  ]     }  \"  ,    container )  ,    sameInstance (  (  ( Object )     ( bean )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["eachObjectIsAvailableUsingAnIndex"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < DefaultNamedDomainObjectSetTest . Bean >    action    =    context . mock ( Action . class )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . execute ( bean )  ;", "}", "}  )  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    =  =    bean ;", "}", "}  ;", "container . matching ( spec )  . whenObjectAdded ( action )  ;", "container . add ( bean )  ;", "container . add ( new   DefaultNamedDomainObjectSetTest . Bean (  )  )  ;", "}", "METHOD_END"], "methodName": ["filteredCollectionExecutesActionWhenMatchingObjectAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   TestClosure   closure    =    context . mock ( TestClosure . class )  ;", "final    . Bean   bean    =    new    . Bean (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( closure )  . call ( bean )  ;", "}", "}  )  ;", "Spec <  . Bean >    spec    =    new   Spec <  . Bean >  (  )     {", "public   boolean   isSatisfiedBy (  . Bean   element )     {", "return   element    =  =    bean ;", "}", "}  ;", "container . matching ( spec )  . whenObjectAdded ( TestUtil . toClosure ( closure )  )  ;", "container . add ( bean )  ;", "container . add ( new    . Bean (  )  )  ;", "}", "METHOD_END"], "methodName": ["filteredCollectionExecutesClosureWhenMatchingObjectAdded"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" b \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 3     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" c \"  )  ;", "DefaultNamedDomainObjectSetTest . Bean   bean 4     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" d \"  )  ;", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   element    !  =    bean 1  ;", "}", "}  ;", "container . add ( bean 1  )  ;", "DomainObjectCollection < DefaultNamedDomainObjectSetTest . Bean >    filteredCollection    =    container . matching ( spec )  ;", "assertTrue ( filteredCollection . isEmpty (  )  )  ;", "container . add ( bean 2  )  ;", "container . add ( bean 3  )  ;", "assertThat ( WrapUtil . toList ( filteredCollection )  ,    equalTo ( WrapUtil . toList ( bean 2  ,    bean 3  )  )  )  ;", "container . add ( bean 4  )  ;", "assertThat ( WrapUtil . toList ( filteredCollection )  ,    equalTo ( WrapUtil . toList ( bean 2  ,    bean 3  ,    bean 4  )  )  )  ;", "assertThat ( container . removeByName (  \" b \"  )  ,    sameInstance ( bean 2  )  )  ;", "assertThat ( WrapUtil . toList ( filteredCollection )  ,    equalTo ( WrapUtil . toList ( bean 3  ,    bean 4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filteredCollectionIsLive"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultNamedDomainObjectSetTest . Bean   bean 1     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" bean 1  \"  )  ;", "final   DefaultNamedDomainObjectSetTest . Bean   bean 2     =    new   DefaultNamedDomainObjectSetTest . Bean (  \" bean 2  \"  )  ;", "container . addRule ( new   Rule (  )     {", "public   String   getDescription (  )     {", "return    \" rule 1  \"  ;", "}", "public   void   apply ( String   domainObjectName )     {", "if    ( domainObjectName . equals (  \" bean 1  \"  )  )     {", "container . add ( bean 1  )  ;", "}", "}", "}  )  ;", "container . addRule ( new   Rule (  )     {", "private   boolean   applyHasBeenCalled ;", "public   String   getDescription (  )     {", "return    \" rule 2  \"  ;", "}", "public   void   apply ( String   domainObjectName )     {", "if    ( domainObjectName . equals (  \" bean 2  \"  )  )     {", "assertThat ( applyHasBeenCalled ,    equalTo ( false )  )  ;", "container . findByName (  \" bean 1  \"  )  ;", "container . findByName (  \" bean 2  \"  )  ;", "container . add ( bean 2  )  ;", "applyHasBeenCalled    =    true ;", "}", "}", "}  )  ;", "container . findByName (  \" bean 2  \"  )  ;", "assertThat ( WrapUtil . toList ( container )  ,    equalTo ( WrapUtil . toList ( bean 1  ,    bean 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findDomainObjectByNameInvokesNestedRulesOnlyOnceForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  \" bean \"  )  ;", "addRuleFor ( bean )  ;", "assertThat ( container . findByName (  \" bean \"  )  ,    sameInstance ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["findDomainObjectByNameInvokesRulesForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( container . findByName (  \" a \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["findDomainObjectByNameReturnsNullForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "Spec < DefaultNamedDomainObjectSetTest . Bean >    spec    =    new   Spec < DefaultNamedDomainObjectSetTest . Bean >  (  )     {", "public   boolean   isSatisfiedBy ( DefaultNamedDomainObjectSetTest . Bean   element )     {", "return   false ;", "}", "}  ;", "container . add ( new   DefaultNamedDomainObjectSetTest . Bean (  \" a \"  )  )  ;", "assertTrue ( container . matching ( spec )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllMatchingDomainObjectsReturnsEmptySetWhenNoMatches"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "container . getByName (  \" unknown \"  )  ;", "fail (  )  ;", "}    catch    ( UnknownException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Bean   with   name    ' unknown '    not   found .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDomainObjectByNameFailsForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSetTest . Bean   bean    =    new   DefaultNamedDomainObjectSetTest . Bean (  )  ;", "addRuleFor ( bean )  ;", "assertThat ( container . getByName (  \" bean \"  )  ,    sameInstance ( bean )  )  ;", "}", "METHOD_END"], "methodName": ["getDomainObjectInvokesRuleForUnknownDomainObject"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( container . getTypeDisplayName (  )  ,    equalTo (  \" Bean \"  )  )  ;", "assertThat ( container . getDisplayName (  )  ,    equalTo (  \" Bean   set \"  )  )  ;", "}", "METHOD_END"], "methodName": ["usesTypeNameToGenerateDisplayName"], "fileName": "org.gradle.api.internal.DefaultNamedDomainObjectSetTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   namedEntityInstantiator . create ( name ,    getType (  )  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "if    (  ( e . getCause (  )  )    instanceof   NoFactoryRegisteredForTypeException )     {", "throw   new   InvalidUserDataException ( String . format (  (  \" Cannot   create   a    % s   named    '  % s '    because   this   c    \"     +     (  \" does   not   support   creating   elements   by   name   alone .    Please   specify   which   subtype   of    % s   to   create .     \"     +     \" Known   subtypes   are :     % s \"  )  )  ,    getTypeDisplayName (  )  ,    name ,    getTypeDisplayName (  )  ,    namedEntityInstantiator . getSupportedTypeNames (  )  )  )  ;", "} else    {", "throw   e ;", "}", "}", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   namedEntityInstantiator . create ( name ,    type )  ;", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "return   namedEntityInstantiator . getCreatableTypes (  )  ;", "}", "METHOD_END"], "methodName": ["getCreateableTypes"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "registerFactory ( type ,    new   NamedDomainObjectFactory < U >  (  )     {", "boolean   named    =    Named . class . isAssignableFrom ( implementationType )  ;", "public   U   create ( String   name )     {", "return   named    ?    getInstantiator (  )  . newInstance ( implementationType ,    name )     :    getInstantiator (  )  . newInstance ( implementationType )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerBinding"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "Class < T >    castType    =    Cast . uncheckedCast ( getType (  )  )  ;", "regisFactory ( castType ,    factory )  ;", "}", "METHOD_END"], "methodName": ["registerDefaultFactory"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "registerFactory ( type ,    new   NamedDomainObjectFactory < U >  (  )     {", "public   U   create ( String   name )     {", "return   factory . call ( name )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["registerFactory"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "namedEntityInstantiator . registerFactory ( type ,    factory )  ;", "}", "METHOD_END"], "methodName": ["registerFactory"], "fileName": "org.gradle.api.internal.DefaultPolymorphicDomainObjectContainer"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?    extends   T >    languageType    :    source . factories . keySet (  )  )     {", "copyFactory ( source ,    languageType )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFactoriesFrom"], "fileName": "org.gradle.api.internal.DefaultPolymorphicNamedEntityInstantiator"}, {"methodBody": ["METHOD_START", "{", "NamedDomainObjectFactory < U >    factory    =    Cast . uncheckedCast ( source . factories . get ( type )  )  ;", "registerFactory ( type ,    factory )  ;", "}", "METHOD_END"], "methodName": ["copyFactory"], "fileName": "org.gradle.api.internal.DefaultPolymorphicNamedEntityInstantiator"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" unchecked \"  )", "DomainObjectFactory < S >    factory    =     (  ( DomainObjectFactory < S >  )     ( factories . get ( type )  )  )  ;", "if    ( factory    =  =    null )     {", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   create   a    % s   because   this   type   is   not   known   to    % s .    Known   types   are :     % s \"  ,    type . getSimpleName (  )  ,    displayName ,    getSupportedTypeNames (  )  )  ,    new   NoFactoryRegisteredForTypeException (  )  )  ;", "}", "return   factory . create ( name )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.DefaultPolymorphicNamedEntityInstantiator"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Lists . newArrayList (  )  ;", "for    ( Class <  ?  >    clazz    :    factories . keySet (  )  )     {", "names . add ( clazz . getSimple (  )  )  ;", "}", "Collections . sort ( names )  ;", "return   names . isEmpty (  )     ?     \"  ( None )  \"     :    Joiner . on (  \"  ,     \"  )  . join ( names )  ;", "}", "METHOD_END"], "methodName": ["getSupportedTypeNames"], "fileName": "org.gradle.api.internal.DefaultPolymorphicNamedEntityInstantiator"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . add ( o )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . addAll ( c )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "all ( ConfigureUtil . configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "backingSet . all ( action )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "backingSet . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . contains ( o )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . containsAll ( c )  ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . findAll ( spec )  ;", "}", "METHOD_END"], "methodName": ["findAll"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   matching ( Specs . convertClosureToSpec ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . matching ( spec )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . remove ( o )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . removeAll ( c )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . retainAll ( c )  ;", "}", "METHOD_END"], "methodName": ["retainAll"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . toArray ( a )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "whenObjectAdded ( ConfigureUtil . configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . whenObjectAdded ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "whenObjectRemoved ( ConfigureUtil . configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . whenObjectRemoved ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . withType ( type )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   withType ( type ,    ConfigureUtil . configureUsing ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "return   backingSet . withType ( type ,    configureAction )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.DelegatingDomainObjectSet"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals ( DependencyFactory . ClassPathNotation . GRADLE _ API . name (  )  )  )     {", "return   gradleApi (  )  ;", "}", "if    ( name . equals ( DependencyFactory . ClassPathNotation . GRADLE _ TEST _ KIT . name (  )  )  )     {", "return   gradleTestKit (  )  ;", "}", "if    ( name . equals ( DependencyFactory . ClassPathNotation . LOCAL _ GROOVY . name (  )  )  )     {", "return   localGroovy (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClassPath"], "fileName": "org.gradle.api.internal.DependencyClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "ClassPath   classpath    =    ClassPath . EMPTY ;", "for    ( String   moduleName    :    Arrays . asList (  \" gradle - core \"  ,     \" gradle - workers \"  ,     \" gradle - dependency - management \"  ,     \" gradle - plugin - use \"  ,     \" gradle - tooling - api \"  )  )     {", "for    ( Module   module    :    moduleRegistry . getModule ( moduleName )  . getAllRequiredModules (  )  )     {", "classpath    =    classpath . plus ( module . getClasspath (  )  )  ;", "}", "}", "for    ( Module   pluginModule    :    pluginModuleRegistry . getApiModules (  )  )     {", "classpath    =    classpath . plus ( pluginModule . getClasspath (  )  )  ;", "}", "return   classpath ;", "}", "METHOD_END"], "methodName": ["gradleApi"], "fileName": "org.gradle.api.internal.DependencyClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "return   moduleRegistry . getModule (  \" gradle - test - kit \"  )  . getClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["gradleTestKit"], "fileName": "org.gradle.api.internal.DependencyClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "return   moduleRegistry . getExternalModule (  \" groovy - all \"  )  . getClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["localGroovy"], "fileName": "org.gradle.api.internal.DependencyClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >  [  ]    parameterTypes    =    constructor . getParameterTypes (  )  ;", "if    (  ( parameterTypes . length )     <     ( parameters . length )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Too   many   parameters   provided   for   constructor   for   class    % s .    Expected    % s ,    received    % s .  \"  ,    type . getName (  )  ,    parameterTypes . length ,    parameters . length )  )  ;", "}", "Type [  ]    genericTypes    =    constructor . getGenericParameterTypes (  )  ;", "Object [  ]    resolvedParameters    =    new   Object [ parameterTypes . length ]  ;", "int   pos    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( resolvedParameters . length )  ;    i +  +  )     {", "Class <  ?  >    targetType    =    parameterTypes [ i ]  ;", "if    ( targetType . isPrimitive (  )  )     {", "targetType    =    JavaReflectionUtil . getWrapperTypeForPrimitiveType ( targetType )  ;", "}", "Type   serviceType    =    genericTypes [ i ]  ;", "Object   currentParameter ;", "if    (  ( pos    <     ( parameters . length )  )     &  &     ( targetType . isce ( parameters [ pos ]  )  )  )     {", "currentParameter    =    parameters [ pos ]  ;", "pos +  +  ;", "} else    {", "currentParameter    =    services . find ( serviceType )  ;", "}", "if    ( currentParameter    !  =    null )     {", "resolvedParameters [ i ]     =    currentParameter ;", "} else    {", "StringBuilder   builder    =    new   StringBuilder ( String . format (  \" Unable   to   determine    % s   argument    #  % s :  \"  ,    type . getName (  )  ,     ( i    +     1  )  )  )  ;", "if    ( pos    <     ( parameters . length )  )     {", "builder . append ( String . format (  \"    value    % s   not   assignable   to   type    % s \"  ,    parameters [ pos ]  ,    parameterTypes [ i ]  )  )  ;", "} else    {", "builder . append ( String . format (  \"    missing   parameter   value   of   type    % s \"  ,    parameterTypes [ i ]  )  )  ;", "}", "builder . append ( String . format (  \"  ,    or   no   service   of   type    % s \"  ,    serviceType )  )  ;", "throw   new   IllegalArgumentException ( builder . toString (  )  )  ;", "}", "}", "if    ( pos    !  =     ( parameters . length )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Unexpected   parameter   provided   for   constructor   for   class    % s .  \"  ,    type . getName (  )  )  )  ;", "}", "return   resolvedParameters ;", "}", "METHOD_END"], "methodName": ["convertParameters"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "return    (  (  !  ( Modifier . isPrivate ( modifiers )  )  )     &  &     (  !  ( Modifier . isProtected ( modifiers )  )  )  )     &  &     (  !  ( Modifier . isPublic ( modifiers )  )  )  ;", "}", "METHOD_END"], "methodName": ["isPackagePrivate"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "if    ( DependencyInjectingInstantiator . isPackagePrivate ( type . getModifiers (  )  )  )     {", "return    (  !  ( Modifier . isPrivate ( constructor . getModifiers (  )  )  )  )     &  &     (  !  ( Modifier . isProtected ( constructor . getModifiers (  )  )  )  )  ;", "} else    {", "return   Modifier . isPublic ( constructor . getModifiers (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isPublicOrPackageScoped"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "try    {", ". CachedConstructor   cached    =    constructorCache . get ( type ,    new   Transformer <  . CachedConstructor ,    Class <  ?  >  >  (  )     {", "@ Override", "public    . CachedConstructor   transform ( Class <  ?  >    aClass )     {", "try    {", ". validateType ( type )  ;", "Class <  ?    extends   T >    implClass    =    classGenerator . generate ( type )  ;", "Constructor <  ?  >    constructor    =     . selectConstructor ( type ,    implClass )  ;", "constructor . setAccessible ( true )  ;", "return    . CachedConstructor . of ( constructor )  ;", "}    catch    ( Throwable   e )     {", "return    . CachedConstructor . of ( e )  ;", "}", "}", "}  )  ;", "if    (  ( cached . error )     !  =    null )     {", "throw   cached . error ;", "}", "Constructor <  ?  >    constructor    =    cached . constructor ;", "Object [  ]    resolvedParameters    =    convertParameters ( type ,    constructor ,    parameters )  ;", "try    {", "Object   instance    =    constructor . newInstance ( resolvedParameters )  ;", "if    ( instance   instanceof    . WithServiceRegistry )     {", "(  (  . WithServiceRegistry )     ( instance )  )  . setServices ( services )  ;", "}", "return   type . cast ( instance )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   e . getCause (  )  ;", "}", "}    catch    ( Throwable   t )     {", "throw   new   ObjectInstantiationException ( type ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstance"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "Constructor <  ?  >  [  ]    constructors    =    implType . getDeclaredConstructors (  )  ;", "if    (  ( constructors . length )     =  =     1  )     {", "Constructor <  ?  >    constructor    =    constructors [  0  ]  ;", "if    (  (  ( constructor . getParameterTypes (  )  . length )     =  =     0  )     &  &     (  . isPublicOrPackageScoped ( implType ,    constructor )  )  )     {", "return   constructor ;", "}", "if    (  ( constructor . getAnnotation ( Inject . class )  )     !  =    null )     {", "return   constructor ;", "}", "if    (  ( constructor . getParameterTypes (  )  . length )     =  =     0  )     {", "throw   new   IllegalArgumentException ( String . format (  \" The   constructor   for   class    % s   should   be   public   or   package   protected   or   annotated   with    @ Inject .  \"  ,    type . getName (  )  )  )  ;", "} else    {", "throw   new   IllegalArgumentException ( String . format (  \" The   constructor   for   class    % s   should   be   annotated   with    @ Inject .  \"  ,    type . getName (  )  )  )  ;", "}", "}", "List < Constructor <  ?  >  >    injectConstructors    =    new   ArrayList < Constructor <  ?  >  >  (  )  ;", "for    ( Constructor <  ?  >    constructor    :    constructors )     {", "if    (  ( constructor . getAnnotation ( Inject . class )  )     !  =    null )     {", "injectConstructors . add ( constructor )  ;", "}", "}", "if    ( injectConstructors . isEmpty (  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Class    % s   has   no   constructor   that   is   annotated   with    @ Inject .  \"  ,    type . getName (  )  )  )  ;", "}", "if    (  ( injectConstructors . size (  )  )     >     1  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Class    % s   has   multiple   constructors   that   are   annotated   with    @ Inject .  \"  ,    type . getName (  )  )  )  ;", "}", "return   injectConstructors . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["selectConstructor"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( type . isInterface (  )  )     |  |     ( type . isAnnotation (  )  )  )     |  |     ( type . isEnum (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Type    % s   is   not   a   class .  \"  ,    type . getName (  )  )  )  ;", "}", "if    (  (  ( type . getEnclosingClass (  )  )     !  =    null )     &  &     (  !  ( Modifier . isStatic ( type . getModifiers (  )  )  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Class    % s   is   a   non - static   inner   class .  \"  ,    type . getName (  )  )  )  ;", "}", "if    ( Modifier . isAbstract ( type . getModifiers (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Class    % s   is   an   abstract   class .  \"  ,    type . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateType"], "fileName": "org.gradle.api.internal.DependencyInjectingInstantiator"}, {"methodBody": ["METHOD_START", "{", "return   serviceRegistry . get ( InstantiatorFactory . class )  . inject ( serviceRegistry )  ;", "}", "METHOD_END"], "methodName": ["dependencyInjectingInstantiator"], "fileName": "org.gradle.api.internal.DependencyInjectingServiceLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServiceLocator ( classLoader )  . implementationsOf ( serviceType )  ;", "}", "METHOD_END"], "methodName": ["implementationsOf"], "fileName": "org.gradle.api.internal.DependencyInjectingServiceLoader"}, {"methodBody": ["METHOD_START", "{", "final   Instantiator   instantiator    =    dependencyInjectingInstantiator (  )  ;", "return   transform ( implementationsOf ( serviceType ,    classLoader )  ,    new   com . google . common . base . Function < Class <  ?    extends   T >  ,    T >  (  )     {", "@ Override", "public   T   apply ( Class <  ?    extends   T >    serviceImplementation )     {", "return   instantiator . newInstance ( serviceImplementation )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.gradle.api.internal.DependencyInjectingServiceLoader"}, {"methodBody": ["METHOD_START", "{", "return   publicId ;", "}", "METHOD_END"], "methodName": ["getPublicId"], "fileName": "org.gradle.api.internal.DomNode"}, {"methodBody": ["METHOD_START", "{", "return   systemId ;", "}", "METHOD_END"], "methodName": ["getSystemId"], "fileName": "org.gradle.api.internal.DomNode"}, {"methodBody": ["METHOD_START", "{", "this . publicId    =    publicId ;", "}", "METHOD_END"], "methodName": ["setPublicId"], "fileName": "org.gradle.api.internal.DomNode"}, {"methodBody": ["METHOD_START", "{", "this . systemId    =    systemId ;", "}", "METHOD_END"], "methodName": ["setSystemId"], "fileName": "org.gradle.api.internal.DomNode"}, {"methodBody": ["METHOD_START", "{", "return   moduleRegistry . getModule ( name )  . getAllRequiredModules (  )  ;", "}", "METHOD_END"], "methodName": ["allRequiredModulesOf"], "fileName": "org.gradle.api.internal.DynamicModulesClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "Module   optionalModule    =    moduleRegistry . findModule ( moduleName )  ;", "if    ( optionalModule    !  =    null )     {", "return   optionalModule . getAllRequired (  )  ;", "}", "return   Collections . emptySet (  )  ;", "}", "METHOD_END"], "methodName": ["allRequiredModulesOfOptional"], "fileName": "org.gradle.api.internal.DynamicModulesClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" GRADLE _ EXTENSIONS \"  )  )     {", "Set < Module >    coreModules    =    allRequiredModulesOf (  \" gradle - core \"  )  ;", "ClassPath   classpath    =    ClassPath . EMPTY ;", "for    ( String   moduleName    :     . GRADLE _ EXTENSION _ MODULES )     {", "Set < Module >    extensionModules    =    allRequiredModulesOf ( moduleName )  ;", "classpath    =    plusExtensionModules ( classpath ,    extensionModules ,    coreModules )  ;", "}", "for    ( String   moduleName    :     . GRADLE _ OPTIONAL _ EXTENSION _ MODULES )     {", "Set < Module >    optionalExtensionModules    =    allRequiredModulesOfOptional ( moduleName )  ;", "classpath    =    plusExtensionModules ( classpath ,    optionalExtensionModules ,    coreModules )  ;", "}", "for    ( Module   pluginModule    :    pluginModuleRegistry . getApiModules (  )  )     {", "classpath    =    classpath . plus ( pluginModule . getClasspath (  )  )  ;", "}", "for    ( Module   pluginModule    :    pluginModuleRegistry . getImplementationModules (  )  )     {", "classpath    =    classpath . plus ( pluginModule . getClasspath (  )  )  ;", "}", "return   classpath ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClassPath"], "fileName": "org.gradle.api.internal.DynamicModulesClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "for    ( Module   module    :    extensionModules )     {", "if    (  !  ( coreModules . contains ( module )  )  )     {", "classpath    =    classpath . plus ( module . getClasspath (  )  )  ;", "}", "}", "return   classpath ;", "}", "METHOD_END"], "methodName": ["plusExtensionModules"], "fileName": "org.gradle.api.internal.DynamicModulesClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( object   instanceof   DynamicObject )     {", "return    (  ( DynamicObject )     ( object )  )  ;", "} else", "if    ( object   instanceof   DynamicObjectAware )     {", "return    (  ( DynamicObjectAware )     ( object )  )  . getAsDynamicObject (  )  ;", "} else    {", "return   new   BeanDynamicObject ( object )  ;", "}", "}", "METHOD_END"], "methodName": ["asDynamicObject"], "fileName": "org.gradle.api.internal.DynamicObjectUtil"}, {"methodBody": ["METHOD_START", "{", "Object   name ;", "try    {", "if    ( thing   instanceof   Named )     {", "name    =     (  ( Named )     ( thing )  )  . getName (  )  ;", "} else", "if    ( thing   instanceof   Map )     {", "name    =     (  ( Map )     ( thing )  )  . get (  \" name \"  )  ;", "} else", "if    ( thing   instanceof   groovy . lang . GroovyObject )     {", "name    =     (  ( groovy . lang . GroovyObject )     ( thing )  )  . get (  \" name \"  )  ;", "} else    {", "name    =    DynamicObjectUtil . asDynamicObject ( thing )  . get (  \" name \"  )  ;", "}", "}    catch    ( MissingException   e )     {", "throw   new   NoNamingException ( thing )  ;", "}", "if    ( name    =  =    null )     {", "throw   new   NullNamingException ( thing )  ;", "}", "return   name . toString (  )  ;", "}", "METHOD_END"], "methodName": ["determineName"], "fileName": "org.gradle.api.internal.DynamicPropertyNamer"}, {"methodBody": ["METHOD_START", "{", "switch    ( location )     {", "case   BeforeConvention    :", "beforeConvention    =    o ;", "break ;", "case   AfterConvention    :", "afterConvention    =    o ;", "}", "updateDelegates (  )  ;", "}", "METHOD_END"], "methodName": ["addObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,     ?  >    entry    :    properties . entrySet (  )  )     {", "getProperties (  )  . set ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addProperties"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   new   BeanDynamicObject ( delegate ,    publicType )  ;", "}", "METHOD_END"], "methodName": ["createDynamicObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   convention ;", "}", "METHOD_END"], "methodName": ["getConvention"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   convention . getExtraProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getDynamicProperties"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   new   ExtensibleDynamicObject . InheritedDynamicObject (  )  ;", "}", "METHOD_END"], "methodName": ["getInheritable"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "this . parent    =    parent ;", "updateDelegates (  )  ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "final   List < DynamicObject >    delegates    =    new   ArrayList < DynamicObject >  (  4  )  ;", "delegates . add ( extraPropertiesDynamicObject )  ;", "if    (  ( beforeConvention )     !  =    null )     {", "delegates . add ( beforeConvention )  ;", "}", "delegates . add ( convention . getExtensionsAsDynamicObject (  )  )  ;", "if    (  ( parent )     !  =    null )     {", "delegates . add ( parent )  ;", "}", "return   new   Composit (  )     {", "{", "setObjects ( delegates . toArray ( new   DynamicObject [  0  ]  )  )  ;", "}", "@ Override", "public   String   getDisplayName (  )     {", "return   dynamicDelegate . getDisplayName (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["snapshotInheritable"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "DynamicObject [  ]    delegates    =    new   DynamicObject [  6  ]  ;", "delegates [  0  ]     =    dynamicDelegate ;", "delegates [  1  ]     =    extraPropertiesDynamicObject ;", "int   idx    =     2  ;", "if    (  ( beforeConvention )     !  =    null )     {", "delegates [  ( idx +  +  )  ]     =    beforeConvention ;", "}", "if    (  ( convention )     !  =    null )     {", "delegates [  ( idx +  +  )  ]     =    convention . getExtensionsAsDynamicObject (  )  ;", "}", "if    (  ( afterConvention )     !  =    null )     {", "delegates [  ( idx +  +  )  ]     =    afterConvention ;", "}", "boolean   addedParent    =    false ;", "if    (  ( parent )     !  =    null )     {", "addedParent    =    true ;", "delegates [  ( idx +  +  )  ]     =    parent ;", "}", "DynamicObject [  ]    objects    =    new   DynamicObject [ idx ]  ;", "System . arraycopy ( delegates ,     0  ,    objects ,     0  ,    idx )  ;", "setObjects ( objects )  ;", "if    ( addedParent )     {", "idx -  -  ;", "objects    =    new   DynamicObject [ idx ]  ;", "System . arraycopy ( delegates ,     0  ,    objects ,     0  ,    idx )  ;", "setObjectsForUpdate ( objects )  ;", "}", "}", "METHOD_END"], "methodName": ["updateDelegates"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObject"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   other    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    other . extensibleDynamicObject . getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" convention \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . extensibleDynamicObject . addObject ( other . getAsDynamicObject (  )  ,    ExtensibleDynamicObject . Location . BeforeConvention )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( inherited . invokeMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" convention : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["additionalObjectMethodsAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   other    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "other . defineProperty (  \" other \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . extensibleDynamicObject . addObject ( other . getAsDynamicObject (  )  ,    ExtensibleDynamicObject . Location . BeforeConvention )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasProperty (  \" other \"  )  )  ;", "assertThat ( inherited . getProperty (  \" other \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( inherited . getProperties (  )  . get (  \" other \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["additionalObjectPropertiesAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "bean . setProperty (  \" readWriteProperty \"  ,     \" value \"  )  ;", "assertThat ( bean . getProperty (  \" readWriteProperty \"  )  ,    equalTo (  (  (  )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" groovyProperty \"  ,     \" value \"  )  ;", "assertThat ( bean . getProperty (  \" groovyProperty \"  )  ,    equalTo (  (  (  )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertCanGetAndSetProperties"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "DynamicGroovyBean   bean    =    new   DynamicGroovyBean (  )  ;", "DynamicObject   object    =    new    ( bean ,    DynamicGroovyBean . class ,    ThreadGlobalInstantiator . getOrCreate (  )  )  ;", "Integer   doubled    =     (  ( Integer )     ( object . invokeMethod (  \" bar \"  ,     1  )  )  )  ;", "assertThat ( doubled ,    equalTo (  2  )  )  ;", "try    {", "object . invokeMethod (  \" xxx \"  ,     1  ,     2  ,     3  )  ;", "fail (  )  ;", "}    catch    ( MissingMethodException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   find   method   xxx (  )    for   arguments    [  1  ,     2  ,     3  ]    on   object   of   type    \"     +     ( DynamicGroovyBean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["canCallGroovyDynamicMethods"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "parent . defineProperty (  \" parentProperty \"  ,     \" parentProperty \"  )  ;", "parent . setReadWriteProperty (  \" ignore   me \"  )  ;", "parent . doSetReadOnlyProperty (  \" ignore   me \"  )  ;", "Convention   parentConvention    =    parent . extensibleDynamicObject . getConvention (  )  ;", "parentConvention . getPlugins (  )  . put (  \" parent \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "bean . defineProperty (  \" additional \"  ,     \" additional \"  )  ;", "bean . setReadWriteProperty (  \" readWriteProperty \"  )  ;", "bean . doSetReadOnlyProperty (  \" readOnlyProperty \"  )  ;", "bean . setGroovyProperty (  \" groovyProperty \"  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "conventionBean . setConventionProperty (  \" conventionProperty \"  )  ;", "convention . getPlugins (  )  . put (  \" bean \"  ,    conventionBean )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "Map < String ,    Object >    properties    =    bean . getProperties (  )  ;", "assertThat ( properties . get (  \" properties \"  )  ,    sameInstance (  (  ( Object )     ( properties )  )  )  )  ;", "assertThat ( properties . get (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" readWriteProperty \"  )  )  )  )  ;", "assertThat ( properties . get (  \" readOnlyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" readOnlyProperty \"  )  )  )  )  ;", "assertThat ( properties . get (  \" parentProperty \"  )  ,    equalTo (  (  ( Object )     (  \" parentProperty \"  )  )  )  )  ;", "assertThat ( properties . get (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" additional \"  )  )  )  )  ;", "assertThat ( properties . get (  \" groovyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" groovyProperty \"  )  )  )  )  ;", "assertThat ( properties . get (  \" groovyDynamicProperty \"  )  ,    equalTo ( null )  )  ;", "assertThat ( properties . get (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" conventionProperty \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllProperties"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTestHelper . assertCanGetAllProperties ( new   ExtensibleDynamicObjectTest . Bean (  )  )  ;", "ExtensibleDynamicObjectTestHelper . assertCanGetAllProperties ( new   GroovyBean (  )  )  ;", "ExtensibleDynamicObjectTestHelper . assertCanGetAllProperties ( new   ExtensibleDynamicObjectTest . DynamicJavaBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAllPropertiesFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setReadWriteProperty (  \" value \"  )  ;", "assertThat ( bean . getProperty (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" readWriteProperty \"  ,     \" new   value \"  )  ;", "assertThat ( bean . getProperty (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( bean . getReadWriteProperty (  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" additional \"  ,     \" value    1  \"  )  ;", "assertThat ( bean . getProperty (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" value    1  \"  )  )  )  )  ;", "bean . setProperty (  \" additional \"  ,     \" value    2  \"  )  ;", "assertThat ( bean . getProperty (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" value    2  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetExtraProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "Helper . decorateGroovyBean ( bean )  ;", "assertThat (  (  (  . Bean )     ( bean )  )  . getProperty (  \" dynamicGroovyProperty \"  )  ,    equalTo ( null )  )  ;", "bean . setProperty (  \" dynamicGroovyProperty \"  ,     \" new   value \"  )  ;", "assertThat (  (  (  . Bean )     ( bean )  )  . getProperty (  \" dynamicGroovyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetGroovyDynamicProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "bean . setGroovyProperty (  \" value \"  )  ;", "assertThat (  (  (  . Bean )     ( bean )  )  . getProperty (  \" groovyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" groovyProperty \"  ,     \" new   value \"  )  ;", "assertThat (  (  (  . Bean )     ( bean )  )  . getProperty (  \" groovyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( bean . getGroovyProperty (  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetGroovyObjectClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTestHelper . assertCanGetAndSetProperties ( new   GroovyBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertiesOnGroovyObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "assertCanGetAndSetProperties ( new   GroovyBean (  )  . getAsDynamicObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertiesOnGroovyObjectFromJava"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTestHelper . assertCanGetAndSetProperties ( new   ExtensibleDynamicObjectTest . DynamicJavaBean (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertiesOnJavaSubClassOfGroovyObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "assertCanGetAndSetProperties ( new   ExtensibleDynamicObjectTest . DynamicJavaBean (  )  . getAsDynamicObject (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertiesOnJavaSubClassOfGroovyObjectFromJava"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   otherObject    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "otherObject . defineProperty (  \" otherObject \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . extensibleDynamicObject . addObject ( otherObject . getAsDynamicObject (  )  ,    ExtensibleDynamicObject . Location . BeforeConvention )  ;", "assertTrue ( bean . hasProperty (  \" otherObject \"  )  )  ;", "assertThat ( bean . getProperty (  \" otherObject \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" otherObject \"  ,     \" new   value \"  )  ;", "assertThat ( otherObject . getProperty (  \" otherObject \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertyDefinedByAdditionalObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "convention . getPlugins (  )  . put (  \" test \"  ,    conventionBean )  ;", "conventionBean . setConventionProperty (  \" value \"  )  ;", "assertThat ( bean . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" conventionProperty \"  ,     \" new   value \"  )  ;", "assertThat ( bean . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( conventionBean . getConventionProperty (  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetPropertyDefinedByConventionObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTestHelper . assertCanGetProperties ( new   ExtensibleDynamicObjectTest . Bean (  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetButNotSetPropertiesOnJavaObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertThat ( DynamicObjectUtil . asDynamicObject ( bean )  ,    sameInstance ( bean . getAsDynamicObject (  )  )  )  ;", "assertThat ( DynamicObjectUtil . asDynamicObject ( new   Object (  )  )  ,    instanceOf ( DynamicObject . class )  )  ;", "}", "METHOD_END"], "methodName": ["canGetObjectAsDynamicObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "parent . defineProperty (  \" parentProperty \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "assertThat ( bean . getProperty (  \" parentProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetPropertyDefinedByParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . doSetReadOnlyProperty (  \" value \"  )  ;", "assertThat ( bean . getProperty (  \" readOnlyProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetReadOnlyClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" someMethod \"  ,    TestUtil . toClosure (  \"  {    param    -  >    param . toLowerCase (  )     }  \"  )  )  ;", "assertThat ( bean . invokeMethod (  \" someMethod \"  ,     \" Param \"  )  ,    equalTo (  (  ( Object )     (  \" param \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeClosurePropertyAsAMethod"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertTrue ( bean . hasMethod (  \" javaMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" javaMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" java : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodDefinedByClass"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "assertFalse ( bean . hasMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "convention . getPlugins (  )  . put (  \" bean \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "assertTrue ( bean . hasMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" convention : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodDefinedByConvention"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   GroovyBean (  )  ;", "ExtensibleDynamicObjectTestHelper . decorateGroovyBean ( bean )  ;", "assertTrue ( bean . hasMethod (  \" groovyMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" groovyMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" groovy : a . b \"  )  )  )  )  ;", "assertTrue ( bean . hasMethod (  \" dynamicGroovyMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" dynamicGroovyMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" dynamicGroovy : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodDefinedByMetaClass"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )     {", "public   String   parentMethod ( String   a ,    String   b )     {", "return   String . format (  \" parent :  % s .  % s \"  ,    a ,    b )  ;", "}", "}  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertFalse ( bean . hasMethod (  \" parentMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "assertTrue ( bean . hasMethod (  \" parentMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" parentMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" parent : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodDefinedByParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Script   script    =    TestUtil . createScript (  \" def   scriptMethod ( a ,    b )     {     \\  \" script :  $ a .  $ b \\  \"     }     \"  )  ;", "bean . extensibleDynamicObject . addObject ( new   BeanDynamicObject ( script )  ,    ExtensibleDynamicObject . Location . BeforeConvention )  ;", "assertTrue ( bean . hasMethod (  \" scriptMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( bean . getAsDynamicObject (  )  . invokeMethod (  \" scriptMethod \"  ,     \" a \"  ,     \" b \"  )  . toString (  )  ,    equalTo (  (  ( Object )     (  \" script : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodDefinedByScriptObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" bean \"  ,    new    . ConventionBean (  )  )  ;", "new   Helper (  )  . assertCanCallMethods ( bean )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodsOnGroovyObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" bean \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "new   ExtensibleDynamicObjectTestHelper (  )  . assertCanCallMethods ( bean )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodsOnJavaObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . DynamicJavaBean   javaBean    =    new   ExtensibleDynamicObjectTest . DynamicJavaBean (  )  ;", "Convention   convention    =    getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" bean \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "new   ExtensibleDynamicObjectTestHelper (  )  . assertCanCallMethods ( javaBean )  ;", "}", "METHOD_END"], "methodName": ["canInvokeMethodsOnJavaSubClassOfGroovyObjectFromGroovy"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setProperty (  \" differentTypesProperty \"  ,     \"  9  1  \"  )  ;", "assertThat ( bean . getProperty (  \" differentTypesProperty \"  )  ,    equalTo (  (  ( Object )     (  9  1  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canSetPropertyWhenGetterAndSetterHaveDifferentTypes"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setProperty (  \" writeOnlyProperty \"  ,     \" value \"  )  ;", "assertThat ( bean . doGetWriteOnlyProperty (  )  ,    equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canSetWriteOnlyClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "try    {", "bean . getProperty (  \" writeOnlyProperty \"  )  ;", "fail (  )  ;", "}    catch    ( GroovyRuntimeException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Cannot   get   the   value   of   write - only   property    ' writeOnlyProperty '    for    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotGetWriteOnlyClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" additional \"  ,     \" value \"  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "try    {", "inherited . setProperty (  \" additional \"  ,     \" new   value \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   find   property    ' additional '    inherited   from    < bean >  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotSetInheritedProperties"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "try    {", "bean . setProperty (  \" readOnlyProperty \"  ,     \" value \"  )  ;", "fail (  )  ;", "}    catch    ( GroovyRuntimeException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Cannot   set   the   value   of   read - only   property    ' readOnlyProperty '    for    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotSetReadOnlyClassProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setReadWriteProperty (  \" value \"  )  ;", "bean . extensibleDynamicObject . getDynamicProperties (  )  . set (  \" readWriteProperty \"  ,     \" additional \"  )  ;", "assertThat ( bean . getProperty (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" readWriteProperty \"  ,     \" new   value \"  )  ;", "assertThat ( bean . getProperty (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( bean . getReadWriteProperty (  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( bean . extensibleDynamicObject . getDynamicProperties (  )  . get (  \" readWriteProperty \"  )  ,    equalTo (  (  ( Object )     (  \" additional \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["classPropertyTakesPrecedenceOverAdditionalProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" convention \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( inherited . invokeMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" convention : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["conventionMethodsAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "conventionBean . setConventionProperty (  \" value \"  )  ;", "convention . getPlugins (  )  . put (  \" convention \"  ,    conventionBean )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasProperty (  \" conventionProperty \"  )  )  ;", "assertThat ( inherited . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( inherited . getProperties (  )  . get (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["conventionPropertiesAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "parent . defineProperty (  \" conventionProperty \"  ,     \" parent \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "conventionBean . setConventionProperty (  \" value \"  )  ;", "convention . getPlugins (  )  . put (  \" test \"  ,    conventionBean )  ;", "assertThat ( bean . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["conventionPropertyTakesPrecedenceOverParentProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "DynamicObject   bean    =    new   ExtensibleDynamicObject ( new   Object (  )  ,    Object . class ,    ThreadGlobalInstantiator . getOrCreate (  )  )  ;", "try    {", "bean . getProperty (  \" unknown \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   get   unknown   property    ' unknown '    for   object   of   type   \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotIncludeToStringInGetPropertyErrorMessageWhenItIsNotImplemented"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "DynamicObject   bean    =    new   ExtensibleDynamicObject ( new   Object (  )  ,    Object . class ,    ThreadGlobalInstantiator . getOrCreate (  )  )  ;", "try    {", "bean . setProperty (  \" unknown \"  ,     \" value \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   set   unknown   property    ' unknown '    for   object   of   type   \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doesNotIncludeToStringInSetPropertyErrorMessageWhenItIsNotImplemented"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" additional \"  ,     \" value \"  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasProperty (  \" additional \"  )  )  ;", "assertThat ( inherited . getProperty (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( inherited . getProperties (  )  . get (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["extraPropertiesAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "bean . defineProperty (  \" parentProperty \"  ,     \" value \"  )  ;", "assertFalse ( parent . hasProperty (  \" parentProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["extraPropertyIsNotVisibleToParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" conventionProperty \"  ,     \" value \"  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "convention . getPlugins (  )  . put (  \" test \"  ,    conventionBean )  ;", "assertThat ( bean . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "bean . setProperty (  \" conventionProperty \"  ,     \" new   value \"  )  ;", "assertThat ( bean . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( bean . extensibleDynamicObject . getDynamicProperties (  )  . get (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" new   value \"  )  )  )  )  ;", "assertThat ( conventionBean . getConventionProperty (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["extraPropertyTakesPrecedenceOverConventionProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . defineProperty (  \" additional \"  ,    null )  ;", "assertThat ( bean . getProperty (  \" additional \"  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["extraPropertyWithNullValueIsNotTreatedAsUnknown"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "try    {", "bean . getProperty (  \" unknown \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   get   unknown   property    ' unknown '    for    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "bean . setParent ( new   ExtensibleDynamicObjectTest . Bean (  )     {", "@ Override", "public   String   toString (  )     {", "return    \"  < parent >  \"  ;", "}", "}  . getAsDynamicObject (  )  )  ;", "try    {", "bean . getProperty (  \" unknown \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   get   unknown   property    ' unknown '    for    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getPropertyFailsForUnknownProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "Helper . decorateGroovyBean ( bean )  ;", "assertTrue ( bean . hasProperty (  \" groovyProperty \"  )  )  ;", "assertTrue ( bean . hasProperty (  \" dynamicGroovyProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["groovyObjectHasPropertiesDefinedByClassMetaInfo"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "GroovyBean   bean    =    new   GroovyBean (  )  ;", "assertTrue ( bean . hasProperty (  \" reWriteProperty \"  )  )  ;", "assertTrue ( bean . hasProperty (  \" reOnlyProperty \"  )  )  ;", "assertTrue ( bean . hasProperty (  \" writeOnlyProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["groovyObjectHasPropertiesInheritedFromSuperClass"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertFalse ( bean . hasProperty (  \" additional \"  )  )  ;", "bean . defineProperty (  \" additional \"  ,     \" value \"  )  ;", "assertTrue ( bean . hasProperty (  \" additional \"  )  )  ;", "bean . setProperty (  \" additional \"  ,    null )  ;", "assertTrue ( bean . hasProperty (  \" additional \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasAdditionalProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertTrue ( bean . hasProperty (  \" readWriteProperty \"  )  )  ;", "assertTrue ( bean . hasProperty (  \" readOnlyProperty \"  )  )  ;", "assertTrue ( bean . hasProperty (  \" writeOnlyProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasPropertiesDefinedByClass"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "assertFalse ( bean . hasProperty (  \" conventionProperty \"  )  )  ;", "assertFalse ( bean . hasProperty (  \" conventionProperty \"  )  )  ;", "convention . getPlugins (  )  . put (  \" test \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "assertTrue ( bean . hasProperty (  \" conventionProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasPropertyDefinedByConventionObject"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "parent . defineProperty (  \" parentProperty \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertFalse ( bean . hasProperty (  \" parentProperty \"  )  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "assertTrue ( bean . hasProperty (  \" parentProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["hasPropertyDefinedByParent"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   other    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "other . defineProperty (  \" other \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertFalse ( inherited . hasProperty (  \" other \"  )  )  ;", "bean . extensibleDynamicObject . addObject ( other . getAsDynamicObject (  )  ,    ExtensibleDynamicObject . Location . BeforeConvention )  ;", "assertTrue ( inherited . hasProperty (  \" other \"  )  )  ;", "assertThat ( inherited . getProperty (  \" other \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["inheritedAdditionalObjectPropertiesTrackChanges"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertFalse ( inherited . hasProperty (  \" additional \"  )  )  ;", "bean . defineProperty (  \" additional \"  ,     \" value \"  )  ;", "assertTrue ( inherited . hasProperty (  \" additional \"  )  )  ;", "assertThat ( inherited . getProperty (  \" additional \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["inheritedAdditionalPropertiesTrackChanges"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertFalse ( inherited . hasProperty (  \" conventionProperty \"  )  )  ;", "Convention   convention    =    bean . extensibleDynamicObject . getConvention (  )  ;", "ExtensibleDynamicObjectTest . ConventionBean   conventionBean    =    new   ExtensibleDynamicObjectTest . ConventionBean (  )  ;", "conventionBean . setConventionProperty (  \" value \"  )  ;", "convention . getPlugins (  )  . put (  \" convention \"  ,    conventionBean )  ;", "assertTrue ( inherited . hasProperty (  \" conventionProperty \"  )  )  ;", "assertThat ( inherited . getProperty (  \" conventionProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["inheritedConventionPropertiesTrackChanges"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "try    {", "bean . getAsDynamicObject (  )  . invokeMethod (  \" unknown \"  ,     \" a \"  ,     1  2  )  ;", "fail (  )  ;", "}    catch    ( MissingMethodException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   find   method   unknown (  )    for   arguments    [ a ,     1  2  ]    on    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeMethodFailsForUnknownMethod"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertTrue ( bean . hasMethod (  \" javaMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertFalse ( inherited . hasMethod (  \" javaMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "}", "METHOD_END"], "methodName": ["otherMethodsAreNotInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "assertTrue ( bean . hasProperty (  \" readWriteProperty \"  )  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertFalse ( inherited . hasProperty (  \" readWriteProperty \"  )  )  ;", "assertFalse ( inherited . getProperties (  )  . containsKey (  \" readWriteProperty \"  )  )  ;", "}", "METHOD_END"], "methodName": ["otherPropertiesAreNotInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "Convention   convention    =    parent . extensibleDynamicObject . getConvention (  )  ;", "convention . getPlugins (  )  . put (  \" convention \"  ,    new   ExtensibleDynamicObjectTest . ConventionBean (  )  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( inherited . invokeMethod (  \" conventionMethod \"  ,     \" a \"  ,     \" b \"  )  ,    equalTo (  (  ( Object )     (  \" convention : a . b \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parentMethodsAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   parent    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "parent . defineProperty (  \" parentProperty \"  ,     \" value \"  )  ;", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "bean . setParent ( parent . getAsDynamicObject (  )  )  ;", "DynamicObject   inherited    =    bean . getInheritable (  )  ;", "assertTrue ( inherited . hasProperty (  \" parentProperty \"  )  )  ;", "assertThat ( inherited . getProperty (  \" parentProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "assertThat ( inherited . getProperties (  )  . get (  \" parentProperty \"  )  ,    equalTo (  (  ( Object )     (  \" value \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["parentPropertiesAreInherited"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   failure    =    new   RuntimeException (  )  ;", ". Bean   bean    =    new    . Bean (  )     {", "String   getFailure (  )     {", "throw   failure ;", "}", "}  ;", "try    {", "bean . getProperty (  \" failure \"  )  ;", "fail (  )  ;", "}    catch    ( Exception   e )     {", "assertThat ( e ,    sameInstance (  (  ( Exception )     ( failure )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propagatesGetPropertyException"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   failure    =    new   RuntimeException (  )  ;", ". Bean   bean    =    new    . Bean (  )     {", "void   failure (  )     {", "throw   failure ;", "}", "}  ;", "try    {", "bean . getAsDynamicObject (  )  . invokeMethod (  \" failure \"  )  ;", "fail (  )  ;", "}    catch    ( Exception   e )     {", "assertThat ( e ,    sameInstance (  (  ( Exception )     ( failure )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propagatesInvokeMethodException"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   failure    =    new   RuntimeException (  )  ;", ". Bean   bean    =    new    . Bean (  )     {", "void   setFailure ( String   value )     {", "throw   failure ;", "}", "}  ;", "try    {", "bean . setProperty (  \" failure \"  ,     \" a \"  )  ;", "fail (  )  ;", "}    catch    ( Exception   e )     {", "assertThat ( e ,    sameInstance (  (  ( Exception )     ( failure )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["propagatesSetPropertyException"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "ExtensibleDynamicObjectTest . Bean   bean    =    new   ExtensibleDynamicObjectTest . Bean (  )  ;", "try    {", "bean . setProperty (  \" unknown \"  ,     1  2  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   set   unknown   property    ' unknown '    for    < bean >    of   type    \"     +     ( ExtensibleDynamicObjectTest . Bean . class . getName (  )  )  )     +     \"  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setPropertyFailsForUnknownProperty"], "fileName": "org.gradle.api.internal.ExtensibleDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "enableFeature ( FeaturePreviews . Feature . withName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["enableFeature"], "fileName": "org.gradle.api.internal.FeaturePreviews"}, {"methodBody": ["METHOD_START", "{", "if    ( feature . isActive (  )  )     {", "enableds . add ( feature )  ;", "}", "}", "METHOD_END"], "methodName": ["enableFeature"], "fileName": "org.gradle.api.internal.FeaturePreviews"}, {"methodBody": ["METHOD_START", "{", "return   activeFeatures ;", "}", "METHOD_END"], "methodName": ["getActiveFeatures"], "fileName": "org.gradle.api.internal.FeaturePreviews"}, {"methodBody": ["METHOD_START", "{", "return   isFeatureEnabled ( FeaturePreviews . Feature . withName ( name )  )  ;", "}", "METHOD_END"], "methodName": ["isFeatureEnabled"], "fileName": "org.gradle.api.internal.FeaturePreviews"}, {"methodBody": ["METHOD_START", "{", "return    ( feature . isActive (  )  )     &  &     ( enabledFeatures . contains ( feature )  )  ;", "}", "METHOD_END"], "methodName": ["isFeatureEnabled"], "fileName": "org.gradle.api.internal.FeaturePreviews"}, {"methodBody": ["METHOD_START", "{", "properties . add ( property )  ;", "changed    =    true ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.FilePropertyContainer"}, {"methodBody": ["METHOD_START", "{", "return   new   FilePropertyContainer < T >  (  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.FilePropertyContainer"}, {"methodBody": ["METHOD_START", "{", "return    !  ( previousSnapshot . getSnapshot (  )  . isContentUpToDate ( fileSnapshot . getSnapshot (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["changedSincePreviousExecution"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "return   previousSnapshot    =  =    null ;", "}", "METHOD_END"], "methodName": ["createdSincePreviousExecution"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    NormalizedFileSnapshot >    previousSnapshots    =    previousExecution . getSnapshots (  )  ;", "Map < String ,    NormalizedFileSnapshot >    beforeSnapshots    =    beforeExecution . getSnapshots (  )  ;", "for    ( Map . Entry < String ,    NormalizedFileSnapshot >    beforeSnapshot    :    beforeSnapshots . entrySet (  )  )     {", "String   path    =    beforeSnapshot . getKey (  )  ;", "NormalizedFileSnapshot   fileSnapshot    =    beforeSnapshot . getValue (  )  ;", "NormalizedFileSnapshot   previousSnapshot    =    previousSnapshots . get ( path )  ;", "if    (  ( fileSnapshot . getSnapshot (  )  . getType (  )  )     !  =     ( FileType . Missing )  )     {", "if    (  (  . createdSincePreviousExecution ( previousSnapshot )  )     |  |     (  . changedSincePreviousExecution ( fileSnapshot ,    previousSnapshot )  )  )     {", "return   new    ( propertyName ,    fileSnapshot . getNormalizedPath (  )  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["detect"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "return   overlappedFilePath ;", "}", "METHOD_END"], "methodName": ["getOverlappedFilePath"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" output   property    '  % s '    with   path    '  % s '  \"  ,    propertyName ,    overlappedFilePath )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.api.internal.OverlappingOutputs"}, {"methodBody": ["METHOD_START", "{", "actions . add ( action )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "org.gradle.api.internal.PropertiesTransformer"}, {"methodBody": ["METHOD_START", "{", "actions . execute ( original )  ;", "return   original ;", "}", "METHOD_END"], "methodName": ["doTransform"], "fileName": "org.gradle.api.internal.PropertiesTransformer"}, {"methodBody": ["METHOD_START", "{", "return   doTransform ( original )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.PropertiesTransformer"}, {"methodBody": ["METHOD_START", "{", "try    {", "do ( original )  . store ( destination ,     \"  \"  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.PropertiesTransformer"}, {"methodBody": ["METHOD_START", "{", "Object [  ]    combinedArgs ;", "if    (  ( extraArgs . length )     =  =     0  )     {", "Object [  ]    nameArg    =    new   Object [  ]  {    name    }  ;", "combinedArgs    =    nameArg ;", "} else    {", "combinedArgs    =    new   Object [  ( extraArgs . length )     +     1  ]  ;", "combinedArgs [  0  ]     =    name ;", "int   i    =     1  ;", "for    ( Object   e    :    extraArgs )     {", "combinedArgs [  ( i +  +  )  ]     =    e ;", "}", "}", "return   combinedArgs ;", "}", "METHOD_END"], "methodName": ["combineInstantiationArgs"], "fileName": "org.gradle.api.internal.ReflectiveNamedDomainObjectFactory"}, {"methodBody": ["METHOD_START", "{", "return   instantiator . newInstance ( type ,    combineInstantiationArgs ( name )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.ReflectiveNamedDomainObjectFactory"}, {"methodBody": ["METHOD_START", "{", "return   prepareNewBuild ( new   StartParameterInternal (  )  )  ;", "}", "METHOD_END"], "methodName": ["newBuild"], "fileName": "org.gradle.api.internal.StartParameterInternal"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    getInstantiator (  )  ;", "Object   testObject    =    new   Object ( instantiator )  ;", "testObject . setName ( name )  ;", "return   testObject ;", "}", "METHOD_END"], "methodName": ["doCreate"], "fileName": "org.gradle.api.internal.TestContainer"}, {"methodBody": ["METHOD_START", "{", "return    \" value \"  ;", "}", "METHOD_END"], "methodName": ["getSomeValue"], "fileName": "org.gradle.api.internal.TestJavaObject"}, {"methodBody": ["METHOD_START", "{", "Deque < Instantiator >    stack    =    ThreadGlobalInstantiator . getStack (  )  ;", "return   stack . isEmpty (  )     ?    null    :    stack . peek (  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.api.internal.ThreadGlobalInstantiator"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    ThreadGlobalInstantiator . get (  )  ;", "if    ( instantiator    !  =    null )     {", "return   instantiator ;", "} else    {", "return   new   ClassGeneratorBackedInstantiator ( new   AsmBackedClassGenerator (  )  ,    DirectInstantiator . INSTANCE )  ;", "}", "}", "METHOD_END"], "methodName": ["getOrCreate"], "fileName": "org.gradle.api.internal.ThreadGlobalInstantiator"}, {"methodBody": ["METHOD_START", "{", "return   ThreadGlobalInstantiator . STORAGE . get (  )  ;", "}", "METHOD_END"], "methodName": ["getStack"], "fileName": "org.gradle.api.internal.ThreadGlobalInstantiator"}, {"methodBody": ["METHOD_START", "{", "Deque < Instantiator >    stack    =    ThreadGlobalInstantiator . getStack (  )  ;", "if    ( instantiator    !  =    null )     {", "stack . push ( instantiator )  ;", "} else", "if    (  !  ( stack . isEmpty (  )  )  )     {", "stack . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.api.internal.ThreadGlobalInstantiator"}, {"methodBody": ["METHOD_START", "{", "return   delegate . add ( e )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . addAll ( c )  ;", "}", "METHOD_END"], "methodName": ["addAll"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . addRule ( description ,    ruleAction )  ;", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . addRule ( rule )  ;", "}", "METHOD_END"], "methodName": ["addRule"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "delegate . all ( action )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "delegate . all ( action )  ;", "}", "METHOD_END"], "methodName": ["all"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "delegate . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "NamedDomainObjectContainerConfigureDelegate   delegate    =    new   NamedDomainObjectContainerConfigureDelegate ( configureClosure ,    this )  ;", "return   ConfigureUtil . configureSelf ( configureClosure ,    this ,    delegate )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . contains ( o )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . containsAll ( c )  ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   parent . create ( name ,    type )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   parent . create ( name ,    type ,    ConfigureUtil . configureUsing ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   parent . create ( name ,    type ,    configureAction )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . findAll ( spec )  ;", "}", "METHOD_END"], "methodName": ["findAll"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . findByName ( name )  ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getAsMap (  )  ;", "}", "METHOD_END"], "methodName": ["getAsMap"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getAt ( name )  ;", "}", "METHOD_END"], "methodName": ["getAt"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getByName ( name )  ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getByName ( name ,    configureClosure )  ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getNamer (  )  ;", "}", "METHOD_END"], "methodName": ["getNamer"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getNames (  )  ;", "}", "METHOD_END"], "methodName": ["getNames"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . getRules (  )  ;", "}", "METHOD_END"], "methodName": ["getRules"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . matching ( spec )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . matching ( spec )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   parent . maybeCreate ( name ,    type )  ;", "}", "METHOD_END"], "methodName": ["maybeCreate"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . remove ( o )  ;", "}", "METHOD_END"], "methodName": ["remove"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . removeAll ( c )  ;", "}", "METHOD_END"], "methodName": ["removeAll"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . retainAll ( c )  ;", "}", "METHOD_END"], "methodName": ["retainAll"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . toArray (  )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . toArray ( a )  ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "delegate . whenObjectAdded ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . whenObjectAdded ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectAdded"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "delegate . whenObjectRemoved ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . whenObjectRemoved ( action )  ;", "}", "METHOD_END"], "methodName": ["whenObjectRemoved"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . withType ( type )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . withType ( type ,    configureClosure )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "return   delegate . withType ( type ,    configureAction )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.TypedDomainObjectContainerWrapper"}, {"methodBody": ["METHOD_START", "{", "try    {", "delegate . execute ( target )  ;", "}    catch    ( Exception   e )     {", "throw   new   InvalidException ( exceptionMessage ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.UserCodeAction"}, {"methodBody": ["METHOD_START", "{", "queue . add ( dependency )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.artifacts.CachingDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   transitive ;", "}", "METHOD_END"], "methodName": ["isTransitive"], "fileName": "org.gradle.api.internal.artifacts.CachingDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "try    {", "walker . add ( queue )  ;", "return   new   UnionFilllection ( walker . findValues (  )  )  ;", "}    finally    {", "queue . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.artifacts.CachingDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   group ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRule"}, {"methodBody": ["METHOD_START", "{", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRule"}, {"methodBody": ["METHOD_START", "{", "this . group    =    groupValue ;", "}", "METHOD_END"], "methodName": ["setGroup"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRule"}, {"methodBody": ["METHOD_START", "{", "this . module    =    moduleValue ;", "}", "METHOD_END"], "methodName": ["setModule"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRule"}, {"methodBody": ["METHOD_START", "{", "maybeAdd ( args )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( addedRules )     =  =    null    ?    Collections .  < ExcludeRule > emptySet (  )     :    addedRules ;", "}", "METHOD_END"], "methodName": ["getRules"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( addedRules )     =  =    null )     {", "addedRules    =    new   HashSet < artifacts . ExcludeRule >  (  )  ;", "}", "return   addedRules . add ( ExcludeRuleNotationConverter . parser (  )  . parseNotation ( args )  )  ;", "}", "METHOD_END"], "methodName": ["maybeAdd"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainer"}, {"methodBody": ["METHOD_START", "{", "List < Map >    foundRules    =    new   ArrayList < Map >  (  )  ;", "for    (    excludeRule    :    excludeRules )     {", "for    ( Map   excludeRuleArg    :    excludeRuleArgs )     {", "if    ( matching ( excludeRule ,    excludeRuleArg )  )     {", "foundRules . add ( excludeRuleArg )  ;", "continue ;", "}", "}", "}", "assertThat ( new   HashSet < Map >  ( Arrays . asList ( excludeRuleArgs )  )  ,    equalTo ( new   HashSet < Map >  ( foundRules )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertExcludeRuleContainerHasCorrectExcludeRules"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "final   DefaultExcludeRule   expectedExcludeRule    =    new   DefaultExcludeRule (  (  ( String )     ( excludeRuleArg . get ( GROUP _ KEY )  )  )  ,     (  ( String )     ( excludeRuleArg . get ( MODULE _ KEY )  )  )  )  ;", "return   excludeRule . equals ( expectedExcludeRule )  ;", "}", "METHOD_END"], "methodName": ["matchingExcludeRule"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "DefaultExcludeRuleContainer   excludeRuleContainer    =    new   DefaultExcludeRuleContainer (  )  ;", "Map < String ,    String >    excludeRuleArgs 1     =    WrapUtil . toMap (  \" group \"  ,     \" value 1  \"  )  ;", "Map < String ,    String >    excludeRuleArgs 2     =    WrapUtil . toMap (  \" module \"  ,     \" value 2  \"  )  ;", "excludeRuleContainer . add ( excludeRuleArgs 1  )  ;", "excludeRuleContainer . add ( excludeRuleArgs 2  )  ;", "assertThat ( excludeRuleContainer . getRules (  )  . size (  )  ,    equalTo (  2  )  )  ;", "assertExcludeRuleContainerHasCorrectExcludeRules ( excludeRuleContainer . getRules (  )  ,    excludeRuleArgs 1  ,    excludeRuleArgs 2  )  ;", "}", "METHOD_END"], "methodName": ["testAdd"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( new   DefaultExcludeRuleContainer (  )  . getRules (  )  . size (  )  ,    equalTo (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testInit"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "Set < ExcludeRule >    sourceExcludeRules    =    new   HashSet < ExcludeRule >  (  )  ;", "sourceExcludeRules . add ( new   DefaultExcludeRule (  \" aGroup \"  ,    null )  )  ;", "defaultExcludeRuleContainer    =    new    ( sourceExcludeRules )  ;", "assertThat ( defaultExcludeRuleContainer . getRules (  )  ,    equalTo ( sourceExcludeRules )  )  ;", "assertThat ( defaultExcludeRuleContainer . getRules (  )  ,    not ( sameInstance ( sourceExcludeRules )  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitWithRules"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "DefaultExcludeRuleContainer   excludeRuleContainer    =    new   DefaultExcludeRuleContainer (  )  ;", "Map < String ,    String >    excludeRuleArgs 1     =    WrapUtil . toMap (  \" group \"  ,     \" value 1  \"  )  ;", "Map < String ,    String >    excludeRuleArgs 2     =    WrapUtil . toMap (  \" invalidkey 2  \"  ,     \" value 2  \"  )  ;", "excludeRuleContainer . add ( excludeRuleArgs 1  )  ;", "excludeRuleContainer . add ( excludeRuleArgs 2  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidExcludeDefinitionThrowsInvalidUserDataException"], "fileName": "org.gradle.api.internal.artifacts.DefaultExcludeRuleContainerTest"}, {"methodBody": ["METHOD_START", "{", "return   group ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.gradle.api.internal.artifacts.DefaultModule"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.DefaultModule"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getProjectPath"], "fileName": "org.gradle.api.internal.artifacts.DefaultModule"}, {"methodBody": ["METHOD_START", "{", "return   status ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.api.internal.artifacts.DefaultModule"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.internal.artifacts.DefaultModule"}, {"methodBody": ["METHOD_START", "{", "if    (  ( group    =  =    null )     &  &     ( module    =  =    null )  )     {", "throw   new   InvalidUserDataException (  \" Dependency   exclude   rule   requires    ' group '    and / or    ' module '    specified .    For   example :     [ group :     ' com . google . collections '  ]  \"  )  ;", "}", "return   new   Default ( group ,    module )  ;", "}", "METHOD_END"], "methodName": ["parseMap"], "fileName": "org.gradle.api.internal.artifacts.ExcludeRuleNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return   ExcludeRuleNotationConverter . PARSER ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.api.internal.artifacts.ExcludeRuleNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( candidate . getName (  )  . equals ( selector . getName (  )  )  )     &  &     ( candidate . getGroup (  )  . equals ( selector . getGroup (  )  )  )  )     &  &     ( candidate . getVersion (  )  . equals ( selector . getVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isSatisfiedBy"], "fileName": "org.gradle.api.internal.artifacts.ModuleVersionSelectorStrictSpec"}, {"methodBody": ["METHOD_START", "{", "return   project . getGroup (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.gradle.api.internal.artifacts.ProjectBackedModule"}, {"methodBody": ["METHOD_START", "{", "return   project . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.ProjectBackedModule"}, {"methodBody": ["METHOD_START", "{", "return   project . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectPath"], "fileName": "org.gradle.api.internal.artifacts.ProjectBackedModule"}, {"methodBody": ["METHOD_START", "{", "return   project . getStatus (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.api.internal.artifacts.ProjectBackedModule"}, {"methodBody": ["METHOD_START", "{", "return   project . getVersion (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.internal.artifacts.ProjectBackedModule"}, {"methodBody": ["METHOD_START", "{", "target . reason    =    reason ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractDependency"}, {"methodBody": ["METHOD_START", "{", "artifacts . add ( artifact )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addArtifact"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . onMutate    =    ImmutableActionSet . of ( onMutate ,    action )  ;", "}", "METHOD_END"], "methodName": ["addMutationValidator"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   artifact ( ConfigureUtil . configureUsing ( configureClosure )  )  ;", "}", "METHOD_END"], "methodName": ["artifact"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "super . copyTo ( target )  ;", "target . setArtifacts ( new   HashSet < artifacts . DependencyArtifact >  ( getArtifacts (  )  )  )  ;", "target . setExcludeRuleContainer ( new   DefaultExcludeRuleContainer ( getExcludeRules (  )  )  )  ;", "target . setTransitive ( isTransitive (  )  )  ;", "target . setAttributes ( attributes )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "if    ( excludeRuleContainer . maybeAdd ( excludeProperties )  )     {", "validateMutation (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   artifacts ;", "}", "METHOD_END"], "methodName": ["getArtifacts"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   attributesFactory ;", "}", "METHOD_END"], "methodName": ["getAttributesFactory"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   excludeRuleContainer . getRules (  )  ;", "}", "METHOD_END"], "methodName": ["getExcludeRules"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isKeyEquals ( dependencyRhs )  )  )     {", "return   false ;", "}", "if    (  ( isTransitive (  )  )     !  =     ( dependencyRhs . isTransitive (  )  )  )     {", "return   false ;", "}", "if    (  !  ( Objects . equal ( getArtifacts (  )  ,    dependencyRhs . getArtifacts (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( Objects . equal ( getExcludeRules (  )  ,    dependencyRhs . getExcludeRules (  )  )  )  )     {", "return   false ;", "}", "if    (  !  ( Objects . equal ( getAttributes (  )  ,    dependencyRhs . getAttributes (  )  )  )  )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isCommonContentEquals"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getGroup (  )  )     !  =    null    ?     !  ( getGroup (  )  . equals ( dependencyRhs . getGroup (  )  )  )     :     ( dependencyRhs . getGroup (  )  )     !  =    null )     {", "return   false ;", "}", "if    (  !  ( getName (  )  . equals ( dependencyRhs . getName (  )  )  )  )     {", "return   false ;", "}", "if    (  ( getTargetConfiguration (  )  )     !  =    null    ?     !  ( getTargetConfiguration (  )  . equals ( dependencyRhs . getTargetConfiguration (  )  )  )     :     ( dependencyRhs . getTargetConfiguration (  )  )     !  =    null )     {", "return   false ;", "}", "if    (  ( getVersion (  )  )     !  =    null    ?     !  ( getVersion (  )  . equals ( dependencyRhs . getVersion (  )  )  )     :     ( dependencyRhs . getVersion (  )  )     !  =    null )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isKeyEquals"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   transitive ;", "}", "METHOD_END"], "methodName": ["isTransitive"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . artifacts    =    artifacts ;", "}", "METHOD_END"], "methodName": ["setArtifacts"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . attributes    =    attributes ;", "}", "METHOD_END"], "methodName": ["setAttributes"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . attributesFactory    =    attributesFactory ;", "}", "METHOD_END"], "methodName": ["setAttributesFactory"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "this . excludeRuleContainer    =    excludeRuleContainer ;", "}", "METHOD_END"], "methodName": ["setExcludeRuleContainer"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "validateMutation ( this . configuration ,    configuration )  ;", "this . configuration    =    configuration ;", "}", "METHOD_END"], "methodName": ["setTargetConfiguration"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "validateMutation ( this . transitive ,    transitive )  ;", "this . transitive    =    transitive ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTransitive"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "onMutate . execute ( this )  ;", "}", "METHOD_END"], "methodName": ["validateMutation"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Objects . equal ( currentValue ,    newValue )  )  )     {", "validateMutation (  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateMutation"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "AbstractModuleDependency . LOG . warn (  (  (  (  (  (  (  \" Cannot   set   attributes   for   dependency    \\  \"  \"     +     ( this . getGroup (  )  )  )     +     \"  :  \"  )     +     ( this . getName (  )  )  )     +     \"  :  \"  )     +     ( this . getVersion (  )  )  )     +     \"  \\  \"  :    it   was   probably   created   by   a   plugin   using   internal   APIs \"  )  )  ;", "}", "METHOD_END"], "methodName": ["warnAboutInternalApiUse"], "fileName": "org.gradle.api.internal.artifacts.dependencies.AbstractModuleDependency"}, {"methodBody": ["METHOD_START", "{", "return   classifier ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "return   extension ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "return   url ;", "}", "METHOD_END"], "methodName": ["getUrl"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . name )     =  =    null )     {", "throw   new   InvalidUserDataException (  \"    name   must   not   be   null !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifact"}, {"methodBody": ["METHOD_START", "{", "String   testName    =     \" name \"  ;", "String   testType    =     \" type \"  ;", "String   testExtension    =     \" ext \"  ;", "String   testClassifier    =     \" classifier \"  ;", "String   testUrl    =     \" url \"  ;", "DependencyArtifact   artifact    =    new    ( testName ,    testType ,    testExtension ,    testClassifier ,    testUrl )  ;", "assertEquals ( testName ,    artifact . getName (  )  )  ;", "assertEquals ( testType ,    artifact . getType (  )  )  ;", "assertEquals ( testExtension ,    artifact . getExtension (  )  )  ;", "assertEquals ( testClassifier ,    artifact . getClassifier (  )  )  ;", "assertEquals ( testUrl ,    artifact . getUrl (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInit"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultDependencyArtifactTest"}, {"methodBody": ["METHOD_START", "{", "projectAccessListener . beforeResolvingProjectDependency ( dependencyProject )  ;", "}", "METHOD_END"], "methodName": ["beforeResolved"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    dependency )     {", "return   true ;", "}", "if    (  ( dependency    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( dependency . getClass (  )  )  )  )     {", "return   false ;", "}", "that    =     (  (  )     ( dependency )  )  ;", "if    (  !  ( isCommonContentEquals ( that )  )  )     {", "return   false ;", "}", "return   dependencyProject . equals ( that . getDependencyProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["contentEquals"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDependency   copiedProjectDependency    =    new   DefaultProjectDependency ( dependencyProject ,    getTargetConfiguration (  )  ,    projectAccessListener ,    buildProjectDependencies )  ;", "copyTo ( copiedProjectDependency )  ;", "return   copiedProjectDependency ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectDependency . TaskDependencyImpl (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   dependencyProject ;", "}", "METHOD_END"], "methodName": ["getDependencyProject"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   dependencyProject . getGroup (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getGroup"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   dependencyProject . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   dependencyProject . getVersion (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "return   resolve ( true )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "CachingDependencyResolveContext   context    =    new   CachingDependencyResolveContext ( transitive ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "context . add ( this )  ;", "return   context . resolve (  )  . getFiles (  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultProjectDependency"}, {"methodBody": ["METHOD_START", "{", "SelfResolvingDependency   equalDependency    =    new   DefaultSelfResolvingDependency ( source )  ;", "SelfResolvingDependency   differentSource    =    new   DefaultSelfResolvingDependency ( context . mock ( FileCollectionInternal . class ,     \" other \"  )  )  ;", "Dependency   differentType    =    context . mock ( Dependency . class )  ;", "assertTrue ( dependency . contentEquals ( dependency )  )  ;", "assertTrue ( dependency . contentEquals ( equalDependency )  )  ;", "assertFalse ( dependency . contentEquals ( differentSource )  )  ;", "assertFalse ( dependency . contentEquals ( differentType )  )  ;", "}", "METHOD_END"], "methodName": ["contentsAreEqualWhenFileSetsAreEqual"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "DefaultSelfResolvingDependency   copy    =    dependency . copy (  )  ;", "assertThat ( copy ,    instanceOf ( DefaultSelfResolvingDependency . class )  )  ;", "assertThat ( copy . getTargetComponentId (  )  ,    equalTo ( targetComponent )  )  ;", "assertThat ( copy . getFiles (  )  ,    sameInstance (  (  ( Object )     ( source )  )  )  )  ;", "assertTrue ( copy . contentEquals ( dependency )  )  ;", "assertTrue ( dependency . contentEquals ( copy )  )  ;", "}", "METHOD_END"], "methodName": ["createsCopy"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( dependency . getGroup (  )  ,    nullValue (  )  )  ;", "assertThat ( dependency . getName (  )  ,    equalTo (  \" unspecified \"  )  )  ;", "assertThat ( dependency . getVersion (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["defaultValues"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "final   DependencyResolveContext   resolveContext    =    context . mock ( DependencyResolveContext . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( resolveContext )  . add ( source )  ;", "}", "}  )  ;", "dependency . resolve ( resolveContext )  ;", "}", "METHOD_END"], "methodName": ["resolvesToTheSourceFileCollection"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "final   TaskDependency   taskDependency    =    context . mock ( TaskDependency . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( source )  . getBuildD (  )  ;", "will ( returnValue ( taskDependency )  )  ;", "}", "}  )  ;", "assertThat ( dependency . getBuildD (  )  ,    sameInstance ( taskDependency )  )  ;", "}", "METHOD_END"], "methodName": ["usesSourceFileCollectionToDetermineBuildDependencies"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file    =    new   File (  \" file \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( source )  . getFiles (  )  ;", "will ( returnValue ( WrapUtil . toSet ( file )  )  )  ;", "}", "}  )  ;", "assertThat ( y . resolve (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file )  )  )  ;", "assertThat ( y . resolve ( true )  ,    equalTo ( WrapUtil . toLinkedSet ( file )  )  )  ;", "assertThat ( y . resolve ( false )  ,    equalTo ( WrapUtil . toLinkedSet ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesSourceFileCollectionToResolveFiles"], "fileName": "org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependencyTest"}, {"methodBody": ["METHOD_START", "{", "taskDependency . add ( tasks )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   taskDependency ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.artifacts.publish.AbstractPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   archiveTask ;", "}", "METHOD_END"], "methodName": ["getArchiveTask"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( classifier ,    archiveTask . getClassifier (  )  )  ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( date ,    new   Date ( archiveTask . getArchivePath (  )  . lastModified (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( extension ,    archiveTask . getExtension (  )  )  ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( file ,    archiveTask . getArchivePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name )     !  =    null )     {", "return   name ;", "}", "if    (  ( aTask . getBaseName (  )  )     !  =    null )     {", "return   withAppendix ( aTask . getBaseName (  )  )  ;", "}", "return   aTask . getAppendix (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( type ,    archiveTask . getExtension (  )  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . classifier    =    classifier ;", "}", "METHOD_END"], "methodName": ["setClassifier"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . date    =    date ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . extension    =    extension ;", "}", "METHOD_END"], "methodName": ["setExtension"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . file    =    file ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   baseName    +     ( GUtil . isTrue ( archiveTask . getAppendix (  )  )     ?     \"  -  \"     +     ( archiveTask . getAppendix (  )  )     :     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["withAppendix"], "fileName": "org.gradle.api.internal.artifacts.publish.ArchivePublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   publishArtifact ;", "}", "METHOD_END"], "methodName": ["getPublishArtifact"], "fileName": "org.gradle.api.internal.artifacts.publish.DecoratingPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   classifier ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   date ;", "}", "METHOD_END"], "methodName": ["getDate"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   extension ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . classifier    =    classifier ;", "}", "METHOD_END"], "methodName": ["setClassifier"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . date    =    date ;", "}", "METHOD_END"], "methodName": ["setDate"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . extension    =    extension ;", "}", "METHOD_END"], "methodName": ["setExtension"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . file    =    file ;", "}", "METHOD_END"], "methodName": ["setFile"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "this . type    =    type ;", "}", "METHOD_END"], "methodName": ["setType"], "fileName": "org.gradle.api.internal.artifacts.publish.DefaultPublishArtifact"}, {"methodBody": ["METHOD_START", "{", "return   password ;", "}", "METHOD_END"], "methodName": ["getPassword"], "fileName": "org.gradle.api.internal.artifacts.repositories.DefaultPasswordCredentials"}, {"methodBody": ["METHOD_START", "{", "return   username ;", "}", "METHOD_END"], "methodName": ["getUsername"], "fileName": "org.gradle.api.internal.artifacts.repositories.DefaultPasswordCredentials"}, {"methodBody": ["METHOD_START", "{", "this . password    =    password ;", "}", "METHOD_END"], "methodName": ["setPassword"], "fileName": "org.gradle.api.internal.artifacts.repositories.DefaultPasswordCredentials"}, {"methodBody": ["METHOD_START", "{", "this . username    =    username ;", "}", "METHOD_END"], "methodName": ["setUsername"], "fileName": "org.gradle.api.internal.artifacts.repositories.DefaultPasswordCredentials"}, {"methodBody": ["METHOD_START", "{", "return   attribute ;", "}", "METHOD_END"], "methodName": ["getAttribute"], "fileName": "org.gradle.api.internal.attributes.AttributeMergingException"}, {"methodBody": ["METHOD_START", "{", "return   leftValue ;", "}", "METHOD_END"], "methodName": ["getLeftValue"], "fileName": "org.gradle.api.internal.attributes.AttributeMergingException"}, {"methodBody": ["METHOD_START", "{", "return   rightValue ;", "}", "METHOD_END"], "methodName": ["getRightValue"], "fileName": "org.gradle.api.internal.attributes.AttributeMergingException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( value )     !  =    null )     {", "Isola < S >    converted    =    value . coerce ( type )  ;", "if    ( converted    !  =    null )     {", "return   converted . isolate (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["coerce"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributes"}, {"methodBody": ["METHOD_START", "{", "DefaultImmutableAttributes   attributes    =    hierarchyByName . get ( key )  ;", "return   attributes    =  =    null    ?    AttributeValue . MISSING    :    attributes ;", "}", "METHOD_END"], "methodName": ["findEntry"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributes"}, {"methodBody": ["METHOD_START", "{", "DefaultImmutableAttributes   attributes    =    hierarchy . get ( key )  ;", "return    (  ( AttributeValue < T >  )     ( attributes    =  =    null    ?    AttributeValue . MISSING    :    attributes )  )  ;", "}", "METHOD_END"], "methodName": ["findEntry"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributes"}, {"methodBody": ["METHOD_START", "{", "DefaultImmutableAttributes   attributes    =    hierarchy . get ( key )  ;", "return    (  ( Isolatable < T >  )     ( attributes    =  =    null    ?    null    :    attributes . value )  )  ;", "}", "METHOD_END"], "methodName": ["getIsolatableAttribute"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributes"}, {"methodBody": ["METHOD_START", "{", "synchronized ( this )     {", "List <  >    nodeChildren    =    children . get ( node )  ;", "if    ( nodeChildren    =  =    null )     {", "nodeChildren    =    Lists . newArrayList (  )  ;", "children . put ( node ,    nodeChildren )  ;", "}", "for    (    child    :    nodeChildren )     {", "if    (  ( child . attribute . equals ( key )  )     &  &     ( child . value . equals ( value )  )  )     {", "return   child ;", "}", "}", "child    =    new    (  (  (  )     ( node )  )  ,    key ,    value )  ;", "nodeChildren . add ( child )  ;", "return   child ;", "}", "}", "METHOD_END"], "methodName": ["doConcatIsolatable"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   String )     {", "return    (  ( Isolatable < T >  )     ( new   CoercingStringValueSnapshot (  (  ( String )     ( value )  )  ,    instantiator )  )  )  ;", "} else    {", "return   isolatable . isolate ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["isolate"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "return   children . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.attributes.DefaultImmutableAttributesFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     =  =    null )     {", "return   state ;", "} else    {", "Imms   attributes    =    parent . asImmutable (  )  ;", "if    (  !  ( state . isEmpty (  )  )  )     {", "attributes    =    cache . concat ( attributes ,    state )  ;", "}", "return   attributes ;", "}", "}", "METHOD_END"], "methodName": ["asImmutable"], "fileName": "org.gradle.api.internal.attributes.DefaultMutableAttributeContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Setting   null   as   an      value   is   not   allowed \"  )  ;", "}", "if    (  !  (  . getType (  )  . isAssignableFrom ( value . getClass (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Unexpected   type   for       '  \"     +     (  . getName (  )  )  )     +     \"  '  .    Expected    \"  )     +     (  . getType (  )  . getName (  )  )  )     +     \"    but   was :  \"  )     +     ( value . getClass (  )  . getName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertAttributeConstraints"], "fileName": "org.gradle.api.internal.attributes.DefaultMutableAttributeContainer"}, {"methodBody": ["METHOD_START", "{", "for    ( Attribute <  ?  >    attribute    :    state . keySet (  )  )     {", "String   name    =    key . getName (  )  ;", "if    (  ( attribute . getName (  )  . equals ( name )  )     &  &     (  ( attribute . getType (  )  )     !  =     ( key . getType (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  (  \" Cannot   have   two      with   the   same   name   but   different   types .     \"     +     \" This   container   already   has   an   attribute   named    '  \"  )     +    name )     +     \"  '    of   type    '  \"  )     +     ( attribute . getType (  )  . getName (  )  )  )     +     \"  '    and   you   are   trying   to   store   another   one   of   type    '  \"  )     +     ( key . getType (  )  . getName (  )  )  )     +     \"  '  \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkInsertionAllowed"], "fileName": "org.gradle.api.internal.attributes.DefaultMutableAttributeContainer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isIncremental"], "fileName": "org.gradle.api.internal.changedetection.changes.ChangesOnlyIncrementalTaskInputs"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskArtifactStateRepository . TaskArtifactStateImpl ( task ,    taskHistoryRepository . getHistory ( task ,    taskProperties )  )  ;", "}", "METHOD_END"], "methodName": ["getStateFor"], "fileName": "org.gradle.api.internal.changedetection.changes.DefaultTaskArtifactStateRepository"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    inputFiles )     {", "outOfDateAction . execute ( new    . RebuildInputFile ( file )  )  ;", "}", "}", "METHOD_END"], "methodName": ["doOutOfDate"], "fileName": "org.gradle.api.internal.changedetection.changes.RebuildIncrementalTaskInputs"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isIncremental"], "fileName": "org.gradle.api.internal.changedetection.changes.RebuildIncrementalTaskInputs"}, {"methodBody": ["METHOD_START", "{", "AndSpec <  ?    super   TaskInternal >    upToDateSpec    =    task . getOutputs (  )  . getUpToDateSpec (  )  ;", "if    (  (  !  ( taskProperties . hasDeclaredOutputs (  )  )  )     &  &     ( upToDateSpec . isEmpty (  )  )  )     {", "if    ( task . hasTaskActions (  )  )     {", "return   NoOutputsArtifactState . WITH _ ACTIONS ;", "} else    {", "return   NoOutputsArtifactState . WITHOUT _ ACTIONS ;", "}", "}", "TaskArtifactState   state    =    repository . getStateFor ( task ,    taskProperties )  ;", "if    ( startParameter . isRerunTasks (  )  )     {", "return   new    . RerunTaskArtifactState ( state ,    task ,     \" Executed   with    '  -  - rerun - tasks '  .  \"  )  ;", "}", "if    (  !  ( upToDateSpec . isSatisfiedBy ( task )  )  )     {", "return   new    . RerunTaskArtifactState ( state ,    task ,     \" Task . upToDateWhen   is   false .  \"  )  ;", "}", "return   state ;", "}", "METHOD_END"], "methodName": ["getStateFor"], "fileName": "org.gradle.api.internal.changedetection.changes.ShortCircuitTaskArtifactStateRepository"}, {"methodBody": ["METHOD_START", "{", "if    ( outOfDateProcessed )     {", "throw   new   IllegalException (  \" Cannot   process   outOfDate   files   multiple   times \"  )  ;", "}", "doOutOfDate ( outOfDateAction )  ;", "outOfDateProcessed    =    true ;", "}", "METHOD_END"], "methodName": ["outOfDate"], "fileName": "org.gradle.api.internal.changedetection.changes.StatefulIncrementalTaskInputs"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( outOfDateProcessed )  )     {", "throw   new   IllegalException (  \" Must   first   process   outOfDate   files   before   processing   removed   files \"  )  ;", "}", "if    ( removedProcessed )     {", "throw   new   IllegalException (  \" Cannot   process   removed   files   multiple   times \"  )  ;", "}", "doRemoved ( removedAction )  ;", "removedProcessed    =    true ;", "}", "METHOD_END"], "methodName": ["removed"], "fileName": "org.gradle.api.internal.changedetection.changes.StatefulIncrementalTaskInputs"}, {"methodBody": ["METHOD_START", "{", "return   getSnapshot ( current )  ;", "}", "METHOD_END"], "methodName": ["getCurrent"], "fileName": "org.gradle.api.internal.changedetection.rules.AbstractNamedFileSnapshotTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "final   List < Iterator < TaskStateChange >  >    iterators    =    new   ArrayList < Iterator < TaskStateChange >  >  (  )  ;", "SortedMapDiffUtil . diff ( getPrevious (  )  ,    getCurrent (  )  ,    new   PropertyDiffListener < String ,    FileCollectionSnapshot >  (  )     {", "@ Override", "public   void   removed ( String   previousProperty )     {", "}", "@ Override", "public   void   added ( String   currentProperty )     {", "}", "@ Override", "public   void   updated ( String   property ,    FileCollectionSnapshot   previousSnapshot ,    FileCollectionSnapshot   currentSnapshot )     {", "String   propertyTitle    =     (  (  ( title )     +     \"    property    '  \"  )     +    property )     +     \"  '  \"  ;", "iterators . add ( currentSnapshot . iterateContentChangesSince ( previousSnapshot ,    propertyTitle ,    includeAdded )  )  ;", "}", "}  )  ;", "return   Iterators . concat ( iterators . iterator (  )  )  ;", "}", "METHOD_END"], "methodName": ["getFileChanges"], "fileName": "org.gradle.api.internal.changedetection.rules.AbstractNamedFileSnapshotTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "return   getSnapshot ( previous )  ;", "}", "METHOD_END"], "methodName": ["getPrevious"], "fileName": "org.gradle.api.internal.changedetection.rules.AbstractNamedFileSnapshotTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( delegateIterator )     =  =    null )     |  |     ( overrun )  )     {", "reset (  )  ;", "}", "return   new   com . google . common . collect . AbstractIterator <  >  (  )     {", "final   Iterator <  >    cacheIterator    =    new   ArrayList <  >  ( cache )  . iterator (  )  ;", "@ Override", "protected      computeNext (  )     {", "if    ( cacheIterator . hasNext (  )  )     {", "return   cacheIterator . next (  )  ;", "}", "if    ( delegateIterator . hasNext (  )  )     {", "next    =    delegateIterator . next (  )  ;", "maybeCache ( next )  ;", "return   next ;", "}", "return   endOfData (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.changedetection.rules.CachingTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "if    ( overrun )     {", "return ;", "}", "if    (  ( cache . size (  )  )     <     ( maxCached )  )     {", "cache . add ( next )  ;", "} else    {", "overrun    =    true ;", "}", "}", "METHOD_END"], "methodName": ["maybeCache"], "fileName": "org.gradle.api.internal.changedetection.rules.CachingTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "cache . clear (  )  ;", "delegateIterator    =    delegate . iterator (  )  ;", "overrun    =    false ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.gradle.api.internal.changedetection.rules.CachingTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["describe"], "fileName": "org.gradle.api.internal.changedetection.rules.ChangeType"}, {"methodBody": ["METHOD_START", "{", "return   new   CachingTaskStateChanges ( TaskUpToDateState . MAX _ OUT _ OF _ DATE _ MESSAGES ,    wrapped )  ;", "}", "METHOD_END"], "methodName": ["caching"], "fileName": "org.gradle.api.internal.changedetection.rules.DefaultTaskUpToDateState"}, {"methodBody": ["METHOD_START", "{", "return   message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.api.internal.changedetection.rules.DescriptiveChange"}, {"methodBody": ["METHOD_START", "{", "return   new   FileChange ( path ,    ChangeType . ADDED ,    title ,    FileType . Missing ,    currentFileType )  ;", "}", "METHOD_END"], "methodName": ["added"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "if    (  ( change )     !  =     ( ChangeType . MODIFIED )  )     {", "return   change ;", "}", "if    (  ( previousFileType )     =  =     ( FileType . Missing )  )     {", "return   ChangeType . ADDED ;", "}", "if    (  ( currentFileType )     =  =     ( FileType . Missing )  )     {", "return   ChangeType . REMOVED ;", "}", "return   ChangeType . MODIFIED ;", "}", "METHOD_END"], "methodName": ["getDisplayedChangeType"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( path )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( title )     +     \"    file    \"  )     +     ( path )  )     +     \"     \"  )     +     ( getDisplayedChangeType (  )  . describe (  )  )  )     +     \"  .  \"  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   change ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return    ( change )     =  =     ( ChangeType . ADDED )  ;", "}", "METHOD_END"], "methodName": ["isAdded"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return    ( change )     =  =     ( ChangeType . MODIFIED )  ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return    ( change )     =  =     ( ChangeType . REMOVED )  ;", "}", "METHOD_END"], "methodName": ["isRemoved"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   new   FileChange ( path ,    ChangeType . MODIFIED ,    title ,    previousFileType ,    currentFileType )  ;", "}", "METHOD_END"], "methodName": ["modified"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   new   FileChange ( path ,    ChangeType . REMOVED ,    title ,    previousFileType ,    FileType . Missing )  ;", "}", "METHOD_END"], "methodName": ["removed"], "fileName": "org.gradle.api.internal.changedetection.rules.FileChange"}, {"methodBody": ["METHOD_START", "{", "return   getFileChanges ( true )  . hasNext (  )  ;", "}", "METHOD_END"], "methodName": ["hasAnyChanges"], "fileName": "org.gradle.api.internal.changedetection.rules.OutputFileTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "if    (  ( changes )     =  =    null )     {", "changes    =    new   ArrayList <  >  (  )  ;", "addAllChanges ( changes )  ;", "}", "return   changes . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.changedetection.rules.SimpleTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "Iterator < Map . Entry < K ,    V >  >    currentEntries    =    current . entrySet (  )  . iterator (  )  ;", "Iterator < Map . Entry < K ,    V >  >    previousEntries    =    previous . entrySet (  )  . iterator (  )  ;", "Comparator <  ?    super   K >    comparator    =    previous . comparator (  )  ;", "if    (  ( currentEntries . hasNext (  )  )     &  &     ( previousEntries . hasNext (  )  )  )     {", "Map . Entry < K ,    V >    currentEntry    =    currentEntries . next (  )  ;", "Map . Entry < K ,    V >    previousEntry    =    previousEntries . next (  )  ;", "while    ( true )     {", "K   previousProperty    =    previousEntry . getKey (  )  ;", "K   currentProperty    =    currentEntry . getKey (  )  ;", "int   compared    =    comparator . compare ( previousProperty ,    currentProperty )  ;", "if    ( compared    <     0  )     {", "diffListener . removed ( previousProperty )  ;", "if    ( previousEntries . hasNext (  )  )     {", "previousEntry    =    previousEntries . next (  )  ;", "} else    {", "diffListener . added ( currentProperty )  ;", "break ;", "}", "} else", "if    ( compared    >     0  )     {", "diffListener . added ( currentProperty )  ;", "if    ( currentEntries . hasNext (  )  )     {", "currentEntry    =    currentEntries . next (  )  ;", "} else    {", "diffListener . removed ( previousProperty )  ;", "break ;", "}", "} else    {", "diffListener . updated ( previousProperty ,    previousEntry . getValue (  )  ,    currentEntry . getValue (  )  )  ;", "if    (  ( previousEntries . hasNext (  )  )     &  &     ( currentEntries . hasNext (  )  )  )     {", "previousEntry    =    previousEntries . next (  )  ;", "currentEntry    =    currentEntries . next (  )  ;", "} else    {", "break ;", "}", "}", "}", "}", "while    ( currentEntries . hasNext (  )  )     {", "diffListener . added ( currentEntries . next (  )  . getKey (  )  )  ;", "}", "while    ( previousEntries . hasNext (  )  )     {", "diffListener . removed ( previousEntries . next (  )  . getKey (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["diff"], "fileName": "org.gradle.api.internal.changedetection.rules.SortedMapDiffUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskStateChanges   source    :    sources )     {", "Iterator < TaskStateChange >    sourceIterator    =    source . iterator (  )  ;", "if    ( sourceIterator . hasNext (  )  )     {", "return   sourceIterator ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["firstDirtyIterator"], "fileName": "org.gradle.api.internal.changedetection.rules.SummaryTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "return   new   com . google . common . collect . AbstractIterator < TaskStateChange >  (  )     {", "Iterator < TaskStateChange >    changes ;", "int   count ;", "@ Override", "protected   TaskStateChange   computeNext (  )     {", "if    (  ( changes )     =  =    null )     {", "changes    =    firstDirtyIterator (  )  ;", "}", "if    (  (  (  ( count )     <     ( maxReportedChanges )  )     &  &     (  ( changes )     !  =    null )  )     &  &     ( changes . hasNext (  )  )  )     {", "( count )  +  +  ;", "return   changes . next (  )  ;", "}", "return   endOfData (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.api.internal.changedetection.rules.SummaryTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "for    ( Implementanapshot   implementa :    implementa )     {", "if    ( implementahasUnknownClassLoader (  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasAnyUnknownClassLoader"], "fileName": "org.gradle.api.internal.changedetection.rules.TaskTypeTaskStateChanges"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    classBytes    =    ByteStreams . toByteArray ( inputStream )  ;", "ApiClassor   extractor    =    new   ApiClassor ( Collections .  < String > emptySet (  )  )  ;", "ClassReader   reader    =    new   ClassReader ( classBytes )  ;", "if    ( extractor . shouldApiClassFrom ( reader )  )     {", "byte [  ]    signature    =    extractor . extractApiClassFrom ( reader )  ;", "if    ( signature    !  =    null )     {", "return   Hashing . md 5  (  )  . hashBytes ( signature )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["hashClassBytes"], "fileName": "org.gradle.api.internal.changedetection.state.AbiExtractingClasspathResourceHasher"}, {"methodBody": ["METHOD_START", "{", "return   name . endsWith (  \"  . class \"  )  ;", "}", "METHOD_END"], "methodName": ["isClassFile"], "fileName": "org.gradle.api.internal.changedetection.state.AbiExtractingClasspathResourceHasher"}, {"methodBody": ["METHOD_START", "{", "return   new   ClasspathEntrySnapshotBuilder ( classpathResourceHasher ,    stringInterner )  ;", "}", "METHOD_END"], "methodName": ["newClasspathEntrySnapshotBuilder"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractClasspathSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "HashCode   hash    =    cacheService . hashFile ( jarFile ,    jarHasher ,    jarHasherConfigurationHash )  ;", "if    ( hash    !  =    null )     {", "builder . collectFile ( jarFile . withContentHash ( hash )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitJar"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractClasspathSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "return   stringInterner ;", "}", "METHOD_END"], "methodName": ["getStringInterner"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter"}, {"methodBody": ["METHOD_START", "{", "registry . register ( DefaultFileCollectionSnapshot . class ,    new   DefaultFileCollectionSnapshot . SerializerImpl ( stringInterner )  )  ;", "registry . register ( EmptyFileCollectionSnapshot . class ,    Serializers . constant ( EmptyFileCollectionSnapshot . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["registerSerializers"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter"}, {"methodBody": ["METHOD_START", "{", "FileCollectionInternal   fileCollection    =     (  ( FileCollectionInternal )     ( input )  )  ;", ". FileCollectionVisitorImpl   visitor    =    new    . FileCollectionVisitorImpl ( builder )  ;", "fileCollection . visitRootElements ( visitor )  ;", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractFileCollectionSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   getNormalizedPath (  )  . equals ( other . getNormalizedPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasSameNormalizedPathAs"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractNormalizedFileSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   getNormalizedPath (  )  . hashCode (  )  ;", "}", "METHOD_END"], "methodName": ["hashNormalizedPath"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractNormalizedFileSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.api.internal.changedetection.state.AbstractScalarValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   elements ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "org.gradle.api.internal.changedetection.state.ArrayValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    ( other   instanceof   ArrayValueSnapshot )     {", "ArrayValueSnapshot   otherArray    =     (  ( ArrayValueSnapshot )     ( other )  )  ;", "if    ( Arrays . equals ( elements ,    otherArray . elements )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEqualArrayValueSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ArrayValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "for    ( File   file    :    files )     {", "addPath ( file ,    builder ,    stringIer )  ;", "}", "}", "METHOD_END"], "methodName": ["addAllPaths"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "return   builder . add ( stringInterner . intern ( file . getAbsolutePath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addPath"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "if    ( taskA . isEmpty (  )  )     {", "return   ImmutableList . of (  )  ;", "}", "ImmutableList . Builder < ImplementationSnapshot >    amplementations    =    ImmutableList . builder (  )  ;", "for    ( ContextAwareTaskAtaskA :    taskA )     {", "String   typeName    =    taskAgetAlassName (  )  ;", "HashCode   classLoaderHash    =    classLoaderHierarchyHasher . getClassLoaderHash ( taskAgetClassLoader (  )  )  ;", "amplementations . add ( new   ImplementationSnapshot ( typeName ,    classLoaderHash )  )  ;", "}", "return   amplementations . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectActionImplementations"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "Class <  ?    extends   TaskInternal >    taskClass    =    task . getClass (  )  ;", "List < ContextAwareTaskAction >    taskActions    =    task . getTaskActions (  )  ;", "ImplementationSnapshot   taskImplementation    =    new   ImplementationSnapshot ( taskClass . getName (  )  ,    classLoaderHierarchyHasher . getClassLoaderHash ( taskClass . getClassLoader (  )  )  )  ;", "ImmutableList < ImplementationSnapshot >    taskActionImplementations    =     . collectActionImplementations ( taskActions ,    classLoaderHierarchyHasher )  ;", "if    (  . LOGGER . isDebugEnabled (  )  )     {", ". LOGGER . debug (  \" Implementation   for    {  }  :     {  }  \"  ,    task ,    taskImplementation )  ;", ". LOGGER . debug (  \" Action   implementations   for    {  }  :     {  }  \"  ,    task ,    taskActionImplementations )  ;", "}", "ImmutableSortedMap < String ,    ValueSnapshot >    previousInputProperties    =     ( previousExecution    =  =    null )     ?    ImmutableSortedMap .  < String ,    ValueSnapshot > of (  )     :    previousExecution . getInputProperties (  )  ;", "ImmutableSortedMap < String ,    ValueSnapshot >    inputProperties    =     . snapshotTaskInputProperties ( task ,    taskProperties ,    previousInputProperties ,    valueSnapshotter )  ;", "ImmutableSortedSet < String >    outputPropertyNames    =     . getOutputPropertyNamesForCacheKey ( taskProperties )  ;", "ImmutableSet < String >    declaredOutputFilePaths    =     . getDeclaredOutputFilePaths ( taskProperties ,    stringInterner )  ;", "ImmutableSortedMap < String ,    FileCollectionSnapshot >    inputFiles    =     . snapshotTaskFiles ( task ,     \" Input \"  ,    normalizationStrategy ,    taskProperties . getInputFileProperties (  )  ,    snapshotterRegistry )  ;", "ImmutableSortedMap < String ,    FileCollectionSnapshot >    outputFiles    =     . snapshotTaskFiles ( task ,     \" Output \"  ,    normalizationStrategy ,    taskProperties . getOutputFileProperties (  )  ,    snapshotterRegistry )  ;", "FileCollectionSnapshot   previousDiscoveredInputs    =     ( previousExecution    =  =    null )     ?    null    :    previousExecution . getDiscoveredInputFilesSnapshot (  )  ;", "FileCollectionSnapshot   discoveredInputs ;", "if    ( previousDiscoveredInputs    !  =    null )     {", "discoveredInputs    =     . snapshotDiscoveredInputs ( task ,    normalizationStrategy ,    previousDiscoveredInputs . getElements (  )  ,    snapshotterRegistry ,    fileCollectionFactory )  ;", "} else    {", "discoveredInputs    =    EmptyFileCollectionSnapshot . INSTANCE ;", "}", "OverlappingOutputs   overlappingOutputs    =     . detectOverlappingOutputs ( outputFiles ,    previousExecution )  ;", "return   new   CurrentTaskExecution ( taskImplementation ,    taskActionImplementations ,    inputProperties ,    outputPropertyNames ,    declaredOutputFilePaths ,    inputFiles ,    discoveredInputs ,    outputFiles ,    overlappingOutputs )  ;", "}", "METHOD_END"], "methodName": ["createExecution"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    FileCollectionSnapshot >    entry    :    taskOutputs . entrySet (  )  )     {", "String   propertyName    =    entry . getKey (  )  ;", "FileCollectionSnapshot   beforeExecution    =    entry . getValue (  )  ;", "FileCollectionSnapshot   afterPreviousExecution    =     . getSnapshotAfterPreviousExecution ( previousExecution ,    propertyName )  ;", "OverlappingOutputs   overlappingOutputs    =    OverlappingOutputs . detect ( propertyName ,    afterPreviousExecution ,    beforeExecution )  ;", "if    ( overlappingOutputs    !  =    null )     {", "return   overlappingOutputs ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["detectOverlappingOutputs"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "FileCollectionSnapshot   filesSnapshot ;", "Map < String ,    NormalizedFileSnapshot >    afterSnapshots    =    afterExecution . getSnapshots (  )  ;", "if    (  (  !  ( beforeExecution . getSnapshots (  )  . isEmpty (  )  )  )     &  &     (  !  ( afterSnapshots . isEmpty (  )  )  )  )     {", "Map < String ,    NormalizedFileSnapshot >    beforeSnapshots    =    beforeExecution . getSnapshots (  )  ;", "Map < String ,    NormalizedFileSnapshot >    afterPreviousSnapshots    =     ( afterPreviousExecution    !  =    null )     ?    afterPreviousExecution . getSnapshots (  )     :    new   HashMap < String ,    NormalizedFileSnapshot >  (  )  ;", "int   newEntryCount    =     0  ;", "Builder < String ,    NormalizedFileSnapshot >    outputEntries    =    ImmutableMap . builder (  )  ;", "for    ( Map . Entry < String ,    NormalizedFileSnapshot >    entry    :    afterSnapshots . entrySet (  )  )     {", "final   String   path    =    entry . getKey (  )  ;", "NormalizedFileSnapshot   fileSnapshot    =    entry . getValue (  )  ;", "if    (  . isOutputEntry ( path ,    fileSnapshot ,    beforeSnapshots ,    afterPreviousSnapshots )  )     {", "outputEntries . put ( entry . getKey (  )  ,    fileSnapshot )  ;", "newEntryCount +  +  ;", "}", "}", "if    ( newEntryCount    =  =     ( afterSnapshots . size (  )  )  )     {", "filesSnapshot    =    afterExecution ;", "} else", "if    ( newEntryCount    =  =     0  )     {", "filesSnapshot    =    EmptyFileCollectionSnapshot . INSTANCE ;", "} else    {", "filesSnapshot    =    new   DefaultFileCollectionSnapshot ( outputEntries . build (  )  ,    TaskFilePropertyCompareStrategy . UNORDERED ,    true )  ;", "}", "} else    {", "filesSnapshot    =    afterExecution ;", "}", "return   filesSnapshot ;", "}", "METHOD_END"], "methodName": ["filterOutputSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "final   ImmutableSet . Builder < String >    declaredOutputFilePaths    =    ImmutableSortedSet . naturalOrder (  )  ;", "FileCollectionI   outputFiles    =     (  ( FileCollectionI )     ( taskProperties . getOutputFiles (  )  )  )  ;", "outputFiles . visitRootElements ( new   FileCollectionVisitor (  )     {", "@ Override", "public   void   visitCollection ( FileCollectionI   fileCollection )     {", "addAllPaths ( fileCollection ,    declaredOutputFilePaths ,    stringInterner )  ;", "}", "@ Override", "public   void   visitTree ( FileTreeI   fileTree )     {", "DeprecationLogger . nagUserOfDeprecated (  \" Adding   file   trees   which   are   not   directory   trees   as   output   files \"  )  ;", "addAllPaths ( fileTree ,    declaredOutputFilePaths ,    stringInterner )  ;", "}", "@ Override", "public   void   visitDirectoryTree ( DirectoryFileTree   directoryTree )     {", "addPath ( directoryTree . getDir (  )  ,    declaredOutputFilePaths ,    stringInterner )  ;", "}", "}  )  ;", "return   declaredOutputFilePaths . build (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredOutputFilePaths"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet < TaskOutputFilePropertySpec >    fileProperties    =    taskProperties . getOutputFileProperties (  )  ;", "List < String >    outputPropertyNames    =    Lists . newArrayListWithCapacity ( fileProperties . size (  )  )  ;", "for    ( TaskOutputFilePropertySpec   propertySpec    :    fileProperties )     {", "if    ( propertySpec   instanceof   ableTaskOutputFilePropertySpec )     {", "ableTaskOutputFilePropertySpec   cacheablePropertySpec    =     (  ( ableTaskOutputFilePropertySpec )     ( propertySpec )  )  ;", "if    (  ( cacheablePropertySpec . getOutputFile (  )  )     !  =    null )     {", "outputPropertyNames . add ( propertySpec . getPropertyName (  )  )  ;", "}", "}", "}", "return   ImmutableSortedSet . copyOf ( outputPropertyNames )  ;", "}", "METHOD_END"], "methodName": ["getOutputPropertyNamesForCacheKey"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "if    ( previousExecution    !  =    null )     {", "Map < String ,    FileCollSnapshot >    previousSnapshots    =    previousExecution . getOutputFilesSnapshot (  )  ;", "FileCollSnapshot   afterPreviousExecution    =    previousSnapshots . get ( propertyName )  ;", "if    ( afterPreviousExecution    !  =    null )     {", "return   afterPreviousExecution ;", "}", "}", "return   EmptyFileCollSnapshot . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getSnapshotAfterPreviousExecution"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileSnapshot . getSnapshot (  )  . getType (  )  )     =  =     ( FileType . Missing )  )     {", "return   false ;", "}", "NormalizedFileSnapshot   beforeSnapshot    =    beforeSnapshots . get ( path )  ;", "if    ( beforeSnapshot    =  =    null )     {", "return   true ;", "}", "if    (  !  ( fileSnapshot . getSnapshot (  )  . isContAndMetadataUpToDate ( beforeSnapshot . getSnapshot (  )  )  )  )     {", "return   true ;", "}", "return   afterPreviousSnapshots . containsKey ( path )  ;", "}", "METHOD_END"], "methodName": ["isOutputEntry"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "return   taskHistoryCache . get ( task . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadPreviousExecution"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "FileCollectionSnapshotter   snapshotter    =    snapshotterRegistry . getSnapshotter ( GenericFileNormalizer . class )  ;", "if    ( discoveredInputs . isEmpty (  )  )     {", ". LOGGER . debug (  \" No   discovered   inputs   for    {  }  \"  ,    task )  ;", "return   EmptyFileCollectionSnapshot . INSTANCE ;", "}", ". LOGGER . debug (  \" Snapshotting   discovered   inputs   for    {  }  \"  ,    task )  ;", "try    {", "return   snapshotter . snapshot ( fileCollectionFactory . fixed (  \" Discovered   input   files \"  ,    discoveredInputs )  ,    InputPathNormalizationStrategy . ABSOLUTE ,    normalizationStrategy )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Failed   to   capture   snapshot   of   discovered   input   files   for    % s   during   up - to - date   check .  \"  ,    task )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["snapshotDiscoveredInputs"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    FileCollectionSnapshot >    builder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( TaskFilePropertySpec   propertySpec    :    fileProperties )     {", "FileCollectionSnapshot   result ;", "try    {", "FileCollectionSnapshotter   snapshotter    =    snapshotterRegistry . getSnapshotter ( propertySpec . getNormalizer (  )  )  ;", ". LOGGER . debug (  \" Snapshotting   property    {  }    for    {  }  \"  ,    propertySpec ,    task )  ;", "result    =    snapshotter . snapshot ( propertySpec . getPropertyFiles (  )  ,    propertySpec . getPathNormalizationStrategy (  )  ,    normalizationStrategy )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Failed   to   capture   snapshot   of    % s   files   for    % s   property    '  % s '    during   up - to - date   check .  \"  ,    title . toLowerCase (  )  ,    task ,    propertySpec . getPropertyName (  )  )  ,    e )  ;", "}", "builder . put ( propertySpec . getPropertyName (  )  ,    result )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["snapshotTaskFiles"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    ValueSnapshot >    builder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( Map . Entry < String ,    Object >    entry    :    taskProperties . getInputPropertyValues (  )  . create (  )  . entrySet (  )  )     {", "String   propertyName    =    entry . getKey (  )  ;", "Object   value    =    entry . getValue (  )  ;", "try    {", "ValueSnapshot   previousSnapshot    =    previousInputProperties . get ( propertyName )  ;", "if    ( previousSnapshot    =  =    null )     {", "builder . put ( propertyName ,    valueSnapshotter . snapshot ( value )  )  ;", "} else    {", "builder . put ( propertyName ,    valueSnapshotter . snapshot ( value ,    previousSnapshot )  )  ;", "}", "}    catch    ( Excep   e )     {", "throw   new   UncheckedIOExcep ( String . format (  \" Unable   to   store   input   properties   for    % s .    Property    '  % s '    with   value    '  % s '    cannot   be   serialized .  \"  ,    task ,    propertyName ,    value )  ,    e )  ;", "}", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["snapshotTaskInputProperties"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "currentExecution . setSuccessful (  (  ( task . getState (  )  . getFailure (  )  )     =  =    null )  )  ;", "currentExecution . setOutputFilesSnapshot ( newOutputSnapshot )  ;", "FileCollectionSnapshot   discoveredFilesSnapshot ;", "if    ( taskInputs    !  =    null )     {", "discoveredFilesSnapshot    =     . snapshotDiscoveredInputs ( task ,    normalizationStrategy ,    taskInputs . getDiscoveredInputs (  )  ,    snapshotterRegistry ,    fileCollectionFactory )  ;", "} else    {", "discoveredFilesSnapshot    =    EmptyFileCollectionSnapshot . INSTANCE ;", "}", "currentExecution . setDiscoveredInputFilesSnapshot ( discoveredFilesSnapshot )  ;", "}", "METHOD_END"], "methodName": ["updateExecution"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "final   ImmutableSortedMap < String ,    FileCollectionSnapshot >    outputFilesAfter    =    CacheBackedTaskHistoryRepository . snapshotTaskFiles ( task ,     \" Output \"  ,    normalizationStrategy ,    taskProperties . getOutputFileProperties (  )  ,    snapshotterRegistry )  ;", "ImmutableSortedMap < String ,    FileCollectionSnapshot >    newOutputSnapshot ;", "if    (  ( currentExecution . getDetectedOverlappingOutputs (  )  )     =  =    null )     {", "newOutputSnapshot    =    outputFilesAfter ;", "} else    {", "newOutputSnapshot    =    ImmutableSortedMap . copyOfSorted ( Maps . transformEntries ( currentExecution . getOutputFilesSnapshot (  )  ,    new   EntryTransformer < String ,    FileCollectionSnapshot ,    FileCollectionSnapshot >  (  )     {", "@ Override", "public   FileCollectionSnapshot   transformEntry ( String   propertyName ,    FileCollectionSnapshot   beforeExecution )     {", "FileCollectionSnapshot   afterExecution    =    outputFilesAfter . get ( propertyName )  ;", "FileCollectionSnapshot   afterPreviousExecution    =    getSnapshotAfterPreviousExecution ( previousExecution ,    propertyName )  ;", "return   filterOutputSnapshot ( afterPreviousExecution ,    beforeExecution ,    afterExecution )  ;", "}", "}  )  )  ;", "}", "updateExecution ( currentExecution ,    task ,    taskInputs ,    newOutputSnapshot ,    normalizationStrategy )  ;", "}", "METHOD_END"], "methodName": ["updateExecution"], "fileName": "org.gradle.api.internal.changedetection.state.CacheBackedTaskHistoryRepository"}, {"methodBody": ["METHOD_START", "{", "cache . remove ( path )  ;", "}", "METHOD_END"], "methodName": ["discard"], "fileName": "org.gradle.api.internal.changedetection.state.CachingFileHasher"}, {"methodBody": ["METHOD_START", "{", "FileMetadataSnapshot   fileMetadata    =    fileSystem . stat ( file )  ;", "return   snapshot ( file ,    fileMetadata . getLength (  )  ,    fileMetadata . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CachingFileHasher"}, {"methodBody": ["METHOD_START", "{", "String   absolutePath    =    file . getAbsolutePath (  )  ;", "if    ( timestampInspector . timestampCanBeUsedToDetectFileChange ( absolutePath ,    timestamp )  )     {", ". FileInfo   info    =    cache . get ( absolutePath )  ;", "if    (  (  ( info    !  =    null )     &  &     ( length    =  =     ( info . length )  )  )     &  &     ( timestamp    =  =     ( info . timestamp )  )  )     {", "return   info ;", "}", "}", "HashCode   hash    =    delegate . hash ( file )  ;", ". FileInfo   info    =    new    . FileInfo ( hash ,    length ,    timestamp )  ;", "cache . put ( stringInterner . intern ( absolutePath )  ,    info )  ;", "return   info ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CachingFileHasher"}, {"methodBody": ["METHOD_START", "{", "return   snapshot ( file . getFile (  )  ,    file . getSize (  )  ,    file . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CachingFileHasher"}, {"methodBody": ["METHOD_START", "{", "if    ( normalizedSnapshots . isEmpty (  )  )     {", "return ;", "}", "List < Map . Entry < String ,    NormalizedFileSnapshot >  >    sorted    =    new   ArrayList < Map . Entry < String ,    NormalizedFileSnapshot >  >  ( normalizedSnapshots . entries (  )  )  ;", "Collections . sort ( sorted ,     . SNAPSHOT _ ENTRY _ ORDERING )  ;", "for    ( Map . Entry < String ,    NormalizedFileSnapshot >    normalizedFileSnapshotEntry    :    sorted )     {", "builder . collectNormalizedFileSnapshot ( normalizedFileSnapshotEntry . getKey (  )  ,    normalizedFileSnapshotEntry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["collectNormalizedSnapshots"], "fileName": "org.gradle.api.internal.changedetection.state.ClasspathEntrySnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( normalizedSnapshots . isEmpty (  )  )     {", "return   null ;", "}", "DefaultBuildCacheHasher   hasher    =    new   DefaultBuildCacheHasher (  )  ;", "Collection < NormalizedFileSnapshot >    values    =    normalizedSnapshots . values (  )  ;", "TaskFilePropertyCompareStrategy . UNORDERED . appendToHasher ( hasher ,    values )  ;", "return   hasher . hash (  )  ;", "}", "METHOD_END"], "methodName": ["getHash"], "fileName": "org.gradle.api.internal.changedetection.state.ClasspathEntrySnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( snapshots . isEmpty (  )  )     {", "return   Empty . INSTANCE ;", "}", "return   new   Default ( snapshots ,    compareStrategy ,    pathNormalizationStrategy . isPathAbsolute (  )  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.internal.changedetection.state.CollectingFileCollectionSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "String   absolutePath    =    fileSnapshot . getPath (  )  ;", "if    (  !  ( snapshots . containsKey ( absolutePath )  )  )     {", "NormalizedFileSnapshot   normalizedSnapshot    =    pathNormalizationStrategy . getNormalizedSnapshot ( fileSnapshot ,    stringInterner )  ;", "collectNormalizedFileSnapshot ( absolutePath ,    normalizedSnapshot )  ;", "}", "}", "METHOD_END"], "methodName": ["collectFileSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CollectingFileCollectionSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( normalizedSnapshot    !  =    null )     &  &     (  !  ( snapshots . containsKey ( absolutePath )  )  )  )     {", "snapshots . put ( absolutePath ,    normalizedSnapshot )  ;", "}", "}", "METHOD_END"], "methodName": ["collectNormalizedFileSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CollectingFileCollectionSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   HistoricalTaskExecution ( getTaskImplementation (  )  ,    getTaskActionImplementations (  )  ,    getInputProperties (  )  ,    getOutputPropertyNamesForCacheKey (  )  ,    inputFilesSnapshot ,    discoveredInputFilesSnapshot ,    outputFilesSnapshot ,    successful ,    originExecutionMetadata )  ;", "}", "METHOD_END"], "methodName": ["archive"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "return   declaredOutputFilePaths ;", "}", "METHOD_END"], "methodName": ["getDeclaredOutputFilePaths"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "return   detectedOverlappingOutputs ;", "}", "METHOD_END"], "methodName": ["getDetectedOverlappingOutputs"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "this . discoveredInputFilesSnapshot    =    discoveredInputFilesSnapshot ;", "}", "METHOD_END"], "methodName": ["setDiscoveredInputFilesSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "this . originExecutionMetadata    =    originExecutionMetadata ;", "}", "METHOD_END"], "methodName": ["setOriginExecutionMetadata"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "this . outputFilesSnapshot    =    outputFilesSnapshot ;", "}", "METHOD_END"], "methodName": ["setOutputFilesSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "this . successful    =    successful ;", "}", "METHOD_END"], "methodName": ["setSuccessful"], "fileName": "org.gradle.api.internal.changedetection.state.CurrentTaskExecution"}, {"methodBody": ["METHOD_START", "{", "List < File >    files    =    Lists . newArrayListWithCapacity ( snapshots . size (  )  )  ;", "for    ( String   name    :    snapshots . keySet (  )  )     {", "files . add ( new   File ( name )  )  ;", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["doGetElements"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileCollectionSnapshot"}, {"methodBody": ["METHOD_START", "{", "List < File >    files    =    Lists . newArrayList (  )  ;", "for    ( Map . Entry < String ,    NormalizedFile >    entry    :    snapshots . entrySet (  )  )     {", "if    (  ( entry . getValue (  )  . get (  )  . getType (  )  )     =  =     ( FileType . RegularFile )  )     {", "files . add ( new   File ( entry . getKey (  )  )  )  ;", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["doGetFiles"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileCollectionSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   Maps . transformValues ( snapshots ,    new   com . google . common . base . Function < NormalizedFileSnapshot ,    FileContentSnapshot >  (  )     {", "@ Override", "public   FileContentSnapshot   apply ( NormalizedFileSnapshot   normalizedSnapshot )     {", "return   normalizedSnapshot . getSnapshot (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getContentSnapshots"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileCollectionSnapshot"}, {"methodBody": ["METHOD_START", "{", "String   path    =    internPath ( file )  ;", "FileMetadataSnapshot   stat    =    f . stat ( file )  ;", "switch    ( stat . getType (  )  )     {", "case   Missing    :", "return   new   MissingFileSnapshot ( path ,    new   RelativePath ( true ,    file . getName (  )  )  )  ;", "case   Directory    :", "return   new   DirectoryFileSnapshot ( path ,    new   RelativePath ( false ,    file . getName (  )  )  ,    true )  ;", "case   RegularFile    :", "return   new   RegularFileSnapshot ( path ,    new   RelativePath ( true ,    file . getName (  )  )  ,    true ,    fileSnapshot ( file ,    stat )  )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unrecognized   file   type :     \"     +     ( stat . getType (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateDetails"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   new   FileHashSnapshot ( hasher . hash ( file ,    fileDetails )  ,    fileDetails . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["fileSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   new   FileHashSnapshot ( hasher . hash ( fileDetails )  ,    fileDetails . getLastModified (  )  )  ;", "}", "METHOD_END"], "methodName": ["fileSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "if    ( patterns . isEmpty (  )  )     {", "return   snapshot ;", "}", "final   Spec < FileTreeElement >    spec    =    patterns . getAsSpec (  )  ;", "Collection < FileSnapshot >    filteredDescendants    =    Collections 2  . filter ( snapshot . getDescendants (  )  ,    new   com . google . common . base . Predicate < FileSnapshot >  (  )     {", "@ Override", "public   boolean   apply ( FileSnapshot   descendant )     {", "return   spec . isSatisfiedBy ( new   SnapshotFileTreeElement ( descendant ,    f )  )  ;", "}", "}  )  ;", "return   new   DirectoryTreeDetails ( snapshot . getPath (  )  ,    filteredDescendants )  ;", "}", "METHOD_END"], "methodName": ["filterSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   stringInterner . intern ( file . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["internPath"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "String   path    =    internPath ( directoryTree . getDir (  )  )  ;", "List < FileSnapshot >    elements    =    Lists . newArrayList (  )  ;", "directoryTree . visit ( new    . FileVisitorImpl ( elements )  )  ;", "ImmutableList < FileSnapshot >    descendants    =    ImmutableList . copyOf ( elements )  ;", "DirectoryTreeDetails   snapshot    =    new   DirectoryTreeDetails ( path ,    descendants )  ;", "fileSystemMirror . putDirectory ( snapshot )  ;", "return   snapshot ;", "}", "METHOD_END"], "methodName": ["snapshotAndCache"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "String   path    =    directoryTree . getDir (  )  . getAbsolutePath (  )  ;", "List < FileSnapshot >    elements    =    Lists . newArrayList (  )  ;", "directoryTree . visit ( new    . FileVisitorImpl ( elements )  )  ;", "return   new   DirectoryTreeDetails ( path ,    elements )  ;", "}", "METHOD_END"], "methodName": ["snapshotWithoutCaching"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultFileSystemSnapshotter"}, {"methodBody": ["METHOD_START", "{", "cache . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultTaskHistoryStore"}, {"methodBody": ["METHOD_START", "{", "return   new   PersistentIndexedCacheParameters < String ,    Boolean >  (  \" outputFiles \"  ,    String . class ,    Boolean . class )  . cacheDecorator ( inMemoryCacheDecoratorFactory . decorator (  1  0  0  0  0  0  ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["cacheParameters"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultTaskOutputFilesRepository"}, {"methodBody": ["METHOD_START", "{", "return    ( outputFiles . get ( absoluteFile . getPath (  )  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["containsFilesGeneratedByGradle"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultTaskOutputFilesRepository"}, {"methodBody": ["METHOD_START", "{", "File   currentFile    =    absoluteFile ;", "while    ( currentFile    !  =    null )     {", "if    (  ( o . get ( currentFile . getPath (  )  )  )     =  =     ( Boolean . TRUE )  )     {", "return   true ;", "}", "currentFile    =    currentFile . getParentFile (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isContainedInAnOutput"], "fileName": "org.gradle.api.internal.changedetection.state.DefaultTaskOutputFilesRepository"}, {"methodBody": ["METHOD_START", "{", "return   DirContentSnapshot . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.api.internal.changedetection.state.DirContentSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   snapshot   instanceof   DirContentSnapshot ;", "}", "METHOD_END"], "methodName": ["isContentUpToDate"], "fileName": "org.gradle.api.internal.changedetection.state.DirContentSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.api.internal.changedetection.state.EnumValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.changedetection.state.EnumValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Enum )     {", "Enum <  ?  >    e    =     (  ( Enum <  ?  >  )     ( value )  )  ;", "if    (  ( e . name (  )  . equals ( name )  )     &  &     ( e . getClass (  )  . getName (  )  . equals ( className )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEqualEnum"], "fileName": "org.gradle.api.internal.changedetection.state.EnumValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.internal.changedetection.state.FileCollectionVisitingSnapshotBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( snapshot   instanceof   FileHashSnapshot )  )     {", "return   false ;", "}", "FileHashSnapshot   other    =     (  ( FileHashSnapshot )     ( snapshot )  )  ;", "return   Objects . equal ( hash ,    other . hash )  ;", "}", "METHOD_END"], "methodName": ["isContentUpToDate"], "fileName": "org.gradle.api.internal.changedetection.state.FileHashSnapshot"}, {"methodBody": ["METHOD_START", "{", "try    {", "file    =     . createTemp (  \" this - build \"  ,     \" bin \"  ,    workDir )  ;", "try    {", "return   file . lastModified (  )  ;", "}    finally    {", "file . delete (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException (  \" Could   not   calculate   current   default   file   timestamp .  \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["currentTimestamp"], "fileName": "org.gradle.api.internal.changedetection.state.FileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "return   lastBuildTimestamp ;", "}", "METHOD_END"], "methodName": ["getLastBuildTimestamp"], "fileName": "org.gradle.api.internal.changedetection.state.FileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "return   timestamp    !  =     ( lastBuildTimestamp )  ;", "}", "METHOD_END"], "methodName": ["timestampCanBeUsedToDetectFileChange"], "fileName": "org.gradle.api.internal.changedetection.state.FileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "markerFile . getParentFile (  )  . mkdirs (  )  ;", "try    {", "FileOutputStream   outputStream    =    new   FileOutputStream ( markerFile )  ;", "try    {", "outputStream . write (  0  )  ;", "}    finally    {", "outputStream . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException (  (  \" Could   not   update    \"     +     ( markerFile )  )  ,    e )  ;", "}", "lastBuildTimestamp    =    markerFile . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["updateOnFinishBuild"], "fileName": "org.gradle.api.internal.changedetection.state.FileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "workDir . mkdirs (  )  ;", "if    ( marker . exists (  )  )     {", "lastBuildTimestamp    =    marker . lastModified (  )  ;", "} else    {", "lastBuildTimestamp    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["updateOnStartBuild"], "fileName": "org.gradle.api.internal.changedetection.state.FileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "this . fileHasher    =    fileHasher ;", "}", "METHOD_END"], "methodName": ["attach"], "fileName": "org.gradle.api.internal.changedetection.state.GlobalScopeFileTimeStampInspector"}, {"methodBody": ["METHOD_START", "{", "if    ( ignoreMatchers . isEmpty (  )  )     {", "return   false ;", "}", "for    ( PathMatcher   ignoreSpec    :    ignoreMatchers )     {", "if    ( ignoreSpec . matches ( relativePath . getSegments (  )  ,     0  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldBeIgnored"], "fileName": "org.gradle.api.internal.changedetection.state.IgnoringResourceHasher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( classLoaderHash )     =  =    null )     {", "throw   new   NullPoException (  \" classLoaderHash \"  )  ;", "}", "return   classLoaderHash ;", "}", "METHOD_END"], "methodName": ["getClassLoaderHash"], "fileName": "org.gradle.api.internal.changedetection.state.ImplementationSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   typeName ;", "}", "METHOD_END"], "methodName": ["getTypeName"], "fileName": "org.gradle.api.internal.changedetection.state.ImplementationSnapshot"}, {"methodBody": ["METHOD_START", "{", "return    ( classLoaderHash )     =  =    null ;", "}", "METHOD_END"], "methodName": ["hasUnknownClassLoader"], "fileName": "org.gradle.api.internal.changedetection.state.ImplementationSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )     {", "return   false ;", "}", "that    =     (  (  )     ( o )  )  ;", "if    (  !  ( typeName . equals ( that . typeName )  )  )     {", "return   false ;", "}", "return    ( classLoaderHash )     !  =    null    ?    classLoaderHash . equals ( that . classLoaderHash )     :     ( that . classLoaderHash )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isSameSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ImplementationSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( longLivingProcess )  )     &  &     (  ! cacheInMemoryForShortLivedProcesses )  )     {", ". LOG . debug (  \" Creating   cache    {  }    without   in - memory   store .  \"  ,    cacheId )  ;", "return   backingCache ;", "}", "int   targetSize    =    cacheSizer . scaleCacheSize ( maxEntriesToKeepInMemory )  ;", ". CacheDetails   cacheDetails    =    getCache ( cacheId ,    targetSize )  ;", "return   new   InMemoryDecoratedCache < K ,    V >  ( backingCache ,    cacheDetails . entries ,    cacheId ,    cacheDetails . lockState )  ;", "}", "METHOD_END"], "methodName": ["applyInMemoryCaching"], "fileName": "org.gradle.api.internal.changedetection.state.InMemoryCacheDecoratorFactory"}, {"methodBody": ["METHOD_START", "{", "LoggingEvictionListener   evictionListener    =    new   LoggingEvictionListener ( cacheId ,    maxSize )  ;", "final   CacheBuilder < Object ,    Object >    cacheBuilder    =    CacheBuilder . newBuilder (  )  . maximumSize ( maxSize )  . recordStats (  )  . removalListener ( evictionListener )  ;", "Cache < Object ,    Object >    i    =    cacheBuilder . build (  )  ;", "evictionListener . setCache ( i )  ;", "return   i ;", "}", "METHOD_END"], "methodName": ["createInMemoryCache"], "fileName": "org.gradle.api.internal.changedetection.state.InMemoryCacheDecoratorFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   InMemoryCacheDecoratorFactory . InMemoryCacheDecorator ( maxEntriesToKeepInMemory ,    cacheInMemoryForShortLivedProcesses )  ;", "}", "METHOD_END"], "methodName": ["decorator"], "fileName": "org.gradle.api.internal.changedetection.state.InMemoryCacheDecoratorFactory"}, {"methodBody": ["METHOD_START", "{", "InMemoryCacheDecoratorFactory . CacheDetails   cacheDetails    =    caches . get ( cacheId ,    new   Transformer < InMemoryCacheDecoratorFactory . CacheDetails ,    String >  (  )     {", "@ Override", "public   InMemoryCacheDecoratorFactory . CacheDetails   transform ( String   cacheId )     {", "Cache < Object ,    Object >    entries    =    createInMemoryCache ( cacheId ,    maxSize )  ;", "InMemoryCacheDecoratorFactory . CacheDetails   cacheDetails    =    new   InMemoryCacheDecoratorFactory . CacheDetails ( cacheId ,    maxSize ,    entries ,    new   AtomicReference < State >  ( null )  )  ;", "InMemoryCacheDecoratorFactory . LOG . debug (  \" Creating   in - memory   store   for   cache    {  }     ( max   size :     {  }  )  \"  ,    cacheId ,    maxSize )  ;", "return   cacheDetails ;", "}", "}  )  ;", "if    (  ( cacheDetails . maxEntries )     !  =    maxSize )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Mismatched   in - memory   store   size   for   cache    \"     +    cacheId )     +     \"  ,    expected :     \"  )     +    maxSize )     +     \"  ,    found :     \"  )     +     ( cacheDetails . maxEntries )  )  )  ;", "}", "return   cacheDetails ;", "}", "METHOD_END"], "methodName": ["getCache"], "fileName": "org.gradle.api.internal.changedetection.state.InMemoryCacheDecoratorFactory"}, {"methodBody": ["METHOD_START", "{", "return   absolutePath ;", "}", "METHOD_END"], "methodName": ["getAbsolutePath"], "fileName": "org.gradle.api.internal.changedetection.state.IndexedNormalizedFileSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   index ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "org.gradle.api.internal.changedetection.state.IndexedNormalizedFileSnapshot"}, {"methodBody": ["METHOD_START", "{", "String   absolutePath    =    fileSnapshot . getPath (  )  ;", "FileContentSnapshot   contentSnapshot    =    fileSnapshot . getContent (  )  ;", "if    (  . lineSeparatorsMatch ( absolutePath ,    normalizedPath )  )     {", "return   new   IndexedNormalizedFileSnapshot ( absolutePath ,     (  ( absolutePath . length (  )  )     -     ( normalizedPath . length (  )  )  )  ,    contentSnapshot )  ;", "} else    {", "return   new   DefaultNormalizedFileSnapshot ( stringInterner . intern ( normalizedPath . toString (  )  )  ,    contentSnapshot )  ;", "}", "}", "METHOD_END"], "methodName": ["getRelativeSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.InputPathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   InputPathNormalizationStrategy . getRelativeSnapshot ( fileSnapshot ,    fileSnapshot . getRelativePath (  )  ,    stringInterner )  ;", "}", "METHOD_END"], "methodName": ["getRelativeSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.InputPathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . endsWith ( absolutePath ,    normalizedPath )  ;", "}", "METHOD_END"], "methodName": ["lineSeparatorsMatch"], "fileName": "org.gradle.api.internal.changedetection.state.InputPathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "switch    ( pathSensitivity )     {", "case   ABSOLUTE    :", "return    . ABSOLUTE ;", "case   RELATIVE    :", "return    . RELATIVE ;", "case   NAME _ ONLY    :", "return    . NAME _ ONLY ;", "case   NONE    :", "return    . NONE ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unknown   path   usage :     \"     +    pathSensitivity )  )  ;", "}", "}", "METHOD_END"], "methodName": ["valueOf"], "fileName": "org.gradle.api.internal.changedetection.state.InputPathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "int   size    =    decoder . readSmallInt (  )  ;", "if    ( size    =  =     0  )     {", "return   ImmutableSortedMap . of (  )  ;", "}", "if    ( size    =  =     1  )     {", "return   ImmutableSortedMap . of ( decoder . readString (  )  ,    readSnapshot ( decoder )  )  ;", "}", "Builder < String ,    ValueSnapshot >    builder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "builder . put ( decoder . readString (  )  ,    readSnapshot ( decoder )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.internal.changedetection.state.InputPropertiesSerializer"}, {"methodBody": ["METHOD_START", "{", "int   type    =    decoder . readSmallInt (  )  ;", "int   size ;", "ValueSnapshot [  ]    elements ;", "switch    ( type )     {", "case    . NULL _ SNAPSHOT    :", "return   NullValueSnapshot . INSTANCE ;", "case    . TRUE _ SNAPSHOT    :", "return   BooleanValueSnapshot . TRUE ;", "case    . FALSE _ SNAPSHOT    :", "return   BooleanValueSnapshot . FALSE ;", "case    . STRING _ SNAPSHOT    :", "return   new   StringValueSnapshot ( decoder . readString (  )  )  ;", "case    . INTEGER _ SNAPSHOT    :", "return   new   IntegerValueSnapshot ( decoder . readInt (  )  )  ;", "case    . LONG _ SNAPSHOT    :", "return   new   LongValueSnapshot ( decoder . readLong (  )  )  ;", "case    . SHORT _ SNAPSHOT    :", "return   new   ShortValueSnapshot (  (  ( short )     ( decoder . readInt (  )  )  )  )  ;", "case    . FILE _ SNAPSHOT    :", "return   new   FileValueSnapshot ( decoder . readString (  )  )  ;", "case    . ENUM _ SNAPSHOT    :", "return   new   EnumValueSnapshot ( decoder . readString (  )  ,    decoder . readString (  )  )  ;", "case    . EMPTY _ ARRAY _ SNAPSHOT    :", "return   ArrayValueSnapshot . EMPTY ;", "case    . ARRAY _ SNAPSHOT    :", "size    =    decoder . readSmallInt (  )  ;", "elements    =    new   ValueSnapshot [ size ]  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "elements [ i ]     =    readSnapshot ( decoder )  ;", "}", "return   new   ArrayValueSnapshot ( elements )  ;", "case    . EMPTY _ LIST _ SNAPSHOT    :", "return   ListValueSnapshot . EMPTY ;", "case    . LIST _ SNAPSHOT    :", "size    =    decoder . readSmallInt (  )  ;", "elements    =    new   ValueSnapshot [ size ]  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "elements [ i ]     =    readSnapshot ( decoder )  ;", "}", "return   new   ListValueSnapshot ( elements )  ;", "case    . SET _ SNAPSHOT    :", "size    =    decoder . readSmallInt (  )  ;", "ImmutableSet . Builder < ValueSnapshot >    setBuilder    =    ImmutableSet . builder (  )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "setBuilder . add ( readSnapshot ( decoder )  )  ;", "}", "return   new   SetValueSnapshot ( setBuilder . build (  )  )  ;", "case    . MAP _ SNAPSHOT    :", "size    =    decoder . readSmallInt (  )  ;", "Builder < ValueSnapshot ,    ValueSnapshot >    mapBuilder    =    ImmutableMap . builder (  )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "mapBuilder . put ( readSnapshot ( decoder )  ,    readSnapshot ( decoder )  )  ;", "}", "return   new   MapValueSnapshot ( mapBuilder . build (  )  )  ;", "case    . PROVIDER _ SNAPSHOT    :", "return   new   ProviderSnapshot ( readSnapshot ( decoder )  )  ;", "case    . MANAGED _ NAMED _ SNAPSHOT    :", "return   new   ManagedNamedTypeSnapshot ( decoder . readString (  )  ,    decoder . readString (  )  )  ;", "case    . IMPLEMENTATION _ SNAPSHOT    :", "return   new   ImplementationSnapshot ( decoder . readString (  )  ,     ( decoder . readBoolean (  )     ?    null    :    serializer . read ( decoder )  )  )  ;", "case    . DEFAULT _ SNAPSHOT    :", "return   new   SerializedValueSnapshot (  ( decoder . readBoolean (  )     ?    serializer . read ( decoder )     :    null )  ,    decoder . readBinary (  )  )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Don ' t   know   how   to   deserialize   a   snapshot   with   type   tag    \"     +    type )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.InputPropertiesSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeSmallInt ( properties . size (  )  )  ;", "for    ( Map . Entry < String ,    ValueSnapshot >    entry    :    properties . entrySet (  )  )     {", "encoder . writeString ( entry . getKey (  )  )  ;", "writeEntry ( encoder ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.api.internal.changedetection.state.InputPropertiesSerializer"}, {"methodBody": ["METHOD_START", "{", "if    ( snapshot    =  =     ( NullValueSnapshot . INSTANCE )  )     {", "encoder . writeSmallInt (  . NULL _ SNAPSHOT )  ;", "} else", "if    ( snapshot   instanceof   StringValueSnapshot )     {", "StringValueSnapshot   stringSnapshot    =     (  ( StringValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . STRING _ SNAPSHOT )  ;", "encoder . writeString ( stringSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   ListValueSnapshot )     {", "ListValueSnapshot   listSnapshot    =     (  ( ListValueSnapshot )     ( snapshot )  )  ;", "if    (  ( listSnapshot . getElements (  )  . length )     =  =     0  )     {", "encoder . writeSmallInt (  . EMPTY _ LIST _ SNAPSHOT )  ;", "} else    {", "encoder . writeSmallInt (  . LIST _ SNAPSHOT )  ;", "encoder . writeSmallInt ( listSnapshot . getElements (  )  . length )  ;", "for    ( ValueSnapshot   valueSnapshot    :    listSnapshot . getElements (  )  )     {", "writeEntry ( encoder ,    valueSnapshot )  ;", "}", "}", "} else", "if    ( snapshot    =  =     ( BooleanValueSnapshot . TRUE )  )     {", "encoder . writeSmallInt (  . TRUE _ SNAPSHOT )  ;", "} else", "if    ( snapshot    =  =     ( BooleanValueSnapshot . FALSE )  )     {", "encoder . writeSmallInt (  . FALSE _ SNAPSHOT )  ;", "} else", "if    ( snapshot   instanceof   IntegerValueSnapshot )     {", "IntegerValueSnapshot   integerSnapshot    =     (  ( IntegerValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . INTEGER _ SNAPSHOT )  ;", "encoder . writeInt ( integerSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   LongValueSnapshot )     {", "LongValueSnapshot   longSnapshot    =     (  ( LongValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . LONG _ SNAPSHOT )  ;", "encoder . writeLong ( longSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   ShortValueSnapshot )     {", "ShortValueSnapshot   shortSnapshot    =     (  ( ShortValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . SHORT _ SNAPSHOT )  ;", "encoder . writeInt ( shortSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   FileValueSnapshot )     {", "FileValueSnapshot   fileSnapshot    =     (  ( FileValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . FILE _ SNAPSHOT )  ;", "encoder . writeString ( fileSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   EnumValueSnapshot )     {", "EnumValueSnapshot   enumSnapshot    =     (  ( EnumValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . ENUM _ SNAPSHOT )  ;", "encoder . writeString ( enumSnapshot . getClassName (  )  )  ;", "encoder . writeString ( enumSnapshot . getName (  )  )  ;", "} else", "if    ( snapshot   instanceof   SetValueSnapshot )     {", "SetValueSnapshot   setSnapshot    =     (  ( SetValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . SET _ SNAPSHOT )  ;", "encoder . writeSmallInt ( setSnapshot . getElements (  )  . size (  )  )  ;", "for    ( ValueSnapshot   valueSnapshot    :    setSnapshot . getElements (  )  )     {", "writeEntry ( encoder ,    valueSnapshot )  ;", "}", "} else", "if    ( snapshot   instanceof   ImplementationSnapshot )     {", "ImplementationSnapshot   implementationSnapshot    =     (  ( ImplementationSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . IMPLEMENTATION _ SNAPSHOT )  ;", "encoder . writeString ( implementationSnapshot . getTypeName (  )  )  ;", "encoder . writeBoolean ( implementationSnapshot . hasUnknownClassLoader (  )  )  ;", "if    (  !  ( implementationSnapshot . hasUnknownClassLoader (  )  )  )     {", "serializer . write ( encoder ,    implementationSnapshot . getClassLoaderHash (  )  )  ;", "}", "} else", "if    ( snapshot   instanceof   SerializedValueSnapshot )     {", "SerializedValueSnapshot   valueSnapshot    =     (  ( SerializedValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . DEFAULT _ SNAPSHOT )  ;", "if    (  ( valueSnapshot . getImplementationHash (  )  )     =  =    null )     {", "encoder . writeBoolean ( false )  ;", "} else    {", "encoder . writeBoolean ( true )  ;", "serializer . write ( encoder ,    valueSnapshot . getImplementationHash (  )  )  ;", "}", "encoder . writeBinary ( valueSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   MapValueSnapshot )     {", "MapValueSnapshot   mapSnapshot    =     (  ( MapValueSnapshot )     ( snapshot )  )  ;", "encoder . writeSmallInt (  . MAP _ SNAPSHOT )  ;", "encoder . writeSmallInt ( mapSnapshot . getEntries (  )  . size (  )  )  ;", "for    ( Entry < ValueSnapshot ,    ValueSnapshot >    entry    :    mapSnapshot . getEntries (  )  . entrySet (  )  )     {", "writeEntry ( encoder ,    entry . getKey (  )  )  ;", "writeEntry ( encoder ,    entry . getValue (  )  )  ;", "}", "} else", "if    ( snapshot   instanceof   ArrayValueSnapshot )     {", "ArrayValueSnapshot   arraySnapshot    =     (  ( ArrayValueSnapshot )     ( snapshot )  )  ;", "if    (  ( arraySnapshot . getElements (  )  . length )     =  =     0  )     {", "encoder . writeSmallInt (  . EMPTY _ ARRAY _ SNAPSHOT )  ;", "} else    {", "encoder . writeSmallInt (  . ARRAY _ SNAPSHOT )  ;", "encoder . writeSmallInt ( arraySnapshot . getElements (  )  . length )  ;", "for    ( ValueSnapshot   valueSnapshot    :    arraySnapshot . getElements (  )  )     {", "writeEntry ( encoder ,    valueSnapshot )  ;", "}", "}", "} else", "if    ( snapshot   instanceof   ProviderSnapshot )     {", "encoder . writeSmallInt (  . PROVIDER _ SNAPSHOT )  ;", "ProviderSnapshot   providerSnapshot    =     (  ( ProviderSnapshot )     ( snapshot )  )  ;", "writeEntry ( encoder ,    providerSnapshot . getValue (  )  )  ;", "} else", "if    ( snapshot   instanceof   ManagedNamedTypeSnapshot )     {", "encoder . writeSmallInt (  . MANAGED _ NAMED _ SNAPSHOT )  ;", "ManagedNamedTypeSnapshot   namedSnapshot    =     (  ( ManagedNamedTypeSnapshot )     ( snapshot )  )  ;", "encoder . writeString ( namedSnapshot . getClassName (  )  )  ;", "encoder . writeString ( namedSnapshot . getName (  )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Don ' t   know   how   to   serialize   a   value   of   type    \"     +     ( snapshot . getClass (  )  . getSimpleName (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeEntry"], "fileName": "org.gradle.api.internal.changedetection.state.InputPropertiesSerializer"}, {"methodBody": ["METHOD_START", "{", "return   elements ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "org.gradle.api.internal.changedetection.state.ListValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( value   instanceof   List )  )     {", "return   snapshotter . snapshot ( value )  ;", "}", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "int   pos    =     0  ;", "int   len    =    Math . min ( elements . length ,    list . size (  )  )  ;", "ValueSnapshot   newElement    =    null ;", "for    (  ;    pos    <    len ;    pos +  +  )     {", "ValueSnapshot   element    =    elements [ pos ]  ;", "newElement    =    snapshotter . snapshot ( list . get ( pos )  ,    element )  ;", "if    ( element    !  =    newElement )     {", "break ;", "}", "newElement    =    null ;", "}", "if    (  ( pos    =  =     ( elements . length )  )     &  &     ( pos    =  =     ( list . size (  )  )  )  )     {", "return   this ;", "}", "ValueSnapshot [  ]    newElements    =    new   ValueSnapshot [ list . size (  )  ]  ;", "System . arraycopy ( elements ,     0  ,    newElements ,     0  ,    pos )  ;", "if    ( pos    <     ( list . size (  )  )  )     {", "if    ( newElement    !  =    null )     {", "newElements [ pos ]     =    newElement ;", "pos +  +  ;", "}", "for    ( int   i    =    pos ;    i    <     ( list . size (  )  )  ;    i +  +  )     {", "newElements [ i ]     =    snapshotter . snapshot ( list . get ( i )  )  ;", "}", "}", "return   new    ( newElements )  ;", "}", "METHOD_END"], "methodName": ["processList"], "fileName": "org.gradle.api.internal.changedetection.state.ListValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "this . cache    =    cache ;", "}", "METHOD_END"], "methodName": ["setCache"], "fileName": "org.gradle.api.internal.changedetection.state.LoggingEvictionListener"}, {"methodBody": ["METHOD_START", "{", "return   className ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.api.internal.changedetection.state.ManagedNamedTypeSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.changedetection.state.ManagedNamedTypeSnapshot"}, {"methodBody": ["METHOD_START", "{", "newSnapshots . put ( element . getKey (  )  ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["added"], "fileName": "org.gradle.api.internal.changedetection.state.MapMergeChangeListener"}, {"methodBody": ["METHOD_START", "{", "newSnapshots . put ( element . getKey (  )  ,    element . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["changed"], "fileName": "org.gradle.api.internal.changedetection.state.MapMergeChangeListener"}, {"methodBody": ["METHOD_START", "{", "newSnapshots . remove ( element . getKey (  )  )  ;", "}", "METHOD_END"], "methodName": ["removed"], "fileName": "org.gradle.api.internal.changedetection.state.MapMergeChangeListener"}, {"methodBody": ["METHOD_START", "{", "return   entries ;", "}", "METHOD_END"], "methodName": ["getEntries"], "fileName": "org.gradle.api.internal.changedetection.state.MapValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   MissingFileContentSnapshot . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.api.internal.changedetection.state.MissingFileContentSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   snapshot   instanceof   MissingFileContentSnapshot ;", "}", "METHOD_END"], "methodName": ["isContentUpToDate"], "fileName": "org.gradle.api.internal.changedetection.state.MissingFileContentSnapshot"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    unaccountedForPreviousSnapshots    =    new   LinkedHashSet < String >  ( previous . keySet (  )  )  ;", "final   Iterator < Map . Entry < String ,    NormalizedFileSnapshot >  >    currentEntries    =    current . entrySet (  )  . iterator (  )  ;", "final   List < String >    added    =    new   ArrayList < String >  (  )  ;", "return   new   com . google . common . collect . AbstractIterator < TaskStateC >  (  )     {", "private   Iterator < String >    unaccountedForPreviousSnapshotsIterator ;", "private   Iterator < String >    addedIterator ;", "@ Override", "protected   TaskStateC   computeNext (  )     {", "while    ( currentEntries . hasNext (  )  )     {", "Map . Entry < String ,    NormalizedFileSnapshot >    currentEntry    =    currentEntries . next (  )  ;", "String   currentAbsolutePath    =    currentEntry . getKey (  )  ;", "NormalizedFileSnapshot   currentNormalizedSnapshot    =    currentEntry . getValue (  )  ;", "FileContentSnapshot   currentSnapshot    =    currentNormalizedSnapshot . getSnapshot (  )  ;", "if    ( unaccountedForPreviousSnapshots . remove ( currentAbsolutePath )  )     {", "NormalizedFileSnapshot   previousNormalizedSnapshot    =    previous . get ( currentAbsolutePath )  ;", "FileContentSnapshot   previousSnapshot    =    previousNormalizedSnapshot . getSnapshot (  )  ;", "if    (  !  ( currentSnapshot . isContentUpToDate ( previousSnapshot )  )  )     {", "return   FileC . modified ( currentAbsolutePath ,    fileType ,    previousSnapshot . getType (  )  ,    currentSnapshot . getType (  )  )  ;", "}", "} else    {", "added . add ( currentAbsolutePath )  ;", "}", "}", "if    (  ( unaccountedForPreviousSnapshotsIterator )     =  =    null )     {", "unaccountedForPreviousSnapshotsIterator    =    unaccountedForPreviousSnapshots . iterator (  )  ;", "}", "if    ( unaccountedForPreviousSnapshotsIterator . hasNext (  )  )     {", "String   previousAbsolutePath    =    unaccountedForPreviousSnapshotsIterator . next (  )  ;", "return   FileC . removed ( previousAbsolutePath ,    fileType ,    previous . get ( previousAbsolutePath )  . getSnapshot (  )  . getType (  )  )  ;", "}", "if    ( includeAdded )     {", "if    (  ( addedIterator )     =  =    null )     {", "addedIterator    =    added . iterator (  )  ;", "}", "if    ( addedIterator . hasNext (  )  )     {", "String   currentAbsolutePath    =    addedIterator . next (  )  ;", "return   FileC . added ( currentAbsolutePath ,    fileType ,    current . get ( currentAbsolutePath )  . getSnapshot (  )  . getType (  )  )  ;", "}", "}", "return   endOfData (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["iterateChangesForAbsolutePaths"], "fileName": "org.gradle.api.internal.changedetection.state.OrderInsensitiveTaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "final   ListMultimap < NormalizedFileSnapshot ,    OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    unaccountedForPreviousSnapshots    =    MultimapBuilder . hashKeys ( previous . size (  )  )  . linkedListValues (  )  . build (  )  ;", "for    ( Map . Entry < String ,    NormalizedFileSnapshot >    entry    :    previous . entrySet (  )  )     {", "String   absolutePath    =    entry . getKey (  )  ;", "NormalizedFileSnapshot   previousSnapshot    =    entry . getValue (  )  ;", "unaccountedForPreviousSnapshots . put ( previousSnapshot ,    new   OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath ( absolutePath ,    previousSnapshot . getSnapshot (  )  )  )  ;", "}", "final   Iterator < Map . Entry < String ,    NormalizedFileSnapshot >  >    currentEntries    =    current . entrySet (  )  . iterator (  )  ;", "return   new   com . google . common . collect . AbstractIterator < TaskStateChange >  (  )     {", "private   Iterator < Map . Entry < NormalizedFileSnapshot ,    OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >  >    unaccountedForPreviousSnapshotsIterator ;", "private   final   ListMultimap < String ,    OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    addedFiles    =    MultimapBuilder . hashKeys (  )  . linkedListValues (  )  . build (  )  ;", "private   Iterator < OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    addedFilesIterator ;", "@ Override", "protected   TaskStateChange   computeNext (  )     {", "while    ( currentEntries . hasNext (  )  )     {", "Map . Entry < String ,    NormalizedFileSnapshot >    entry    =    currentEntries . next (  )  ;", "String   currentAbsolutePath    =    entry . getKey (  )  ;", "NormalizedFileSnapshot   currentNormalizedSnapshot    =    entry . getValue (  )  ;", "FileContentSnapshot   currentSnapshot    =    currentNormalizedSnapshot . getSnapshot (  )  ;", "List < OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    previousSnapshotsForNormalizedPath    =    unaccountedForPreviousSnapshots . get ( currentNormalizedSnapshot )  ;", "if    ( previousSnapshotsForNormalizedPath . isEmpty (  )  )     {", "OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath   currentSnapshotWithAbsolutePath    =    new   OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath ( currentAbsolutePath ,    currentSnapshot )  ;", "addedFiles . put ( currentNormalizedSnapshot . getNormalizedPath (  )  ,    currentSnapshotWithAbsolutePath )  ;", "} else    {", "OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath   previousSnapshotWithAbsolutePath    =    previousSnapshotsForNormalizedPath . remove (  0  )  ;", "FileContentSnapshot   previousSnapshot    =    previousSnapshotWithAbsolutePath . getSnapshot (  )  ;", "if    (  !  ( currentSnapshot . isContentUpToDate ( previousSnapshot )  )  )     {", "return   FileChange . modified ( currentAbsolutePath ,    fileType ,    previousSnapshot . getType (  )  ,    currentSnapshot . getType (  )  )  ;", "}", "}", "}", "if    (  ( unaccountedForPreviousSnapshotsIterator )     =  =    null )     {", "if    ( unaccountedForPreviousSnapshots . isEmpty (  )  )     {", "unaccountedForPreviousSnapshotsIterator    =    Iterators . emptyIterator (  )  ;", "} else    {", "List < Map . Entry < NormalizedFileSnapshot ,    OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >  >    entries    =    Lists . newArrayList ( unaccountedForPreviousSnapshots . entries (  )  )  ;", "Collections . sort ( entries ,    OrderInsensitiveTaskFilePropertyCompareStrategy . ENTRY _ COMPARATOR )  ;", "unaccountedForPreviousSnapshotsIterator    =    entries . iterator (  )  ;", "}", "}", "if    ( unaccountedForPreviousSnapshotsIterator . hasNext (  )  )     {", "Map . Entry < NormalizedFileSnapshot ,    OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    unaccountedForPreviousSnapshotEntry    =    unaccountedForPreviousSnapshotsIterator . next (  )  ;", "NormalizedFileSnapshot   previousSnapshot    =    unaccountedForPreviousSnapshotEntry . getKey (  )  ;", "String   normalizedPath    =    previousSnapshot . getNormalizedPath (  )  ;", "List < OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath >    addedFilesForNormalizedPath    =    addedFiles . get ( normalizedPath )  ;", "if    (  !  ( addedFilesForNormalizedPath . isEmpty (  )  )  )     {", "OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath   modifiedSnapshot    =    addedFilesForNormalizedPath . remove (  0  )  ;", "return   FileChange . modified ( modifiedSnapshot . getAbsolutePath (  )  ,    fileType ,    previousSnapshot . getSnapshot (  )  . getType (  )  ,    modifiedSnapshot . getSnapshot (  )  . getType (  )  )  ;", "} else    {", "OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath   removedSnapshot    =    unaccountedForPreviousSnapshotEntry . getValue (  )  ;", "return   FileChange . removed ( removedSnapshot . getAbsolutePath (  )  ,    fileType ,    removedSnapshot . getSnapshot (  )  . getType (  )  )  ;", "}", "}", "if    ( includeAdded )     {", "if    (  ( addedFilesIterator )     =  =    null )     {", "addedFilesIterator    =    addedFiles . values (  )  . iterator (  )  ;", "}", "if    ( addedFilesIterator . hasNext (  )  )     {", "OrderInsensitiveTaskFilePropertyCompareStrategy . IncrementalFileSnapshotWithAbsolutePath   addedFile    =    addedFilesIterator . next (  )  ;", "return   FileChange . added ( addedFile . getAbsolutePath (  )  ,    fileType ,    addedFile . getSnapshot (  )  . getType (  )  )  ;", "}", "}", "return   endOfData (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["iterateChangesForRelativePaths"], "fileName": "org.gradle.api.internal.changedetection.state.OrderInsensitiveTaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "return   OutputPathNormalizationStrategy . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.gradle.api.internal.changedetection.state.OutputPathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   valueSnapshot ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.api.internal.changedetection.state.ProviderSnapshot"}, {"methodBody": ["METHOD_START", "{", "HashCode   resourceHashCacheKey    =    ResourceSnapshotterCacheService . resourceHashCacheKey ( fileSnapshot ,    configurationHash )  ;", "HashCode   resourceHash    =    persistentCache . get ( resourceHashCacheKey )  ;", "if    ( resourceHash    !  =    null )     {", "if    ( resourceHash . equals ( ResourceSnapshotterCacheService . NO _ HASH )  )     {", "return   null ;", "}", "return   resourceHash ;", "}", "resourceHash    =    hasher . hash ( fileSnapshot )  ;", "if    ( resourceHash    !  =    null )     {", "persistentCache . put ( resourceHashCacheKey ,    resourceHash )  ;", "} else    {", "persistentCache . put ( resourceHashCacheKey ,    ResourceSnapshotterCacheService . NO _ HASH )  ;", "}", "return   resourceHash ;", "}", "METHOD_END"], "methodName": ["hashFile"], "fileName": "org.gradle.api.internal.changedetection.state.ResourceSnapshotterCacheService"}, {"methodBody": ["METHOD_START", "{", "BuildCacheHasher   hasher    =    new   DefaultBuildCacheHasher (  )  ;", "hasher . putHash ( configurationHash )  ;", "hasher . putHash ( fil . getContent (  )  . getContentMd 5  (  )  )  ;", "return   hasher . hash (  )  ;", "}", "METHOD_END"], "methodName": ["resourceHashCacheKey"], "fileName": "org.gradle.api.internal.changedetection.state.ResourceSnapshotterCacheService"}, {"methodBody": ["METHOD_START", "{", "return   implementationHash ;", "}", "METHOD_END"], "methodName": ["getImplementationHash"], "fileName": "org.gradle.api.internal.changedetection.state.SerializedValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   serializedValue ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.api.internal.changedetection.state.SerializedValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    ( snapshot   instanceof   SerializedValueSnapshot )     {", "SerializedValueSnapshot   newSnapshot    =     (  ( SerializedValueSnapshot )     ( snapshot )  )  ;", "if    (  !  ( Objects . equal ( implementationHash ,    newSnapshot . implementationHash )  )  )     {", "return   false ;", "}", "if    ( Arrays . equals ( serializedValue ,    newSnapshot . serializedValue )  )     {", "return   true ;", "}", "Object   oldValue    =    populateClass ( value . getClass (  )  )  ;", "if    ( oldValue . equals ( value )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasSameSerializedValue"], "fileName": "org.gradle.api.internal.changedetection.state.SerializedValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "Object   populated ;", "try    {", "populated    =    new   ClassLoaderObjectInputStream ( new   ByteArrayInputStream ( s )  ,    originalClass . getClassLoader (  )  )  . readObject (  )  ;", "}    catch    ( Exception   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "return   populated ;", "}", "METHOD_END"], "methodName": ["populateClass"], "fileName": "org.gradle.api.internal.changedetection.state.SerializedValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "return   elements ;", "}", "METHOD_END"], "methodName": ["getElements"], "fileName": "org.gradle.api.internal.changedetection.state.SetValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "if    ( newSnapshot   instanceof   SetValueSnapshot )     {", "SetValueSnapshot   other    =     (  ( SetValueSnapshot )     ( newSnapshot )  )  ;", "if    ( elements . equals ( other . elements )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isEqualSetValueSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.SetValueSnapshot"}, {"methodBody": ["METHOD_START", "{", "byte   fileSnapshotKind    =    decoder . readByte (  )  ;", "FileContentSnapshot   snapshot ;", "switch    ( fileSnapshotKind )     {", "case    . DIR _ SNAPSHOT    :", "snapshot    =    DirContentSnapshot . getInstance (  )  ;", "break ;", "case    . MISSING _ FILE _ SNAPSHOT    :", "snapshot    =    MissingFileContentSnapshot . getInstance (  )  ;", "break ;", "case    . REGULAR _ FILE _ SNAPSHOT    :", "snapshot    =    new   FileHashSnapshot ( hashCodeSerializer . read ( decoder )  )  ;", "break ;", "default    :", "throw   new   RuntimeException (  \" Unable   to   read   serialized   file   snapshot .    Unrecognized   value   found   in   the   data   stream .  \"  )  ;", "}", "int   normalizedSnapshotKind    =    decoder . readByte (  )  ;", "switch    ( normalizedSnapshotKind )     {", "case    . NO _ NORMALIZATION    :", "return   new   NonNormalizedFileSnapshot ( absolutePath ,    snapshot )  ;", "case    . DEFAULT _ NORMALIZATION    :", "String   normalizedPath    =    stringInterner . intern ( decoder . readString (  )  )  ;", "return   new   DefaultNormalizedFileSnapshot ( normalizedPath ,    snapshot )  ;", "case    . INDEXED _ NORMALIZATION    :", "int   index    =    decoder . readSmallInt (  )  ;", "return   new   IndexedNormalizedFileSnapshot ( absolutePath ,    index ,    snapshot )  ;", "case    . IGNORED _ PATH _ NORMALIZATION    :", "return   new   IgnoredPathFileSnapshot ( snapshot )  ;", "default    :", "throw   new   RuntimeException (  \" Unable   to   read   serialized   file   snapshot .    Unrecognized   value   found   in   the   data   stream .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["readSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.SnapshotMapSerializer"}, {"methodBody": ["METHOD_START", "{", "FileContentSnapshot   snapshot    =    value . getSnapshot (  )  ;", "if    ( snapshot   instanceof   DirContentSnapshot )     {", "encoder . writeByte (  . DIR _ SNAPSHOT )  ;", "} else", "if    ( snapshot   instanceof   MissingFileContentSnapshot )     {", "encoder . writeByte (  . MISSING _ FILE _ SNAPSHOT )  ;", "} else", "if    ( snapshot   instanceof   FileHashSnapshot )     {", "encoder . writeByte (  . REGULAR _ FILE _ SNAPSHOT )  ;", "hashCodeSerializer . write ( encoder ,    snapshot . getContentMd 5  (  )  )  ;", "} else    {", "throw   new   AssertionError (  )  ;", "}", "if    ( value   instanceof   NonNormalizedFileSnapshot )     {", "encoder . writeByte (  . NO _ NORMALIZATION )  ;", "} else", "if    ( value   instanceof   DefaultNormalizedFileSnapshot )     {", "encoder . writeByte (  . DEFAULT _ NORMALIZATION )  ;", "encoder . writeString ( value . getNormalizedPath (  )  )  ;", "} else", "if    ( value   instanceof   IndexedNormalizedFileSnapshot )     {", "encoder . writeByte (  . INDEXED _ NORMALIZATION )  ;", "encoder . writeSmallInt (  (  ( IndexedNormalizedFileSnapshot )     ( value )  )  . getIndex (  )  )  ;", "} else", "if    ( value   instanceof   IgnoredPathFileSnapshot )     {", "encoder . writeByte (  . IGNORED _ PATH _ NORMALIZATION )  ;", "} else    {", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.SnapshotMapSerializer"}, {"methodBody": ["METHOD_START", "{", "boolean   successful    =    decoder . readBoolean (  )  ;", "OriginTaskExecutionMetadata   originExecutionMetadata    =    new   OriginTaskExecutionMetadata ( UniqueId . from ( decoder . readString (  )  )  ,    decoder . readLong (  )  )  ;", "ImmutableSortedMap < String ,    FileCollectionSnapshot >    inputFilesSnapshots    =    readSnapshots ( decoder )  ;", "ImmutableSortedMap < String ,    FileCollectionSnapshot >    outputFilesSnapshots    =    readSnapshots ( decoder )  ;", "FileCollectionSnapshot   discoveredFilesSnapshot    =    fileCollectionSnapshotSerializer . read ( decoder )  ;", "ImplementationSnapshot   taskImplementation    =     . readImplementation ( decoder )  ;", "int   taskActionsCount    =    decoder . readSmallInt (  )  ;", "ImmutableList . Builder < ImplementationSnapshot >    taskActionImplementationsBuilder    =    ImmutableList . builder (  )  ;", "for    ( int   j    =     0  ;    j    <    taskActionsCount ;    j +  +  )     {", "ImplementationSnapshot   actionImpl    =     . readImplementation ( decoder )  ;", "taskActionImplementationsBuilder . add ( actionImpl )  ;", "}", "ImmutableList < ImplementationSnapshot >    taskActionImplementations    =    taskActionImplementationsBuilder . build (  )  ;", "int   cacheableOutputPropertiesCount    =    decoder . readSmallInt (  )  ;", "ImmutableSortedSet . Builder < String >    cacheableOutputPropertiesBuilder    =    ImmutableSortedSet . naturalOrder (  )  ;", "for    ( int   j    =     0  ;    j    <    cacheableOutputPropertiesCount ;    j +  +  )     {", "cacheableOutputPropertiesBuilder . add ( decoder . readString (  )  )  ;", "}", "ImmutableSortedSet < String >    cacheableOutputProperties    =    cacheableOutputPropertiesBuilder . build (  )  ;", "ImmutableSortedMap < String ,    ValueSnapshot >    inputProperties    =    inputPropertiesSerializer . read ( decoder )  ;", "return   new   HistoricalTaskExecution ( taskImplementation ,    taskActionImplementations ,    inputProperties ,    cacheableOutputProperties ,    inputFilesSnapshots ,    discoveredFilesSnapshot ,    outputFilesSnapshots ,    successful ,    originExecutionMetadata )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "String   typeName    =    decoder . readString (  )  ;", "HashCode   classLoaderHash    =     ( decoder . readBoolean (  )  )     ?    HashCode . fromBytes ( decoder . readBinary (  )  )     :    null ;", "return   new   Implementa ( typeName ,    classLoaderHash )  ;", "}", "METHOD_END"], "methodName": ["readImplementation"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "int   count    =    decoder . readSmallInt (  )  ;", "Builder < String ,    FileCollectionSnapshot >    builder    =    ImmutableSortedMap . naturalOrder (  )  ;", "for    ( int   snapshotIdx    =     0  ;    snapshotIdx    <    count ;    snapshotIdx +  +  )     {", "String   property    =    decoder . readString (  )  ;", "FileCollectionSnapshot   snapshot    =    fileCollec . read ( decoder )  ;", "builder . put ( property ,    snapshot )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["readSnapshots"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeBoolean ( execution . isSuccessful (  )  )  ;", "encoder . writeString ( execution . getOriginExecutionMetadata (  )  . getBuildInvocationId (  )  . asString (  )  )  ;", "encoder . writeLong ( execution . getOriginExecutionMetadata (  )  . getExecutionTime (  )  )  ;", "writeSnapshots ( encoder ,    execution . getInputFilesSnapshot (  )  )  ;", "writeSnapshots ( encoder ,    execution . getOutputFilesSnapshot (  )  )  ;", "fileCollectionSnapshotSerializer . write ( encoder ,    execution . getDiscoveredInputFilesSnapshot (  )  )  ;", ". writeImplementation ( encoder ,    execution . getTaskImplementation (  )  )  ;", "encoder . writeSmallInt ( execution . getTaskActionImplementations (  )  . size (  )  )  ;", "for    ( ImplementationSnapshot   actionImpl    :    execution . getTaskActionImplementations (  )  )     {", ". writeImplementation ( encoder ,    actionImpl )  ;", "}", "encoder . writeSmallInt ( execution . getOutputPropertyNamesForCacheKey (  )  . size (  )  )  ;", "for    ( String   outputFile    :    execution . getOutputPropertyNamesForCacheKey (  )  )     {", "encoder . writeString ( outputFile )  ;", "}", "inputPropertiesSerializer . write ( encoder ,    execution . getInputProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeString ( implementation . getTypeName (  )  )  ;", "if    ( implementation . hasUnknownClassLoader (  )  )     {", "encoder . writeBoolean ( false )  ;", "} else    {", "encoder . writeBoolean ( true )  ;", "encoder . writeBinary ( implementation . getClassLoaderHash (  )  . toByteArray (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeImplementation"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "encoder . writeSmallInt ( ids . size (  )  )  ;", "for    ( Map . Entry < String ,    FileCollectionSnapshot >    entry    :    ids . entrySet (  )  )     {", "encoder . writeString ( entry . getKey (  )  )  ;", "fileCollec . write ( encoder ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeSnapshots"], "fileName": "org.gradle.api.internal.changedetection.state.TaskExecutionSnapshotSerializer"}, {"methodBody": ["METHOD_START", "{", "delegate . appendToHasher ( hasher ,    snapshots )  ;", "}", "METHOD_END"], "methodName": ["appendToHasher"], "fileName": "org.gradle.api.internal.changedetection.state.TaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "NormalizedFileSnapshot   normalizedPrevious    =    previousEntry . getValue (  )  ;", "NormalizedFileSnapshot   normalizedCurrent    =    currentEntry . getValue (  )  ;", "if    ( normalizedCurrent . getNormalizedPath (  )  . equals ( normalizedPrevious . getNormalizedPath (  )  )  )     {", "FileContentSnapshot   previousSnapshot    =    normalizedPrevious . getSnapshot (  )  ;", "FileContentSnapshot   currentSnapshot    =    normalizedCurrent . getSnapshot (  )  ;", "if    (  !  ( currentSnapshot . isContentUpToDate ( previousSnapshot )  )  )     {", "String   path    =    currentEntry . getKey (  )  ;", "TaskStateChange       =    FileChange . modified ( path ,    fileType ,    previousSnapshot . getType (  )  ,    currentSnapshot . getType (  )  )  ;", "return   singletonIterator (  )  ;", "} else    {", "return   emptyIterator (  )  ;", "}", "} else    {", "if    ( includeAdded )     {", "String   previousPath    =    previousEntry . getKey (  )  ;", "String   currentPath    =    currentEntry . getKey (  )  ;", "TaskStateChange   remove    =    FileChange . removed ( previousPath ,    fileType ,    normalizedPrevious . getSnapshot (  )  . getType (  )  )  ;", "TaskStateChange   add    =    FileChange . added ( currentPath ,    fileType ,    normalizedCurrent . getSnapshot (  )  . getType (  )  )  ;", "return   Iterators . forArray ( remove ,    add )  ;", "} else    {", "String   path    =    previousEntry . getKey (  )  ;", "TaskStateChange       =    FileChange . removed ( path ,    fileType ,    previousEntry . getValue (  )  . getSnapshot (  )  . getType (  )  )  ;", "return   singletonIterator (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["compareTrivialSnapshotEntries"], "fileName": "org.gradle.api.internal.changedetection.state.TaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "switch    ( current . size (  )  )     {", "case    0     :", "switch    ( previous . size (  )  )     {", "case    0     :", "return   emptyIterator (  )  ;", "case    1     :", "Map . Entry < String ,    NormalizedFileSnapshot >    entry    =    previous . entrySet (  )  . iterator (  )  . next (  )  ;", "TaskStateChange   change    =    FileChange . removed ( entry . getKey (  )  ,    fileType ,    entry . getValue (  )  . getSnapshot (  )  . getType (  )  )  ;", "return   singletonIterator ( change )  ;", "default    :", "return   null ;", "}", "case    1     :", "switch    ( previous . size (  )  )     {", "case    0     :", "if    ( includeAdded )     {", "Map . Entry < String ,    NormalizedFileSnapshot >    entry    =    current . entrySet (  )  . iterator (  )  . next (  )  ;", "TaskStateChange   change    =    FileChange . added ( entry . getKey (  )  ,    fileType ,    entry . getValue (  )  . getSnapshot (  )  . getType (  )  )  ;", "return   singletonIterator ( change )  ;", "} else    {", "return   emptyIterator (  )  ;", "}", "case    1     :", "Map . Entry < String ,    NormalizedFileSnapshot >    previousEntry    =    previous . entrySet (  )  . iterator (  )  . next (  )  ;", "Map . Entry < String ,    NormalizedFileSnapshot >    currentEntry    =    current . entrySet (  )  . iterator (  )  . next (  )  ;", "return    . compareTrivialSnapshotEntries ( currentEntry ,    previousEntry ,    fileType ,    includeAdded )  ;", "default    :", "return   null ;", "}", "default    :", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["compareTrivialSnapshots"], "fileName": "org.gradle.api.internal.changedetection.state.TaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "Iterator < TaskStateChange >    trivialResult    =    TaskFilePropertyCompareStrategy . compareTrivialSnapshots ( current ,    previous ,    fileType ,    includeAdded )  ;", "if    ( trivialResult    !  =    null )     {", "return   trivialResult ;", "}", "return   delegate . iterateContentChangesSince ( current ,    previous ,    fileType ,    pathIsAbsolute ,    includeAdded )  ;", "}", "METHOD_END"], "methodName": ["iterateContentChangesSince"], "fileName": "org.gradle.api.internal.changedetection.state.TaskFilePropertyCompareStrategy"}, {"methodBody": ["METHOD_START", "{", "return   snapshotter . snapshot ( value )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotStrategy"}, {"methodBody": ["METHOD_START", "{", "ValueSnapshot   possible    =    processValue ( value ,    isolatedSnapshotStrategy )  ;", "if    ( possible   instanceof   Isolatable )     {", "return   possible ;", "} else    {", "return   wrap ( value ,    possible )  ;", "}", "}", "METHOD_END"], "methodName": ["isolatableSnapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   Null . INSTANCE ;", "}", "if    ( value   instanceof   String )     {", "return   new   String (  (  ( String )     ( value )  )  )  ;", "}", "if    ( value   instanceof   Boolean )     {", "return   value . equals ( Boolean . TRUE )     ?    Boolean . TRUE    :    Boolean . FALSE ;", "}", "if    ( value   instanceof   List )     {", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( value )  )  ;", "if    (  ( list . size (  )  )     =  =     0  )     {", "return   List . EMPTY ;", "}", "[  ]    elements    =    new    [ list . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( list . size (  )  )  ;    i +  +  )     {", "Object   element    =    list . get ( i )  ;", "elements [ i ]     =    strategy . snapshot ( element )  ;", "}", "return   new   List ( elements )  ;", "}", "if    ( value   instanceof   Enum )     {", "return   new   Enum (  (  ( Enum )     ( value )  )  )  ;", "}", "if    ( value   instanceof   Class <  ?  >  )     {", "Class <  ?  >    implementation    =     (  ( Class <  ?  >  )     ( value )  )  ;", "return   new   ImplementationSnapshot ( implementation . getName (  )  ,    classLoaderHasher . getClassLoaderHash ( implementation . getClassLoader (  )  )  )  ;", "}", "if    ( value . getClass (  )  . equals ( File . class )  )     {", "return   new   File (  (  ( File )     ( value )  )  )  ;", "}", "if    ( value   instanceof   Number )     {", "if    ( value   instanceof   Integer )     {", "return   new   Integer (  (  ( Integer )     ( value )  )  )  ;", "}", "if    ( value   instanceof   Long )     {", "return   new   Long (  (  ( Long )     ( value )  )  )  ;", "}", "if    ( value   instanceof   Short )     {", "return   new   Short (  (  ( Short )     ( value )  )  )  ;", "}", "}", "if    ( value   instanceof   Set )     {", "Set <  ?  >    set    =     (  ( Set <  ?  >  )     ( value )  )  ;", "ImmutableSet . Builder <  >    builder    =    ImmutableSet . builder (  )  ;", "for    ( Object   element    :    set )     {", "builder . add ( strategy . snapshot ( element )  )  ;", "}", "return   new   Set ( builder . build (  )  )  ;", "}", "if    ( value   instanceof   Map )     {", "Map <  ?  ,     ?  >    map    =     (  ( Map <  ?  ,     ?  >  )     ( value )  )  ;", "Builder <  ,     >    builder    =    new   Builder <  ,     >  (  )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    map . entrySet (  )  )     {", "builder . put ( strategy . snapshot ( entry . getKey (  )  )  ,    strategy . snapshot ( entry . getValue (  )  )  )  ;", "}", "return   new   Map ( builder . build (  )  )  ;", "}", "if    ( value . getClass (  )  . isArray (  )  )     {", "int   length    =    Array . getLength ( value )  ;", "if    ( length    =  =     0  )     {", "return   Array . EMPTY ;", "}", "[  ]    elements    =    new    [ length ]  ;", "for    ( int   i    =     0  ;    i    <    length ;    i +  +  )     {", "Object   element    =    Array . get ( value ,    i )  ;", "elements [ i ]     =    strategy . snapshot ( element )  ;", "}", "return   new   Array ( elements )  ;", "}", "if    ( value   instanceof   Provider )     {", "Provider <  ?  >    provider    =     (  ( Provider )     ( value )  )  ;", "valueSnapshot    =    strategy . snapshot ( provider . get (  )  )  ;", "return   new   ProviderSnapshot ( valueSnapshot )  ;", "}", "if    ( value   instanceof   NamedObjectInstantiator . Managed )     {", "return   new   ManagedNamedTypeSnapshot (  (  ( Named )     ( value )  )  )  ;", "}", "return   serialize ( value )  ;", "}", "METHOD_END"], "methodName": ["processValue"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   outputStream ;", "try    {", "outputStream    =    new   ByteArrayOutputStream (  )  ;", "ObjectOutputStream   objectStr    =    new   ObjectOutputStream ( outputStream )  ;", "objectStr . writeObject ( value )  ;", "objectStr . flush (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "return   new   Serialized ( classLoaderHasher . getClassLoaderHash ( value . getClass (  )  . getClassLoader (  )  )  ,    outputStream . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   processValue ( value ,    valueSnapshotStrategy )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "return   candidate . snapshot ( value ,    this )  ;", "}", "METHOD_END"], "methodName": ["snapshot"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "if    ( possible   instanceof   EnumValueSnapshot )     {", "return   new   IsolatableEnumValueSnapshot (  (  ( Enum )     ( value )  )  )  ;", "}", "if    ( possible   instanceof   SerializedValueSnapshot )     {", "SerializedValueSnapshot   original    =     (  ( SerializedValueSnapshot )     ( possible )  )  ;", "return   new   IsolatableSerializedValueSnapshot ( original . getImplementationHash (  )  ,    original . getValue (  )  ,    value . getClass (  )  )  ;", "}", "if    ( possible   instanceof   ManagedNamedTypeSnapshot )     {", "return   new   IsolatedManagedNamedTypeSnapshot (  (  ( Named )     ( value )  )  ,    namedObjectInstantiator )  ;", "}", "throw   new   IsolationException ( value )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.api.internal.changedetection.state.ValueSnapshotter"}, {"methodBody": ["METHOD_START", "{", "try    {", "Class <  ?  >    groovySystem ;", "try    {", "groovySystem    =    classLoader . loadClass (  \" groovy . lang . GroovySystem \"  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "return    . NOT _ BROKEN ;", "}", "if    (  ( groovySystem . getClassLoader (  )  )     !  =    classLoader )     {", "return    . NOT _ BROKEN ;", "}", "String   versionString ;", "try    {", "Method   getVersion    =    groovySystem . getDeclaredMethod (  \" getVersion \"  )  ;", "versionString    =     (  ( String )     ( getVersion . invoke ( null )  )  )  ;", "}    catch    ( NoSuchMethodException   ex )     {", "return    . NOT _ BROKEN ;", "}", "VersionNumber   groovyVersion    =    VersionNumber . parse ( versionString )  ;", "boolean   isFaultyGroovy    =     (  ( groovyVersion . getMajor (  )  )     =  =     2  )     &  &     (  ( groovyVersion . getMinor (  )  )     =  =     4  )  ;", "return   isFaultyGroovy    ?    new   LeakyOnJava 7 GroovySystemLoader ( classLoader )     :     . NOT _ BROKEN ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException (  (  \" Could   not   inspect   the   Groovy   system   for   ClassLoader    \"     +    classLoader )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["forClassLoader"], "fileName": "org.gradle.api.internal.classloading.GroovySystemLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Iterator )     ( globalClassSetIteratorMethod . invoke ( globalClassSetItems )  )  )  ;", "}", "METHOD_END"], "methodName": ["globalClassSetIterator"], "fileName": "org.gradle.api.internal.classloading.LeakyOnJava7GroovySystemLoader"}, {"methodBody": ["METHOD_START", "{", "File   jarFile    =    ars . get ( name )  ;", "if    ( jarFile    !  =    null )     {", "return   jarFile ;", "}", "if    (  ( gradleInstallation )     =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   find   JAR    '  % s '    required   by   module    '  % s '    using    \"  ,    name ,    module )  )  ;", "}", "for    ( File   libDir    :    gradleInstallation . getLibDirs (  )  )     {", "jarFile    =    new   File ( libDir ,    name )  ;", "if    ( jarFile . isFile (  )  )     {", "return   jarFile ;", "}", "}", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   find   JAR    '  % s '    required   by   module    '  % s '    using   or   distribution   directory    '  % s '  \"  ,    name ,    module ,    gradleInstallation . getGradleHome (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["findDependencyJar"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < File >    runtimeC =    new   LinkedHashSet < File >  (  )  ;", "for    ( String   jarName    :    jarNames )     {", "runtimeCadd ( findDependencyJar ( moduleName ,    jarName )  )  ;", "}", "return   runtimeC", "}", "METHOD_END"], "methodName": ["findDependencyJars"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "List < String >    suffixes    =    new   ArrayList < String >  (  )  ;", "Matcher   matcher    =    Pattern . compile (  \" gradle -  (  .  +  )  \"  )  . matcher ( name )  ;", "matcher . matches (  )  ;", "String   projectDirName    =    matcher . group (  1  )  ;", "String   projectName    =    toCamelCase ( projectDirName )  ;", "suffixes . add (  (  \"  / out / production /  \"     +    projectName )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / bin \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / src / main / resources \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / build / classes / main \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / build / resources / main \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / build / generated - resources / main \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "suffixes . add (  (  (  \"  /  \"     +    projectDirName )     +     \"  / build / generated - resources / test \"  )  . replace (  '  /  '  ,    File . separatorChar )  )  ;", "for    ( File   file    :     )     {", "if    ( file . isDirectory (  )  )     {", "for    ( String   suffix    :    suffixes )     {", "if    ( file . getAbsolutePath (  )  . endsWith ( suffix )  )     {", "implementationClasspath . add ( file )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["findImplementationClasspath"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Pattern   pattern    =    Pattern . compile (  (  ( Pattern . quote ( name )  )     +     \"  -  \\  \\ d .  +  \\  \\  . jar \"  )  )  ;", "if    (  ( gradleInstallation )     !  =    null )     {", "for    ( File   libDir    :    gradleInstallation . getLibDirs (  )  )     {", "for    ( File   file    :    libDir . listFiles (  )  )     {", "if    ( pattern . matcher ( file . getName (  )  )  . matches (  )  )     {", "return   file ;", "}", "}", "}", "}", "for    ( File   file    :     )     {", "if    ( pattern . matcher ( file . getName (  )  )  . matches (  )  )     {", "return   file ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findJar"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "File   externalJar    =    findJar ( name )  ;", "if    ( externalJar    =  =    null )     {", "throw   new   UnknownModuleException ( String . format (  \" Cannot   locate   JAR   for   module    '  % s '    in   distribution   directory    '  % s '  .  \"  ,    name ,    gradleInstallation . getGradleHome (  )  )  )  ;", "}", "return   new    . DefaultModule ( name ,    Collections . singleton ( externalJar )  ,    Collections .  < File > emptySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getExternalModule"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Module   module    =    modules . get ( name )  ;", "if    ( module    =  =    null )     {", "module    =    loadModule ( name )  ;", "modules . put ( name ,    module )  ;", "}", "return   module ;", "}", "METHOD_END"], "methodName": ["getModule"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < Module >    modules    =    new   LinkedHashSet < Module >  (  )  ;", "for    ( String   project    :    projectNames )     {", "modules . add ( ge ( project )  )  ;", "}", "return   modules ;", "}", "METHOD_END"], "methodName": ["getModules"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Module   module    =    loadOptionalModule ( moduleName )  ;", "if    ( module    !  =    null )     {", "return   module ;", "}", "if    (  ( gradleInstallation )     =  =    null )     {", "throw   new   UnknownModuleException ( String . format (  \" Cannot   locate   manifest   for   module    '  % s '    in    :     % s .  \"  ,    moduleName ,     )  )  ;", "}", "throw   new   UnknownModuleException ( String . format (  \" Cannot   locate   JAR   for   module    '  % s '    in   distribution   directory    '  % s '  .  \"  ,    moduleName ,    gradleInstallation . getGradleHome (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["loadModule"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "try    {", "ZipFile   zipFile    =    new   ZipFile ( jarFile )  ;", "try    {", "final   String   entryName    =    name    +     \"  - properties \"  ;", "ZipEntry   entry    =    zipFile . getEntry ( entryName )  ;", "if    ( entry    =  =    null )     {", "throw   new   IllegalStateException (  (  (  (  \" Did   not   find    \"     +    entryName )     +     \"    in    \"  )     +     ( jarFile . getAbsolutePath (  )  )  )  )  ;", "}", "return   GUtil . loadProperties ( zipFile . getInputStream ( entry )  )  ;", "}    finally    {", "zipFile . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( String . format (  \" Could   not   load   properties   for   module    '  % s '    from    % s \"  ,    name ,    jarFile )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["loadModuleProperties"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "File   jarFile    =    findJar ( moduleName )  ;", "if    ( jarFile    !  =    null )     {", "Set < File >    implementationClasspath    =    new   LinkedHashSet < File >  (  )  ;", "implementationClasspath . add ( jarFile )  ;", "Properties   properties    =    loadModuleProperties ( moduleName ,    jarFile )  ;", "return   module ( moduleName ,    properties ,    implementationClasspath )  ;", "}", "String   resourceName    =    moduleName    +     \"  - properties \"  ;", "Set < File >    implementationClasspath    =    new   LinkedHashSet < File >  (  )  ;", "findImplementationClasspath ( moduleName ,    implementationClasspath )  ;", "for    ( File   file    :    implementationClasspath )     {", "if    ( file . isDirectory (  )  )     {", "File   propertiesFile    =    new   File ( file ,    resourceName )  ;", "if    ( propertiesFile . isFile (  )  )     {", "Properties   properties    =    GUtil . loadProperties ( propertiesFile )  ;", "return   module ( moduleName ,    properties ,    implementationClasspath )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["loadOptionalModule"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "String [  ]    runtimeJarNames    =    split ( properties . getProperty (  \" runtime \"  )  )  ;", "Set < File >    runtimeClasspath    =    findDependencyJars ( moduleName ,    runtimeJarNames )  ;", "String [  ]    projects    =    split ( properties . getProperty (  \" projects \"  )  )  ;", "String [  ]    optionalProjects    =    split ( properties . getProperty (  \" optional \"  )  )  ;", "return   new    . DefaultModule ( moduleName ,    implementationClasspath ,    runtimeClasspath ,    projects ,    optionalProjects )  ;", "}", "METHOD_END"], "methodName": ["module"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "return   new   String [  0  ]  ;", "}", "value    =    value . trim (  )  ;", "if    (  ( value . length (  )  )     =  =     0  )     {", "return   new   String [  0  ]  ;", "}", "return   value . split (  \"  ,  \"  )  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   result    =    new   StringBuffer (  )  ;", "Matcher   matcher    =    Pat . compile (  \"  -  (  [  ^  -  ]  )  \"  )  . matcher ( name )  ;", "while    ( matcher . find (  )  )     {", "matcher . appendReplacement ( result ,     \"  \"  )  ;", "result . append ( matcher . group (  1  )  . toUpperCase (  )  )  ;", "}", "matcher . appendTail ( result )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toCamelCase"], "fileName": "org.gradle.api.internal.classpath.DefaultModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < Module >    modules    =    new   LinkedHashSet < Module >  (  )  ;", "for    ( String   pluginModule    :    properties . getProperty (  \" plugins \"  )  . split (  \"  ,  \"  )  )     {", "try    {", "modules . add ( moduleRegistry . getModule ( pluginModule )  )  ;", "}    catch    ( UnknownModuleException   e )     {", ". LOGGER . debug (  \" Cannot   find   module   for   plugin    {  }  .    Ignoring .  \"  ,    pluginModule )  ;", "}", "}", "return   modules ;", "}", "METHOD_END"], "methodName": ["loadModules"], "fileName": "org.gradle.api.internal.classpath.DefaultPluginModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . loadProperties ( getClass (  )  . getResource ( resource )  )  ;", "}", "METHOD_END"], "methodName": ["loadPluginProperties"], "fileName": "org.gradle.api.internal.classpath.DefaultPluginModuleRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( classpathFile . exists (  )  )     &  &     (  !  ( classpathFiles . contains ( classpathFile )  )  )  )     {", "classpathFiles . add ( classpathFile )  ;", ". addManifestClasspathFiles ( classpathFile ,    classpathFiles )  ;", "}", "}", "METHOD_END"], "methodName": ["addClasspathFile"], "fileName": "org.gradle.api.internal.classpath.EffectiveClassPath"}, {"methodBody": ["METHOD_START", "{", "List < URI >    classpathUris    =    ManifestUtil . parseManifestClasspath ( classpathFile )  ;", "for    ( URI   classpathUri    :    classpathUris )     {", ". addClasspathFile ( new   File ( classpathUri )  ,    classpathFiles )  ;", "}", "}", "METHOD_END"], "methodName": ["addManifestClasspathFiles"], "fileName": "org.gradle.api.internal.classpath.EffectiveClassPath"}, {"methodBody": ["METHOD_START", "{", "List < URL >    rawClasspath    =    ClasspathUtil . getClasspath ( classLoader )  . getAsURLs (  )  ;", "List < File >    classpathFiles    =    new   ArrayList < File >  (  )  ;", "for    ( URL   url    :    rawClasspath )     {", "if    ( url . getProtocol (  )  . equals (  \" file \"  )  )     {", "try    {", "File   classpathFile    =    new   File ( url . toURI (  )  )  ;", ". addClasspathFile ( classpathFile ,    classpathFiles )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}", "if    ( classLoader    =  =     ( ClassLoader . getSystemClassLoader (  )  )  )     {", "for    ( String   value    :    System . getProperty (  \" path \"  )  . split ( File . pathSeparator )  )     {", ". addClasspathFile ( new   File ( value )  ,    classpathFiles )  ;", "}", "}", "return   classpathFiles ;", "}", "METHOD_END"], "methodName": ["findAvailableClasspathFiles"], "fileName": "org.gradle.api.internal.classpath.EffectiveClassPath"}, {"methodBody": ["METHOD_START", "{", "URI   jarFileUri    =    jarFile . getParentFile (  )  . toURI (  )  ;", "URI   fileUri    =    file . toURI (  )  ;", "URI   relativeUri    =    jarFileUri . relativize ( fileUri )  ;", "return   relativeUri . getRawPath (  )  ;", "}", "METHOD_END"], "methodName": ["constructRelativeClasspathUri"], "fileName": "org.gradle.api.internal.classpath.ManifestUtil"}, {"methodBody": ["METHOD_START", "{", "List < String >    paths    =    new   ArrayList < String >  ( classpath . size (  )  )  ;", "for    ( File   file    :    classpath )     {", "String   path    =     . constructRelativeClasspathUri ( jarFile ,    file )  ;", "paths . add ( path )  ;", "}", "return   CollectionUtils . join (  \"     \"  ,    paths )  ;", "}", "METHOD_END"], "methodName": ["createManifestClasspath"], "fileName": "org.gradle.api.internal.classpath.ManifestUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( possibleJarFile . exists (  )  )  )     |  |     (  !  ( possibleJarFile . isFile (  )  )  )  )     {", "return   null ;", "}", "JarFile   jarFile ;", "try    {", "jarFile    =    new   JarFile ( possibleJarFile )  ;", "}    catch    ( ZipException   e )     {", "return   null ;", "}", "try    {", "return   jarFile . get (  )  ;", "}    finally    {", "jarFile . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["findManifest"], "fileName": "org.gradle.api.internal.classpath.ManifestUtil"}, {"methodBody": ["METHOD_START", "{", "List < URI >    manifestClasspath    =    new   ArrayList < URI >  (  )  ;", "for    ( String   value    :     . readManifestClasspathString ( jarFile )  )     {", "try    {", "URI   uri    =    new   URI ( value )  ;", "uri    =    jarFile . toURI (  )  . resolve ( uri )  ;", "manifestClasspath . add ( uri )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "return   manifestClasspath ;", "}", "METHOD_END"], "methodName": ["parseManifestClasspath"], "fileName": "org.gradle.api.internal.classpath.ManifestUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "Manifest   manifest    =     . findManifest ( classpathFile )  ;", "if    ( manifest    =  =    null )     {", "return    . EMPTY ;", "}", "String   classpathEntry    =    manifest . getMainAttributes (  )  . getValue (  \" Class - Path \"  )  ;", "if    (  ( classpathEntry    =  =    null )     |  |     (  ( classpathEntry . trim (  )  . length (  )  )     =  =     0  )  )     {", "return    . EMPTY ;", "}", "return   classpathEntry . split (  \"     \"  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readManifestClasspathString"], "fileName": "org.gradle.api.internal.classpath.ManifestUtil"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( enumType )  . noImplicitConverters (  )  . fromCharSequence ( new   EnumFromCharSequenceNotationParser < T >  ( enumType )  )  . toComposite (  )  . parseNotation ( charSequence )  ;", "}", "METHOD_END"], "methodName": ["toEnumValue"], "fileName": "org.gradle.api.internal.coerce.StringToEnumTransformer"}, {"methodBody": ["METHOD_START", "{", "return   addActions ;", "}", "METHOD_END"], "methodName": ["getAddAction"], "fileName": "org.gradle.api.internal.collections.BroadcastingCollectionEventRegister"}, {"methodBody": ["METHOD_START", "{", "return   removeActions ;", "}", "METHOD_END"], "methodName": ["getRemoveAction"], "fileName": "org.gradle.api.internal.collections.BroadcastingCollectionEventRegister"}, {"methodBody": ["METHOD_START", "{", "if    ( baseTypeSubscribed )     {", "return ;", "}", "if    ( type . equals ( baseType )  )     {", "baseTypeSubscribed    =    true ;", "subscribedTypes    =    null ;", "} else    {", "if    (  ( subscribedTypes )     =  =    null )     {", "subscribedTypes    =    new   HashSet < Class <  ?  >  >  (  )  ;", "}", "subscribedTypes . add ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["subscribe"], "fileName": "org.gradle.api.internal.collections.BroadcastingCollectionEventRegister"}, {"methodBody": ["METHOD_START", "{", "return   new   CollectionFilter < S >  ( other . type ,    Specs . intersect ( spec ,    other . spec )  )  ;", "}", "METHOD_END"], "methodName": ["and"], "fileName": "org.gradle.api.internal.collections.CollectionFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( type . isInstance ( object )  )  )     {", "return   null ;", "}", "T   t    =    type . cast ( object )  ;", "if    ( spec . isSatisfiedBy ( t )  )     {", "return   t ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.api.internal.collections.CollectionFilter"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.collections.CollectionFilter"}, {"methodBody": ["METHOD_START", "{", "return    ( filter ( element )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isSatisfiedBy"], "fileName": "org.gradle.api.internal.collections.CollectionFilter"}, {"methodBody": ["METHOD_START", "{", "return    ( filter . filter ( o )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.gradle.api.internal.collections.FilteredCollection"}, {"methodBody": ["METHOD_START", "{", "return    (  \"  '  \"     +     ( GUtil . toWords ( name (  )  )  )  )     +     \"  '    artifacts \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.api.internal.component.ArtifactType"}, {"methodBody": ["METHOD_START", "{", "return   mainComponent ;", "}", "METHOD_END"], "methodName": ["getMainComponent"], "fileName": "org.gradle.api.internal.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "this . mainComponent    =    mainComponent ;", "}", "METHOD_END"], "methodName": ["setMainComponent"], "fileName": "org.gradle.api.internal.component.ComponentRegistry"}, {"methodBody": ["METHOD_START", "{", "ComponentTypeRegistration   registration    =    componentRegistrations . get ( componentType )  ;", "if    ( registration    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Not   a   registered   component   type :     % s .  \"  ,    componentType . getName (  )  )  )  ;", "}", "return   registration ;", "}", "METHOD_END"], "methodName": ["getComponentRegistration"], "fileName": "org.gradle.api.internal.component.DefaultComponentTypeRegistry"}, {"methodBody": ["METHOD_START", "{", "ComponentTypeRegistration   registration    =    componentRegistrations . get ( componentType )  ;", "if    ( registration    =  =    null )     {", "registration    =    newyation ( componentType )  ;", "componentRegistrations . put ( componentType ,    registration )  ;", "}", "return   registration ;", "}", "METHOD_END"], "methodName": ["maybeRegisterComponentType"], "fileName": "org.gradle.api.internal.component.DefaultComponentTypeRegistry"}, {"methodBody": ["METHOD_START", "{", "List < String >    basePath    =    Arrays . asList ( StringUtils . split ( getBaseDir (  )  . getAbsolutePath (  )  ,     (  \"  /  \"     +     ( File . separator )  )  )  )  ;", "File   targetFile    =    resolve ( path )  ;", "List < String >    targetPath    =    new   ArrayList < String >  ( Arrays . asList ( StringUtils . split ( targetFile . getAbsolutePath (  )  ,     (  \"  /  \"     +     ( File . separator )  )  )  )  )  ;", "int   maxDepth    =    Math . min ( basePath . size (  )  ,    targetPath . size (  )  )  ;", "int   prefixLen    =     0  ;", "while    (  ( prefixLen    <    maxDepth )     &  &     ( basePath . get ( prefixLen )  . equals ( targetPath . get ( prefixLen )  )  )  )     {", "prefixLen +  +  ;", "}", "basePath    =    basePath . subList ( prefixLen ,    basePath . size (  )  )  ;", "targetPath    =    targetPath . subList ( prefixLen ,    targetPath . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( basePath . size (  )  )  ;    i +  +  )     {", "targetPath . add (  0  ,     \"  .  .  \"  )  ;", "}", "if    ( targetPath . isEmpty (  )  )     {", "return    \"  .  \"  ;", "}", "return   CollectionUtils . join ( File . separator ,    targetPath )  ;", "}", "METHOD_END"], "methodName": ["resolveAsRelativePath"], "fileName": "org.gradle.api.internal.file.AbstractBaseDirFileResolver"}, {"methodBody": ["METHOD_START", "{", "new   AntFileSetBuilder ( getAsFileTrees (  )  )  . addToAntBuilder ( builder ,    nodeName )  ;", "}", "METHOD_END"], "methodName": ["addAsFileSet"], "fileName": "org.gradle.api.internal.file.AbstractFileCollection"}, {"methodBody": ["METHOD_START", "{", "new   AntFileCollectionMatchingTaskBuilder ( getAsFileTrees (  )  )  . addToAntBuilder ( builder ,    nodeName )  ;", "}", "METHOD_END"], "methodName": ["addAsMatchingTask"], "fileName": "org.gradle.api.internal.file.AbstractFileCollection"}, {"methodBody": ["METHOD_START", "{", "new   AntFileCollectionBuilder ( this )  . addToAntBuilder ( builder ,    nodeName )  ;", "}", "METHOD_END"], "methodName": ["addAsResourceCollection"], "fileName": "org.gradle.api.internal.file.AbstractFileCollection"}, {"methodBody": ["METHOD_START", "{", "List < DirectoryFileTree >    rees    =    new   ArrayList < DirectoryFileTree >  (  )  ;", "for    ( File    :    this )     {", "if    ( isFile (  )  )     {", "rees . add ( new   FileBackedDirectoryFileTree (  )  ;", "}", "}", "return   rees ;", "}", "METHOD_END"], "methodName": ["getAsFileTrees"], "fileName": "org.gradle.api.internal.file.AbstractFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . capitalize ( getDisplayName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCapDisplayName"], "fileName": "org.gradle.api.internal.file.AbstractFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   new   NotationParser < Object ,    File >  (  )     {", "public   File   parseNotation ( Object   notation )    throws   UnsupportedNotationException    {", "return   resolve ( notation ,    NONE )  ;", "}", "@ Override", "public   void   describe ( DiagnosticsVisitor   visitor )     {", "visitor . candidate (  \" Anything   that   can   be   converted   to   a   file ,    as   per   Project . file (  )  \"  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["asNotationParser"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCompositeFileTree ( CollectionUtils . checkedCast ( FileTreeInternal . class ,    fileTrees )  )  ;", "}", "METHOD_END"], "methodName": ["compositeFileTree"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "Object   object    =    DeferredUtil . unpack ( path )  ;", "if    ( object    =  =    null )     {", "return   null ;", "}", "Object   converted    =    otationParser . parseNotation ( object )  ;", "if    ( converted   instanceof   File )     {", "return    (  ( File )     ( converted )  )  ;", "}", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   convert   URL    '  % s '    to   a    \"  ,    converted )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToFile"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "Object   object    =    DeferredUtil . unpack ( path )  ;", "Object   converted    =    fileNotationParser . parseNotation ( object )  ;", "if    ( converted   instanceof   File )     {", "return   r ( converted )  . toURI (  )  ;", "}", "return    (  ( URI )     ( converted )  )  ;", "}", "METHOD_END"], "methodName": ["convertObjectToURI"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   fileSystem ;", "}", "METHOD_END"], "methodName": ["getFileSystem"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   resolve ( path ,    NONE )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "File   file    =    doResolve ( path )  ;", "file    =    FileUtils . normalize ( file )  ;", "validate ( file ,    validation )  ;", "return   file ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( paths . length )     =  =     1  )     &  &     (  ( paths [  0  ]  )    instanceof   FileCollection )  )     {", "return   Cast . cast ( FileCollectionIclass ,    paths [  0  ]  )  ;", "}", "return   new   DefaultConfigurableFileCollection ( this ,    null ,    paths )  ;", "}", "METHOD_END"], "methodName": ["resolveFiles"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   Cast . cast ( FileTreeInternal . class ,    resolveFiles ( paths )  . getAsFileTree (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveFilesAsTree"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( path   instanceof   ReadableResourceInternal )     {", "return    (  ( ReadableResourceInternal )     ( path )  )  ;", "}", "return   new   LocalResourceAdapter ( new   internal . resource . local . LocalFileStandInExternalResource ( resolve ( path )  ,    fileSystem )  )  ;", "}", "METHOD_END"], "methodName": ["resolveResource"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   convertObjectToURI ( path )  ;", "}", "METHOD_END"], "methodName": ["resolveUri"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "switch    ( validation )     {", "case   NONE    :", "break ;", "case   EXISTS    :", "if    (  !  ( exists (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" File    '  % s '    does   not   exist .  \"  ,     )  ;", "}", "break ;", "case   FILE    :", "if    (  !  ( exists (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" File    '  % s '    does   not   exist .  \"  ,     )  ;", "}", "if    (  !  ( isFile (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" File    '  % s '    is   not   a    \"  ,     )  ;", "}", "break ;", "case   DIRECTORY    :", "if    (  !  ( exists (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Directory    '  % s '    does   not   exist .  \"  ,     )  ;", "}", "if    (  !  ( isDirectory (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Directory    '  % s '    is   not   a   directory .  \"  ,     )  ;", "}", "break ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseDirFileResolver ( fileSystem ,    resolve ( path )  ,    patternSetFactory )  ;", "}", "METHOD_END"], "methodName": ["withBaseDir"], "fileName": "org.gradle.api.internal.file.AbstractFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   DefaultGroovyMethods . asType ( closure ,    FileVisitor . class )  ;", "}", "METHOD_END"], "methodName": ["fileVisitorFrom"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    File >    map    =    new   LinkedHashMap < String ,    File >  (  )  ;", "visit ( new   EmptyFileVisitor (  )     {", "public   void   visi ( FileVisitDetails   fileDetails )     {", "map . put ( fileDetails . getRelativePath (  )  . getPathString (  )  ,    fileDetails . ge (  )  )  ;", "}", "}  )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["getAsMap"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "final   Set < File >    files    =    new   LinkedHashSet < File >  (  )  ;", "visit ( new   EmptyFileVisitor (  )     {", "public   void   visi ( FileVisitDetails   fileDetails )     {", "files . add ( fileDetails . ge (  )  )  ;", "}", "}  )  ;", "return   files ;", "}", "METHOD_END"], "methodName": ["getFiles"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "return   matching ( ConfigureUtil . configure ( filterConfigClosure ,    patternSetFactory . create (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "PatternSet   patternSet    =     (  ( PatternSet )     ( patterns )  )  ;", "return   new    . FilteredFileTreeImpl ( this ,    patternSet . getAsSpec (  )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "return   new   UnionFileTree ( this ,    Cast . cast ( FileTreeInternal . class ,    fileTree )  )  ;", "}", "METHOD_END"], "methodName": ["plus"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "return   visit ( AbstractFileTree . fileVisitorFrom ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "final   AtomicBoolean   hasContent    =    new   AtomicBoolean (  )  ;", "visit ( new   FileVisitor (  )     {", "public   void   visitDir ( FileVisitDetails   dirDetails )     {", "dirDetails . ge (  )  ;", "hasContent . set ( true )  ;", "}", "public   void   visi ( FileVisitDetails   fileDetails )     {", "fileDetails . ge (  )  ;", "hasContent . set ( true )  ;", "}", "}  )  ;", "return   hasContent . get (  )  ;", "}", "METHOD_END"], "methodName": ["visitAll"], "fileName": "org.gradle.api.internal.file.AbstractFileTree"}, {"methodBody": ["METHOD_START", "{", "FileOutputStream   outputStream    =    new   FileOutputStream ( target )  ;", "try    {", "copyTo ( outputStream )  ;", "}    finally    {", "outputStream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFile"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "validateTimeStamps (  )  ;", "try    {", "if    ( isDirectory (  )  )     {", "GFileUtils . mkdirs ( target )  ;", "} else    {", "GFileUtils . mkdirs ( target . getParen (  )  )  ;", "copyFile ( target )  ;", "}", "chmod . chmod ( target ,    getMode (  )  )  ;", "return   true ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   copy    % s   to    '  % s '  .  \"  ,    getDisplayName (  )  ,    target )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "InputStream   inputStream    =    open (  )  ;", "try    {", "IOUtils . copyLarge ( inputStream ,    output )  ;", "}    fily    {", "inputStream . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   chmod ;", "}", "METHOD_END"], "methodName": ["getChmod"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   isDirectory (  )     ?    FileSystem    :    FileSystem ;", "}", "METHOD_END"], "methodName": ["getMode"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   getRelativePath (  )  . getLastName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   getRelativePath (  )  . getPathString (  )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "final   long   lastModified    =    getLastModified (  )  ;", "if    ( lastModified    <     0  )     {", "throw   new   GException ( String . format (  \" Invalid   Timestamp    % s   for    '  % s '  .  \"  ,    lastModified ,    getDisplayName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateTimeStamps"], "fileName": "org.gradle.api.internal.file.AbstractFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "final   DynamicObject   dynamicObject    =    new   BeanDynamicObject ( node )  ;", "final   Iterable < DirectoryFileTree >    existing    =    Lists . newLinkedList ( FluentIterable . from ( fileTrees )  . filter ( new   com . google . common . base . Predicate < DirectoryFileTree >  (  )     {", "@ Override", "public   boolean   apply ( DirectoryFileTree   input )     {", "return   input . getDir (  )  . exists (  )  ;", "}", "}  )  )  ;", "for    ( DirectoryFileTree   fileTree    :    existing )     {", "dynamicObject . invokeMethod ( childNodeName ,    s . singletonMap (  \" location \"  ,    fileTree . getDir (  )  )  )  ;", "}", "dynamicObject . invokeMethod (  \" or \"  ,    new   groovy . lang . Closure < Void >  ( this )     {", "public   Object   doCall ( Object   ignore )     {", "for    ( final   DirectoryFileTree   fileTree    :    existing )     {", "dynamicObject . invokeMethod (  \" and \"  ,    new   groovy . lang . Closure < Void >  ( this )     {", "public   Object   doCall ( Object   ignore )     {", "dynamicObject . invokeMethod (  \" gradleBaseDirSelector \"  ,    s . singletonMap (  \" baseDir \"  ,    fileTree . getDir (  )  )  )  ;", "fileTree . getPatterns (  )  . addToAntBuilder ( node ,    null )  ;", "return   null ;", "}", "}  )  ;", "}", "return   null ;", "}", "}  )  ;", "return   node ;", "}", "METHOD_END"], "methodName": ["addToAntBuilder"], "fileName": "org.gradle.api.internal.file.AntFileCollectionMatchingTaskBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( original . startsWith (  \" file :  \"  )  )     {", "try    {", "return   FileUtils . normalize ( new   File ( new   URI ( original )  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "File   file    =    new   File ( original )  ;", "if    ( file . isAbsolute (  )  )     {", "return   FileUtils . normalize ( file )  ;", "}", "if    (  . URI _ SCHEME . matcher ( original )  . matches (  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   convert   URL    '  % s '    to   a   file .  \"  ,    original )  )  ;", "}", "file    =    new   File ( baseDir ,    original )  ;", "return   FileUtils . normalize ( file )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.file.BasicFileResolver"}, {"methodBody": ["METHOD_START", "{", "DefaultFileCollectionResolveContext   context    =    new   DefaultFileCollectionResolveContext ( new   IdentityFileResolver (  )  )  ;", "visitContents ( context )  ;", "return   context . resolveAsFileCollections (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceCollections"], "fileName": "org.gradle.api.internal.file.CompositeFileCollection"}, {"methodBody": ["METHOD_START", "{", "final   Action < PatternFilterable >    action    =    Actions . doNothing (  )  ;", "final   FileTreeInternal   filtered 1     =    context . mock ( FileTreeInternal . class )  ;", "final   FileTreeInternal   filtered 2     =    context . mock ( FileTreeInternal . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . matching ( action )  ;", "will ( returnValue ( filtered 1  )  )  ;", "oneOf ( source 2  )  . matching ( action )  ;", "will ( returnValue ( filtered 2  )  )  ;", "}", "}  )  ;", "FileTree   filtered    =    tree . matching ( action )  ;", "assertThat ( filtered ,    instanceOf (  . class )  )  ;", "filteredCompositeSet    =     (  (  )     ( filtered )  )  ;", "assertThat ( WrapUtil . toList ( filteredCompositeSet . getSourceCollections (  )  )  ,    equalTo ( WrapUtil . toList ( filtered 1  ,    filtered 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchingWithActionReturnsUnionOfFilteredSets"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   Closure   closure    =    TestUtil . TEST _ CLOSURE ;", "final   FileTreeInternal   filtered 1     =    context . mock ( FileTreeInternal . class )  ;", "final   FileTreeInternal   filtered 2     =    context . mock ( FileTreeInternal . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . matching ( closure )  ;", "will ( returnValue ( filtered 1  )  )  ;", "oneOf ( source 2  )  . matching ( closure )  ;", "will ( returnValue ( filtered 2  )  )  ;", "}", "}  )  ;", "FileTree   filtered    =    tree . matching ( closure )  ;", "assertThat ( filtered ,    instanceOf (  . class )  )  ;", "filteredCompositeSet    =     (  (  )     ( filtered )  )  ;", "assertThat ( WrapUtil . toList ( filteredCompositeSet . getSourceCollections (  )  )  ,    equalTo ( WrapUtil . toList ( filtered 1  ,    filtered 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchingWithClosureReturnsUnionOfFilteredSets"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   PatternSet   patternSet    =    new   PatternSet (  )  ;", "final   FileTreeInternal   filtered 1     =    context . mock ( FileTreeInternal . class )  ;", "final   FileTreeInternal   filtered 2     =    context . mock ( FileTreeInternal . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . matching ( patternSet )  ;", "will ( returnValue ( filtered 1  )  )  ;", "oneOf ( source 2  )  . matching ( patternSet )  ;", "will ( returnValue ( filtered 2  )  )  ;", "}", "}  )  ;", "FileTree   filtered    =    tree . matching ( patternSet )  ;", "assertThat ( filtered ,    instanceOf (  . class )  )  ;", "filteredCompositeSet    =     (  (  )     ( filtered )  )  ;", "assertThat ( WrapUtil . toList ( filteredCompositeSet . getSourceCollections (  )  )  ,    equalTo ( WrapUtil . toList ( filtered 1  ,    filtered 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["matchingWithPatternSetReturnsUnionOfFilteredSets"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "FileTreeInternal   other    =    context . mock ( FileTreeInternal . class )  ;", "FileTree   sum    =    tree . plus ( other )  ;", "assertThat ( sum ,    instanceOf (  . class )  )  ;", "UnionFileTree   sumCompositeTree    =     (  ( UnionFileTree )     ( sum )  )  ;", "assertThat ( sumCompositeTree . getSourceCollections (  )  ,    equalTo (  (  ( Iterable )     ( WrapUtil . toList ( source 1  ,    source 2  ,    other )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["plusReturnsUnionOfThisTreeAndSourceTree"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "NativeServicesTestFixture . initialize (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   Action < FileVisitDetails >    visitor    =    Actions . doNothing (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . visit ( visitor )  ;", "oneOf ( source 2  )  . visit ( visitor )  ;", "}", "}  )  ;", "tree . visit ( visitor )  ;", "}", "METHOD_END"], "methodName": ["visitsEachTreeWithAction"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   Closure   visitor    =    TestUtil . TEST _ CLOSURE ;", "final   FileVisitor   closureAsVisitor    =    DefaultGroovyMethods . asType ( visitor ,    FileVisitor . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . visit ( closureAsVisitor )  ;", "oneOf ( source 2  )  . visit ( closureAsVisitor )  ;", "}", "}  )  ;", "tree . visit ( visitor )  ;", "}", "METHOD_END"], "methodName": ["visitsEachTreeWithClosure"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   FileVisitor   visitor    =    context . mock ( FileVisitor . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( source 1  )  . visit ( visitor )  ;", "oneOf ( source 2  )  . visit ( visitor )  ;", "}", "}  )  ;", "tree . visit ( visitor )  ;", "}", "METHOD_END"], "methodName": ["visitsEachTreeWithVisitor"], "fileName": "org.gradle.api.internal.file.CompositeFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.internal.file.DefaultFileLookup"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . withBaseDir ( baseDirectory )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.internal.file.DefaultFileLookup"}, {"methodBody": ["METHOD_START", "{", "return   fileSystem ;", "}", "METHOD_END"], "methodName": ["getFileSystem"], "fileName": "org.gradle.api.internal.file.DefaultFileLookup"}, {"methodBody": ["METHOD_START", "{", "return   fileCopier . copy ( action )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "CopySpec   copySpec    =    copySpec (  )  ;", "ac . execute ( copySpec )  ;", "return   copySpec ;", "}", "METHOD_END"], "methodName": ["copySpec"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   deleter . delete ( paths )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   deleter . delete ( action )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "ExecAction   execAction    =    execFactory . forContext ( fileResolver ,    instantiator )  . newDecoratedExecAction (  )  ;", "action . execute ( execAction )  ;", "return   execAction . execute (  )  ;", "}", "METHOD_END"], "methodName": ["exec"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . resolve ( path )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . resolve ( path ,    validation )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultConfigurableFileTree ( baseDir ,    fileResolver ,    taskResolver ,    fileCopier ,    directoryFileTreeFactory )  ;", "}", "METHOD_END"], "methodName": ["fileTree"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultConfigurableFileTree ( args ,    fileResolver ,    taskResolver ,    fileCopier ,    directoryFileTreeFactory )  ;", "}", "METHOD_END"], "methodName": ["fileTree"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultConfigurableFileCollection ( fileResolver ,    taskResolver ,    paths )  ;", "}", "METHOD_END"], "methodName": ["files"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   temporaryFileProvider . newTemporaryFile (  \" expandedArchives \"  )  ;", "}", "METHOD_END"], "methodName": ["getExpandDir"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   resourceHandler ;", "}", "METHOD_END"], "methodName": ["getResources"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "JavaExecAction   javaExecAction    =    execFactory . forContext ( fileResolver ,    instantiator )  . newDecoratedJavaExecAction (  )  ;", "action . execute ( javaExecAction )  ;", "return   execute (  )  ;", "}", "METHOD_END"], "methodName": ["javaexec"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    esolver . resolve ( path )  ;", "if    ( dir . isFile (  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Can ' t   create   directory .    The   path =  % s   points   to   an   existing    \"  ,    path )  )  ;", "}", "GFileUtils . mkdirs ( dir )  ;", "return   dir ;", "}", "METHOD_END"], "methodName": ["mkdir"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . resolveAsRelativePath ( path )  ;", "}", "METHOD_END"], "methodName": ["relativePath"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileCopier . sync ( action )  ;", "}", "METHOD_END"], "methodName": ["sync"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "File   tarFile    =    null ;", "ReadableResourceInternal   resource ;", "if    ( tarPath   instanceof   ReadableResourceInternal )     {", "resource    =     (  ( ReadableResourceInternal )     ( tarPath )  )  ;", "} else", "if    ( tarPath   instanceof   resources . ReadableResource )     {", "resource    =    new   UnknownBackingFileReadableResource (  (  ( resources . ReadableResource )     ( tarPath )  )  )  ;", "} else    {", "tarFile    =    file ( tarPath )  ;", "resource    =    new   resources . internal . LocalResourceAdapter ( new   LocalFileStandInExternalResource ( tarFile ,    fileSystem )  )  ;", "}", "TarFileTree   tarTree    =    new   TarFileTree ( tarFile ,    new   MaybeCompressedFileResource ( resource )  ,    getExpandDir (  )  ,    fileSystem ,    fileSystem ,    directoryFileTreeFactory ,    streamHasher )  ;", "return   new   FileTreeAdapter ( tarTree ,    fileResolver . getPatternSetFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["tarTree"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   fileResolver . resolveUri ( path )  ;", "}", "METHOD_END"], "methodName": ["uri"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return   new   FileTreeAdapter ( new   ZipFileTree ( file ( zipPath )  ,    getExpandDir (  )  ,    fileSystem ,    directoryFileTreeFactory ,    fileHasher )  ,    fileResolver . getPatternSetFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["zipTree"], "fileName": "org.gradle.api.internal.file.DefaultFileOperations"}, {"methodBody": ["METHOD_START", "{", "return    (  \" file    '  \"     +     ( file )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   file . lastModified (  )  ;", "}", "METHOD_END"], "methodName": ["getLastModified"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   stat . getUnixMode ( file )  ;", "}", "METHOD_END"], "methodName": ["getMode"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   relativePath ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   file . length (  )  ;", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   file . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "RelativePath   path    =    RelativePath . parse (  (  !  ( file . isDirectory (  )  )  )  ,    file . getAbsolutePath (  )  )  ;", "return   new    ( file ,    path ,    fileSystem ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "return   GFileUtils . openInputStream ( file )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.api.internal.file.DefaultFileTreeElement"}, {"methodBody": ["METHOD_START", "{", "buildDir . resolveAndSet ( value )  ;", "}", "METHOD_END"], "methodName": ["setBuildDirectory"], "fileName": "org.gradle.api.internal.file.DefaultProjectLayout"}, {"methodBody": ["METHOD_START", "{", "Set < DirectoryTree >    result    =    new   LinkedHashSet < DirectoryTree >  (  )  ;", "for    ( Object   path    :    source )     {", "if    ( path   instanceof    )     {", "nested    =     (  (  )     ( path )  )  ;", "result . addAll ( nested . getSrcDirTrees (  )  )  ;", "} else    {", "for    ( File   srcDir    :    fileResolver . resolveFiles ( path )  )     {", "if    (  ( srcDir . exists (  )  )     &  &     (  !  ( srcDir . isDirectory (  )  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Source   directory    '  % s '    is   not   a   directory .  \"  ,    srcDir )  )  ;", "}", "result . add ( directoryFileTreeFactory . create ( srcDir ,    patterns )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doGetSrcDirTrees"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . exclude ( excludeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . exclude ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . exclude ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . exclude ( excludeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "return   patterns . getExcludes (  )  ;", "}", "METHOD_END"], "methodName": ["getExcludes"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "return   filter ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "return   patterns . getIncludes (  )  ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "return   this . name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "Map < File ,    DirectoryTree >    trees    =    new   LinkedHashMap < File ,    DirectoryTree >  (  )  ;", "for    ( DirectoryTree   tree    :    doGetSrcDirTrees (  )  )     {", "if    (  !  ( trees . containsKey ( tree . getDir (  )  )  )  )     {", "trees . put ( tree . getDir (  )  ,    tree )  ;", "}", "}", "return   new   LinkedHashSet < DirectoryTree >  ( trees . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSrcDirTrees"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "Set < File >    dirs    =    new   LinkedHashSet < File >  (  )  ;", "for    ( Tree   tree    :    getSrcDirTrees (  )  )     {", "dirs . add ( tree . getDir (  )  )  ;", "}", "return   dirs ;", "}", "METHOD_END"], "methodName": ["getSrcDirs"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . include ( includeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . include ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . include ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . include ( includeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . setExcludes ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExcludes"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "patterns . setIncludes ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIncludes"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "source . clear (  )  ;", "GUtil . addToCollection ( source ,    srcPaths )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSrcDirs"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "this . source . add ( source )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "source . add ( srcDir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["srcDir"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   srcDir    :    srcDirs )     {", "s . add ( srcDir )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["srcDirs"], "fileName": "org.gradle.api.internal.file.DefaultSourceDirectorySet"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    new   File ( baseDirFactory . create (  )  ,    CollectionUtils . join (  \"  /  \"  ,    path )  )  ;", "GFileUtils . mkdirs ( dir )  ;", "try    {", "File   tmpDir    =    File . createTempFile (  \"  \"  ,     \" projectDir \"  ,    dir )  ;", "tmpDir . delete (  )  ;", "tmpDir . mkdir (  )  ;", "return   tmpDir ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createTemporaryDirectory"], "fileName": "org.gradle.api.internal.file.DefaultTemporaryFileProvider"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    new   File ( baseDirFactory . create (  )  ,    CollectionUtils . join (  \"  /  \"  ,    path )  )  ;", "GFileUtils . mkdirs ( dir )  ;", "try    {", "return   File . createTempFile ( prefix ,    suffix ,    dir )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createTemporaryFile"], "fileName": "org.gradle.api.internal.file.DefaultTemporaryFileProvider"}, {"methodBody": ["METHOD_START", "{", "return   FileUtils . canonicalize ( new   File ( baseDirFactory . create (  )  ,    CollectionUtils . join (  \"  /  \"  ,    path )  )  )  ;", "}", "METHOD_END"], "methodName": ["newTemporaryFile"], "fileName": "org.gradle.api.internal.file.DefaultTemporaryFileProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( notation   instanceof   File )     {", "result . converted ( notation )  ;", "return ;", "}", "if    ( notation   instanceof   Path )     {", "result . converted (  (  ( Path )     ( notation )  )  . toFile (  )  )  ;", "return ;", "}", "if    ( notation   instanceof   FileSystemLocation )     {", "result . converted (  (  ( FileSystemLocation )     ( notation )  )  . getAsFile (  )  )  ;", "return ;", "}", "if    ( notation   instanceof   URL )     {", "try    {", "notation    =     (  ( URL )     ( notation )  )  . toURI (  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "if    ( notation   instanceof   URI )     {", "URI   uri    =     (  ( URI )     ( notation )  )  ;", "if    (  (  \" file \"  . equals ( uri . getScheme (  )  )  )     &  &     (  ( uri . getPath (  )  )     !  =    null )  )     {", "result . converted ( new   File ( uri . getPath (  )  )  )  ;", "} else    {", "result . converted ( uri )  ;", "}", "return ;", "}", "if    ( notation   instanceof   CharSequence )     {", "String   notationString    =    notation . toString (  )  ;", "if    ( notationString . startsWith (  \" file :  \"  )  )     {", "result . converted ( new   File ( uriDecode ( notationString . substring (  5  )  )  )  )  ;", "return ;", "}", "for    ( File   file    :    File . listRoots (  )  )     {", "String   rootPath    =    file . getAbsolutePath (  )  ;", "String   normalisedStr    =    notationString ;", "if    (  !  ( fileSystem . isCaseSensitive (  )  )  )     {", "rootPath    =    rootPath . toLowerCase (  )  ;", "normalisedStr    =    normalisedStr . toLowerCase (  )  ;", "}", "if    (  ( normalisedStr . startsWith ( rootPath )  )     |  |     ( normalisedStr . startsWith ( rootPath . replace ( File . separatorChar ,     '  /  '  )  )  )  )     {", "result . converted ( new   File ( notationString )  )  ;", "return ;", "}", "}", "if    (  . URI _ SCHEME . matcher ( notationString )  . matches (  )  )     {", "try    {", "result . converted ( new   URI ( notationString )  )  ;", "return ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "result . converted ( new   File ( notationString )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.api.internal.file.FileOrUriNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( Object . class )  . typeDisplayName (  \" a   File   or   URI \"  )  . converter ( new   FileOrUriNotationConverter ( fileSystem )  )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.api.internal.file.FileOrUriNotationConverter"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   builder    =    new   StringBuffer (  )  ;", "Matcher   matcher    =     . ENCODED _ URI . matcher ( path )  ;", "while    ( matcher . find (  )  )     {", "String   val    =    matcher . group (  1  )  ;", "matcher . appendReplacement ( builder ,    String . valueOf (  (  ( char )     ( Integer . parseInt ( val ,     1  6  )  )  )  )  )  ;", "}", "matcher . appendTail ( builder )  ;", "return   builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["uriDecode"], "fileName": "org.gradle.api.internal.file.FileOrUriNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return   new   FileSystemSubset . Builder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.gradle.api.internal.file.FileSystemSubset"}, {"methodBody": ["METHOD_START", "{", "File   absoluteFile    =    file . getAbsoluteFile (  )  ;", "String   pathWithSeparator    =     ( file . getAbsolutePath (  )  )     +     ( File . separator )  ;", "for    ( File   candidateFile    :    files )     {", "String   candidateFilePathWithSeparator    =     ( candidateFile . getPath (  )  )     +     ( File . separator )  ;", "if    ( pathWithSeparator . startsWith ( candidateFilePathWithSeparator )  )     {", "return   true ;", "}", "}", "for    ( DirectoryTree   tree    :    trees )     {", "if    (  ( tree . getDir (  )  . getAbsoluteFile (  )  . equals ( absoluteFile )  )     |  |     ( DirectoryTrees . contains ( s . getDefault (  )  ,    tree ,    absoluteFile )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.file.FileSystemSubset"}, {"methodBody": ["METHOD_START", "{", "return   FileUtils . calculateRoots ( Iterables . concat ( files ,    Iterables . transform ( trees ,    new   com . google . common . base . Function < DirectoryTree ,    File >  (  )     {", "@ Override", "public   File   apply ( DirectoryTree   input )     {", "return   input . getDir (  )  ;", "}", "}  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRoots"], "fileName": "org.gradle.api.internal.file.FileSystemSubset"}, {"methodBody": ["METHOD_START", "{", "return    ( files . isEmpty (  )  )     &  &     ( trees . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.api.internal.file.FileSystemSubset"}, {"methodBody": ["METHOD_START", "{", "return   new   FileSystemSubset ( ImmutableList . copyOf ( getRoots (  )  )  ,    ImmutableList .  < ImmutableDirectoryTree > of (  )  )  ;", "}", "METHOD_END"], "methodName": ["unfiltered"], "fileName": "org.gradle.api.internal.file.FileSystemSubset"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException ( String . format (  \" Cannot   convert   path    % s   to   a   relative   path .  \"  ,    path )  )  ;", "}", "METHOD_END"], "methodName": ["resolveAsRelativePath"], "fileName": "org.gradle.api.internal.file.IdentityFileResolver"}, {"methodBody": ["METHOD_START", "{", "return   new   ImmutableDirectoryTree ( dir ,    patternSet )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.file.ImmutableDirectoryTree"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   ImmutableDirectoryTree )     {", "return    (  ( ImmutableDirectoryTree )     ( source )  )  ;", "} else    {", "return   ImmutableDirectoryTree . of ( source . getDir (  )  ,    source . getPatterns (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.file.ImmutableDirectoryTree"}, {"methodBody": ["METHOD_START", "{", "if    ( source   instanceof   ImmutablePatternSet )     {", "return    (  ( ImmutablePatternSet )     ( source )  )  ;", "} else    {", "return   new   ImmutablePatternSet ( source )  ;", "}", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.file.ImmutablePatternSet"}, {"methodBody": ["METHOD_START", "{", "return   resource . getBackingFile (  )  ;", "}", "METHOD_END"], "methodName": ["getBackingFile"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "return   resource . getBaseName (  )  ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "return   resource . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "return   resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "return   resource . getURI (  )  ;", "}", "METHOD_END"], "methodName": ["getURI"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "return   resource . read (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.internal.file.MaybeCompressedFileResource"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( file )     =  =    null )     |  |     (  ( relativePath )     =  =    null )  )     {", "return   null ;", "}", "int   relativeSegments    =    relativePath . getSegments (  )  . length ;", "File   parentFile    =    file ;", "for    ( int   i    =     0  ;    i    <    relativeSegments ;    i +  +  )     {", "parentFile    =    parentFile . getParentFile (  )  ;", "}", "return   parentFile ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.api.internal.file.RelativeFile"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.file.RelativeFile"}, {"methodBody": ["METHOD_START", "{", "return   relativePath ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "org.gradle.api.internal.file.RelativeFile"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDirectoryFileTreeFactory ( TestFiles . getPatternSetFactory (  )  ,    TestFiles . fileSystem (  )  )  ;", "}", "METHOD_END"], "methodName": ["directoryFileTreeFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . execFactory (  )  ;", "}", "METHOD_END"], "methodName": ["execActionFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . EXEC _ FACTORY ;", "}", "METHOD_END"], "methodName": ["execFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . execFactory (  )  ;", "}", "METHOD_END"], "methodName": ["execHandleFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . execFactory (  )  . forContext ( TestFiles . resolver ( baseDir )  ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["execHandleFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileCollectionFactory (  )  ;", "}", "METHOD_END"], "methodName": ["fileCollectionFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileHasher ( TestFiles . streamHasher (  )  )  ;", "}", "METHOD_END"], "methodName": ["fileHasher"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . FILE _ LOOKUP ;", "}", "METHOD_END"], "methodName": ["fileLookup"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileOperations ( TestFiles . resolver ( basedDir )  ,    null ,    null ,    DirectInstantiator . INSTANCE ,    TestFiles . fileLookup (  )  ,    TestFiles . directoryFileTreeFactory (  )  ,    TestFiles . streamHasher (  )  ,    TestFiles . fileHasher (  )  ,    TestFiles . execFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["fileOperations"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   FileResourceConnector ( TestFiles . FILE _ SYSTEM )  ;", "}", "METHOD_END"], "methodName": ["fileRepository"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . FILE _ SYSTEM ;", "}", "METHOD_END"], "methodName": ["fileSystem"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . resolver (  )  . getPatternSetFactory (  )  ;", "}", "METHOD_END"], "methodName": ["getPatternSetFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . execFactory (  )  . forContext ( TestFiles . resolver ( baseDir )  ,    INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["javaExecHandleFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . FILE _ LOOKUP . getFileResolver (  )  ;", "}", "METHOD_END"], "methodName": ["resolver"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   TestFiles . FILE _ LOOKUP . getFileResolver ( baseDir )  ;", "}", "METHOD_END"], "methodName": ["resolver"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultSourceDirectorySetFactory ( TestFiles . resolver (  )  ,    new   DefaultDirectoryFileTreeFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["sourceDirectorySetFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultSourceDirectorySetFactory ( TestFiles . resolver ( baseDir )  ,    new   DefaultDirectoryFileTreeFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["sourceDirectorySetFactory"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultStreamHasher ( new   DefaultContentHasherFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["streamHasher"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( path )  . getAbsolutePath (  )  ;", "}", "METHOD_END"], "methodName": ["systemSpecificAbsolutePath"], "fileName": "org.gradle.api.internal.file.TestFiles"}, {"methodBody": ["METHOD_START", "{", "source . add ( collection )  ;", "}", "METHOD_END"], "methodName": ["addToUnion"], "fileName": "org.gradle.api.internal.file.UnionFileCollection"}, {"methodBody": ["METHOD_START", "{", "return    \" file   collection \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.UnionFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSources"], "fileName": "org.gradle.api.internal.file.UnionFileCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( source   instanceof   FileTree )  )     {", "throw   new   UnsupportedOperationException ( String . format (  \" Can   only   add   FileTree   instances   to    % s .  \"  ,    getDisplayName (  )  )  )  ;", "}", "sourceTrees . add ( Cast . cast ( FileTreeInternal . class ,    source )  )  ;", "}", "METHOD_END"], "methodName": ["addToUnion"], "fileName": "org.gradle.api.internal.file.UnionFileTree"}, {"methodBody": ["METHOD_START", "{", "FileTreeInternal   set 1     =    context . mock ( FileTreeInternal . class ,     \" set 1  \"  )  ;", "set . addToUnion ( set 1  )  ;", "assertThat ( set . getSourceCollections (  )  ,    equalTo (  (  ( Iterable )     ( WrapUtil . toList (  (  ( Object )     ( set 1  )  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddFileTree"], "fileName": "org.gradle.api.internal.file.UnionFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "set . addToUnion ( context . mock ( FileCollection . class )  )  ;", "fail (  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Can   only   add      instances   to    < display   name >  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotAddFileCollection"], "fileName": "org.gradle.api.internal.file.UnionFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "NativeServicesTestFixture . initialize (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.file.UnionFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "return   basedir . equals ( this . baseDir )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.gradle.api.internal.file.ant.BaseDirSelector"}, {"methodBody": ["METHOD_START", "{", "this . baseDir    =    baseDir ;", "}", "METHOD_END"], "methodName": ["setBaseDir"], "fileName": "org.gradle.api.internal.file.ant.BaseDirSelector"}, {"methodBody": ["METHOD_START", "{", "final   OutputStream   outStr ;", "try    {", "outStr    =    compressor . createArchiveOutputStream ( tarFile )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   create   TAR    '  % s '  .  \"  ,    tarFile )  ,    e )  ;", "}", "IoActions . withResource ( outStr ,    new   ErroringAction < OutputStream >  (  )     {", "@ Override", "protected   void   doExecute ( final   OutputStream   outStr )    throws   Exception    {", "TarOutputStream   tarOutStr ;", "try    {", "tarOutStr    =    new   TarOutputStream ( outStr )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   create   TAR    '  % s '  .  \"  ,    tarFile )  ,    e )  ;", "}", "tarOutStr . setLongFileMode ( LONGFILE _ GNU )  ;", "stream . process ( new    . StreamAction ( tarOutStr )  )  ;", "tarOutStr . close (  )  ;", "}", "}  )  ;", "return   WorkResults . didWork ( true )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.archive.TarCopyAction"}, {"methodBody": ["METHOD_START", "{", "return   preserveFileTimestamps    ?    details . getLastModified (  )     :    TarCopyAction . CONSTANT _ TIME _ FOR _ TAR _ ENTRIES ;", "}", "METHOD_END"], "methodName": ["getArchiveTimeFor"], "fileName": "org.gradle.api.internal.file.archive.TarCopyAction"}, {"methodBody": ["METHOD_START", "{", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   expand    % s .  \"  ,    getDisplayName (  )  )  ,    e )  ;", "}", "METHOD_END"], "methodName": ["cannotExpand"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( tarFile )     !  =    null )     {", "return   tarFile ;", "}", "return   resource . getBackingFile (  )  ;", "}", "METHOD_END"], "methodName": ["getBackingFile"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" TAR    '  % s '  \"  ,    resource . getDisplayName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "InputStream   inputStream    =    null ;", "try    {", "inputStream    =    new   BufferedInputStream ( resource . read (  )  )  ;", "String   expandedDirName    =     (  ( resource . getBaseName (  )  )     +     \"  _  \"  )     +     ( streamHasher . hash ( inputStream )  )  ;", "return   new    ( tmpDir ,    expandedDirName )  ;", "}    catch    ( ResourceException   e )     {", "throw   cannotExpand ( e )  ;", "}    finally    {", "IoActions . closeQuietly ( inputStream )  ;", "}", "}", "METHOD_END"], "methodName": ["getExpandedDir"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "return   directoryFileTreeFactory . create ( getExpandedDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMirror"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "InputStream   inputStream ;", "try    {", "inputStream    =    new   BufferedInputStream ( resource . read (  )  )  ;", "}    catch    ( ResourceException   e )     {", "throw   cannotExpand ( e )  ;", "}", "try    {", "try    {", "visitImpl ( visitor ,    inputStream )  ;", "}    finally    {", "inputStream . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "String   message    =     (  (  (  (  \" Unable   to   expand    \"     +     ( getDisplayName (  )  )  )     +     \"  \\ n \"  )     +     \"       The   tar   might   be   corrupted   or   it   is   compressed   in   an   unexpected   way .  \\ n \"  )     +     \"       By   default   the   tar   tree   tries   to   guess   the   compression   based   on   the   file   extension .  \\ n \"  )     +     \"       If   you   need   to   specify   the   compression   explicitly   please   refer   to   the   DSL   reference .  \"  ;", "throw   new   GException ( message ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "AtomicBoolean   stopFlag    =    new   AtomicBoolean (  )  ;", ". NoCloseTarInputStream   tar    =    new    . NoCloseTarInputStream ( inputStream )  ;", "TarEntry   entry ;", "File   expandedDir    =    getExpandedDir (  )  ;", "while    (  (  !  ( stopFlag . get (  )  )  )     &  &     (  ( entry    =    tar . getNextEntry (  )  )     !  =    null )  )     {", "if    ( entry . isDirectory (  )  )     {", "visitor . visitDir ( new    . DetailsImpl ( resource ,    expandedDir ,    entry ,    tar ,    stopFlag ,    chmod )  )  ;", "} else    {", "visitor . visitFile ( new    . DetailsImpl ( resource ,    expandedDir ,    entry ,    tar ,    stopFlag ,    chmod )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["visitImpl"], "fileName": "org.gradle.api.internal.file.archive.TarFileTree"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir / other / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . tarTo ( t )  ;", "assertCanStopVisiting ( tree )  ;", "}", "METHOD_END"], "methodName": ["canStopVisitingFiles"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( tree . getDisplayName (  )  ,    equalTo (  (  (  \" TAR    '  \"     +     ( tarFile )  )     +     \"  '  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["displayName"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . tarTo ( t )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" file 1  . txt \"  )  ,    new   ArrayList < String >  (  )  )  ;", "TestFile   content    =    expandDir . listFiles (  )  [  0  ]  . listFiles (  )  [  0  ]  ;", "content . makeOlder (  )  ;", "TestFile . Snapshot   snapshot    =    content . snapshot (  )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" file 1  . txt \"  )  ,    new   ArrayList < String >  (  )  )  ;", "content . assertHasNotChangedSince ( snapshot )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverwriteFilesOnSecondVisit"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "resources . findResource (  \" permissions . tar \"  )  . copyTo ( tarFile )  ;", "final   Map < String ,    Integer >    expected    =    new   HashMap < String ,    Integer >  (  )  ;", "expected . put (  \" file \"  ,     4  2  0  )  ;", "expected . put (  \" folder \"  ,     4  9  3  )  ;", "assertVisitsPermissions ( tree ,    expected )  ;", "}", "METHOD_END"], "methodName": ["expectedFilePermissionsAreFound"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "assertThat ( e . getMessage (  )  ,    containsString (  (  (  \" Cannot   expand   TAR    '  \"     +     ( t )  )     +     \"  '  .  \"  )  )  )  ;", "assertThat ( e . getCause (  )  ,    instanceOf ( MissingResourceException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failsWhenTarFileDoesNotExist"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "tarFile . createDir (  )  ;", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "assertThat ( e . getMessage (  )  ,    containsString (  (  (  \" Cannot   expand   TAR    '  \"     +     ( tarFile )  )     +     \"  '  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failsWhenTarFileIsADirectory"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "TestFile   tbz 2     =    tmpDir . getTestDirectory (  )  . file (  \" test . tbz 2  \"  )  ;", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir 2  / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . tbzTo ( tbz 2  )  ;", "MaybeCompressedFileResource   resource    =    new   MaybeCompressedFileResource ( new   LocalResourceAdapter ( TestFiles . fileRepository (  )  . localResource ( tbz 2  )  )  )  ;", "tree    =    new    ( tarFile ,    resource ,    expandDir ,    TestFiles . fileSystem (  )  ,    TestFiles . fileSystem (  )  ,    TestFiles . directoryFileTreeFactory (  )  ,    TestFiles . streamHasher (  )  )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  ,    WrapUtil . toList (  \" subdir \"  ,     \" subdir 2  \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readsBzippedTarFile"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "TestFile   tgz    =    tmpDir . getTestDirectory (  )  . file (  \" test . tgz \"  )  ;", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir 2  / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . tgzTo ( tgz )  ;", "MaybeCompressedFileResource   resource    =    new   MaybeCompressedFileResource ( new   LocalResourceAdapter ( TestFiles . fileRepository (  )  . localResource ( tgz )  )  )  ;", "tree    =    new    ( tarFile ,    resource ,    expandDir ,    TestFiles . fileSystem (  )  ,    TestFiles . fileSystem (  )  ,    TestFiles . directoryFileTreeFactory (  )  ,    TestFiles . streamHasher (  )  )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  ,    WrapUtil . toList (  \" subdir \"  ,     \" subdir 2  \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["readsGzippedTarFile"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "resources . findResource (  \" nullpermissions . tar \"  )  . copyTo ( tarFile )  ;", "final   Map < String ,    Integer >    expected    =    new   HashMap < String ,    Integer >  (  )  ;", "expected . put (  \" bin \"  ,     4  9  3  )  ;", "assertVisitsPermissions ( tree ,    expected )  ;", "}", "METHOD_END"], "methodName": ["readsTarFileWithNullPermissions"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir 2  / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . tarTo ( t )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  ,    WrapUtil . toList (  \" subdir \"  ,     \" subdir 2  \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["visitsContentsOfTarFile"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "expandDir . write (  \" not   a   directory \"  )  ;", "t . write (  \" not   a   tar   file \"  )  ;", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    containsString (  (  (  \" Unable   to   expand   TAR    '  \"     +     ( t )  )     +     \"  '  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["wrapsFailureToUntarFile"], "fileName": "org.gradle.api.internal.file.archive.TarFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   ZipOutputStream   zipOutStr ;", "try    {", "zipOutStr    =    compressor . createArchiveOutputStream ( zipFile )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   create   ZIP    '  % s '  .  \"  ,    zipFile )  ,    e )  ;", "}", "try    {", "IoActions . withResource ( zipOutStr ,    new   Action < ZipOutputStream >  (  )     {", "public   void   execute ( ZipOutputStream   outputStream )     {", "stream . process ( new   ZipCopyAction . StreamAction ( outputStream ,    encoding )  )  ;", "}", "}  )  ;", "}    catch    ( UncheckedIOException   e )     {", "if    (  ( e . getCause (  )  )    instanceof   Zip 6  4 RequiredException )     {", "throw   new   tasks . bundling . internal . Zip 6  4 RequiredException ( String . format (  \"  % s \\ n \\ nTo   build   this   archive ,    please   enable   the   zip 6  4    extension .  \\ nSee :     % s \"  ,    e . getCause (  )  . getMessage (  )  ,    documentationRegistry . getDslRefForProperty ( Zip . class ,     \" zip 6  4  \"  )  )  )  ;", "}", "}", "return   WorkResults . didWork ( true )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.archive.ZipCopyAction"}, {"methodBody": ["METHOD_START", "{", "return   preserveFileTimestamps    ?    details . getLastModified (  )     :    ZipCopyAction . CONSTANT _ TIME _ FOR _ ZIP _ ENTRIES ;", "}", "METHOD_END"], "methodName": ["getArchiveTimeFor"], "fileName": "org.gradle.api.internal.file.archive.ZipCopyAction"}, {"methodBody": ["METHOD_START", "{", "return   zipFile ;", "}", "METHOD_END"], "methodName": ["getBackingFile"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTree"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" ZIP    '  % s '  \"  ,    zipFile )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTree"}, {"methodBody": ["METHOD_START", "{", "String   expandedDirName    =     (  ( zipFile . getName (  )  )     +     \"  _  \"  )     +     ( fileHasher . hash ( zipFile )  )  ;", "return   new   File ( tmpDir ,    expandedDirName )  ;", "}", "METHOD_END"], "methodName": ["getExpandedDir"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTree"}, {"methodBody": ["METHOD_START", "{", "return   directoryFileTreeFactory . create ( getExpandedDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMirror"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTree"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( zipFile . exists (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   expand    % s   as   it   does   not   exist .  \"  ,    getDisplayName (  )  )  )  ;", "}", "if    (  !  ( zipFile . isFile (  )  )  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   expand    % s   as   it   is   not   a   file .  \"  ,    getDisplayName (  )  )  )  ;", "}", "AtomicBoolean   stopFlag    =    new   AtomicBoolean (  )  ;", "try    {", "ZipFile   zip    =    new   ZipFile ( zipFile )  ;", "File   expandedDir    =    getExpandedDir (  )  ;", "try    {", "Map < String ,    ZipEntry >    entriesByName    =    new   TreeMap < String ,    ZipEntry >  (  )  ;", "Enumeration   entries    =    zip . getEntries (  )  ;", "while    ( entries . hasMoreElements (  )  )     {", "ZipEntry   entry    =     (  ( ZipEntry )     ( entries . nextElement (  )  )  )  ;", "entriesByName . put ( entry . getName (  )  ,    entry )  ;", "}", "Iterator < ZipEntry >    sortedEntries    =    entriesByName . values (  )  . iterator (  )  ;", "while    (  (  !  ( stopFlag . get (  )  )  )     &  &     ( sortedEntries . hasNext (  )  )  )     {", "ZipEntry   entry    =    sortedEntries . next (  )  ;", "if    ( entry . isDirectory (  )  )     {", "visitor . visitDir ( new    . DetailsImpl ( zipFile ,    expandedDir ,    entry ,    zip ,    stopFlag ,    chmod )  )  ;", "} else    {", "visitor . visitFile ( new    . DetailsImpl ( zipFile ,    expandedDir ,    entry ,    zip ,    stopFlag ,    chmod )  )  ;", "}", "}", "}    finally    {", "zip . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   expand    % s .  \"  ,    getDisplayName (  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTree"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir / other / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . zipTo ( z )  ;", "assertCanStopVisiting ( tree )  ;", "}", "METHOD_END"], "methodName": ["canStopVisitingFiles"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( tree . getDisplayName (  )  ,    equalTo (  (  (  \" ZIP    '  \"     +     ( zipFile )  )     +     \"  '  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["displayName"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . zipTo ( z )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" file 1  . txt \"  )  ,    new   ArrayList < String >  (  )  )  ;", "TestFile   content    =    expandDir . listFiles (  )  [  0  ]  . listFiles (  )  [  0  ]  ;", "content . makeOlder (  )  ;", "TestFile . Snapshot   snapshot    =    content . snapshot (  )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" file 1  . txt \"  )  ,    new   ArrayList < String >  (  )  )  ;", "content . assertHasNotChangedSince ( snapshot )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverwriteFilesOnSecondVisit"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "resources . findResource (  \" nomodeinfos . zip \"  )  . copyTo ( zipFile )  ;", "final   Map < String ,    Integer >    expected    =    new   HashMap < String ,    Integer >  (  )  ;", "expected . put (  \" file . txt \"  ,     4  2  0  )  ;", "expected . put (  \" folder \"  ,     4  9  3  )  ;", "assertVisitsPermissions ( tree ,    expected )  ;", "}", "METHOD_END"], "methodName": ["expectedDefaultForNoModeZips"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "resources . findResource (  \" permissions . zip \"  )  . copyTo ( zipFile )  ;", "final   Map < String ,    Integer >    expected    =    new   HashMap < String ,    Integer >  (  )  ;", "expected . put (  \" file \"  ,     4  2  0  )  ;", "expected . put (  \" folder \"  ,     4  9  3  )  ;", "assertVisitsPermissions ( tree ,    expected )  ;", "}", "METHOD_END"], "methodName": ["expectedFilePermissionsAreFound"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Cannot   expand   ZIP    '  \"     +     ( z )  )     +     \"  '    as   it   does   not   exist .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failsWhenZipFileDoesNotExist"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "zipFile . createDir (  )  ;", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Cannot   expand   ZIP    '  \"     +     ( zipFile )  )     +     \"  '    as   it   is   not   a   file .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["failsWhenZipFileIsADirectory"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "rootDir . file (  \" subdir / file 1  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . file (  \" subdir 2  / file 2  . txt \"  )  . write (  \" content \"  )  ;", "rootDir . zipTo ( z )  ;", "assertVisits ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  ,    WrapUtil . toList (  \" subdir \"  ,     \" subdir 2  \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" subdir / file 1  . txt \"  ,     \" subdir 2  / file 2  . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["visitsContentsOfZipFile"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "zipFile . write (  \" not   a   zip   file \"  )  ;", "try    {", "tree . visit ( null )  ;", "fail (  )  ;", "}    catch    ( GradleException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  (  (  \" Could   not   expand   ZIP    '  \"     +     ( zipFile )  )     +     \"  '  .  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["wrapsFailureToUnzipFile"], "fileName": "org.gradle.api.internal.file.archive.ZipFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "return   resource . getBackingFile (  )  ;", "}", "METHOD_END"], "methodName": ["getBackingFile"], "fileName": "org.gradle.api.internal.file.archive.compression.AbstractArchiver"}, {"methodBody": ["METHOD_START", "{", "return   resource . getBaseName (  )  ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.internal.file.archive.compression.AbstractArchiver"}, {"methodBody": ["METHOD_START", "{", "return   resource . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.archive.compression.AbstractArchiver"}, {"methodBody": ["METHOD_START", "{", "return   uri ;", "}", "METHOD_END"], "methodName": ["getURI"], "fileName": "org.gradle.api.internal.file.archive.compression.AbstractArchiver"}, {"methodBody": ["METHOD_START", "{", "return   new   ArchiveOutputStreamFactory (  )     {", "public   OutputStream   createArchiveOutputStream ( File   destination )    throws   FileNotFoundException    {", "OutputStream   outStr    =    new   BufferedOutputStream ( new   FileOutputStream ( destination )  )  ;", "try    {", "outStr . write (  ' B '  )  ;", "outStr . write (  ' Z '  )  ;", "return   new   CBZip 2 OutputStream ( outStr )  ;", "}    catch    ( Exception   e )     {", "IOUtils . closeQuietly ( outStr )  ;", "String   message    =    String . format (  \" Unable   to   create   bzip 2    output   stream   for   file    % s \"  ,    destination )  ;", "throw   new   RuntimeException ( message ,    e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getCompressor"], "fileName": "org.gradle.api.internal.file.archive.compression.Bzip2Archiver"}, {"methodBody": ["METHOD_START", "{", "return    \" bzip 2  :  \"  ;", "}", "METHOD_END"], "methodName": ["getSchemePrefix"], "fileName": "org.gradle.api.internal.file.archive.compression.Bzip2Archiver"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    new   BufferedInputStream ( resource . read (  )  )  ;", "try    {", "byte [  ]    skip    =    new   byte [  2  ]  ;", "input . read ( skip )  ;", "return   new   CBZip 2 InputStream ( input )  ;", "}    catch    ( Exception   e )     {", "IOUtils . closeQuietly ( input )  ;", "throw   ResourceExceptions . readFailed ( resource . getDisplayName (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.internal.file.archive.compression.Bzip2Archiver"}, {"methodBody": ["METHOD_START", "{", "return   new   ArchiveOutputStreamFactory (  )     {", "public   OutputStream   createArchiveOutputStream ( File   destination )    throws   FileNotFoundException    {", "OutputStream   outStr    =    new   FileOutputStream ( destination )  ;", "try    {", "return   new   GZIPOutputStream ( outStr )  ;", "}    catch    ( Exception   e )     {", "IOUtils . closeQuietly ( outStr )  ;", "String   message    =    String . format (  \" Unable   to   create   gzip   output   stream   for   file    % s .  \"  ,    destination )  ;", "throw   new   RuntimeException ( message ,    e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getCompressor"], "fileName": "org.gradle.api.internal.file.archive.compression.GzipArchiver"}, {"methodBody": ["METHOD_START", "{", "return    \" gzip :  \"  ;", "}", "METHOD_END"], "methodName": ["getSchemePrefix"], "fileName": "org.gradle.api.internal.file.archive.compression.GzipArchiver"}, {"methodBody": ["METHOD_START", "{", "InputStream   input    =    new   BufferedInputStream ( resource . read (  )  )  ;", "try    {", "return   new   GZIPInputStream ( input )  ;", "}    catch    ( Exception   e )     {", "IOUtils . closeQuietly ( input )  ;", "throw   ResourceExceptions . readFailed ( resource . getDisplayName (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.api.internal.file.archive.compression.GzipArchiver"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   FileOutputStream ( destination )  ;", "}    catch    ( Exception   e )     {", "String   message    =    String . format (  \" Unable   to   create   output   stream   for       % s .  \"  ,    destination )  ;", "throw   new   RuntimeException ( message ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["createArchiveOutputStream"], "fileName": "org.gradle.api.internal.file.archive.compression.SimpleCompressor"}, {"methodBody": ["METHOD_START", "{", "buildDependency . add ( tasks )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( files ,    Arrays . asList ( paths )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   buildDependency . getMutableValues (  )  ;", "}", "METHOD_END"], "methodName": ["getBuiltBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "return   files ;", "}", "METHOD_END"], "methodName": ["getFrom"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "buildDependency . setValues ( tasks )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBuiltBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "files . clear (  )  ;", "files . add ( path )  ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "files . clear (  )  ;", "GUtil . addTo ( files ,    Arrays . asList ( paths )  )  ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollection"}, {"methodBody": ["METHOD_START", "{", "final   Callable   callable    =    context . mock ( Callable . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( callable )  . call (  )  ;", "will ( returnValue ( null )  )  ;", "}", "}  )  ;", ". from ( callable )  ;", "assertThat (  . getFiles (  )  ,    Matchers . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["callableCanReturnNull"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "collection . from (  \" src 1  \"  ,     \" src 2  \"  )  ;", "assertThat ( collection . getFrom (  )  ,    equalTo ( WrapUtil . toLinkedSet (  (  ( Object )     (  \" src 1  \"  )  )  ,     \" src 2  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddPathsToTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "DefaultConfigurableFileCollection   collection    =    new   DefaultConfigurableFileCollection ( resolverMock ,    taskResolverStub )  ;", "assertTrue ( collection . getFrom (  )  . isEmpty (  )  )  ;", "assertTrue ( collection . getFiles (  )  . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["canCreateEmptyCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( collection . getBuiltBy (  )  ,    Matchers . isEmpty (  )  )  ;", "collection . builtBy (  \" a \"  )  ;", "collection . builtBy (  \" b \"  )  ;", "collection . from (  \" f \"  )  ;", "assertThat ( collection . getBuiltBy (  )  ,    equalTo ( WrapUtil . toSet (  (  ( Object )     (  \" a \"  )  )  ,     \" b \"  )  )  )  ;", "collection . setBuiltBy ( WrapUtil . toList (  \" c \"  )  )  ;", "assertThat ( collection . getBuiltBy (  )  ,    equalTo ( WrapUtil . toSet (  (  ( Object )     (  \" c \"  )  )  )  )  )  ;", "final   Task   task    =    context . mock ( Task . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  \" f \"  )  ;", "will ( returnValue ( new   File (  \" f \"  )  )  )  ;", "allowing ( taskResolverStub )  . resolveTask (  \" c \"  )  ;", "will ( returnValue ( task )  )  ;", "}", "}  )  ;", "assertThat ( collection . getBuildDependencies (  )  . getDependencies ( null )  ,    equalTo (  (  ( Set )     ( WrapUtil . toSet ( task )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canGetAndSetTaskDependencies"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "collection . from (  \" ignore - me \"  )  ;", "collection . setFrom (  \" src 1  \"  ,     \" src 2  \"  )  ;", "assertThat ( collection . getFrom (  )  ,    equalTo ( WrapUtil . toLinkedSet (  (  ( Object )     (  \" src 1  \"  )  )  ,     \" src 2  \"  )  )  )  ;", "collection . setFrom ( WrapUtil . toList (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( collection . getFrom (  )  ,    equalTo ( WrapUtil . toLinkedSet (  (  ( Object )     ( WrapUtil . toList (  \" a \"  ,     \" b \"  )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canSetThePathsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "final   Callable   callable    =    context . mock ( Callable . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( callable )  . call (  )  ;", "will ( returnValue ( WrapUtil . toList (  \" src 1  \"  ,     \" src 2  \"  )  )  )  ;", "allowing ( resolverMock )  . resolve (  \" src 1  \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "allowing ( resolverMock )  . resolve (  \" src 2  \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", ". from ( callable )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseACallableToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "Closure   closure    =    TestUtil . returns (  ' a '  )  ;", "final   File   file    =    new   File (  \"  1  \"  )  ;", ". from ( closure )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( resolverMock )  . resolve (  ' a '  )  ;", "will ( returnValue ( file )  )  ;", "}", "}  )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseAClosureToSpecifyASingleFile"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  ' a '  )  ;", "will ( returnValue ( file 1  )  )  ;", "allowing ( resolverMock )  . resolve (  ' b '  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", "List < Character >    files    =    WrapUtil . toList (  ' a '  )  ;", "Closure   closure    =    TestUtil . returns ( files )  ;", ". from ( closure )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  )  )  )  ;", "files . add (  ' b '  )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseAClosureToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  \" src 1  \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "allowing ( resolverMock )  . resolve (  \" src 2  \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", "List < String >    files    =    WrapUtil . toList (  \" src 1  \"  )  ;", ". from ( files )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  )  )  )  ;", "files . add (  \" src 2  \"  )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseACollectionToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "final   Internal   src    =    context . mock ( Internal . class )  ;", "collection . from ( src )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( src )  . getFiles (  )  ;", "will ( returnValue ( WrapUtil . toLinkedSet ( file 1  )  )  )  ;", "}", "}  )  ;", "assertThat ( collection . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  )  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( src )  . getFiles (  )  ;", "will ( returnValue ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "}  )  ;", "assertThat ( collection . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseAFileCollectionToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  \" src 1  \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "allowing ( resolverMock )  . resolve (  \" src 2  \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", ". from (  (  ( Object )     ( WrapUtil . toArray (  \" src 1  \"  ,     \" src 2  \"  )  )  )  )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseAnArrayToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  \" src 1  \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "allowing ( resolverMock )  . resolve (  \" src 2  \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", ". from ( TestUtil . toClosure (  \"  {  [  {  [  ' src 1  '  ,     {     [  ' src 2  '  ]    as   String [  ]     }  ]  }  ]  }  \"  )  )  ;", "assertThat (  . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["canUseNestedObjectsToSpecifyTheContentsOfTheCollection"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "Closure   closure    =    TestUtil . returns ( null )  ;", ". from ( closure )  ;", "assertThat (  . getFiles (  )  ,    Matchers . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["closureCanReturnNull"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "collection . builtBy (  \" task \"  )  ;", "final   Task   task    =    context . mock ( Task . class )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( taskResolverStub )  . resolveTask (  \" task \"  )  ;", "will ( returnValue ( task )  )  ;", "}", "}  )  ;", "assertThat ( collection . getBuildDependencies (  )  . getDependencies ( null )  ,    equalTo (  (  ( Set )     ( WrapUtil . toSet ( task )  )  )  )  )  ;", "assertThat ( collection . getAsFileTree (  )  . getBuildDependencies (  )  . getDependencies ( null )  ,    equalTo (  (  ( Set )     ( WrapUtil . toSet ( task )  )  )  )  )  ;", "assertThat ( collection . getAsFileTree (  )  . matching ( TEST _ CLOSURE )  . getBuildDependencies (  )  . getDependencies ( null )  ,    equalTo (  (  ( Set )     ( WrapUtil . toSet ( task )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasSpecifiedDependenciesWhenEmpty"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCollectionResolveContext   resolveContext    =    context . mock ( FileCollectionResolveContext . class )  ;", "final   FileCollectionResolveContext   nestedContext    =    context . mock ( FileCollectionResolveContext . class )  ;", "final   FileCollection   fileCollectionMock    =    context . mock ( FileCollection . class )  ;", "collection . from (  \" file \"  )  ;", "collection . from ( fileCollectionMock )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( resolveContext )  . push ( resolverMock )  ;", "will ( returnValue ( nestedContext )  )  ;", "oneOf ( nestedContext )  . add ( collection . getFrom (  )  )  ;", "}", "}  )  ;", "collection . visitContents ( resolveContext )  ;", "}", "METHOD_END"], "methodName": ["resolveAddsEachSourceObjectAndBuildDependencies"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "collection    =    new    ( resolverMock ,    taskResolverStub ,    Arrays . asList (  \" a \"  ,     \" b \"  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( resolverMock )  . resolve (  \" a \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "oneOf ( resolverMock )  . resolve (  \" b \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", "assertThat ( collection . getFrom (  )  ,    equalTo ( WrapUtil . toLinkedSet (  (  ( Object )     (  \" a \"  )  )  ,     \" b \"  )  )  )  ;", "assertThat ( collection . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvesSpecifiedFilesUseFileResolver"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   File   file 1     =    new   File (  \"  1  \"  )  ;", "final   File   file 2     =    new   File (  \"  2  \"  )  ;", "collection    =    new    ( resolverMock ,    taskResolverStub ,    Arrays . asList (  \" src 1  \"  ,     \" src 2  \"  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "oneOf ( resolverMock )  . resolve (  \" src 1  \"  )  ;", "will ( returnValue ( file 1  )  )  ;", "oneOf ( resolverMock )  . resolve (  \" src 2  \"  )  ;", "will ( returnValue ( file 2  )  )  ;", "}", "}  )  ;", "assertThat ( collection . getFiles (  )  ,    equalTo ( WrapUtil . toLinkedSet ( file 1  ,    file 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolvesSpecifiedPathsUseFileResolver"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "NativeServicesTestFixture . initialize (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCollectionInternal   fileCollectionMock    =    context . mock ( FileCollectionInternal . class )  ;", "collection . from ( fileCollectionMock )  ;", "collection . from (  \" f \"  )  ;", "collection . builtBy (  \" b \"  )  ;", "final   Task   taskA    =    context . mock ( Task . class ,     \" a \"  )  ;", "final   Task   taskB    =    context . mock ( Task . class ,     \" b \"  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( resolverMock )  . resolve (  \" f \"  )  ;", "will ( returnValue ( new   File (  \" f \"  )  )  )  ;", "TaskDependency   dependency    =    context . mock ( TaskDependency . class )  ;", "allowing ( fileCollectionMock )  . getBuildDependencies (  )  ;", "will ( returnValue ( dependency )  )  ;", "allowing ( dependency )  . getDependencies ( null )  ;", "will ( returnValue ( WrapUtil . toSet ( taskA )  )  )  ;", "allowing ( taskResolverStub )  . resolveTask (  \" b \"  )  ;", "will ( returnValue ( taskB )  )  ;", "}", "}  )  ;", "assertThat ( collection . getBuildDependencies (  )  . getDependencies ( null )  ,    equalTo (  (  ( Set )     ( WrapUtil . toSet ( taskA ,    taskB )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["taskDependenciesContainsUnionOfDependenciesOfNestedFileCollectionsPlusOwnDependencies"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileCollectionTest"}, {"methodBody": ["METHOD_START", "{", "buildDependency . add ( tasks )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   fileCopier . copy ( new   Action < CopySpec >  (  )     {", "public   void   execute ( CopySpec   copySpec )     {", "copySpec . from (  . this )  ;", "ConfigureUtil . configure ( closure ,    copySpec )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "this . dir    =    dir ;", "return   this ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   buildDependency . getMutableValues (  )  ;", "}", "METHOD_END"], "methodName": ["getBuiltBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "if    (  ( dir )     =  =    null )     {", "throw   new   InvalidUserDataExcep (  \" A   base   directory   must   be   specified   in   the   task   or   via   a   method   argument !  \"  )  ;", "}", "return   resolver . resolve ( dir )  ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return    (  \" directory    '  \"     +     ( dir )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   patternSet . getExcludes (  )  ;", "}", "METHOD_END"], "methodName": ["getExcludes"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   patternSet . getIncludes (  )  ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   patternSet ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includeSpec )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "buildDependency . setValues ( tasks )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBuiltBy"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "from ( dir )  ;", "turn   this ;", "}", "METHOD_END"], "methodName": ["setDir"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . setExcludes ( excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExcludes"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "patternSet . setIncludes ( includes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIncludes"], "fileName": "org.gradle.api.internal.file.collections.DefaultConfigurableFileTree"}, {"methodBody": ["METHOD_START", "{", "return   instance ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.file.collections.DefaultDirectoryWalkerFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isJava 8 Compatible (  )  )     |  |     (  ( isJava 7 Compatible (  )  )     &  &     ( defaultEncodingContainsPlatformEncoding (  )  )  )  )     {", "return   new   Jdk 7 DirectoryWalker ( fileSystem )  ;", "} else    {", "return   new    ( fileSystem )  ;", "}", "}", "METHOD_END"], "methodName": ["createInstance"], "fileName": "org.gradle.api.internal.file.collections.DefaultDirectoryWalkerFactory"}, {"methodBody": ["METHOD_START", "{", "String   platformEncoding    =    System . getProperty (  \" sun . jnu . encoding \"  )  ;", "Charset   platformCharset    =     (  ( platformEncoding    !  =    null )     &  &     ( Charset . isSupported ( platformEncoding )  )  )     ?    Charset . forName ( platformEncoding )     :    null ;", "Charset   requiredCharset    =     ( platformCharset    !  =    null )     ?    platformCharset    :    Charsets . UTF _  8  ;", "return   Charset . dCharset (  )  . contains ( requiredCharset )  ;", "}", "METHOD_END"], "methodName": ["defaultEncodingContainsPlatformEncoding"], "fileName": "org.gradle.api.internal.file.collections.DefaultDirectoryWalkerFactory"}, {"methodBody": ["METHOD_START", "{", "this . instance    =    createInstance (  )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.gradle.api.internal.file.collections.DefaultDirectoryWalkerFactory"}, {"methodBody": ["METHOD_START", "{", "List < T >    result    =    new   ArrayList < T >  (  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "Object   element    =    queue . remove (  0  )  ;", "if    ( element   instanceof    )     {", "nestedContext    =     (  (  )     ( element )  )  ;", "converter . convertInto ( nestedContext ,    result ,    fileResolver )  ;", "} else", "if    ( element   instanceof   FileCollectionContainer )     {", "FileCollectionContainer   fileCollection    =     (  ( FileCollectionContainer )     ( element )  )  ;", "resolveNested ( fileCollection ,    result ,    converter )  ;", "} else", "if    (  ( element   instanceof   FileCollection )     |  |     ( element   instanceof   MinimalFileCollection )  )     {", "converter . convertInto ( element ,    result ,    fileResolver )  ;", "} else", "if    ( element   instanceof   Task )     {", "Task   task    =     (  ( Task )     ( element )  )  ;", "queue . add (  0  ,    task . getOutputs (  )  . getFiles (  )  )  ;", "} else", "if    ( element   instanceof   TaskOutputs )     {", "TaskOutputs   outputs    =     (  ( TaskOutputs )     ( element )  )  ;", "queue . add (  0  ,    outputs . getFiles (  )  )  ;", "} else", "if    ( element   instanceof   Callable )     {", "Callable   callable    =     (  ( Callable )     ( element )  )  ;", "Object   callableResult    =    uncheckedCall ( callable )  ;", "if    ( callableResult    !  =    null )     {", "queue . add (  0  ,    callableResult )  ;", "}", "} else", "if    ( element   instanceof   Provider )     {", "Provider   provider    =     (  ( Provider )     ( element )  )  ;", "Object   providerResult    =    provider . get (  )  ;", "queue . add (  0  ,    providerResult )  ;", "} else", "if    ( element   instanceof   Path )     {", "queue . add (  0  ,     (  ( Path )     ( element )  )  . toFile (  )  )  ;", "} else", "if    ( element   instanceof   Iterable )     {", "Iterable <  ?  >    iterable    =     (  ( Iterable )     ( element )  )  ;", "addToCollection ( queue . subList (  0  ,     0  )  ,    iterable )  ;", "} else", "if    ( element   instanceof   Object [  ]  )     {", "Object [  ]    array    =     (  ( Object [  ]  )     ( element )  )  ;", "addToCollection ( queue . subList (  0  ,     0  )  ,    asList ( array )  )  ;", "} else    {", "converter . convertInto ( element ,    result ,    fileResolver )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["doResolve"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileCollectionResolveContext ( fileResolver ,    fileCollectionConverter ,    fileTreeConverter )  ;", "}", "METHOD_END"], "methodName": ["newContext"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   doResolve ( fileCollectionConverter )  ;", "}", "METHOD_END"], "methodName": ["resolveAsFileCollections"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   doResolve ( fileTreeConverter )  ;", "}", "METHOD_END"], "methodName": ["resolveAsFileTrees"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   doResolve ( new   DefaultFileCollectionResolveContext . MinimalFileCollectionConverter (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveAsMinimalFileCollections"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "addTo    =    queue . subList (  0  ,     0  )  ;", "try    {", "f . visitContents ( this )  ;", "}    finally    {", "addTo    =    queue ;", "}", "}", "METHOD_END"], "methodName": ["resolveNested"], "fileName": "org.gradle.api.internal.file.collections.DefaultFileCollectionResolveContext"}, {"methodBody": ["METHOD_START", "{", "return    ( DirectoryTrees . contains ( fileSystem ,    this ,    file )  )     &  &     ( file . isFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "PatternSet   patternSet    =    this . patternSet . intersect (  )  ;", "patternSet . copyFrom ( patterns )  ;", "return   new    ( dir ,    patternSet ,    directoryWalkerFactory ,    fileSystem ,    postfix )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   dir ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "String   includes    =     ( patternSet . getIncludes (  )  . isEmpty (  )  )     ?     \"  \"     :    String . format (  \"    include    % s \"  ,    GUtil . toString ( patternSet . getIncludes (  )  )  )  ;", "String   excludes    =     ( patternSet . getExcludes (  )  . isEmpty (  )  )     ?     \"  \"     :    String . format (  \"    exclude    % s \"  ,    GUtil . toString ( patternSet . getExcludes (  )  )  )  ;", "return   String . format (  \" d    '  % s '  % s % s \"  ,    dir ,    includes ,    excludes )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singletonList ( this )  ;", "}", "METHOD_END"], "methodName": ["getLocalContents"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   patternSet ;", "}", "METHOD_END"], "methodName": ["getPatternSet"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   patternSet ;", "}", "METHOD_END"], "methodName": ["getPatterns"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   spec . isSatisfiedBy ( element )  ;", "}", "METHOD_END"], "methodName": ["isAllowed"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "if    ( postfix )     {", "return   this ;", "}", "return   new    ( dir ,    patternSet ,    directoryWalkerFactory ,    fileSystem ,    true )  ;", "}", "METHOD_END"], "methodName": ["postfix"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "RelativePath   path    =    new   RelativePath ( true ,    file . getName (  )  )  ;", "FileVisitDetails   details    =    new   DefaultFileVisitDetails ( file ,    path ,    stopFlag ,    fileSystem ,    fileSystem ,    false )  ;", "if    (  . isAllowed ( details ,    spec )  )     {", "visitor . visitFile ( details )  ;", "}", "}", "METHOD_END"], "methodName": ["processSingleFile"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "visitFrom ( visitor ,    dir ,    EMPTY _ ROOT )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "AtomicBoolean   stopFlag    =    new   AtomicBoolean (  )  ;", "Spec < FileTreeElement >    spec    =    patternSet . getAsSpec (  )  ;", "if    ( fileOrDirectory . exists (  )  )     {", "if    ( fileOrDirectory . isFile (  )  )     {", "processSingleFile ( fileOrDirectory ,    visitor ,    spec ,    stopFlag )  ;", "} else    {", "walkDir ( fileOrDirectory ,    path ,    visitor ,    spec ,    stopFlag )  ;", "}", "} else    {", ". LOGGER . info (  \" file   or   directory    '  {  }  '  ,    not   found \"  ,    fileOrDirectory )  ;", "}", "}", "METHOD_END"], "methodName": ["visitFrom"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "DirectoryWalker   directoryWalker ;", "if    (  ( visitor   instanceof   ReproducibleFileVisitor )     &  &     (  (  ( ReproducibleFileVisitor )     ( visitor )  )  . isReproducibleFileOrder (  )  )  )     {", "directoryWalker    =     . REPRODUCIBLE _ DIRECTORY _ WALKER ;", "} else    {", "directoryWalker    =    directoryWalkerFactory . create (  )  ;", "}", "directoryWalker . walkDir ( file ,    path ,    visitor ,    spec ,    stopFlag ,    postfix )  ;", "}", "METHOD_END"], "methodName": ["walkDir"], "fileName": "org.gradle.api.internal.file.collections.DirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =     ( tree . getDir (  )  . getAbsolutePath (  )  )     +     ( File . separator )  ;", "if    (  !  ( getAbsolutePath (  )  . startsWith ( prefix )  )  )     {", "return   false ;", "}", "RelativePath   path    =    RelativePath . parse ( true ,    getAbsolutePath (  )  . substring ( prefix . length (  )  )  )  ;", "return   tree . getPatterns (  )  . getAsSpec (  )  . isSatisfiedBy ( new   DefaultFileTreeElement (    path ,    ystem ,    ystem )  )  ;", "}", "METHOD_END"], "methodName": ["contains"], "fileName": "org.gradle.api.internal.file.collections.DirectoryTrees"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.file.collections.FileBackedDirectoryFileTree"}, {"methodBody": ["METHOD_START", "{", "return   fileCollection . getFiles (  )  ;", "}", "METHOD_END"], "methodName": ["getFiles"], "fileName": "org.gradle.api.internal.file.collections.FileCollectionAdapter"}, {"methodBody": ["METHOD_START", "{", "return   tree ;", "}", "METHOD_END"], "methodName": ["getTree"], "fileName": "org.gradle.api.internal.file.collections.FileTreeAdapter"}, {"methodBody": ["METHOD_START", "{", "tree . visit ( visitor )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.collections.FileTreeAdapter"}, {"methodBody": ["METHOD_START", "{", "tree . visitTreeOrBackingFile ( visitor )  ;", "}", "METHOD_END"], "methodName": ["visitTreeOrBackingFile"], "fileName": "org.gradle.api.internal.file.collections.FileTreeAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( files . length )     =  =     0  )     {", "return    . EMPTY ;", "}", "return   new    . FileOnly ( files )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.file.collections.ImmutableFileCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  ( paths . length )     =  =     0  )     {", "return    . EMPTY ;", "}", "return   new    . Resolving ( fileResolver ,    paths )  ;", "}", "METHOD_END"], "methodName": ["usingResolver"], "fileName": "org.gradle.api.internal.file.collections.ImmutableFileCollection"}, {"methodBody": ["METHOD_START", "{", "switch    ( files . size (  )  )     {", "case    0     :", "return    \" empty   file    \"  ;", "case    1     :", "return   String . format (  \" file    '  % s '  \"  ,    files . iterator (  )  . next (  )  )  ;", "default    :", "return   String . format (  \" files    % s \"  ,    GUtil . toString ( files )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.ListBackedFileSet"}, {"methodBody": ["METHOD_START", "{", "return   files ;", "}", "METHOD_END"], "methodName": ["getFiles"], "fileName": "org.gradle.api.internal.file.collections.ListBackedFileSet"}, {"methodBody": ["METHOD_START", "{", "Action < OutputStream >    action    =    ConfigureUtil . configureUsing ( contentClosure )  ;", "add ( path ,    action )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "elements . put ( RelativePath . parse ( true ,    path )  ,    contentWriter )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "return   path . getFile ( getTmpDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["createFileInstance"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "return    \" file   tree \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . collect ( elements . keySet (  )  ,    new   Transformer < File ,    RelativePath >  (  )     {", "@ Override", "public   File   transform ( RelativePath   relativePath )     {", "return   createFileInstance ( relativePath )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["getFilesWithoutCreating"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "return   directoryFileTreeFactory . create ( getTmpDir (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMirror"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "return   tmpDirSource . create (  )  ;", "}", "METHOD_END"], "methodName": ["getTmpDir"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "AtomicBoolean   stopFlag    =    new   AtomicBoolean (  )  ;", ". Visit   visit    =    new    . Visit ( visitor ,    stopFlag )  ;", "for    ( Map . Entry < RelativePath ,    Action < OutputStream >  >    entry    :    elements . entrySet (  )  )     {", "if    ( stopFlag . get (  )  )     {", "break ;", "}", "RelativePath   path    =    entry . getKey (  )  ;", "Action < OutputStream >    generator    =    entry . getValue (  )  ;", "visit . visit ( path ,    generator )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.collections.MapFileTree"}, {"methodBody": ["METHOD_START", "{", "Action < OutputStream >    action    =    getAction (  )  ;", "tree . add (  \" path / file . txt \"  ,    action )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  )  ;", "rootDir . file (  \" path \"  )  . assertIsDir (  )  ;", "rootDir . file (  \" path / file . txt \"  )  . assertContents ( equalTo (  \" content \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddAnElementUsingAClosureToGeneratedContent"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "Action < OutputStream >    action    =    getAction (  )  ;", "tree . add (  \" path / file . txt \"  ,    action )  ;", "tree . add (  \" file . txt \"  ,    action )  ;", "tree . add (  \" path / subdir / file . txt \"  ,    action )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  ,     \" file . txt \"  ,     \" path / subdir / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  ,     \" path / subdir \"  )  )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    WrapUtil . toList (  \" path / file . txt \"  ,     \" file . txt \"  ,     \" path / subdir / file . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddMultipleElementsInDifferentDirs"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "Action < OutputStream >    closure    =    getAction (  )  ;", "tree . add (  \" path / file . txt \"  ,    closure )  ;", "tree . add (  \" file . txt \"  ,    closure )  ;", "FileVisitorUtil . assertCanStopVisiting ( tree )  ;", "}", "METHOD_END"], "methodName": ["canStopVisitingElements"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   AtomicInteger   callCounter    =    new   AtomicInteger (  0  )  ;", "Action < OutputStream >    fileAction    =    new   Action < OutputStream >  (  )     {", "@ Override", "public   void   execute ( OutputStream   outputStream )     {", "callCounter . incrementAndGet (  )  ;", "}", "}  ;", "tree . add (  \" file . txt \"  ,    fileAction )  ;", "Adapter   fileTreeAdapter    =    new   Adapter ( tree )  ;", "File   file    =    rootDir . file (  \" file . txt \"  )  ;", "assertTrue ( fileTreeAdapter . contains ( file )  )  ;", "assertTrue ( fileTreeAdapter . contains ( file )  )  ;", "assertFalse ( fileTreeAdapter . contains ( rootDir . file (  \" file 2  . txt \"  )  )  )  ;", "assertEquals (  0  ,    callCounter . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["containsWontCreateFiles"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "Action < OutputStream >    action    =    getAction (  )  ;", "tree . add (  \" path / file . txt \"  ,    action )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  )  )  ;", "TestFile   file    =    rootDir . file (  \" path / file . txt \"  )  ;", "file . assertContents ( equalTo (  \" content \"  )  )  ;", "file . makeOlder (  )  ;", "TestFile . Snapshot   snapshot    =    file . snapshot (  )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  )  )  ;", "file . assertContents ( equalTo (  \" content \"  )  )  ;", "file . assertHasNotChangedSince ( snapshot )  ;", "}", "METHOD_END"], "methodName": ["doesNotOverwriteFileWhenGeneratedContentRemainsTheSame"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "return   new   Action < OutputStream >  (  )     {", "public   void   execute ( OutputStream   outputStream )     {", "try    {", "outputStream . write (  \" content \"  . getBytes (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getAction"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    emptyList    =    WrapUtil . toList (  )  ;", "VisitorUtil . assertVisits ( tree ,    emptyList ,    emptyList )  ;", "AntBuilderAwareUtil . assertSetContainsForAllTypes ( tree ,    emptyList )  ;", "}", "METHOD_END"], "methodName": ["isEmptyByDefault"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "final   AtomicReference < String >    currentContentReference    =    new   AtomicReference < String >  (  \" content \"  )  ;", "tree . add (  \" path / file . txt \"  ,    new   Action < OutputStream >  (  )     {", "@ Override", "public   void   execute ( OutputStream   outputStream )     {", "try    {", "outputStream . write ( currentContentReference . get (  )  . getBytes (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  )  )  ;", "TestFile   file    =    rootDir . file (  \" path / file . txt \"  )  ;", "file . assertContents ( equalTo (  \" content \"  )  )  ;", "TestFile . Snapshot   snapshot    =    file . snapshot (  )  ;", "currentContentReference . set (  \" updated   content \"  )  ;", "FileVisitorUtil . assertVisits ( tree ,    WrapUtil . toList (  \" path / file . txt \"  )  ,    WrapUtil . toList (  \" path \"  )  )  ;", "file . assertContents ( equalTo (  \" updated   content \"  )  )  ;", "file . assertHasChangedSince ( snapshot )  ;", "}", "METHOD_END"], "methodName": ["overwritesFileWhenGeneratedContentChanges"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "NativeServicesTestFixture . initialize (  )  ;", "tree    =    new    ( rootDir ,    TestFiles . fileSystem (  )  ,    TestFiles . directoryFileTreeFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.gradle.api.internal.file.collections.MapFileTreeTest"}, {"methodBody": ["METHOD_START", "{", "if    ( stopFlag . get (  )  )     {", "return ;", "}", "String   segment    =    patternSegments . get ( segmentIndex )  ;", "if    ( segment . contains (  \"  *  *  \"  )  )     {", "PatternSet   patternSet    =    new   PatternSet (  )  ;", "patternSet . include ( includePattern )  ;", "patternSet . exclude ( excludeSpec )  ;", "DirectoryFileTree   fileTree    =    new   DirectoryFileTree ( baseDir ,    patternSet ,    fileSystem )  ;", "fileTree . visitFrom ( visitor ,    file ,    new   RelativePath ( file . isFile (  )  ,    relativePath . toArray ( new   String [ relativePath . size (  )  ]  )  )  )  ;", "} else", "if    (  ( segment . contains (  \"  *  \"  )  )     |  |     ( segment . contains (  \"  ?  \"  )  )  )     {", "pattern . PatternStep   step    =    pattern . PatternStepFactory . getStep ( segment ,    false )  ;", "File [  ]    children    =    file . listFiles (  )  ;", "if    ( children    =  =    null )     {", "if    (  !  ( file . canRead (  )  )  )     {", "throw   new   GradleException ( String . format (  \" Could   not   list   contents   of   directory    '  % s '    as   it   is   not   readable .  \"  ,    file )  )  ;", "}", "throw   new   GradleException ( String . format (  \" Could   not   list   contents   of    '  % s '  .  \"  ,    file )  )  ;", "}", "for    ( File   child    :    children )     {", "if    ( stopFlag . get (  )  )     {", "break ;", "}", "String   childName    =    child . getName (  )  ;", "if    ( step . matches ( childName )  )     {", "relativePath . addLast ( childName )  ;", "doVisitDirOrFile ( visitor ,    child ,    relativePath ,     ( segmentIndex    +     1  )  ,    stopFlag )  ;", "relativePath . removeLast (  )  ;", "}", "}", "} else    {", "relativePath . addLast ( segment )  ;", "doVisitDirOrFile ( visitor ,    new   File ( file ,    segment )  ,    relativePath ,     ( segmentIndex    +     1  )  ,    stopFlag )  ;", "relativePath . removeLast (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doVisit"], "fileName": "org.gradle.api.internal.file.collections.SingleIncludePatternFileTree"}, {"methodBody": ["METHOD_START", "{", "if    ( file . isFile (  )  )     {", "if    ( segmentIndex    =  =     ( pSegments . size (  )  )  )     {", "RelativePath   path    =    new   RelativePath ( true ,    relativePath . toArray ( new   String [ relativePath . size (  )  ]  )  )  ;", "FileVisitDetails   details    =    new   DefaultFileVisitDetails ( file ,    path ,    stopFlag ,    fileSystem ,    fileSystem )  ;", "if    (  !  ( excludeSpec . isSatisfiedBy ( details )  )  )     {", "visitor . visitFile ( details )  ;", "}", "}", "} else", "if    ( file . isDirectory (  )  )     {", "RelativePath   path    =    new   RelativePath ( false ,    relativePath . toArray ( new   String [ relativePath . size (  )  ]  )  )  ;", "FileVisitDetails   details    =    new   DefaultFileVisitDetails ( file ,    path ,    stopFlag ,    fileSystem ,    fileSystem )  ;", "if    (  !  ( excludeSpec . isSatisfiedBy ( details )  )  )     {", "visitor . visitDir ( details )  ;", "}", "if    ( segmentIndex    <     ( pSegments . size (  )  )  )     {", "doVisit ( visitor ,    file ,    relativePath ,    segmentIndex ,    stopFlag )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doVisitDirOrFile"], "fileName": "org.gradle.api.internal.file.collections.SingleIncludePatternFileTree"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" directory    '  \"     +     ( baseDir )  )     +     \"  '    include    '  \"  )     +     ( includePattern )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.SingleIncludePatternFileTree"}, {"methodBody": ["METHOD_START", "{", "doVisit ( visitor ,    baseDir ,    new   LinkedList < String >  (  )  ,     0  ,    new   AtomicBoolean (  )  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.collections.SingleIncludePatternFileTree"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" file    '  % s '  \"  ,    file )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.collections.SingletonFileTree"}, {"methodBody": ["METHOD_START", "{", "visitor . visitFile ( new   DefaultFileVisitDetails ( file ,    fileSystem ,    fileSystem )  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.collections.SingletonFileTree"}, {"methodBody": ["METHOD_START", "{", "return   spec . isSatisfiedBy ( element )  ;", "}", "METHOD_END"], "methodName": ["isAllowed"], "fileName": "org.gradle.api.internal.file.collections.jdk7.Jdk7DirectoryWalker"}, {"methodBody": ["METHOD_START", "{", "final   CopyAction   effectiveVisitor    =    new   DuplicateHandlingCopyActionDecorator ( new   NormalizingCopyActionDecorator ( action ,    fileSystem )  )  ;", "CopyActionProcessingStream   processingStream    =    new   CopySpecBackedCopyActionProcessingStream ( spec ,    instantiator ,    fileSystem ,    reproducibleFileOrder )  ;", "return   effectiveVisitor . execute ( processingStream )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.CopyActionExecuter"}, {"methodBody": ["METHOD_START", "{", "return   visitor . execute ( new   CopyActionProcessingStream (  )     {", "public   void   process ( CopyActionProcessingStreamAction   action )     {", "for    ( FileCopyDetailsInternal   detailsInternal    :    detailses )     {", "action . processFile ( detailsInternal )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.copy.CopyActionExecuterUtil"}, {"methodBody": ["METHOD_START", "{", "return   CopyActionExecuterUtil . visit ( visitor ,    Arrays . asList ( detailses )  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.api.internal.file.copy.CopyActionExecuterUtil"}, {"methodBody": ["METHOD_START", "{", "return   instantiator . newInstance ( DefaultFileCopyDetails . class ,    visitDetails ,    copySpecResolver ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["createDefaultFileCopyDetails"], "fileName": "org.gradle.api.internal.file.copy.CopyFileVisitorImpl"}, {"methodBody": ["METHOD_START", "{", "DefaultFileCopyDetails   details    =    createDefaultFileCopyDetails ( visitDetails )  ;", "action . processFile ( details )  ;", "}", "METHOD_END"], "methodName": ["processDir"], "fileName": "org.gradle.api.internal.file.copy.CopyFileVisitorImpl"}, {"methodBody": ["METHOD_START", "{", "DefaultFileCopyDetails   details    =    createDefaultFileCopyDetails ( visitDetails )  ;", "for    ( Action <  ?    super   FileCopyDetails >    action    :    copySpecResolver . getAllCopyActions (  )  )     {", "action . execute ( details )  ;", "if    ( details . isExcluded (  )  )     {", "return ;", "}", "}", "action . processFile ( details )  ;", "}", "METHOD_END"], "methodName": ["processFile"], "fileName": "org.gradle.api.internal.file.copy.CopyFileVisitorImpl"}, {"methodBody": ["METHOD_START", "{", "processDir ( dirDetails )  ;", "}", "METHOD_END"], "methodName": ["visitDir"], "fileName": "org.gradle.api.internal.file.copy.CopyFileVisitorImpl"}, {"methodBody": ["METHOD_START", "{", "processFile ( fileDetails )  ;", "}", "METHOD_END"], "methodName": ["visitFile"], "fileName": "org.gradle.api.internal.file.copy.CopyFileVisitorImpl"}, {"methodBody": ["METHOD_START", "{", "FileTree   source    =    specResolver . getSource (  )  ;", "source . visit ( new   CopyFileVisitorImpl ( specResolver ,    a ,    instantiator ,    fileSystem ,    reproducibleFileOrder )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.CopySpecActionImpl"}, {"methodBody": ["METHOD_START", "{", "spec . walk ( new   CopySpecActionImpl ( action ,    instantiator ,    fileSystem ,    reproducibleFileOrder )  )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.api.internal.file.copy.CopySpecBackedCopyActionProcessingStream"}, {"methodBody": ["METHOD_START", "{", "DefaultCopySpec   child    =    instantiator . newInstance ( SingleParentCopySpec . class ,    fileResolver ,    instantiator ,    buildRootResolver (  )  )  ;", "addChildSpec ( position ,    child )  ;", "return   child ;", "}", "METHOD_END"], "methodName": ["addChildAtPosition"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "childSpecs . add ( index ,    childSpec )  ;", "final   int   additionIndex    =    childSpecsInAdditionOrder . size (  )  ;", "childSpecsInAdditionOrder . add ( childSpec )  ;", "childSpec . addChildSpecListener ( new   CopySpecInternal . CopySpecListener (  )     {", "@ Override", "public   void   childSpecAdded ( CopySpecInternal . CopySpecAddress   path ,    CopySpecInternal   spec )     {", "CopySpecInternal . CopySpecAddress   childPath    =    newAddress ( null ,  . this ,    additionIndex )  . append ( path )  ;", "fireChildSpecListeners ( childPath ,    spec )  ;", "}", "}  )  ;", "childSpec . visit ( newAddress ( null ,    this ,    additionIndex )  ,    new   CopySpecInternal . CopySpecVisitor (  )     {", "@ Override", "public   void   visit ( final   CopySpecInternal . CopySpecAddress   parentPath ,    CopySpecInternal   spec )     {", "fireChildSpecListeners ( parentPath ,    spec )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["addChildSpec"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "addChildSpec ( childSpecs . size (  )  ,    childSpec )  ;", "}", "METHOD_END"], "methodName": ["addChildSpec"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "hasCustomActions    =    true ;", "Actions . add ( action )  ;", "}", "METHOD_END"], "methodName": ["appendCopyAction"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "for    ( CopySpecInternal . CopySpecListener   listener    :    listeners )     {", "listener . childSpecAdded ( path ,    spec )  ;", "}", "}", "METHOD_END"], "methodName": ["fireChildSpecListeners"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "return   copyActions ;", "}", "METHOD_END"], "methodName": ["getCopyActions"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "return   sourcePaths ;", "}", "METHOD_END"], "methodName": ["getSourcePaths"], "fileName": "org.gradle.api.internal.file.copy.DefaultCopySpec"}, {"methodBody": ["METHOD_START", "{", "int   specMode    =    getMode (  )  ;", "getChmod (  )  . chmod ( target ,    specMode )  ;", "}", "METHOD_END"], "methodName": ["adaptPermissions"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    ( filterChain . hasFilters (  )  )     {", "return   super . copyTo ( target )  ;", "} else    {", "final   boolean   copied    =    file . copyTo ( target )  ;", "adaptPermissions ( target )  ;", "return   copied ;", "}", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    ( filterChain . hasFilters (  )  )     {", "super . copyTo ( output )  ;", "} else    {", "file . copyTo ( output )  ;", "}", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "excluded    =    true ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "filterChain . expand ( properties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   filter ( new   ClosureBackedTransformer ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "filterChain . add ( filterType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "filterChain . add ( filterType ,    properties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["filter"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   fileDetails . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   this . duplicatesStrategy ;", "}", "METHOD_END"], "methodName": ["getDuplicatesStrategy"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    ( filterChain . hasFilters (  )  )     {", "throw   new   UnsupportedOperationException (  )  ;", "} else    {", "return   file . getFile (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   fileDetails . getLastModified (  )  ;", "}", "METHOD_END"], "methodName": ["getLastModified"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mode )     !  =    null )     {", "return   mode ;", "}", "Integer   specMode    =    getSpecMode (  )  ;", "if    ( specMode    !  =    null )     {", "return   specMode ;", "}", "return   file . getMode (  )  ;", "}", "METHOD_END"], "methodName": ["getMode"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    (  ( relativePath )     =  =    null )     {", "RelativePath   path    =    file . getRelativePath (  )  ;", "relativePath    =    specResolver . getDestPath (  )  . append ( path . isFile (  )  ,    path . getSegments (  )  )  ;", "}", "return   relativePath ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   this . fileDetails . getRelativePath (  )  ;", "}", "METHOD_END"], "methodName": ["getRelativeSourcePath"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    ( filterChain . hasFilters (  )  )     {", ". ByteCountingOutputStream   outputStream    =    new    . ByteCountingOutputStream (  )  ;", "copyTo ( outputStream )  ;", "return   outputStream . size ;", "} else    {", "return   fileDetails . getSize (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSize"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   this . fileDetails . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getSourceName"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   this . fileDetails . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getSourcePath"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   fileDetails . isDirectory (  )     ?    specResolver . getDirMode (  )     :    specResolver . getFileMode (  )  ;", "}", "METHOD_END"], "methodName": ["getSpecMode"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   fileDetails . isDirectory (  )  ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   excluded ;", "}", "METHOD_END"], "methodName": ["isExcluded"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "return   specResolver . getIncludeEmptyDirs (  )  ;", "}", "METHOD_END"], "methodName": ["isIncludeEmptyDirs"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "if    ( filterChain . hasFilters (  )  )     {", "return   filterChain . transform ( file . open (  )  )  ;", "} else    {", "return   file . open (  )  ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "this . duplicatesStrategy    =    strategy ;", "}", "METHOD_END"], "methodName": ["setDuplicatesStrategy"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "this . mode    =    mode ;", "}", "METHOD_END"], "methodName": ["setMode"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "relativePath    =    getRelativePath (  )  . replaceLastName ( name )  ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "relativePath    =    RelativePath . parse ( getRelativePath (  )  . isFile (  )  ,    path )  ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "this . relativePath    =    path ;", "}", "METHOD_END"], "methodName": ["setRelativePath"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "fileDetails . stopVisiting (  )  ;", "}", "METHOD_END"], "methodName": ["stopVisiting"], "fileName": "org.gradle.api.internal.file.copy.DefaultFileCopyDetails"}, {"methodBody": ["METHOD_START", "{", "ZipOutputStream   outStream    =    new   ZipOutputStream ( destination )  ;", "try    {", "outStream . setUseZip 6  4  ( zip 6  4 Mode )  ;", "outStream . setMethod ( entryionMethod )  ;", "return   outStream ;", "}    catch    ( Exception   e )     {", "IOUtils . closeQuietly ( outStream )  ;", "String   message    =    String . format (  \" Unable   to   create   ZIP   output   stream   for   file    % s .  \"  ,    destination )  ;", "throw   new   UncheckedIOException ( message ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["createArchiveOutputStream"], "fileName": "org.gradle.api.internal.file.copy.DefaultZipCompressor"}, {"methodBody": ["METHOD_START", "{", "return    ( destinationDir )     =  =    null    ?    null    :    fileResolver . resolve ( destinationDir )  ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.internal.file.copy.DestinationRootCopySpec"}, {"methodBody": ["METHOD_START", "{", "final   Set < RelativePath >    visitedFiles    =    new   HashSet < RelativePath >  (  )  ;", "return   delegate . execute ( new   CopyActionProcessingStream (  )     {", "public   void   process ( final   CopyActionProcessingStreamAction   action )     {", "stream . process ( new   CopyActionProcessingStreamAction (  )     {", "public   void   processFile ( FileCopyDetailsInternal   details )     {", "if    (  !  ( details . isDirectory (  )  )  )     {", "DuplicatesStrategy   strategy    =    details . getDuplicatesStrategy (  )  ;", "if    (  !  ( visitedFiles . add ( details . getRelativePath (  )  )  )  )     {", "if    ( strategy    =  =     ( DuplicatesStrategy . EXCLUDE )  )     {", "return ;", "} else", "if    ( strategy    =  =     ( DuplicatesStrategy . FAIL )  )     {", "throw   new   DuplicateFileCopyingException ( String . format (  \" Encountered   duplicate   path    \\  \"  % s \\  \"    during   copy   operation   configured   with   DuplicatesStrategy . FAIL \"  ,    details . getRelativePath (  )  )  )  ;", "} else", "if    ( strategy    =  =     ( DuplicatesStrategy . WARN )  )     {", ". LOGGER . warn (  \" Encountered   duplicate   path    \\  \"  {  }  \\  \"    during   copy   operation   configured   with   DuplicatesStrategy . WARN \"  ,    details . getRelativePath (  )  )  ;", "}", "}", "}", "action . processFile ( details )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.DuplicateHandlingCopyActionDecorator"}, {"methodBody": ["METHOD_START", "{", "DestinationRootCopySpec   copySpec    =    createCopySpec ( action )  ;", "File   destinationDir    =    copySpec . getDestinationDir (  )  ;", "return   doCopy ( copySpec ,    getCopyVisitor ( destinationDir )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.api.internal.file.copy.FileCopier"}, {"methodBody": ["METHOD_START", "{", "DefaultCopySpec   copySpec    =    new   DefaultCopySpec ( this . fileResolver ,    instantiator )  ;", "DestinationRootCopySpec   destinationRootCopySpec    =    new   DestinationRootCopySpec ( fileResolver ,    copySpec )  ;", "CopySpec   wrapped    =    instantiator . newInstance ( CopySpecWrapper . class ,    destinationRootCopySpec )  ;", "action . execute ( wrapped )  ;", "return   destinationRootCopySpec ;", "}", "METHOD_END"], "methodName": ["createCopySpec"], "fileName": "org.gradle.api.internal.file.copy.FileCopier"}, {"methodBody": ["METHOD_START", "{", "CopyActionExecuter   visitorDriver    =    new   CopyActionExecuter ( instantiator ,    fileLookup . getFileSystem (  )  ,    false )  ;", "return   visitorDriver . execute ( copySpec ,    visitor )  ;", "}", "METHOD_END"], "methodName": ["doCopy"], "fileName": "org.gradle.api.internal.file.copy.FileCopier"}, {"methodBody": ["METHOD_START", "{", "return   new   FileCopyAction ( fileLookup . getFileResolver ( destination )  )  ;", "}", "METHOD_END"], "methodName": ["getCopyVisitor"], "fileName": "org.gradle.api.internal.file.copy.FileCopier"}, {"methodBody": ["METHOD_START", "{", "DestinationRootCopySpec   copySpec    =    createCopySpec ( action )  ;", "File   destinationDir    =    copySpec . getDestinationDir (  )  ;", "return   doCopy ( copySpec ,    new   SyncCopyActionDecorator ( destinationDir ,    getCopyVisitor ( destinationDir )  ,    directoryFileTreeFactory )  )  ;", "}", "METHOD_END"], "methodName": ["sync"], "fileName": "org.gradle.api.internal.file.copy.FileCopier"}, {"methodBody": ["METHOD_START", "{", "FileCopyAction . FileCopyDetailsInternalAction   action    =    new   FileCopyAction . FileCopyDetailsInternalAction (  )  ;", "stream . process ( action )  ;", "return   WorkResults . didWork ( action . didWork )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.FileCopyAction"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   details    =    context . mock ( FileCopyDetailsInternal . class ,    relativePath . getPathString (  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( details )  . getRelativePath (  )  ;", "will ( returnValue ( relativePath )  )  ;", "one ( details )  . copyTo ( targetFile )  ;", "}", "}  )  ;", "return   details ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.api.internal.file.copy.FileCopyActionTest"}, {"methodBody": ["METHOD_START", "{", "FileCopyAction   visitor    =    new   FileCopyAction ( TestFiles . resolver ( destDir )  )  ;", "CopyActionExecuterUtil . visit ( visitor ,    file ( new   RelativePath ( true ,     \" rootfile . txt \"  )  ,    new   File ( destDir ,     \" rootfile . txt \"  )  )  ,    file ( new   RelativePath ( true ,     \" subdir \"  ,     \" anotherfile . txt \"  )  ,    new   File ( destDir ,     \" subdir / anotherfile . txt \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["plainCopy"], "fileName": "org.gradle.api.internal.file.copy.FileCopyActionTest"}, {"methodBody": ["METHOD_START", "{", "destDir    =    tmpDir . getTestDirectory (  )  . file (  \" dest \"  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.file.copy.FileCopyActionTest"}, {"methodBody": ["METHOD_START", "{", "add ( new   ClosureBackedTransformer ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "add ( filterType ,    null )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "transformers . add ( new   Transformer < Reader ,    Reader >  (  )     {", "public   Reader   transform ( Reader   original )     {", "try    {", "Constructor <  ?    extends   FilterReader >    constructor    =    filterType . getConstructor ( Reader . class )  ;", "FilterReader   result    =    constructor . newInstance ( original )  ;", "if    ( properties    !  =    null )     {", "ConfigureUtil . configureByMap ( properties ,    result )  ;", "}", "return   result ;", "}    catch    ( Throwable   th )     {", "throw   new   InvalidUserDataException (  (  \" Error    -    Invalid   filter   specification   for    \"     +     ( filterType . getName (  )  )  )  ,    th )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "transformers . add ( new   Transformer < Reader ,    Reader >  (  )     {", "@ Override", "public   Reader   transform ( Reader   reader )     {", "return   new   LineFilter ( reader ,    transformer )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "transformers . add ( new   Transformer < Reader ,    Reader >  (  )     {", "public   Reader   transform ( Reader   original )     {", "try    {", "Template   template ;", "try    {", "SimpleTemplateEngine   engine    =    new   SimpleTemplateEngine (  )  ;", "template    =    engine . createTemplate ( original )  ;", "}    finally    {", "original . close (  )  ;", "}", "StringWriter   writer    =    new   StringWriter (  )  ;", "template . make ( properties )  . writeTo ( writer )  ;", "return   new   StringReader ( writer . toString (  )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["expand"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "return   transformers . hasTransformers (  )  ;", "}", "METHOD_END"], "methodName": ["hasFilters"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   ReaderInputStream ( transform ( new   InputStreamReader ( origi ,    charset )  )  ,    charset )  ;", "}    catch    ( UnsupportedEncodingException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "return   transformers . transform ( original )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.file.copy.FilterChain"}, {"methodBody": ["METHOD_START", "{", "filterChain . expand ( WrapUtil . toMap (  \" prop \"  ,     1  )  )  ;", "Reader   transformedReader    =    filterChain . transform ( new   StringReader (  \"  [  $ prop ]  [  $  { prop +  1  }  ]  [  <  %  =    prop +  2     %  >  ]  \"  )  )  ;", "assertThat ( IOUtils . toString ( transformedReader )  ,    equalTo (  \"  [  1  ]  [  2  ]  [  3  ]  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddExpandFilterToEndOfChain"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "filterChain . add ( FilterChainTest . TestFilterReader . class )  ;", "Reader   transformedReader    =    filterChain . transform ( originalReader )  ;", "assertThat ( transformedReader ,    instanceOf ( FilterChainTest . TestFilterReader . class )  )  ;", "FilterChainTest . TestFilterReader   reader    =     (  ( FilterChainTest . TestFilterReader )     ( transformedReader )  )  ;", "assertThat ( reader . getIn (  )  ,    sameInstance ( originalReader )  )  ;", "}", "METHOD_END"], "methodName": ["canAddFilterReaderToEndOfChain"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "filterChain . add ( FilterChainTest . TestFilterReader . class ,    WrapUtil . toMap (  \" property \"  ,     \" value \"  )  )  ;", "Reader   transformedReader    =    filterChain . transform ( originalReader )  ;", "assertThat ( transformedReader ,    instanceOf ( FilterChainTest . TestFilterReader . class )  )  ;", "FilterChainTest . TestFilterReader   reader    =     (  ( FilterChainTest . TestFilterReader )     ( transformedReader )  )  ;", "assertThat ( reader . getIn (  )  ,    sameInstance ( originalReader )  )  ;", "assertThat ( reader . property ,    equalTo (  \" value \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canAddFilterReaderWithParametersToEndOfChain"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "filterChain . add ( TEST _ CLOSURE )  ;", "Reader   transformedReader    =    filterChain . transform ( originalReader )  ;", "assertThat ( transformedReader ,    instanceOf ( LineFilter . class )  )  ;", "}", "METHOD_END"], "methodName": ["canAddLineFilterReaderToEndOfChain"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "FilterChain   filterChainWithCharset    =    new   FilterChain ( charset )  ;", "filterChainWithCharset . expand ( WrapUtil . toMap (  \" prop \"  ,     1  )  )  ;", "byte [  ]    source    =     \"  \u00a8\u00a6  \u00a8\u00a4  \u00a8\u00b9  ?     $ prop \"  . getBytes ( charset )  ;", "InputStream   transformedInputStream    =    filterChainWithCharset . transform ( new   ByteArrayInputStream ( source )  )  ;", "String   actualResult    =    new   String ( ByteStreams . toByteArray ( transformedInputStream )  ,    charset )  ;", "String   expectedResult    =     \"  \u00a8\u00a6  \u00a8\u00a4  \u00a8\u00b9  ?     1  \"  ;", "assertThat ( actualResult ,    equalTo ( expectedResult )  )  ;", "}", "METHOD_END"], "methodName": ["canFilterUsingCharset"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "canFilterUsingCharset (  \" ISO _  8  8  5  9  _  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["canFilterUsingISO88591"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "canFilterUsingCharset (  \" UTF 8  \"  )  ;", "}", "METHOD_END"], "methodName": ["canFilterUsingUTF8"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( filterChain . transform ( originalReader )  ,    sameInstance ( originalReader )  )  ;", "}", "METHOD_END"], "methodName": ["usesOriginalReaderByDefault"], "fileName": "org.gradle.api.internal.file.copy.FilterChainTest"}, {"methodBody": ["METHOD_START", "{", "in . close (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.api.internal.file.copy.LineFilter"}, {"methodBody": ["METHOD_START", "{", "while    (  (  ( state )     =  =     ( LineFilter . State . SKIP _ LINE )  )     |  |     (  (  ( state )     =  =     ( LineFilter . State . NORMAL )  )     &  &     (  (  ( transformedLine )     =  =    null )     |  |     (  ( transformedIndex )     >  =     ( transformedLine . length (  )  )  )  )  )  )     {", "readTransformedLine (  )  ;", "transformedIndex    =     0  ;", "}", "}", "METHOD_END"], "methodName": ["ensureData"], "fileName": "org.gradle.api.internal.file.copy.LineFilter"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   line    =    new   StringBuilder (  )  ;", "boolean   eol    =    false ;", "int   ch ;", "while    (  (  ! eol )     &  &     (  ( ch    =    bufferedIn . read (  )  )     >  =     0  )  )     {", "if    ( ch    =  =     '  \\ n '  )     {", "eol    =    true ;", "} else", "if    ( ch    =  =     '  \\ r '  )     {", "eol    =    true ;", "bufferedIn . mark (  1  )  ;", "if    (  ( bufferedIn . read (  )  )     !  =     '  \\ n '  )     {", "bufferedIn . reset (  )  ;", "}", "} else    {", "line . append (  (  ( char )     ( ch )  )  )  ;", "}", "}", "if    (  (  ( line . length (  )  )     =  =     0  )     &  &     (  ! eol )  )     {", "state    =     . State . EOF ;", "return ;", "}", "String   result    =    transformer . transform ( line . toString (  )  )  ;", "if    ( result    =  =    null )     {", "state    =     . State . SKIP _ LINE ;", "return ;", "}", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append ( result )  ;", "if    ( eol )     {", "builder . append ( SystemProperties . getInstance (  )  . getLineSeparator (  )  )  ;", "}", "state    =     . State . NORMAL ;", "transformedLine    =    builder . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readTransformedLine"], "fileName": "org.gradle.api.internal.file.copy.LineFilter"}, {"methodBody": ["METHOD_START", "{", "if    ( matchSpec . isSatisfiedBy ( details . getRelativeSourcePath (  )  )  )     {", "toApply . execute ( details )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.MatchingCopyAction"}, {"methodBody": ["METHOD_START", "{", "final   Set < RelativePath >    visitedDirs    =    new   HashSet < RelativePath >  (  )  ;", "final   ListMultimap < RelativePath ,    FileCopyDetailsInternal >    pendingDirs    =    ArrayListMultimap . create (  )  ;", "WorkResult   result    =    delegate . execute ( new   CopyActionProcessingStream (  )     {", "public   void   process ( final   CopyActionProcessingStreamAction   action )     {", "stream . process ( new   CopyActionProcessingStreamAction (  )     {", "public   void   processFile ( FileCopyDetailsInternal   details )     {", "if    ( details . isDirectory (  )  )     {", "RelativePath   path    =    details . getRelativePath (  )  ;", "if    (  !  ( visitedDirs . contains ( path )  )  )     {", "pendingDirs . put ( path ,    details )  ;", "}", "} else    {", "maybeVisit ( details . getRelativePath (  )  . getParent (  )  ,    details . isIncludeEmptyDirs (  )  ,    action )  ;", "action . processFile ( details )  ;", "}", "}", "}  )  ;", "for    ( RelativePath   path    :    new   LinkedHashSet < RelativePath >  ( pendingDirs . keySet (  )  )  )     {", "List < FileCopyDetailsInternal >    detailsList    =    new   ArrayList < FileCopyDetailsInternal >  ( pendingDirs . get ( path )  )  ;", "for    ( FileCopyDetailsInternal   details    :    detailsList )     {", "if    ( details . isIncludeEmptyDirs (  )  )     {", "maybeVisit ( path ,    details . isIncludeEmptyDirs (  )  ,    action )  ;", "}", "}", "}", "visitedDirs . clear (  )  ;", "pendingDirs . clear (  )  ;", "}", "private   void   maybeVisit ( RelativePath   path ,    boolean   includeEmptyDirs ,    CopyActionProcessingStreamAction   delegateAction )     {", "if    (  (  ( path    =  =    null )     |  |     (  ( path . getParent (  )  )     =  =    null )  )     |  |     (  !  ( visitedDirs . add ( path )  )  )  )     {", "return ;", "}", "maybeVisit ( path . getParent (  )  ,    includeEmptyDirs ,    delegateAction )  ;", "List < FileCopyDetailsInternal >    detailsForPath    =    pendingDirs . removeAll ( path )  ;", "FileCopyDetailsInternal   dir ;", "if    ( detailsForPath . isEmpty (  )  )     {", "dir    =    new    . StubbedFileCopyDetails ( path ,    includeEmptyDirs ,    chmod )  ;", "} else    {", "dir    =    detailsForPath . get (  0  )  ;", "}", "delegateAction . processFile ( dir )  ;", "}", "}  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecorator"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   details    =    file (  \" dir \"  ,    true ,    true )  ;", "final   FileCopyDetailsInternal   file    =    file (  \" dir / file \"  ,    false ,    true )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( delegateAction )  . processFile ( details )  ;", "one ( delegateAction )  . processFile ( file )  ;", "}", "}  )  ;", "ExecuterUtil . visit ( decorator ,    details ,    file ,    details )  ;", "}", "METHOD_END"], "methodName": ["doesNotVisitADirectoryWhichHasBeenVisitedBefore"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   dir    =    file (  \" dir \"  ,    true ,    false )  ;", "context . checking ( new   Expectations (  )     {", "{", "exactly (  0  )  . of ( delegateAction )  . processFile ( dir )  ;", "}", "}  )  ;", "ExecuterUtil . visit ( decorator ,    dir )  ;", "}", "METHOD_END"], "methodName": ["doesNotVisitAnEmptyDirectoryIfCorrespondingOptionIsOff"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   details    =    context . mock ( FileCopyDetailsInternal . class ,    path )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( details )  . getRelativePath (  )  ;", "will ( returnValue ( RelativePath . parse ( false ,    path )  )  )  ;", "allowing ( details )  . isDirectory (  )  ;", "will ( returnValue ( isDir )  )  ;", "allowing ( details )  . isIncludeEmptyDirs (  )  ;", "will ( returnValue ( includeEmptyDirs )  )  ;", "}", "}  )  ;", "return   details ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < FileCopyDetailsInternal >  (  )     {", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" has   path    \"  )  . appendValue ( path )  ;", "}", "public   boolean   matches ( Object   o )     {", "FileCopyDetails   details    =     (  ( FileCopyDetails )     ( o )  )  ;", "return   details . getRelativePath (  )  . getPathString (  )  . equals ( path )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["hasPath"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   dir    =    file (  \" dir \"  ,    true ,    true )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( delegateAction )  . processFile ( dir )  ;", "}", "}  )  ;", "ExecuterUtil . visit ( decorator ,    dir )  ;", "}", "METHOD_END"], "methodName": ["visitsAnEmptyDirectoryIfCorrespondingOptionIsOn"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   dir 1     =    file (  \" a / b / c \"  ,    true ,    true )  ;", "final   FileCopyDetailsInternal   file 1     =    file (  \" a / b / c / file \"  ,    false ,    true )  ;", "decorator . execute ( new   ProcessingStream (  )     {", "public   void   process ( ProcessingStreamAction   action )     {", "context . checking ( new   Expectations (  )     {", "{", "one ( delegateAction )  . processFile ( with ( hasPath (  \" a \"  )  )  )  ;", "one ( delegateAction )  . processFile ( with ( hasPath (  \" a / b \"  )  )  )  ;", "one ( delegateAction )  . processFile ( dir 1  )  ;", "one ( delegateAction )  . processFile ( file 1  )  ;", "}", "}  )  ;", "action . processFile ( dir 1  )  ;", "action . processFile ( file 1  )  ;", "final   FileCopyDetailsInternal   dir 2     =    file (  \" a / b / d / e \"  ,    true ,    true )  ;", "final   FileCopyDetailsInternal   file 2     =    file (  \" a / b / d / e / file \"  ,    false ,    true )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( delegateAction )  . processFile ( with ( hasPath (  \" a / b / d \"  )  )  )  ;", "one ( delegateAction )  . processFile ( dir 2  )  ;", "one ( delegateAction )  . processFile ( file 2  )  ;", "}", "}  )  ;", "action . processFile ( dir 2  )  ;", "action . processFile ( file 2  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["visitsDirectoryAncestorsWhichHaveNotBeenVisited"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "final   FileCopyDetailsInternal   details    =    file (  \" a / b / c \"  ,    false ,    true )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( delegateAction )  . processFile ( with ( hasPath (  \" a \"  )  )  )  ;", "one ( delegateAction )  . processFile ( with ( hasPath (  \" a / b \"  )  )  )  ;", "one ( delegateAction )  . processFile ( details )  ;", "}", "}  )  ;", "ExecuterUtil . visit ( decorator ,    details )  ;", "}", "METHOD_END"], "methodName": ["visitsFileAncestorsWhichHaveNotBeenVisited"], "fileName": "org.gradle.api.internal.file.copy.NormalizingCopyActionDecoratorTest"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( String . class )  . noImplicitConverters (  )  . allowNullInput (  )  . converter ( new   PathNotationConverter (  )  )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["parser"], "fileName": "org.gradle.api.internal.file.copy.PathNotationConverter"}, {"methodBody": ["METHOD_START", "{", "String   result    =    source ;", "matcher . reset ( source )  ;", "if    ( matchernd (  )  )     {", "result    =    matcher . replaceFirst ( replacement )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.api.internal.file.copy.RegExpNameMapper"}, {"methodBody": ["METHOD_START", "{", "RegExpNameMapper   mapper    =    new   RegExpNameMapper (  \"  (  .  +  )  . java \"  ,     \"  $  1 Test . java \"  )  ;", "String   noMatch    =     \" NoMatch \"  ;", "assertEquals ( noMatch ,    mapper . transform ( noMatch )  )  ;", "}", "METHOD_END"], "methodName": ["testRenameNoMatch"], "fileName": "org.gradle.api.internal.file.copy.RegExpNameMapperTest"}, {"methodBody": ["METHOD_START", "{", "RegExpNameMapper   mapper    =    new   RegExpNameMapper (  \"  (  .  +  )  . java \"  ,     \"  $  1 Test . java \"  )  ;", "assertEquals (  \" SourceTest . java \"  ,    mapper . transform (  \" Source . java \"  )  )  ;", "assertEquals (  \" SecondTest . java \"  ,    mapper . transform (  \" Second . java \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenameWithCapture"], "fileName": "org.gradle.api.internal.file.copy.RegExpNameMapperTest"}, {"methodBody": ["METHOD_START", "{", "RelativePath   path    =    fileCopyDetails . getRelativePath (  )  ;", "String   newName    =    transformer . transform ( path . getLastName (  )  )  ;", "if    ( newName    !  =    null )     {", "path    =    path . replaceLastName ( newName )  ;", "fileCopyDetails . setRelativePath ( path )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.RenamingCopyAction"}, {"methodBody": ["METHOD_START", "{", "final   Set < RelativePath >    visited    =    new   HashSet < RelativePath >  (  )  ;", "WorkResult   didWork    =    delegate . execute ( new   CopyActionProcessingStream (  )     {", "public   void   process ( final   CopyActionProcessingStreamAction   action )     {", "stream . process ( new   CopyActionProcessingStreamAction (  )     {", "public   void   processFile ( FileCopyDetailsInternal   details )     {", "visited . add ( details . getRelativePath (  )  )  ;", "action . processFile ( details )  ;", "}", "}  )  ;", "}", "}  )  ;", "FileVisitor   fileVisitor    =    newFileVisitor ( visited ,    preserveSpec )  ;", "MinimalFileTree   walker    =    directoryFileTreeFactory . create ( baseDestDir )  . postfix (  )  ;", "walker . visit ( fileVisitor )  ;", "visited . clear (  )  ;", "return   WorkResults . didWork (  (  ( didWork . getDidWork (  )  )     |  |     ( fileVisitor . didWork )  )  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.file.copy.SyncCopyActionDecorator"}, {"methodBody": ["METHOD_START", "{", "final   Object [  ]    innerPaths    =    paths ;", "return   delete ( new   Action < DeleteSpec >  (  )     {", "@ Override", "public   void   execute ( DeleteSpec   deleteSpec )     {", "deleteSpec . delete ( innerPaths )  . setFollowSymlinks ( false )  ;", "}", "}  )  . getDidWork (  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.api.internal.file.delete.Deleter"}, {"methodBody": ["METHOD_START", "{", "boolean   didWork    =    false ;", "DeleteSpecI   deleteSpec    =    new   DefaultDeleteSpec (  )  ;", "action . execute ( deleteSpec )  ;", "Object [  ]    paths    =    deleteSpec . getPaths (  )  ;", "for    ( File   file    :    fileResolver . resolveFiles ( paths )  )     {", "if    (  !  ( file . exists (  )  )  )     {", "continue ;", "}", "Deleter . LOGGER . debug (  \" Deleting    {  }  \"  ,    file )  ;", "didWork    =    true ;", "doDeleteI ( file ,    deleteSpec )  ;", "}", "return   WorkResults . didWork ( didWork )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.api.internal.file.delete.Deleter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( file . isDirectory (  )  )     &  &     (  ( deleteSpec . isFollowSymlinks (  )  )     |  |     (  !  ( fileSystem . isSymlink ( file )  )  )  )  )     {", "File [  ]    contents    =    file . listFiles (  )  ;", "if    ( contents    =  =    null )     {", "return ;", "}", "for    ( File   item    :    contents )     {", "doDeleteInternal ( item ,    deleteSpec )  ;", "}", "}", "if    (  (  !  (  (  )  )  )     &  &     ( file . exists (  )  )  )     {", "handleFailedDelete ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["doDeleteInternal"], "fileName": "org.gradle.api.internal.file.delete.Deleter"}, {"methodBody": ["METHOD_START", "{", "if    ( isRunGcOnFailedDelete (  )  )     {", "System . gc (  )  ;", "}", "try    {", "Thread . sleep ( Deleter . DELETE _ RETRY _ SLEEP _ MILLIS )  ;", "}    catch    ( InterruptedException   ex )     {", "}", "if    (  (  !  (  (  )  )  )     &  &     ( file . exists (  )  )  )     {", "throw   new   UnableToDeleteFileException ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["handleFailedDelete"], "fileName": "org.gradle.api.internal.file.delete.Deleter"}, {"methodBody": ["METHOD_START", "{", "return   OperatingSystem . current (  )  . isWindows (  )  ;", "}", "METHOD_END"], "methodName": ["isRunGcOnFailedDelete"], "fileName": "org.gradle.api.internal.file.delete.Deleter"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < Spec < RelativePath >  >  (  )     {", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" matches    \"  )  . appendValue ( path )  ;", "}", "public   boolean   matches ( Object   o )     {", "Spec < RelativePath >    matcher    =     (  ( Spec < RelativePath >  )     ( o )  )  ;", "return   matcher . isSatisfiedBy ( path )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "return   matches ( new   RelativePath ( false ,    paths )  )  ;", "}", "METHOD_END"], "methodName": ["matchesDir"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "return   matches ( new   RelativePath ( true ,    paths )  )  ;", "}", "METHOD_END"], "methodName": ["matchesFile"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( PatternMatcherFactory . PathMatcherBackedSpec )     ( matcher )  )  . getPathMatcher (  )  ;", "}", "METHOD_END"], "methodName": ["pathMatcher"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b / c \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" C \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    false ,     \" a \\  \\ b \\  \\ c \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" C \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCaseSensitive"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  \"  )  ;", "assertThat ( matcher ,    matchesFile (  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testEmpty"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  \"  )  ;", "assertThat ( pathMatcher ( matcher )  ,    instanceOf ( AnythingMatcher . class )  )  ;", "assertThat ( matcher ,    matchesFile (  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  /  \"  )  ;", "assertThat ( pathMatcher ( matcher )  ,    instanceOf ( AnythingMatcher . class )  )  ;", "assertThat ( matcher ,    matchesFile (  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  /  *  *  /  *  *  \"  )  ;", "assertThat ( pathMatcher ( matcher )  ,    instanceOf ( AnythingMatcher . class )  )  ;", "assertThat ( matcher ,    matchesFile (  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGreedy"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  / a \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" b \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  ,     \" a \"  ,     \" c \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  / a / b /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" c \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" c \"  ,     \" a \"  ,     \" b \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" c \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" d \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  / a /  *  *  / b \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" c \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" c \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" c \"  ,     \" a \"  ,     \" d \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" d \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \" a / b /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" c \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" d \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \" a / b /  *  *  / c \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" c \"  ,     \" b \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" d \"  ,     \" a \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \" a / b /  *  *  / c /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" d \"  ,     \" a \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  *  /  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  *  /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \" a /  *  *  /  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  ,     \" a \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGreedyPatternsMatchingFiles"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  / a \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" b \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" d \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  / a / b /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" c \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" c \"  ,     \" a \"  ,     \" b \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" c \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" c \"  ,     \" a \"  ,     \" a \"  ,     \" b \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" d \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" a \"  ,     \" c \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" c \"  ,     \" a \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b /  *  *  / c \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" d \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" a \"  ,     \" c \"  ,     \" b \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" d \"  ,     \" a \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  /  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a /  *  *  /  *  \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  ,     \" d \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" b \"  ,     \" a \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGreedyPatternsPartialMatchingDirs"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  /  * a *  /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" abc \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" abc \"  ,     \" r \"  ,     \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" r \"  ,     \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" abc \"  ,     \" q \"  ,     \" r \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" r \"  ,     \" abc \"  ,     \" q \"  ,     \" r \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  /  *  *  / abc /  *  *  /  *  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" abc \"  ,     \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" abc \"  ,     \" r \"  ,     \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" r \"  ,     \" abc \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" abc \"  ,     \" q \"  ,     \" r \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" q \"  ,     \" r \"  ,     \" abc \"  ,     \" q \"  ,     \" r \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" b \"  ,     \" b \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGreedyWithSingleNameFollowedByGreedy"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  /  *  . jsp \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" fred . txt \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" src \"  ,     \" fred . txt \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \"  *  *  /  *  *  /  *  . jsp \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" fred . jsp \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" fred . txt \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" src \"  ,     \" fred . txt \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGreedyWithTrailingName"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b \"  )  ;", "assertThat ( matcher ,    matchesDir (  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesDir (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" other \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" other \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" b \"  ,     \" other \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesDir (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralsPartialMatchingDirs"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b / c \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" other \"  ,     \" c \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a \\  \\ b \\  \\ c \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  ,     \" d \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" other \"  ,     \" c \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSlashDirection"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a / b /  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( true ,    true ,     \" a \\  \\ b \\  \\  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" c \"  ,     \" b \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testTrailingSlashIsReplacedWithTrailingGreedy"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \" a /  *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  ,     \" b \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" a \"  ,     \" b \"  ,     \" c \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" other \"  ,     \" b \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  ?  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \"  ?  \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" a \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" C \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" abc \"  )  )  )  ;", "matcher    =    PatternMatcherFactory . getPatternMatcher ( false ,    true ,     \"  ? b ?  ? e *  \"  )  ;", "assertThat ( matcher ,    matchesFile (  \"  ? b ?  ? e *  \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" abcde \"  )  )  ;", "assertThat ( matcher ,    matchesFile (  \" abcdefgh \"  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" aaaae \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" abcdfe \"  )  )  )  ;", "assertThat ( matcher ,    not ( matchesFile (  \" abc \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testWildcards"], "fileName": "org.gradle.api.internal.file.pattern.PatternMatcherFactoryTest"}, {"methodBody": ["METHOD_START", "{", "RegExpPatternStep   step    =    new   RegExpPatternStep (  \" MiXeD \"  ,    true )  ;", "assertTrue ( step . matches (  \" MiXeD \"  )  )  ;", "assertFalse ( step . matches (  \" mixed \"  )  )  ;", "step    =    new   RegExpPatternStep (  \" MiXeD \"  ,    false )  ;", "assertTrue ( step . matches (  \" MiXeD \"  )  )  ;", "assertTrue ( step . matches (  \" mixed \"  )  )  ;", "step    =    new   RegExpPatternStep (  \" MiXeD ?  \"  ,    true )  ;", "assertTrue ( step . matches (  \" MiXeD 1  \"  )  )  ;", "assertFalse ( step . matches (  \" mixed 1  \"  )  )  ;", "step    =    new   RegExpPatternStep (  \" MiXeD ?  \"  ,    false )  ;", "assertTrue ( step . matches (  \" MiXeD 1  \"  )  )  ;", "assertTrue ( step . matches (  \" mixed 1  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testCase"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "String   testChars    =     \"  `  ~  !  @  #  $  %  ^  &  *  (  )  -  _  =  +  [  ]  {  }  \\  \\  |  ;  :  \\  '  \\  \"  <  >  ,  /  \"  ;", "step    =    new    ( testChars ,    true )  ;", "assertTrue ( step . matches ( testChars )  )  ;", "}", "METHOD_END"], "methodName": ["testEscapeSet"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "testPatternEscape (  \" literal \"  ,     \" literal \"  )  ;", "testPatternEscape (  \" dotq .  \"  ,     \" dotq ?  \"  )  ;", "testPatternEscape (  \" star .  * stuff \"  ,     \" star * stuff \"  )  ;", "testPatternEscape (  \"  \\  \\  \\  \\  \\  \\  [  \\  \\  ]  \\  \\  ^  \\  \\  -  \\  \\  &  \\  \\  .  \\  \\  {  \\  \\  }  \\  \\  (  \\  \\  )  \\  \\  $  \\  \\  +  \\  \\  |  \\  \\  <  \\  \\  =  \\  \\  !  \"  ,     \"  \\  \\  [  ]  ^  -  &  .  {  }  (  )  $  +  |  <  =  !  \"  )  ;", "testPatternEscape (  \"  \\  \\  $  \\  \\  & time \"  ,     \"  $  & time \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetRegExpPattern"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "RegExpPatternStep   step    =    new   RegExpPatternStep (  \" literal \"  ,    true )  ;", "assertTrue ( step . matches (  \" literal \"  )  )  ;", "assertFalse ( step . matches (  \" Literal \"  )  )  ;", "assertFalse ( step . matches (  \" literally \"  )  )  ;", "assertFalse ( step . matches (  \" aliteral \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testLiteralMatches"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "RegExpPatternStep   step    =    new   RegExpPatternStep (  \" a * c \"  ,    true )  ;", "assertTrue ( step . matches (  \" abc \"  )  )  ;", "assertTrue ( step . matches (  \" abrac \"  )  )  ;", "assertFalse ( step . matches (  \" abcd \"  )  )  ;", "assertFalse ( step . matches (  \" ab \"  )  )  ;", "assertFalse ( step . matches (  \" a \"  )  )  ;", "step    =    new   RegExpPatternStep (  \"  *  \"  ,    true )  ;", "assertTrue ( step . matches (  \" asd ; flkj \"  )  )  ;", "assertTrue ( step . matches (  \"  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiCharWildcard"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expected ,    RegExpPatternStep . getRegExPattern ( pattern )  )  ;", "}", "METHOD_END"], "methodName": ["testPatternEscape"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "RegExpPatternStep   step    =    new   RegExpPatternStep (  \" a ? c \"  ,    true )  ;", "assertTrue ( step . matches (  \" abc \"  )  )  ;", "assertTrue ( step . matches (  \" a $ c \"  )  )  ;", "assertTrue ( step . matches (  \" a ? c \"  )  )  ;", "assertFalse ( step . matches (  \" ac \"  )  )  ;", "assertFalse ( step . matches (  \" abcd \"  )  )  ;", "assertFalse ( step . matches (  \" abd \"  )  )  ;", "assertFalse ( step . matches (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSingleCharWildcard"], "fileName": "org.gradle.api.internal.file.pattern.RegExpPatternStepTest"}, {"methodBody": ["METHOD_START", "{", "return   id . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.api.internal.initialization.AbstractClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "return   ClassLoaderIds . of ( ClassLoaderIds . Type . SCRIPT ,    fileName ,    operationId )  ;", "}", "METHOD_END"], "methodName": ["buildScript"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderIds"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassLoaderIds . DefaultClassLoaderId ( type ,    attributes )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderIds"}, {"methodBody": ["METHOD_START", "{", "return   ClassLoaderIds . of ( ClassLoaderIds . Type . TEST _ TASK _ CLASSPATH ,    testTaskPath )  ;", "}", "METHOD_END"], "methodName": ["testTaskClasspath"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderIds"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassLoaderScopeIdentifier ( this ,    name )  ;", "}", "METHOD_END"], "methodName": ["child"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderScopeIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassLoaderScopeIdentifier . Id ( this ,    true )  ;", "}", "METHOD_END"], "methodName": ["exportId"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderScopeIdentifier"}, {"methodBody": ["METHOD_START", "{", "List < String >    names    =    Lists . newLinkedList (  )  ;", "names . add ( name )  ;", "nextParent    =    parent ;", "while    ( nextParent    !  =    null )     {", "names . add (  0  ,    nextParent . name )  ;", "nextParent    =    nextParent . parent ;", "}", "return   Joiner . on (  \"  :  \"  )  . join ( names )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderScopeIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   new   ClassLoaderScopeIdentifier . Id ( this ,    false )  ;", "}", "METHOD_END"], "methodName": ["localId"], "fileName": "org.gradle.api.internal.initialization.ClassLoaderScopeIdentifier"}, {"methodBody": ["METHOD_START", "{", "if    ( locked )     {", "throw   new   IllegalStateException (  (  \" class   l   scope   is   locked ,    scope   identifier   is    \"     +     ( id )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotLocked"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "if    (  ( effectiveLocalClassLoader )     =  =    null )     {", "boolean   hasExports    =     (  !  ( export . isEmpty (  )  )  )     |  |     (  ( exportLoaders )     !  =    null )  ;", "boolean   hasLocals    =     !  ( local . isEmpty (  )  )  ;", "if    ( locked )     {", "if    ( hasExports    &  &    hasLocals )     {", "effectiveExportClassLoader    =    buildLockedLoader ( id . exportId (  )  ,    export ,    exportLoaders )  ;", "effectiveLocalClassLoader    =    buildLockedLoader ( id . localId (  )  ,    effectiveExportClassLoader ,    local )  ;", "} else", "if    ( hasLocals )     {", "classLoaderCache . remove ( id . exportId (  )  )  ;", "effectiveLocalClassLoader    =    buildLockedLoader ( id . localId (  )  ,    local )  ;", "effectiveExportClassLoader    =    parent . getExportClassLoader (  )  ;", "} else", "if    ( hasExports )     {", "classLoaderCache . remove ( id . localId (  )  )  ;", "effectiveLocalClassLoader    =    buildLockedLoader ( id . exportId (  )  ,    export ,    exportLoaders )  ;", "effectiveExportClassLoader    =    effectiveLocalClassLoader ;", "} else    {", "classLoaderCache . remove ( id . localId (  )  )  ;", "classLoaderCache . remove ( id . exportId (  )  )  ;", "effectiveLocalClassLoader    =    parent . getExportClassLoader (  )  ;", "effectiveExportClassLoader    =    parent . getExportClassLoader (  )  ;", "}", "} else    {", "if    ( Boolean . getBoolean (  . STRICT _ MODE _ PROPERTY )  )     {", "throw   new   IllegalStateException (  (  \" Attempt   to   define   scope   class   loader   before   scope   is   locked ,    scope   identifier   is    \"     +     ( id )  )  )  ;", "}", "exportingClassLoader    =    buildMultiLoader ( id . exportId (  )  ,    export ,    exportLoaders )  ;", "effectiveExportClassLoader    =    new   CachingClassLoader ( exportingClassLoader )  ;", "localClassLoader    =    new   MultiParentClassLoader ( effectiveExportClassLoader ,    loader ( id . localId (  )  ,    local )  )  ;", "effectiveLocalClassLoader    =    new   CachingClassLoader ( localClassLoader )  ;", "}", "export    =    null ;", "exportLoaders    =    null ;", "local    =    null ;", "}", "}", "METHOD_END"], "methodName": ["buildEffectiveLoaders"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "if    ( classPath . isEmpty (  )  )     {", "return   additional ;", "}", "return   new   CachingClassLoader ( new   MultiParen ( additional ,    loader ( id ,    classPath )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildLockedLoader"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "if    ( classPath . isEmpty (  )  )     {", "return   parent . getExpor (  )  ;", "}", "return   loader ( id ,    classPath )  ;", "}", "METHOD_END"], "methodName": ["buildLockedLoader"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "if    ( loaders    !  =    null )     {", "return   new   internal . classloader . CachingClassLoader ( buildMultiLoader ( id ,    classPath ,    loaders )  )  ;", "}", "return   buildLockedLoader ( id ,    classPath )  ;", "}", "METHOD_END"], "methodName": ["buildLockedLoader"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "int   numParents    =     1  ;", "if    ( loaders    !  =    null )     {", "numParents    +  =    loaders . size (  )  ;", "}", "if    (  !  ( classPath . isEmpty (  )  )  )     {", "numParents    +  =     1  ;", "}", "List < ClassLoader >    parents    =    new   ArrayList < ClassLoader >  ( numParents )  ;", "parents . add ( parent . getExpor (  )  )  ;", "if    ( loaders    !  =    null )     {", "parents . addAll ( loaders )  ;", "}", "if    (  !  ( classPath . isEmpty (  )  )  )     {", "parents . add ( loader ( id ,    classPath )  )  ;", "}", "return   new   MultiParen ( parents )  ;", "}", "METHOD_END"], "methodName": ["buildMultiLoader"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   classLoader    =    classLoaderCache . get ( id ,    classPath ,    parent . getExportClassLoader (  )  ,    null )  ;", "if    (  ( ownLoaders )     =  =    null )     {", "ownLoaders    =    new   ArrayList < ClassLoader >  (  )  ;", "}", "ownLoaders . add ( classLoader )  ;", "return   classLoader ;", "}", "METHOD_END"], "methodName": ["loader"], "fileName": "org.gradle.api.internal.initialization.DefaultClassLoaderScope"}, {"methodBody": ["METHOD_START", "{", "if    (  ( configContainer )     =  =    null )     {", "configContainer    =    dependencyResolutionServices . getConfigurContainer (  )  ;", "}", "if    (  ( classpathConfigur )     =  =    null )     {", "classpathConfigur    =    configContainer . create ( CLASSPATH _ CONFIGURATION )  ;", "}", "}", "METHOD_END"], "methodName": ["defineConfiguration"], "fileName": "org.gradle.api.internal.initialization.DefaultScriptHandler"}, {"methodBody": ["METHOD_START", "{", "return   create ( scriptSource ,    classLoaderScope ,    RootScriptDomainObjectContext . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.initialization.DefaultScriptHandlerFactory"}, {"methodBody": ["METHOD_START", "{", "DependencyResolutionServices   services    =    dependencyManagementServices . create ( fileResolver ,    dependencyMetaDataProvider ,    projectFinder ,    context )  ;", "return   new    ( scriptSource ,    services ,    classLoaderScope ,    scriptClassPathResolver )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.initialization.DefaultScriptHandlerFactory"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "Map < ClassLoaderId ,     . CachedClassLoader >    orphaned    =    Maps . newHashMap (  )  ;", "for    ( Map . Entry < ClassLoaderId ,     . CachedClassLoader >    entry    :    byId . entrySet (  )  )     {", "if    (  !  ( bySpec . containsKey ( entry . getValue (  )  . spec )  )  )     {", "orphaned . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "if    (  !  ( orphaned . isEmpty (  )  )  )     {", "throw   new   IllegalStateException (  (  \" The   following   class   loaders   are   orphaned :     \"     +     ( Joiner . on (  \"  ,  \"  )  . withKeyValueSeparator (  \"  :  \"  )  . join ( orphaned )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["assertInternalIntegrity"], "fileName": "org.gradle.api.internal.initialization.loadercache.DefaultClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "DefaultClassLoaderCache . CachedClassLoader   cachedLoader    =    bySpec . get ( spec )  ;", "if    ( cachedLoader    =  =    null )     {", "ClassLoader   classLoader ;", "DefaultClassLoaderCache . CachedClassLoader   parentCachedLoader    =    null ;", "if    ( spec . isFiltered (  )  )     {", "parentCachedLoader    =    getAndRetainLoader ( classPath ,    spec . unfiltered (  )  ,    id )  ;", "classLoader    =    classLoaderFactory . createFilteringClassLoader ( parentCachedLoader . classLoader ,    spec . filterSpec )  ;", "} else    {", "classLoader    =    classLoaderFactory . createChildClassLoader ( spec . parent ,    classPath ,    spec . implementationHash )  ;", "}", "cachedLoader    =    new   DefaultClassLoaderCache . CachedClassLoader ( classLoader ,    spec ,    parentCachedLoader )  ;", "bySpec . put ( spec ,    cachedLoader )  ;", "}", "return   cachedLoader . retain ( id )  ;", "}", "METHOD_END"], "methodName": ["getAndRetainLoader"], "fileName": "org.gradle.api.internal.initialization.loadercache.DefaultClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  \" Instantiator   does   not   support   constructing   property   objects \"  )  ;", "}", "METHOD_END"], "methodName": ["broken"], "fileName": "org.gradle.api.internal.model.InstantiatorBackedObjectFactory"}, {"methodBody": ["METHOD_START", "{", "URL   resource    =    classLoader . getResource (  (  (  \" META - INF / gradle - plugins /  \"     +    pluginId )     +     \"  . properties \"  )  )  ;", "if    ( resource    =  =    null )     {", "return   null ;", "} else    {", "return   new    ( resource )  ;", "}", "}", "METHOD_END"], "methodName": ["findPluginDescriptor"], "fileName": "org.gradle.api.internal.plugins.ClassloaderBackedPluginDescriptorLocator"}, {"methodBody": ["METHOD_START", "{", "return   pluginId . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.api.internal.plugins.DefaultAppliedPlugin"}, {"methodBody": ["METHOD_START", "{", "return   pluginId . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.plugins.DefaultAppliedPlugin"}, {"methodBody": ["METHOD_START", "{", "return   pluginId . getNamespace (  )  ;", "}", "METHOD_END"], "methodName": ["getNamespace"], "fileName": "org.gradle.api.internal.plugins.DefaultAppliedPlugin"}, {"methodBody": ["METHOD_START", "{", "add ( preferredPublicTypeOf ( extension ,    defaultType )  ,    name ,    extension )  ;", "}", "METHOD_END"], "methodName": ["addWithDefaultPublicType"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "if    ( extensionsStorage . hasExtension ( name )  )     {", "throw   new   IllegalArgumentExcep ( String . format (  \" There ' s   an   extension   registered   with   name    '  % s '  .    You   should   not   reassign   it   via   a   property   setter .  \"  ,    name )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkExtensionIsNotReassigned"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "Closure   closure    =     (  ( Closure )     ( args [  0  ]  )  )  ;", "Ac < Object >    ac    =    ConfigureUtil . configureUsing ( closure )  ;", "return   extensionsStorage . configureExtension ( name ,    ac )  ;", "}", "METHOD_END"], "methodName": ["configureExtension"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "if    (  ( instantiator )     =  =    null )     {", "throw   new   GradleException (  \" request   for    . instantiator   when   the   object   was   constructed   without   a   convention \"  )  ;", "}", "return   instantiator ;", "}", "METHOD_END"], "methodName": ["getInstantiator"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "return   getInstantiator (  )  . newInstance ( instanceType ,    constructionArguments )  ;", "}", "METHOD_END"], "methodName": ["instantiate"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( args . length )     =  =     1  )     &  &     (  ( args [  0  ]  )    instanceof   Closure )  )     &  &     ( extensionsStorage . hasExtension ( name )  )  ;", "}", "METHOD_END"], "methodName": ["isConfigureExtensionMethod"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "if    ( extension   instanceof   HasPublicType )     {", "return   Cast . uncheckedCast (  (  ( HasPublicType )     ( extension )  )  . getPublicType (  )  )  ;", "}", "return   TypeOf .  < Object > typeOf ( dType )  ;", "}", "METHOD_END"], "methodName": ["preferredPublicTypeOf"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "return   getByName ( name )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "checkExtensionIsNotReassigned ( name )  ;", "add ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.plugins.DefaultConvention"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExtensionsSchema ( Cast .  < Iterable < ExtensionSchema >  > uncheckedCast ( schemas )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.plugins.DefaultExtensionsSchema"}, {"methodBody": ["METHOD_START", "{", "return   storage . get ( name )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    find ( name )  ;", "if    (  ( value    =  =    null )     &  &     (  !  ( has ( name )  )  )  )     {", "throw   new   UnknownyException ( this ,    name )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "return   new   HashMap < String ,    Object >  ( storage )  ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" properties \"  )  )     {", "return   get (  )  ;", "}", "if    ( storage . containsKey ( name )  )     {", "return   storage . get ( name )  ;", "} else    {", "throw   new   groovy . lang . MissingPropertyException ( UnknownPropertyException . createMessage ( name )  ,    name ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "return   storage . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["has"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "Object   item    =    find ( name )  ;", "if    (  ( item    !  =    null )     &  &     ( item   tanceof   Closure )  )     {", "Closure   closure    =     (  ( Closure )     ( item )  )  ;", "return   closure . call (  (  ( Object [  ]  )     ( args )  )  )  ;", "} else    {", "throw   new   MissingMethodException ( name ,    getClass (  )  ,     (  ( Object [  ]  )     ( args )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["methodMissing"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "storage . put ( name ,    value )  ;", "}", "METHOD_END"], "methodName": ["set"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" properties \"  )  )     {", "throw   new   ReadOnlyPropertyException (  \" name \"  ,     . class )  ;", "}", "set ( name ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["setProperty"], "fileName": "org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension"}, {"methodBody": ["METHOD_START", "{", "applyType ( pluginClass )  ;", "}", "METHOD_END"], "methodName": ["applyPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "URI   scriptUri    =    resolver . resolveUri ( script )  ;", "TextResource   resource    =    resourceLoader . loadUri (  \" script \"  ,    scriptUri )  ;", "ScriptSource   scriptSource    =    new   TextResourceScriptSource ( resource )  ;", "ClassLoaderScope   classLoaderScopeChild    =    classLoaderScope . createChild (  (  \" script -  \"     +     ( scriptUri . toString (  )  )  )  )  ;", "ScriptHandler   scriptHandler    =    scriptHandlerFactory . create ( scriptSource ,    classLoaderScopeChild )  ;", "ScriptPlugin   cer    =    cerFactory . create ( scriptSource ,    scriptHandler ,    classLoaderScopeChild ,    classLoaderScope ,    false )  ;", "for    ( Object   target    :    targets )     {", "cer . apply ( target )  ;", "}", "}", "METHOD_END"], "methodName": ["applyScript"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   target    :    targets )     {", "if    ( target   instanceof   PluginAware )     {", "(  ( PluginAware )     ( target )  )  . getPluginManager (  )  . apply ( pluginClass )  ;", "} else    {", "throw   new   UnsupportedOperationException ( String . format (  \" Cannot   apply   plugin   of   class    '  % s '    to    '  % s '     ( class :     % s )    as   it   does   not   implement   PluginAware \"  ,    pluginClass . getName (  )  ,    target . toString (  )  ,    target . getClass (  )  . getName (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyType"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   target    :    targets )     {", "if    ( target   instanceof   PluginAware )     {", "(  ( PluginAware )     ( target )  )  . getPluginManager (  )  . apply ( pluginId )  ;", "} else    {", "throw   new   UnsupportedOperationException ( String . format (  \" Cannot   apply   plugin   with   id    '  % s '    to    '  % s '     ( class :     % s )    as   it   does   not   implement   PluginAware \"  ,    pluginId ,    target . toString (  )  ,    target . getClass (  )  . getName (  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["applyType"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "if    ( targets . isEmpty (  )  )     {", "to ( dTarget )  ;", "}", "for    ( Runnable   action    :    actions )     {", "action . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "actions . add ( new   Runnable (  )     {", "public   void   run (  )     {", "applyScript ( script )  ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "actions . add ( new   Runnable (  )     {", "public   void   run (  )     {", "applyPlugin ( Class )  ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["plugin"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "actions . add ( new   Runnable (  )     {", "public   void   run (  )     {", "applyType ( Id )  ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["plugin"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "GUtil . flatten ( targets ,    this . targets )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["to"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "actions . add ( new   Runnable (  )     {", "public   void   run (  )     {", "applyType ( Class )  ;", "}", "}  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["type"], "fileName": "org.gradle.api.internal.plugins.DefaultObjectConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPluginCollection < S >  ( this ,    filter )  ;", "}", "METHOD_END"], "methodName": ["filtered"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "return   matching ( Specs .  < T > convertClosureToSpec ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( spec )  )  ;", "}", "METHOD_END"], "methodName": ["matching"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "whenObjectAdded ( closure )  ;", "}", "METHOD_END"], "methodName": ["whenPluginAdded"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "return   whenObjectAdded ( action )  ;", "}", "METHOD_END"], "methodName": ["whenPluginAdded"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "return   filtered ( createFilter ( type )  )  ;", "}", "METHOD_END"], "methodName": ["withType"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginCollection"}, {"methodBody": ["METHOD_START", "{", "return   pluginManager . addImperativePlugin ( type )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "PluginImplementation   plugin    =    pluginRegistry . lookup ( DefaultPluginId . unvalidated ( id )  )  ;", "if    ( plugin    =  =    null )     {", "throw   new   UnknownPluginException (  (  (  \" Plugin   with   id    '  \"     +    id )     +     \"  '    not   found .  \"  )  )  ;", "}", "if    (  !  ( Plugin . class . isAssignableFrom ( plugin . asClass (  )  )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Plugin   implementation    '  \"     +     ( plugin . asClass (  )  . getName (  )  )  )     +     \"  '    does   not   implement   the   Plugin   interface .    This   plugin   cannot   be   applied   directly   via   the    .  \"  )  )  ;", "} else    {", "return   pluginManager . addImperativePlugin ( plugin )  ;", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "for    ( final   PluginManagerInternal . PluginWithId   pluginWithId    :    pluginManager . pluginsForId ( id )  )     {", "Plugin   plugin    =    Iterables . tryFind ( this ,    new   com . google . common . base . Predicate < Plugin >  (  )     {", "public   boolean   apply ( Plugin   plugin )     {", "return   pluginWithId . clazz . equals ( plugin . getClass (  )  )  ;", "}", "}  )  . orNull (  )  ;", "if    ( plugin    !  =    null )     {", "return   plugin ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doFindPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "for    ( Plugin   plugin    :    this )     {", "if    ( plugin . getClass (  )  . equals ( type )  )     {", "return   type . cast ( plugin )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return   doFindPlugin ( id )  ;", "}", "METHOD_END"], "methodName": ["findPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return   getPlugin ( type )  ;", "}", "METHOD_END"], "methodName": ["getAt"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return   getPlugin ( id )  ;", "}", "METHOD_END"], "methodName": ["getAt"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "P   plugin    =    findPlugin ( type )  ;", "if    ( plugin    =  =    null )     {", "throw   new   UnknownPluginException (  (  (  \" Plugin   with   type    \"     +    type )     +     \"    has   not   been   used .  \"  )  )  ;", "}", "return   type . cast ( plugin )  ;", "}", "METHOD_END"], "methodName": ["getPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "Plugin   plugin    =    findPlugin ( id )  ;", "if    ( plugin    =  =    null )     {", "throw   new   UnknownPluginException (  (  (  \" Plugin   with   id    \"     +    id )     +     \"    has   not   been   used .  \"  )  )  ;", "}", "return   plugin ;", "}", "METHOD_END"], "methodName": ["getPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( findPlugin ( type )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return    ( findPlugin ( id )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "super . add ( plugin )  ;", "}", "METHOD_END"], "methodName": ["pluginAdded"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "Action < PluginManagerInternal . PluginWithId >    wrappedAction    =    new   Action < PluginManagerInternal . PluginWithId >  (  )     {", "public   void   execute ( final   PluginManagerInternal . PluginWithId   pluginWithId )     {", "matching ( new   specs . Spec < Plugin >  (  )     {", "public   boolean   isSatisfiedBy ( Plugin   element )     {", "return   pluginWithId . clazz . equals ( element . getClass (  )  )  ;", "}", "}  )  . all ( action )  ;", "}", "}  ;", "pluginManager . pluginsForId ( pluginId )  . all ( wrappedAction )  ;", "}", "METHOD_END"], "methodName": ["withId"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginContainer"}, {"methodBody": ["METHOD_START", "{", "return   addImperativePlugin ( pluginRegistry . inspect ( type )  )  ;", "}", "METHOD_END"], "methodName": ["addImperativePlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "boolean   imperative    =  . isImperative (  )  ;", "if    ( imperative )     {", "Plugin <  ?  > Instance    =    producePluginInstanceClass )  ;", "if    . isHasRules (  )  )     {", "target . applyImperativeRulesHybridId , Instance )  ;", "} else    {", "target . applyImperativeId , Instance )  ;", "}", "instances . putClass , Instance )  ;", "ContainerAddedInstance )  ;", "} else    {", "target . applyRulesId , Class )  ;", "}", "adder . run (  )  ;", "}", "METHOD_END"], "methodName": ["addPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    pluginClass    =    plugin . asClass (  )  ;", "if    ( plugins . containsKey ( pluginClass )  )     {", "return   null ;", "}", "plugins . put ( pluginClass ,    plugin )  ;", "return   new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "Iterable < PluginId >    pluginIds    =    Lists . newArrayList ( idMappings . keySet (  )  )  ;", "for    ( PluginId   id    :    pluginIds )     {", "if    ( plugin . isAlsoKnownAs ( id )  )     {", "idMappings . get ( id )  . add ( new   Internal . PluginWithId ( id ,    pluginClass )  )  ;", "}", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["addPluginInternal"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "doApply ( pluginRegistry . inspect ( type )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "PluginImplementation <  ?  >    plugin    =    pluginRegistry . lookup ( DefaultPluginId . unvalidated ( pluginId )  )  ;", "if    ( plugin    =  =    null )     {", "throw   new   UnknownPluginException (  (  (  \" Plugin   with   id    '  \"     +    pluginId )     +     \"  '    not   found .  \"  )  )  ;", "}", "doApply ( plugin )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "PluginId   pluginId    =    plugin . getPluginId (  )  ;", "String   pluginIdStr    =     ( pluginId    =  =    null )     ?    null    :    pluginId . toString (  )  ;", "Class <  ?  >    pluginClass    =    plugin . asClass (  )  ;", "ClassLoader   contextClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "try    {", "Thread . currentThread (  )  . setContextClassLoader ( pluginClass . getClassLoader (  )  )  ;", "if    ( plugin . getType (  )  . equals ( PotentialPlugin . Type . UNKNOWN )  )     {", "throw   new   InvalidPluginException (  (  (  \"  '  \"     +     ( pluginClass . getName (  )  )  )     +     \"  '    is   neither   a   plugin   or   a   rule   source   and   cannot   be   applied .  \"  )  )  ;", "} else    {", "Runnable   adder    =    addPluginInternal ( plugin )  ;", "if    ( adder    !  =    null )     {", "buildOperationExecutor . run ( new    . AddPluginBuildOperation ( adder ,    plugin ,    pluginIdStr ,    pluginClass )  )  ;", "}", "}", "}    catch    ( PluginApplicationException   e )     {", "throw   e ;", "}    catch    ( Exception   e )     {", "throw   new   PluginApplicationException ( plugin . getDisplayName (  )  ,    e )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( contextClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["doApply"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   instance    :    instances )     {", "if    ( instance . getClass (  )  . equals ( clazz )  )     {", "return   clazz . cast ( instance )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findInstance"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "DomainObjectSet < PluginManagerInternal . PluginWithId >    pluginWithIds    =    pluginsForId ( id )  ;", "if    (  !  ( pluginWithIds . isEmpty (  )  )  )     {", "return   pluginWithIds . iterator (  )  . next (  )  . asAppliedPlugin (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "return   pluginContainer ;", "}", "METHOD_END"], "methodName": ["getPluginContainer"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "return    ( findPlugin ( id )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   instantiator . newInstance ( type )  ;", "}    catch    ( ObjectInstantiationException   e )     {", "throw   new   plugins . PluginInstantiationException ( String . format (  \" Could   not   create   plugin   of   type    '  % s '  .  \"  ,    type . getSimpleName (  )  )  ,    e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiatePlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "PluginId   pluginId    =    DefaultPluginId . unvalidated ( id )  ;", "DomainObjectSet < PluginManagerInternal . PluginWithId >    pluginsForId    =    idMappings . get ( pluginId )  ;", "if    ( pluginsForId    =  =    null )     {", "pluginsForId    =    new   DefaultDomainObjectSet < PluginManagerInternal . PluginWithId >  ( PluginManagerInternal . PluginWithId . class )  ;", "idMappings . put ( pluginId ,    pluginsForId )  ;", "for    ( PluginImplementation <  ?  >    plugin    :    plugins . values (  )  )     {", "if    ( plugin . isAlsoKnownAs ( pluginId )  )     {", "pluginsForId . add ( new   PluginManagerInternal . PluginWithId ( pluginId ,    plugin . asClass (  )  )  )  ;", "}", "}", "}", "return   pluginsForId ;", "}", "METHOD_END"], "methodName": ["pluginsForId"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "Object   instance    =    findInstance ( pluginClass ,    pluginContainer )  ;", "if    ( instance    =  =    null )     {", "instance    =    instantiatePlugin ( pluginClass )  ;", "}", "return   Cast . uncheckedCast ( instance )  ;", "}", "METHOD_END"], "methodName": ["producePluginInstance"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "Action < PluginManagerInternal . PluginWithId >    wrappedAction    =    new   Action < PluginManagerInternal . PluginWithId >  (  )     {", "public   void   execute ( PluginManagerInternal . PluginWithId   pluginWithId )     {", "action . execute ( pluginWithId . asAppliedPlugin (  )  )  ;", "}", "}  ;", "pluginsForId ( id )  . all ( wrappedAction )  ;", "}", "METHOD_END"], "methodName": ["withPlugin"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginManager"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPluginRegistry ( this ,    pluginInspector ,    lookupScope )  ;", "}", "METHOD_END"], "methodName": ["createChild"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "PluginImplementation < T >    implementation    =    maybeInspect ( clazz )  ;", "if    ( implementation    !  =    null )     {", "return   implementation ;", "}", "return   Cast . uncheckedCast (  . uncheckedGet ( classMappings ,    clazz )  )  ;", "}", "METHOD_END"], "methodName": ["inspect"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "PluginImplementation   lookup ;", "if    (  ( pluginId . getNamespace (  )  )     =  =    null )     {", "PluginId   qualified    =    pluginId . withNamespace ( DefaultPluginManager . CORE _ PLUGIN _ NAMESPACE )  ;", "lookup    =     . uncheckedGet ( idMappings ,    new    . PluginIdLookupCacheKey ( qualified ,    classLoader )  )  . orNull (  )  ;", "if    ( lookup    !  =    null )     {", "return   lookup ;", "}", "}", "return    . uncheckedGet ( idMappings ,    new    . PluginIdLookupCacheKey ( pluginId ,    classLoader )  )  . orNull (  )  ;", "}", "METHOD_END"], "methodName": ["lookup"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   cache . get ( key )  ;", "}    catch    ( ExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}    catch    ( UncheckedExecutionException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e . getCause (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["uncheckedGet"], "fileName": "org.gradle.api.internal.plugins.DefaultPluginRegistry"}, {"methodBody": ["METHOD_START", "{", "return   potentialPlugin . asClass (  )  ;", "}", "METHOD_END"], "methodName": ["asClass"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "return   pluginId ;", "}", "METHOD_END"], "methodName": ["getPluginId"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "return   potentialPlugin . getType (  )  ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "return   potentialPlugin . isHasRules (  )  ;", "}", "METHOD_END"], "methodName": ["isHasRules"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "return   potentialPlugin . isImperative (  )  ;", "}", "METHOD_END"], "methodName": ["isImperative"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPotentialPluginWithId < T >  ( pluginId ,    potentialPlugin )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.plugins.DefaultPotentialPluginWithId"}, {"methodBody": ["METHOD_START", "{", "if    (  ( dynamicObject )     =  =    null )     {", "this . dynamicObject    =     . toType ( object ,    DynamicObjectAware . class )  . getAsDynamicObject (  )  ;", "}", "return   dynamicObject ;", "}", "METHOD_END"], "methodName": ["getAsDynamicObject"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( convention )     =  =    null )     {", "this . convention    =     . toType ( object ,    HasConvention . class )  . getConvention (  )  ;", "}", "return   convention ;", "}", "METHOD_END"], "methodName": ["getConvention"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( conventionMapping )     =  =    null )     {", "this . conventionMapping    =     . toType ( object ,    IConventionAware . class )  . getConventionMapping (  )  ;", "}", "return   conventionMapping ;", "}", "METHOD_END"], "methodName": ["getConventionMapping"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( object )    instanceof   DynamicObjectAware )     {", "return   object . getClass (  )  . getSuperclass (  )  ;", "}", "return   object . getClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredType"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( extensionContainer )     =  =    null )     {", "this . extensionContainer    =     . toType ( object ,    ExtensionAware . class )  . getExtensions (  )  ;", "}", "return   extensionContainer ;", "}", "METHOD_END"], "methodName": ["getExtensions"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    ( type . isInstance ( delegate )  )     {", "return   type . cast ( delegate )  ;", "} else    {", "throw   new   IllegalStateException ( String . format (  \" Cannot   create      for    '  % s '     ( class :     % s )    as   it   does   not   implement    '  % s '     ( it   is   not   a   DSL   object )  \"  ,    delegate ,    delegate . getClass (  )  . getSimpleName (  )  ,    type . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toType"], "fileName": "org.gradle.api.internal.plugins.DslObject"}, {"methodBody": ["METHOD_START", "{", "if    ( hasExtension ( name )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   add   extension   with   name    '  % s '  ,    as   there   is   an   extension   already   registered   with   that   name .  \"  ,    name )  )  ;", "}", "extensions . put ( name ,    wrap ( name ,    publicType ,    extension )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "ExtensionsStorage . ExtensionHolder < T >    extensionHolder    =    Cast . uncheckedCast ( extensions . get ( name )  )  ;", "return   extensionHolder . configure ( action )  ;", "}", "METHOD_END"], "methodName": ["configureExtension"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "getHolderByType ( type )  . configure ( action )  ;", "}", "METHOD_END"], "methodName": ["configureExtension"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "ExtensionsStorage . ExtensionHolder   extensionHolder    =    extensions . get ( name )  ;", "return   extensionHolder    !  =    null    ?    extensionHolder . get (  )     :    null ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "ExtensionsStorage . ExtensionHolder < T >    found    =    findHolderByType ( type )  ;", "return   found    !  =    null    ?    found . get (  )     :    null ;", "}", "METHOD_END"], "methodName": ["findByType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "ExtensionsStorage . ExtensionHolder < T >    firstHolderWithExactPublicType    =    firstHolderWithExactPublicType ( type )  ;", "return   firstHolderWithExactPublicType    !  =    null    ?    firstHolderWithExactPublicType    :    firstHolderWithAssignableType ( type )  ;", "}", "METHOD_END"], "methodName": ["findHolderByType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "for    ( ExtensionsStorage . ExtensionHolder   extensionHolder    :    extensions . values (  )  )     {", "if    ( type . isAssignableFrom ( extensionHolder . getPublicType (  )  )  )     {", "return   Cast . uncheckedCast ( extensionHolder )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["firstHolderWithAssignableType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "for    ( ExtensionsStorage . ExtensionHolder   extensionHolder    :    extensions . values (  )  )     {", "if    ( type . equals ( extensionHolder . getPublicType (  )  )  )     {", "return   Cast . uncheckedCast ( extensionHolder )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["firstHolderWithExactPublicType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    rawExtensions    =    new   LinkedHashMap < String ,    Object >  ( extensions . size (  )  )  ;", "for    ( Map . Entry < String ,     . ExtensionHolder >    entry    :    extensions . entrySet (  )  )     {", "rawExtensions . put ( entry . getKey (  )  ,    entry . getValue (  )  . get (  )  )  ;", "}", "return   rawExtensions ;", "}", "METHOD_END"], "methodName": ["getAsMap"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "Object   extension    =    findByName ( name )  ;", "if    ( extension    !  =    null )     {", "return   extension ;", "}", "throw   new   UnknownDomainObjectException (  (  (  (  \"    with   name    '  \"     +    name )     +     \"  '    does   not   exist .    Currently   registered   extension   names :     \"  )     +     ( extensions . keySet (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getByName"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "return   getHolderByType ( type )  . get (  )  ;", "}", "METHOD_END"], "methodName": ["getByType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "ExtensionsStorage . ExtensionHolder < T >    found    =    findHolderByType ( type )  ;", "if    ( found    !  =    null )     {", "return   found ;", "}", "throw   new   UnknownDomainObjectException (  (  (  (  \" Extension   of   type    '  \"     +     ( type . getSimpleName (  )  )  )     +     \"  '    does   not   exist .    Currently   registered   extension   types :     \"  )     +     ( registeredExtensionTypeNames (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getHolderByType"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "return   DefaultExtensionsSchema . create ( extensions . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSchema"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "return   extensions . containsKey ( name )  ;", "}", "METHOD_END"], "methodName": ["hasExtension"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "return   extension . getClass (  )  . isAnnotationPresent ( DeferredConfigurable . class )  ;", "}", "METHOD_END"], "methodName": ["isDeferredConfigurable"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "List < String >    types    =    new   ArrayList < String >  ( extensions . size (  )  )  ;", "for    (  . ExtensionHolder   holder    :    extensions . values (  )  )     {", "types . add ( holder . getPublicType (  )  . getSimpleName (  )  )  ;", "}", "return   types ;", "}", "METHOD_END"], "methodName": ["registeredExtensionTypeNames"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "if    ( isDeferredConfigurable ( extension )  )     {", "return   new    . DeferredConfigurableExtensionHolder < T >  ( name ,    publicType ,    extension )  ;", "}", "return   new    . ExtensionHolder < T >  ( name ,    publicType ,    extension )  ;", "}", "METHOD_END"], "methodName": ["wrap"], "fileName": "org.gradle.api.internal.plugins.ExtensionsStorage"}, {"methodBody": ["METHOD_START", "{", "Plugin < T >    cast    =    Cast . uncheckedCast ( plugin )  ;", "cast . apply ( target )  ;", "}", "METHOD_END"], "methodName": ["applyImperative"], "fileName": "org.gradle.api.internal.plugins.ImperativeOnlyPluginTarget"}, {"methodBody": ["METHOD_START", "{", "applyRules ( pluginId ,    plugin . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["applyImperativeRulesHybrid"], "fileName": "org.gradle.api.internal.plugins.ImperativeOnlyPluginTarget"}, {"methodBody": ["METHOD_START", "{", "String   message    =    String . format (  \" Cannot   apply   model   rules   of   plugin    '  % s '    as   the   target    '  % s '    is   not   model   rule   aware \"  ,    clazz . getName (  )  ,    target . toString (  )  )  ;", "throw   new   UnsupportedOperationException ( message )  ;", "}", "METHOD_END"], "methodName": ["applyRules"], "fileName": "org.gradle.api.internal.plugins.ImperativeOnlyPluginTarget"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    GUtil . loadProperties ( propertiesFileUrl )  ;", "return   properties . getProperty (  \" implementation - class \"  )  ;", "}", "METHOD_END"], "methodName": ["getImplementationClassName"], "fileName": "org.gradle.api.internal.plugins.PluginDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   propertiesFileUrl ;", "}", "METHOD_END"], "methodName": ["getPropertiesFileUrl"], "fileName": "org.gradle.api.internal.plugins.PluginDescriptor"}, {"methodBody": ["METHOD_START", "{", "boolean   implementsInterface    =    Plugin . class . isAssignableFrom ( type )  ;", "boolean   hasRules    =    this . modelRuleSourceDetector . hasRules ( type )  ;", "if    ( implementsInterface )     {", "@ SuppressWarnings (  \" unchecked \"  )", "Class <  ?    extends   Plugin <  ?  >  >    cast    =     (  ( Class <  ?    extends   Plugin <  ?  >  >  )     ( type )  )  ;", "return   Cast . uncheckedCast ( toImperative ( cast ,    hasRules )  )  ;", "} else", "if    ( hasRules )     {", "return   new    . PotentialPureRuleSourceClassPlugin < T >  ( type )  ;", "} else    {", "return   new    . PotentialUnknownTypePlugin < T >  ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["inspect"], "fileName": "org.gradle.api.internal.plugins.PluginInspector"}, {"methodBody": ["METHOD_START", "{", "if    ( hasRules )     {", "return   new    . PotentialHybridImperativeAndRulesPlugin < T >  ( type )  ;", "} else    {", "return   new    . PotentialImperativeClassPlugin < T >  ( type )  ;", "}", "}", "METHOD_END"], "methodName": ["toImperative"], "fileName": "org.gradle.api.internal.plugins.PluginInspector"}, {"methodBody": ["METHOD_START", "{", "imperativeTarget . applyImperative ( pluginId ,    plugin )  ;", "}", "METHOD_END"], "methodName": ["applyImperative"], "fileName": "org.gradle.api.internal.plugins.RuleBasedPluginTarget"}, {"methodBody": ["METHOD_START", "{", "applyImperative ( pluginId ,    plugin )  ;", "applyRules ( pluginId ,    plugin . getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["applyImperativeRulesHybrid"], "fileName": "org.gradle.api.internal.plugins.RuleBasedPluginTarget"}, {"methodBody": ["METHOD_START", "{", "ModelRegistry   modelRegistry    =    target . getModelRegistry (  )  ;", "Iterable < Class <  ?    extends   RuleSource >  >    declaredSources    =    ruleDetector . getDeclaredSources ( clazz )  ;", "for    ( Class <  ?    extends   RuleSource >    ruleSource    :    declaredSources )     {", "ExtractedRuleSource <  ?  >    rules    =    ruleInspector . extract ( ruleSource )  ;", "for    ( Class <  ?  >    dependency    :    rules . getRequirs (  )  )     {", "target . getPluginManager (  )  . apply ( dependency )  ;", "}", "modelRegistry . getRoot (  )  . applyToSelf ( rules )  ;", "}", "}", "METHOD_END"], "methodName": ["applyRules"], "fileName": "org.gradle.api.internal.plugins.RuleBasedPluginTarget"}, {"methodBody": ["METHOD_START", "{", "apply ( ConfigureUtil . configureUsing ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.project.AbstractPluginAware"}, {"methodBody": ["METHOD_START", "{", "DefaultObjectConfigurationAction   action    =    createObjectConfigurationAction (  )  ;", "ConfigureUtil . configureByMap ( options ,    action )  ;", "action . execute (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.project.AbstractPluginAware"}, {"methodBody": ["METHOD_START", "{", "DefaultObjectConfigurationAction   configAction    =    createObjectConfigurationAction (  )  ;", "action . execute ( configAction )  ;", "configAction . execute (  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.project.AbstractPluginAware"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getConfigurationTargetIdentifier"], "fileName": "org.gradle.api.internal.project.AbstractPluginAware"}, {"methodBody": ["METHOD_START", "{", "return   getPluginManager (  )  . getPluginContainer (  )  ;", "}", "METHOD_END"], "methodName": ["getPlugins"], "fileName": "org.gradle.api.internal.project.AbstractPluginAware"}, {"methodBody": ["METHOD_START", "{", "buildOperationExecutor . run ( new   BuildOperationCrossProjectConfigurator . BlockConfigureBuildOperation ( details ,    projects )     {", "@ Override", "protected   void   doRunProjectConfigure ( Project   project )     {", "runProjectConfigureAction ( project ,    configureAction )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["runBlockConfigureAction"], "fileName": "org.gradle.api.internal.project.BuildOperationCrossProjectConfigurator"}, {"methodBody": ["METHOD_START", "{", "buildOperationExecutor . run ( new   BuildOperationCrossProjectConfigurator . BlockConfigureBuildOperation ( details ,    projects )     {", "@ Override", "protected   void   doRunProjectConfigure ( Project   project )     {", "runProjectConfigureClosure ( project ,    configureClosure )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["runBlockConfigureClosure"], "fileName": "org.gradle.api.internal.project.BuildOperationCrossProjectConfigurator"}, {"methodBody": ["METHOD_START", "{", "buildOperationExecutor . run ( new   BuildOperationCrossProjectConfigurator . CrossConfigureProjectBuildOperation ( project )     {", "@ Override", "public   void   run ( BuildOperationContext   context )     {", "Actions . with ( project ,    configureAction )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["runProjectConfigureAction"], "fileName": "org.gradle.api.internal.project.BuildOperationCrossProjectConfigurator"}, {"methodBody": ["METHOD_START", "{", "buildOperationExecutor . run ( new   BuildOperationCrossProjectConfigurator . CrossConfigureProjectBuildOperation ( project )     {", "@ Override", "public   void   run ( BuildOperationContext   context )     {", "ConfigureUtil . configure ( configureClosure ,    project )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["runProjectConfigureClosure"], "fileName": "org.gradle.api.internal.project.BuildOperationCrossProjectConfigurator"}, {"methodBody": ["METHOD_START", "{", "String   previous    =    null ;", "for    ( fi   String   dependency    :    dependencies )     {", "if    ( previous    !  =    null )     {", "fi   String   fiPrevious    =    previous ;", "tasks . all ( new   Action < Task >  (  )     {", "public   void   execute ( Task   task )     {", "if    ( task . getName (  )  . equals ( dependency )  )     {", "task . shouldRunAfter ( fiPrevious )  ;", "}", "}", "}  )  ;", "}", "previous    =    dependency ;", "}", "}", "METHOD_END"], "methodName": ["addDependencyOrdering"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "task . setTarget ( target )  ;", "task . setBaseDir ( baseDir )  ;", "final   List < String >    taskDependencyNames    =     . getTaskDependencyNames ( target ,    taskNamer )  ;", "task . dependsOn ( new    . AntTargetsTaskDependency ( taskDependencyNames )  )  ;", ". addDependencyOrdering ( taskDependencyNames ,    task . getProject (  )  . getTasks (  )  )  ;", "}", "METHOD_END"], "methodName": ["configureTask"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "PropertyHelper . getPropertyHelper ( getProject (  )  )  . setUserProperty ( null ,    property ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["doSetProperty"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "ObservableMap   map    =    new   ObservableMap ( getProject (  )  . getProperties (  )  )  ;", "map . addPropertyChangeListener ( new   PropertyChangeListener (  )     {", "public   void   propertyChange ( PropertyChangeEvent   event )     {", "doSetProperty ( event . getPropertyName (  )  ,    event . getNewValue (  )  )  ;", "}", "}  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    castMap    =     (  ( Map < String ,    Object >  )     ( map )  )  ;", "return   castMap ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "ObservableMap   map    =    new   ObservableMap ( getProject (  )  . getReferences (  )  )  ;", "map . addPropertyChangeListener ( new   PropertyChangeListener (  )     {", "public   void   propertyChange ( PropertyChangeEvent   event )     {", "getProject (  )  . addReference ( event . getPropertyName (  )  ,    event . getNewValue (  )  )  ;", "}", "}  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "Map < String ,    Object >    castMap    =     (  ( Map < String ,    Object >  )     ( map )  )  ;", "return   castMap ;", "}", "METHOD_END"], "methodName": ["getReferences"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "Enumeration < String >    dependencies    =    target . getDependencies (  )  ;", "List < String >    taskDependencyNames    =    Lists . newLinkedList (  )  ;", "while    ( dependencies . hasMoreElements (  )  )     {", "String   targetName    =    dependencies . nextElement (  )  ;", "String   taskName    =    taskNamer . transform ( targetName )  ;", "taskDependencyNames . add ( taskName )  ;", "}", "return   taskDependencyNames ;", "}", "METHOD_END"], "methodName": ["getTaskDependencyNames"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "importBuild ( antBuildFile ,    Transformers .  < String > noOpTransformer (  )  )  ;", "}", "METHOD_END"], "methodName": ["importBuild"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "File   file    =    gradleProject . file ( antBuildFile )  ;", "final   File   baseDir    =    file . getParentFile (  )  ;", "Set < String >    existingAntTargets    =    new   HashSet < String >  ( getAntProject (  )  . getTargets (  )  . keySet (  )  )  ;", "File   oldBaseDir    =    getAntProject (  )  . getBaseDir (  )  ;", "getAntProject (  )  . setBaseDir ( baseDir )  ;", "try    {", "getAntProject (  )  . setUserProperty ( ANT _ FILE ,    file . getAbsolutePath (  )  )  ;", "ProjectHelper . configureProject ( getAntProject (  )  ,    file )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException (  (  (  \" Could   not   import   Ant   build   file    '  \"     +     ( String . valueOf ( file )  )  )     +     \"  '  .  \"  )  ,    e )  ;", "}    finally    {", "getAntProject (  )  . setBaseDir ( oldBaseDir )  ;", "}", "getAntProject (  )  . getTargets (  )  . remove (  \"  \"  )  ;", "Set < String >    newAntTargets    =    new   HashSet < String >  ( getAntProject (  )  . getTargets (  )  . keySet (  )  )  ;", "newAntTargets . removeAll ( existingAntTargets )  ;", "for    ( String   name    :    newAntTargets )     {", "final   Target   target    =    getAntProject (  )  . getTargets (  )  . get ( name )  ;", "String   taskName    =    taskNamer . transform ( target . getName (  )  )  ;", "final   AntTarget   task    =    gradleProject . getTasks (  )  . create ( taskName ,    AntTarget . class )  ;", ". configureTask ( target ,    task ,    baseDir ,    taskNamer )  ;", "}", "}", "METHOD_END"], "methodName": ["importBuild"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( getProject (  )  . getProperties (  )  . containsKey ( name )  )     {", "return   getProject (  )  . getProperties (  )  . get ( name )  ;", "}", "throw   new   MissingPropertyException ( name ,    getClass (  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "doSetProperty ( property ,    newValue )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilder"}, {"methodBody": ["METHOD_START", "{", "stoppable . stop (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "AntLoggingAdapter   loggingAdapter    =    loggingAdapterFactory . create (  )  ;", "antBuilder    =    new    ( project ,    loggingAdapter )  ;", "antBuilder . getProject (  )  . setBaseDir ( project . getProjectDir (  )  )  ;", "antBuilder . getProject (  )  . removeBuildListener ( antBuilder . getProject (  )  . getBuildListeners (  )  . get (  0  )  )  ;", "antBuilder . getProject (  )  . addBuildListener ( loggingAdapter )  ;", "stoppable . add ( antBuilder )  ;", "return   antBuilder ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.project.DefaultAntBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( projectToEvaluate . getState (  )  . getExecuting (  )  )     {", "throw   new   CircularReferenceException ( String . format (  \" Circular   referencing   during   evaluation   for    % s .  \"  ,    projectToEvaluate )  )  ;", "}", "return   projectToEvaluate . evaluate (  )  ;", "}", "METHOD_END"], "methodName": ["evaluationDependsOn"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( antBuilderFactory )     =  =    null )     {", "antBuilderFactory    =    services . getFactory ( AntBuilder . class )  ;", "}", "return   antBuilderFactory ;", "}", "METHOD_END"], "methodName": ["getAntBuilderFactory"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getDeferredProjectConfiguration"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileOperations"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getModelSchemaStore"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getProcessOperations"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectConfigurator"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( projectEvaluator )     =  =    null )     {", "projectEvaluator    =    services . get ( ProjectEvaluator . class )  ;", "}", "return   projectEvaluator ;", "}", "METHOD_END"], "methodName": ["getProjectEvaluator"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptHandlerFactory"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptPluginFactory"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return    (  \" Project .  < init >  .  \"     +    path )     +     \"  (  )  \"  ;", "}", "METHOD_END"], "methodName": ["instanceDescriptorFor"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "ModelRegistry   modelRegistry    =    getModelRegistry (  )  ;", "if    ( TransformedModelDslBacking . isTransformedBlock ( modelRules )  )     {", "ClosureBackedAction . execute ( new   TransformedModelDslBacking ( modelRegistry ,    this . getRootProject (  )  . getFileResolver (  )  )  ,    modelRules )  ;", "} else    {", "new   model . dsl . internal . NonTransformedModelDslBacking ( modelRegistry )  . configure ( modelRules )  ;", "}", "}", "METHOD_END"], "methodName": ["model"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return   object ;", "}", "METHOD_END"], "methodName": ["passThrough"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "registerServiceOn ( modelRegistry ,     \" serviceRegistry \"  ,    DefaultProject . SERVICE _ REGISTRY _ MODEL _ TYPE ,    services ,    instanceDescriptorFor (  \" serviceRegistry \"  )  )  ;", "registerFactoryOn ( modelRegistry ,     \" buildDir \"  ,    DefaultProject . FILE _ MODEL _ TYPE ,    new   Factory < File >  (  )     {", "@ Override", "public   File   create (  )     {", "return   getBuildDir (  )  ;", "}", "}  )  ;", "registerInstanceOn ( modelRegistry ,     \" projectIdentifier \"  ,    DefaultProject . PROJECT _ IDENTIFIER _ MODEL _ TYPE ,    this )  ;", "registerInstanceOn ( modelRegistry ,     \" extensionContainer \"  ,    DefaultProject . EXTENSION _ CONTAINER _ MODEL _ TYPE ,    getExtensions (  )  )  ;", "modelRegistry . getRoot (  )  . applyToSelf ( DefaultProject . BasicServicesRules . class )  ;", "}", "METHOD_END"], "methodName": ["populateModelRegistry"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "modelRegistry . register ( ModelRegistrations . unmanagedInstance ( ModelReference . of ( path ,    type )  ,    factory )  . descriptor ( instanceDescriptorFor ( path )  )  . hidden ( true )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerFactoryOn"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "registerFactoryOn ( modelRegistry ,    path ,    type ,    Factories . constant ( instance )  )  ;", "}", "METHOD_END"], "methodName": ["registerInstanceOn"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "modelRegistry . register ( serviceInstance ( of ( path ,    type )  ,    instance )  . descriptor ( descriptor )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["registerServiceOn"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . ant    =    ant ;", "}", "METHOD_END"], "methodName": ["setAnt"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . artifactHandler    =    artifactHandler ;", "}", "METHOD_END"], "methodName": ["setArtifactHandler"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . configurationContainer    =    configurationContainer ;", "}", "METHOD_END"], "methodName": ["setConfigurationContainer"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . dependencyHandler    =    dependencyHandler ;", "}", "METHOD_END"], "methodName": ["setDependencyHandler"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . fileResolver    =    fileResolver ;", "}", "METHOD_END"], "methodName": ["setFileResolver"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "this . projectEvaluator    =    projectEvaluator ;", "}", "METHOD_END"], "methodName": ["setProjectEvaluator"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return   taskContainer . create ( task . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return   task ( task . toString (  )  ,    configureClosure )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return   task ( options ,    task . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "return   task ( options ,    task . toString (  )  ,    configureClosure )  ;", "}", "METHOD_END"], "methodName": ["task"], "fileName": "org.gradle.api.internal.project.DefaultProject"}, {"methodBody": ["METHOD_START", "{", "evaluateProjectAndDiscoverTasks ( targetProject )  ;", "}", "METHOD_END"], "methodName": ["beforeRequestingTaskByPath"], "fileName": "org.gradle.api.internal.project.DefaultProjectAccessListener"}, {"methodBody": ["METHOD_START", "{", "evaluateProjectAndDiscoverTasks ( targetProject )  ;", "}", "METHOD_END"], "methodName": ["beforeResolvingProjectDependency"], "fileName": "org.gradle.api.internal.project.DefaultProjectAccessListener"}, {"methodBody": ["METHOD_START", "{", "targetProject . evaluate (  )  ;", "targetProject . getTasks (  )  . discoverTasks (  )  ;", "}", "METHOD_END"], "methodName": ["evaluateProjectAndDiscoverTasks"], "fileName": "org.gradle.api.internal.project.DefaultProjectAccessListener"}, {"methodBody": ["METHOD_START", "{", "projects . put ( project . getPath (  )  ,    project )  ;", "subProjects . put ( project . getPath (  )  ,    new   HashSet < T >  (  )  )  ;", "addProjectToParentSubProjects ( project )  ;", "}", "METHOD_END"], "methodName": ["addProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "ProjectIdentifier   loopProject    =    project . getParentIdentifier (  )  ;", "while    ( loopProject    !  =    null )     {", "subProjects . get ( loopProject . getPath (  )  )  . add ( project )  ;", "loopProject    =    loopProject . getParentIdentifier (  )  ;", "}", "}", "METHOD_END"], "methodName": ["addProjectToParentSubProjects"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < T >    matches    =    new   HashSet < T >  (  )  ;", "for    ( T       :    s . values (  )  )     {", "if    ( constraint . isSatisfiedBy (  )  )     {", "matches . add (  )  ;", "}", "}", "return   matches ;", "}", "METHOD_END"], "methodName": ["findAll"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   HashSet < T >  ( projects . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllProjects"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < T >    result    =    new   HashSet < T >  ( getSubProjects ( path )  )  ;", "if    (  ( projects . get ( path )  )     !  =    null )     {", "result . add ( projects . get ( path )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getAllProjects"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "Set < T >    projects    =    findAll ( new   Spec < T >  (  )     {", "public   boolean   isSatisfiedBy ( T   element )     {", "return   element . getProjectDir (  )  . equals ( projectDir )  ;", "}", "}  )  ;", "if    (  ( projects . size (  )  )     >     1  )     {", "throw   new   InvalidUserDataException ( String . format (  \" Found   multiple   projects   with   project   directory    '  % s '  :     % s \"  ,    projectDir ,    projects )  )  ;", "}", "return    ( projects . size (  )  )     =  =     1     ?    projects . iterator (  )  . next (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "return   projects . get ( path )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "return   GUtil . elvis ( subProjects . get ( path )  ,    new   HashSet < T >  (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSubProjects"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "T    =     . remove ( path )  ;", "assert    !  =    null ;", "subProjects . remove ( path )  ;", "ProjectIdentifier   loopProject    =    getParentIdentifier (  )  ;", "while    ( loopProject    !  =    null )     {", "subProjects . get ( loopProject . getPath (  )  )  . remove (  ;", "loopProject    =    loopProject . getParentIdentifier (  )  ;", "}", "return", "}", "METHOD_END"], "methodName": ["removeProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistry"}, {"methodBody": ["METHOD_START", "{", "projectRegistry    =    new   DefaultProjectRegistry < ProjectInternal >  (  )  ;", "Project   otherRoot    =    TestUtil . create ( temporaryFolder . getTestDirectory (  )  )  . rootProject (  )  ;", "assertNull ( projectRegistry . getProject ( otherRoot . getPath (  )  )  )  ;", "assertEquals ( new   TreeSet < ProjectInternal >  (  )  ,    projectRegistry . getAllProjects ( otherRoot . getPath (  )  )  )  ;", "assertEquals ( new   TreeSet < ProjectInternal >  (  )  ,    projectRegistry . getSubProjects ( otherRoot . getPath (  )  )  )  ;", "assertNull ( projectRegistry . getProject ( otherRoot . getProjectDir (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["accessMethodsForNonExistingsPaths"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "checkAccessMethods ( rootMock ,    WrapUtil . toSortedSet ( rootMock ,    childMock ,    childChildMock )  ,    WrapUtil . toSortedSet ( childMock ,    childChildMock )  ,    rootMock )  ;", "checkAccessMethods ( childMock ,    WrapUtil . toSortedSet ( childMock ,    childChildMock )  ,    WrapUtil . toSortedSet ( childChildMock )  ,    childMock )  ;", "checkAccessMethods ( childChildMock ,    WrapUtil . toSortedSet ( childChildMock )  ,    new   TreeSet (  )  ,    childChildMock )  ;", "}", "METHOD_END"], "methodName": ["addProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( projectRegistry . getAllProjects (  )  ,    equalTo ( WrapUtil . toSet (  (  ( ProjectInternal )     ( rootMock )  )  ,    childMock ,    childChildMock )  )  )  ;", "}", "METHOD_END"], "methodName": ["canLocalAllProjects"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "Spec < Project >    spec    =    new   Spec < Project >  (  )     {", "public   boolean   isSatisfiedBy ( Project   element )     {", "return   element . getName (  )  . contains (  \" child \"  )  ;", "}", "}  ;", "assertThat ( p . findAll ( spec )  ,    equalTo ( WrapUtil . toSet (  (  ( ProjectInternal )     ( childMock )  )  ,    childChildMock )  )  )  ;", "}", "METHOD_END"], "methodName": ["canLocateAllProjectsWhichMatchSpec"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "String   path    =    childChildMock . getPath (  )  ;", "assertThat ( p . removeProject ( path )  ,    sameInstance (  (  ( ProjectInternal )     ( childChildMock )  )  )  )  ;", "assertThat ( p . getProject ( path )  ,    nullValue (  )  )  ;", "assertThat ( p . getProject ( childChildMock . getProjectDir (  )  )  ,    nullValue (  )  )  ;", "assertTrue ( p . getAllProjects ( path )  . isEmpty (  )  )  ;", "assertTrue ( p . getSubProjects ( path )  . isEmpty (  )  )  ;", "assertFalse ( p . getAllProjects (  )  . contains ( childChildMock )  )  ;", "assertFalse ( p . getAllProjects (  \"  :  \"  )  . contains ( childChildMock )  )  ;", "assertFalse ( p . getSubProjects (  \"  :  \"  )  . contains ( childChildMock )  )  ;", "}", "METHOD_END"], "methodName": ["canRemoveProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "ProjectInternal   duplicateProjectDirProject    =    TestUtil . createChildProject ( childMock ,     \" childchild 2  \"  ,    childMock . getProjectDir (  )  )  ;", "p . addProject ( duplicateProjectDirProject )  ;", "try    {", "p . getProject ( childMock . getProjectDir (  )  )  ;", "fail (  )  ;", "}    catch    ( InvalidUserDataException   e )     {", "assertThat ( e . getMessage (  )  ,    startsWith (  \" Found   multiple   projects   with   project   directory    \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["cannotLocateProjectsWithAmbiguousProjectDir"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertSame ( expectedGetProject ,    projectRegistry . getProject ( project . getPath (  )  )  )  ;", "assertEquals ( expectedAllProjects ,    projectRegistry . getAllProjects ( project . getPath (  )  )  )  ;", "assertEquals ( expectedSubProjects ,    projectRegistry . getSubProjects ( project . getPath (  )  )  )  ;", "Assert . assertSame ( expectedGetProject ,    projectRegistry . getProject ( project . getProjectDir (  )  )  )  ;", "assertTrue ( projectRegistry . getAllProjects (  )  . contains ( project )  )  ;", "}", "METHOD_END"], "methodName": ["checkAccessMethods"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertSame ( rootMock ,    projectRegistry . getRootProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["rootProject"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "projectRegistry    =    new   DefaultProjectRegistry < ProjectInternal >  (  )  ;", "rootMock    =    TestUtil . create ( temporaryFolder )  . rootProject (  )  ;", "childMock    =    TestUtil . createChildProject ( rootMock ,     . CHILD _ NAME )  ;", "childChildMock    =    TestUtil . createChildProject ( childMock ,     . CHILD _ CHILD _ NAME )  ;", "projectRegistry . addProject ( rootMock )  ;", "projectRegistry . addProject ( childMock )  ;", "projectRegistry . addProject ( childChildMock )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.internal.project.DefaultProjectRegistryTest"}, {"methodBody": ["METHOD_START", "{", "ProjectIprojectI =     (  ( ProjectI    ( project )  )  ;", "TaskContainerItasks    =    projectIgetTasks (  )  ;", "tasks . realize (  )  ;", "return   tasks ;", "}", "METHOD_END"], "methodName": ["listProjectTasks"], "fileName": "org.gradle.api.internal.project.DefaultProjectTaskLister"}, {"methodBody": ["METHOD_START", "{", "if    ( fired )     {", "String   message    =     \" Cannot   add   deferred   c   for   project    \"     +     ( project . getPath (  )  )  ;", "if    (  ( firedSentinel )     =  =    null )     {", "throw   new   IllegalStateException ( message )  ;", "} else    {", "throw   new   IllegalStateException ( message ,    firedSentinel )  ;", "}", "} else    {", "this . c . add ( c )  ;", "}", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.project.DeferredProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( fired )  )     {", "if    ( Boolean . getBoolean (  . TRACE )  )     {", "firedSentinel    =    new   Exception (  (  (  \" Project    '  \"     +     ( project . getPath (  )  )  )     +     \"  '    deferred   configuration   fired \"  )  )  ;", "}", "fired    =    true ;", "try    {", "for    ( Runnable   runnable    :    configuration )     {", "runnable . run (  )  ;", "}", "}    finally    {", "configuration . clear (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["fire"], "fileName": "org.gradle.api.internal.project.DeferredProjectConfiguration"}, {"methodBody": ["METHOD_START", "{", "File   buildFile    =    projectDescriptor . getBuildFile (  )  ;", "TextResource   resource    =    resourceLoader . loadFile (  \" build   file \"  ,    buildFile )  ;", "ScriptSource   source    =    new   TextResourceScriptSource ( resource )  ;", "NameValidator . validate ( projectDescriptor . getName (  )  ,     \" project   name \"  ,    DefaultProjectDescriptor . INVALID _ NAME _ IN _ INCLUDE _ HINT )  ;", "DefaultProject   project    =    instantiator . newInstance ( DefaultProject . class ,    projectDescriptor . getName (  )  ,    parent ,    projectDescriptor . getProjectDir (  )  ,    buildFile ,    source ,    gradle ,    gradle . getServiceRegistryFactory (  )  ,    selfClassLoaderScope ,    baseClassLoaderScope )  ;", "if    ( parent    !  =    null )     {", "parent . addChildProject ( project )  ;", "}", "projectRegistry . addProject ( project )  ;", "return   project ;", "}", "METHOD_END"], "methodName": ["createProject"], "fileName": "org.gradle.api.internal.project.ProjectFactory"}, {"methodBody": ["METHOD_START", "{", "getScriptTarget (  )  . apply ( closure )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "getScriptTarget (  )  . apply ( options )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "getScriptTarget (  )  . buildscript ( configureClosure )  ;", "}", "METHOD_END"], "methodName": ["buildscript"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . getBuildscript (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildscript"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . getLogger (  )  ;", "}", "METHOD_END"], "methodName": ["getLogger"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . getLogging (  )  ;", "}", "METHOD_END"], "methodName": ["getLogging"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . getStandardOutputCapture (  )  ;", "}", "METHOD_END"], "methodName": ["getStandardOutputCapture"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.api.internal.project.ProjectScript"}, {"methodBody": ["METHOD_START", "{", "executed    =    true ;", "}", "METHOD_END"], "methodName": ["executed"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "assert    ( this . failure )     =  =    null ;", "this . failure    =    failure ;", "executed    =    true ;", "}", "METHOD_END"], "methodName": ["executed"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   executed ;", "}", "METHOD_END"], "methodName": ["getExecuted"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   executing ;", "}", "METHOD_END"], "methodName": ["getExecuting"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   failure ;", "}", "METHOD_END"], "methodName": ["getFailure"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( failure )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasFailure"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failure )     =  =    null )     {", "retu ;", "}", "throw   UncheckedException . throwAsUncheckedException ( failure )  ;", "}", "METHOD_END"], "methodName": ["rethrowFailure"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "this . executing    =    executing ;", "}", "METHOD_END"], "methodName": ["setExecuting"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "String   state ;", "if    ( getExecuting (  )  )     {", "state    =     \" EXECUTING \"  ;", "} else", "if    ( getExecuted (  )  )     {", "if    (  ( failure )     =  =    null )     {", "state    =     \" EXECUTED \"  ;", "} else    {", "state    =    String . format (  \" FAILED    (  % s )  \"  ,    failure . getMessage (  )  )  ;", "}", "} else    {", "state    =     \" NOT   EXECUTED \"  ;", "}", "return   String . format (  \"    state    '  % s '  \"  ,    state )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.api.internal.project.ProjectStateInternal"}, {"methodBody": ["METHOD_START", "{", "Project    =    getProject (  )  ;", "fireBuildFinished ( null )  ;", "ComponentHelper   helper    =    ComponentHelper . getComponentHelper (  ;", "helper . getAntTypeTable (  )  . clear (  )  ;", "helper . getDataTypeDefinitions (  )  . clear (  )  ;", "getReferences (  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.api.internal.project.ant.BasicAntBuilder"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    super . doInvokeMethod ( methodName ,    name ,    args )  ;", "try    {", "nodeField . set ( this ,    null )  ;", "children . clear (  )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["doInvokeMethod"], "fileName": "org.gradle.api.internal.project.ant.BasicAntBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["importBuild"], "fileName": "org.gradle.api.internal.project.ant.BasicAntBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["importBuild"], "fileName": "org.gradle.api.internal.project.ant.BasicAntBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "retu   nodeField . get ( this )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["postNodeCompletion"], "fileName": "org.gradle.api.internal.project.ant.BasicAntBuilder"}, {"methodBody": ["METHOD_START", "{", "DynamicObject   project    =    DynamicObjectUtil . asDynamicObject ( builder . getProperty (  \" project \"  )  )  ;", "project . invokeMethod (  \" addTaskDefinition \"  ,    name ,    antlibClassLoader . loadClass ( className )  )  ;", "}", "METHOD_END"], "methodName": ["addTaskDefinition"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   builder . invokeMethod (  \" createNode \"  ,    name )  ;", "}", "METHOD_END"], "methodName": ["createNode"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   builder . invokeMethod (  \" createNode \"  ,    name ,    value )  ;", "}", "METHOD_END"], "methodName": ["createNode"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" taskdef \"  )  )     {", "taskdef ( Cast .  < Map < String ,    String >  > uncheckedCast ( attributes )  )  ;", "} else    {", "return   invokeMethod (  \" createNode \"  ,    name ,    attributes )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["createNode"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   builder . invokeMethod (  \" createNode \"  ,    name ,    attributes ,    value )  ;", "}", "METHOD_END"], "methodName": ["createNode"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getAnt"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   originalBuilder ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent    =  =    null )     &  &     ( node    =  =    null )  )     {", "return ;", "}", "invokeMethod (  \" nodeCompleted \"  ,    parent ,    node )  ;", "}", "METHOD_END"], "methodName": ["nodeCompleted"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   builder . invokeMethod (  \" postNodeCompletion \"  ,    parent ,    node )  ;", "}", "METHOD_END"], "methodName": ["postNodeCompletion"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   builder . getProperty ( name )  ;", "}", "METHOD_END"], "methodName": ["propertyMissing"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "builder . invokeMethod (  \" setParent \"  ,    parent ,    child )  ;", "}", "METHOD_END"], "methodName": ["setParent"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "Set < String >    argNames    =    args . keySet (  )  ;", "if    ( argNames . equals ( ImmutableSet . of (  \" name \"  ,     \" classname \"  )  )  )     {", "try    {", "String   name    =    args . get (  \" name \"  )  ;", "String   className    =    args . get (  \" classname \"  )  ;", "addTaskDefinition ( name ,    className )  ;", "}    catch    ( ClassNotFoundException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "} else", "if    ( argNames . equals ( singleton (  \" resource \"  )  )  )     {", "InputStream   instr    =    antlibClassLoader . getResourceAsStream ( args . get (  \" resource \"  )  )  ;", "try    {", "groovy . util . Node   xml    =    new   groovy . util . XmlParser (  )  . parse ( instr )  ;", "for    ( Object   taskdefObject    :     (  ( groovy . util . NodeList )     ( xml . get (  \" taskdef \"  )  )  )  )     {", "groovy . util . Node   taskdef    =     (  ( groovy . util . Node )     ( taskdefObject )  )  ;", "String   name    =     (  ( String )     ( taskdef . get (  \"  @ name \"  )  )  )  ;", "String   className    =     (  ( String )     ( taskdef . get (  \"  @ classname \"  )  )  )  ;", "addTaskDefinition ( name ,    className )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   internal . UncheckedException . throwAsUncheckedException ( ex )  ;", "}    finally    {", "closeQuietly ( instr )  ;", "}", "} else    {", "throw   new   RuntimeException (  (  \" Unsupported   parameters   for   taskdef (  )  :     \"     +    args )  )  ;", "}", "}", "METHOD_END"], "methodName": ["taskdef"], "fileName": "org.gradle.api.internal.project.antbuilder.AntBuilderDelegate"}, {"methodBody": ["METHOD_START", "{", "return   key ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.gradle.api.internal.project.antbuilder.CacheEntry"}, {"methodBody": ["METHOD_START", "{", "return   classLoader ;", "}", "METHOD_END"], "methodName": ["getClassLoader"], "fileName": "org.gradle.api.internal.project.antbuilder.CachedClassLoader"}, {"methodBody": ["METHOD_START", "{", "return   key ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.gradle.api.internal.project.antbuilder.CachedClassLoader"}, {"methodBody": ["METHOD_START", "{", "return   cacheEntries . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.gradle.api.internal.project.antbuilder.ClassPathToClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "return   cacheEntry    !  =    null    ?    cacheEntry . get (  )     :    null ;", "}", "METHOD_END"], "methodName": ["maybeGet"], "fileName": "org.gradle.api.internal.project.antbuilder.ClassPathToClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "return   cacheEntries . size (  )  ;", "}", "METHOD_END"], "methodName": ["size"], "fileName": "org.gradle.api.internal.project.antbuilder.ClassPathToClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "finalizerThread . exit (  )  ;", "try    {", "finalizerThread . join (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.api.internal.project.antbuilder.ClassPathToClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "CachedClassLoader   cachedClassLoader ;", "lock . lock (  )  ;", "try    {", "CacheEntry   cacheEntry    =    cacheEntries . get ( libClasspath )  ;", "cachedClassLoader    =    maybeGet ( cacheEntry )  ;", "if    ( cachedClassLoader    =  =    null )     {", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  \" Classloader   cache   miss   for   classpath    :     {  }  .    Creating   classloader .  \"  ,    libClasspath . getAsURIs (  )  )  ;", "}", "ClassLoader   classLoader    =    factory . create (  )  ;", "cachedClassLoader    =    new   CachedClassLoader ( libClasspath ,    classLoader )  ;", "cacheEntry    =    new   CacheEntry ( libClasspath ,    cachedClassLoader )  ;", "GroovySystemLoader   groovySystemForLoader    =    groovySystemLoaderFactory . forClassLoader ( classLoader )  ;", "Cleanup   cleanup    =    new   Cleanup ( libClasspath ,    cachedClassLoader ,    finalizerThread . getReferenceQueue (  )  ,    classLoader ,    groovySystemForLoader ,    gradleApiGroovy ,    antBuilderAdapterGroovy )  ;", "finalizerThread . putCleanup ( libClasspath ,    cleanup )  ;", "cacheEntries . put ( libClasspath ,    cacheEntry )  ;", "} else    {", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  \" Classloader   found   in   cache :     {  }  \"  ,    libClasspath . getAsURIs (  )  )  ;", "}", "}", "inUseClassLoaders . add ( cachedClassLoader )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "try    {", "action . execute ( cachedClassLoader )  ;", "}    finally    {", "lock . lock (  )  ;", "try    {", "inUseClassLoaders . remove ( cachedClassLoader )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["withCachedClassLoader"], "fileName": "org.gradle.api.internal.project.antbuilder.ClassPathToClassLoaderCache"}, {"methodBody": ["METHOD_START", "{", "groovySystemForClassLoader . shutdown (  )  ;", "gradleApiGroovyLoader . discardTypesFrom ( classLoader )  ;", "antBuilderGroovyLoader . discardTypesFrom ( classLoader )  ;", "if    ( mode    =  =     (  . Mode . CLOSE _ CLASSLOADER )  )     {", "ClassLoaderUtils . tryClose ( classLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.gradle.api.internal.project.antbuilder.Cleanup"}, {"methodBody": ["METHOD_START", "{", "return   key ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.gradle.api.internal.project.antbuilder.Cleanup"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   project    =    getProject ( a )  ;", "Class <  ?  >    projectClass    =    project . getClass (  )  ;", "ClassLoader   cl    =    projectClass . getClassLoader (  )  ;", "Class <  ?  >    buildListenerClass    =    cl . loadClass (  \" BuildListener \"  )  ;", "Method   addBuildListener    =    projectClass . getDeclaredMethod (  \" addBuildListener \"  ,    buildListenerClass )  ;", "Method   removeBuildListener    =    projectClass . getDeclaredMethod (  \" removeBuildListener \"  ,    buildListenerClass )  ;", "Method   getBuildListeners    =    projectClass . getDeclaredMethod (  \" getBuildListeners \"  )  ;", "Vector   listeners    =     (  ( Vector )     ( getBuildListeners . invoke ( project )  )  )  ;", "removeBuildListener . invoke ( project ,    listeners . get (  0  )  )  ;", "addBuildListener . invoke ( project ,    antLogger )  ;", "}    catch    ( Exception   ex )     {", "throw   UncheckedException . throwAsUncheckedException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["configureAntBuilder"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "Object   project    =    getProject ( a )  ;", "Class <  ?  >    projectClass    =    project . getClass (  )  ;", "ClassLoader   cl    =    projectClass . getClassLoader (  )  ;", "Class <  ?  >    buildListenerClass    =    cl . loadClass (  \" BuildListener \"  )  ;", "Method   removeBuildListener    =    projectClass . getDeclaredMethod (  \" removeBuildListener \"  ,    buildListenerClass )  ;", "removeBuildListener . invoke ( project ,    antLogger )  ;", "a . getClass (  )  . getDeclaredMethod (  \" close \"  )  . invoke ( a )  ;", "}    catch    ( Exception   ex )     {", "throw   UncheckedException . throwAsUncheckedException ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["disposeBuilder"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "classLoaderCache . withCachedClassLoader ( libClasspath ,    gradleApiGroovyLoader ,    antAdapterGroovyLoader ,    new   Factory < ClassLoader >  (  )     {", "@ Override", "public   ClassLoader   create (  )     {", "return   new   VisitableURLClassLoader ( baseAntLoader ,    libClasspath )  ;", "}", "}  ,    new   Action < CachedClassLoader >  (  )     {", "@ Override", "public   void   execute ( CachedClassLoader   cachedClassLoader )     {", "ClassLoader   classLoader    =    cachedClassLoader . getClassLoader (  )  ;", "Object   antBuilder    =    newInstanceOf (  \"  . BasicAntBuilder \"  )  ;", "Object   antLogger    =    newInstanceOf (  \"  . AntLoggingAdapter \"  )  ;", "ClassLoader   originalLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( classLoader )  ;", "try    {", "configureAntBuilder ( antBuilder ,    antLogger )  ;", "Object   delegate    =    new   AntBuilderDelegate ( antBuilder ,    classLoader )  ;", "ClosureBackedAction . execute ( delegate ,    antClosure )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( originalLoader )  ;", "disposeBuilder ( antBuilder ,    antLogger )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "return   classLoaderCache ;", "}", "METHOD_END"], "methodName": ["getClassLoaderCache"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "return   antBuilder . getClass (  )  . getMethod (  \" getProject \"  )  . invoke ( antBuilder )  ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   antAdapterLoaloadClass ( className )  . newInstance (  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["newInstanceOf"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( DefaultIsolatedAntBuilder . LOG . isDebugEnabled (  )  )     {", "DefaultIsolatedAntBuilder . LOG . debug (  \" Forking   a   new   isolated   ant   builder   for   classpath    :     {  }  \"  ,    classpath )  ;", "}", "return   new   DefaultIsolatedAntBuilder ( this ,    classpath )  ;", "}", "METHOD_END"], "methodName": ["withClasspath"], "fileName": "org.gradle.api.internal.project.antbuilder.DefaultIsolatedAntBuilder"}, {"methodBody": ["METHOD_START", "{", "stopped . set ( true )  ;", "interrupt (  )  ;", "lock . lock (  )  ;", "try    {", "while    (  !  ( cleanups . isEmpty (  )  )  )     {", "Map . Entry < ClassPath ,    Cleanup >    entry    =    cleanups . entrySet (  )  . iterator (  )  . next (  )  ;", "removeCacheEntry ( entry . getKey (  )  ,    entry . getValue (  )  ,    Cleanup . Mode . CLOSE _ CLASSLOADER )  ;", "}", ". LOG . debug (  \" Completed   shutdown \"  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["exit"], "fileName": "org.gradle.api.internal.project.antbuilder.FinalizerThread"}, {"methodBody": ["METHOD_START", "{", "return   referenceQueue ;", "}", "METHOD_END"], "methodName": ["getReferenceQueue"], "fileName": "org.gradle.api.internal.project.antbuilder.FinalizerThread"}, {"methodBody": ["METHOD_START", "{", "cleanups . put ( key ,    cleanup )  ;", "}", "METHOD_END"], "methodName": ["putCleanup"], "fileName": "org.gradle.api.internal.project.antbuilder.FinalizerThread"}, {"methodBody": ["METHOD_START", "{", "if    ( FinalizerThread . LOG . isDebugEnabled (  )  )     {", "FinalizerThread . LOG . debug (  \" Removing   classloader   from   cache ,    classpath    =     {  }  \"  ,    key . getAsURIs (  )  )  ;", "}", "lock . lock (  )  ;", "try    {", "cacheEntries . remove ( key )  ;", "cleanups . remove ( key )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "try    {", "entry . clear (  )  ;", "entry . cleanup ( mode )  ;", "}    catch    ( Exception   ex )     {", "FinalizerThread . LOG . error (  (  \" Unable   to   perform   cleanup   of   classloader   for   classpath :     \"     +    key )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["removeCacheEntry"], "fileName": "org.gradle.api.internal.project.antbuilder.FinalizerThread"}, {"methodBody": ["METHOD_START", "{", "try    {", "while    (  !  ( stopped . get (  )  )  )     {", "Cleanup   entry    =     (  ( Cleanup )     ( referenceQueue . remove (  )  )  )  ;", "ClassPath   key    =    entry . getKey (  )  ;", "removeCacheEntry ( key ,    entry ,    Cleanup . Mode . DONT _ CLOSE _ CLASSLOADER )  ;", "}", "}    catch    ( InterruptedException   ex )     {", ". LOG . debug (  \" Shutdown   of   classloader   cache   in   progress \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.api.internal.project.antbuilder.FinalizerThread"}, {"methodBody": ["METHOD_START", "{", "TaskClassInfo   taskClassInfo    =    taskClassInfoStore . getTaskClassInfo ( task . getClass (  )  )  ;", "if    ( taskClassInfo . isIncremental (  )  )     {", "task . getOutputs (  )  . upToDateWhen ( new   specs . Spec < Task >  (  )     {", "public   boolean   isSatisfiedBy ( Task   element )     {", "return   true ;", "}", "}  )  ;", "}", "for    ( TaskActionFactory   actionFactory    :    taskClassInfo . getTaskActionFactories (  )  )     {", "(  ( TaskInternal )     ( task )  )  . prependParallelSafeAction ( actionFactory . create (  )  )  ;", "}", "if    ( taskClassInfo . isCacheable (  )  )     {", "task . getOutputs (  )  . cacheIf (  \" Annotated   with    @ CacheableTask \"  ,    SATISFIES _ ALL )  ;", "}", "return   task ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( method . getAnnotation ( TaskAction . class )  )     =  =    null )     {", "return   null ;", "}", "Class <  ?  >    declaringClass    =    method . getDeclaringClass (  )  ;", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   use    @ TaskAction   annotation   on   static   method    % s .  % s (  )  .  \"  ,    declaringClass . getSimpleName (  )  ,    method . getName (  )  )  )  ;", "}", "final   Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "if    (  ( parameterTypes . length )     >     1  )     {", "throw   new   GradleException ( String . format (  \" Cannot   use    @ TaskAction   annotation   on   method    % s .  % s (  )    as   this   method   takes   multiple   parameters .  \"  ,    declaringClass . getSimpleName (  )  ,    method . getName (  )  )  )  ;", "}", "TaskActionFactory   taskActionFactory ;", "if    (  ( parameterTypes . length )     =  =     1  )     {", "if    (  !  ( parameterTypes [  0  ]  . equals ( IncrementalTaskInputs . class )  )  )     {", "throw   new   GradleException ( String . format (  \" Cannot   use    @ TaskAction   annotation   on   method    % s .  % s (  )    because    % s   is   not   a   valid   parameter   to   an   action   method .  \"  ,    declaringClass . getSimpleName (  )  ,    method . getName (  )  ,    parameterTypes [  0  ]  )  )  ;", "}", "taskActionFactory    =    new    . IncrementalTaskActionFactory ( taskType ,    method )  ;", "} else    {", "taskActionFactory    =    new    . StandardTaskActionFactory ( taskType ,    method )  ;", "}", "Class <  ?  >    previousDeclaringClass    =    processedMethods . put ( method . getName (  )  ,    declaringClass )  ;", "if    ( previousDeclaringClass    =  =    declaringClass )     {", "throw   new   GradleException ( String . format (  \" Cannot   use    @ TaskAction   annotation   on   multiple   overloads   of   method    % s .  % s (  )  \"  ,    declaringClass . getSimpleName (  )  ,    method . getName (  )  )  )  ;", "} else", "if    ( previousDeclaringClass    !  =    null )     {", "return   null ;", "}", "return   taskActionFactory ;", "}", "METHOD_END"], "methodName": ["createTaskAction"], "fileName": "org.gradle.api.internal.project.taskfactory.DefaultTaskClassInfoStore"}, {"methodBody": ["METHOD_START", "{", "boolean   cacheable    =    type . isAnnotationPresent ( CacheableTask . class )  ;", "boolean   incremental    =    false ;", "Map < String ,    Class <  ?  >  >    processedMethods    =    Maps . newHashMap (  )  ;", "ImmutableList . Builder < TaskActionFactory >    taskActionFactoriesBuilder    =    ImmutableList . builder (  )  ;", "for    ( Class   current    =    type ;    current    !  =    null ;    current    =    current . getSuperclass (  )  )     {", "for    ( Method   method    :    current . getDeclaredMethods (  )  )     {", "TaskActionFactory   taskActionFactory    =     . createTaskAction ( type ,    method ,    processedMethods )  ;", "if    ( taskActionFactory    =  =    null )     {", "continue ;", "}", "if    ( taskActionFactory   instanceof    . IncrementalTaskActionFactory )     {", "if    ( incremental )     {", "throw   new   GradleException ( String . format (  \" Cannot   have   multiple    @ TaskAction   methods   accepting   an    % s   parameter .  \"  ,    IncrementalTaskInputs . class . getSimpleName (  )  )  )  ;", "}", "incremental    =    true ;", "}", "taskActionFactoriesBuilder . add ( taskActionFactory )  ;", "}", "}", "return   new   TaskClassInfo ( incremental ,    taskActionFactoriesBuilder . build (  )  ,    cacheable )  ;", "}", "METHOD_END"], "methodName": ["createTaskClassInfo"], "fileName": "org.gradle.api.internal.project.taskfactory.DefaultTaskClassInfoStore"}, {"methodBody": ["METHOD_START", "{", "this . taskArtifactState    =    context . getTaskArtifactState (  )  ;", "this . taskProperties    =    context . getTaskProperties (  )  ;", "}", "METHOD_END"], "methodName": ["contextualise"], "fileName": "org.gradle.api.internal.project.taskfactory.IncrementalTaskAction"}, {"methodBody": ["METHOD_START", "{", "JavaReflectionUtil . method ( task ,    Object . class ,    methodName ,    IncrementalTaskInputs . class )  . invoke ( task ,    taskArtifactState . getInputChanges ( taskProperties )  )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.gradle.api.internal.project.taskfactory.IncrementalTaskAction"}, {"methodBody": ["METHOD_START", "{", "JavaReflectionUtil . method ( task ,    Object . class ,    methodName )  . invoke ( task )  ;", "}", "METHOD_END"], "methodName": ["doExecute"], "fileName": "org.gradle.api.internal.project.taskfactory.StandardTaskAction"}, {"methodBody": ["METHOD_START", "{", "ClassLoader   original    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( method . getDeclaringClass (  )  . getClassLoader (  )  )  ;", "try    {", "doExecute (  ,    method . getName (  )  )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( original )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.project.taskfactory.StandardTaskAction"}, {"methodBody": ["METHOD_START", "{", "return   taskActionFactories ;", "}", "METHOD_END"], "methodName": ["getTaskActionFactories"], "fileName": "org.gradle.api.internal.project.taskfactory.TaskClassInfo"}, {"methodBody": ["METHOD_START", "{", "return   cacheable ;", "}", "METHOD_END"], "methodName": ["isCacheable"], "fileName": "org.gradle.api.internal.project.taskfactory.TaskClassInfo"}, {"methodBody": ["METHOD_START", "{", "return   incremental ;", "}", "METHOD_END"], "methodName": ["isIncremental"], "fileName": "org.gradle.api.internal.project.taskfactory.TaskClassInfo"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskFactory ( generator ,    project ,    instantiator )  ;", "}", "METHOD_END"], "methodName": ["createChild"], "fileName": "org.gradle.api.internal.project.taskfactory.TaskFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( locked )     {", "throw   new   IllegalStateException (  \" This   p   is   locked   and   cannot   be   changed .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertNotLocked"], "fileName": "org.gradle.api.internal.provider.AbstractLockableProperty"}, {"methodBody": ["METHOD_START", "{", "locked    =    true ;", "T   currentValue    =    delegate . getOrNull (  )  ;", "value    =     ( currentValue    =  =    null )     ?    null    :    immutCopy ( currentValue )  ;", "type    =    delegate . getType (  )  ;", "delegate    =    null ;", "}", "METHOD_END"], "methodName": ["lockNow"], "fileName": "org.gradle.api.internal.provider.AbstractLockableProperty"}, {"methodBody": ["METHOD_START", "{", "return   provider ;", "}", "METHOD_END"], "methodName": ["getProvider"], "fileName": "org.gradle.api.internal.provider.DefaultPropertyState"}, {"methodBody": ["METHOD_START", "{", "if    ( valueType    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Class   cannot   be   null \"  )  ;", "}", "PropertyState < T >    propertyState    =    new   pertyState < T >  ( valueType )  ;", "if    ( valueType    =  =     ( Boolean . class )  )     {", "(  ( PropertyState < Boolean >  )     ( propertyState )  )  . set ( Providers . FALSE )  ;", "} else", "if    ( valueType    =  =     ( Byte . class )  )     {", "(  ( PropertyState < Byte >  )     ( propertyState )  )  . set ( Providers . BYTE _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Short . class )  )     {", "(  ( PropertyState < Short >  )     ( propertyState )  )  . set ( Providers . SHORT _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Integer . class )  )     {", "(  ( PropertyState < Integer >  )     ( propertyState )  )  . set ( Providers . INTEGER _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Long . class )  )     {", "(  ( PropertyState < Long >  )     ( propertyState )  )  . set ( Providers . LONG _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Float . class )  )     {", "(  ( PropertyState < Float >  )     ( propertyState )  )  . set ( Providers . FLOAT _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Double . class )  )     {", "(  ( PropertyState < Double >  )     ( propertyState )  )  . set ( Providers . DOUBLE _ ZERO )  ;", "} else", "if    ( valueType    =  =     ( Character . class )  )     {", "(  ( PropertyState < Character >  )     ( propertyState )  )  . set ( Providers . CHAR _ ZERO )  ;", "}", "return   propertyState ;", "}", "METHOD_END"], "methodName": ["propertyNoNag"], "fileName": "org.gradle.api.internal.provider.DefaultProviderFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Value   cannot   be   null \"  )  ;", "}", "return   new    < T >  ( value )  ;", "}", "METHOD_END"], "methodName": ["provider"], "fileName": "org.gradle.api.internal.provider.DefaultProviderFactory"}, {"methodBody": ["METHOD_START", "{", "return   Cast . uncheckedCast ( Providers . NULL _ PROVIDER )  ;", "}", "METHOD_END"], "methodName": ["notDefined"], "fileName": "org.gradle.api.internal.provider.Providers"}, {"methodBody": ["METHOD_START", "{", "return   new   Providers . FixedValueProvider < T >  ( value )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.provider.Providers"}, {"methodBody": ["METHOD_START", "{", "return   new   Bzip 2 Archiver ( fileOperations . getFileResolver (  )  . resolveResource ( path )  )  ;", "}", "METHOD_END"], "methodName": ["bzip2"], "fileName": "org.gradle.api.internal.resources.DefaultResourceHandler"}, {"methodBody": ["METHOD_START", "{", "return   textResourceFactory ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.gradle.api.internal.resources.DefaultResourceHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   GzipArchiver ( fileOperations . getFileResolver (  )  . resolveResource ( path )  )  ;", "}", "METHOD_END"], "methodName": ["gzip"], "fileName": "org.gradle.api.internal.resources.DefaultResourceHandler"}, {"methodBody": ["METHOD_START", "{", "return   fromArchiveEntry ( archive ,    entryPath ,    Charset . defaultCharset (  )  . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromArchiveEntry"], "fileName": "org.gradle.api.internal.resources.DefaultTextResourceFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   FileCollectionBackedArchiveTextResource ( fileOperations ,    tempFileProvider ,    fileOperations . files ( archive )  ,    entryPath ,    Charset . forName ( charset )  )  ;", "}", "METHOD_END"], "methodName": ["fromArchiveEntry"], "fileName": "org.gradle.api.internal.resources.DefaultTextResourceFactory"}, {"methodBody": ["METHOD_START", "{", "return   fromFile ( file ,    Charset . defaultCharset (  )  . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["fromFile"], "fileName": "org.gradle.api.internal.resources.DefaultTextResourceFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   FileCollectionBackedTextResource ( tempFileProvider ,    fileOperations . files ( file )  ,    Charset . forName ( charset )  )  ;", "}", "METHOD_END"], "methodName": ["fromFile"], "fileName": "org.gradle.api.internal.resources.DefaultTextResourceFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   StringBackedTextResource ( tempFileProvider ,    string )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "org.gradle.api.internal.resources.DefaultTextResourceFactory"}, {"methodBody": ["METHOD_START", "{", "return   asFile ( Charset . defaultCharset (  )  . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["asFile"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "try    {", "Charset   targetCharsetObj    =    Charset . forName ( targetCharset )  ;", "if    ( targetCharsetObj . equals ( charset )  )     {", "return   f . getSingleFile (  )  ;", "}", "File   targetFile    =    tempFileProvider . createTemporaryFile (  \" f \"  ,     \"  . txt \"  ,     \" resource \"  )  ;", "try    {", "Files . asCharSource ( f . getSingleFile (  )  ,    charset )  . copyTo ( Files . asCharSink ( targetFile ,    targetCharsetObj )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   ResourceException (  (  (  (  (  \" Could   not   write    \"     +     ( getDisplayName (  )  )  )     +     \"    content   to    \"  )     +    targetFile )     +     \"  .  \"  )  ,    e )  ;", "}", "return   targetFile ;", "}    catch    ( Exception   e )     {", "throw   ResourceExceptions . readFailed ( getDisplayName (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["asFile"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "File   file    =    asFile (  )  ;", "try    {", "return   Files . newReader ( asFile (  )  ,    charset )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   Exceptions . readMissing ( file ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["asReader"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "File   file    =    asFile (  )  ;", "try    {", "return   Files . toString ( file ,    charset )  ;", "}    catch    ( FileNotFoundException   e )     {", "throw   Exceptions . readMissing ( file ,    e )  ;", "}    catch    ( IOException   e )     {", "throw   Exceptions . readFailed ( file ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   fileCollection . getBuildDependencies (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   fileCollection ;", "}", "METHOD_END"], "methodName": ["getInputFiles"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   charset . name (  )  ;", "}", "METHOD_END"], "methodName": ["getInputProperties"], "fileName": "org.gradle.api.internal.resources.FileCollectionBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   asFile ( Charset . defaultCharset (  )  . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["asFile"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "File   file    =    tempFileProvider . createTemporaryFile (  \" string \"  ,     \"  . txt \"  ,     \" resource \"  )  ;", "try    {", "Files . write ( string ,    file ,    Charset . forName ( charset )  )  ;", "}    catch    ( IOException   e )     {", "throw   new   ResourceException (  (  (  (  (  \" Could   not   write    \"     +     ( getDisplayName (  )  )  )     +     \"    content   to    \"  )     +    file )     +     \"  .  \"  )  ,    e )  ;", "}", "return   file ;", "}", "METHOD_END"], "methodName": ["asFile"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   new   StringReader ( string )  ;", "}", "METHOD_END"], "methodName": ["asReader"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   string ;", "}", "METHOD_END"], "methodName": ["asString"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   TaskDependencies . EMPTY ;", "}", "METHOD_END"], "methodName": ["getBuildDependencies"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getInputFiles"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "return   string ;", "}", "METHOD_END"], "methodName": ["getInputProperties"], "fileName": "org.gradle.api.internal.resources.StringBackedTextResource"}, {"methodBody": ["METHOD_START", "{", "assert   GUtil . isTrue ( schemePrefix )  ;", "try    {", "return   new   URI (  (  (  ( schemePrefix )     +     \"  :  \"  )     +     ( uri . toString (  )  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException (  (  \" Unable   to   b   URI   based   on   supplied   URI :     \"     +     ( uri )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.internal.resources.URIBuilder"}, {"methodBody": ["METHOD_START", "{", "assert   GUtil . isTrue ( schemePrefix )  ;", "this . schemePrefix    =    schemePrefix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["schemePrefix"], "fileName": "org.gradle.api.internal.resources.URIBuilder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ExplainingSpec < T >  )     ( ExplainingSpecs . SATISFIES _ ALL )  )  ;", "}", "METHOD_END"], "methodName": ["satisfyAll"], "fileName": "org.gradle.api.internal.specs.ExplainingSpecs"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ExplainingSpec < T >  )     ( ExplainingSpecs . SATISFIES _ NONE )  )  ;", "}", "METHOD_END"], "methodName": ["satisfyNone"], "fileName": "org.gradle.api.internal.specs.ExplainingSpecs"}, {"methodBody": ["METHOD_START", "{", "CachingTaskDependencyResolveContext   context    =    new   CachingTaskDependencyResolveContext (  )  ;", "return   context . getDependencies ( task ,    this )  ;", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.api.internal.tasks.AbstractTaskDependency"}, {"methodBody": ["METHOD_START", "{", "return   GenericFileNormalizer . class ;", "}", "METHOD_END"], "methodName": ["getNormalizer"], "fileName": "org.gradle.api.internal.tasks.AbstractTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   OutputPathNormalizationStrategy . getInstance (  )  ;", "}", "METHOD_END"], "methodName": ["getPathNormalizationStrategy"], "fileName": "org.gradle.api.internal.tasks.AbstractTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   optional ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.gradle.api.internal.tasks.AbstractTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( dependency )  ;", "queue . add ( dependency )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.tasks.CachingTaskDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "walker . add ( container )  ;", "return   walker . findValues (  )  ;", "}", "METHOD_END"], "methodName": ["doGetDependencies"], "fileName": "org.gradle.api.internal.tasks.CachingTaskDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "this . task    =    task ;", "try    {", "return   doGetDependencies ( container )  ;", "}    catch    ( Exception   e )     {", "throw   new   Exception ( String . format (  \" Could   not   determine   the   dependencies   of    % s .  \"  ,    task )  ,    e )  ;", "}    finally    {", "queue . clear (  )  ;", "this . task    =    null ;", "}", "}", "METHOD_END"], "methodName": ["getDependencies"], "fileName": "org.gradle.api.internal.tasks.CachingTaskDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   task ;", "}", "METHOD_END"], "methodName": ["getTask"], "fileName": "org.gradle.api.internal.tasks.CachingTaskDependencyResolveContext"}, {"methodBody": ["METHOD_START", "{", "return   outputType ;", "}", "METHOD_END"], "methodName": ["getOutputType"], "fileName": "org.gradle.api.internal.tasks.CompositeTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "Object   unpackedPaths    =    DeferredUtil . unpack ( paths )  ;", "if    ( unpackedPaths    =  =    null )     {", "return   Iterators . emptyIterator (  )  ;", "} else", "if    ( unpackedPaths   instanceof   Map )     {", "final   Iterator <  ?    extends   Entry <  ?  ,     ?  >  >    iterator    =     (  ( Map <  ?  ,     ?  >  )     ( unpackedPaths )  )  . entrySet (  )  . iterator (  )  ;", "return   new   com . google . common . collect . AbstractIterator < TaskOutputFilePropertySpec >  (  )     {", "@ Override", "protected   TaskOutputFilePropertySpec   computeNext (  )     {", "if    ( iterator . hasNext (  )  )     {", "Entry <  ?  ,     ?  >    entry    =    iterator . next (  )  ;", "Object   key    =    entry . getKey (  )  ;", "if    ( key    =  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \" Mapped   output   property    '  % s '    has   null   key \"  ,    getPropertyName (  )  )  )  ;", "}", "String   id    =    key . toString (  )  ;", "File   file    =    resolver . resolve ( entry . getValue (  )  )  ;", "return   new   CacheableTaskOutputCompositeFilePropertyElementSpec (  . this ,     (  \"  .  \"     +    id )  ,    file )  ;", "}", "return   endOfData (  )  ;", "}", "}  ;", "} else    {", "final   List < Object >    roots    =    com . google . common . collect . Lists . newArrayList (  )  ;", "resolver . resolveFiles ( paths )  . visitRootElements ( new   FileCollectionVisitor (  )     {", "@ Override", "public   void   visitCollection ( FileCollectionInternal   fileCollection )     {", "visitRoot ( fileCollection )  ;", "}", "@ Override", "public   void   visitTree ( FileTreeInternal   fileTree )     {", "visitRoot ( fileTree )  ;", "}", "@ Override", "public   void   visitDirectoryTree ( DirectoryFileTree   directoryTree )     {", "visitRoot ( directoryTree )  ;", "}", "private   void   visitRoot ( Object   root )     {", "roots . add ( root )  ;", "}", "}  )  ;", "final   Iterator < Object >    iterator    =    roots . iterator (  )  ;", "return   new   com . google . common . collect . AbstractIterator < TaskOutputFilePropertySpec >  (  )     {", "private   int   index ;", "@ Override", "protected   TaskOutputFilePropertySpec   computeNext (  )     {", "if    (  !  ( iterator . hasNext (  )  )  )     {", "return   endOfData (  )  ;", "}", "Object   root    =    iterator . next (  )  ;", "return   new   NonCacheableTaskOutputPropertySpec ( taskName ,     . this ,     (  +  +  ( index )  )  ,    resolver ,    root )  ;", "}", "}  ;", "}", "}", "METHOD_END"], "methodName": ["resolveToOutputProperties"], "fileName": "org.gradle.api.internal.tasks.CompositeTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheableTaskOutputFilePropertySpec ( task . getName (  )  ,    resolver ,    file ,    path ,    outputFileValidator )  ;", "}", "METHOD_END"], "methodName": ["createOutputFilePropertySpec"], "fileName": "org.gradle.api.internal.tasks.DefaultPropertySpecFactory"}, {"methodBody": ["METHOD_START", "{", "return   getInstantiator (  )  . newInstance ( DefaultTaskCollection . class ,    this ,    filter ,    getInstantiator (  )  ,    project )  ;", "}", "METHOD_END"], "methodName": ["filtered"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskCollection"}, {"methodBody": ["METHOD_START", "{", "whenObjectAdded ( closure )  ;", "}", "METHOD_END"], "methodName": ["whenTaskAdded"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskCollection"}, {"methodBody": ["METHOD_START", "{", "return   whenObjectAdded ( action )  ;", "}", "METHOD_END"], "methodName": ["whenTaskAdded"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskCollection"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( modelNode . hasLink ( placeholderName )  )  )     {", "final   ModelType < T >    taskModelType    =    ModelType . of ( taskType )  ;", "ModelPath   path    =    TaskContainerInternal . MODEL _ PATH . child ( placeholderName )  ;", "modelNode . addLink ( ModelRegistrations . of ( path )  . action ( Create ,    new    . TaskCreator < T >  ( placeholderName ,    taskType ,    configure ,    taskModelType )  )  . withProjection ( new   UnmanagedModelProjection < T >  ( taskModelType )  )  . descriptor ( new   SimpleModelRuleDescriptor (  (  (  \" tasks . addPlaceholderAction (  \"     +    placeholderName )     +     \"  )  \"  )  )  )  . build (  )  )  ;", "}", "if    (  ( findByNameWithoutRules ( placeholderName )  )     =  =    null )     {", "placeholders . add ( placeholderName )  ;", "}", "}", "METHOD_END"], "methodName": ["addPlaceholderAction"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "String   name    =    task . getName (  )  ;", "if    ( placeholders . remove ( name )  )     {", "modelNode . removeLink ( name )  ;", "}", "if    ( replaceExisting )     {", "Task   existing    =    findByNameWithoutRules ( name )  ;", "if    ( existing    !  =    null )     {", "remove ( existing )  ;", "}", "} else", "if    ( hasWithName ( name )  )     {", "duplicateTask ( name )  ;", "}", "add ( task )  ;", "return   task ;", "}", "METHOD_END"], "methodName": ["addTask"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskContainer . validateArgs ( args )  ;", "if    (  !  ( args . keySet (  )  . containsAll ( DefaultTaskContainer . MANDATORY _ TASK _ ARGUMENTS )  )  )     {", "Map < String ,    Object >    argsWithDefaults    =    Maps . newHashMap ( args )  ;", "DefaultTaskContainer . setIfNull ( argsWithDefaults ,    TASK _ NAME ,     \"  \"  )  ;", "DefaultTaskContainer . setIfNull ( argsWithDefaults ,    TASK _ TYPE ,    DefaultTask . class )  ;", "return   argsWithDefaults ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["checkTaskArgsAndCreateDefaultValues"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   ConfigureUtil . configureSelf ( configureClosure ,    this ,    new   NamedDomainObjectContainerConfigureDelegate ( configureClosure ,    this )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["containerWithType"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( name ,    DefaultTask . class )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( name )  . configure ( configureClosure )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "T   task    =    create ( name ,    type )  ;", "configuration . execute ( task )  ;", "return   task ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Task   task    =    create ( name )  ;", "configureAction . execute ( task )  ;", "return   task ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Map < String ,     ?  >    factoryOptions    =    options ;", "boolean   replace    =    false ;", "if    ( options . containsKey ( TASK _ OVERWRITE )  )     {", "factoryOptions    =    new   HashMap < String ,    Object >  ( options )  ;", "Object   replaceStr    =    factoryOptions . remove ( TASK _ OVERWRITE )  ;", "replace    =     \" true \"  . equals ( replaceStr . toString (  )  )  ;", "}", "Map < String ,     ?  >    actualArgs    =     . checkTaskArgsAndCreateDefaultValues ( factoryOptions )  ;", "String   name    =    actualArgs . get ( TASK _ NAME )  . toString (  )  ;", "if    (  !  ( GUtil . isTrue ( name )  )  )     {", "throw   new   InvalidUserDataException (  \" The   task   name   must   be   provided .  \"  )  ;", "}", "Class <  ?    extends   TaskInternal >    type    =    Cast . uncheckedCast ( actualArgs . get ( TASK _ TYPE )  )  ;", "Object [  ]    constructorArgs    =     . getConstructorArgs ( actualArgs )  ;", "TaskInternal   task    =    createTask ( name ,    type ,    constructorArgs )  ;", "statistics . eagerTask ( type )  ;", "Object   dependsOnTasks    =    actualArgs . get ( TASK _ DEPENDS _ ON )  ;", "if    ( dependsOnTasks    !  =    null )     {", "task . dependsOn ( dependsOnTasks )  ;", "}", "Object   description    =    actualArgs . get ( TASK _ DESCRIPTION )  ;", "if    ( description    !  =    null )     {", "task . setDescription ( description . toString (  )  )  ;", "}", "Object   group    =    actualArgs . get ( TASK _ GROUP )  ;", "if    ( group    !  =    null )     {", "task . setGroup ( group . toString (  )  )  ;", "}", "Object   action    =    actualArgs . get ( TASK _ ACTION )  ;", "if    ( action   instanceof   Action )     {", "Action <  ?    super   Task >    taskAction    =    Cast . uncheckedCast ( action )  ;", "task . doFirst ( taskAction )  ;", "} else", "if    ( action    !  =    null )     {", "groovy . lang . Closure   closure    =     (  ( groovy . lang . Closure )     ( action )  )  ;", "task . doFirst ( closure )  ;", "}", "return   addTask ( task ,    replace )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   create ( options )  . configure ( configureClosure )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( constructorArgs . length )  ;    i +  +  )     {", "if    (  ( constructorArgs [ i ]  )     =  =    null )     {", "throw   new   NullPoException ( String . format (  \" Received   null   for    % s   constructor   argument    #  % s \"  ,    type . getName (  )  ,     ( i    +     1  )  )  )  ;", "}", "}", "return   taskFactory . create ( name ,    type ,    constructorArgs )  ;", "}", "METHOD_END"], "methodName": ["createTask"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "throw   new   InvalidUserDataException ( String . format (  \" Cannot   add   task    '  % s '    as   a   task   with   that   name   already   exists .  \"  ,    task )  )  ;", "}", "METHOD_END"], "methodName": ["duplicateTask"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Task   task    =    super . findByName ( name )  ;", "if    ( task    !  =    null )     {", "return   task ;", "}", "if    (  !  ( maybeCreateTasks ( name )  )  )     {", "return   null ;", "}", "placeholders . remove ( name )  ;", "return   super . findByNameWithoutRules ( name )  ;", "}", "METHOD_END"], "methodName": ["findByName"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( Strings . isNullOrEmpty ( path )  )     {", "throw   new   InvalidUserDataException (  \" A   path   must   be   specified !  \"  )  ;", "}", "if    (  !  ( path . contains ( PATH _ SEPARATOR )  )  )     {", "return   findByName ( path )  ;", "}", "String   projectPath    =    StringUtils . substringBeforeLast ( path ,    PATH _ SEPARATOR )  ;", "ProjectI   project    =    this . project . findProject (  ( Strings . isNullOrEmpty ( projectPath )     ?    Project . PATH _ SEPARATOR    :    projectPath )  )  ;", "if    ( project    =  =    null )     {", "return   null ;", "}", "projectAccessListener . beforeRequestingTaskByPath ( project )  ;", "return   project . getTasks (  )  . findByName ( StringUtils . substringAfterLast ( path ,    PATH _ SEPARATOR )  )  ;", "}", "METHOD_END"], "methodName": ["findByPath"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Task   task    =    findByPath ( path )  ;", "if    ( task    =  =    null )     {", "throw   new   UnknownTaskException ( String . format (  \" Task   with   path    '  % s '    not   found   in    % s .  \"  ,    path ,    project )  )  ;", "}", "return   task ;", "}", "METHOD_END"], "methodName": ["getByPath"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Object   constructorArgs    =    args . get ( TASK _ CONSTRUCTOR _ ARGS )  ;", "if    ( constructorArgs   instanceof   List )     {", "List <  ?  >    asList    =     (  ( List <  ?  >  )     ( constructorArgs )  )  ;", "return   asList . toArray ( new   Object [ asList . size (  )  ]  )  ;", "}", "if    ( constructorArgs   instanceof   Object [  ]  )     {", "return    (  ( Object [  ]  )     ( constructorArgs )  )  ;", "}", "if    ( constructorArgs    !  =    null )     {", "throw   new   IllegalArgumentException ( String . format (  \"  % s   must   be   a   List   or   Object [  ]  .       Received    % s \"  ,    TASK _ CONSTRUCTOR _ ARGS ,    constructorArgs . getClass (  )  )  )  ;", "}", "return    . NO _ ARGS ;", "}", "METHOD_END"], "methodName": ["getConstructorArgs"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   Collections . singleton ( getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCreateableTypes"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   getElementsAsDynamicObject (  )  ;", "}", "METHOD_END"], "methodName": ["getTasksAsDynamicObject"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Task   task    =    findByName ( name )  ;", "if    ( task    !  =    null )     {", "return   task ;", "}", "return   create ( name )  ;", "}", "METHOD_END"], "methodName": ["maybeCreate"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "Task   existing    =    findByName ( name )  ;", "if    ( existing    !  =    null )     {", "return   Transformers . cast ( type )  . transform ( existing )  ;", "}", "return   create ( name ,    type )  ;", "}", "METHOD_END"], "methodName": ["maybeCreate"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( modelNode . hasLink ( name )  )     {", "realizeTask ( Internal . MODEL _ PATH . child ( name )  ,    Initialized )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["maybeCreateTasks"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "project . getModelRegistry (  )  . realizeNode ( modelNode . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["realize"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   project . getModelRegistry (  )  . atStateOrLater ( taskPath ,    ModelType . of ( Task . class )  ,    minState )  ;", "}", "METHOD_END"], "methodName": ["realizeTask"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "return   replace ( name ,    DefaultTask . class )  ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "T   task    =    taskFactory . create ( name ,    type )  ;", "return   addTask ( task ,    true )  ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "if    ( Strings . isNullOrEmpty ( path )  )     {", "throw   new   InvalidUserDataException (  \" A   path   must   be   specified !  \"  )  ;", "}", "return   getByPath ( path )  ;", "}", "METHOD_END"], "methodName": ["resolveTask"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( map . get ( key )  )     =  =    null )     {", "map . put ( key ,    dValue )  ;", "}", "}", "METHOD_END"], "methodName": ["setIfNull"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( DefaultTaskContainer . VALID _ TASK _ ARGUMENTS . containsAll ( args . keySet (  )  )  )  )     {", "Map < String ,    Object >    unknownArguments    =    new   HashMap < String ,    Object >  ( args )  ;", "unknownArguments . keySet (  )  . removeAll ( DefaultTaskContainer . VALID _ TASK _ ARGUMENTS )  ;", "throw   new   InvalidUserDataException ( String . format (  \" Could   not   create   task    '  % s '  :    Unknown   argument ( s )    in   task   definition :     % s \"  ,    args . get ( TASK _ NAME )  ,    unknownArguments . keySet (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["validateArgs"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainer"}, {"methodBody": ["METHOD_START", "{", "ModelReference < DefaultTaskContainer >    containerReference    =    ModelReference . of ( TaskContainerInternal . MODEL _ PATH ,    DefaultTaskContainerFactory . DEFAULT _ TASK _ CONTAINER _ MODEL _ TYPE )  ;", "ModelRegistrations . Builder   registrationBuilder    =    BridgedCollections . registration ( containerReference ,    new   Transformer < DefaultTaskContainer ,    MutableModelNode >  (  )     {", "@ Override", "public   DefaultTaskContainer   transform ( MutableModelNode   mutableModelNode )     {", "return   instantiator . newInstance ( DefaultTaskContainer . class ,    mutableModelNode ,    project ,    instantiator ,    taskFactory ,    projectAccessListener ,    statistics )  ;", "}", "}  ,    new   Task . Namer (  )  ,     \" Project .  < init >  . tasks (  )  \"  ,    new   DefaultTaskContainerFactory . Namer (  )  )  ;", "modelRegistry . register ( registrationBuilder . withProjection ( ModelMapModelProjection . unmanaged ( DefaultTaskContainerFactory . TASK _ MODEL _ TYPE ,    ChildNodeInitializerStrategyAccessors . of ( NodeBackedModelMap . createUsingParentNode ( new   Transformer < NamedEntityInstantiator < Task >  ,    MutableModelNode >  (  )     {", "@ Override", "public   NamedEntityInstantiator < Task >    transform ( MutableModelNode   modelNode )     {", "return   modelNode . getPrivateData ( DefaultTaskContainerFactory . DEFAULT _ TASK _ CONTAINER _ MODEL _ TYPE )  . getEntityInstantiator (  )  ;", "}", "}  )  )  )  )  . withProjection ( UnmanagedModelProjection . of ( DefaultTaskContainerFactory . TASK _ CONTAINER _ MODEL _ TYPE )  )  . build (  )  )  ;", "ModelNode   modelNode    =    modelRegistry . atStateOrLater ( TaskContainerInternal . MODEL _ PATH ,    Created )  ;", "MutableModelNode   mutableModelNode    =     (  ( MutableModelNode )     ( modelNode )  )  ;", "mutableModelNode . applyTo ( allLinks (  )  ,    Initialize ,    DirectNodeNoInputsModelAction . of ( DefaultTaskContainerFactory . TASK _ MODEL _ REFERENCE ,    DefaultTaskContainerFactory . COPY _ TO _ TASK _ CONTAINER _ DESCRIPTOR ,    new   BiAction < MutableModelNode ,    Task >  (  )     {", "@ Override", "public   void   execute ( MutableModelNode   modelNode ,    Task   task )     {", "TaskContainerInternal   taskContainer    =    modelNode . getParent (  )  . getPrivateData ( TaskContainerInternal . MODEL _ TYPE )  ;", "taskContainer . add ( task )  ;", "}", "}  )  )  ;", "return   mutableModelNode . getPrivateData ( TaskContainerInternal . MODEL _ TYPE )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskContainerFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   value    :    values )     {", "addValue ( value )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskDependency"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     ( items . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "queue . addFirst ( items [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["addAllFirst"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskDependency"}, {"methodBody": ["METHOD_START", "{", "if    ( dependency    =  =    null )     {", "throw   new   InvalidUserDataException (  \" A   dependency   must   not   be   empty \"  )  ;", "}", "getMutableValues (  )  . add ( dependency )  ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskDependency"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mutableValues )     =  =    null )     {", "mutableValues    =    Sets . newHashSet (  )  ;", "}", "return   mutableValues ;", "}", "METHOD_END"], "methodName": ["getMutableValues"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskDependency"}, {"methodBody": ["METHOD_START", "{", "getMutableValues (  )  . clear (  )  ;", "for    ( Object   value    :    values )     {", "addValue ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["setValues"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskDependency"}, {"methodBody": ["METHOD_START", "{", "return   optional ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskInputFilePropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   skipWhenEmpty ;", "}", "METHOD_END"], "methodName": ["isSkipWhenEmpty"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskInputFilePropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   optional ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskInputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     =  =     1  )     {", "return   args [  0  ]  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["unpackVarargs"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskInputs"}, {"methodBody": ["METHOD_START", "{", "return   new   ValidationAction (  )     {", "@ Override", "public   void   validate ( String   propertyName ,    Object   value ,    TaskValidationContext   context ,    TaskValidationContext . Severity   severity )     {", "try    {", "validator . validate ( propertyName ,    value ,    context ,    severity )  ;", "}    catch    ( UnsupportedNotationException   ex )     {", "DeprecationLogger . nagUserOfDeprecated (  (  (  \" Using    .  \"     +    method )     +     \"  (  )    with   something   that   doesn ' t   resolve   to   a   File   object \"  )  ,     \" Use    . files (  )    instead \"  )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["wrapRuntimeApiValidator"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskInputs"}, {"methodBody": ["METHOD_START", "{", "checkArgument (  (  !  ( isNullOrEmpty ( disabledReason )  )  )  ,     \" disabledReason   must   be   set   if   task   output   caching   is   disabled \"  )  ;", "checkNotNull ( disabledReasonCategory ,     \" disabledReasonCategory   must   be   set   if   task   output   caching   is   disabled \"  )  ;", "return   new    ( disabledReasonCategory ,    disabledReason )  ;", "}", "METHOD_END"], "methodName": ["disabled"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskOutputCachingState"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskOutputCachingState ( null ,    null )  ;", "}", "METHOD_END"], "methodName": ["enabled"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskOutputCachingState"}, {"methodBody": ["METHOD_START", "{", "GetOutputFilesVisitor   visitor    =    new   GetOutputFilesVisitor (  )  ;", "TaskPropertyUtils . visitProperties ( propertyWalker ,    task ,    visitor )  ;", "return   visitor . getFileProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getFileProperties"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskOutputs"}, {"methodBody": ["METHOD_START", "{", "return    ( history )     !  =    null    ?    history . getOverlappingOutputs (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getOverlappingOutputs"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskOutputs"}, {"methodBody": ["METHOD_START", "{", "return    ( paths    !  =    null )     &  &     (  ( paths . length )     =  =     1  )     ?    paths [  0  ]     :    paths ;", "}", "METHOD_END"], "methodName": ["resolveSingleArray"], "fileName": "org.gradle.api.internal.tasks.DefaultTaskOutputs"}, {"methodBody": ["METHOD_START", "{", "return   parent . getPropertyName (  )  ;", "}", "METHOD_END"], "methodName": ["getOriginalPropertyName"], "fileName": "org.gradle.api.internal.tasks.NonCacheableTaskOutputPropertySpec"}, {"methodBody": ["METHOD_START", "{", "return   buildInvocationId ;", "}", "METHOD_END"], "methodName": ["getBuildInvocationId"], "fileName": "org.gradle.api.internal.tasks.OriginTaskExecutionMetadata"}, {"methodBody": ["METHOD_START", "{", "return   executionTime ;", "}", "METHOD_END"], "methodName": ["getExecutionTime"], "fileName": "org.gradle.api.internal.tasks.OriginTaskExecutionMetadata"}, {"methodBody": ["METHOD_START", "{", "return   new   RealizableTaskCollection < S >  ( type ,    collection ,    modelNode )  ;", "}", "METHOD_END"], "methodName": ["realizable"], "fileName": "org.gradle.api.internal.tasks.RealizableTaskCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( realized . compareAndSet ( false ,    true )  )     {", "modelNode . ensureAtLeast ( SelfClosed )  ;", "for    ( MutableModelNode   node    :    modelNode . getLinks ( ModelType . of ( type )  )  )     {", "node . ensureAtLeast ( GraphClosed )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["realizeRuleTaskTypes"], "fileName": "org.gradle.api.internal.tasks.RealizableTaskCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( dependencies . isEmpty (  )  )     {", "return    . EMPTY ;", "}", "return   new   DefaultTaskDependency (  )  . add ( dependencies )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.api.internal.tasks.TaskDependencies"}, {"methodBody": ["METHOD_START", "{", "return   message ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.api.internal.tasks.TaskExecutionOutcome"}, {"methodBody": ["METHOD_START", "{", "return   skipped ;", "}", "METHOD_END"], "methodName": ["isSkipped"], "fileName": "org.gradle.api.internal.tasks.TaskExecutionOutcome"}, {"methodBody": ["METHOD_START", "{", "return   upToDate ;", "}", "METHOD_END"], "methodName": ["isUpToDate"], "fileName": "org.gradle.api.internal.tasks.TaskExecutionOutcome"}, {"methodBody": ["METHOD_START", "{", "if    ( task . getState (  )  . isConfigurable (  )  )     {", "return ;", "}", "String   method    =    null ;", "if    ( evt   instanceof   ObservableList . ElementEvent )     {", "switch    (  (  ( ObservableList . ElementEvent )     ( evt )  )  . getChangeType (  )  )     {", "case   ADDED    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" add (  )  \"  )  ;", "break ;", "case   UPDATED    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" set ( int ,    Object )  \"  )  ;", "break ;", "case   REMOVED    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" remove (  )  \"  )  ;", "break ;", "case   CLEARED    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" clear (  )  \"  )  ;", "break ;", "case   MULTI _ ADD    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" addAll (  )  \"  )  ;", "break ;", "case   MULTI _ REMOVE    :", "method    =    String . format (  \"  % s .  % s \"  ,    listname ,     \" removeAll (  )  \"  )  ;", "break ;", "}", "}", "if    ( method    =  =    null )     {", "return ;", "}", "throw   new   IllegalStateException ( format ( method )  )  ;", "}", "METHOD_END"], "methodName": ["assertMutable"], "fileName": "org.gradle.api.internal.tasks.TaskMutator"}, {"methodBody": ["METHOD_START", "{", "if    ( executingleftShiftAction )     {", "return   String . format (  \" Cannot   call    % s   on    % s   after      has   started   execution .    Check   the   configuration   of    % s   as   you   may   have   misused    '  <  <  '    at      declaration .  \"  ,    method ,     ,     )  ;", "}", "return   String . format (  \" Cannot   call    % s   on    % s   after      has   started   execution .  \"  ,    method ,     )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.api.internal.tasks.TaskMutator"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskMutator . LeftShiftTaskAction ( action )  ;", "}", "METHOD_END"], "methodName": ["leftShift"], "fileName": "org.gradle.api.internal.tasks.TaskMutator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( task . getState (  )  . isConfigurable (  )  )  )     {", "throw   new   IllegalStateException ( format ( method )  )  ;", "}", "action . run (  )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.api.internal.tasks.TaskMutator"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( task . getState (  )  . isConfigurable (  )  )  )     {", "throw   new   IllegalStateException ( format ( method )  )  ;", "}", "return   GUtil . uncheckedCall ( action )  ;", "}", "METHOD_END"], "methodName": ["mutate"], "fileName": "org.gradle.api.internal.tasks.TaskMutator"}, {"methodBody": ["METHOD_START", "{", "throw   failWithUnsupportedMethod (  \" doNotCacheIf ( Spec )  \"  )  ;", "}", "METHOD_END"], "methodName": ["doNotCacheIf"], "fileName": "org.gradle.api.internal.tasks.TaskOutputsDeprecationSupport"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException ( String . format (  \" Chaining   of   the   TaskOutputs .  % s   method   is   not   supported   since   Gradle    4  .  0  .  \"  ,    method )  )  ;", "}", "METHOD_END"], "methodName": ["failWithUnsupportedMethod"], "fileName": "org.gradle.api.internal.tasks.TaskOutputsDeprecationSupport"}, {"methodBody": ["METHOD_START", "{", "return   paths ;", "}", "METHOD_END"], "methodName": ["getPaths"], "fileName": "org.gradle.api.internal.tasks.TaskPropertyFileCollection"}, {"methodBody": ["METHOD_START", "{", "if    ( propertyName . isEmpty (  )  )     {", "throw   new   IllegalArgumentException (  \"    name   must   not   be   empty   string \"  )  ;", "}", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["checkPropertyName"], "fileName": "org.gradle.api.internal.tasks.TaskPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "Set < String >    names    =    Sets . newHashSet (  )  ;", "ImmutableSortedSet . Builder < T >    builder    =    ImmutableSortedSet . naturalOrder (  )  ;", "while    ( fileProperties . hasNext (  )  )     {", "T   propertySpec    =    fileProperties . next (  )  ;", "String   propertyName    =    propertySpec . getName (  )  ;", "if    (  !  ( names . add ( propertyName )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Multiple    % s   file   properties   with   name    '  % s '  \"  ,    displayName ,    propertyName )  )  ;", "}", "builder . add ( propertySpec )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectFileProperties"], "fileName": "org.gradle.api.internal.tasks.TaskPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "final   PropertySpecFactory   specFactory    =    new   DefaultPropertySpecFactory ( task ,     (  ( ProjectInternal )     ( task . getProject (  )  )  )  . getFileResolver (  )  )  ;", "propertyWalker . visitProperties ( specFactory ,    visitor ,    task )  ;", "task . getInputs (  )  . visitRegisteredProperties ( visitor )  ;", "task . getOutputs (  )  . visitRegisteredProperties ( visitor )  ;", "int   destroyableCount    =     0  ;", "for    ( Object   path    :     (  ( TaskDestroyablesInternal )     ( task . getDestroyables (  )  )  )  . getRegisteredPaths (  )  )     {", "visitor . visitDestroyableProperty ( new   DefaultTaskDestroyablePropertySpec (  (  \"  $  \"     +     (  +  + destroyableCount )  )  ,    path )  )  ;", "}", "int   localStateCount    =     0  ;", "for    ( Object   path    :     (  ( TaskLocalStateInternal )     ( task . getLocalState (  )  )  )  . getRegisteredPaths (  )  )     {", "visitor . visitLocalStateProperty ( new   DefaultTaskLocalStatePropertySpec (  (  \"  $  \"     +     (  +  + localStateCount )  )  ,    path )  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitProperties"], "fileName": "org.gradle.api.internal.tasks.TaskPropertyUtils"}, {"methodBody": ["METHOD_START", "{", "return   didWork ;", "}", "METHOD_END"], "methodName": ["getDidWork"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( outcome )     !  =    null ;", "}", "METHOD_END"], "methodName": ["getExecuted"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   executing ;", "}", "METHOD_END"], "methodName": ["getExecuting"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   failure ;", "}", "METHOD_END"], "methodName": ["getFailure"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   outcome ;", "}", "METHOD_END"], "methodName": ["getOutcome"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( outcome )     !  =    null    ?    outcome . getMessage (  )     :    null ;", "}", "METHOD_END"], "methodName": ["getSkipMessage"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    (  ( outcome )     !  =    null )     &  &     ( outcome . isSkipped (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSkipped"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   taskOutputCaching ;", "}", "METHOD_END"], "methodName": ["getTaskOutputCaching"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    (  ( outcome )     !  =    null )     &  &     ( outcome . isUpToDate (  )  )  ;", "}", "METHOD_END"], "methodName": ["getUpToDate"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return   actionable ;", "}", "METHOD_END"], "methodName": ["isActionable"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    (  !  ( getExecuted (  )  )  )     &  &     (  !  ( executing )  )  ;", "}", "METHOD_END"], "methodName": ["isConfigurable"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "return    ( outcome )     =  =     ( TaskExecutionOutcome . FROM _ CACHE )  ;", "}", "METHOD_END"], "methodName": ["isFromCache"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failure )     =  =    null )     {", "return ;", "}", "if    (  ( failure )    instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( failure )  )  ;", "}", "if    (  ( failure )    instanceof   Error )     {", "throw    (  ( Error )     ( failure )  )  ;", "}", "throw   new   GException (  \" Task   failed   with   an   exception .  \"  ,    failure )  ;", "}", "METHOD_END"], "methodName": ["rethrowFailure"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "this . actionable    =    actionable ;", "}", "METHOD_END"], "methodName": ["setActionable"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "this . didWork    =    didWork ;", "}", "METHOD_END"], "methodName": ["setDidWork"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "this . executing    =    executing ;", "}", "METHOD_END"], "methodName": ["setExecuting"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "assert    ( this . failure )     =  =    null ;", "this . outcome    =    ExecutionOutcome . EXECUTED ;", "this . failure    =    failure ;", "}", "METHOD_END"], "methodName": ["setOutcome"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "assert    ( this . outcome )     =  =    null ;", "this . outcome    =    outcome ;", "}", "METHOD_END"], "methodName": ["setOutcome"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "this . taskOutputCaching    =    taskOutputCaching ;", "}", "METHOD_END"], "methodName": ["setTaskOutputCaching"], "fileName": "org.gradle.api.internal.tasks.TaskStateInternal"}, {"methodBody": ["METHOD_START", "{", "if    ( collectStatistics )     {", "eagerTasks . incrementAndGet (  )  ;", "synchronized ( typeCounts )     {", "Integer   count    =    typeCounts . get ( type )  ;", "if    ( count    =  =    null )     {", "count    =     1  ;", "} else    {", "count    =    count    +     1  ;", "}", "typeCounts . put ( type ,    count )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["eagerTask"], "fileName": "org.gradle.api.internal.tasks.TaskStatistics"}, {"methodBody": ["METHOD_START", "{", "if    ( collectStatistics )     {", "lazyTasks . incrementAndGet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["lazyTask"], "fileName": "org.gradle.api.internal.tasks.TaskStatistics"}, {"methodBody": ["METHOD_START", "{", "if    ( collectStatistics )     {", "lazyRealizedTasks . incrementAndGet (  )  ;", "if    (  ( lazyTaskLog )     !  =    null )     {", "new   Throwable (  )  . printStackTrace ( lazyTaskLog )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["lazyTaskRealized"], "fileName": "org.gradle.api.internal.tasks.TaskStatistics"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   ConfigurableFileTree )     {", "return    (  ( ConfigurableFileTree )     ( value )  )  . getDir (  )  ;", "}", "return    . toFile ( context ,    value )  ;", "}", "METHOD_END"], "methodName": ["toDirectory"], "fileName": "org.gradle.api.internal.tasks.ValidationActions"}, {"methodBody": ["METHOD_START", "{", "return   context . getResolver (  )  . resolve ( value )  ;", "}", "METHOD_END"], "methodName": ["toFile"], "fileName": "org.gradle.api.internal.tasks.ValidationActions"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Map )     {", "return    . toFiles ( context ,     (  ( Map )     ( value )  )  . values (  )  )  ;", "} else", "if    ( value   instanceof   FileCollection )     {", "return    (  ( FileCollection )     ( value )  )  ;", "} else    {", "return   context . getResolver (  )  . resolveFiles ( value )  ;", "}", "}", "METHOD_END"], "methodName": ["toFiles"], "fileName": "org.gradle.api.internal.tasks.ValidationActions"}, {"methodBody": ["METHOD_START", "{", "return   super . compare ( o )  . compare ( access ,    o . access )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.gradle.api.internal.tasks.compile.AccessibleMember"}, {"methodBody": ["METHOD_START", "{", "return   access ;", "}", "METHOD_END"], "methodName": ["getAccess"], "fileName": "org.gradle.api.internal.tasks.compile.AccessibleMember"}, {"methodBody": ["METHOD_START", "{", "annotations . add ( annotationMember )  ;", "}", "METHOD_END"], "methodName": ["addAnnotation"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotatableMember"}, {"methodBody": ["METHOD_START", "{", "return   super . compare ( o )  . compare (  (  ( signature )     =  =    null    ?     \"  \"     :    signature )  ,     (  ( o . signature )     =  =    null    ?     \"  \"     :    o . signature )  )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotatableMember"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSortedSet . copyOf ( annotations )  ;", "}", "METHOD_END"], "methodName": ["getAnnotations"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotatableMember"}, {"methodBody": ["METHOD_START", "{", "return   signature ;", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotatableMember"}, {"methodBody": ["METHOD_START", "{", "values . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addValue"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationMember"}, {"methodBody": ["METHOD_START", "{", "this . values . addAll ( values )  ;", "}", "METHOD_END"], "methodName": ["addValues"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationMember"}, {"methodBody": ["METHOD_START", "{", "return   super . compare ( o )  . compare ( visible ,    o . visible )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationMember"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSortedSet . copyOf ( values )  ;", "}", "METHOD_END"], "methodName": ["getValues"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationMember"}, {"methodBody": ["METHOD_START", "{", "return   visible ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationMember"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.api.internal.tasks.compile.AnnotationValue"}, {"methodBody": ["METHOD_START", "{", "ClassWriter   apiClassWriter    =    new   ClassWriter ( ClassWriter . COMPUTE _ MAXS )  ;", "ApiMemberSelector   visitor    =    new   ApiMemberSelector ( originalClassReader . getClassName (  )  ,    new   MethodStubbingApiMemberAdapter ( apiClassWriter )  ,    apiIncludesPackagePrivateMembers )  ;", "originalClassReader . accept ( visitor ,     (  ( ClassReader . SKIP _ DEBUG )     |     ( ClassReader . SKIP _ FRAMES )  )  )  ;", "if    ( visitor . isPrivateInnerClass (  )  )     {", "return   null ;", "}", "return   apiClassWriter . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["extractApiClassFrom"], "fileName": "org.gradle.api.internal.tasks.compile.ApiClassExtractor"}, {"methodBody": ["METHOD_START", "{", "return   ApiClassExtractor . LOCAL _ CLASS _ PATTERN . matcher ( className )  . matches (  )  ;", "}", "METHOD_END"], "methodName": ["isLocalClass"], "fileName": "org.gradle.api.internal.tasks.compile.ApiClassExtractor"}, {"methodBody": ["METHOD_START", "{", "int   packageSeparatorIndex    =    internalClassName . lastIndexOf (  '  /  '  )  ;", "return   packageSeparatorIndex    >     0     ?    internalClassName . substring (  0  ,    packageSeparatorIndex )  . replace (  '  /  '  ,     '  .  '  )     :     \"  \"  ;", "}", "METHOD_END"], "methodName": ["packageNameOf"], "fileName": "org.gradle.api.internal.tasks.compile.ApiClassExtractor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( ApiMemberSelector . isCandidateApiMember ( originalClassReader . getAccess (  )  ,    apiIncludesPackagePrivateMembers )  )  )     {", "return   false ;", "}", "String   originalClassName    =    originalClassReader . getClassName (  )  ;", "if    (  . isLocalClass ( originalClassName )  )     {", "return   false ;", "}", "return    (  ( exportedPackages )     =  =    null )     |  |     ( exportedPackages . contains (  . packageNameOf ( originalClassName )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldExtractApiClassFrom"], "fileName": "org.gradle.api.internal.tasks.compile.ApiClassExtractor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ApiMemberSelector . isPublicMember ( access )  )     |  |     ( ApiMemberSelector . isProtectedMember ( access )  )  )     |  |     ( apiIncludesPackagePrivateMembers    &  &     ( ApiMemberSelector . isPackagePrivateMember ( access )  )  )  ;", "}", "METHOD_END"], "methodName": ["isCandidateApiMember"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "return    ( access    &     (  (  ( ACC _ PUBLIC )     |     ( ACC _ PROTECTED )  )     |     ( ACC _ PRIVATE )  )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isPackagePrivateMember"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "return   thisClassIsPrivateInnerClass ;", "}", "METHOD_END"], "methodName": ["isPrivateInnerClass"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "return    ( access    &     ( ACC _ PROTECTED )  )     =  =     ( ACC _ PROTECTED )  ;", "}", "METHOD_END"], "methodName": ["isProtectedMember"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "return    ( access    &     ( ACC _ PUBLIC )  )     =  =     ( ACC _ PUBLIC )  ;", "}", "METHOD_END"], "methodName": ["isPublicMember"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "for    ( AnnotationMember   annotation    :    annotationMembers )     {", "AnnotationVisitor   annotationVisitor    =    aAdapter . visitAnnotation ( annotation . getName (  )  ,    annotation . isVisible (  )  )  ;", "visitAnnotationValues ( annotation ,    annotationVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAnnotationMembers"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "for    ( AnnotationMember   annotation    :    annotationMembers )     {", "AnnotationVisitor   annotationVisitor    =    fv . visitAnnotation ( annotation . getName (  )  ,    annotation . isVisible (  )  )  ;", "visitAnnotationValues ( annotation ,    annotationVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAnnotationMembers"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "for    ( AnnotationMember   annotation    :    annotationMembers )     {", "AnnotationVisitor   annotationVisitor ;", "if    ( annotation   instanceof   ParameterAnnotationMember )     {", "annotationVisitor    =    mv . visitParameterAnnotation (  (  ( ParameterAnnotationMember )     ( annotation )  )  . getParameter (  )  ,    annotation . getName (  )  ,    annotation . isVisible (  )  )  ;", "} else    {", "annotationVisitor    =    mv . visitAnnotation ( annotation . getName (  )  ,    annotation . isVisible (  )  )  ;", "}", "visitAnnotationValues ( annotation ,    annotationVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAnnotationMembers"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "String   name    =    value . getName (  )  ;", "if    ( value   instanceof   EnumAnnotationValue )     {", "annotationVisitor . visitEnum ( name ,     (  ( EnumAnnotationValue )     ( value )  )  . getTypeDesc (  )  ,     (  ( String )     ( value . getValue (  )  )  )  )  ;", "} else", "if    ( value   instanceof   SimpleAnnotationValue )     {", "annotationVisitor . visit ( name ,    value . getValue (  )  )  ;", "} else", "if    ( value   instanceof   ArrayAnnotationValue )     {", "AnnotationVisitor   arrayVisitor    =    annotationVisitor . visitArray ( name )  ;", "AnnotationValue <  ?  >  [  ]    values    =     (  ( ArrayAnnotationValue )     ( value )  )  . getValue (  )  ;", "for    ( AnnotationValue <  ?  >    annotationValue    :    values )     {", "visitAnnotationValue ( arrayVisitor ,    annotationValue )  ;", "}", "arrayVisitor . visitEnd (  )  ;", "} else", "if    ( value   instanceof   AnnotationAnnotationValue )     {", "Annotation   annotation    =     (  ( AnnotationAnnotationValue )     ( value )  )  . getValue (  )  ;", "AnnotationVisitor   annVisitor    =    annotationVisitor . visitAnnotation ( name ,    annotation . getName (  )  )  ;", "visitAnnotationValues ( annotation ,    annVisitor )  ;", "}", "}", "METHOD_END"], "methodName": ["visitAnnotationValue"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "for    ( AnnotationValue <  ?  >    value    :    annotation . getValues (  )  )     {", "visitAnnotationValue ( annotationVisi ,    value )  ;", "}", "annotationVisi . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["visitAnnotationValues"], "fileName": "org.gradle.api.internal.tasks.compile.ApiMemberSelector"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . copyOf ( interfaces ,    interfaces . length )  ;", "}", "METHOD_END"], "methodName": ["getInterfaces"], "fileName": "org.gradle.api.internal.tasks.compile.ClassMember"}, {"methodBody": ["METHOD_START", "{", "return   superName ;", "}", "METHOD_END"], "methodName": ["getSuperName"], "fileName": "org.gradle.api.internal.tasks.compile.ClassMember"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.internal.tasks.compile.ClassMember"}, {"methodBody": ["METHOD_START", "{", "return   typeDesc ;", "}", "METHOD_END"], "methodName": ["getTypeDesc"], "fileName": "org.gradle.api.internal.tasks.compile.EnumAnnotationValue"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.api.internal.tasks.compile.FieldMember"}, {"methodBody": ["METHOD_START", "{", "return   innerName ;", "}", "METHOD_END"], "methodName": ["getInnerName"], "fileName": "org.gradle.api.internal.tasks.compile.InnerClassMember"}, {"methodBody": ["METHOD_START", "{", "return   outerName ;", "}", "METHOD_END"], "methodName": ["getOuterName"], "fileName": "org.gradle.api.internal.tasks.compile.InnerClassMember"}, {"methodBody": ["METHOD_START", "{", "return   ComparisonChain . start (  )  . compare ( name ,    o . name )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.gradle.api.internal.tasks.compile.Member"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.tasks.compile.Member"}, {"methodBody": ["METHOD_START", "{", "parameterAnnotations . add ( parameterAnnotationMember )  ;", "}", "METHOD_END"], "methodName": ["addParameterAnnotation"], "fileName": "org.gradle.api.internal.tasks.compile.MethodMember"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSortedSet . copyOf ( exceptions )  ;", "}", "METHOD_END"], "methodName": ["getExceptions"], "fileName": "org.gradle.api.internal.tasks.compile.MethodMember"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSortedSet . copyOf ( parameterAnnotations )  ;", "}", "METHOD_END"], "methodName": ["getParameterAnnotations"], "fileName": "org.gradle.api.internal.tasks.compile.MethodMember"}, {"methodBody": ["METHOD_START", "{", "MethodVisitor   mv    =    cv . visitMethod (  (  (  ( ACC _ PRIVATE )     |     ( ACC _ STATIC )  )     |     ( ACC _ SYNTHETIC )  )  ,    MethodStubbingApiMemberAdapter . UOE _ METHOD ,     \"  (  ) Ljava / lang / UnsupportedOperationException ;  \"  ,    null ,    null )  ;", "mv . visitCode (  )  ;", "mv . visitTypeInsn ( NEW ,     \" java / lang / UnsupportedOperationException \"  )  ;", "mv . visitInsn ( DUP )  ;", "mv . visitLdcInsn (  \" You   tried   to   call   a   method   on   an   API   class .    Is   the   API   jar   on   the   classpath   instead   of   the   runtime   jar ?  \"  )  ;", "mv . visitMethodInsn ( INVOKESPECIAL ,     \" java / lang / UnsupportedOperationException \"  ,     \"  < init >  \"  ,     \"  ( Ljava / lang / String ;  ) V \"  ,    false )  ;", "mv . visitInsn ( ARETURN )  ;", "mv . visitMaxs (  3  ,     0  )  ;", "mv . visitEnd (  )  ;", "}", "METHOD_END"], "methodName": ["generateUnsupportedOperationExceptionMethod"], "fileName": "org.gradle.api.internal.tasks.compile.MethodStubbingApiMemberAdapter"}, {"methodBody": ["METHOD_START", "{", "return   parameter ;", "}", "METHOD_END"], "methodName": ["getParameter"], "fileName": "org.gradle.api.internal.tasks.compile.ParameterAnnotationMember"}, {"methodBody": ["METHOD_START", "{", "return   name    =  =    null    ?     \" value \"     :    name ;", "}", "METHOD_END"], "methodName": ["nameOrValue"], "fileName": "org.gradle.api.internal.tasks.compile.SortingAnnotationVisitor"}, {"methodBody": ["METHOD_START", "{", "return   super . compare ( o )  . compare (  (  ( typeDesc )     =  =    null    ?     \"  \"     :    typeDesc )  ,     (  ( o . typeDesc )     =  =    null    ?     \"  \"     :    o . typeDesc )  )  ;", "}", "METHOD_END"], "methodName": ["compare"], "fileName": "org.gradle.api.internal.tasks.compile.TypedMember"}, {"methodBody": ["METHOD_START", "{", "return   typeDesc ;", "}", "METHOD_END"], "methodName": ["getTypeDesc"], "fileName": "org.gradle.api.internal.tasks.compile.TypedMember"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . executionTime )     !  =    null )     {", "throw   new   IllegalStateException (  \" execution   time   already   set \"  )  ;", "}", "return   this . executionTime    =    executionTimer . getElapsedMillis (  )  ;", "}", "METHOD_END"], "methodName": ["markExecutionTime"], "fileName": "org.gradle.api.internal.tasks.execution.DefaultTaskExecutionContext"}, {"methodBody": ["METHOD_START", "{", "String   beanName    =    task . toString (  )  ;", "GetInputFilesVisitor   inputFilesVisitor    =    new   GetInputFilesVisitor (  )  ;", "GetOutputFilesVisitor   outputFilesVisitor    =    new   GetOutputFilesVisitor (  )  ;", "GetInputPropertiesVisitor   inputPropertiesVisitor    =    new   GetInputPropertiesVisitor ( beanName )  ;", ". GetLocalStateVisitor   localStateVisitor    =    new    . GetLocalStateVisitor ( beanName ,    resolver )  ;", ". GetDestroyablesVisitor   destroyablesVisitor    =    new    . GetDestroyablesVisitor ( beanName ,    resolver )  ;", ". ValidationVisitor   validationVisitor    =    new    . ValidationVisitor (  )  ;", "try    {", "TaskPropertyUtils . visitProperties ( propertyWalker ,    task ,    new   CompositePropertyVisitor ( inputPropertiesVisitor ,    inputFilesVisitor ,    outputFilesVisitor ,    validationVisitor ,    destroyablesVisitor ,    localStateVisitor )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   TaskExecutionException ( task ,    e )  ;", "}", "return   new    ( task . toString (  )  ,    inputPropertiesVisitor . getPropertyValuesFactory (  )  ,    inputFilesVisitor . getFileProperties (  )  ,    outputFilesVisitor . getFileProperties (  )  ,    outputFilesVisitor . hasDeclaredOutputs (  )  ,    localStateVisitor . getFiles (  )  ,    destroyablesVisitor . getFiles (  )  ,    validationVisitor . getTaskPropertySpecs (  )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.tasks.execution.DefaultTaskProperties"}, {"methodBody": ["METHOD_START", "{", "listener . beforeActions ( task )  ;", "if    ( task . hasTaskActions (  )  )     {", "outputsGenerationListener . beforeTaskOutputChanged (  )  ;", "}", "state . setExecuting ( true )  ;", "try    {", "GradleException   failure    =    e ( task ,    state ,    context )  ;", "if    ( failure    !  =    null )     {", "state . setOutcome ( failure )  ;", "} else    {", "state . setOutcome (  ( state . getDidWork (  )     ?    TaskExecutionOutcome . EXECUTED    :    TaskExecutionOutcome . UP _ TO _ DATE )  )  ;", "}", "context . getTaskArtifactState (  )  . snapshotAfterTaskExecution ( failure ,    buildInvocationScopeId . getId (  )  ,    context )  ;", "}    finally    {", "state . setExecuting ( false )  ;", "listener . afterActions ( task )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "action . contextualise ( context )  ;", "buildOperationExecutor . run ( new   RunnableBuildOperation (  )     {", "@ Override", "public   Builder   description (  )     {", "return   BuildOperationDescriptor . displayName (  (  ( actionDisplayName    +     \"    for    \"  )     +     ( task . getPath (  )  )  )  )  . name ( actionDisplayName )  ;", "}", "@ Override", "public   void   run ( BuildOperationContext   context )     {", "BuildOperationRef   currentOperation    =    buildOperationExecutor . getCurrentOperation (  )  ;", "Throwable   actionFailure    =    null ;", "try    {", "action . execute ( task )  ;", "}    catch    ( Throwable   t )     {", "actionFailure    =    t ;", "}    finally    {", "action . releaseContext (  )  ;", "}", "try    {", "asyncWorkTracker . waitForCompletion ( currentOperation ,    true )  ;", "}    catch    ( Throwable   t )     {", "List < Throwable >    failures    =    Lists . newArrayList (  )  ;", "if    ( actionFailure    !  =    null )     {", "failures . add ( actionFailure )  ;", "}", "if    ( t   instanceof   MultiCauseException )     {", "failures . addAll (  (  ( MultiCauseException )     ( t )  )  . getCauses (  )  )  ;", "} else    {", "failures . add ( t )  ;", "}", "if    (  ( failures . size (  )  )     >     1  )     {", "throw   new    . MultipleTaskActionFailures (  \" Multiple   task   action   failures   occurred :  \"  ,    failures )  ;", "} else    {", "throw   UncheckedException . throwAsUncheckedException ( failures . get (  0  )  )  ;", "}", "}", "if    ( actionFailure    !  =    null )     {", "throw   UncheckedException . throwAsUncheckedException ( actionFailure )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeAction"], "fileName": "org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "ExecuteActionsTaskExecuter . LOGGER . debug (  \" Executing   actions   for    {  }  .  \"  ,    task )  ;", "final   List < ContextAwareTaskAction >    actions    =    new   ArrayList < ContextAwareTaskAction >  ( task . getTaskActions (  )  )  ;", "for    ( ContextAwareTaskAction   action    :    actions )     {", "state . setDidWork ( true )  ;", "task . getStandardOutputCapture (  )  . start (  )  ;", "try    {", "executeAction ( action . getDisplayName (  )  ,    task ,    action ,    context )  ;", "}    catch    ( StopActionException   e )     {", "ExecuteActionsTaskExecuter . LOGGER . debug (  \" Action   stopped   by   some   action   with   message :     {  }  \"  ,    e . getMessage (  )  )  ;", "}    catch    ( StopExecutionException   e )     {", "ExecuteActionsTaskExecuter . LOGGER . info (  \" Execution   stopped   by   some   action   with   message :     {  }  \"  ,    e . getMessage (  )  )  ;", "break ;", "}    catch    ( Throwable   t )     {", "return   new   TaskExecutionException ( task ,    t )  ;", "}    finally    {", "task . getStandardOutputCapture (  )  . stop (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["executeActions"], "fileName": "org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( state . getExecuted (  )  )     {", "return ;", "}", ". LOGGER . debug (  \" Starting   to   execute    {  }  \"  ,    task )  ;", "try    {", "executer . execute ( task ,    state ,    context )  ;", "}    finally    {", ". LOGGER . debug (  \" Finished   executing    {  }  \"  ,    task )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( output    =  =    null )     {", ". LOGGER . debug (  \" Not   ensuring   directory   exists   for   property    {  }  ,    because   value   is   null \"  ,    outputProperty )  ;", "return ;", "}", "switch    ( type )     {", "case   DIRECTORY    :", ". LOGGER . debug (  \" Ensuring   directory   exists   for   property    {  }    at    {  }  \"  ,    outputProperty ,    output )  ;", "GFileUtils . mkdirs ( output )  ;", "break ;", "case   FILE    :", ". LOGGER . debug (  \" Ensuring   parent   directory   exists   for   property    {  }    at    {  }  \"  ,    outputProperty ,    output )  ;", "GFileUtils . mkdirs ( output . getParentFile (  )  )  ;", "break ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureOutput"], "fileName": "org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskOutputFilePropertySpec   outputProperty    :    context . getTaskProperties (  )  . getOutputFileProperties (  )  )     {", "OutputType   type    =    outputProperty . getOutputType (  )  ;", "for    ( File   output    :    outputProperty . getPropertyFiles (  )  )     {", ". ensureOutput ( outputProperty ,    output ,    type )  ;", "}", "}", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "TaskArtifactState   taskState    =    context . getTaskArtifactState (  )  ;", "TaskOutputCachingBuildCacheKey   cacheKey    =    taskState . calculateCacheKey (  )  ;", "if    ( context . getTaskProperties (  )  . hasDeclaredOutputs (  )  )     {", "if    ( cacheKey . isValid (  )  )     {", "LogLevel   logLevel    =     ( buildCacheDebugLogging )     ?    LogLevel . LIFECYCLE    :    LogLevel . INFO ;", ". LOGGER . log ( logLevel ,     \" Build   cache   key   for    {  }    is    {  }  \"  ,    task ,    cacheKey . getHashCode (  )  )  ;", "}", "}", "return   cacheKey ;", "}", "METHOD_END"], "methodName": ["doResolve"], "fileName": "org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter"}, {"methodBody": ["METHOD_START", "{", "buildOperationExecutor . run ( new   RunnableBuildOperation (  )     {", "@ Override", "public   void   run ( BuildOperationContext   buildOperationContext )     {", "TaskOutputCachingBuildCacheKey   cacheKey    =    doResolve ( task ,    context )  ;", "buildOperationContext . setResult ( new    . OperationResultImpl ( cacheKey )  )  ;", "context . setBuildCacheKey ( cacheKey )  ;", "}", "@ Override", "public   Builder   description (  )     {", "return   BuildOperationDescriptor . displayName (  (  (  (  . BUILD _ OPERATION _ NAME )     +     \"    for    \"  )     +     ( task . getIdentityPath (  )  )  )  )  . name (  . BUILD _ OPERATION _ NAME )  . details (  . OperationDetailsImpl . INSTANCE )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.api.internal.tasks.execution.ResolveBuildCacheKeyExecuter"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet . Builder < ResolvedTaskOutputFilePropertySpec >    builder    =    ImmutableSortedSet . naturalOrder (  )  ;", "for    ( TaskOutputFilePropertySpec   property    :    properties )     {", "CacheableTaskOutputFilePropertySpec   cacheableProperty    =     (  ( CacheableTaskOutputFilePropertySpec )     ( property )  )  ;", "builder . add ( new   ResolvedTaskOutputFilePropertySpec ( cacheableProperty . getPropertyName (  )  ,    cacheableProperty . getOutputType (  )  ,    cacheableProperty . getOutputFile (  )  )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["resolveProperties"], "fileName": "org.gradle.api.internal.tasks.execution.SkipCachedTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "TaskProperties   taskProperties    =    context . getTaskProperties (  )  ;", "FileCollection   sourceFiles    =    taskProperties . getSourceFiles (  )  ;", "if    (  ( taskProperties . hasSourceFiles (  )  )     &  &     ( sourceFiles . isEmpty (  )  )  )     {", "TaskArtifactState   taskArtifactState    =    context . getTaskArtifactState (  )  ;", "TaskExecutionHistory   executionHistory    =    taskArtifactState . getExecutionHistory (  )  ;", "Set < File >    outputFiles    =    executionHistory . getOutputFiles (  )  ;", "if    ( outputFiles . isEmpty (  )  )     {", "state . setOutcome ( TaskExecutionOutcome . NO _ SOURCE )  ;", ". LOGGER . info (  \" Skipping    {  }    as   it   has   no   source   files   and   no   previous   output   files .  \"  ,    task )  ;", "} else    {", "boolean   cleanupDirectories    =     ( executionHistory . getOverlappingOutputs (  )  )     =  =    null ;", "if    (  ! cleanupDirectories )     {", ". LOGGER . info (  \" No   leftover   directories   for    {  }    will   be   deleted   since   overlapping   outputs   were   detected .  \"  ,    task )  ;", "}", "taskOutputChangesListener . beforeTaskOutputChanged (  )  ;", "boolean   deletedFiles    =    false ;", "boolean   debugEnabled    =     . LOGGER . isDebugEnabled (  )  ;", "for    ( File   file    :    outputFiles )     {", "if    (  ( file . exists (  )  )     &  &     ( buildOutputCleanupRegistry . isOutputOwnedByBuild ( file )  )  )     {", "if    (  (  ! cleanupDirectories )     &  &     ( file . isDirectory (  )  )  )     {", "continue ;", "}", "if    ( debugEnabled )     {", ". LOGGER . debug (  \" Deleting   stale   output   file    '  {  }  '  .  \"  ,    file . getAbsolutePath (  )  )  ;", "}", "GFileUtils . forceDelete ( file )  ;", "deletedFiles    =    true ;", "}", "}", "if    ( deletedFiles )     {", ". LOGGER . info (  \" Cleaned   previous   output   of    {  }    as   it   has   no   source   files .  \"  ,    task )  ;", "state . setOutcome ( TaskExecutionOutcome . EXECUTED )  ;", "} else    {", "state . setOutcome ( TaskExecutionOutcome . NO _ SOURCE )  ;", "}", "taskArtifactState . snapshotAfterTaskExecution ( null ,    buildInvocationScopeId . getId (  )  ,    context )  ;", "}", "taskInputsListener . onExecute ( task ,    Cast . cast ( FileCollectionInternal . class ,    sourceFiles )  )  ;", "return ;", "} else    {", "taskInputsListener . onExecute ( task ,    Cast . cast ( FileCollectionInternal . class ,    taskProperties . getInputFiles (  )  )  )  ;", "}", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "boolean   skip ;", "try    {", "skip    =     !  ( task . getOnlyIf (  )  . isSatisfiedBy ( task )  )  ;", "}    catch    ( Throwable   t )     {", "state . setOutcome ( new   GradleException ( String . format (  \" Could   not   evaluate   onlyIf   predicate   for    % s .  \"  ,    task )  ,    t )  )  ;", "return ;", "}", "if    ( skip )     {", ". LOGGER . info (  \" Skipping    {  }    as   task   onlyIf   is   false .  \"  ,    task )  ;", "state . setOutcome ( TaskExecutionOutcome . SKIPPED )  ;", "return ;", "}", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( task . hasTaskActions (  )  )  )     {", ". LOGGER . info (  \" Skipping    {  }    as   it   has   no   actions .  \"  ,    task )  ;", "boolean   upToDate    =    true ;", "if    ( taskExecutionGraph . hasTask ( task )  )     {", "for    ( Task   dependency    :    taskExecutionGraph . getDependencies ( task )  )     {", "if    (  !  ( dependency . getState (  )  . getSkipped (  )  )  )     {", "upToDate    =    false ;", "break ;", "}", "}", "}", "state . setActionable ( false )  ;", "state . setOutcome (  ( upToDate    ?    TaskExecutionOutcome . UP _ TO _ DATE    :    TaskExecutionOutcome . EXECUTED )  )  ;", "return ;", "}", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter"}, {"methodBody": ["METHOD_START", "{", "SkipUpToDateTaskExecuter . LOGGER . debug (  \" Determining   if    {  }    is   up - to - date \"  ,    task )  ;", "TaskArtifactState   taskArtifactState    =    context . getTaskArtifactState (  )  ;", "List < String >    messages    =    new   ArrayList < String >  ( TaskUpToDateState . MAX _ OUT _ OF _ DATE _ MESSAGES )  ;", "if    ( taskArtifactState . isUpToDate ( messages )  )     {", "SkipUpToDateTaskExecuter . LOGGER . info (  \" Skipping    {  }    as   it   is   up - to - date .  \"  ,    task )  ;", "state . setOutcome ( TaskExecutionOutcome . UP _ TO _ DATE )  ;", "context . setOriginExecutionMetadata ( taskArtifactState . getExecutionHistory (  )  . getOriginExecutionMetadata (  )  )  ;", "return ;", "}", "context . setUpToDateMessages ( ImmutableList . copyOf ( messages )  )  ;", "logOutOfDateMessages ( messages ,    task )  ;", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( SkipUpToDateTaskExecuter . LOGGER . isInfoEnabled (  )  )     {", "Formatter   formatter    =    new   Formatter (  )  ;", "formatter . format (  \" Task    '  % s '    is   not   up - to - date   because :  \"  ,    task . getIdentityPath (  )  )  ;", "for    ( String   message    :    messages )     {", "formatter . format (  \"  % n       % s \"  ,    message )  ;", "}", "SkipUpToDateTaskExecuter . LOGGER . info ( formatter . toString (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logOutOfDateMessages"], "fileName": "org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "List < String >    messages    =    Lists . newArrayList (  )  ;", "FileResolver   resolver    =     (  ( ProjectInternal )     ( task . getProject (  )  )  )  . getFileResolver (  )  ;", "final   TaskValidationContext   validationContext    =    new   DefaultTaskValidationContext ( resolver ,    messages )  ;", "try    {", "context . getTaskProperties (  )  . validate ( validationContext )  ;", "}    catch    ( Exception   ex )     {", "throw   new   ionException ( task ,    ex )  ;", "}", "if    (  !  ( messages . isEmpty (  )  )  )     {", "List < String >    firstMessages    =    messages . subList (  0  ,    Math . min (  5  ,    messages . size (  )  )  )  ;", "if    (  !  ( validationContext . getHighestSeverity (  )  . report ( task ,    firstMessages ,    state )  )  )     {", "return ;", "}", "}", "executer . execute ( task ,    state ,    context )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter"}, {"methodBody": ["METHOD_START", "{", "return   executedTasksCount ;", "}", "METHOD_END"], "methodName": ["getExecutedTasksCount"], "fileName": "org.gradle.api.internal.tasks.execution.statistics.TaskExecutionStatistics"}, {"methodBody": ["METHOD_START", "{", "return   fromCacheTaskCount ;", "}", "METHOD_END"], "methodName": ["getFromCacheTaskCount"], "fileName": "org.gradle.api.internal.tasks.execution.statistics.TaskExecutionStatistics"}, {"methodBody": ["METHOD_START", "{", "return    (  ( executedTasksCount )     +     ( fromCacheTaskCount )  )     +     ( upToDateTaskCount )  ;", "}", "METHOD_END"], "methodName": ["getTotalTaskCount"], "fileName": "org.gradle.api.internal.tasks.execution.statistics.TaskExecutionStatistics"}, {"methodBody": ["METHOD_START", "{", "return   upToDateTaskCount ;", "}", "METHOD_END"], "methodName": ["getUpToDateTaskCount"], "fileName": "org.gradle.api.internal.tasks.execution.statistics.TaskExecutionStatistics"}, {"methodBody": ["METHOD_START", "{", "return    ( task . getProject (  )  . getGradle (  )  . getParent (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["taskIsForNestedBuild"], "fileName": "org.gradle.api.internal.tasks.execution.statistics.TaskExecutionStatisticsEventAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( type    =  =     ( Boolean . class )  )     |  |     ( type    =  =     ( Boolean . TYPE )  )  )     {", "return   Void . TYPE ;", "} else    {", "return   type ;", "}", "}", "METHOD_END"], "methodName": ["calculateOptionType"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   ValueNotationParserFactory . toComposite ( Type )  ;", "}    catch    ( OptionValidationException   ex )     {", "throw   new   OptionValidationException ( String . format (  \" Option    '  % s '    cannot   be   casted   to   type    '  % s '    in   class    '  % s '  .  \"  ,    Name ,    Type . getName (  )  ,    declaringClass . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createNotationParserOrFail"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "ValueCollectingDiagnosticsVisitor   visitor    =    new   ValueCollectingDiagnosticsVisitor (  )  ;", "notaParser . describe ( visitor )  ;", "return   visitor . getValues (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableValues"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   notationParser ;", "}", "METHOD_END"], "methodName": ["getNotationParser"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   optionName ;", "}", "METHOD_END"], "methodName": ["getOptionName"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   optionType ;", "}", "METHOD_END"], "methodName": ["getOptionType"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "final   JavaMethod < Object ,    Object >    javaMethod    =    JavaReflectionUtil . method ( Object . class ,    method )  ;", "return   invoke ( object ,    parameterValues )  ;", "}", "METHOD_END"], "methodName": ["invokeMethod"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . description (  )  ;", "}    catch    ( IncompleteAnnotationException   ex )     {", "throw   new   OptionValidationException ( String . format (  \" No   description   set   on       '  % s '    at   for   class    '  % s '  .  \"  ,    Name ,    declaringClass . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readDescription"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . description (  )  ;", "}    catch    ( IncompleteAnnotationException   ex )     {", "throw   new   OptionValidationException ( String . format (  \" No   description   set   on       '  % s '    at   for   class    '  % s '  .  \"  ,    Name ,    declaringClass . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["readDescription"], "fileName": "org.gradle.api.internal.tasks.options.AbstractOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getOptionType (  )  )     =  =     ( Void . TYPE )  )     &  &     (  ( parameterValues . size (  )  )     =  =     0  )  )     {", "setFieldValue ( object ,    true )  ;", "} else", "if    (  (  ( parameterValues . size (  )  )     >     1  )     |  |     ( List . class . equals ( getOptionType (  )  )  )  )     {", "setFieldValue ( object ,    parameterValues )  ;", "} else    {", "Object   arg    =    getNotationParser (  )  . parseNotation ( parameterValues . get (  0  )  )  ;", "setFieldValue ( object ,    arg )  ;", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( option . option (  )  . length (  )  )     =  =     0  )     {", "return   field . getName (  )  ;", "} else    {", "return   option . option (  )  ;", "}", "}", "METHOD_END"], "methodName": ["calOptionName"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( option . option (  )  . length (  )  )     =  =     0  )     {", "return   field . getName (  )  ;", "} else    {", "return   option . option (  )  ;", "}", "}", "METHOD_END"], "methodName": ["calOptionName"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "String   optionName    =    FieldOptionElement . calOptionName ( option ,    field )  ;", "Class <  ?  >    optionType    =    AbstractOptionElement . calculateOptionType ( field . getType (  )  )  ;", "NotationParser < CharSequence ,     ?  >    notationParser    =    AbstractOptionElement . createNotationParserOrFail ( optionValueNotationParserFactory ,    optionName ,    optionType ,    field . getDeclaringClass (  )  )  ;", "return   new   FieldOptionElement ( field ,    optionName ,    option ,    optionType ,    notationParser )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "String   optionName    =    FieldOptionElement . calOptionName ( option ,    field )  ;", "Class <  ?  >    optionType    =    AbstractOptionElement . calculateOptionType ( field . getType (  )  )  ;", "NotationParser < CharSequence ,     ?  >    notationParser    =    AbstractOptionElement . createNotationParserOrFail ( optionValueNotationParserFactory ,    optionName ,    optionType ,    field . getDeclaringClass (  )  )  ;", "return   new   FieldOptionElement ( field ,    optionName ,    option ,    optionType ,    notationParser )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   field . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredClass"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   field . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getElementName"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   setterName    =     \" set \"     +     ( StringUtils . capitalize ( field . getName (  )  )  )  ;", "return   field . getDeclaringClass (  )  . getMethod ( setterName ,    field . getType (  )  )  ;", "}    catch    ( NoSuchMethodException   e )     {", "throw   new   OptionValidationException ( String . format (  \" No   setter   for   Option   annotated   field    '  % s '    in   class    '  % s '  .  \"  ,    getName (  )  ,    getDeclaredClass (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getSetter"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "Method   setter    =    getSetter (  )  ;", "invokeMethod ( object ,    setter ,    value )  ;", "}", "METHOD_END"], "methodName": ["setFieldValue"], "fileName": "org.gradle.api.internal.tasks.options.FieldOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    ( objectParam    !  =     ( object )  )     {", "throw   new   AssertionError ( String . format (  \" Object    % s   not   applyable .    Expecting    % s \"  ,    objectParam ,    object )  )  ;", "}", "Element . apply ( objectParam ,    parameterValues )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   getName (  )  . compareTo ( o . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   optionElement . getOptionType (  )  ;", "}", "METHOD_END"], "methodName": ["getArgumentType"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    values    =    optionElement . getAvailableValues (  )  ;", "if    ( getArgumentType (  )  . isAssignableFrom ( String . class )  )     {", "values . addAll ( readDynamicAvailableValues (  )  )  ;", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["getAvailableValues"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   optionElement . getDescription (  )  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   optionElement . getOptionName (  )  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   optionElement ;", "}", "METHOD_END"], "methodName": ["getOptionElement"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( optionValueMethod )     !  =    null )     {", "Collection   values    =    optionValueMethod . invoke ( object )  ;", "return   CollectionUtils . toStringList ( values )  ;", "}", "return   Collections . emptyList (  )  ;", "}", "METHOD_END"], "methodName": ["readDynamicAvailableValues"], "fileName": "org.gradle.api.internal.tasks.options.InstanceOptionDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parameterValues . size (  )  )     =  =     0  )     {", "invoke ( object ,    method ,    true )  ;", "} else", "if    (  (  ( parameterValues . size (  )  )     >     1  )     |  |     ( List . class . equals ( getOptionType (  )  )  )  )     {", "invoke ( object ,    method ,    parameterValues )  ;", "} else    {", "invoke ( object ,    method ,    getNotationParser (  )  . parseNotation ( parameterValues . get (  0  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "if    (  ( parameterTypes . length )     >     1  )     {", "throw   new   OptionValidationException ( String . format (  \" Option    '  % s '    cannot   be   linked   to   methods   with   multiple   parameters   in   class    '  % s #  % s '  .  \"  ,    Name ,    method . getDeclaringClass (  )  . getName (  )  ,    method . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertMethodTypeSupported"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( getOptionName (  )  )     =  =    null )     |  |     (  ( getOptionName (  )  . length (  )  )     =  =     0  )  )     {", "throw   new   OptionValidationException ( String . format (  \" No   option   name   set   on    '  % s '    in   class    '  % s '  .  \"  ,    getName (  )  ,    getDeclaredClass (  )  . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertValidOptionName"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "if    (  ( optionMethod . getParameterTypes (  )  . length )     =  =     0  )     {", "return   Void . TYPE ;", "} else    {", "return   Abstract . calculateOptionType ( optionMethod . getParameterTypes (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["calculateOptionType"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    optionType    =    MethodOptionElement . calculateOptionType ( method )  ;", "NotationParser < CharSequence ,     ?  >    notationParser    =    AbstractOptionElement . createNotationParserOrFail ( optionValueNotationParserFactory ,    option . option (  )  ,    optionType ,    method . getDeclaringClass (  )  )  ;", "return   new   MethodOptionElement ( option ,    method ,    optionType ,    notationParser )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    optionType    =    MethodOptionElement . calculateOptionType ( method )  ;", "NotationParser < CharSequence ,     ?  >    notationParser    =    AbstractOptionElement . createNotationParserOrFail ( optionValueNotationParserFactory ,    option . option (  )  ,    optionType ,    method . getDeclaringClass (  )  )  ;", "return   new   MethodOptionElement ( option ,    method ,    optionType ,    notationParser )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   method . getDeclaringClass (  )  ;", "}", "METHOD_END"], "methodName": ["getDeclaredClass"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "return   method . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getElementName"], "fileName": "org.gradle.api.internal.tasks.options.MethodOptionElement"}, {"methodBody": ["METHOD_START", "{", "T   option    =    field . getAnnotation ( optionType )  ;", "if    ( option    !  =    null )     {", "if    ( Modifier . isStatic ( field . getModifiers (  )  )  )     {", "throw   new   OptionValidationException ( String . format (  \"  @ Option   on   static   field    '  % s '    not   supported   in   class    '  % s '  .  \"  ,    field . getName (  )  ,    field . getDeclaringClass (  )  . getName (  )  )  )  ;", "}", "}", "return   option ;", "}", "METHOD_END"], "methodName": ["findOption"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "T   option    =    method . getAnnotation ( optionType )  ;", "if    ( option    !  =    null )     {", "if    ( Modifier . isStatic ( method . getModifiers (  )  )  )     {", "throw   new   OptionValidationException ( String . format (  \"  @ Option   on   static   method    '  % s '    not   supported   in   class    '  % s '  .  \"  ,    method . getName (  )  ,    method . getDeclaringClass (  )  . getName (  )  )  )  ;", "}", "}", "return   option ;", "}", "METHOD_END"], "methodName": ["findOption"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "T   optionValues    =    method . getAnnotation ( optionValuesType )  ;", "if    ( optionValues    =  =    null )     {", "return   null ;", "}", "if    (  (  ( Collection . class . isAssignableFrom ( method . getReturnType (  )  )  )     &  &     (  ( method . getParameterTypes (  )  . length )     =  =     0  )  )     &  &     (  !  ( Modifier . isStatic ( method . getModifiers (  )  )  )  )  )     {", "return   JavaReflectionUtil . method ( Collection . class ,    method )  ;", "} else    {", "throw   new   OptionValidationException ( String . format (  \"  @ OptionValues   annotation   not   supported   on   method    '  % s '    in   class    '  % s '  .    Supported   method   must   be   non - static ,    return   a   Collection < String >    and   take   no   parameters .  \"  ,    method . getName (  )  ,    type . getName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAsOptionValuesMethod"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "List < OptionElement >    fieldOptionElements    =    new   ArrayList < OptionElement >  (  )  ;", "for    ( Field   field    :    type . getDeclaredFields (  )  )     {", "Option   option    =    findOption ( field ,    Option . class )  ;", "if    ( option    !  =    null )     {", "fieldOptionElements . add ( FieldOptionElement . create ( option ,    field ,    optionValueNotationParserFactory )  )  ;", "} else    {", "Option   internalOption    =    findOption ( field ,    Option . class )  ;", "if    ( internalOption    !  =    null )     {", "SingleMessageLogger . nagUserOfDeprecated (  \"  \"  ,     \" Use   Option   instead \"  )  ;", "fieldOptionElements . add ( FieldOptionElement . create ( internalOption ,    field ,    optionValueNotationParserFactory )  )  ;", "}", "}", "}", "return   fieldOptionElements ;", "}", "METHOD_END"], "methodName": ["getFieldAnnotations"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "List < OptionElement >    methodOptionElements    =    new   ArrayList < OptionElement >  (  )  ;", "for    ( Method   method    :    type . getDeclaredMethods (  )  )     {", "Option   option    =    findOption ( method ,    Option . class )  ;", "if    ( option    !  =    null )     {", "OptionElement   methodOptionDescriptor    =    MethodOptionElement . create ( option ,    method ,    optionValueNotationParserFactory )  ;", "methodOptionElements . add ( methodOptionDescriptor )  ;", "} else    {", "Option   internalOption    =    findOption ( method ,    Option . class )  ;", "if    ( internalOption    !  =    null )     {", "SingleMessageLogger . nagUserOfDeprecated (  \"  \"  ,     \" Use   Option   instead \"  )  ;", "methodOptionElements . add ( MethodOptionElement . create ( internalOption ,    method ,    optionValueNotationParserFactory )  )  ;", "}", "}", "}", "return   methodOptionElements ;", "}", "METHOD_END"], "methodName": ["getMethodAnnotations"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "List < OptionElement >    allOptionElements    =    new   ArrayList < OptionElement >  (  )  ;", "for    ( Class <  ?  >    type    =    target . getClass (  )  ;     ( type    !  =     ( Object . class )  )     &  &     ( type    !  =    null )  ;    type    =    type . getSuperclass (  )  )     {", "allOptionElements . addAll ( getMethodAnnotations ( type )  )  ;", "allOptionElements . addAll ( getFieldAnnotations ( type )  )  ;", "}", "return   allOptionElements ;", "}", "METHOD_END"], "methodName": ["getOptionElements"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "OptionValues   optionValues    =    optionValueMethod . getMethod (  )  . getAnnotation ( OptionValues . class )  ;", "if    ( optionValues    !  =    null )     {", "return   optionValues . value (  )  ;", "}", "return   optionValueMethod . getMethod (  )  . getAnnotation ( OptionValues . class )  . value (  )  ;", "}", "METHOD_END"], "methodName": ["getOptionNames"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "JavaMethod < Object ,    Collection >    valueMethod    =    null ;", "for    ( JavaMethod < Object ,    Collection >    optionValueMethod    :    optionValueMethods )     {", "String [  ]    optionNames    =     . getOptionNames ( optionValueMethod )  ;", "if    ( CollectionUtils . toList ( optionNames )  . contains ( optionElement . getOptionName (  )  )  )     {", "if    ( valueMethod    =  =    null )     {", "valueMethod    =    optionValueMethod ;", "} else    {", "throw   new   OptionValidationException ( String . format (  \"  @ OptionValues   for    '  % s '    cannot   be   attached   to   multiple   methods   in   class    '  % s '  .  \"  ,    optionElement . getOptionName (  )  ,    optionValueMethod . getMethod (  )  . getDeclaringClass (  )  . getName (  )  )  )  ;", "}", "}", "}", "return   valueMethod ;", "}", "METHOD_END"], "methodName": ["getOptionValueMethodForOption"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "final   Class <  ?  >    targetClass    =    target . getClass (  )  ;", "Map < String ,    OptionDescriptor >     =    new   HashMap < String ,    OptionDescriptor >  (  )  ;", "if    (  !  ( cachedOptionElements . containsKey ( targetClass )  )  )     {", "loadClassDescriptorInCache ( target )  ;", "}", "for    ( OptionElement   optionElement    :    cachedOptionElements . get ( targetClass )  )     {", "JavaMethod < Object ,    Collection >    optionValueMethod    =    cachedOptionValueMethods . get ( optionElement )  ;", "put ( optionElement . getOptionName (  )  ,    new   InstanceOptionDescriptor ( target ,    optionElement ,    optionValueMethod )  )  ;", "}", "return   CollectionUtils . sort ( values (  )  )  ;", "}", "METHOD_END"], "methodName": ["getOptions"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "final   Collection < OptionElement >    optionElements    =    getOptionElements ( target )  ;", "List < JavaMethod < Object ,    Collection >  >    optionValueMethods    =     . loadValueMethodForOption ( target . getClass (  )  )  ;", "Set < String >    processedOptionElements    =    new   HashSet < String >  (  )  ;", "for    ( OptionElement   optionElement    :    optionElements )     {", "if    ( processedOptionElements . contains ( optionElement . getOptionName (  )  )  )     {", "throw   new   OptionValidationException ( String . format (  \"  @ Option    '  % s '    linked   to   multiple   elements   in   class    '  % s '  .  \"  ,    optionElement . getOptionName (  )  ,    target . getClass (  )  . getName (  )  )  )  ;", "}", "processedOptionElements . add ( optionElement . getOptionName (  )  )  ;", "JavaMethod < Object ,    Collection >    optionValueMethodForOption    =     . getOptionValueMethodForOption ( optionValueMethods ,    optionElement )  ;", "cachedOptionElements . put ( target . getClass (  )  ,    optionElement )  ;", "cachedOptionValueMethods . put ( optionElement ,    optionValueMethodForOption )  ;", "}", "}", "METHOD_END"], "methodName": ["loadClassDescriptorInCache"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "List < JavaMethod < Object ,    Collection >  >    methods    =    new   ArrayList < JavaMethod < Object ,    Collection >  >  (  )  ;", "for    ( Class <  ?  >    type    =    declaredClass ;     ( type    !  =     ( Object . class )  )     &  &     ( type    !  =    null )  ;    type    =    type . getSuperclass (  )  )     {", "for    ( Method   method    :    type . getDeclaredMethods (  )  )     {", "JavaMethod < Object ,    Collection >    optionValuesMethod    =    OptionReader . getAsOptionValuesMethod ( type ,    method ,    OptionValues . class )  ;", "if    ( optionValuesMethod    !  =    null )     {", "methods . add ( optionValuesMethod )  ;", "} else    {", "optionValuesMethod    =    OptionReader . getAsOptionValuesMethod ( type ,    method ,    OptionValues . class )  ;", "if    ( optionValuesMethod    !  =    null )     {", "SingleMessageLogger . nagUserOfDeprecated (  \" Values \"  ,     \" Use   OptionValues   instead \"  )  ;", "methods . add ( optionValuesMethod )  ;", "}", "}", "}", "}", "return   methods ;", "}", "METHOD_END"], "methodName": ["loadValueMethodForOption"], "fileName": "org.gradle.api.internal.tasks.options.OptionReader"}, {"methodBody": ["METHOD_START", "{", "assert   targetType    !  =    null    :     \" resultingType   cannot   be   null \"  ;", "if    ( targetType    =  =     ( Void . TYPE )  )     {", "return   new    . UnsupportedNotationParser < T >  (  )  ;", "} else", "if    (  ( targetType . isAssignableFrom ( String . class )  )     |  |     ( targetType    =  =     ( class )  )  )     {", "return   uncheckedCast ( new    . NoDescriptionValuesJustReturningParser (  )  )  ;", "} else", "if    ( targetType . isEnum (  )  )     {", "@ SuppressWarnings (  {     \" rawtypes \"  ,     \" unchecked \"     }  )", "NotationConverter < CharSequence ,    T >    converter    =    new   EnumFromCharSequenceNotationParser ( targetType . asSubclass ( Enum . class )  )  ;", "return   new   NotationConverterToNotationParserAdapter < CharSequence ,    T >  ( converter )  ;", "}", "throw   new   OptionValidationException ( String . format (  \" Don ' t   know   how   to   convert   strings   to   type    '  % s '  .  \"  ,    targetType . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toComposite"], "fileName": "org.gradle.api.internal.tasks.options.OptionValueNotationParserFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( nodeEquivalence . equivalent ( getNodeValue (  )  ,    childValue )  )     {", "return   this ;", "}", "if    (  ( parentNode )     =  =    null )     {", "return   null ;", "}", "return   parentNode . findNodeCreatingCycle ( childValue ,    nodeEquivalence )  ;", "}", "METHOD_END"], "methodName": ["findNodeCreatingCycle"], "fileName": "org.gradle.api.internal.tasks.properties.AbstractPropertyNode"}, {"methodBody": ["METHOD_START", "{", "return   propertyName ;", "}", "METHOD_END"], "methodName": ["getPropertyName"], "fileName": "org.gradle.api.internal.tasks.properties.AbstractPropertyNode"}, {"methodBody": ["METHOD_START", "{", "return    ( propertyName )     =  =    null    ?    childPropertyName    :     (  ( propertyName )     +     \"  .  \"  )     +    childPropertyName ;", "}", "METHOD_END"], "methodName": ["getQualifiedPropertyName"], "fileName": "org.gradle.api.internal.tasks.properties.AbstractPropertyNode"}, {"methodBody": ["METHOD_START", "{", "return   typeMetadata ;", "}", "METHOD_END"], "methodName": ["getTypeMetadata"], "fileName": "org.gradle.api.internal.tasks.properties.AbstractPropertyNode"}, {"methodBody": ["METHOD_START", "{", "Builder < Class <  ?    extends   Annotation >  ,    Class <  ?    extends   Annotation >  >    builder    =    ImmutableSetMultimap . builder (  )  ;", "for    ( AnnotationHandler   handler    :    allAnnotationHandlers )     {", "if    ( handler   instanceof   OverridingAnnotationHandler )     {", "builder . put (  (  ( OverridingAnnotationHandler )     ( handler )  )  . getOverriddenAnnotationType (  )  ,    handler . getAnnotationType (  )  )  ;", "}", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectAnnotationOverrides"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "return   ImmutableSet .  < Class <  ?    extends   Annotation >  > builder (  )  . addAll ( propertyTypeAnnotations )  . add ( Optional . class )  . add ( SkipWhenEmpty . class )  . add ( PathSensitive . class )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["collectRelevantAnnotationTypes"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "List < Annotation >    relevantAnnotations    =    Lists . newArrayListWithCapacity ( annotations . length )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( relevantAnnotationTypcontains ( annotation . annotationType (  )  )  )     {", "relevantAnnotations . add ( annotation )  ;", "}", "}", "return   relevantAnnotations ;", "}", "METHOD_END"], "methodName": ["collectRelevantAnnotations"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "final   Set < Class <  ?    extends   Annotation >  >    propertyTypeAnnotations    =    annotationHandlers . keySet (  )  ;", "final   Map < String ,     . DefaultPropertyMetadata >    propertyContexts    =    Maps . newLinkedHashMap (  )  ;", "Types . walkTypeHierarchy ( type ,     . IGNORED _ SUPER _ CLASSES ,    new   Types . TypeVisitor < T >  (  )     {", "@ Override", "public   void   visitType ( Class <  ?    extends   T >    type )     {", "if    ( type . isSynthetic (  )  )     {", "return ;", "}", "Map < String ,    Field >    fields    =    getFields ( type )  ;", "List < Getter >    getters    =    getGetters ( type )  ;", "for    ( Getter   getter    :    getters )     {", "Method   method    =    getter . getMethod (  )  ;", "if    ( method . isSynthetic (  )  )     {", "continue ;", "}", "if    (  ( method . getName (  )  . equals (  \" getContentHash \"  )  )     |  |     ( method . getName (  )  . equals (  \" getOriginalClassName \"  )  )  )     {", "continue ;", "}", "String   fieldName    =    getter . getName (  )  ;", "Field   field    =    fields . get ( fieldName )  ;", "if    (  ( field    !  =    null )     &  &     ( field . isSynthetic (  )  )  )     {", "continue ;", "}", "DefaultPropertyMetadata   propertyMetadata    =    propertyContexts . get ( fieldName )  ;", "if    ( propertyMetadata    =  =    null )     {", "propertyMetadata    =    new   DefaultPropertyMetadata ( propertyTypeAnnotations ,    fieldName ,    method )  ;", "propertyContexts . put ( fieldName ,    propertyMetadata )  ;", "}", "Iterable < Annotation >    declaredAnnotations    =    mergeDeclaredAnnotations ( method ,    field ,    propertyMetadata )  ;", "Iterable < Annotation >    overriddenAnnotations    =    filterOverridingAnnotations ( declaredAnnotations ,    propertyTypeAnnotations )  ;", "recordAnnotations ( propertyMetadata ,    overriddenAnnotations ,    propertyTypeAnnotations )  ;", "}", "}", "}  )  ;", "return   new    . DefaultTypeMetadata ( ImmutableSet .  < PropertyMetadata > builder (  )  . addAll ( propertyContexts . values (  )  )  . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createTypeMetadata"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "return   Iterables . filter ( declaredAnnotations ,    new   com . google . common . base . Predicate < Annotation >  (  )     {", "@ Override", "public   boolean   apply ( Annotation   input )     {", "Class <  ?    extends   Annotation >    annotationType    =    input . annotationType (  )  ;", "if    (  !  ( yTypeAnnotations . contains ( annotationType )  )  )     {", "return   true ;", "}", "for    ( Class <  ?    extends   Annotation >    overridingAnnotation    :    annotationOverrides . get ( annotationType )  )     {", "for    ( Annotation   declaredAnnotation    :    declaredAnnotations )     {", "if    ( declaredAnnotation . annotationType (  )  . equals ( overridingAnnotation )  )     {", "return   false ;", "}", "}", "}", "return   true ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["filterOverridingAnnotations"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Field >    fields    =    Maps . newHashMap (  )  ;", "for    ( Field   field    :    type . getDeclaredFields (  )  )     {", "fieldut ( field . getName (  )  ,    field )  ;", "}", "return   fields ;", "}", "METHOD_END"], "methodName": ["getFields"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "Method [  ]    methods    =    type . getDeclaredMethods (  )  ;", "List <  . Getter >    getters    =    Lists . newArrayListWithCapacity ( methods . length )  ;", "for    ( Method   method    :    methods )     {", "PropertyAccessorType   accessorType    =    PropertyAccessorType . of ( method )  ;", "if    (  ( accessorType    =  =    null )     |  |     ( accessorType    =  =     ( PropertyAccessorType . SETTER )  )  )     {", "continue ;", "}", "if    (  ( method . isBridge (  )  )     |  |     ( GroovyMethods . isObjectMethod ( method )  )  )     {", "continue ;", "}", "getters . add ( new    . Getter ( method ,    accessorType . propertyNameFor ( method )  )  )  ;", "}", "Collections . sort ( getters )  ;", "return   getters ;", "}", "METHOD_END"], "methodName": ["getGetters"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "Collection < Annotation >    methodAnnotations    =    collectRelevantAnnotations ( method . getDeclaredAnnotations (  )  )  ;", "if    (  ( Modifier . isPrivate ( method . getModifiers (  )  )  )     &  &     (  !  ( methodAnnotations . isEmpty (  )  )  )  )     {", "yContext . validationMessage (  \" is   private   and   annotated   with   an   input   or   output   annotation \"  )  ;", "}", "if    ( field    =  =    null )     {", "return   methodAnnotations ;", "}", "Collection < Annotation >    fieldAnnotations    =    collectRelevantAnnotations ( field . getDeclaredAnnotations (  )  )  ;", "if    ( fieldAnnotations . isEmpty (  )  )     {", "return   methodAnnotations ;", "}", "if    ( methodAnnotations . isEmpty (  )  )     {", "return   fieldAnnotations ;", "}", "for    ( Annotation   methodAnnotation    :    methodAnnotations )     {", "Iterator < Annotation >    iFieldAnnotation    =    fieldAnnotations . iterator (  )  ;", "while    ( iFieldAnnotation . hasNext (  )  )     {", "Annotation   fieldAnnotation    =    iFieldAnnotation . next (  )  ;", "if    ( methodAnnotation . annotationType (  )  . equals ( fieldAnnotation . annotationType (  )  )  )     {", "yContext . validationMessage (  (  \" has   both   a   getter   and   field   declared   with   annotation    @  \"     +     ( methodAnnotation . annotationType (  )  . getSimpleName (  )  )  )  )  ;", "iFieldAnnotation . remove (  )  ;", "}", "}", "}", "return   Iterables . concat ( methodAnnotations ,    fieldAnnotations )  ;", "}", "METHOD_END"], "methodName": ["mergeDeclaredAnnotations"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "Set < Class <  ?    extends   Annotation >  >    declaredPropertyTypes    =    Sets . newLinkedHashSet (  )  ;", "for    ( Annotation   annotation    :    annotations )     {", "if    ( propertyTypeAnnotations . contains ( annotation . annotationType (  )  )  )     {", "declaredPropertyTypes . add ( annotation . annotationType (  )  )  ;", "}", "propertyContext . addAnnotation ( annotation )  ;", "}", "if    (  ( declaredPropertyTypes . size (  )  )     >     1  )     {", "propertyContext . validationMessage (  (  \" has   conflicting   property   types   declared :     \"     +     ( Joiner . on (  \"  ,     \"  )  . join ( Iterables . transform ( declaredPropertyTypes ,    new   com . google . common . base . Function < Class <  ?    extends   Annotation >  ,    String >  (  )     {", "@ Override", "public   String   apply ( Class <  ?    extends   Annotation >    annotationType )     {", "return    \"  @  \"     +     ( annotationType . getSimpleName (  )  )  ;", "}", "}  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["recordAnnotations"], "fileName": "org.gradle.api.internal.tasks.properties.DefaultPropertyMetadataStore"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileProperties )     =  =    null )     {", "fileProperties    =    TaskPropertyUtils . collectFileProperties (  \" input \"  ,    specs . iterator (  )  )  ;", "}", "return   fileProperties ;", "}", "METHOD_END"], "methodName": ["getFileProperties"], "fileName": "org.gradle.api.internal.tasks.properties.GetInputFilesVisitor"}, {"methodBody": ["METHOD_START", "{", "return   hasSourceFiles ;", "}", "METHOD_END"], "methodName": ["hasSourceFiles"], "fileName": "org.gradle.api.internal.tasks.properties.GetInputFilesVisitor"}, {"methodBody": ["METHOD_START", "{", "return   value   instanceof   GString    ?    value . toString (  )     :    value ;", "}", "METHOD_END"], "methodName": ["avoidGString"], "fileName": "org.gradle.api.internal.tasks.properties.GetInputPropertiesVisitor"}, {"methodBody": ["METHOD_START", "{", "return   new   Factory < Map < String ,    Object >  >  (  )     {", "@ Override", "public   Map < String ,    Object >    create (  )     {", "Map < String ,    Object >    result    =    new   HashMap < String ,    Object >  (  )  ;", "for    ( TaskInputPropertySpec   inputProperty    :    inputProperties )     {", "String   propertyName    =    inputProperty . getPropertyName (  )  ;", "try    {", "Object   value    =     . prepareValue ( inputProperty . getValue (  )  )  ;", "result . put ( propertyName ,    value )  ;", "}    catch    ( Exception   ex )     {", "throw   new   InvalidUserDataException ( String . format (  \" Error   while   evaluating   property    '  % s '    of    % s \"  ,    propertyName ,    beanName )  ,    ex )  ;", "}", "}", "return   result ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getPropertyValuesFactory"], "fileName": "org.gradle.api.internal.tasks.properties.GetInputPropertiesVisitor"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "if    ( value   instanceof   Callable )     {", "Callable   callable    =     (  ( Callable )     ( value )  )  ;", "value    =    GUtil . uncheckedCall ( callable )  ;", "} else", "if    ( value   instanceof   FileCollection )     {", "FileCollection   fileCollection    =     (  ( FileCollection )     ( value )  )  ;", "return   fileCollection . getFiles (  )  ;", "} else    {", "return    . avoidGString ( value )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["prepareValue"], "fileName": "org.gradle.api.internal.tasks.properties.GetInputPropertiesVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fileProperties )     =  =    null )     {", "fileProperties    =    TaskPropertyUtils . collectFileProperties (  \" output \"  ,    specs . iterator (  )  )  ;", "}", "return   fileProperties ;", "}", "METHOD_END"], "methodName": ["getFileProperties"], "fileName": "org.gradle.api.internal.tasks.properties.GetOutputFilesVisitor"}, {"methodBody": ["METHOD_START", "{", "return   hasDeclaredOutputs ;", "}", "METHOD_END"], "methodName": ["hasDeclaredOutputs"], "fileName": "org.gradle.api.internal.tasks.properties.GetOutputFilesVisitor"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskClassInfoStore   taskClassInfoStore    =    new   DefaultTaskClassInfoStore (  )  ;", "PropertyMetadataStore   metadataStore    =    new   DefaultPropertyMetadataStore ( ImmutableList . of ( new   ClasspathPropertyAnnotationHandler (  )  ,    new   CompileClasspathPropertyAnnotationHandler (  )  )  )  ;", "Queue <  . BeanTypeNode <  ?  >  >    queue    =    new   ArrayDeque <  . BeanTypeNode <  ?  >  >  (  )  ;", ". BeanTypeNodeFactory   nodeFactory    =    new    . BeanTypeNodeFactory ( metadataStore )  ;", "queue . add ( nodeFactory . createRootNode ( TypeToken . of ( topLevelBean )  )  )  ;", "boolean   cacheable    =    taskClassInfoStore . getTaskClassInfo ( Cast .  < Class <  ?    extends   Task >  > uncheckedCast ( topLevelBean )  )  . isCacheable (  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", ". BeanTypeNode <  ?  >    node    =    queue . remove (  )  ;", "node . visit ( topLevelBean ,    cacheable ,    problems ,    queue ,    nodeFactory )  ;", "}", "}", "METHOD_END"], "methodName": ["collectTaskValidationProblems"], "fileName": "org.gradle.api.internal.tasks.properties.PropertyValidationAccess"}, {"methodBody": ["METHOD_START", "{", "ParameterizedType   type    =     (  ( ParameterizedType )     ( beanType . getSupertype ( parameterizedSuperClass )  . getType (  )  )  )  ;", "return   TypeToken . of ( type . getActualTypeArguments (  )  [ typeParameterIndex ]  )  ;", "}", "METHOD_END"], "methodName": ["extractNestedType"], "fileName": "org.gradle.api.internal.tasks.properties.PropertyValidationAccess"}, {"methodBody": ["METHOD_START", "{", "return   context . getResolver (  )  . resolve ( value )  ;", "}", "METHOD_END"], "methodName": ["toFile"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.AbstractInputPropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   InputDirectory . class ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.InputDirectoryPropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   InputFile . class ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.InputFilePropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   InputFiles . class ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.InputFilesPropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   Input . class ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.InputPropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   LocalState . class ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.LocalStatePropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( value   instanceof   Provider )     {", "return    (  ( Provider <  ?  >  )     ( value )  )  . get (  )  ;", "}", "return   value ;", "}", "METHOD_END"], "methodName": ["unpackProvider"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.NestedBeanAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "return   annotationType ;", "}", "METHOD_END"], "methodName": ["getAnnotationType"], "fileName": "org.gradle.api.internal.tasks.properties.annotations.NoOpPropertyAnnotationHandler"}, {"methodBody": ["METHOD_START", "{", "TypeMetadata   typeMetadata    =    getTypeMetadata (  )  ;", "for    ( final   PropertyMetadata   propertyMetadata    :    typeMetadata . getPropertiesMetadata (  )  )     {", "PropertyValueVisitor   propertyValueVisitor    =    propertyMetadata . getPropertyValueVisitor (  )  ;", "if    ( propertyValueVisitor    =  =    null )     {", "continue ;", "}", "String   propertyName    =    getQualifiedPropertyName ( propertyMetadata . getFieldName (  )  )  ;", "PropertyValue   propertyValue    =    new    . DefaultPropertyValue ( propertyName ,    propertyMetadata . getAnnotations (  )  ,    getBean (  )  ,    propertyMetadata . getMethod (  )  )  ;", "propertyValueVisitor . visitPropertyValue ( propertyValue ,    visitor ,    specFactory ,    new   BeanPropertyContext (  )     {", "@ Override", "public   void   addNested ( String   propertyName ,    Object   bean )     {", "queue . add ( nodeFactory . create (  . this ,    propertyName ,    bean )  )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitProperties"], "fileName": "org.gradle.api.internal.tasks.properties.bean.AbstractNestedRuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "String   prefix    =     ( input   instanceof   Named )     ?     (  ( Named )     ( input )  )  . getName (  )     :     \"  \"  ;", "return    ( prefix    +     \"  $  \"  )     +    co ;", "}", "METHOD_END"], "methodName": ["determinePropertyName"], "fileName": "org.gradle.api.internal.tasks.properties.bean.IterableRuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "if    ( Proxy . isProxyClass ( bean . getClass (  )  )  )     {", "InvocationHandler   invocationHandler    =    Proxy . getInvocationHandler ( bean )  ;", "if    ( invocationHandler   instanceof   ConvertedClosure )     {", "Object   delegate    =     (  ( ConvertedClosure )     ( invocationHandler )  )  . getDelegate (  )  ;", "return   delegate . getClass (  )  ;", "}", "return   invocationHandler . getClass (  )  ;", "}", "if    ( bean   instanceof   ConfigureUtil . WrappedConfigureAction )     {", "return    (  ( ConfigureUtil . WrappedConfigureAction )     ( bean )  )  . getConfigureClosure (  )  . getClass (  )  ;", "}", "if    ( bean   instanceof   ClosureBackedAction )     {", "return    (  ( ClosureBackedAction )     ( bean )  )  . getClosure (  )  . getClass (  )  ;", "}", "return   bean . getClass (  )  ;", "}", "METHOD_END"], "methodName": ["getImplementationClass"], "fileName": "org.gradle.api.internal.tasks.properties.bean.NestedRuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskInputPropertySpec   implementation    =    specFactory . createInputPropertySpec ( getPropertyName (  )  ,    new   NestedRuntimeBeanNode . ImplementationPropertyValue ( NestedRuntimeBeanNode . getImplementationClass ( getBean (  )  )  )  )  ;", "implementation . optional ( false )  ;", "visitor . visitInputProperty ( implementation )  ;", "}", "METHOD_END"], "methodName": ["visitImplementation"], "fileName": "org.gradle.api.internal.tasks.properties.bean.NestedRuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "AbstractPropertyNode <  ?  >    nodeCreatingCycle    =    findNodeCreatingCycle ( childBean ,    Equivalence . identity (  )  )  ;", "Preconditions . checkState (  ( nodeCreatingCycle    =  =    null )  ,     \" Cycles   between   nested   beans   are   not   allowed .    Cycle   detected   between :     '  % s '    and    '  % s '  .  \"  ,    nodeCreatingCycle ,    yName )  ;", "}", "METHOD_END"], "methodName": ["checkCycles"], "fileName": "org.gradle.api.internal.tasks.properties.bean.RuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "String   qualifiedPropertyName    =    getQualifiedPropertyName ( propertyName )  ;", "Object   bean    =    Preconditions . checkNotNull ( input ,     \" Null   is   not   allowed   as   nested   property    '  % s '  \"  ,    qualifiedPropertyName )  ;", "return   nodeFactory . create ( this ,    qualifiedPropertyName ,    bean )  ;", "}", "METHOD_END"], "methodName": ["createChildNode"], "fileName": "org.gradle.api.internal.tasks.properties.bean.RuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "return   bean ;", "}", "METHOD_END"], "methodName": ["getBean"], "fileName": "org.gradle.api.internal.tasks.properties.bean.RuntimeBeanNode"}, {"methodBody": ["METHOD_START", "{", "parentNode . checkCycles ( propertyName ,    bean )  ;", "TypeMetadata   typeMetadata    =    metadataStore . getTypeMetadata ( bean . getClass (  )  )  ;", "if    (  !  ( typeMetadata . hasAnnotatedProperties (  )  )  )     {", "if    ( bean   instanceof   Map <  ?  ,     ?  >  )     {", "return   new   Map ( parentNode ,    propertyName ,     (  ( Map <  ?  ,     ?  >  )     ( bean )  )  ,    typeMetadata )  ;", "}", "if    ( bean   instanceof   Iterable <  ?  >  )     {", "return   new   Iterable ( parentNode ,    propertyName ,     (  ( Iterable <  ?  >  )     ( bean )  )  ,    typeMetadata )  ;", "}", "}", "return   new   Nested ( parentNode ,    propertyName ,    bean ,    typeMetadata )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.api.internal.tasks.properties.bean.RuntimeBeanNodeFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   RootRuntimeBeanNode ( bean ,    metadataStore . getTypeMetadata ( bean . getClass (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createRoot"], "fileName": "org.gradle.api.internal.tasks.properties.bean.RuntimeBeanNodeFactory"}, {"methodBody": ["METHOD_START", "{", "return   userInputHandler . askYesNoQuestion ( question )  ;", "}", "METHOD_END"], "methodName": ["askYesNoQuestion"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultBuildScanUserInputHandler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   prompt    =    new   StringBuilder (  )  ;", "prompt . append ( question )  ;", "prompt . append (  \"     [  \"  )  ;", "prompt . append ( StringUtils . join (  . YES _ NO _ CHOICES ,     \"  ,     \"  )  )  ;", "prompt . append (  \"  ]  \"  )  ;", "return   prompt . toString (  )  ;", "}", "METHOD_END"], "methodName": ["createPrompt"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultUserInputHandler"}, {"methodBody": ["METHOD_START", "{", "return   input    =  =    null ;", "}", "METHOD_END"], "methodName": ["isInputCancelled"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultUserInputHandler"}, {"methodBody": ["METHOD_START", "{", "return   JAVA _ ISO _ CONTROL . removeFrom ( StringUtils . trim ( input )  )  ;", "}", "METHOD_END"], "methodName": ["sanitizeInput"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultUserInputHandler"}, {"methodBody": ["METHOD_START", "{", "return    ( c    =  =     4  )     |  |     ( c    =  =     (  -  1  )  )  ;", "}", "METHOD_END"], "methodName": ["isEOF"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultUserInputReader"}, {"methodBody": ["METHOD_START", "{", "return    ( c    =  =     ( DefaultUserInputReader . UNIX _ NEW _ LINE )  )     |  |     ( c    =  =     ( DefaultUserInputReader . WINDOWS _ NEW _ LINE )  )  ;", "}", "METHOD_END"], "methodName": ["isLineSeparator"], "fileName": "org.gradle.api.internal.tasks.userinput.DefaultUserInputReader"}, {"methodBody": ["METHOD_START", "{", "TypeOf < List < String [  ]  >  [  ]  >    type    =    new   TypeOf < List < String [  ]  >  [  ]  >  (  )     {  }  ;", "assertTrue ( type . isArray (  )  )  ;", "assertFalse ( type . isSimple (  )  )  ;", "assertFalse ( type . isParameterized (  )  )  ;", "assertEquals ( new   TypeOf < List < String [  ]  >  >  (  )     {  }  ,    type . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentGenericArrayType"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "TypeOf < List < String >  >    type    =    new   TypeOf < List < String >  >  (  )     {  }  ;", "assertTrue ( type . isParameterized (  )  )  ;", "assertFalse ( type . isArray (  )  )  ;", "assertFalse ( type . isSimple (  )  )  ;", "assertEquals ( new   TypeOf < List >  (  )     {  }  ,    type . getParameterizedTypeDefinition (  )  )  ;", "assertEquals ( type . getActualTypeArguments (  )  ,    Collections . singletonList ( new   TypeOf < String >  (  )     {  }  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentParameterizedType"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "TypeOf < String [  ]  >    type    =    new   TypeOf < String [  ]  >  (  )     {  }  ;", "assertTrue ( type . isArray (  )  )  ;", "assertFalse ( type . isSimple (  )  )  ;", "assertFalse ( type . isParameterized (  )  )  ;", "assertEquals ( new   TypeOf < String >  (  )     {  }  ,    type . getComponentType (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentPrimitiveArrayType"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "TypeOf < String >    type    =    new   TypeOf < String >  (  )     {  }  ;", "assertTrue ( type . isSimple (  )  )  ;", "assertFalse ( type . isArray (  )  )  ;", "assertFalse ( type . isParameterized (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentSimpleType"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "TypeOf <  ?  >    type    =    new   TypeOf < List <  ?    extends   Cloneable >  >  (  )     {  }  . getActualTypeArguments (  )  . get (  0  )  ;", "assertTrue ( type . isWildcard (  )  )  ;", "assertEquals ( type . getUpperBound (  )  ,    new   TypeOf < Cloneable >  (  )     {  }  )  ;", "assertFalse ( type . isSimple (  )  )  ;", "assertFalse ( type . isArray (  )  )  ;", "assertFalse ( type . isParameterized (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentWildcardTypeExpression"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "TypeOf <  ?  >    type    =    new   TypeOf < List <  ?  >  >  (  )     {  }  . getActualTypeArguments (  )  . get (  0  )  ;", "assertTrue ( type . isWildcard (  )  )  ;", "assertNull ( type . getUpperBound (  )  )  ;", "assertFalse ( type . isSimple (  )  )  ;", "assertFalse ( type . isArray (  )  )  ;", "assertFalse ( type . isParameterized (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRepresentWildcardTypeExpressionWithDefaultUpperBound"], "fileName": "org.gradle.api.reflect.TypeOfTest"}, {"methodBody": ["METHOD_START", "{", "CopyActionExecuter   copyActionExecuter    =    createCopyActionExecuter (  )  ;", "CopyAction   copyAction    =    createCopyAction (  )  ;", "WorkResult   didWork    =    copyActionExecuter . execute ( rootSpec ,    copyAction )  ;", "setDidWork ( didWork . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    getInstantiator (  )  ;", "FileSystem   fileSystem    =    getFileSystem (  )  ;", "return   new   ActionExecuter ( instantiator ,    fileSystem ,    false )  ;", "}", "METHOD_END"], "methodName": ["createCopyActionExecuter"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    getInstantiator (  )  ;", "FileResolver   fileResolver    =    getFileResolver (  )  ;", "return   instantiator . newInstance ( DefaulSpec . class ,    fileResolver ,    instantiator )  ;", "}", "METHOD_END"], "methodName": ["createRootSpec"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getDirectoryFileTreeFactory"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileLookup"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileSystem"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getInstantiator"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "return   mainSpec ;", "}", "METHOD_END"], "methodName": ["getMainSpec"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "return   rootSpec . buildRootResolver (  )  . getAllSource (  )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.api.tasks.AbstractCopyTask"}, {"methodBody": ["METHOD_START", "{", "execResult    =    execAction . execute (  )  ;", "}", "METHOD_END"], "methodName": ["exec"], "fileName": "org.gradle.api.tasks.AbstractExecTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getExecActionFactory"], "fileName": "org.gradle.api.tasks.AbstractExecTask"}, {"methodBody": ["METHOD_START", "{", "return   execResult ;", "}", "METHOD_END"], "methodName": ["getExecResult"], "fileName": "org.gradle.api.tasks.AbstractExecTask"}, {"methodBody": ["METHOD_START", "{", "return   execAction . getWorkingDir (  )  ;", "}", "METHOD_END"], "methodName": ["getWorkingDir"], "fileName": "org.gradle.api.tasks.AbstractExecTask"}, {"methodBody": ["METHOD_START", "{", "this . execAction    =    execAction ;", "}", "METHOD_END"], "methodName": ["setExecAction"], "fileName": "org.gradle.api.tasks.AbstractExecTask"}, {"methodBody": ["METHOD_START", "{", "return   getRootSpec (  )  . getDestinationDir (  )  ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.tasks.Copy"}, {"methodBody": ["METHOD_START", "{", "into ( destinationDir )  ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.api.tasks.Copy"}, {"methodBody": ["METHOD_START", "{", "Deleter   deleter    =    new   Deleter ( getFileResolver (  )  ,    getFileSystem (  )  )  ;", "final   boolean   innerFollowSymLinks    =    followSymlinks ;", "final   Object [  ]    paths    =    delete . toArray (  )  ;", "setDidWork ( deleter . delete ( new   Action < DeleteSpec >  (  )     {", "@ Override", "public   void   execute ( DeleteSpec   deleteSpec )     {", "deleteSpec . delete ( paths )  . setFollowSymlinks ( innerFollowSymLinks )  ;", "}", "}  )  . getDidWork (  )  )  ;", "}", "METHOD_END"], "methodName": ["clean"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   target    :    targets )     {", "this . d . add ( target )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "return   delete ;", "}", "METHOD_END"], "methodName": ["getDelete"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileSystem"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "return   getProject (  )  . files ( delete )  ;", "}", "METHOD_END"], "methodName": ["getTargetFiles"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "return   followSymlinks ;", "}", "METHOD_END"], "methodName": ["isFollowSymlinks"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "delete . clear (  )  ;", "this . delete . add ( target )  ;", "}", "METHOD_END"], "methodName": ["setDelete"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "this . delete    =    targets ;", "}", "METHOD_END"], "methodName": ["setDelete"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "this . followSymlinks    =    followSymlinks ;", "}", "METHOD_END"], "methodName": ["setFollowSymlinks"], "fileName": "org.gradle.api.tasks.Delete"}, {"methodBody": ["METHOD_START", "{", "BuildController   buildController    =    nestedBuildFactory . nestedBuildController ( BuildDefinition . fromStartParameter ( getStartParameter (  )  )  )  ;", "try    {", "buildController . run (  )  ;", "}    finally    {", "buildController . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "return   getStartParameter (  )  . getBuildFile (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildFile"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "return   getStartParameter (  )  . getCurrentDir (  )  ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["getStartParameter"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "return   getStartParameter (  )  . getTaskNames (  )  ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "setBuildFile (  (  ( Object )     ( file )  )  )  ;", "}", "METHOD_END"], "methodName": ["setBuildFile"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "getStartParameter (  )  . setBuildFile ( getProject (  )  . file ( file )  )  ;", "}", "METHOD_END"], "methodName": ["setBuildFile"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "setDir (  (  ( Object )     ( dir )  )  )  ;", "}", "METHOD_END"], "methodName": ["setDir"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "getStartParameter (  )  . setCurrentDir ( getProject (  )  . file ( dir )  )  ;", "}", "METHOD_END"], "methodName": ["setDir"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "this . startParameter    =    startParameter ;", "}", "METHOD_END"], "methodName": ["setStartParameter"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "getStartParameter (  )  . setTaskNames ( tasks )  ;", "}", "METHOD_END"], "methodName": ["setTasks"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "setTasks (  (  ( Collection < String >  )     ( tasks )  )  )  ;", "}", "METHOD_END"], "methodName": ["setTasks"], "fileName": "org.gradle.api.tasks.GradleBuild"}, {"methodBody": ["METHOD_START", "{", "args ( args )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "args ( args )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "bootstrapClasspath ( classpath )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bootstrapClasspath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "classpath ( paths )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["classpath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "copyTo ( options )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "copyTo ( target )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "environment ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["environment"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "environment ( environmentVariables )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["environment"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setMain ( getMain (  )  )  ;", "setJvmArgs ( getJvmArgs (  )  )  ;", "jHandleBuilder . execute (  )  ;", "}", "METHOD_END"], "methodName": ["exec"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "executable ( executable )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["executable"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getAllJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getAllJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getBootstrapClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getBootstrapClasspath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getCommandLine (  )  ;", "}", "METHOD_END"], "methodName": ["getCommandLine"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getDebug (  )  ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getDefaultCharacterEncoding (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCharacterEncoding"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getEnableAssertions (  )  ;", "}", "METHOD_END"], "methodName": ["getEnableAssertions"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getEnvironment (  )  ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getErrorOutput (  )  ;", "}", "METHOD_END"], "methodName": ["getErrorOutput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getExecActionFactory"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getExecutable (  )  ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getMain (  )  ;", "}", "METHOD_END"], "methodName": ["getMain"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getMaxHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxHeapSize"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getMinHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeapSize"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getStandardInput (  )  ;", "}", "METHOD_END"], "methodName": ["getStandardInput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getStandardOutput (  )  ;", "}", "METHOD_END"], "methodName": ["getStandardOutput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getSystemProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getSystemProperties"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   getWorkingDir (  )  ;", "}", "METHOD_END"], "methodName": ["getWorkingDir"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "return   isIgnoreExitValue (  )  ;", "}", "METHOD_END"], "methodName": ["isIgnoreExitValue"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setAllJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setAllJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setArgs ( applicationArgs )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setArgs ( applicationArgs )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setBootstrapClasspath ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setBootstrapClasspath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setClasspath ( classpath )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setDebug ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setDefaultCharacterEncoding ( defaultCharacterEncoding )  ;", "}", "METHOD_END"], "methodName": ["setDefaultCharacterEncoding"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setEnableAssertions ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setEnableAssertions"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setEnvironment ( environmentVariables )  ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setErrorOutput ( outputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setErrorOutput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setExecutable ( executable )  ;", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setExecutable ( executable )  ;", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setIgnoreExitValue ( ignoreExitValue )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIgnoreExitValue"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setMain ( mainClassName )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMain"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setMaxHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxHeapSize"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setMinHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMinHeapSize"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setStandardInput ( inputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardInput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setStandardOutput ( outputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardOutput"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setSystemProperties ( properties )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperties"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setWorkingDir ( dir )  ;", "}", "METHOD_END"], "methodName": ["setWorkingDir"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "setWorkingDir ( dir )  ;", "}", "METHOD_END"], "methodName": ["setWorkingDir"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "systemProperties ( properties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperties"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "systemProperty ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperty"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "workingDir ( dir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["workingDir"], "fileName": "org.gradle.api.tasks.JavaExec"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludeSpec )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . exclude ( excludeSpec )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["exclude"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "return   patternSet . getExcludes (  )  ;", "}", "METHOD_END"], "methodName": ["getExcludes"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "return   patternSet . getIncludes (  )  ;", "}", "METHOD_END"], "methodName": ["getIncludes"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getPatternSetFactory"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "ArrayList < Object >    copy    =    new   ArrayList < Object >  ( this . source )  ;", "FileTree   src    =    getProject (  )  . files ( copy )  . getAsFileTree (  )  ;", "return   src . matching ( patternSet )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includeSpec )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . include ( includeSpec )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . setExcludes ( excludes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["setExcludes"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "patternSet . setIncludes ( includes )  ;", "retn   this ;", "}", "METHOD_END"], "methodName": ["setIncludes"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "this . source . clear (  )  ;", "this . source . add ( source )  ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "setSource (  (  ( Object )     ( source )  )  )  ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "Collections . addAll ( this . source ,    sources )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["source"], "fileName": "org.gradle.api.tasks.SourceTask"}, {"methodBody": ["METHOD_START", "{", "return   getRootSpec (  )  . getDestinationDir (  )  ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.tasks.Sync"}, {"methodBody": ["METHOD_START", "{", "return   preserveInDestination ;", "}", "METHOD_END"], "methodName": ["getPreserve"], "fileName": "org.gradle.api.tasks.Sync"}, {"methodBody": ["METHOD_START", "{", "action . execute ( preserveInDestination )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["preserve"], "fileName": "org.gradle.api.tasks.Sync"}, {"methodBody": ["METHOD_START", "{", "into ( destinationDir )  ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.api.tasks.Sync"}, {"methodBody": ["METHOD_START", "{", "return   TaskDependencyMatchers . builtBy ( equalTo ( new   HashSet < String >  ( Arrays . asList ( tasks )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < T >  (  )     {", "public   boolean   matches ( Object   o )     {", "Buildable   task    =     (  ( Buildable )     ( o )  )  ;", "Set < String >    names    =    new   HashSet < String >  (  )  ;", "Set <  ?    extends   Task >    depTasks    =    task . getBuildies (  )  . geties ( null )  ;", "for    ( Task   depTask    :    depTasks )     {", "names . add ( depTask . getName (  )  )  ;", "}", "boolean   matches    =    matcher . matches ( names )  ;", "if    (  ! matches )     {", "StringDescription   description    =    new   StringDescription (  )  ;", "matcher . describeTo ( description )  ;", "System . out . println ( String . format (  \" expected    % s ,    got    % s .  \"  ,    description . toString (  )  ,    names )  )  ;", "}", "return   matches ;", "}", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" a   Buildable   that   is   built   by    \"  )  . appendDescriptionOf ( matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["builtBy"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   TaskDependencyMatchers . dependsOn ( equalTo ( new   HashSet < String >  ( Arrays . asList ( tasks )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["dependsOn"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   TaskDependencyMatchers . dependsOn ( matcher ,    false )  ;", "}", "METHOD_END"], "methodName": ["dependsOn"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseMatcher < Task >  (  )     {", "public   boolean   matches ( Object   o )     {", "Task   task    =     (  ( Task )     ( o )  )  ;", "Set < String >    names    =    new   HashSet < String >  (  )  ;", "Set <  ?    extends   Task >    depTasks    =    task . geties (  )  . getDependencies ( task )  ;", "for    ( Task   depTask    :    depTasks )     {", "names . add (  ( matchOnPaths    ?    depTask . getPath (  )     :    depTask . getName (  )  )  )  ;", "}", "boolean   matches    =    matcher . matches ( names )  ;", "if    (  ! matches )     {", "StringDescription   description    =    new   StringDescription (  )  ;", "matcher . describeTo ( description )  ;", "System . out . println ( String . format (  \" expected    % s ,    got    % s .  \"  ,    description . toString (  )  ,    names )  )  ;", "}", "return   matches ;", "}", "public   void   describeTo ( Description   description )     {", "description . appendText (  \" a   Task   that   depends   on    \"  )  . appendDescriptionOf ( matcher )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["dependsOn"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   TaskDependencyMatchers . dependsOn ( matcher ,    true )  ;", "}", "METHOD_END"], "methodName": ["dependsOnPaths"], "fileName": "org.gradle.api.tasks.TaskDependencyMatchers"}, {"methodBody": ["METHOD_START", "{", "return   task ;", "}", "METHOD_END"], "methodName": ["getTask"], "fileName": "org.gradle.api.tasks.TaskExecutionException"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( value ,     \" Property    '  % s '    is   not   allowed   to   have   a   null   value .  \"  ,    key )  ;", "}", "METHOD_END"], "methodName": ["checkForNullValue"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "return   comment ;", "}", "METHOD_END"], "methodName": ["getComment"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "return   encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "return   lineSeparator ;", "}", "METHOD_END"], "methodName": ["getLineSeparator"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "return   getProject (  )  . file ( outputFile )  ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    String >    propertiesBuilder    =    ImmutableMap . builder (  )  ;", "propertiesBuilder . putAll ( properties )  ;", "try    {", "for    ( Map . Entry < String ,    Callable < String >  >    e    :    deferred . entrySet (  )  )     {", "propertiesBuilder . put ( e . getKey (  )  ,    e . getValue (  )  . call (  )  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "return   propertiesBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,    Object >    e    :    properties . entrySet (  )  )     {", "property ( e . getKey (  )  ,    e . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["properties"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "WriteProperties . checkForNullValue ( name ,    value )  ;", "if    ( value   instanceof   Callable )     {", "deferredProperties . put ( name ,    new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "Object   futureValue    =     (  ( Callable )     ( value )  )  . call (  )  ;", "WriteProperties . checkForNullValue ( name ,    futureValue )  ;", "return   String . valueOf ( futureValue )  ;", "}", "}  )  ;", "} else    {", "properties . put ( name ,    String . valueOf ( value )  )  ;", "}", "}", "METHOD_END"], "methodName": ["property"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . comment    =    comment ;", "}", "METHOD_END"], "methodName": ["setComment"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . encoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . lineSeparator    =    lineSeparator ;", "}", "METHOD_END"], "methodName": ["setLineSeparator"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . outputFile    =    outputFile ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . outputFile    =    outputFile ;", "}", "METHOD_END"], "methodName": ["setOutputFile"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "this . properties . clear (  )  ;", "properties ( properties )  ;", "}", "METHOD_END"], "methodName": ["setProperties"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "Charset   charset    =    Charset . forName ( getEncoding (  )  )  ;", "OutputStream   out    =    new   BufferedOutputStream ( new   FileOutputStream ( getOutputFile (  )  )  )  ;", "try    {", "propertiesToWrite    =    new    (  )  ;", "propertiesToWrite . putAll ( get (  )  )  ;", "Utils . store ( propertiesToWrite ,    out ,    getComment (  )  ,    charset ,    getLineSeparator (  )  )  ;", "}    finally    {", "IOUtils . closeQuietly ( out )  ;", "}", "}", "METHOD_END"], "methodName": ["writeProperties"], "fileName": "org.gradle.api.tasks.WriteProperties"}, {"methodBody": ["METHOD_START", "{", "File   oldBaseDir    =    target . getProject (  )  . getBaseDir (  )  ;", "target . getProject (  )  . setBaseDir ( baseDir )  ;", "try    {", "target . performTasks (  )  ;", "}    finally    {", "target . getProject (  )  . setBaseDir ( oldBaseDir )  ;", "}", "}", "METHOD_END"], "methodName": ["executeAntTarget"], "fileName": "org.gradle.api.tasks.ant.AntTarget"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.api.tasks.ant.AntTarget"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getTarget"], "fileName": "org.gradle.api.tasks.ant.AntTarget"}, {"methodBody": ["METHOD_START", "{", "this . baseDir    =    baseDir ;", "}", "METHOD_END"], "methodName": ["setBaseDir"], "fileName": "org.gradle.api.tasks.ant.AntTarget"}, {"methodBody": ["METHOD_START", "{", "this . target    =    target ;", "}", "METHOD_END"], "methodName": ["setTarget"], "fileName": "org.gradle.api.tasks.ant.AntTarget"}, {"methodBody": ["METHOD_START", "{", "antTarget . setDescription (  \" description \"  )  ;", "task . setTarget ( antTarget )  ;", "assertThat ( task . getDescription (  )  ,    equalTo (  \" description \"  )  )  ;", "antTarget . setDescription (  \" new   description \"  )  ;", "assertThat ( task . getDescription (  )  ,    equalTo (  \" new   description \"  )  )  ;", "}", "METHOD_END"], "methodName": ["delegatesDescriptionToTarget"], "fileName": "org.gradle.api.tasks.ant.AntTargetTest"}, {"methodBody": ["METHOD_START", "{", "AntTargetTest . TestTask   testTask    =    new   AntTargetTest . TestTask (  )  ;", "testTask . setProject ( antTarget . getProject (  )  )  ;", "antTarget . addTask ( testTask )  ;", "task . setTarget ( antTarget )  ;", "task . setBaseDir ( baseDir )  ;", "task . executeAntTarget (  )  ;", "assertTrue ( testTask . executed )  ;", "}", "METHOD_END"], "methodName": ["executesTargetOnExecute"], "fileName": "org.gradle.api.tasks.ant.AntTargetTest"}, {"methodBody": ["METHOD_START", "{", "antTarget . setProject ( new   Project (  )  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.api.tasks.ant.AntTargetTest"}, {"methodBody": ["METHOD_START", "{", "return   appendix ;", "}", "METHOD_END"], "methodName": ["getAppendix"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "if    (  ( customName )     !  =    null )     {", "return   customName ;", "}", "Str   name    =     ( GUtil . elvis ( getBaseName (  )  ,     \"  \"  )  )     +     ( maybe ( getBaseName (  )  ,    getAppendix (  )  )  )  ;", "name    +  =    maybe ( name ,    getVersion (  )  )  ;", "name    +  =    maybe ( name ,    getClassifier (  )  )  ;", "name    +  =     ( GUtil . isTrue ( getExtension (  )  )  )     ?     \"  .  \"     +     ( getExtension (  )  )     :     \"  \"  ;", "return   name ;", "}", "METHOD_END"], "methodName": ["getArchiveName"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( getDestinationDir (  )  ,    getArchiveName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getArchivePath"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   classifier ;", "}", "METHOD_END"], "methodName": ["getClassifier"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   destinationDir ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   extension ;", "}", "METHOD_END"], "methodName": ["getExtension"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   version ;", "}", "METHOD_END"], "methodName": ["getVersion"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   preserveFileTimestamps ;", "}", "METHOD_END"], "methodName": ["isPreserveFileTimestamps"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   reproducibleFileOrder ;", "}", "METHOD_END"], "methodName": ["isReproducibleFileOrder"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "if    ( GUtil . isTrue ( value )  )     {", "if    ( GUtil . isTrue ( prefix )  )     {", "return    \"  -  \"  . concat ( value )  ;", "} else    {", "return   value ;", "}", "}", "return    \"  \"  ;", "}", "METHOD_END"], "methodName": ["maybe"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . appendix    =    appendix ;", "}", "METHOD_END"], "methodName": ["setAppendix"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "customName    =    name ;", "}", "METHOD_END"], "methodName": ["setArchiveName"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . baseName    =    baseName ;", "}", "METHOD_END"], "methodName": ["setBaseName"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . classifier    =    classifier ;", "}", "METHOD_END"], "methodName": ["setClassifier"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . destinationDir    =    destinationDir ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . extension    =    extension ;", "}", "METHOD_END"], "methodName": ["setExtension"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . preserveFileTimestamps    =    preserveFileTimestamps ;", "}", "METHOD_END"], "methodName": ["setPreserveFileTimestamps"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . reproducibleFileOrder    =    reproducibleFileOrder ;", "}", "METHOD_END"], "methodName": ["setReproducibleFileOrder"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "this . version    =    version ;", "}", "METHOD_END"], "methodName": ["setVersion"], "fileName": "org.gradle.api.tasks.bundling.AbstractArchiveTask"}, {"methodBody": ["METHOD_START", "{", "return   defaultExtension ;", "}", "METHOD_END"], "methodName": ["getDefaultExtension"], "fileName": "org.gradle.api.tasks.bundling.Compression"}, {"methodBody": ["METHOD_START", "{", "return   supportedExtensions ;", "}", "METHOD_END"], "methodName": ["getSupportedExtensions"], "fileName": "org.gradle.api.tasks.bundling.Compression"}, {"methodBody": ["METHOD_START", "{", "return   compression ;", "}", "METHOD_END"], "methodName": ["getCompression"], "fileName": "org.gradle.api.tasks.bundling.Tar"}, {"methodBody": ["METHOD_START", "{", "switch    ( compression )     {", "ce   BZIP 2     :", "return   Bzip 2 Archiver . getCompressor (  )  ;", "ce   GZIP    :", "return   GzipArchiver . getCompressor (  )  ;", "default    :", "return   new   SimpleCompressor (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCompressor"], "fileName": "org.gradle.api.tasks.bundling.Tar"}, {"methodBody": ["METHOD_START", "{", "this . compression    =    compression ;", "}", "METHOD_END"], "methodName": ["setCompression"], "fileName": "org.gradle.api.tasks.bundling.Tar"}, {"methodBody": ["METHOD_START", "{", "switch    ( entryCompression )     {", "case   DEFLATED    :", "return   new   DefaultZipCompressor ( allowZip 6  4  ,    ZipOutputStream . DEFLATED )  ;", "case   STORED    :", "return   new   DefaultZipCompressor ( allowZip 6  4  ,    ZipOutputStream . STORED )  ;", "default    :", "throw   new   IllegalArgumentException ( Strformat (  \" Unknown   Compression   type    % s \"  ,    entryCompression )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCompressor"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "return   entryCompression ;", "}", "METHOD_END"], "methodName": ["getEntryCompression"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "return   this . metadataCharset ;", "}", "METHOD_END"], "methodName": ["getMetadataCharset"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "return   allowZip 6  4  ;", "}", "METHOD_END"], "methodName": ["isZip64"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "this . entryCompression    =    entryCompression ;", "}", "METHOD_END"], "methodName": ["setEntryCompression"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "if    ( metadataCharset    =  =    null )     {", "throw   new   InvalidUserDataException (  \" metadataCharset   must   not   be   null \"  )  ;", "}", "if    (  !  ( Charset . isSupported ( metadataCharset )  )  )     {", "throw   new   InvalidUserDataException ( Strformat (  \" Charset   for   metadataCharset    '  % s '    is   not   supported   by   your   JVM \"  ,    metadataCharset )  )  ;", "}", "this . metadataCharset    =    metadataCharset ;", "}", "METHOD_END"], "methodName": ["setMetadataCharset"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "this . allowZip 6  4     =    allowZip 6  4  ;", "}", "METHOD_END"], "methodName": ["setZip64"], "fileName": "org.gradle.api.tasks.bundling.Zip"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheKeyBuilder ( Hashing . md 5  (  )  ,    fileHasher ,    classpathHasher ,    classLoaderHierarchyHasher )  ;", "}", "METHOD_END"], "methodName": ["createCacheKeyBuilder"], "fileName": "org.gradle.cache.internal.CacheRepositoryServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheRepository ( scopeMapping ,    factory )  ;", "}", "METHOD_END"], "methodName": ["createCacheRepository"], "fileName": "org.gradle.cache.internal.CacheRepositoryServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheScopeMapping ( gradleUserHomeDir ,    projectCacheDir ,    GradleVersion . current (  )  )  ;", "}", "METHOD_END"], "methodName": ["createCacheScopeMapping"], "fileName": "org.gradle.cache.internal.CacheRepositoryServices"}, {"methodBody": ["METHOD_START", "{", "CrossBuildInMemoryCacheFactory . DefaultCrossBuildInMemoryCache < K ,    V >    cache    =    new   CrossBuildInMemoryCacheFactory . DefaultCrossBuildInMemoryCache < K ,    V >  ( new   HashMap < K ,    SoftReference < V >  >  (  )  )  ;", "listenerManager . addListener ( cache )  ;", "return   cache ;", "}", "METHOD_END"], "methodName": ["newCache"], "fileName": "org.gradle.cache.internal.CrossBuildInMemoryCacheFactory"}, {"methodBody": ["METHOD_START", "{", "CrossBuildInMemoryCacheFactory . DefaultCrossBuildInMemoryCache < Class <  ?  >  ,    V >    cache    =    new   CrossBuildInMemoryCacheFactory . DefaultCrossBuildInMemoryCache < Class <  ?  >  ,    V >  ( new   WeakHashMap < Class <  ?  >  ,    SoftReference < V >  >  (  )  )  ;", "listenerManager . addListener ( cache )  ;", "return   cache ;", "}", "METHOD_END"], "methodName": ["newClassCache"], "fileName": "org.gradle.cache.internal.CrossBuildInMemoryCacheFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( key . equalsIgnoreCase (  \" projects \"  )  )     |  |     ( key . equalsIgnoreCase (  \" tasks \"  )  )  )     |  |     (  !  ( key . matches (  \"  \\  \\ p { Alpha }  +  [  -  /  /  .  \\  \\ w ]  *  \"  )  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Unsupported   cache   key    '  % s '  .  \"  ,    key )  )  ;", "}", "File   cacheRootDir    =    getRootDirectory ( scope )  ;", "String   subDir    =    key ;", "if    ( scope   instanceof   Project )     {", "Project   project    =     (  ( Project )     ( scope )  )  ;", "subDir    =     (  (  \" projects /  \"     +     ( project . getPath (  )  . replace (  '  :  '  ,     '  _  '  )  )  )     +     \"  /  \"  )     +    key ;", "}", "if    ( scope   instanceof   Task )     {", "Task   task    =     (  ( Task )     ( scope )  )  ;", "subDir    =     (  (  \" tasks /  \"     +     ( task . getPath (  )  . replace (  '  :  '  ,     '  _  '  )  )  )     +     \"  /  \"  )     +    key ;", "}", "return   geDir ( cacheRootDir ,    versionStrategy ,    subDir )  ;", "}", "METHOD_END"], "methodName": ["getBaseDirectory"], "fileName": "org.gradle.cache.internal.DefaultCacheScopeMapping"}, {"methodBody": ["METHOD_START", "{", "if    (  ( projectCacheDir )     !  =    null )     {", "return   projectCacheDir ;", "}", "return   new   File ( rootProject . getProjectDir (  )  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["getBuildCacheDir"], "fileName": "org.gradle.cache.internal.DefaultCacheScopeMapping"}, {"methodBody": ["METHOD_START", "{", "switch    ( versionStrategy )     {", "case   CachePerVersion    :", "return   new   File ( rootDir ,     (  (  ( version . getVersion (  )  )     +     \"  /  \"  )     +    subDir )  )  ;", "case   SharedCache    :", "return   new   File ( rootDir ,    subDir )  ;", "d    :", "throw   new   IllegalArgumentException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getCacheDir"], "fileName": "org.gradle.cache.internal.DefaultCacheScopeMapping"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( cache . getBaseDir (  )  ,     (  (  (  (  \" gradle -  \"     +    identifier )     +     \"  -  \"  )     +     ( gradleVersion )  )     +     \"  . jar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["jarFile"], "fileName": "org.gradle.cache.internal.DefaultGeneratedGradleJarCache"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["maybePingOwner"], "fileName": "org.gradle.cache.internal.locklistener.NoOpFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["reservePort"], "fileName": "org.gradle.cache.internal.locklistener.NoOpFileLockContentionHandler"}, {"methodBody": ["METHOD_START", "{", "return   actionClassLoaderHashes ;", "}", "METHOD_END"], "methodName": ["getActionClassLoaderHashes"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   actionClassNames ;", "}", "METHOD_END"], "methodName": ["getActionClassNames"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   classLoaderHash ;", "}", "METHOD_END"], "methodName": ["getClassLoaderHash"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   inputHashes ;", "}", "METHOD_END"], "methodName": ["getInputHashes"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   inputPropertiesLoadedByUnknownClassLoader ;", "}", "METHOD_END"], "methodName": ["getInputPropertiesLoadedByUnknownClassLoader"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   outputPropertyNames ;", "}", "METHOD_END"], "methodName": ["getOutputPropertyNames"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "return   taskClass ;", "}", "METHOD_END"], "methodName": ["getTaskClass"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheKeyInputs"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( isRoot ( gradle )  )     |  |     ( isRootBuildSrc ( gradle )  )  )     |  |     ( isGradleBuildTaskRoot ( rootControllerRef )  )  )     {", "return   doCreateController ( serviceRegistry ,    buildCacheConfiguration ,    buildOperationExecutor ,    instantiatorFactory ,    gradle )  ;", "} else    {", "return   rootControllerRef . getForNonRootBuild (  )  ;", "}", "}", "METHOD_END"], "methodName": ["createBuildCacheController"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOutputCacheCommandFactory ( taskOutputPacker ,    taskOutputOriginFactory ,    fileSystemMirror ,    stringInterner )  ;", "}", "METHOD_END"], "methodName": ["createTaskOutputCacheCommandFactory"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "File   rootDir    =    gradleInternal . getRootProject (  )  . getRootDir (  )  ;", "return   new   TaskOutputOriginFactory ( clock ,    inetAddressFactory ,    rootDir ,    SystemProperties . getInstance (  )  . getUserName (  )  ,    OperatingSystem . current (  )  . getName (  )  ,    GradleVersion . current (  )  ,    buildInvocationScopeId )  ;", "}", "METHOD_END"], "methodName": ["createTaskOutputOriginFactory"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "return   new   GZipTaskOutputPacker ( new   TarTaskOutputPacker ( fileSystem ,    fileHasher ,    stringInterner )  )  ;", "}", "METHOD_END"], "methodName": ["createTaskResultPacker"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "StartParameter   startParameter    =    gradle . getStartParameter (  )  ;", "Path   buildIdentityPath    =    gradle . getIdentityPath (  )  ;", "File   gradleUserHomeDir    =    gradle . getGradleUserHomeDir (  )  ;", "Mode   buildCacheMode    =     ( startParameter . isEnabled (  )  )     ?    ENABLED    :    DISABLED ;", "RemoteAccessMode   remoteAccessMode    =     ( startParameter . isOffline (  )  )     ?    OFFLINE    :    ONLINE ;", "boolean   logStackTraces    =     ( startParameter . getShowStacktrace (  )  )     !  =     ( ShowStacktrace . INTERNAL _ EXCEPTIONS )  ;", "boolean   emitDebugLogging    =    startParameter . isDebugLogging (  )  ;", "return   ControllerFactory . create ( buildOperationExecutor ,    buildIdentityPath ,    gradleUserHomeDir ,    buildCacheConfiguration ,    buildCacheMode ,    remoteAccessMode ,    logStackTraces ,    emitDebugLogging ,    instantiatorFactory . inject ( serviceRegistry )  )  ;", "}", "METHOD_END"], "methodName": ["doCreateBuildCacheController"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "return    !  ( rootControllerRef . isSet (  )  )  ;", "}", "METHOD_END"], "methodName": ["isGradleBuildTaskRoot"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "return    ( gradle . getParent (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isRoot"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "return   gradle . getIdentityPath (  )  . equals ( BuildCacheTaskServices . ROOT _ BUILD _ SRC _ PATH )  ;", "}", "METHOD_END"], "methodName": ["isRootBuildSrc"], "fileName": "org.gradle.caching.internal.tasks.BuildCacheTaskServices"}, {"methodBody": ["METHOD_START", "{", "DebuggingTaskOutputCachingBuildCacheKeyBuilder . LOGGER . lifecycle (  \" Appending    {  }    to   build   cache   key :     {  }  \"  ,    name ,    value )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.gradle.caching.internal.tasks.DebuggingTaskOutputCachingBuildCacheKeyBuilder"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   GZIPInStream ( in )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createGzipInputStream"], "fileName": "org.gradle.caching.internal.tasks.GZipTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   GZIPStream ( output )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["createGzipOutputStream"], "fileName": "org.gradle.caching.internal.tasks.GZipTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "TarArchiveEntry   entry    =    new   TarArchiveEntry ( path ,    true )  ;", "entry . setSize ( size )  ;", "entry . setMode ( mode )  ;", "tar . putArchiveEntry ( entry )  ;", "}", "METHOD_END"], "methodName": ["createTarEntry"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   URLEncoder . encode ( name ,     \" utf -  8  \"  )  ;", "}    catch    ( UnsupportedEncodException   ignored )     {", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["escape"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "long   entries    =     0  ;", "for    ( ResolvedFilePropertySpec   propertySpec    :    propertySpecs )     {", "String   propertyName    =    propertySpec . getPropertyName (  )  ;", "Map < String ,    FileContentSnapshot >    outputs    =    outputSnapshots . get ( propertyName )  ;", "try    {", "entries    +  =    packProperty ( propertySpec ,    outputs ,    tarOutput )  ;", "}    catch    ( Exception   ex )     {", "throw   new   GradleException ( String . format (  \" Could   not   pack   property    '  % s '  :     % s \"  ,    propertyName ,    ex . getMessage (  )  )  ,    ex )  ;", "}", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["pack"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "writeMetadata . execute ( baos )  ;", ". createTarEntry (  . METADATA _ PATH ,    baos . size (  )  ,     (  ( UnixStat . FILE _ FLAG )     |     ( UnixStat . DEFAULT _ FILE _ PERM )  )  ,    tarOutput )  ;", "tarOutput . write ( baos . toByteArray (  )  )  ;", "tarOutput . closeArchiveEntry (  )  ;", "}", "METHOD_END"], "methodName": ["packMetadata"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "String   propertyName    =    propertySpec . getPropertyName (  )  ;", "File   root    =    propertySpec . getOutputFile (  )  ;", "if    ( root    =  =    null )     {", "return    0  ;", "}", "String   propertyPath    =     \" property -  \"     +     (  . escape ( propertyName )  )  ;", "if    ( outputSnapshots . isEmpty (  )  )     {", "storeMissingProperty ( propertyPath ,    tarOutput )  ;", "return    1  ;", "}", "switch    ( propertySpec . getOutputType (  )  )     {", "case   DIRECTORY    :", "return   storeDirectoryProperty ( propertyPath ,    root ,    outputSnapshots ,    tarOutput )  ;", "case   FILE    :", "storeFileProperty ( propertyPath ,    root ,    tarOutput )  ;", "return    1  ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["packProperty"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "TarTaskOutputPacker . createTarEntry (  ( path    +     \"  /  \"  )  ,     0  ,     (  ( UnixStat . DIR _ FLAG )     |    mode )  ,    tarOutput )  ;", "tarOutput . closeArchiveEntry (  )  ;", "}", "METHOD_END"], "methodName": ["storeDirectoryEntry"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( directory . isDirectory (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Expected    '  % s '    to   be   a   directory \"  ,    directory )  )  ;", "}", "long   entries    =     0  ;", "final   String   propertyRoot    =    propertyPath    +     \"  /  \"  ;", ". createTarEntry ( propertyRoot ,     0  ,     (  ( UnixStat . DIR _ FLAG )     |     ( UnixStat . DEFAULT _ DIR _ PERM )  )  ,    tarOutput )  ;", "tarOutput . closeArchiveEntry (  )  ;", "entries +  +  ;", "String   rootAbsolutePath    =    directory . getAbsolutePath (  )  ;", "Path   rootPath    =    directory . toPath (  )  ;", "for    ( Map . Entry < String ,    FileContentSnapshot >    entry    :    outputSnapshots . entrySet (  )  )     {", "String   absolutePath    =    entry . getKey (  )  ;", "if    ( absolutePath . equals ( rootAbsolutePath )  )     {", "continue ;", "}", "File   file    =    new   File ( absolutePath )  ;", "String   relativePath    =    rootPath . relativize ( file . toPath (  )  )  . toString (  )  ;", "String   targetPath    =    propertyRoot    +    relativePath ;", "int   mode    =    fileSystem . getUnixMode ( file )  ;", "switch    ( entry . getValue (  )  . getType (  )  )     {", "case   RegularFile    :", "storeFileEntry ( file ,    targetPath ,    file . length (  )  ,    mode ,    tarOutput )  ;", "break ;", "case   Directory    :", "storeDirectoryEntry ( targetPath ,    mode ,    tarOutput )  ;", "break ;", "case   Missing    :", "throw   new   IllegalStateException (  (  \" File   should   not   be   missing :     \"     +    file )  )  ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "entries +  +  ;", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["storeDirectoryProperty"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "TarTaskOutputPacker . createTarEntry ( path ,    size ,     (  ( UnixStat . FILE _ FLAG )     |    mode )  ,    tarOutput )  ;", "FileInputStream   input    =    new   FileInputStream ( inputFile )  ;", "try    {", "IOUtils . copyLarge ( input ,    tarOutput ,    TarTaskOutputPacker . COPY _ BUFFERS . get (  )  )  ;", "}    finally    {", "IOUtils . closeQuietly ( input )  ;", "}", "tarOutput . closeArchiveEntry (  )  ;", "}", "METHOD_END"], "methodName": ["storeFileEntry"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( file . isFile (  )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Expected    '  % s '    to   be   a   file \"  ,    file )  )  ;", "}", "storeFileEntry ( file ,    propertyPath ,    file . length (  )  ,    fileSystem . getUnixMode ( file )  ,    tar )  ;", "}", "METHOD_END"], "methodName": ["storeFileProperty"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "TarTaskOutputPacker . createTarEntry (  (  \" missing -  \"     +    propertyPath )  ,     0  ,     (  ( UnixStat . FILE _ FLAG )     |     ( UnixStat . DEFAULT _ FILE _ PERM )  )  ,    tarOutput )  ;", "tarOutput . closeArchiveEntry (  )  ;", "}", "METHOD_END"], "methodName": ["storeMissingProperty"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   URLDecoder . decode ( name ,     \" utf -  8  \"  )  ;", "}    catch    ( UnsupportedEncodException   e )     {", "throw   new   AssertionError ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["unescape"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ResolvedTaskOutputFilePropertySpec >    propertySpecsMap    =    Maps . uniqueIndex ( propertySpecs ,    new   com . google . common . base . Function < TaskFilePropertySpec ,    String >  (  )     {", "@ Override", "public   String   apply ( TaskFilePropertySpec   propertySpec )     {", "return   propertySpec . getPropertyName (  )  ;", "}", "}  )  ;", "TarArchiveEntry   tarEntry ;", "OriginTaskExecutionMetadata   originMetadata    =    null ;", "Builder < String ,    FileSnapshot >    propertyFileSnapshots    =    ImmutableListMultimap . builder (  )  ;", "long   entries    =     0  ;", "while    (  ( tarEntry    =    tarInput . getNextTarEntry (  )  )     !  =    null )     {", "+  + entries ;", "String   path    =    tarEntry . getName (  )  ;", "if    ( path . equals (  . METADATA _ PATH )  )     {", "originMetadata    =    readOriginAction . execute ( new   CloseShieldInputStream ( tarInput )  )  ;", "} else    {", "Matcher   matcher    =     . PROPERTY _ PATH . matcher ( path )  ;", "if    (  !  ( matcher . matches (  )  )  )     {", "throw   new   IllegalStateException (  (  \" Cached   result   format   error ,    invalid   contents :     \"     +    path )  )  ;", "}", "String   propertyName    =     . unescape ( matcher . group (  2  )  )  ;", "ResolvedTaskOutputFilePropertySpec   propertySpec    =    propertySpecsMap . get ( propertyName )  ;", "if    ( propertySpec    =  =    null )     {", "throw   new   IllegalStateException ( String . format (  \" No   output   property    '  % s '    registered \"  ,    propertyName )  )  ;", "}", "boolean   outputMissing    =     ( matcher . group (  1  )  )     !  =    null ;", "String   childPath    =    matcher . group (  3  )  ;", "unpackPropertyEntry ( propertySpec ,    tarInput ,    tarEntry ,    childPath ,    outputMissing ,    propertyFileSnapshots )  ;", "}", "}", "if    ( originMetadata    =  =    null )     {", "throw   new   IllegalStateException (  \" Cached   result   format   error ,    no   origin   metadata   was   found .  \"  )  ;", "}", "return   new   TaskOutputPacker . UnpackResult ( originMetadata ,    entries ,    propertyFileSnapshots . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "File   propertyRoot    =    propertySpec . getOutputFile (  )  ;", "String   propertyName    =    propertySpec . getPropertyName (  )  ;", "if    ( propertyRoot    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Optional   property   should   have   a   value :     \"     +    propertyName )  )  ;", "}", "File   outputFile ;", "boolean   isDirEntry    =    entry . isDirectory (  )  ;", "boolean   root    =    Strings . isNullOrEmpty ( childPath )  ;", "if    ( root )     {", "if    ( missing )     {", "if    (  !  ( TaskOutputPackerUtils . makeDirectory ( propertyRoot . getParentFile (  )  )  )  )     {", "if    ( propertyRoot . exists (  )  )     {", "FileUtils . forceDelete ( propertyRoot )  ;", "}", "}", "return ;", "}", "OutputType   outputType    =    propertySpec . getOutputType (  )  ;", "if    ( isDirEntry )     {", "if    ( outputType    !  =     ( OutputType . DIRECTORY )  )     {", "throw   new   IllegalStateException (  (  \" Property   should   be   an   output   directory   property :     \"     +    propertyName )  )  ;", "}", "} else    {", "if    ( outputType    =  =     ( OutputType . DIRECTORY )  )     {", "throw   new   IllegalStateException (  (  \" Property   should   be   an   output   file   property :     \"     +    propertyName )  )  ;", "}", "}", "TaskOutputPackerUtils . ensureDirectoryForProperty ( outputType ,    propertyRoot )  ;", "outputFile    =    propertyRoot ;", "} else    {", "outputFile    =    new   File ( propertyRoot ,    childPath )  ;", "}", "String   internedPath    =    stringInterner . intern ( outputFile . getAbsolutePath (  )  )  ;", "RelativePath   relativePath    =     ( root )     ?    RelativePath . parse (  (  ! isDirEntry )  ,    outputFile . getName (  )  )     :    RelativePath . parse (  (  ! isDirEntry )  ,    childPath )  ;", "if    ( isDirEntry )     {", "FileUtils . forceMkdir ( outputFile )  ;", "fileSnapshots . put ( propertyName ,    new   DirectoryFileSnapshot ( internedPath ,    relativePath ,    root )  )  ;", "} else    {", "OutputStream   output    =    new   FileOutputStream ( outputFile )  ;", "HashCode   hash ;", "try    {", "hash    =    streamHasher . hashCopy ( input ,    output )  ;", "}    finally    {", "IOUtils . closeQuietly ( output )  ;", "}", "FileHashSnapshot   contentSnapshot    =    new   FileHashSnapshot ( hash ,    outputFile . lastModified (  )  )  ;", "fileSnapshots . put ( propertyName ,    new   RegularFileSnapshot ( internedPath ,    relativePath ,    root ,    contentSnapshot )  )  ;", "}", "fileSystem . chmod ( outputFile ,     (  ( entry . getMode (  )  )     &     (  . FILE _ PERMISSION _ MASK )  )  )  ;", "}", "METHOD_END"], "methodName": ["unpackPropertyEntry"], "fileName": "org.gradle.caching.internal.tasks.TarTaskOutputPacker"}, {"methodBody": ["METHOD_START", "{", "TaskOutputCachingBuildCacheKeyBuilder   builder    =    new   DefaultTaskOutputCachingBuildCacheKeyBuilder ( task . getIdentityPath (  )  )  ;", "if    ( buildCacheDebugLogging )     {", "builder    =    new   DebuggingTaskOutputCachingBuildCacheKeyBuilder ( builder )  ;", "}", "builder . appendTaskImplementation ( execution . getTaskImplementation (  )  )  ;", "builder . appendTaskActionImplementations ( execution . getTaskActionImplementations (  )  )  ;", "SortedMap < String ,    ValueSnapshot >    inputProperties    =    execution . getInputProperties (  )  ;", "for    ( Map . Entry < String ,    ValueSnapshot >    entry    :    inputProperties . entrySet (  )  )     {", "DefaultBuildCacheHasher   newHasher    =    new   DefaultBuildCacheHasher (  )  ;", "entry . getValue (  )  . appendToHasher ( newHasher )  ;", "if    ( newHasher . isValid (  )  )     {", "HashCode   hash    =    newHasher . hash (  )  ;", "builder . appendInputPropertyHash ( entry . getKey (  )  ,    hash )  ;", "} else    {", "builder . inputPropertyLoadedByUnknownClassLoader ( entry . getKey (  )  )  ;", "}", "}", "SortedMap < String ,    FileCollectionSnapshot >    inputFilesSnapshots    =    execution . getInputFilesSnapshot (  )  ;", "for    ( Map . Entry < String ,    FileCollectionSnapshot >    entry    :    inputFilesSnapshots . entrySet (  )  )     {", "FileCollectionSnapshot   snapshot    =    entry . getValue (  )  ;", "builder . appendInputPropertyHash ( entry . getKey (  )  ,    snapshot . getHash (  )  )  ;", "}", "SortedSet < String >    outputPropertyNamesForCacheKey    =    execution . getOutputPropertyNamesForCacheKey (  )  ;", "for    ( String   cacheableOutputPropertyName    :    outputPropertyNamesForCacheKey )     {", "builder . appendOutputPropertyName ( cacheableOutputPropertyName )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "org.gradle.caching.internal.tasks.TaskCacheKeyCalculator"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOutputCacheCommandFactory . LoadCommand ( cacheKey ,    outputProperties ,    task ,    taskProperties ,    taskOutputChangesListener ,    taskArtifactState )  ;", "}", "METHOD_END"], "methodName": ["createLoad"], "fileName": "org.gradle.caching.internal.tasks.TaskOutputCacheCommandFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOutputCacheCommandFactory . StoreCommand ( cacheKey ,    outputProperties ,    outputSnapshots ,    task ,    taskExecutionTime )  ;", "}", "METHOD_END"], "methodName": ["createStore"], "fileName": "org.gradle.caching.internal.tasks.TaskOutputCacheCommandFactory"}, {"methodBody": ["METHOD_START", "{", "return   stringInterner . intern ( outputFile . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["internedAbsolutePath"], "fileName": "org.gradle.caching.internal.tasks.TaskOutputCacheCommandFactory"}, {"methodBody": ["METHOD_START", "{", "switch    ( outputType )     {", "case   DIRECTORY    :", "if    (  !  (  . makeDirectory ( specRoot )  )  )     {", "FileUtils . cleanDirectory ( specRoot )  ;", "}", "break ;", "case   FILE    :", "if    (  !  (  . makeDirectory ( specRoot . getParentFile (  )  )  )  )     {", "if    ( specRoot . exists (  )  )     {", "FileUtils . forceDelete ( specRoot )  ;", "}", "}", "break ;", "default    :", "throw   new   AssertionError (  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureDirectoryForProperty"], "fileName": "org.gradle.caching.internal.tasks.TaskOutputPackerUtils"}, {"methodBody": ["METHOD_START", "{", "if    ( output . isDirectory (  )  )     {", "return   false ;", "} else", "if    ( output . isFile (  )  )     {", "FileUtils . forceDelete ( output )  ;", "}", "FileUtils . forceMkdir ( output )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["makeDirectory"], "fileName": "org.gradle.caching.internal.tasks.TaskOutputPackerUtils"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOutputOriginReader (  )     {", "@ Override", "public   OriginTaskExecutionMetadata   execute ( InputStream   inputStream )     {", "Properties   properties    =    new   Properties (  )  ;", "try    {", "properties . load ( inputStream )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "if    (  !  ( properties . stringPropertyNames (  )  . containsAll (  . METADATA _ KEYS )  )  )     {", "throw   new   IllegalStateException (  \" Cached   result   format   error ,    corrupted   origin   metadata .  \"  )  ;", "}", ". LOGGER . info (  \" Origin   for    {  }  :     {  }  \"  ,    task ,    properties )  ;", "UniqueId   originBuildInvocationId    =    UniqueId . from ( properties . getProperty (  . BUILD _ INVOCATION _ ID _ KEY )  )  ;", "long   originalExecutionTime    =    Long . parseLong ( properties . getProperty (  . EXECUTION _ TIME _ KEY )  )  ;", "return   new   OriginTaskExecutionMetadata ( originBuildInvocationId ,    originalExecutionTime )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createReader"], "fileName": "org.gradle.caching.internal.tasks.origin.TaskOutputOriginFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskOutputOriginWriter (  )     {", "@ Override", "public   void   execute ( OutputStream   outputStream )     {", "Properties   properties    =    new   Properties (  )  ;", "properties . setProperty (  . BUILD _ INVOCATION _ ID _ KEY ,    buildInvocationScopeId . getId (  )  . asString (  )  )  ;", "properties . setProperty (  . TYPE _ KEY ,    task . getClass (  )  . getCanonicalName (  )  )  ;", "properties . setProperty (  . PATH _ KEY ,    task . getPath (  )  )  ;", "properties . setProperty (  . GRADLE _ VERSION _ KEY ,    gradleVersion . getVersion (  )  )  ;", "properties . setProperty (  . CREATION _ TIME _ KEY ,    Long . toString ( clock . getCurrentTime (  )  )  )  ;", "properties . setProperty (  . EXECUTION _ TIME _ KEY ,    Long . toString ( elapsedTime )  )  ;", "properties . setProperty (  . ROOT _ PATH _ KEY ,    rootDir . getAbsolutePath (  )  )  ;", "properties . setProperty (  . OPERATING _ SYSTEM _ KEY ,    operatingSystem )  ;", "properties . setProperty (  . HOST _ NAME _ KEY ,    inetAddressFactory . getHostname (  )  )  ;", "properties . setProperty (  . USER _ NAME _ KEY ,    userName )  ;", "try    {", "properties . store ( outputStream ,     \" Generated   origin   information \"  )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "assert    . METADATA _ KEYS . containsAll ( properties . stringPropertyNames (  )  )     :     \" Update   expected   metadata   property   list \"  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createWriter"], "fileName": "org.gradle.caching.internal.tasks.origin.TaskOutputOriginFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( any   instanceof   PluginAwareInternal )     {", "return    (  ( PluginAwareInternal )     ( any )  )  . get (  )  ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.configuration.ConfigurationTargetIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfigurationTargetIdentifier (  )     {", "@ Override", "public   ConfigurationTargetIdentifier . Type   getTargetType (  )     {", "return   ConfigurationTargetIdentifier . Type . GRADLE ;", "}", "@ Nullable", "@ Override", "public   String   getTargetPath (  )     {", "return   null ;", "}", "@ Override", "public   String   getBuildPath (  )     {", "return   gradle . getIdentityPath (  )  . getPath (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.configuration.ConfigurationTargetIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfigurationTargetIdentifier (  )     {", "@ Override", "public   ConfigurationTargetIdentifier . Type   getTargetType (  )     {", "return   ConfigurationTargetIdentifier . Type . SETTINGS ;", "}", "@ Nullable", "@ Override", "public   String   getTargetPath (  )     {", "return   null ;", "}", "@ Override", "public   String   getBuildPath (  )     {", "return   settings . getGradle (  )  . getIdentityPath (  )  . getPath (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.configuration.ConfigurationTargetIdentifier"}, {"methodBody": ["METHOD_START", "{", "return   new   ConfigurationTargetIdentifier (  )     {", "@ Override", "public   ConfigurationTargetIdentifier . Type   getTargetType (  )     {", "return   ConfigurationTargetIdentifier . Type . PROJECT ;", "}", "@ Nullable", "@ Override", "public   String   getTargetPath (  )     {", "return   project . getProjectPath (  )  . getPath (  )  ;", "}", "@ Override", "public   String   getBuildPath (  )     {", "return   project . getGradle (  )  . getIdentityPath (  )  . getPath (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.configuration.ConfigurationTargetIdentifier"}, {"methodBody": ["METHOD_START", "{", "maybeInformAboutIncubatingMode ( gradle )  ;", "if    ( gradle . getStartParameter (  )  . isConfigureOnDemand (  )  )     {", "project . configure ( gradle . getRootProject (  )  )  ;", "} else    {", "project . configureHierarchy ( gradle . getRootProject (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.configuration.DefaultBuildConfigurer"}, {"methodBody": ["METHOD_START", "{", "StartParameter   startParameter    =    gradle . getStartParameter (  )  ;", "if    (  ( startParameter . isParallelProjectExecutionEnabled (  )  )     &  &     ( startParameter . isConfigureOnDemand (  )  )  )     {", "SingleMessageLogger . incubatingFeatureUsed (  \" Parallel   execution   with      on   demand \"  )  ;", "} else", "if    ( startParameter . isParallelProjectExecutionEnabled (  )  )     {", "SingleMessageLogger . incubatingFeatureUsed (  \" Parallel   execution \"  )  ;", "} else", "if    ( startParameter . isConfigureOnDemand (  )  )     {", "SingleMessageLogger . incubatingFeatureUsed (  \" Configuration   on   demand \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeInformAboutIncubatingMode"], "fileName": "org.gradle.configuration.DefaultBuildConfigurer"}, {"methodBody": ["METHOD_START", "{", "return   importPackages ;", "}", "METHOD_END"], "methodName": ["getImportPackages"], "fileName": "org.gradle.configuration.DefaultImportsReader"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderScope   baseScope    =    gradle . getClassLoaderScope (  )  ;", "URI   uri    =    i . getResource (  )  . getLocation (  )  . getURI (  )  ;", "String   id    =     ( uri    =  =    null )     ?    idGenerator . generateId (  )  . toString (  )     :    uri . toString (  )  ;", "ClassLoaderScope   scriptScope    =    baseScope . createChild (  (  \" init -  \"     +    id )  )  ;", "ScriptHandler   scriptHandler    =    scriptHandlerFactory . create ( i ,    scriptScope )  ;", "ScriptPlugin   configurer    =    configurerFactory . create ( i ,    scriptHandler ,    scriptScope ,    baseScope ,    true )  ;", "configurer . apply ( gradle )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.configuration.DefaultInitScriptProcessor"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptPluginFactory . ScriptPluginImpl ( scriptSource ,     (  ( ScriptHandlerInternal )     ( scriptHandler )  )  ,    targetScope ,    baseScope ,    topLevelScript )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.configuration.DefaultScriptPluginFactory"}, {"methodBody": ["METHOD_START", "{", "this . scriptPluginFactory    =    scriptPluginFactory ;", "}", "METHOD_END"], "methodName": ["setScriptPluginFactory"], "fileName": "org.gradle.configuration.DefaultScriptPluginFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "output . append ( appName )  ;", "for    ( String   arg    :    args )     {", "output . append (  '     '  )  ;", "output . append ( arg )  ;", "}", "}    catch    ( IOExcepe )     {", "throw   UncheckedExcepthrowAsUncheckedExcepe )  ;", "}", "}", "METHOD_END"], "methodName": ["describeCommand"], "fileName": "org.gradle.configuration.GradleLauncherMetaData"}, {"methodBody": ["METHOD_START", "{", "return   appName ;", "}", "METHOD_END"], "methodName": ["getAppName"], "fileName": "org.gradle.configuration.GradleLauncherMetaData"}, {"methodBody": ["METHOD_START", "{", "return   new   ScriptPluginFactorySelector . ProviderInstantiator (  )     {", "@ Override", "public   ScriptPluginFactory   instantiate ( String   providerClassName )     {", "Class <  ?  >    providerClass    =    loadProviderClass ( providerClassName )  ;", "return    (  ( ScriptPluginFactory )     ( instantiator . newInstance ( providerClass )  )  )  ;", "}", "private   Class <  ?  >    loadProviderClass ( String   providerClassName )     {", "try    {", "return   getClass (  )  . getClassLoader (  )  . loadClass ( providerClassName )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["defaultProviderInstantiatorFor"], "fileName": "org.gradle.configuration.ScriptPluginFactorySelector"}, {"methodBody": ["METHOD_START", "{", "return   providerInstantiator . instantiate ( provider )  ;", "}", "METHOD_END"], "methodName": ["instantiate"], "fileName": "org.gradle.configuration.ScriptPluginFactorySelector"}, {"methodBody": ["METHOD_START", "{", "for    ( ScriptingLanguage   scriptingLanguage    :    scriptingLanguages (  )  )     {", "if    ( fileName . endsWith ( scriptingLanguage . getExtension (  )  )  )     {", "String   provider    =    scriptingLanguage . getProvider (  )  ;", "if    ( provider    !  =    null )     {", "return   instantiate ( provider )  ;", "}", "return   default ;", "}", "}", "return   default ;", "}", "METHOD_END"], "methodName": ["scriptPluginFactoryFor"], "fileName": "org.gradle.configuration.ScriptPluginFactorySelector"}, {"methodBody": ["METHOD_START", "{", "return   ScriptingLanguages . all (  )  ;", "}", "METHOD_END"], "methodName": ["scriptingLanguages"], "fileName": "org.gradle.configuration.ScriptPluginFactorySelector"}, {"methodBody": ["METHOD_START", "{", "if    ( BuildScriptProcessor . LOGGER . isInfoEnabled (  )  )     {", "BuildScriptProcessor . LOGGER . info (  \" Evaluating    {  }    using    {  }  .  \"  ,    project ,    project . getBuildScriptSource (  )  . getDisplayName (  )  )  ;", "}", "final   Timer   clock    =    Time . startTimer (  )  ;", "try    {", "ScriptPlugin   configurer    =    configurerFactory . create ( project . getBuildScriptSource (  )  ,    project . getBuildscript (  )  ,    project . getClassLoaderScope (  )  ,    project . getBaseClassLoaderScope (  )  ,    true )  ;", "configurer . apply ( project )  ;", "}    finally    {", "if    ( BuildScriptProcessor . LOGGER . isDebugEnabled (  )  )     {", "BuildScriptProcessor . LOGGER . debug (  \" Timing :    Running   the   build   script   took    {  }  \"  ,    clock . getElapsed (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.configuration.project.BuildScriptProcessor"}, {"methodBody": ["METHOD_START", "{", "for    ( ProjectConfigureAction   configureAction    :    configureActions )     {", "configureAction . execute ( project )  ;", "}", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.gradle.configuration.project.ConfigureActionsProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "add ( ConfigureUtil . configureUsing ( action )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.configuration.project.DefaultProjectConfigurationActionContainer"}, {"methodBody": ["METHOD_START", "{", "actions . add ( action )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.configuration.project.DefaultProjectConfigurationActionContainer"}, {"methodBody": ["METHOD_START", "{", "actions . clear (  )  ;", "}", "METHOD_END"], "methodName": ["finished"], "fileName": "org.gradle.configuration.project.DefaultProjectConfigurationActionContainer"}, {"methodBody": ["METHOD_START", "{", "return   actions ;", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "org.gradle.configuration.project.DefaultProjectConfigurationActionContainer"}, {"methodBody": ["METHOD_START", "{", "ProjectConfigurationActionContainer   actions    =    projectInternal . getConfigurationActions (  )  ;", "try    {", "for    ( Action <  ?    super   ProjectInternal >    action    :    actions . getActions (  )  )     {", "action . execute ( projectInternal )  ;", "}", "}    finally    {", "actions . finished (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.configuration.project.DelayedConfigurationActions"}, {"methodBody": ["METHOD_START", "{", "ProjectConfigurationException   failure    =    new   ProjectConfigurationException ( String . format (  \" A   problem   occurred   configuring    % s .  \"  ,    project . getDisplayName (  )  )  ,    e )  ;", "state . executed ( failure )  ;", "}", "METHOD_END"], "methodName": ["addConfigurationFailure"], "fileName": "org.gradle.configuration.project.LifecycleProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "ProjectEvaluationListener   listener    =    project . getProjectEvaluationBroadcaster (  )  ;", "try    {", "listener . beforeEvaluate ( project )  ;", "}    catch    ( Exception   e )     {", "addConfigurationFailure ( project ,    state ,    e )  ;", "return ;", "}", "state . setExecuting ( true )  ;", "try    {", "delegate . evaluate ( project ,    state )  ;", "}    catch    ( Exception   e )     {", "addConfigurationFailure ( project ,    state ,    e )  ;", "}    finally    {", "state . setExecuting ( false )  ;", "state . executed (  )  ;", "notifyAfterEvaluate ( listener ,    project ,    state )  ;", "}", "}", "METHOD_END"], "methodName": ["doConfigure"], "fileName": "org.gradle.configuration.project.LifecycleProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state . getExecuted (  )  )     |  |     ( state . getExecuting (  )  )  )     {", "return ;", "}", "buildOperationExecutor . run ( new    . ConfigureProject ( project ,    state )  )  ;", "}", "METHOD_END"], "methodName": ["evaluate"], "fileName": "org.gradle.configuration.project.LifecycleProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "try    {", "listener . afterEvaluate ( project ,    state )  ;", "}    catch    ( Exception   e )     {", "if    ( state . hasFailure (  )  )     {", "boolean   logStackTraces    =     ( project . getGradle (  )  . getStartParameter (  )  . getShowStacktrace (  )  )     !  =     ( ShowStacktrace . INTERNAL _ EXCEPTIONS )  ;", "String   infoMessage    =     \" Project   evaluation   failed   including   an   error   in   afterEvaluate    {  }  .  \"  ;", "if    ( logStackTraces )     {", ". LOGGER . error ( infoMessage ,    e )  ;", "} else    {", ". LOGGER . error (  ( infoMessage    +     \"    Run   with    -  - stacktrace   for   details   of   the   afterEvaluate    {  }    error .  \"  )  )  ;", "}", "return ;", "}", "addConfigurationFailure ( project ,    state ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["notifyAfterEvaluate"], "fileName": "org.gradle.configuration.project.LifecycleProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "for    ( Action < ProjectInternal >    action    :    actions )     {", "action . execute ( project )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.configuration.project.PluginsProjectConfigureActions"}, {"methodBody": ["METHOD_START", "{", "return   PluginsProjectConfigureActions . of ( ProjectConfigureAction . class ,    serviceLocator )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.gradle.configuration.project.PluginsProjectConfigureActions"}, {"methodBody": ["METHOD_START", "{", "return   new   PluginsProjectConfigureActions ( ImmutableList .  < Action < ProjectInternal >  > copyOf ( serviceLocator . getAll ( serviceType )  )  )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.configuration.project.PluginsProjectConfigureActions"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "pendingChanges . changesIncorporated (  )  ;", "if    (  !  ( pendingChanges . hasRemainingChanges (  )  )  )     {", "Throwable   failure    =    buildResult . getFailure (  )  ;", "for    ( RegisteredDeployment    :     . values (  )  )     {", "upToDate ( failure )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.deployment.internal.DefaultDeploymentRegistry"}, {"methodBody": ["METHOD_START", "{", "if    ( stopped )     {", "throw   new   IllegalStateException (  \" Cannot   modify      handles   once   the   registry   has   been   stopped .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["failIfStopped"], "fileName": "org.gradle.deployment.internal.DefaultDeploymentRegistry"}, {"methodBody": ["METHOD_START", "{", "switch    ( changeBehavior )     {", "case   NONE    :", "return   new    ( id ,    false ,    deploymentHandle ,    new   OutOfDateTrackingDeployment (  )  )  ;", "case   RESTART    :", "return   new    ( id ,    true ,    deploymentHandle ,    new   SimpleBlockingDeployment ( new   OutOfDateTrackingDeployment (  )  )  )  ;", "case   BLOCK    :", "return   new    ( id ,    false ,    deploymentHandle ,    new   GateControllingDeployment ( continuousExecutionGate ,    new   SimpleBlockingDeployment ( new   OutOfDateTrackingDeployment (  )  )  )  )  ;", "default    :", "throw   new   IllegalArgumentException (  (  \" Unknown   changeBehavior    \"     +    changeBehavior )  )  ;", "}", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "return   delegate ;", "}", "METHOD_END"], "methodName": ["getDeployment"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "return   handle ;", "}", "METHOD_END"], "methodName": ["getHandle"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "delegate . outOfDate (  )  ;", "}", "METHOD_END"], "methodName": ["outOfDate"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "if    ( restartable )     {", "hanstop (  )  ;", "hanstart ( delegate )  ;", "}", "}", "METHOD_END"], "methodName": ["restart"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "delegate . upToDate ( failure )  ;", "restart (  )  ;", "}", "METHOD_END"], "methodName": ["upToDate"], "fileName": "org.gradle.deployment.internal.RegisteredDeployment"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( processingConfigurationActions . size (  )  )  )     {", "return ;", "}", "processingConfigurationActions . get ( index )  . configure ( new   BuildExecutionContext (  )     {", "public   GradleInternal   getGradle (  )     {", "return   gradle ;", "}", "public   void   proceed (  )     {", "configure ( processingConfigurationActions ,    gradle ,     ( index    +     1  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.execution.DefaultBuildConfigurationActionExecuter"}, {"methodBody": ["METHOD_START", "{", "List < BuildConfigurationAction >    processingBuildActions    =    CollectionUtils . flattenCollections ( BuildConfigurationAction . class ,    configurationActions ,    taskSelectors )  ;", "configure ( processingBuildActions ,    gradle ,     0  )  ;", "}", "METHOD_END"], "methodName": ["select"], "fileName": "org.gradle.execution.DefaultBuildConfigurationActionExecuter"}, {"methodBody": ["METHOD_START", "{", "execute ( gradle ,     0  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.DefaultBuildExecuter"}, {"methodBody": ["METHOD_START", "{", "if    ( index    >  =     ( executionActions . size (  )  )  )     {", "return ;", "}", "executionActions . get ( index )  . execute ( new   ionContext (  )     {", "public   GradleInternal   getGradle (  )     {", "return   gradle ;", "}", "public   void   proceed (  )     {", "execute ( gradle ,     ( index    +     1  )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.DefaultBuildExecuter"}, {"methodBody": ["METHOD_START", "{", "return    ( c    =  =     ( DefaultCancellableOperationManager . KEY _ CODE _ CTRL _ D )  )     |  |     ( c    =  =     ( DefaultCancellableOperationManager . EOF )  )  ;", "}", "METHOD_END"], "methodName": ["isCancellation"], "fileName": "org.gradle.execution.DefaultCancellableOperationManager"}, {"methodBody": ["METHOD_START", "{", "StartParameter   startParameter    =    context . getGradle (  )  . getStartParameter (  )  ;", "for    ( TaskExecutionRequest   request    :    startParameter . getTaskRequests (  )  )     {", "if    (  !  ( request . getArgs (  )  . isEmpty (  )  )  )     {", "context . proceed (  )  ;", "return ;", "}", "}", "ProjectInternal   project    =    context . getGradle (  )  . getDefaultProject (  )  ;", "projectConfigurer . configure ( project )  ;", "List < String >    defaultTasks    =    project . getDefaultTasks (  )  ;", "if    (  ( defaultTasks . size (  )  )     =  =     0  )     {", "defaultTasks    =    Collections . singletonList ( ProjectInternal . HELP _ TASK )  ;", ". LOGGER . info (  \" No   tasks   specified .    Using   default   task    {  }  \"  ,    GUtil . toString ( defaultTasks )  )  ;", "} else    {", ". LOGGER . info (  \" No   tasks   specified .    Using   project   default   tasks    {  }  \"  ,    GUtil . toString ( defaultTasks )  )  ;", "}", "startParameter . setTaskNames ( defaultTasks )  ;", "context . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.execution.DefaultTasksBuildExecutionAction"}, {"methodBody": ["METHOD_START", "{", "GradleInternal   gradle    =    context . getGradle (  )  ;", "if    ( gradle . getStartParameter (  )  . isDryRun (  )  )     {", "for    ( Task   task    :    gradle . getTaskGraph (  )  . getAllTasks (  )  )     {", "textOutputFactory . create (  . class )  . append (  (  ( TaskInternal )     ( task )  )  . getIdentityPath (  )  . getPath (  )  )  . append (  \"     \"  )  . style ( ProgressStatus )  . append (  \" SKIPPED \"  )  . println (  )  ;", "}", "} else    {", "context . proceed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.DryRunBuildExecutionAction"}, {"methodBody": ["METHOD_START", "{", "GradleInternal   gradle    =    context . getGradle (  )  ;", "Set < String >    excludedTaskNames    =    gradle . getStartParameter (  )  . getNames (  )  ;", "if    (  !  ( excludedTaskNames . isEmpty (  )  )  )     {", "final   Set < Spec < Task >  >    filters    =    new   HashSet < Spec < Task >  >  (  )  ;", "for    ( String   taskName    :    excludedTaskNames )     {", "filters . add ( taskSelector . getFilter ( taskName )  )  ;", "}", "gradle . getTaskGraph (  )  . useFilter ( Specs . intersect ( filters )  )  ;", "}", "context . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.execution.ExcludedTaskFilteringBuildConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "super . initCauses ( causes )  ;", "}", "METHOD_END"], "methodName": ["replaceCauses"], "fileName": "org.gradle.execution.MultipleBuildFailures"}, {"methodBody": ["METHOD_START", "{", "return   guard . guardByKey ( project ,    factory )  ;", "}", "METHOD_END"], "methodName": ["withProjectState"], "fileName": "org.gradle.execution.ProjectStateAccess"}, {"methodBody": ["METHOD_START", "{", "GradleInternal   gradle    =    context . getGradle (  )  ;", "TaskGraphExecuter   taskGraph    =    gradle . getTaskGraph (  )  ;", "if    ( gradle . getStartParameter (  )  . isContinueOnFailure (  )  )     {", "taskGraph . useFailureHandler ( new    . ContinueOnFailureHandler (  )  )  ;", "}", "taskGraph . addTaskExecutionGraphListener ( new    . BindAllReferencesOfProjectsToExecuteListener (  )  )  ;", "taskGraph . execute (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.SelectedTaskExecutionAction"}, {"methodBody": ["METHOD_START", "{", "TaskNameResolver . discoverTasks ( project )  ;", "result . addAll ( TaskNameResolver . getTaskNames ( project )  )  ;", "for    ( Project   subProject    :    project . getChildProjects (  )  . values (  )  )     {", "collectTaskNames (  (  ( ProjectInternal )     ( subProject )  )  ,    result )  ;", "}", "}", "METHOD_END"], "methodName": ["collectTaskNames"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "project . gets (  )  . discovers (  )  ;", "}    catch    ( Throwable   e )     {", "throw   new   ProjectConfigurationException ( String . format (  \" A   problem   occurred   configuring    % s .  \"  ,    project )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["discoverTasks"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( TaskInternal )     ( project . getTasks (  )  . getByName ( t )  )  )  ;", "}    catch    ( Throwable   e )     {", "throw   new   ProjectConfigurationException ( String . format (  \" A   problem   occurred   configuring    % s .  \"  ,    project )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getExistingTask"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "return   project . getTasks (  )  . getNames (  )  ;", "}", "METHOD_END"], "methodName": ["getTaskNames"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "return    ( project . getTasks (  )  . getNames (  )  . contains ( taskName )  )     |  |     (  ( project . getTasks (  )  . findByName ( taskName )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["hasTask"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TaskSelectionResult >    selected    =    Maps . newLinkedHashMap (  )  ;", "if    ( includeSubProjects )     {", "Set < String >    taskNames    =    Sets . newLinkedHashSet (  )  ;", "collectTaskNames ( project ,    taskNames )  ;", "for    ( String   taskName    :    taskNames )     {", "selected . put ( taskName ,    new    . MultiProjectTaskSelectionResult ( taskName ,    project ,    true )  )  ;", "}", "} else    {", ". discoverTasks ( project )  ;", "for    ( String   taskName    :     . getTaskNames ( project )  )     {", "selected . put ( taskName ,    new    . SingleProjectTaskSelectionResult ( taskName ,    project . getTasks (  )  )  )  ;", "}", "}", "return   selected ;", "}", "METHOD_END"], "methodName": ["selectAll"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "if    ( includeSubProjects )     {", "Set < Task >    tasks    =    Sets . newLinkedHashSet (  )  ;", "new    . MultiProjectTaskSelectionResult ( taskName ,    project ,    false )  . collectTasks ( tasks )  ;", "if    (  !  ( tasks . isEmpty (  )  )  )     {", "return   new    . FixedTaskSelectionResult ( tasks )  ;", "}", "} else    {", ". discoverTasks ( project )  ;", "if    (  . hasTask ( taskName ,    project )  )     {", "return   new   TaskSelectionResult (  )     {", "@ Override", "public   void   collectTasks ( Collection <  ?    super   Task >    tasks )     {", "tasks . add (  . getExistingTask ( project ,    taskName )  )  ;", "}", "}  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["selectWithName"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "for    ( Project   project 1     :    project . getAllprojects (  )  )     {", "if    ( project 1  . gets (  )  . getNames (  )  . contains ( name )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["tryFindUnqualifiedTaskCheaply"], "fileName": "org.gradle.execution.TaskNameResolver"}, {"methodBody": ["METHOD_START", "{", "GradleInternal   gradle    =    context . getGradle (  )  ;", "TaskGraphExecuter   executer    =    gradle . getTaskGraph (  )  ;", "List < TaskExecutionRequest >    taskParameters    =    gradle . getStartParameter (  )  . getTaskRequests (  )  ;", "for    ( TaskExecutionRequest   taskParameter    :    taskParameters )     {", "List < TaskSelector . TaskSelection >    taskSelections    =    commandLineTaskParser . parseTasks ( taskParameter )  ;", "for    ( TaskSelector . TaskSelection   taskSelection    :    taskSelections )     {", ". LOGGER . info (  \" Selected   primary   task    '  {  }  '    from   project    {  }  \"  ,    taskSelection . getTaskName (  )  ,    taskSelection . getProjectPath (  )  )  ;", "executer . addTasks ( taskSelection . getTasks (  )  )  ;", "}", "}", "context . proceed (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.execution.TaskNameResolvingBuildConfigurationAction"}, {"methodBody": ["METHOD_START", "{", "if    ( cancellationToken . isCancellationRequested (  )  )     {", "throw   new   BuildCancelledException (  )  ;", "}", "p . bindAllModelRules (  )  ;", "}", "METHOD_END"], "methodName": ["bindAllModelRules"], "fileName": "org.gradle.execution.TaskPathProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "if    ( cancellationToken . isCancellationRequested (  )  )     {", "throw   new   BuildCancelledException (  )  ;", "}", "p . evaluate (  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.execution.TaskPathProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "configure ( project )  ;", "for    (    sub    :    project . getSubprojects (  )  )     {", "configure (  (  ( Internal )     ( sub )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["configureHierarchy"], "fileName": "org.gradle.execution.TaskPathProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "if    ( cancellationToken . isCancellationRequested (  )  )     {", "throw   new   BuildCancelledException (  )  ;", "}", "p . getTasks (  )  . discoverTasks (  )  ;", "}", "METHOD_END"], "methodName": ["discoverTasks"], "fileName": "org.gradle.execution.TaskPathProjectEvaluator"}, {"methodBody": ["METHOD_START", "{", "output . text (  \" Run    \"  )  ;", "clientMetaData . describeCommand ( output . withStyStyUserInput )  ,    ProjectInternal . TASKS _ TASK )  ;", "output . text (  \"    to   get   a   list   of   availabtasks .  \"  )  ;", "}", "METHOD_END"], "methodName": ["appendResolution"], "fileName": "org.gradle.execution.TaskSelectionException"}, {"methodBody": ["METHOD_START", "{", "Set < File >    includedRoots    =    new   HashSet < File >  (  )  ;", "for    ( IncludedBuild   includedBuild    :    gradle . getIncludedBuilds (  )  )     {", "includedRoots . add ( includedBuild . getProjectDir (  )  )  ;", "}", "if    ( includedRoots . contains ( root )  )     {", "throw   new   ionException (  \" Can ' t   launch   tasks   from   included   builds \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["ensureNotFromIncludedBuild"], "fileName": "org.gradle.execution.TaskSelector"}, {"methodBody": ["METHOD_START", "{", "final   ResolvedTaskPath   taskPath    =    taskPathResolver . resolvePath ( path ,    gradle . getDefaultProject (  )  )  ;", "if    (  !  ( taskPath . isQualified (  )  )  )     {", "ProjectInternal   targetProject    =    taskPath . getProject (  )  ;", "configurer . configure ( targetProject )  ;", "if    ( taskNameResolver . tryFindUnqualifiedTaskCheaply ( taskPath . getTaskName (  )  ,    taskPath . getProject (  )  )  )     {", "return   new    . TaskPathSpec ( targetProject ,    taskPath . getTaskName (  )  )  ;", "}", "}", "final   Set < Task >    selectedTasks    =    getSelection ( path ,    gradle . getDefaultProject (  )  )  . getTasks (  )  ;", "return   new   Spec < Task >  (  )     {", "public   boolean   isSatisfiedBy ( Task   element )     {", "return    !  ( selectedTasks . contains ( element )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getFilter"], "fileName": "org.gradle.execution.TaskSelector"}, {"methodBody": ["METHOD_START", "{", "return   getSelection ( path ,    gradle . getDefaultProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "org.gradle.execution.TaskSelector"}, {"methodBody": ["METHOD_START", "{", "if    ( root    !  =    null )     {", "ensureNotFromIncludedBuild ( root )  ;", "}", "ProjectInternal   project    =     ( projectPath    !  =    null )     ?    getRootProject (  )  . findProject ( projectPath )     :    getDefaultProject (  )  ;", "return   getSelection ( path ,    project )  ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "org.gradle.execution.TaskSelector"}, {"methodBody": ["METHOD_START", "{", "ResolvedTaskPath   taskPath    =    taskPathResolver . resolvePath ( path ,    project )  ;", "ProjectInternal   targetProject    =    taskPath . getProject (  )  ;", "if    ( taskPath . isQualified (  )  )     {", "configurer . configure ( targetProject )  ;", "} else    {", "configurer . configureHierarchy ( targetProject )  ;", "}", "TaskSelectionResult   tasks    =    taskNameResolver . selectWithName ( taskPath . getTaskName (  )  ,    taskPath . getProject (  )  ,     (  !  ( taskPath . isQualified (  )  )  )  )  ;", "if    ( tasks    !  =    null )     {", "return   new    . TaskSelection ( taskPath . getProject (  )  . getPath (  )  ,    path ,    tasks )  ;", "}", "Map < String ,    TaskSelectionResult >    tasksByName    =    taskNameResolver . selectAll ( taskPath . getProject (  )  ,     (  !  ( taskPath . isQualified (  )  )  )  )  ;", "NameMatcher   matcher    =    new   NameMatcher (  )  ;", "String   actualName    =    matcher . find ( taskPath . getTaskName (  )  ,    tasksByName . keySet (  )  )  ;", "if    ( actualName    !  =    null )     {", "return   new    . TaskSelection ( taskPath . getProject (  )  . getPath (  )  ,     (  ( taskPath . getPrefix (  )  )     +    actualName )  ,    tasksByName . get ( actualName )  )  ;", "}", "throw   new   TaskSelectionException ( matcher . formatErrorMessage (  \" task \"  ,    taskPath . getProject (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "org.gradle.execution.TaskSelector"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( tasks . isEmpty (  )  )  ;", "if    ( arguments . isEmpty (  )  )     {", "return   arguments ;", "}", "return   cTasksNow ( tasks ,    arguments )  ;", "}", "METHOD_END"], "methodName": ["configureTasks"], "fileName": "org.gradle.execution.commandline.CommandLineTaskConfigurer"}, {"methodBody": ["METHOD_START", "{", "List < String >    remainingArguments    =    null ;", "for    ( Task   task    :    tasks )     {", "CommandLineParser   parser    =    new   CommandLineParser (  )  ;", "final   List < OptionDescriptor >    commandLineOptions    =    optionReader . getOptions ( task )  ;", "for    ( OptionDescriptor   optionDescriptor    :    commandLineOptions )     {", "String   optionName    =    optionDescriptor . getName (  )  ;", "CommandLineOption   option    =    parser . option ( optionName )  ;", "option . hasDescription ( optionDescriptor . getDescription (  )  )  ;", "option . hasArgument ( optionDescriptor . getArgumentType (  )  )  ;", "}", "ParsedCommandLine   parsed ;", "try    {", "parsed    =    parser . parse ( arguments )  ;", "}    catch    ( CommandLineArgumentException   e )     {", "throw   new   ationException ( task . getPath (  )  ,     (  (  \" Problem   configuring   task    \"     +     ( task . getPath (  )  )  )     +     \"    from   command   line .  \"  )  ,    e )  ;", "}", "for    ( OptionDescriptor   commandLineOptionDescriptor    :    commandLineOptions )     {", "final   String   name    =    commandLineOptionDescriptor . getName (  )  ;", "if    ( parsed . hasOption ( name )  )     {", "ParsedCommandLineOption   o    =    parsed . option ( name )  ;", "try    {", "commandLineOptionDescriptor . apply ( task ,    o . getValues (  )  )  ;", "}    catch    ( TypeConversionException   ex )     {", "throw   new   ationException ( task . getPath (  )  ,    String . format (  \" Problem   configuring   option    '  % s '    on   task    '  % s '    from   command   line .  \"  ,    name ,    task . getPath (  )  )  ,    ex )  ;", "}", "}", "}", "assert    ( remainingArguments    =  =    null )     |  |     ( remainingArguments . equals ( parsed . getExtraArguments (  )  )  )     :     \" we   expect   all   options   to   be   consumed   by   each   task   so   remainingArguments   should   be   the   same   for   each   task \"  ;", "remainingArguments    =    parsed . getExtraArguments (  )  ;", "}", "return   remainingArguments ;", "}", "METHOD_END"], "methodName": ["configureTasksNow"], "fileName": "org.gradle.execution.commandline.CommandLineTaskConfigurer"}, {"methodBody": ["METHOD_START", "{", "List < TaskSelector . TaskSelection >    out    =    Lists . newArrayList (  )  ;", "List < String >    remainingPaths    =    new   LinkedList < String >  ( taskERequest . getArgs (  )  )  ;", "while    (  !  ( remainingPaths . isEmpty (  )  )  )     {", "String   path    =    remainingPaths . remove (  0  )  ;", "TaskSelector . TaskSelection   selection    =    taskSelector . getSelection ( taskERequest . getProjectPath (  )  ,    taskERequest . getRootDir (  )  ,    path )  ;", "Set < Task >    tasks    =    selection . getTasks (  )  ;", "remainingPaths    =    taskConfigurer . configureTasks ( tasks ,    remainingPaths )  ;", "out . add ( selection )  ;", "}", "return   out ;", "}", "METHOD_END"], "methodName": ["parseTasks"], "fileName": "org.gradle.execution.commandline.CommandLineTaskParser"}, {"methodBody": ["METHOD_START", "{", "output . text (  \" Run    \"  )  ;", "clientMetaData . describeC ( output . withStyle ( Style . UserInput )  ,    ProjectInternal . HELP _ TASK )  ;", "output . withStyle ( Style . UserInput )  . format (  \"     -  - task    % s \"  ,    taskPath )  ;", "output . text (  \"    to   get   task   usage   details .  \"  )  ;", "}", "METHOD_END"], "methodName": ["appendResolution"], "fileName": "org.gradle.execution.commandline.TaskConfigurationException"}, {"methodBody": ["METHOD_START", "{", "abortExecution ( true )  ;", "this . failureCollector . addFailure ( t )  ;", "}", "METHOD_END"], "methodName": ["abortAllAndFail"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "return   abortExecution ( false )  ;", "}", "METHOD_END"], "methodName": ["abortExecution"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "boolean   aborted    =    false ;", "for    ( TaskInfo   taskInfo    :    e . values (  )  )     {", "if    ( taskInfo . isRequired (  )  )     {", "taskInfo . skipExecution (  )  ;", "aborted    =    true ;", "}", "if    ( abortAll    &  &     ( taskInfo . isReady (  )  )  )     {", "taskInfo . abortExecution (  )  ;", "aborted    =    true ;", "}", "}", "return   aborted ;", "}", "METHOD_END"], "methodName": ["abortExecution"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "List < T >    elements    =    CollectionUtils . toList ( set )  ;", "Collections . reverse ( elements )  ;", "list . addAll ( elements )  ;", "}", "METHOD_END"], "methodName": ["addAllReversed"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "addAllReversed ( dependsOnTasks ,    taskNode . getDependencySuccessors (  )  )  ;", "addAllReversed ( dependsOnTasks ,    taskNode . getMustSuccessors (  )  )  ;", "addAllReversed ( dependsOnTasks ,    taskNode . getShouldSuccessors (  )  )  ;", "}", "METHOD_END"], "methodName": ["addAllSuccessorsInReverseOrder"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    ( filter . isSatisfiedBy ( finalizerNode . getTask (  )  )  )     {", "node . addFinalizer ( finalizerNode )  ;", "if    (  !  ( finalizerNode . isInKnownState (  )  )  )     {", "finalizerNode . mustNotRun (  )  ;", "}", "finalizerNode . addMustSuccessor ( node )  ;", "}", "}", "METHOD_END"], "methodName": ["addFinalizerNode"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "List < TaskInfo >    queue    =    new   ArrayList < TaskInfo >  (  )  ;", "List < Task >    sortedTasks    =    new   ArrayList < Task >  ( tasks )  ;", "Collections . sort ( sortedTasks )  ;", "for    ( Task   task    :    sortedTasks )     {", "TaskInfo   node    =    nodeFactory . createNode ( task )  ;", "if    ( node . isMustNotRun (  )  )     {", "requireWithDependencies ( node )  ;", "} else", "if    ( filter . isSatisfiedBy ( task )  )     {", "node . require (  )  ;", "}", "entryTasks . add ( node )  ;", "queue . add ( node )  ;", "}", "Set < TaskInfo >    visiting    =    new   HashSet < TaskInfo >  (  )  ;", "CachingTaskDependencyResolveContext   context    =    new   CachingTaskDependencyResolveContext (  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "TaskInfo   node    =    queue . get (  0  )  ;", "if    ( node . getDependenciesProcessed (  )  )     {", "queue . remove (  0  )  ;", "continue ;", "}", "TaskInternal   task    =    node . getTask (  )  ;", "boolean   filtered    =     !  ( filter . isSatisfiedBy ( task )  )  ;", "if    ( filtered )     {", "queue . remove (  0  )  ;", "node . dependenciesProcessed (  )  ;", "node . doNotRequire (  )  ;", "filteredTasks . add ( task )  ;", "continue ;", "}", "if    ( visiting . add ( node )  )     {", "(  ( TaskContainerInternal )     ( task . getProject (  )  . getTasks (  )  )  )  . prepareFor ( task )  ;", "Set <  ?    extends   Task >    dependsOnTasks    =    context . getDependencies ( task ,    task . getTaskDependencies (  )  )  ;", "for    ( Task   dependsOnTask    :    dependsOnTasks )     {", "TaskInfo   targetNode    =    nodeFactory . createNode ( dependsOnTask )  ;", "node . addDependencySuccessor ( targetNode )  ;", "if    (  !  ( visiting . contains ( targetNode )  )  )     {", "queue . add (  0  ,    targetNode )  ;", "}", "}", "for    ( Task   finalizerTask    :    context . getDependencies ( task ,    task . getFinalizedBy (  )  )  )     {", "TaskInfo   targetNode    =    nodeFactory . createNode ( finalizerTask )  ;", "addFinalizerNode ( node ,    targetNode )  ;", "if    (  !  ( visiting . contains ( targetNode )  )  )     {", "queue . add (  0  ,    targetNode )  ;", "}", "}", "for    ( Task   mustRunAfter    :    context . getDependencies ( task ,    task . getMustRunAfter (  )  )  )     {", "TaskInfo   targetNode    =    nodeFactory . createNode ( mustRunAfter )  ;", "node . addMustSuccessor ( targetNode )  ;", "}", "for    ( Task   shouldRunAfter    :    context . getDependencies ( task ,    task . getShouldRunAfter (  )  )  )     {", "TaskInfo   targetNode    =    nodeFactory . createNode ( shouldRunAfter )  ;", "node . addShouldSuccessor ( targetNode )  ;", "}", "if    ( node . isRequired (  )  )     {", "for    ( TaskInfo   successor    :    node . getDependencySuccessors (  )  )     {", "if    ( filter . isSatisfiedBy ( successor . getTask (  )  )  )     {", "successor . require (  )  ;", "}", "}", "} else    {", "tasksInUnknownState . add ( node )  ;", "}", "} else    {", "queue . remove (  0  )  ;", "visiting . remove ( node )  ;", "node . dependenciesProcessed (  )  ;", "}", "}", "resolveTasksInUnknownState (  )  ;", "}", "METHOD_END"], "methodName": ["addToTaskGraph"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    ( dependenciesCompleteCache . contains ( taskInfo )  )     {", "return   true ;", "}", "boolean   dependenciesComplete    =    taskInfo . allDependenciesComplete (  )  ;", "if    ( dependenciesComplete )     {", "dependenciesCompleteCache . add ( taskInfo )  ;", "}", "return   dependenciesComplete ;", "}", "METHOD_END"], "methodName": ["allDependenciesComplete"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "for    ( ResourceLock   lock    :    projectLocks . values (  )  )     {", "if    (  !  ( lock . isLocked (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["allProjectsLocked"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskInfo   taskInfo    :    executionPlan . values (  )  )     {", "if    (  !  ( taskInfo . isComplete (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["allTasksComplete"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "coordinationService . withStateLock ( new   Transformer < ResourceLockState . Disposition ,    ResourceLockState >  (  )     {", "@ Override", "public   Disposition   transform ( ResourceLockState   resourceLockState )     {", "if    ( allTasksComplete (  )  )     {", "rethrowFailures (  )  ;", "return   FINISHED ;", "} else    {", "return   RETRY ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["awaitCompletion"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "return    (  ( taskMutationInfo    !  =    null )     &  &     ( taskMutationInfo . task . isComplete (  )  )  )     &  &     ( taskMutationInfo . consumingTasks . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["canRemoveTaskMutation"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Set < String >    candidateTaskDestroyables    =    taskMutationInfo . destroyablePaths ;", "if    (  !  ( candidateTaskDestroyables . isEmpty (  )  )  )     {", "if    ( taskMutationInfo . hasOutputs )     {", "throw   new   IllegalStateException (  (  (  \" Task    \"     +     ( taskInfo . ge (  )  . getIdentityPath (  )  )  )     +     \"    has   both   outputs   and   destroyables   defined .       A   task   can   define   either   outputs   or   destroyables ,    but   not   both .  \"  )  )  ;", "}", "if    ( taskMutationInfo . hasFileInputs )     {", "throw   new   IllegalStateException (  (  (  \" Task    \"     +     ( taskInfo . ge (  )  . getIdentityPath (  )  )  )     +     \"    has   both   inputs   and   destroyables   defined .       A   task   can   define   either   inputs   or   destroyables ,    but   not   both .  \"  )  )  ;", "}", "if    ( taskMutationInfo . hasLocalState )     {", "throw   new   IllegalStateException (  (  (  \" Task    \"     +     ( taskInfo . ge (  )  . getIdentityPath (  )  )  )     +     \"    has   both   local   state   and   destroyables   defined .       A   task   can   define   either   local   state   or   destroyables ,    but   not   both .  \"  )  )  ;", "}", "}", "if    (  !  ( runningTasks . isEmpty (  )  )  )     {", "Set < String >    candidateTaskOutputs    =    taskMutationInfo . outputPaths ;", "Set < String >    candidateTaskMutations    =     (  !  ( candidateTaskOutputs . isEmpty (  )  )  )     ?    candidateTaskOutputs    :    candidateTaskDestroyables ;", "Pair < TaskInfo ,    String >    overlap    =    firstRunningTaskWithOverlappingMutations ( candidateTaskMutations )  ;", "if    ( overlap    !  =    null )     {", "return   false ;", "}", "}", "Pair < TaskInfo ,    String >    overlap    =    firsWithDestroyedIntermediateInput ( taskInfo ,    candidateTaskDestroyables )  ;", "if    ( overlap    !  =    null )     {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["canRunWithCurrentlyExecutedTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "ImmutableSet . Builder < String >    builder    =    ImmutableSet . builder (  )  ;", "for    ( File   file    :    files )     {", "String   path ;", "try    {", "path    =    cache . get ( file )  ;", "if    ( path    =  =    null )     {", "path    =    file . getCanonicalPath (  )  ;", "cache . put ( file ,    path )  ;", "}", "builder . add ( path )  ;", "}    catch    ( IOExcep   e )     {", "throw   new   UncheckedIOExcep ( e )  ;", "}", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["canonicalizedPaths"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "coordinationService . withStateLock ( new   Transformer < ResourceLockState . Disposition ,    ResourceLockState >  (  )     {", "@ Override", "public   Disposition   transform ( ResourceLockState   resourceLockState )     {", "nodeFactory . clear (  )  ;", "entryTasks . clear (  )  ;", "e . clear (  )  ;", "executionQueue . clear (  )  ;", "projectLocks . clear (  )  ;", "failureCollector . clearFailures (  )  ;", "taskMutations . clear (  )  ;", "canonicalizedFileCache . clear (  )  ;", "reachableCache . clear (  )  ;", "dependenciesCompleteCache . clear (  )  ;", "runningTasks . clear (  )  ;", "return   FINISHED ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" A   deadlock   was   detected   while   resolving   the    % s   for   task    '  % s '  .    This   can   be   caused ,    for   instance ,    by    % s   property   causing   dependency   resolution .  \"  ,    plural ,    task ,    singular )  ;", "}", "METHOD_END"], "methodName": ["deadlockMessage"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "List < DefaultTaskExecutionPlan . TaskInfoInVisitingSegment >    nodeQueue    =    Lists . newArrayList ( Iterables . transform ( entryTasks ,    new   com . google . common . base . Function < TaskInfo ,    DefaultTaskExecutionPlan . TaskInfoInVisitingSegment >  (  )     {", "int   index ;", "public   DefaultTaskExecutionPlan . TaskInfoInVisitingSegment   apply ( TaskInfo   taskInfo )     {", "return   new   DefaultTaskExecutionPlan . TaskInfoInVisitingSegment ( taskInfo ,     (  ( index )  +  +  )  )  ;", "}", "}  )  )  ;", "int   visitingSegmentCounter    =    nodeQueue . size (  )  ;", "HashMultimap < TaskInfo ,    Integer >    visitingNodes    =    HashMultimap . create (  )  ;", "Deque < DefaultTaskExecutionPlan . GraphEdge >    walkedShouldRunAfterEdges    =    new   ArrayDeque < DefaultTaskExecutionPlan . GraphEdge >  (  )  ;", "Deque < TaskInfo >    path    =    new   ArrayDeque < TaskInfo >  (  )  ;", "HashMap < TaskInfo ,    Integer >    planBeforeVisiting    =    new   HashMap < TaskInfo ,    Integer >  (  )  ;", "while    (  !  ( nodeQueue . isEmpty (  )  )  )     {", "DefaultTaskExecutionPlan . TaskInfoInVisitingSegment   taskInfoInVisitingSegment    =    nodeQueue . get (  0  )  ;", "int   currentSegment    =    taskInfoInVisitingSegment . visitingSegment ;", "TaskInfo   taskNode    =    taskInfoInVisitingSegment . taskInfo ;", "if    (  ( taskNode . isIncludeInGraph (  )  )     |  |     ( executionPlan . containsKey ( taskNode . getTask (  )  )  )  )     {", "nodeQueue . remove (  0  )  ;", "visitingNodes . remove ( taskNode ,    currentSegment )  ;", "maybeRemoveProcessedShouldRunAfterEdge ( walkedShouldRunAfterEdges ,    taskNode )  ;", "continue ;", "}", "boolean   alreadyVisited    =    visitingNodes . containsKey ( taskNode )  ;", "visitingNodes . put ( taskNode ,    currentSegment )  ;", "if    (  ! alreadyVisited )     {", "recordEdgeIfArrivedViaShouldRunAfter ( walkedShouldRunAfterEdges ,    path ,    taskNode )  ;", "removeShouldRunAfterSuccessorsIfTheyImposeACycle ( visitingNodes ,    taskInfoInVisitingSegment )  ;", "takePlanSnapshotIfCanBeRestoredToCurrentTask ( planBeforeVisiting ,    taskNode )  ;", "ArrayList < TaskInfo >    successors    =    new   ArrayList < TaskInfo >  (  )  ;", "addAllSuccessorsInReverseOrder ( taskNode ,    successors )  ;", "for    ( TaskInfo   successor    :    successors )     {", "if    ( visitingNodes . containsEntry ( successor ,    currentSegment )  )     {", "if    (  !  ( walkedShouldRunAfterEdges . isEmpty (  )  )  )     {", "DefaultTaskExecutionPlan . GraphEdge   toBeRemoved    =    walkedShouldRunAfterEdges . pop (  )  ;", "toBeRemoved . from . removeShouldRunAfterSuccessor ( toBeRemoved . to )  ;", "restorePath ( path ,    toBeRemoved )  ;", "restoreQueue ( nodeQueue ,    visitingNodes ,    toBeRemoved )  ;", "restoreExecutionPlan ( planBeforeVisiting ,    toBeRemoved )  ;", "break ;", "} else    {", "onOrderingCycle (  )  ;", "}", "}", "nodeQueue . add (  0  ,    new   DefaultTaskExecutionPlan . TaskInfoInVisitingSegment ( successor ,    currentSegment )  )  ;", "}", "path . push ( taskNode )  ;", "} else    {", "nodeQueue . remove (  0  )  ;", "maybeRemoveProcessedShouldRunAfterEdge ( walkedShouldRunAfterEdges ,    taskNode )  ;", "visitingNodes . remove ( taskNode ,    currentSegment )  ;", "path . pop (  )  ;", "executionPlan . put ( taskNode . getTask (  )  ,    taskNode )  ;", "Project   project    =    taskNode . getTask (  )  . getProject (  )  ;", "projectLocks . put ( project ,    getOrCreateProjectLock ( project )  )  ;", "DefaultTaskExecutionPlan . TaskMutationInfo   taskMutationInfo    =    getOrCreateMutationsOf ( taskNode )  ;", "for    ( TaskInfo   dependency    :    taskNode . getDependencySuccessors (  )  )     {", "getOrCreateMutationsOf ( dependency )  . consumingTasks . add ( taskNode )  ;", "taskMutationInfo . consumesOutputOf . add ( dependency )  ;", "}", "ArrayList < TaskInfo >    finalizerTasks    =    new   ArrayList < TaskInfo >  (  )  ;", "addAllReversed ( finalizerTasks ,    taskNode . getFinalizers (  )  )  ;", "for    ( TaskInfo   finalizer    :    finalizerTasks )     {", "if    (  !  ( visitingNodes . containsKey ( finalizer )  )  )     {", "nodeQueue . add ( finalizerTaskPosition ( finalizer ,    nodeQueue )  ,    new   DefaultTaskExecutionPlan . TaskInfoInVisitingSegment ( finalizer ,     ( visitingSegmentCounter +  +  )  )  )  ;", "}", "}", "}", "}", "executionQueue . clear (  )  ;", "executionQueue . addAll ( executionPlan . values (  )  )  ;", "}", "METHOD_END"], "methodName": ["determineExecutionPlan"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskInfo   finalizerNode    :    taskInfo . getFinalizers (  )  )     {", "if    (  ( finalizerNode . isRequired (  )  )     |  |     ( finalizerNode . isMustNotRun (  )  )  )     {", ". enforceWithDependencies ( finalizerNode ,    Sets .  < TaskInfo > newHashSet (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["enforceFinalizerTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Deque < TaskInfo >    candidateNodes    =    new   ArrayDeque < TaskInfo >  (  )  ;", "candidateNodes . add ( nodeInfo )  ;", "while    (  !  ( candidateNodes . isEmpty (  )  )  )     {", "TaskInfo   node    =    candidateNodes . pop (  )  ;", "if    (  !  ( enforcedTasks . contains ( node )  )  )     {", "enforcedTasks . add ( node )  ;", "candidateNodes . addAll ( node . getDependencySuccessors (  )  )  ;", "if    (  ( node . isMustNotRun (  )  )     |  |     ( node . isRequired (  )  )  )     {", "node . enforceRun (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["enforceWithDependencies"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    ( selectedTask    =  =    null )     {", "return ;", "}", "try    {", "if    (  !  ( selectedTask . isComplete (  )  )  )     {", "try    {", "t . execute ( selectedTask . getTask (  )  )  ;", "}    catch    ( Throwable   e )     {", "selectedTask . setExecutionFailure ( e )  ;", "}", "}", "}    finally    {", "coordinationService . withStateLock ( new   Transformer < ResourceLockState . Disposition ,    ResourceLockState >  (  )     {", "@ Override", "public   Disposition   transform ( ResourceLockState   state )     {", "if    (  !  ( selectedTask . isComplete (  )  )  )     {", "taskComplete ( selectedTask )  ;", "}", "return   unlock ( workerLease ,    getProjectLock ( selectedTask )  )  . transform ( state )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  ( nodeQueue . size (  )  )     =  =     0  )     {", "return    0  ;", "}", "Set < TaskInfo >    precedingTasks    =    getAllPrecedingTasks ( finalizer )  ;", "Set < Integer >    precedingTaskIndices    =    CollectionUtils . collect ( precedingTasks ,    new   Transformer < Integer ,    TaskInfo >  (  )     {", "public   Integer   transform ( final   TaskInfo   dependsOnTask )     {", "return   Iterables . indexOf ( nodeQueue ,    new   com . google . common . base . Predicate <  . TaskInfoInVisitingSegment >  (  )     {", "public   boolean   apply (  . TaskInfoInVisitingSegment   taskInfoInVisitingSegment )     {", "return   taskInfoInVisitingSegment . taskInfo . equals ( dependsOnTask )  ;", "}", "}  )  ;", "}", "}  )  ;", "return    ( Collections . max ( precedingTaskIndices )  )     +     1  ;", "}", "METHOD_END"], "methodName": ["finalizerTaskPosition"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "for    ( String   path 1     :    paths 1  )     {", "for    ( String   path 2     :    paths 2  )     {", "String   overLappedPath    =     . getOverLappedPath ( path 1  ,    path 2  )  ;", "if    ( overLappedPath    !  =    null )     {", "return   overLappedPath ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findFirstOverlap"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( candidateTaskMutations . isEmpty (  )  )  )     {", "for    ( TaskInfo   runningTask    :    runningTasks )     {", ". TaskMutationInfo   taskMutationInfo    =    taskMutations . get ( runningTask )  ;", "Iterable < String >    runningTaskMutations    =    Iterables . concat ( taskMutationInfo . outputPaths ,    taskMutationInfo . destroyablePaths )  ;", "String   firstOverlap    =     . findFirstOverlap ( candidateTaskMutations ,    runningTaskMutations )  ;", "if    ( firstOverlap    !  =    null )     {", "return   Pair . of ( runningTask ,    firstOverlap )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["firstRunningTaskWithOverlappingMutations"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( destroyablePaths . isEmpty (  )  )  )     {", "Iterator <  . TaskMutationInfo >    iterator    =    taskMutations . values (  )  . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", ". TaskMutationInfo   taskMutationInfo    =    iterator . next (  )  ;", "if    (  ( taskMutationInfo . task . isComplete (  )  )     &  &     (  !  ( taskMutationInfo . consumingTasks . isEmpty (  )  )  )  )     {", "String   firstOverlap    =     . findFirstOverlap ( destroyablePaths ,    taskMutationInfo . outputPaths )  ;", "if    ( firstOverlap    !  =    null )     {", "for    ( TaskInfo   consumingTask    :    taskMutationInfo . consumingTasks )     {", "if    (  ( consumingTask    !  =    taskInfo )     &  &     (  !  ( isReachableFrom ( consumingTask ,    taskInfo )  )  )  )     {", "return   Pair . of ( consumingTask ,    firstOverlap )  ;", "}", "}", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["firstTaskWithDestroyedIntermediateInput"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Set < TaskInfo >    precedingTasks    =    new   HashSet < TaskInfo >  (  )  ;", "Deque < TaskInfo >    candidateTasks    =    new   ArrayDeque < TaskInfo >  (  )  ;", "candidateTasks . addAll ( finalizer . getDependencySuccessors (  )  )  ;", "candidateTasks . addAll ( finalizer . getMustSuccessors (  )  )  ;", "candidateTasks . addAll ( finalizer . getShouldSuccessors (  )  )  ;", "while    (  !  ( candidateTasks . isEmpty (  )  )  )     {", "TaskInfo   precedingTask    =    candidateTasks . pop (  )  ;", "if    ( precedingTasks . add ( precedingTask )  )     {", "candidateTasks . addAll ( precedingTask . getMustSuccessors (  )  )  ;", "}", "}", "return   precedingTasks ;", "}", "METHOD_END"], "methodName": ["getAllPrecedingTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . canonicalizedPaths ( canonicalizedFileCache ,    destroyableFiles )  ;", "}    catch    ( ResourceDeadlockException   e )     {", "throw   new   IllegalStateException (  . deadlockMessage ( task ,     \" a   destroyable \"  ,     \" destroyables \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDestroyablePaths"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskExecutionPlan . TaskMutationInfo   mutations    =    taskMutations . get ( taskInfo )  ;", "if    ( mutations    =  =    null )     {", "mutations    =    new   DefaultTaskExecutionPlan . TaskMutationInfo ( taskInfo )  ;", "taskMutations . put ( taskInfo ,    mutations )  ;", "}", "return   mutations ;", "}", "METHOD_END"], "methodName": ["getOrCreateMutationsOf"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "String   gradlePath    =     (  ( GradleInternal )     ( project . getGradle (  )  )  )  . getIdentityPath (  )  . toString (  )  ;", "String   projectPath    =     (  ( ProjectInternal )     ( project )  )  . getIdentityPath (  )  . toString (  )  ;", "return   workerLeaseService . getProjectLock ( gradlePath ,    projectPath )  ;", "}", "METHOD_END"], "methodName": ["getOrCreateProjectLock"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    . canonicalizedPaths ( canonicalizedFileCache ,    Iterables . concat ( outputFiles ,    localStateFiles )  )  ;", "}    catch    ( ResourceDeadlockException   e )     {", "throw   new   IllegalStateException (  . deadlockMessage ( task ,     \" an   output   or   local   state \"  ,     \" outputs \"  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getOutputPaths"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    ( firstPath . equals ( secondPath )  )     {", "return   firstPath ;", "}", "if    (  ( firstPath . gth (  )  )     =  =     ( secondPath . gth (  )  )  )     {", "return   null ;", "}", "String   shorter ;", "String   longer ;", "if    (  ( firstPath . gth (  )  )     >     ( secondPath . gth (  )  )  )     {", "shorter    =    secondPath ;", "longer    =    firstPath ;", "} else    {", "shorter    =    firstPath ;", "longer    =    secondPath ;", "}", "boon   isOverlapping    =     ( longer . startsWith ( shorter )  )     &  &     (  ( longer . charAt ( shorter . gth (  )  )  )     =  =     ( FiseparatorChar )  )  ;", "if    ( isOverlapping )     {", "return   shorter ;", "} else    {", "return   null ;", "}", "}", "METHOD_END"], "methodName": ["getOverLappedPath"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "return   projectLocks . get ( taskInfo . getTask (  )  . getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProjectLock"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "TaskInternal   task    =    taskInfo . getTask (  )  ;", ". TaskMutationInfo   taskMutationInfo    =    taskMutations . get ( taskInfo )  ;", "if    (  !  ( taskMutationInfo . resolved )  )     {", "ProjectInternal   project    =     (  ( ProjectInternal )     ( task . getProject (  )  )  )  ;", "ServiceRegistry   serviceRegistry    =    project . getServices (  )  ;", "PathToFileResolver   resolver    =    serviceRegistry . get ( PathToFileResolver . class )  ;", "PropertyWalker   propertyWalker    =    serviceRegistry . get ( PropertyWalker . class )  ;", "TaskProperties   taskProperties    =    DefaultTaskProperties . resolve ( propertyWalker ,    resolver ,    task )  ;", "taskMutationInfo . outputPaths . addAll (  . getOutputPaths ( canonicalizedFileCache ,    taskInfo ,    taskProperties . getOutputFiles (  )  ,    taskProperties . getLocalStateFiles (  )  )  )  ;", "taskMutationInfo . destroyablePaths . addAll (  . getDestroyablePaths ( canonicalizedFileCache ,    taskInfo ,    taskProperties . getDestroyableFiles (  )  )  )  ;", "taskMutationInfo . hasFileInputs    =     !  ( taskProperties . getInputFileProperties (  )  . isEmpty (  )  )  ;", "taskMutationInfo . hasOutputs    =    taskProperties . hasDeclaredOutputs (  )  ;", "taskMutationInfo . hasLocalState    =     !  ( taskProperties . getLocalStateFiles (  )  . isEmpty (  )  )  ;", "taskMutationInfo . resolved    =    true ;", "}", "return   taskMutationInfo ;", "}", "METHOD_END"], "methodName": ["getResolvedTaskMutationInfo"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList < Task >  ( executionPlan . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Throwable   executionFailure    =    taskInfo . getExecutionFailure (  )  ;", "if    ( executionFailure    !  =    null )     {", "abortExecution (  )  ;", "this . failureCollector . addFailure ( executionFailure )  ;", "return ;", "}", "try    {", "failureHandler . onTaskFailure ( taskInfo . getTask (  )  )  ;", "this . failureCollector . addFailure ( taskInfo . getTaskFailure (  )  )  ;", "}    catch    ( Exception   e )     {", "abortExecution (  )  ;", "this . failureCollector . addFailure ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["handleFailure"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Pair < TaskInfo ,    TaskInfo >    taskPair    =    Pair . of ( fromTask ,    toTask )  ;", "if    (  ( reachableCache . get ( taskPair )  )     !  =    null )     {", "return   reachableCache . get ( taskPair )  ;", "}", "boolean   reachable    =    false ;", "for    ( TaskInfo   dependency    :    Iterables . concat ( fromTask . getMustSuccessors (  )  ,    fromTask . getDependencySuccessors (  )  )  )     {", "if    (  !  ( dependency . isComplete (  )  )  )     {", "if    ( dependency    =  =    toTask )     {", "reachable    =    true ;", "}", "if    ( isReachableFrom ( dependency ,    toTask )  )     {", "reachable    =    true ;", "}", "}", "}", "reachableCache . put ( taskPair ,    reachable )  ;", "return   reachable ;", "}", "METHOD_END"], "methodName": ["isReachableFrom"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( walkedShouldRunAfterEdges . isEmpty (  )  )  )     &  &     ( walkedShouldRunAfterEdges . peek (  )  . to . equals ( taskNode )  )  )     {", "walkedShouldRunAfterEdges . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeRemoveProcessedShouldRunAfterEdge"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "CachingDirectedGraphWalker < TaskInfo ,    Void >    graphWalker    =    new   CachingDirectedGraphWalker < TaskInfo ,    Void >  ( new   DirectedGraph < TaskInfo ,    Void >  (  )     {", "public   void   getNodeValues ( TaskInfo   node ,    Collection <  ?    super   Void >    values ,    Collection <  ?    super   TaskInfo >    connectedNodes )     {", "connectedNodes . addAll ( node . getDependencySuccessors (  )  )  ;", "connectedNodes . addAll ( node . getMustSuccessors (  )  )  ;", "}", "}  )  ;", "graphWalker . add ( entryTasks )  ;", "final   List < TaskInfo >    firstCycle    =    new   ArrayList < TaskInfo >  ( graphWalker . findCycles (  )  . get (  0  )  )  ;", "Collections . sort ( firstCycle )  ;", "DirectedGraphRenderer < TaskInfo >    graphRenderer    =    new   DirectedGraphRenderer < TaskInfo >  ( new   GraphNodeRenderer < TaskInfo >  (  )     {", "public   void   renderTo ( TaskInfo   node ,    StyledTextOutput   output )     {", "output . withStyle ( Identifier )  . text ( node . getTask (  )  . getIdentityPath (  )  )  ;", "}", "}  ,    new   DirectedGraph < TaskInfo ,    Object >  (  )     {", "public   void   getNodeValues ( TaskInfo   node ,    Collection <  ?    super   Object >    values ,    Collection <  ?    super   TaskInfo >    connectedNodes )     {", "for    ( TaskInfo   dependency    :    firstCycle )     {", "if    (  ( node . getDependencySuccessors (  )  . contains ( dependency )  )     |  |     ( node . getMustSuccessors (  )  . contains ( dependency )  )  )     {", "connectedNodes . add ( dependency )  ;", "}", "}", "}", "}  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "graphRenderer . renderTo ( firstCycle . get (  0  )  ,    writer )  ;", "throw   new   CircularReferenceException ( String . format (  \" Circular   dependency   between   the   following   tasks :  % n % s \"  ,    writer . toString (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["onOrderingCycle"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( path . isEmpty (  )  )  )     &  &     ( path . peek (  )  . getShouldSuccessors (  )  . contains ( taskNode )  )  )     {", "walkedShouldRunAfterEdges . push ( new    . GraphEdge ( path . peek (  )  ,    taskNode )  )  ;", "}", "}", "METHOD_END"], "methodName": ["recordEdgeIfArrivedViaShouldRunAfter"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "runningTasks . remove ( taskInfo )  ;", ". TaskMutationInfo   taskMutationInfo    =    taskMutations . get ( taskInfo )  ;", "for    ( TaskInfo   producerTask    :    taskMutationInfo . consumesOutputOf )     {", ". TaskMutationInfo   producerTaskMutationInfo    =    taskMutations . get ( producerTask )  ;", "if    (  ( producerTaskMutationInfo . consumingTasks . remove ( taskInfo )  )     &  &     (  . canRemoveTaskMutation ( producerTaskMutationInfo )  )  )     {", "taskMutations . remove ( producerTask )  ;", "}", "}", "if    (  . canRemoveTaskMutation ( taskMutationInfo )  )     {", "taskMutations . remove ( taskInfo )  ;", "}", "}", "METHOD_END"], "methodName": ["recordTaskCompleted"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "runningTasks . add ( taskInfo )  ;", "}", "METHOD_END"], "methodName": ["recordTaskStarted"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "TaskInfo   taskNode    =    taskNodeWithVisitingSegment . taskInfo ;", "Iterables . removeIf ( taskNode . getShouldSuccessors (  )  ,    new   com . google . common . base . Predicate < TaskInfo >  (  )     {", "public   boolean   apply ( TaskInfo   input )     {", "return   visitingNodes . containsEntry ( input ,    taskNodeWithVisitingSegment . visitingSegment )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["removeShouldRunAfterSuccessorsIfTheyImposeACycle"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  ( taskInfo . isMustNotRun (  )  )     &  &     ( filter . isSatisfiedBy ( taskInfo . getTask (  )  )  )  )     {", "taskInfo . require (  )  ;", "for    ( TaskInfo   dependency    :    taskInfo . getDependencySuccessors (  )  )     {", "requireWithDependencies ( dependency )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["requireWithDependencies"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "List < TaskInfo >    queue    =    new   ArrayList < TaskInfo >  ( tasksInUnknownState )  ;", "Set < TaskInfo >    visiting    =    new   HashSet < TaskInfo >  (  )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "TaskInfo   task    =    queue . get (  0  )  ;", "if    ( task . isInKnownState (  )  )     {", "queue . remove (  0  )  ;", "continue ;", "}", "if    ( visiting . add ( task )  )     {", "for    ( TaskInfo   hardPredecessor    :    task . getDependencyPredecessors (  )  )     {", "if    (  !  ( visiting . contains ( hardPredecessor )  )  )     {", "queue . add (  0  ,    hardPredecessor )  ;", "}", "}", "} else    {", "queue . remove (  0  )  ;", "visiting . remove ( task )  ;", "task . mustNotRun (  )  ;", "for    ( TaskInfo   predecessor    :    task . getDependencyPredecessors (  )  )     {", "assert    ( predecessor . isRequired (  )  )     |  |     ( predecessor . isMustNotRun (  )  )  ;", "if    ( predecessor . isRequired (  )  )     {", "task . require (  )  ;", "break ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["resolveTasksInUnknownState"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "Iterator < Map . Entry < Task ,    TaskInfo >  >    executionPlanIterator    =    executionPlan . entrySet (  )  . iterator (  )  ;", "for    ( int   i    =     0  ;    i    <     ( planBeforeVisiting . get ( toBeRemoved . from )  )  ;    i +  +  )     {", "executionPlanIterator . next (  )  ;", "}", "while    ( executionPlanIterator . hasNext (  )  )     {", "executionPlanIterator . next (  )  ;", "executionPlanIterator . remove (  )  ;", "}", "}", "METHOD_END"], "methodName": ["restoreExecutionPlan"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "TaskInfo   removedFromPath    =    null ;", "while    (  !  ( toBeRemoved . from . equals ( removedFromPath )  )  )     {", "removedFromPath    =    path . pop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["restorePath"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskExecutionPlan . TaskInfoInVisitingSegment   nextInQueue    =    null ;", "while    (  ( nextInQueue    =  =    null )     |  |     (  !  ( toBeRemoved . from . equals ( nextInQueue . taskInfo )  )  )  )     {", "nextInQueue    =    nodeQueue . get (  0  )  ;", "visitingNodes . remove ( nextInQueue . taskInfo ,    nextInQueue . visitingSegment )  ;", "if    (  !  ( toBeRemoved . from . equals ( nextInQueue . taskInfo )  )  )     {", "nodeQueue . remove (  0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["restoreQueue"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    ( tasksCancelled )     {", "failureCollector . addFailure ( new   BuildCancelledException (  )  )  ;", "}", "if    ( failureCollector . getFailures (  )  . isEmpty (  )  )     {", "return ;", "}", "if    (  ( failureCollector . getFailures (  )  . size (  )  )     >     1  )     {", "throw   new   MultipleBuildFailures ( failureCollector . getFailures (  )  )  ;", "}", "throw   UncheckedExcephrowAsUncheckedException ( failureCollector . getFailures (  )  . get (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["rethrowFailures"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "final   AtomicReference < TaskInfo >    selected    =    new   AtomicReference < TaskInfo >  (  )  ;", "final   Iterator < TaskInfo >    iterator    =    executionQueue . iterator (  )  ;", "while    ( iterator . hasNext (  )  )     {", "final   TaskInfo   taskInfo    =    iterator . next (  )  ;", "if    (  ( taskInfo . isReady (  )  )     &  &     ( allDependenciesComplete ( taskInfo )  )  )     {", "coordinationService . withStateLock ( new   Transformer < ResourceLockState . Disposition ,    ResourceLockState >  (  )     {", "@ Override", "public   Disposition   transform ( ResourceLockState   resourceLockState )     {", "ResourceLock   projectLock    =    getProjectLock ( taskInfo )  ;", ". TaskMutationInfo   taskMutationInfo    =    getResolvedTaskMutationInfo ( taskInfo )  ;", "if    (  (  (  !  ( projectLock . tryLock (  )  )  )     |  |     (  !  ( workerLease . tryLock (  )  )  )  )     |  |     (  !  ( canRunWithCurrentlyExecutedTasks ( taskInfo ,    taskMutationInfo )  )  )  )     {", "return   FAILED ;", "}", "selected . set ( taskInfo )  ;", "if    ( taskInfo . allDependenciesSuccessful (  )  )     {", "recordTaskStarted ( taskInfo )  ;", "taskInfo . startExecution (  )  ;", "} else    {", "taskInfo . skipExecution (  )  ;", "}", "iterator . remove (  )  ;", "return   FINISHED ;", "}", "}  )  ;", "if    (  ( selected . get (  )  )     !  =    null )     {", "break ;", "}", "}", "}", "return   selected . get (  )  ;", "}", "METHOD_END"], "methodName": ["selectNextTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "if    (  ( taskNode . getShouldSuccessors (  )  . size (  )  )     >     0  )     {", "planBeforeVisiting . put ( taskNode ,    e . size (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["takePlanSnapshotIfCanBeRestoredToCurrentTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskExecutionPlan . enforceFinalizerTasks ( taskInfo )  ;", "if    ( taskInfo . isFailed (  )  )     {", "handleFailure ( taskInfo )  ;", "}", "taskInfo . finishExecution (  )  ;", "recordTaskCompleted ( taskInfo )  ;", "}", "METHOD_END"], "methodName": ["taskComplete"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "this . failureHandler    =    handler ;", "}", "METHOD_END"], "methodName": ["useFailureHandler"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "this . filter    =    filter ;", "}", "METHOD_END"], "methodName": ["useFilter"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskInfo   taskInfo    :    executionQueue )     {", "if    (  !  ( taskInfo . isComplete (  )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["workRemaining"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskExecutionPlan"}, {"methodBody": ["METHOD_START", "{", "graphListeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addTaskExecutionGraphListener"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addTaskExecutionListener"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "assert   tasks    !  =    null ;", "final   Timer   clock    =    Time . startTimer (  )  ;", "Set < Task >    taskSet    =    new   LinkedHashSet < Task >  (  )  ;", "for    ( Task   task    :    tasks )     {", "taskSet . add ( task )  ;", "requestedTasks . add ( task )  ;", "}", "taskExecutionPlan . addToTaskGraph ( taskSet )  ;", "taskGraphState    =     . TaskGraphState . DIRTY ;", ". LOGGER . debug (  (  \" Timing :    Creating   the   DAG   took    \"     +     ( clock . getElapsed (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . add ( new   ClosureBackedMethodInvocationDispatch (  \" afterExecute \"  ,    closure )  )  ;", "}", "METHOD_END"], "methodName": ["afterTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . add ( new   TaskExecutionAdapter (  )     {", "@ Override", "public   void   afterExecute ( Task   task ,    TaskState   state )     {", "action . execute ( task )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["afterTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . add ( new   ClosureBackedMethodInvocationDispatch (  \" beforeExecute \"  ,    closure )  )  ;", "}", "METHOD_END"], "methodName": ["beforeTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . add ( new   TaskExecutionAdapter (  )     {", "@ Override", "public   void   beforeExecute ( Task   task )     {", "action . execute ( task )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["beforeTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "switch    ( taskGraphState )     {", "case   EMPTY    :", "throw   new   IllegalStateException (  \" Task   information   is   not   available ,    as   this   task   execution   graph   has   not   been   populated .  \"  )  ;", "case   DIRTY    :", "taskExecutionPlan . determineExecutionPlan (  )  ;", "taskGraphState    =     . TaskGraphState . POPULATED ;", "return ;", "case   POPULATED    :", "}", "}", "METHOD_END"], "methodName": ["ensurePopulated"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "Timer   clock    =    Time . startTimer (  )  ;", "ensurePopulated (  )  ;", "graphListeners . getSource (  )  . graphPopulated ( this )  ;", "try    {", "taskPlanExecutor . process ( taskExecutionPlan ,    new    . EventFiringTaskWorker ( taskExecuter . create (  )  ,    buildOperationExecutor . getCurrentOperation (  )  )  )  ;", ". LOGGER . debug (  (  \" Timing :    Executing   the   DAG   took    \"     +     ( clock . getElapsed (  )  )  )  )  ;", "}    finally    {", "taskExecutionPlan . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "ensurePopulated (  )  ;", "return   taskEPlan . getTasks (  )  ;", "}", "METHOD_END"], "methodName": ["getAllTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "return   taskExecutionPlan . getFilteredTasks (  )  ;", "}", "METHOD_END"], "methodName": ["getFilteredTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "return   requestedTasks ;", "}", "METHOD_END"], "methodName": ["getRequestedTasks"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "ensurePopulated (  )  ;", "assert    ( path    !  =    null )     &  &     (  ( path . length (  )  )     >     0  )  ;", "for    ( Task   task    :    taskEPlan . getTasks (  )  )     {", "if    ( task . getPath (  )  . equals ( path )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["hasTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "ensurePopulated (  )  ;", "return   taskEPlan . getTasks (  )  . contains ( task )  ;", "}", "METHOD_END"], "methodName": ["hasTask"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "graphListeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeTaskExecutionGraphListener"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskListeners . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeTaskExecutionListener"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "taskExecutionPlan . useFailureHandler ( handler )  ;", "}", "METHOD_END"], "methodName": ["useFailureHandler"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "this . filter    =     (  ( Spec <  ?    super   Task >  )     (  ( filter    !  =    null )     ?    filter    :    Specs . SATISFIES _ ALL )  )  ;", "taskExecutionPlan . useFilter ( this . filter )  ;", "taskGraphState    =     . TaskGraphState . DIRTY ;", "}", "METHOD_END"], "methodName": ["useFilter"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "graphListeners . add ( new   ClosureBackedMethodInvocationDispatch (  \" graphPopulated \"  ,    closure )  )  ;", "}", "METHOD_END"], "methodName": ["whenReady"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "graphListeners . add ( new   TaskExecutionGraphListener (  )     {", "@ Override", "public   void   graphPopulated ( TaskExecutionGraph   graph )     {", "action . execute ( graph )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["whenReady"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskGraphExecuter"}, {"methodBody": ["METHOD_START", "{", "DefaultTaskPlanExecutor . LOGGER . debug (  \" Using    {  }    parallel   executor   threads \"  ,    executorCount )  ;", "for    ( int   i    =     1  ;    i    <     ( executorCount )  ;    i +  +  )     {", "Runnable   worker    =    taskWorker ( taskExecutionPlan ,    taskWorker ,    parentWorkerLease )  ;", "executor . execute ( worker )  ;", "}", "}", "METHOD_END"], "methodName": ["startAdditionalWorkers"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskPlanExecutor"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskPlanExecutor . TaskExecutorWorker ( taskExecutionPlan ,    taskWorker ,    parentWorkerLease )  ;", "}", "METHOD_END"], "methodName": ["taskWorker"], "fileName": "org.gradle.execution.taskgraph.DefaultTaskPlanExecutor"}, {"methodBody": ["METHOD_START", "{", "failures . add ( throwable )  ;", "}", "METHOD_END"], "methodName": ["addFailure"], "fileName": "org.gradle.execution.taskgraph.TaskFailureCollector"}, {"methodBody": ["METHOD_START", "{", "failures . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearFailures"], "fileName": "org.gradle.execution.taskgraph.TaskFailureCollector"}, {"methodBody": ["METHOD_START", "{", "return   failures ;", "}", "METHOD_END"], "methodName": ["getFailures"], "fileName": "org.gradle.execution.taskgraph.TaskFailureCollector"}, {"methodBody": ["METHOD_START", "{", "assert   isReady (  )  ;", "state    =    TaskInfo . TaskEState . SKIPPED ;", "}", "METHOD_END"], "methodName": ["abortExecution"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "dependencySuccessors . add ( toNode )  ;", "toNode . dependencyPredecessors . add ( this )  ;", "}", "METHOD_END"], "methodName": ["addDependencySuccessor"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "finalizers . add ( finalizerNode )  ;", "}", "METHOD_END"], "methodName": ["addFinalizer"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "mustSuccessors . add ( toNode )  ;", "}", "METHOD_END"], "methodName": ["addMustSuccessor"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "shouldSuccessors . add ( toNode )  ;", "}", "METHOD_END"], "methodName": ["addShouldSuccessor"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskInfo   dependency    :    mustSuccessors )     {", "if    (  !  ( dependency . isComplete (  )  )  )     {", "return   false ;", "}", "}", "for    ( TaskInfo   dependency    :    dependencySuccessors )     {", "if    (  !  ( dependency . isComplete (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["allDependenciesComplete"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "for    ( TaskInfo   dependency    :    dependencySuccessors )     {", "if    (  !  ( dependency . isSuccessful (  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["allDependenciesSuccessful"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   task . compareTo ( otherInfo . getTask (  )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "dependenciesProcessed    =    true ;", "}", "METHOD_END"], "methodName": ["dependenciesProcessed"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "state    =    TaskInfo . TaskExecutionState . NOT _ REQUIRED ;", "}", "METHOD_END"], "methodName": ["doNotRequire"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "assert    (  (  ( state )     =  =     ( TaskInfo . TaskExecutionState . SHOULD _ RUN )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ NOT _ RUN )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ RUN )  )  ;", "state    =    TaskInfo . TaskExecutionState . MUST _ RUN ;", "}", "METHOD_END"], "methodName": ["enforceRun"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "assert    ( state )     =  =     ( TaskInfo . TaskExecutionState . EXECUTING )  ;", "state    =    TaskInfo . TaskExecutionState . EXECUTED ;", "}", "METHOD_END"], "methodName": ["finishExecution"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   dependenciesProcessed ;", "}", "METHOD_END"], "methodName": ["getDependenciesProcessed"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   dependencyPredecessors ;", "}", "METHOD_END"], "methodName": ["getDependencyPredecessors"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   dependencySuccessors ;", "}", "METHOD_END"], "methodName": ["getDependencySuccessors"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . executionFailure ;", "}", "METHOD_END"], "methodName": ["getExecutionFailure"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   finalizers ;", "}", "METHOD_END"], "methodName": ["getFinalizers"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   mustSuccessors ;", "}", "METHOD_END"], "methodName": ["getMustSuccessors"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   shouldSuccessors ;", "}", "METHOD_END"], "methodName": ["getShouldSuccessors"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   task ;", "}", "METHOD_END"], "methodName": ["getTask"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   this . getTask (  )  . getState (  )  . getFailure (  )  ;", "}", "METHOD_END"], "methodName": ["getTaskFailure"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  ( state )     =  =     ( TaskInfo . TaskExecutionState . EXECUTED )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . SKIPPED )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . UNKNOWN )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . NOT _ REQUIRED )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ NOT _ RUN )  )  ;", "}", "METHOD_END"], "methodName": ["isComplete"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  ( getTaskFailure (  )  )     !  =    null )     |  |     (  ( getExecutionFailure (  )  )     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isFailed"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    ( state )     !  =     ( TaskInfo . TaskExecutionState . UNKNOWN )  ;", "}", "METHOD_END"], "methodName": ["isInKnownState"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  ( state )     =  =     ( TaskInfo . TaskExecutionState . NOT _ REQUIRED )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . UNKNOWN )  )  ;", "}", "METHOD_END"], "methodName": ["isIncludeInGraph"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ NOT _ RUN )  ;", "}", "METHOD_END"], "methodName": ["isMustNotRun"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  ( state )     =  =     ( TaskInfo . TaskExecutionState . SHOULD _ RUN )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ RUN )  )  ;", "}", "METHOD_END"], "methodName": ["isReady"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    ( state )     =  =     ( TaskInfo . TaskExecutionState . SHOULD _ RUN )  ;", "}", "METHOD_END"], "methodName": ["isRequired"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( state )     =  =     ( TaskInfo . TaskExecutionState . EXECUTED )  )     &  &     (  !  ( isFailed (  )  )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . NOT _ REQUIRED )  )  )     |  |     (  ( state )     =  =     ( TaskInfo . TaskExecutionState . MUST _ NOT _ RUN )  )  ;", "}", "METHOD_END"], "methodName": ["isSuccessful"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "state    =    TaskInfo . TaskExecutionState . MUST _ NOT _ RUN ;", "}", "METHOD_END"], "methodName": ["mustNotRun"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "shouldSuccessors . remove ( toNode )  ;", "}", "METHOD_END"], "methodName": ["removeShouldRunAfterSuccessor"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "state    =    TaskInfo . TaskExecutionState . SHOULD _ RUN ;", "}", "METHOD_END"], "methodName": ["require"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "assert    ( state )     =  =     ( TaskInfo . TaskExecutionState . EXECUTING )  ;", "thisFailure    =    failure ;", "}", "METHOD_END"], "methodName": ["setExecutionFailure"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "assert    ( state )     =  =     ( TaskInfo . TaskExecutionState . SHOULD _ RUN )  ;", "state    =    TaskInfo . TaskExecutionState . SKIPPED ;", "}", "METHOD_END"], "methodName": ["skipExecution"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "assert   isReady (  )  ;", "state    =    TaskInfo . TaskEState . EXECUTING ;", "}", "METHOD_END"], "methodName": ["startExecution"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "return   task . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.execution.taskgraph.TaskInfo"}, {"methodBody": ["METHOD_START", "{", "nodes . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.execution.taskgraph.TaskInfoFactory"}, {"methodBody": ["METHOD_START", "{", "TaskInfo   node    =    nodes . get ( task )  ;", "if    ( node    =  =    null )     {", "if    ( task   instanceof   IncludedBuildTaskResource )     {", "node    =    new    . TaskResourceTaskInfo (  (  ( TaskInternal )     ( task )  )  ,    failureCollector )  ;", "} else    {", "node    =    new   TaskInfo (  (  ( TaskInternal )     ( task )  )  )  ;", "}", "nodes . put ( task ,    node )  ;", "}", "return   node ;", "}", "METHOD_END"], "methodName": ["createNode"], "fileName": "org.gradle.execution.taskgraph.TaskInfoFactory"}, {"methodBody": ["METHOD_START", "{", "return   nodes . keySet (  )  ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.execution.taskgraph.TaskInfoFactory"}, {"methodBody": ["METHOD_START", "{", "int   parallelThreads    =    parallelismConfigurationManager . getParallelismConfiguration (  )  . getMaxWorkerCount (  )  ;", "if    ( parallelThreads    <     1  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   create   executor   for   requested   number   of   worker   threads :     % s .  \"  ,    parallelThreads )  )  ;", "}", "taskPlanExecutor    =    new   Default ( parallelismConfigurationManager . getParallelismConfiguration (  )  ,    executorFactory ,    workerLeaseService )  ;", "taskPlanExecutors . add ( taskPlanExecutor )  ;", "return   taskPlanExecutor ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.execution.taskgraph.TaskPlanExecutorFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( projectPath . equals ( PATH _ SEPARATOR )  )     {", "return   startFrom . getRootProject (  )  ;", "}", "Project   current    =    startFrom ;", "if    ( projectPath . startsWith ( PATH _ SEPARATOR )  )     {", "current    =    current . getRootProject (  )  ;", "projectPath    =    projectPath . substring (  1  )  ;", "}", "for    ( String   pattern    :    projectPath . split ( PATH _ SEPARATOR )  )     {", "Map < String ,    Project >    children    =    current . getChildProjects (  )  ;", "NameMatcher   matcher    =    new   NameMatcher (  )  ;", "Project   child    =    matcher . find ( pattern ,    children )  ;", "if    ( child    !  =    null )     {", "current    =    child ;", "continue ;", "}", "throw   new    . ProjectLookupException ( matcher . formatErrorMessage (  \" project \"  ,    current )  )  ;", "}", "return    (  ( ProjectInternal )     ( current )  )  ;", "}", "METHOD_END"], "methodName": ["findProject"], "fileName": "org.gradle.execution.taskpath.ProjectFinderByTaskPath"}, {"methodBody": ["METHOD_START", "{", "return   prefix ;", "}", "METHOD_END"], "methodName": ["getPrefix"], "fileName": "org.gradle.execution.taskpath.ResolvedTaskPath"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.gradle.execution.taskpath.ResolvedTaskPath"}, {"methodBody": ["METHOD_START", "{", "return   taskName ;", "}", "METHOD_END"], "methodName": ["getTaskName"], "fileName": "org.gradle.execution.taskpath.ResolvedTaskPath"}, {"methodBody": ["METHOD_START", "{", "return   isQualified ;", "}", "METHOD_END"], "methodName": ["isQualified"], "fileName": "org.gradle.execution.taskpath.ResolvedTaskPath"}, {"methodBody": ["METHOD_START", "{", "ProjectInternal   project ;", "String   taskName ;", "String   prefix ;", "if    ( path . contains ( PATH _ SEPARATOR )  )     {", "int   idx    =    path . lastIndexOf ( PATH _ SEPARATOR )  ;", "taskName    =    path . substring (  ( idx    +     1  )  )  ;", "prefix    =    path . substring (  0  ,     ( idx    +     1  )  )  ;", "String   projectPath    =     ( PATH _ SEPARATOR . equals ( prefix )  )     ?    prefix    :    path . substring (  0  ,    idx )  ;", "project    =    projectFinder . findProject ( projectPath ,    startFrom )  ;", "} else    {", "project    =    startFrom ;", "taskName    =    path ;", "prefix    =     \"  \"  ;", "}", "return   new   Resolved ( prefix ,    taskName ,    project )  ;", "}", "METHOD_END"], "methodName": ["resolvePath"], "fileName": "org.gradle.execution.taskpath.TaskPathResolver"}, {"methodBody": ["METHOD_START", "{", "return   System . out ;", "}", "METHOD_END"], "methodName": ["getOut"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "return   dynamicObject . getProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getProperties"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "return   target ;", "}", "METHOD_END"], "methodName": ["getScriptTarget"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "return   standardOutputCapture ;", "}", "METHOD_END"], "methodName": ["getStandardOutputCapture"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "return   dynamicObject . hasProperty ( property )  ;", "}", "METHOD_END"], "methodName": ["hasProperty"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "standardOutputCapture    =    services . get ( StandardOutputCapture . class )  ;", "setTarget ( target )  ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "this . target    =    target ;", "this . dynamicObject . setTarget ( target )  ;", "}", "METHOD_END"], "methodName": ["setScriptTarget"], "fileName": "org.gradle.groovy.scripts.BasicScript"}, {"methodBody": ["METHOD_START", "{", "if    ( source . getResource (  )  . isContentCached (  )  )     {", "return   source ;", "}", "return   new    ( source )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.groovy.scripts.CachingScriptSource"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderScope   classLoaderScope    =     _  _ scriptServices . get ( ClassLoaderScope . class )  ;", "return   new   ObjectConfigurationAction ( getFileResolver (  )  ,     _  _ scriptServices . get ( ScriptPluginFactory . class )  ,     _  _ scriptServices . get ( ScriptHandlerFactory . class )  ,    classLoaderScope ,     _  _ scriptServices . get ( TextResourceLoader . class )  ,    getScriptTarget (  )  )  ;", "}", "METHOD_END"], "methodName": ["createObjectConfigurationAction"], "fileName": "org.gradle.groovy.scripts.DefaultScript"}, {"methodBody": ["METHOD_START", "{", "return    \" script \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.groovy.scripts.DefaultScript"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptCompilerFactory . ScriptCompilerImpl ( source )  ;", "}", "METHOD_END"], "methodName": ["createCompiler"], "fileName": "org.gradle.groovy.scripts.DefaultScriptCompilerFactory"}, {"methodBody": ["METHOD_START", "{", "return   source . getClassName (  )  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.groovy.scripts.DelegatingScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   source . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.groovy.scripts.DelegatingScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   source . getFileName (  )  ;", "}", "METHOD_END"], "methodName": ["getFileName"], "fileName": "org.gradle.groovy.scripts.DelegatingScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   source . getResource (  )  ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.gradle.groovy.scripts.DelegatingScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "org.gradle.groovy.scripts.DelegatingScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.groovy.scripts.EmptyScript"}, {"methodBody": ["METHOD_START", "{", "return   contextClassloader ;", "}", "METHOD_END"], "methodName": ["getContextClassloader"], "fileName": "org.gradle.groovy.scripts.Script"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getScriptSource"], "fileName": "org.gradle.groovy.scripts.Script"}, {"methodBody": ["METHOD_START", "{", "this . contextClassloader    =    contextClassloader ;", "}", "METHOD_END"], "methodName": ["setContextClassloader"], "fileName": "org.gradle.groovy.scripts.Script"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "}", "METHOD_END"], "methodName": ["setScriptSource"], "fileName": "org.gradle.groovy.scripts.Script"}, {"methodBody": ["METHOD_START", "{", "return   lineNumber ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.gradle.groovy.scripts.ScriptCompilationException"}, {"methodBody": ["METHOD_START", "{", "return   scriptSource ;", "}", "METHOD_END"], "methodName": ["getScriptSource"], "fileName": "org.gradle.groovy.scripts.ScriptCompilationException"}, {"methodBody": ["METHOD_START", "{", "return    \" script _  \"     +     ( HashUtil . createCompactMD 5  ( resource . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.groovy.scripts.StringScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   resource . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.groovy.scripts.StringScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   getClassName (  )  ;", "}", "METHOD_END"], "methodName": ["getFileName"], "fileName": "org.gradle.groovy.scripts.StringScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.gradle.groovy.scripts.StringScriptSource"}, {"methodBody": ["METHOD_START", "{", "assertThat ( source . getClassName (  )  ,    matchesRegexp (  \" script _  [ a - z 0  -  9  ]  +  \"  )  )  ;", "assertThat ( source . getFileName (  )  ,    equalTo ( source . getClassName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["generatesClassNameAndSourceFileNameUsingHashOfText"], "fileName": "org.gradle.groovy.scripts.StringScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( source . getClassName (  )  ,    equalTo ( new   StringScriptSource (  \"  ?  \"  ,     \"  < content >  \"  )  . getClassName (  )  )  )  ;", "assertThat ( source . getClassName (  )  ,    not ( equalTo ( new   StringScriptSource (  \"  ?  \"  ,     \"  < other >  \"  )  . getClassName (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["sourcesWithDifferentTextHaveDifferentClassNames"], "fileName": "org.gradle.groovy.scripts.StringScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( source . getResource (  )  ,    instanceOf ( StringTextResource . class )  )  ;", "assertThat ( source . getResource (  )  . getText (  )  ,    equalTo (  \"  < content >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["usesProvidedContent"], "fileName": "org.gradle.groovy.scripts.StringScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( source . getDisplayName (  )  ,    equalTo (  \"  < description >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["usesProvidedDescription"], "fileName": "org.gradle.groovy.scripts.StringScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "String   name    =    StringUtils . substringBeforeLast ( StringUtils . substringAfterLast ( path ,     \"  /  \"  )  ,     \"  .  \"  )  ;", "StringBuilder   className    =    new   StringBuilder ( name . length (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( name . length (  )  )  ;    i +  +  )     {", "char   ch    =    name . charAt ( i )  ;", "className . append (  ( Character . isJavaIdentifierPart ( ch )     ?    ch    :     '  _  '  )  )  ;", "}", "if    (  !  ( Character . isJavaIdentifierStart ( className . charAt (  0  )  )  )  )     {", "className . insert (  0  ,     '  _  '  )  ;", "}", "className . setLength ( Math . min ( className . length (  )  ,     3  0  )  )  ;", "className . append (  '  _  '  )  ;", "className . append ( HashUtil . createCompactMD 5  ( path )  )  ;", "return   className . toString (  )  ;", "}", "METHOD_END"], "methodName": ["classNameFromPath"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "if    (  ( claName )     =  =    null )     {", "thiclaName    =    initClaName (  )  ;", "}", "return   claName ;", "}", "METHOD_END"], "methodName": ["getClassName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   resource . getDisplayName (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "ResourceLocation   location    =    resource . getLocation (  )  ;", "if    (  ( location . getFile (  )  )     !  =    null )     {", "return   location . getFile (  )  . getPath (  )  ;", "}", "if    (  ( location . getURI (  )  )     !  =    null )     {", "return   location . getURI (  )  . toString (  )  ;", "}", "return   getClassName (  )  ;", "}", "METHOD_END"], "methodName": ["getFileName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "return   resource ;", "}", "METHOD_END"], "methodName": ["getResource"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "URI   sourceUri    =    getResource (  )  . getLocation (  )  . getURI (  )  ;", "if    ( sourceUri    !  =    null )     {", "String   path    =    sourceUri . toString (  )  ;", "return   classNameFromPath ( path )  ;", "}", "return    \" script _  \"     +     ( HashUtil . createCompactMD 5  ( resource . getText (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["initClassName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSource"}, {"methodBody": ["METHOD_START", "{", "scriptFile . createNewFile (  )  ;", "source    =    forFile ( scriptFile )  ;", "assertThat ( source . getResource (  )  ,    instanceOf ( UriTextResource . class )  )  ;", "assertThat ( source . getResource (  )  . getFile (  )  ,    equalTo ( this . scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getFile (  )  ,    equalTo ( this . scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    equalTo ( scriptFileUri )  )  ;", "}", "METHOD_END"], "methodName": ["canConstructSourceFromFile"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "scriptFile . createNewFile (  )  ;", "source    =    forUri ( scriptFileUri )  ;", "assertThat ( source . getResource (  )  ,    instanceOf ( UriTextResource . class )  )  ;", "assertThat ( source . getResource (  )  . getFile (  )  ,    equalTo ( scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getCharset (  )  ,    equalTo ( Charset . forName (  \" utf -  8  \"  )  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getFile (  )  ,    equalTo ( scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    equalTo ( this . scriptFileUri )  )  ;", "}", "METHOD_END"], "methodName": ["canConstructSourceFromFileURI"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "URI   uri    =    createJar (  )  ;", "source    =    forUri ( uri )  ;", "assertThat ( source . getResource (  )  ,    instanceOf ( UriTextResource . class )  )  ;", "assertNull ( source . getResource (  )  . getFile (  )  )  ;", "assertNull ( source . getResource (  )  . getCharset (  )  )  ;", "assertNull ( source . getResource (  )  . getLocation (  )  . getFile (  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    equalTo ( uri )  )  ;", "}", "METHOD_END"], "methodName": ["canConstructSourceFromJarURI"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    new   TextResourceScriptSource ( new   StringTextResource (  \"  < string >  \"  ,     \" resource   content \"  )  )  ;", "assertThat ( source . getResource (  )  ,    instanceOf ( StringTextResource . class )  )  ;", "assertThat ( source . getResource (  )  . getFile (  )  ,    nullValue (  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getFile (  )  ,    nullValue (  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    nullValue (  )  )  ;", "assertThat ( source . getDisplayName (  )  ,    equalTo (  \"  < string >  \"  )  )  ;", "assertThat ( source . getClassName (  )  ,    equalTo (  \" script _  5 z 2 up 7 fl 2 zfks 7 lm 6 sqlalp 1 q \"  )  )  ;", "}", "METHOD_END"], "methodName": ["canConstructSourceFromStringResource"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( scriptFile )  ;", "assertThat ( source . getResource (  )  ,    instanceOf ( EmptyFileTextResource . class )  )  ;", "assertNull ( source . getResource (  )  . getFile (  )  )  ;", "assertNull ( source . getResource (  )  . getCharset (  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getFile (  )  ,    equalTo ( scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    equalTo ( scriptFileUri )  )  ;", "assertThat ( source . getResource (  )  . getText (  )  ,    equalTo (  \"  \"  )  )  ;", "assertTrue ( source . getResource (  )  . isContentCached (  )  )  ;", "assertTrue ( source . getResource (  )  . getHasEmptyContent (  )  )  ;", "assertTrue ( source . getResource (  )  . getExists (  )  )  ;", "}", "METHOD_END"], "methodName": ["convenienceMethodReplacesFileThatDoesNotExistWithEmptyScript"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "new   TestFile ( scriptFile )  . write (  \" content \"  )  ;", "ScriptSource   source    =    forFile ( scriptFile )  ;", "assertThat ( source ,    instanceOf (  . class )  )  ;", "assertThat ( source . getResource (  )  . getFile (  )  ,    equalTo ( scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getCharset (  )  ,    equalTo ( Charset . forName (  \" utf -  8  \"  )  )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getFile (  )  ,    equalTo ( scriptFile )  )  ;", "assertThat ( source . getResource (  )  . getLocation (  )  . getURI (  )  ,    equalTo ( scriptFileUri )  )  ;", "assertThat ( source . getResource (  )  . getText (  )  ,    equalTo (  \" content \"  )  )  ;", "assertFalse ( source . getResource (  )  . isContentCached (  )  )  ;", "assertFalse ( source . getResource (  )  . getHasEmptyContent (  )  )  ;", "assertTrue ( source . getResource (  )  . getExists (  )  )  ;", "}", "METHOD_END"], "methodName": ["convenienceMethodScriptForFileThatHasContent"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "TestFile   jarFile    =    tmpDir . getTestDirectory (  )  . file (  \" test . jar \"  )  ;", "testDir . file (  \" ignoreme \"  )  . write (  \" content \"  )  ;", "testDir . zipTo ( jarFile )  ;", "return   new   URI ( String . format (  \" jar :  % s !  / build \"  ,    jarFile . toURI (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createJar"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( new   File ( testDir ,     \" name -  +  . chars . gradle \"  )  )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \" name _  _  _ chars _  [  0  -  9 a - z ]  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["encodesReservedCharactersInClassName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source 1     =    forFile ( new   File ( testDir ,     \" build . gradle \"  )  )  ;", "ScriptSource   source 2     =    forFile ( new   File ( testDir ,     \" subdir / build . gradle \"  )  )  ;", "assertThat ( source 1  . getClassName (  )  ,    not ( equalTo ( source 2  . getClassName (  )  )  )  )  ;", "ScriptSource   source 3     =    forFile ( new   File ( testDir ,     \" build . gradle \"  )  )  ;", "assertThat ( source 1  . getClassName (  )  ,    equalTo ( source 3  . getClassName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filesWithSameNameAndDifferentPathHaveDifferentClassName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source 1     =    forFile ( new   File ( testDir ,     \" build . gradle \"  )  )  ;", "ScriptSource   source 2     =    forUri ( new   URI (  \" http :  /  / localhost / build . gradle \"  )  )  ;", "assertThat ( source 1  . getClassName (  )  ,    not ( equalTo ( source 2  . getClassName (  )  )  )  )  ;", "ScriptSource   source 3     =    forFile ( new   File ( testDir ,     \" build . gradle \"  )  )  ;", "assertThat ( source 1  . getClassName (  )  ,    equalTo ( source 3  . getClassName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["filesWithSameNameAndUriHaveDifferentClassName"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "return   new   TextResourceScriptSource ( resourceLoader . loadFile (  \"  < file - type >  \"  ,    scriptFile )  )  ;", "}", "METHOD_END"], "methodName": ["forFile"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "return   new   TextResourceScriptSource ( resourceLoader . loadUri (  \"  < file - type >  \"  ,    scriptFileUri )  )  ;", "}", "METHOD_END"], "methodName": ["forUri"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( scriptFile )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \" build _  [  0  -  9 a - z ]  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["generatesClassNameFromFileNameByRemovingExtensionAndAddingHashOfFileURL"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forUri ( createJar (  )  )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \" build _  [  0  -  9 a - z ]  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["generatesClassNameFromFileNameByRemovingExtensionAndAddingHashOfJarURL"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( new   File ( testDir ,     \"  1  2  3  \"  )  )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \"  _  1  2  3  _  [  0  -  9 a - z ]  +  \"  )  )  ;", "source    =    forFile ( new   File ( testDir ,     \"  -  \"  )  )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \"  _  _  [  0  -  9 a - z ]  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["prefixesClassNameWhenFirstCharacterIsNotValidIdentifierStartChar"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "testDir    =    tmpDir . createDir (  \" scripts \"  )  ;", "scriptFile    =    new   File ( testDir ,     \" build . script \"  )  ;", "scriptFileUri    =    scriptFile . toURI (  )  ;", "createJar (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( new   File ( testDir ,     \" a - long - file - name -  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  . gradle \"  )  )  ;", "assertThat ( source . getClassName (  )  ,    Matchers . matchesRegexp (  \" a _ long _ file _ name _  1  2  3  4  5  6  7  8  9  0  1  2  3  _  [  0  -  9 a - z ]  +  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["truncatesClassNameAt30Characters"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( scriptFile )  ;", "assertThat ( source . getDisplayName (  )  ,    equalTo ( String . format (  \"  < file - type >     '  % s '  \"  ,    scriptFile . getAbsolutePath (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptFileNameToBuildDescription"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forUri ( scriptFileUri )  ;", "assertThat ( source . getDisplayName (  )  ,    equalTo ( String . format (  \"  < file - type >     '  % s '  \"  ,    scriptFile . getAbsolutePath (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptFileNameToBuildDescriptionWhenUsingFileUri"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forUri ( new   URI (  \" http :  /  / www . gradle . org / unknown . txt \"  )  )  ;", "assertThat ( source . getDisplayName (  )  ,    equalTo ( String . format (  \"  < file - type >     ' http :  /  / www . gradle . org / unknown . txt '  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptFileNameToBuildDescriptionWhenUsingHttpUri"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forFile ( scriptFile )  ;", "assertThat ( source . getFileName (  )  ,    equalTo ( scriptFile . getAbsolutePath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptFilePathForFileNameUsingFile"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forUri ( scriptFileUri )  ;", "assertThat ( source . getFileName (  )  ,    equalTo ( scriptFile . getAbsolutePath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptFilePathForFileNameUsingFileUri"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   source    =    forUri ( new   URI (  \" http :  /  / www . gradle . org / unknown . txt \"  )  )  ;", "assertThat ( source . getFileName (  )  ,    equalTo (  \" http :  /  / www . gradle . org / unknown . txt \"  )  )  ;", "}", "METHOD_END"], "methodName": ["usesScriptUriForFileNameUsingHttpUri"], "fileName": "org.gradle.groovy.scripts.TextResourceScriptSourceTest"}, {"methodBody": ["METHOD_START", "{", "return   hasImperativeStatements ;", "}", "METHOD_END"], "methodName": ["getHasImperativeStatements"], "fileName": "org.gradle.groovy.scripts.internal.BuildScriptData"}, {"methodBody": ["METHOD_START", "{", "new   FilteringScriptTransformer ( filter )  . register ( compilationUnit )  ;", "new   TaskDefinitionScriptTransformer (  )  . register ( compilationUnit )  ;", "new   FixMainScriptTransformer (  )  . register ( compilationUnit )  ;", "new   StatementLabelsScriptTransformer (  )  . register ( compilationUnit )  ;", "new   ModelBlockTransformer ( scriptSource . getDisplayName (  )  ,    scriptSource . getResource (  )  . getLocation (  )  . getURI (  )  )  . register ( compilationUnit )  ;", "imperativeStatementDetectingTransformer . register ( compilationUnit )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.groovy.scripts.internal.BuildScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "ScriptCacheKey   key    =    new   ScriptCacheKey ( source . getClassName (  )  ,    classLoader ,    operation . getId (  )  )  ;", ". CachedCompiledScript   cached    =    cachedCompiledScripts . get ( key )  ;", "HashCode   hash    =    hasher . hash ( source )  ;", "if    ( cached    !  =    null )     {", "if    ( hash . equals ( cached . hash )  )     {", "return   Cast . uncheckedCast ( cached . compiledScript )  ;", "}", "}", "CompiledScript < T ,    M >    compiledScript    =    delegate . compile ( source ,    classLoader ,    classLoaderId ,    operation ,    scriptBaseClass ,    verifier )  ;", "cachedCompiledScripts . put ( key ,    new    . CachedCompiledScript ( hash ,    compiledScript )  )  ;", "return   compiledScript ;", "}", "METHOD_END"], "methodName": ["getOrCompile"], "fileName": "org.gradle.groovy.scripts.internal.CrossBuildInMemoryCachingScriptClassCache"}, {"methodBody": ["METHOD_START", "{", "final   Transformer   transformer    =     ( extractingTransformer    !  =    null )     ?    extractingTransformer . getTransformer (  )     :    null ;", "logger . info (  \" Compiling    {  }    using    {  }  .  \"  ,    source . getDisplayName (  )  ,     ( transformer    !  =    null    ?    transformer . getClass (  )  . getSimpleName (  )     :     \" no   transformer \"  )  )  ;", "final    . EmptyScriptDetector   emptyScriptDetector    =    new    . EmptyScriptDetector (  )  ;", "final    . PackageStatementDetector   packageDetector    =    new    . PackageStatementDetector (  )  ;", "GroovyClassLoader   groovyClassLoader    =    new   GroovyClassLoader ( classLoader ,    configuration ,    false )     {", "@ Override", "protected   CompilationUnit   createCompilationUnit ( CompilerConfiguration   compilerConfiguration ,    CodeSource   codeSource )     {", "CompilationUnit   compilationUnit    =    new    . CustomCompilationUnit ( source ,    compilerConfiguration ,    codeSource ,    customVerifier ,    this )  ;", "if    ( transformer    !  =    null )     {", "transformer . register ( compilationUnit )  ;", "}", "compilationUnit . addPhaseOperation ( packageDetector ,    CANONICALIZATION )  ;", "compilationUnit . addPhaseOperation ( emptyScriptDetector ,    CANONICALIZATION )  ;", "return   compilationUnit ;", "}", "}  ;", "groovyClassLoader . setResourceLoader (  . NO _ OP _ GROOVY _ RESOURCE _ LOADER )  ;", "String   scriptText    =    source . getResource (  )  . getText (  )  ;", "String   scriptName    =    source . getClassName (  )  ;", "GroovyCodeSource   codeSource    =    new   GroovyCodeSource (  ( scriptText    =  =    null    ?     \"  \"     :    scriptText )  ,    scriptName ,     \"  / groovy / script \"  )  ;", "try    {", "try    {", "groovyClassLoader . parseClass ( codeSource ,    false )  ;", "}    catch    ( MultipleCompilationErrorsException   e )     {", "wrapCompilationFailure ( source ,    e )  ;", "}    catch    ( CompilationFailedException   e )     {", "throw   new   GradleException ( String . format (  \" Could   not   compile    % s .  \"  ,    source . getDisplayName (  )  )  ,    e )  ;", "}", "if    ( packageDetector . hasPackageStatement )     {", "throw   new   UnsupportedOperationException ( String . format (  \"  % s   should   not   contain   a   package   statement .  \"  ,    StringUtils . capitalize ( source . getDisplayName (  )  )  )  )  ;", "}", "serializeMetadata ( source ,    extractingTransformer ,    metadataDir ,    emptyScriptDetector . isEmptyScript (  )  ,    emptyScriptDetector . getHasMethods (  )  )  ;", "}    finally    {", "ClassLoaderUtils . tryClose ( groovyClassLoader )  ;", "}", "}", "METHOD_END"], "methodName": ["compileScript"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptCompilationHandler"}, {"methodBody": ["METHOD_START", "{", "CompilerConfiguration   configuration    =    new   CompilerConfiguration (  )  ;", "configuration . seBaseClass ( scriptBaseClass . getName (  )  )  ;", "return   configuration ;", "}", "METHOD_END"], "methodName": ["createBaseCompilerConfiguration"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptCompilationHandler"}, {"methodBody": ["METHOD_START", "{", "File   metadataFile    =    new   File ( metadataDir ,    DefaultScriptCompilationHandler . METADATA _ FILE _ NAME )  ;", "try    {", "GFileUtils . mkdirs ( metadataDir )  ;", "KryoBackedEncoder   encoder    =    new   KryoBackedEncoder ( new   FileOutputStream ( metadataFile )  )  ;", "try    {", "byte   flags    =     (  ( byte )     (  ( emptyScript    ?    DefaultScriptCompilationHandler . EMPTY _ FLAG    :     0  )     |     ( hasMethods    ?    DefaultScriptCompilationHandler . HAS _ METHODS _ FLAG    :     0  )  )  )  ;", "encoder . writeByte ( flags )  ;", "if    (  ( extractingTransformer    !  =    null )     &  &     (  ( extractingTransformer . getDataSerializer (  )  )     !  =    null )  )     {", "Serializer < M >    serializer    =    extractingTransformer . getDataSerializer (  )  ;", "serializer . write ( encoder ,    extractingTransformer . getExtractedData (  )  )  ;", "}", "}    finally    {", "encoder . close (  )  ;", "}", "}    catch    ( Exception   e )     {", "throw   new   GradleException ( String . format (  \" Failed   to   serialize   script   metadata   extracted   for    % s \"  ,    scriptSource . getDisplayName (  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["serializeMetadata"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptCompilationHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   message    :    e . getErrorCollector (  )  . getErrors (  )  )     {", "if    ( message   instanceof   SyntaxErrorMessage )     {", "try    {", "SyntaxErrorMessage   syntaxErrorMessage    =     (  ( SyntaxErrorMessage )     ( message )  )  ;", "Field   sourceField    =    SyntaxErrorMessage . class . getDeclaredField (  \" source \"  )  ;", "sourceField . setAccessible ( true )  ;", "SourceUnit   sourceUnit    =     (  ( SourceUnit )     ( sourceField . get ( syntaxErrorMessage )  )  )  ;", "Field   nameField    =    SourceUnit . class . getDeclaredField (  \" name \"  )  ;", "nameField . setAccessible ( true )  ;", "nameField . set ( sourceUnit ,    source . getDisplayName (  )  )  ;", "}    catch    ( Exception   failure )     {", "throw   UncheckedException . throwAsUncheckedException ( failure )  ;", "}", "}", "}", "SyntaxException   syntaxError    =    e . getErrorCollector (  )  . getSyntaxError (  0  )  ;", "Integer   lineNumber    =     ( syntaxError    =  =    null )     ?    null    :    syntaxError . getLine (  )  ;", "throw   new   Exception ( String . format (  \" Could   not   compile    % s .  \"  ,    source . getDisplayName (  )  )  ,    e ,    source ,    lineNumber )  ;", "}", "METHOD_END"], "methodName": ["wrapCompilationFailure"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptCompilationHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptRunnerFactory . ScriptRunnerImpl < T ,    M >  ( script ,    source ,    contextClassLoader )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactory"}, {"methodBody": ["METHOD_START", "{", "ScriptRunner <  ?  ,    Void >    scriptRunner    =    factory . create ( compiledScriptMock ,    scriptSourceDummy ,    classLoaderDummy )  ;", "assertThat ( scriptRunner ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotLoadScriptWhenScriptRunnerCreated"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "allowing ( compiledScriptMock )  . loadClass (  )  ;", "will ( returnValue ( Script . class )  )  ;", "allowing ( instantiatorMock )  . newInstance ( Script . class )  ;", "will ( returnValue ( scriptMock )  )  ;", "allowing ( scriptMock )  . getStandardOutputCapture (  )  ;", "will ( returnValue ( standardOutputCaptureMock )  )  ;", "allowing ( scriptMock )  . geSource (  )  ;", "will ( returnValue ( scriptSourceDummy )  )  ;", "allowing ( scriptMock )  . getContextClassloader (  )  ;", "will ( returnValue ( classLoaderDummy )  )  ;", "allowing ( scriptMock )  . seSource ( scriptSourceDummy )  ;", "allowing ( scriptMock )  . setContextClassloader ( classLoaderDummy )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["expectScriptInstantiated"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "ScriptRunner <  ?  ,    Void >    scriptRunner    =    factory . create ( compiledScriptMock ,    scriptSourceDummy ,    classLoaderDummy )  ;", "context . checking ( new   Expectations (  )     {", "{", "allowing ( compiledScriptMock )  . getRunDoesSomething (  )  ;", "will ( returnValue ( false )  )  ;", "}", "}  )  ;", "scriptRunner . run ( target ,    scriptServices )  ;", "}", "METHOD_END"], "methodName": ["runDoesNothingWhenEmptyScriptIsRun"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "context . checking ( new   Expectations (  )     {", "{", "ignoring ( SourceDummy )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "ScriptRunner <  ?  ,    Void >    scriptRunner    =    factory . create ( compiledScriptMock ,    scriptSourceDummy ,    classLoaderDummy )  ;", "expectScriptInstantiated (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "allowing ( compiledScriptMock )  . getRunDoesSomething (  )  ;", "will ( returnValue ( true )  )  ;", "one ( scriptExecutionListenerMock )  . scriptClassLoaded ( scriptSourceDummy ,    Script . class )  ;", "inSequence ( sequence )  ;", "one ( scriptMock )  . init ( target ,    scriptServices )  ;", "inSequence ( sequence )  ;", "one ( standardOutputCaptureMock )  . start (  )  ;", "inSequence ( sequence )  ;", "one ( scriptMock )  . run (  )  ;", "inSequence ( sequence )  ;", "will ( doAll ( new   Action (  )     {", "public   void   describeTo ( Description   description )     {", "description . appendValue (  \" check   context   classloader \"  )  ;", "}", "public   Object   invoke ( Invocation   invocation )    throws   Throwable    {", "assertThat ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    sameInstance ( classLoaderDummy )  )  ;", "return   null ;", "}", "}  )  )  ;", "one ( standardOutputCaptureMock )  . stop (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "ClassLoader   originalClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "assertThat ( originalClassLoader ,    not ( sameInstance ( classLoaderDummy )  )  )  ;", "scriptRunner . run ( target ,    scriptServices )  ;", "assertThat ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    sameInstance ( originalClassLoader )  )  ;", "}", "METHOD_END"], "methodName": ["setsUpAndTearsDownWhenNonEmptyScriptIsRun"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "final   RuntimeException   failure    =    new   RuntimeException (  )  ;", "<  ?  ,    Void >    scriptRunner    =    factory . create ( compiledScriptMock ,    scriptSourceDummy ,    classLoaderDummy )  ;", "expectScriptInstantiated (  )  ;", "context . checking ( new   Expectations (  )     {", "{", "Sequence   sequence    =    context . sequence (  \" seq \"  )  ;", "allowing ( compiledScriptMock )  . getRunDoesSomething (  )  ;", "will ( returnValue ( true )  )  ;", "one ( scriptExecutionListenerMock )  . scriptClassLoaded ( scriptSourceDummy ,    Script . class )  ;", "inSequence ( sequence )  ;", "one ( scriptMock )  . init ( target ,    scriptServices )  ;", "inSequence ( sequence )  ;", "one ( standardOutputCaptureMock )  . start (  )  ;", "inSequence ( sequence )  ;", "one ( scriptMock )  . run (  )  ;", "inSequence ( sequence )  ;", "will ( throwException ( failure )  )  ;", "one ( standardOutputCaptureMock )  . stop (  )  ;", "inSequence ( sequence )  ;", "}", "}  )  ;", "ClassLoader   originalClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "assertThat ( originalClassLoader ,    not ( sameInstance ( classLoaderDummy )  )  )  ;", "try    {", "scriptRunner . run ( target ,    scriptServices )  ;", "fail (  )  ;", "}    catch    ( GradleScriptException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" A   problem   occurred   evaluating    < script - to - string >  .  \"  )  )  ;", "assertThat ( e . getCause (  )  ,    sameInstance (  (  ( Throwable )     ( failure )  )  )  )  ;", "}", "assertThat ( Thread . currentThread (  )  . getContextClassLoader (  )  ,    sameInstance ( originalClassLoader )  )  ;", "}", "METHOD_END"], "methodName": ["wrapsExecutionExceptionAndRestoresStateWhenScriptFails"], "fileName": "org.gradle.groovy.scripts.internal.DefaultScriptRunnerFactoryTest"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( cache . getBaseDir (  )  ,     \" classes \"  )  ;", "}", "METHOD_END"], "methodName": ["classesDir"], "fileName": "org.gradle.groovy.scripts.internal.FileCacheBackedScriptClassCompiler"}, {"methodBody": ["METHOD_START", "{", "classLoaderCache . remove ( classLoaderId )  ;", "return   new    . EmptyCompiledScript < T ,    M >  ( operation )  ;", "}", "METHOD_END"], "methodName": ["emptyCompiledScript"], "fileName": "org.gradle.groovy.scripts.internal.FileCacheBackedScriptClassCompiler"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( cache . getBaseDir (  )  ,     \" metadata \"  )  ;", "}", "METHOD_END"], "methodName": ["metadataDir"], "fileName": "org.gradle.groovy.scripts.internal.FileCacheBackedScriptClassCompiler"}, {"methodBody": ["METHOD_START", "{", "if    ( type . getName (  )  . equals ( iType . getName (  )  )  )     {", "addError (  (  (  (  (  (  (  \" reference   to    \"     +    name )     +     \"    is   ambiguous ,    both   class    \"  )     +     ( type . getName (  )  )  )     +     \"    and    \"  )     +     ( iType . getName (  )  )  )     +     \"    match \"  )  ,    type )  ;", "} else    {", "type . setRedirect ( iType )  ;", "}", "}", "METHOD_END"], "methodName": ["ambiguousClass"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( newValue   instanceof   PropertyExpression )     {", "PropertyExpression   pe    =     (  ( PropertyExpression )     ( newValue )  )  ;", "if    (  !  (  ( pe . getObjectExpression (  )  )    instanceof   ClassExpression )  )     {", "addError (  (  (  \" unable   to   find   class    '  \"     +     ( pe . getText (  )  )  )     +     \"  '    for   annotation   attribute   constant \"  )  ,    pe . getObjectExpression (  )  )  ;", "}", "} else", "if    ( newValue   instanceof   ListExpression )     {", "ListExpression   le    =     (  ( ListExpression )     ( newValue )  )  ;", "for    ( Expression   e    :    le . getExpressions (  )  )     {", "checkAnnotationMemberValue ( e )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkAnnotationMemberValue"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( originalNode . isInterface (  )  )  )     {", "if    ( parentToCompare    =  =    null )     {", "return ;", "}", "if    ( originalNode    =  =     ( parentToCompare . redirect (  )  )  )     {", "addError (  (  (  (  \" Cyclic   inheritance   involving    \"     +     ( parentToCompare . getName (  )  )  )     +     \"    in   class    \"  )     +     ( originalNode . getName (  )  )  )  ,    originalNode )  ;", "return ;", "}", "if    (  ( interfacesToCompare    !  =    null )     &  &     (  ( interfacesToCompare . length )     >     0  )  )     {", "for    ( ClassNode   intfToCompare    :    interfacesToCompare )     {", "if    ( originalNode    =  =     ( intfToCompare . redirect (  )  )  )     {", "addError (  (  (  \" Cycle   detected :    the   type    \"     +     ( originalNode . getName (  )  )  )     +     \"    cannot   implement   itself \"  )  ,    originalNode )  ;", "return ;", "}", "}", "}", "if    ( parentToCompare    =  =     ( ClassHelper . OBJECT _ TYPE )  )     {", "return ;", "}", "checkCyclicInheritence ( originalNode ,    parentToCompare . getUnrdSuperClass (  )  ,    null )  ;", "} else    {", "if    (  ( interfacesToCompare    !  =    null )     &  &     (  ( interfacesToCompare . length )     >     0  )  )     {", "for    ( ClassNode   intfToCompare    :    interfacesToCompare )     {", "if    ( originalNode    =  =     ( intfToCompare . redirect (  )  )  )     {", "addError (  (  (  (  \" Cyclic   inheritance   involving    \"     +     ( intfToCompare . getName (  )  )  )     +     \"    in   interface    \"  )     +     ( originalNode . getName (  )  )  )  ,    originalNode )  ;", "return ;", "}", "}", "for    ( ClassNode   intf    :    interfacesToCompare )     {", "checkCyclicInheritence ( originalNode ,    null ,    intf . getInterfaces (  )  )  ;", "}", "} else    {", "return ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkCyclicInheritence"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( expression . isImplicitThis (  )  )     {", "return ;", "}", "String   prop    =    expression . getPropertyAsString (  )  ;", "if    ( prop    =  =    null )     {", "return ;", "}", "if    (  (  !  ( prop . equals (  \" this \"  )  )  )     &  &     (  !  ( prop . equals (  \" super \"  )  )  )  )     {", "return ;", "}", "ClassNode   type    =    expression . getObjectExpression (  )  . getType (  )  ;", "if    (  ( expression . getObjectExpression (  )  )    instanceof   ClassExpression )     {", "if    (  (  !  (  ( currentClass )    instanceof   InnerClassNode )  )     &  &     (  !  ( TraisTrait ( type )  )  )  )     {", "addError (  \" The   usage   of    ' Class . this '    and    ' Class . super '    is   only   allowed   in   nested / inner   classes .  \"  ,    expression )  ;", "return ;", "}", "if    (  (  (  (  (  ( currentScope )     !  =    null )     &  &     (  !  ( currentScope . isInStaticContext (  )  )  )  )     &  &     ( TraisTrait ( type )  )  )     &  &     (  \" super \"  . equals ( prop )  )  )     &  &     ( directlyImplementsTrait ( type )  )  )     {", "return ;", "}", "ClassNode   iterType    =    currentClass ;", "while    ( iterType    !  =    null )     {", "if    ( iterType . equals ( type )  )     {", "break ;", "}", "iterType    =    iterType . getOuterClass (  )  ;", "}", "if    ( iterType    =  =    null )     {", "addError (  (  (  (  (  \" The   class    '  \"     +     ( type . getName (  )  )  )     +     \"  '    needs   to   be   an   outer   class   of    '  \"  )     +     ( currentClass . getName (  )  )  )     +     \"  '    when   using    '  . this '    or    '  . super '  .  \"  )  ,    expression )  ;", "}", "if    (  (  ( currentClass . getModifiers (  )  )     &     ( Opcodes . ACC _ STATIC )  )     =  =     0  )     {", "return ;", "}", "if    (  (  ( currentScope )     !  =    null )     &  &     (  !  ( currentScope . isInStaticContext (  )  )  )  )     {", "return ;", "}", "addError (  (  (  \" The   usage   of    ' Class . this '    and    ' Class . super '    within   static   nested   class    '  \"     +     ( currentClass . getName (  )  )  )     +     \"  '    is   not   allowed   in   a   static   context .  \"  )  ,    expression )  ;", "}", "}", "METHOD_END"], "methodName": ["checkThisAndSuperAsPropertyAccess"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "LinkedList < Expression >    stack    =    new   LinkedList < Expression >  (  )  ;", "ClassExpression   found    =    null ;", "for    ( Expression   it    =    pe ;    it    !  =    null ;    it    =     (  ( PropertyExpression )     ( it )  )  . getObjectExpression (  )  )     {", "if    ( it   instanceof   ClassExpression )     {", "found    =     (  ( ClassExpression )     ( it )  )  ;", "break ;", "} else", "if    (  !  (  ( it . getClass (  )  )     =  =     ( PropertyExpression . class )  )  )     {", "return   pe ;", "}", "stack . addFirst ( it )  ;", "}", "if    ( found    =  =    null )     {", "return   pe ;", "}", "if    ( stack . isEmpty (  )  )     {", "return   pe ;", "}", "Object   stackElement    =    stack . removeFirst (  )  ;", "if    (  !  (  ( stackElement . getClass (  )  )     =  =     ( PropertyExpression . class )  )  )     {", "return   pe ;", "}", "PropertyExpression   classPropertyExpression    =     (  ( PropertyExpression )     ( stackElement )  )  ;", "String   propertyNamePart    =    classPropertyExpression . getPropertyAsString (  )  ;", "if    (  ( propertyNamePart    =  =    null )     |  |     (  !  ( propertyNamePart . equals (  \" class \"  )  )  )  )     {", "return   pe ;", "}", "found . setSourcePoion ( classPropertyExpression )  ;", "if    ( stack . isEmpty (  )  )     {", "return   found ;", "}", "stackElement    =    stack . removeFirst (  )  ;", "if    (  !  (  ( stackElement . getClass (  )  )     =  =     ( PropertyExpression . class )  )  )     {", "return   pe ;", "}", "PropertyExpression   classPropertyExpressionContainer    =     (  ( PropertyExpression )     ( stackElement )  )  ;", "classPropertyExpressionContainer . setObjectExpression ( found )  ;", "return   pe ;", "}", "METHOD_END"], "methodName": ["correctClassClassChain"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNode [  ]    interfaces    =    currentClass . getInterfaces (  )  ;", "if    ( interfaces    =  =    null )     {", "return   currentClass . getSuperClass (  )  . equals ( trait )  ;", "}", "for    ( ClassNode   node    :    interfaces )     {", "if    ( node . equals ( trait )  )     {", "return   true ;", "}", "}", "return   currentClass . getSuperClass (  )  . equals ( trait )  ;", "}", "METHOD_END"], "methodName": ["directlyImplementsTrait"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( newDeclExpr . getDeclaringClass (  )  )     =  =    null )     &  &     (  ( currentMethod )     !  =    null )  )     {", "newDeclExpr . setDeclaringClass ( currentMethod . getDeclaringClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["fixDeclaringClass"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return   deprecatedImports ;", "}", "METHOD_END"], "methodName": ["getDeprecatedImports"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( node . isInterface (  )     ?     \" interface \"     :     \" class \"  )     +     \"     '  \"  )     +     ( node . getName (  )  )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return   source ;", "}", "METHOD_END"], "methodName": ["getSourceUnit"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( op    =  =     ( Types . ARRAY _ EXPRESSION )  )     |  |     ( op    =  =     ( Types . LEFT _ SQUARE _ BRACKET )  )  )     |  |     ( op    =  =     ( Types . SYNTH _ LIST )  )  )     |  |     ( op    =  =     ( Types . SYNTH _ MAP )  )  ;", "}", "METHOD_END"], "methodName": ["isLeftSquareBracket"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "boolean   doInitialClassTest    =    true ;", "String   name    =     \"  \"  ;", "for    ( Expression   it    =    pe ;    it    !  =    null ;    it    =     (  ( PropertyExpression )     ( it )  )  . getObjectExpression (  )  )     {", "if    ( it   instanceof   VariableExpression )     {", "VariableExpression   ve    =     (  ( VariableExpression )     ( it )  )  ;", "if    (  ( ve . isSuperExpression (  )  )     |  |     ( ve . isThisExpression (  )  )  )     {", "return   null ;", "}", "String   varName    =    vetName (  )  ;", "if    ( doInitialClassTest )     {", "if    (  !  ( testVanillaNameForClass ( varName )  )  )     {", "return   null ;", "}", "doInitialClassTest    =    false ;", "name    =    varName ;", "} else    {", "name    =     ( varName    +     \"  .  \"  )     +    name ;", "}", "break ;", "} else", "if    (  ( it . getClass (  )  )     !  =     ( PropertyExpression . class )  )     {", "return   null ;", "} else    {", "PropertyExpression   current    =     (  ( PropertyExpression )     ( it )  )  ;", "String   propertyPart    =    current . getPropertyAsString (  )  ;", "if    (  ( propertyPart    =  =    null )     |  |     ( propertyPart . equals (  \" class \"  )  )  )     {", "return   null ;", "}", "if    ( doInitialClassTest )     {", "if    (  !  ( testVanillaNameForClass ( propertyPart )  )  )     {", "return   null ;", "}", "doInitialClassTest    =    false ;", "name    =    propertyPart ;", "} else    {", "name    =     ( propertyPart    +     \"  .  \"  )     +    name ;", "}", "}", "}", "if    (  ( name . lth (  )  )     =  =     0  )     {", "return   null ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["lookupClassName"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "int   lastPoint    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( lastPoint    >     0  )     {", "name    =     (  ( name . substring (  0  ,    lastPoint )  )     +     \"  $  \"  )     +     ( name . substring (  ( lastPoint    +     1  )  )  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["replaceLastPoint"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return   name . replace (  '  .  '  ,     '  $  '  )  ;", "}", "METHOD_END"], "methodName": ["replacePoints"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return   resolve ( type ,    true ,    true ,    true )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "resolveGenericsTypes ( type . getGenericsTypes (  )  )  ;", "if    (  ( type . isd (  )  )     |  |     ( type . isPrimaryClassNode (  )  )  )     {", "return   true ;", "}", "if    ( type . isArray (  )  )     {", "ClassNode   element    =    type . getComponentType (  )  ;", "boolean   resolved    =    resolve ( element ,    testModuleImports ,    testDefaultImports ,    testStaticInnerClasses )  ;", "if    ( resolved )     {", "ClassNode   cn    =    element . makeArray (  )  ;", "type . setRedirect ( cn )  ;", "}", "return   resolved ;", "}", "if    (  ( currentClass )     =  =    type )     {", "return   true ;", "}", "String   name    =    type . getName (  )  ;", "if    (  ( genericParameterNames . get ( name )  )     !  =    null )     {", "GenericsType   gt    =    genericParameterNames . get ( name )  ;", "type . setRedirect ( gt . getType (  )  )  ;", "type . setGenericsTypes ( new   GenericsType [  ]  {    gt    }  )  ;", "type . setGenericsPlaceHolder ( true )  ;", "return   true ;", "}", "if    ( currentClass . getNameWithoutPackage (  )  . equals ( name )  )     {", "type . setRedirect ( currentClass )  ;", "return   true ;", "}", "if    ( type . hasPackageName (  )  )     {", "if    ( resolveFromr ( type ,    name )  )     {", "return   true ;", "}", "}", "return    (  (  (  (  ( resolveNestedClass ( type )  )     |  |     ( resolveFromModule ( type ,    testModuleImports )  )  )     |  |     ( resolveFromCompileUnit ( type )  )  )     |  |     ( resolveFromDefaultImports ( type ,    testDefaultImports )  )  )     |  |     ( resolveFromStaticInnerClasses ( type ,    testStaticInnerClasses )  )  )     |  |     ( resolveToOuter ( type )  )  ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedClassWithPackage )     {", "return   false ;", "}", "ModuleNode   module    =    currentClass . getModule (  )  ;", "if    ( module    =  =    null )     {", "return   false ;", "}", "String   name    =    type . getName (  )  ;", "String   pname    =    name ;", "int   index    =    name . length (  )  ;", "while    ( true )     {", "pname    =    name . substring (  0  ,    index )  ;", "ClassNode   aliasedNode    =    null ;", "ImportNode   importNode    =    module . getImport ( pname )  ;", "if    (  ( importNode    !  =    null )     &  &     ( importNode    !  =     ( currImportNode )  )  )     {", "aliasedNode    =    importNode . getType (  )  ;", "}", "if    ( aliasedNode    =  =    null )     {", "importNode    =    module . getStaticImports (  )  . get ( pname )  ;", "if    (  ( importNode    !  =    null )     &  &     ( importNode    !  =     ( currImportNode )  )  )     {", "ClassNode   tmp    =    new   GradleResolveVisitor . ConstructedNestedClass ( importNode . getType (  )  ,    importNode . getFieldName (  )  )  ;", "if    ( resolve ( tmp ,    false ,    false ,    true )  )     {", "if    (  (  ( tmp . getModifiers (  )  )     &     ( Opcodes . ACC _ STATIC )  )     !  =     0  )     {", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "}", "}", "if    ( aliasedNode    !  =    null )     {", "if    (  ( pname . length (  )  )     =  =     ( name . length (  )  )  )     {", "type . setRedirect ( aliasedNode )  ;", "return   true ;", "} else    {", "String   className    =     (  ( aliasedNode . getNameWithoutPackage (  )  )     +     '  $  '  )     +     ( name . substring (  (  ( pname . length (  )  )     +     1  )  )  . replace (  '  .  '  ,     '  $  '  )  )  ;", "GradleResolveVisitor . ConstructedClassWithPackage   tmp    =    new   GradleResolveVisitor . ConstructedClassWithPackage (  (  ( aliasedNode . getPackageName (  )  )     +     \"  .  \"  )  ,    className )  ;", "if    ( resolve ( tmp ,    true ,    true ,    false )  )     {", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "}", "index    =    pname . lastIndexOf (  '  .  '  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "break ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveAliasFromModule"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "CompileUnit   compileUnit    =    currentClass . getCompileUnit (  )  ;", "if    ( compileUnit    =  =    null )     {", "return   false ;", "}", "ClassNode   cuClass    =    compileUnit . getClass ( typetName (  )  )  ;", "if    ( cuClass    !  =    null )     {", "if    ( type    !  =    cuClass )     {", "type . setRedirect ( cuClass )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveFromCompileUnit"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "testDefaultImports    &  =     !  ( type . hasPackageName (  )  )  ;", "testDefaultImports    &  =     !  ( type   instanceof    . LowerCaseClass )  ;", "if    ( testDefaultImports )     {", "String   name    =    type . getName (  )  ;", "List < String >    fqn    =    simpleNameToFQN . get ( type . getName (  )  )  ;", "if    ( fqn    !  =    null )     {", "if    ( resolveFromResolver ( type ,    fqn . get (  0  )  )  )     {", "return   true ;", "}", "}", "for    ( String   packagePrefix    :     . DEFAULT _ IMPORTS )     {", ". ConstructedClassWithPackage   tmp    =    new    . ConstructedClassWithPackage ( packagePrefix ,    name )  ;", "if    ( resolve ( tmp ,    false ,    false ,    false )  )     {", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "if    ( resolveFromResolver ( type ,     (  \" \"     +    name )  )  )     {", "deprecatedImports . add ( name )  ;", "return   true ;", "}", "if    ( name . equals (  \" BigInteger \"  )  )     {", "type . setRedirect ( BigInteger _ TYPE )  ;", "return   true ;", "} else", "if    ( name . equals (  \" BigDecimal \"  )  )     {", "type . setRedirect ( ClassHelper . BigDecimal _ TYPE )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveFromDefaultImports"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedNestedClass )     {", "return   false ;", "}", "if    ( type   instanceof   GradleResolveVisitor . LowerCaseClass )     {", "return   resolveAliasFromModule ( type )  ;", "}", "String   name    =    type . getName (  )  ;", "ModuleNode   module    =    currentClass . getModule (  )  ;", "if    ( module    =  =    null )     {", "return   false ;", "}", "boolean   newNameUsed    =    false ;", "if    (  (  (  !  ( type . hasPackageName (  )  )  )     &  &     ( module . hasPackageName (  )  )  )     &  &     (  !  ( type   instanceof   GradleResolveVisitor . ConstructedClassWithPackage )  )  )     {", "type . setName (  (  ( module . getPackageName (  )  )     +    name )  )  ;", "newNameUsed    =    true ;", "}", "List < ClassNode >    moduleClasses    =    module . getClasses (  )  ;", "for    ( ClassNode   mClass    :    moduleClasses )     {", "if    ( mClass . getName (  )  . equals ( type . getName (  )  )  )     {", "if    ( mClass    !  =    type )     {", "type . setRedirect ( mClass )  ;", "}", "return   true ;", "}", "}", "if    ( newNameUsed )     {", "type . setName ( name )  ;", "}", "if    ( testModuleImports )     {", "if    ( resolveAliasFromModule ( type )  )     {", "return   true ;", "}", "if    ( module . hasPackageName (  )  )     {", "GradleResolveVisitor . ConstructedClassWithPackage   tmp    =    new   GradleResolveVisitor . ConstructedClassWithPackage ( module . getPackageName (  )  ,    name )  ;", "if    ( resolve ( tmp ,    false ,    false ,    false )  )     {", "ambiguousClass ( type ,    tmp ,    name )  ;", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "if    (  !  ( name . contains (  \"  .  \"  )  )  )     {", "for    ( ImportNode   importNode    :    module . getStaticImports (  )  . values (  )  )     {", "if    ( importNode . getFieldName (  )  . equals ( name )  )     {", "ClassNode   tmp    =    new   GradleResolveVisitor . ConstructedNestedClass ( importNode . getType (  )  ,    name )  ;", "if    ( resolve ( tmp ,    false ,    false ,    true )  )     {", "if    (  (  ( tmp . getModifiers (  )  )     &     ( Opcodes . ACC _ STATIC )  )     !  =     0  )     {", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "}", "}", "for    ( ImportNode   importNode    :    module . getStarImports (  )  )     {", "String   packagePrefix    =    importNode . getPackageName (  )  ;", "GradleResolveVisitor . ConstructedClassWithPackage   tmp    =    new   GradleResolveVisitor . ConstructedClassWithPackage ( packagePrefix ,    name )  ;", "if    ( resolve ( tmp ,    false ,    false ,    true )  )     {", "ambiguousClass ( type ,    tmp ,    name )  ;", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "for    ( ImportNode   importNode    :    module . getStaticStarImports (  )  . values (  )  )     {", "ClassNode   tmp    =    new   GradleResolveVisitor . ConstructedNestedClass ( importNode . getType (  )  ,    name )  ;", "if    ( resolve ( tmp ,    false ,    false ,    true )  )     {", "if    (  (  ( tmp . getModifiers (  )  )     &     ( Opcodes . ACC _ STATIC )  )     !  =     0  )     {", "ambiguousClass ( type ,    tmp ,    name )  ;", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "}", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveFromModule"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNodeResolver . LookupResult   result    =    classNodeResolver . resolveName ( name ,    compilationUnit )  ;", "if    (  ( result    !  =    null )     &  &     ( result . isClassNode (  )  )  )     {", "type . setRedirect ( result . getClassNode (  )  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveFromResolver"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedNestedClass )     {", "return   false ;", "}", "if    ( type   instanceof   GradleResolveVisitor . LowerCaseClass )     {", "return   false ;", "}", "testStaticInnerClasses    &  =    type . hasPackageName (  )  ;", "if    ( testStaticInnerClasses )     {", "if    ( type   instanceof   GradleResolveVisitor . ConstructedClassWithPackage )     {", "GradleResolveVisitor . ConstructedClassWithPackage   tmp    =     (  ( GradleResolveVisitor . ConstructedClassWithPackage )     ( type )  )  ;", "String   savedName    =    tmp . className ;", "tmp . className    =    GradleResolveVisitor . replaceLastPoint ( savedName )  ;", "if    ( resolve ( tmp ,    false ,    true ,    false )  )     {", "type . setRedirect ( tmp . redirect (  )  )  ;", "return   true ;", "}", "tmp . className    =    savedName ;", "} else    {", "String   savedName    =    type . getName (  )  ;", "String   replacedPointType    =    GradleResolveVisitor . replaceLastPoint ( savedName )  ;", "type . setName ( replacedPointType )  ;", "if    ( resolve ( type ,    false ,    true ,    false )  )     {", "return   true ;", "}", "type . setName ( savedName )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveFromStaticInnerClasses"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( types    =  =    null )     {", "return ;", "}", "currentClass . setUsingGenerics ( true )  ;", "for    ( GenericsType   type    :    types )     {", "ClassNode   classNode    =    type . getType (  )  ;", "String   name    =    type . getName (  )  ;", "ClassNode [  ]    bounds    =    type . getUpperBounds (  )  ;", "if    ( bounds    !  =    null )     {", "boolean   nameAdded    =    false ;", "for    ( ClassNode   upperBound    :    bounds )     {", "if    (  (  (  ! nameAdded )     &  &     ( upperBound    !  =    null )  )     |  |     (  !  ( r ( classNode )  )  )  )     {", "genericParameterNames . put ( name ,    type )  ;", "type . setPlaceholder ( true )  ;", "classNode . setRedirect ( upperBound )  ;", "nameAdded    =    true ;", "}", "rOrFail ( upperBound ,    classNode )  ;", "}", "} else    {", "genericParameterNames . put ( name ,    type )  ;", "classNode . setRedirect ( OBJECT _ TYPE )  ;", "type . setPlaceholder ( true )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["resolveGenericsHeader"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( genericsType . isResolved (  )  )     {", "return   true ;", "}", "currentClass . setUsingGenerics ( true )  ;", "ClassNode   type    =    genericsType . getType (  )  ;", "String   name    =    type . getName (  )  ;", "ClassNode [  ]    bounds    =    genericsType . getUpperBounds (  )  ;", "if    (  !  ( genericParameterNames . containsKey ( name )  )  )     {", "if    ( bounds    !  =    null )     {", "for    ( ClassNode   upperBound    :    bounds )     {", "resolveOrFail ( upperBound ,    genericsType )  ;", "type . setRedirect ( upperBound )  ;", "resolveGenericsTypes ( upperBound . getGenericsTypes (  )  )  ;", "}", "} else", "if    ( genericsType . isWildcard (  )  )     {", "type . setRedirect ( ClassHelper . OBJECT _ TYPE )  ;", "} else    {", "resolveOrFail ( type ,    genericsType )  ;", "}", "} else    {", "GenericsType   gt    =    genericParameterNames . get ( name )  ;", "type . setRedirect ( gt . getType (  )  )  ;", "genericsType . setPlaceholder ( true )  ;", "}", "if    (  ( genericsType . getLowerBound (  )  )     !  =    null )     {", "resolveOrFail ( genericsType . getLowerBound (  )  ,    genericsType )  ;", "}", "if    ( resolveGenericsTypes ( type . getGenericsTypes (  )  )  )     {", "genericsType . setResolved ( genericsType . getType (  )  . isResolved (  )  )  ;", "}", "return   genericsType . isResolved (  )  ;", "}", "METHOD_END"], "methodName": ["resolveGenericsType"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( types    =  =    null )     {", "return   true ;", "}", "currentClass . setUsingGenerics ( true )  ;", "boolean   rd    =    true ;", "for    ( GenericsType   type    :    types )     {", "rd    =     ( rGenericsType ( type )  )     &  &    rd ;", "}", "return   rd ;", "}", "METHOD_END"], "methodName": ["resolveGenericsTypes"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedNestedClass )     {", "return   false ;", "}", "Map < String ,    ClassNode >    hierClasses    =    new   LinkedHashMap < String ,    ClassNode >  (  )  ;", "ClassNode   val ;", "for    ( ClassNode   classToCheck    =    currentClass ;     (  ( classToCheck    !  =    null )     &  &     ( classToCheck    !  =     ( ClassHelper . OBJECT _ TYPE )  )  )     &  &     (  !  ( GradleResolveVisitor . SCRIPTS _ PACKAGE . equals ( classToCheck . getPackageName (  )  )  )  )  ;    classToCheck    =    classToCheck . getSuperClass (  )  )     {", "if    ( hierClasses . containsKey ( classToCheck . getName (  )  )  )     {", "break ;", "}", "hierClasses . put ( classToCheck . getName (  )  ,    classToCheck )  ;", "}", "for    ( ClassNode   classToCheck    :    hierClasses . values (  )  )     {", "val    =    new   GradleResolveVisitor . ConstructedNestedClass ( classToCheck ,    type . getName (  )  )  ;", "if    ( resolveFromCompileUnit ( val )  )     {", "type . setRedirect ( val )  ;", "return   true ;", "}", "for    ( ClassNode   next    :    classToCheck . getAllInterfaces (  )  )     {", "if    ( type . getName (  )  . contains ( next . getName (  )  )  )     {", "continue ;", "}", "val    =    new   GradleResolveVisitor . ConstructedNestedClass ( next ,    type . getName (  )  )  ;", "if    ( resolve ( val ,    false ,    false ,    false )  )     {", "type . setRedirect ( val )  ;", "return   true ;", "}", "}", "}", "if    (  !  (  ( currentClass )    instanceof   InnerClassNode )  )     {", "return   false ;", "}", "LinkedList < ClassNode >    outerClasses    =    new   LinkedList < ClassNode >  (  )  ;", "ClassNode   outer    =    currentClass . getOuterClass (  )  ;", "while    ( outer    !  =    null )     {", "outerClasses . addFirst ( outer )  ;", "outer    =    outer . getOuterClass (  )  ;", "}", "for    ( ClassNode   testNode    :    outerClasses )     {", "val    =    new   GradleResolveVisitor . ConstructedNestedClass ( testNode ,    type . getName (  )  )  ;", "if    ( resolveFromCompileUnit ( val )  )     {", "type . setRedirect ( val )  ;", "return   true ;", "}", "for    ( ClassNode   next    :    testNode . getAllInterfaces (  )  )     {", "if    ( type . getName (  )  . contains ( next . getName (  )  )  )     {", "continue ;", "}", "val    =    new   GradleResolveVisitor . ConstructedNestedClass ( next ,    type . getName (  )  )  ;", "if    ( resolve ( val ,    false ,    false ,    false )  )     {", "type . setRedirect ( val )  ;", "return   true ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveNestedClass"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( resolve ( type )  )     {", "return ;", "}", "if    ( resolveToInner ( type )  )     {", "return ;", "}", "addError (  (  (  (  \" unable   to   resolve   class    \"     +     ( type . getName (  )  )  )     +     \"     \"  )     +    msg )  ,    node )  ;", "}", "METHOD_END"], "methodName": ["resolveOrFail"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "resolveOrFail ( type ,     \"  \"  ,    node )  ;", "}", "METHOD_END"], "methodName": ["resolveOrFail"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "resolveGenericsTypes ( type . getGenericsTypes (  )  )  ;", "if    ( prefereImports    &  &     ( resolveAliasFromModule ( type )  )  )     {", "return ;", "}", "resolveOrFail ( type ,    node )  ;", "}", "METHOD_END"], "methodName": ["resolveOrFail"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedClassWithPackage )     {", "return   false ;", "}", "if    ( type   instanceof   GradleResolveVisitor . ConstructedNestedClass )     {", "return   false ;", "}", "String   name    =    type . getName (  )  ;", "String   saved    =    name ;", "while    ( true )     {", "int   len    =    name . lastIndexOf (  '  .  '  )  ;", "if    ( len    =  =     (  -  1  )  )     {", "break ;", "}", "name    =     (  ( name . substring (  0  ,    len )  )     +     \"  $  \"  )     +     ( name . substring (  ( len    +     1  )  )  )  ;", "type . setName ( name )  ;", "if    ( resolve ( type )  )     {", "return   true ;", "}", "}", "if    ( resolveToNestedOfCurrent ( type )  )     {", "return   true ;", "}", "type . setName ( saved )  ;", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveToInner"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( type   instanceof   GradleResolveVisitor . ConstructedNestedClass )     {", "return   false ;", "}", "String   name    =    type . getName (  )  ;", "if    (  (  (  ( currentClass )     !  =    type )     &  &     (  !  ( name . contains (  \"  .  \"  )  )  )  )     &  &     ( type . getClass (  )  . equals ( ClassNode . class )  )  )     {", "ClassNode   tmp    =    new   GradleResolveVisitor . ConstructedNestedClass ( currentClass ,    name )  ;", "if    ( resolve ( tmp )  )     {", "type . setRedirect ( tmp )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveToNestedOfCurrent"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "String   name    =    type . getName (  )  ;", "if    ( type   instanceof    . LowerCaseClass )     {", "classNodeResolver . cacheClass ( name ,     . NO _ CLASS )  ;", "return   false ;", "}", "if    ( name . contains (  \"  $  \"  )  )     {", "return   false ;", "}", "if    (  ( currentClass . getModule (  )  . hasPackageName (  )  )     &  &     (  ( name . indexOf (  '  .  '  )  )     =  =     (  -  1  )  )  )     {", "return   false ;", "}", "ClassNodeResolver . LookupResult   lr    =    null ;", "lr    =    classNodeResolver . resolveName ( name ,    compilationUnit )  ;", "if    ( lr    !  =    null )     {", "if    ( lr . isSourceUnit (  )  )     {", "SourceUnit   su    =    lr . getSourceUnit (  )  ;", "currentClass . getCompileUnit (  )  . addClassNodeToCompile ( type ,    su )  ;", "} else    {", "type . setRedirect ( lr . getClassNode (  )  )  ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["resolveToOuter"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "this . classNodeResolver    =    classNodeResolver ;", "}", "METHOD_END"], "methodName": ["setClassNodeResolver"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "this . source    =    source ;", "vClass ( node )  ;", "}", "METHOD_END"], "methodName": ["startResolving"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( name    =  =    null )     |  |     (  ( name . length (  )  )     =  =     0  )  )     {", "return   false ;", "}", "return    !  ( Charac . isLowerCase ( name . charAt (  0  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testVanillaNameForClass"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( exp    =  =    null )     {", "return   null ;", "}", "Expression   ret    =    null ;", "if    ( exp   instanceof   VariableExpression )     {", "ret    =    transformVariableExpression (  (  ( VariableExpression )     ( exp )  )  )  ;", "} else", "if    (  ( exp . getClass (  )  )     =  =     ( class )  )     {", "ret    =    transformPropertyExpression (  (  ( PropertyExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   DeclarationExpression )     {", "ret    =    transformDeclarationExpression (  (  ( DeclarationExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   BinaryExpression )     {", "ret    =    transformBinaryExpression (  (  ( BinaryExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   MethodCallExpression )     {", "ret    =    transformMethodCallExpression (  (  ( MethodCallExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   ClosureExpression )     {", "ret    =    transformClosureExpression (  (  ( ClosureExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   ConstructorCallExpression )     {", "ret    =    transformConstructorCallExpression (  (  ( ConstructorCallExpression )     ( exp )  )  )  ;", "} else", "if    ( exp   instanceof   AnnotationConstantExpression )     {", "ret    =    transformAnnotationConstantExpression (  (  ( AnnotationConstantExpression )     ( exp )  )  )  ;", "} else    {", "resolveOrFail ( exp . getType (  )  ,    exp )  ;", "ret    =    exp . transformExpression ( this )  ;", "}", "if    (  ( ret    !  =    null )     &  &     ( ret    !  =    exp )  )     {", "ret . setSourcePosition ( exp )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "AnnotationNode   an    =     (  ( AnnotationNode )     ( ace . getValue (  )  )  )  ;", "ClassNode   type    =    an . getClassNode (  )  ;", "rOrFail ( type ,     \"  ,    unable   to   find   class   for   annotation \"  ,    an )  ;", "for    ( Map . Entry < String ,    Expression >    member    :    an . getMembers (  )  . entrySet (  )  )     {", "member . setValue ( transform ( member . getValue (  )  )  )  ;", "}", "return   ace ;", "}", "METHOD_END"], "methodName": ["transformAnnotationConstantExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "Expression   left    =    transform ( be . getLeftExpression (  )  )  ;", "int   type    =    be . getOperation (  )  . getType (  )  ;", "if    (  (  ( type    =  =     ( Types . ASSIGNMENT _ OPERATOR )  )     |  |     ( type    =  =     ( Types . EQUAL )  )  )     &  &     ( left   instanceof   ClassExpression )  )     {", "ClassExpression   ce    =     (  ( ClassExpression )     ( left )  )  ;", "String   error    =     (  \" you   tried   to   assign   a   value   to   the   class    '  \"     +     ( ce . getType (  )  . getName (  )  )  )     +     \"  '  \"  ;", "if    ( ce . getType (  )  . isScript (  )  )     {", "error    +  =     \"  .    Do   you   have   a   script   with   this   name ?  \"  ;", "}", "addError ( error ,    be . getLeftExpression (  )  )  ;", "return   be ;", "}", "if    (  ( left   instanceof   ClassExpression )     &  &     ( isLeftSquareBracket ( type )  )  )     {", "if    (  ( be . getRightExpression (  )  )    instanceof   ListExpression )     {", "ListExpression   list    =     (  ( ListExpression )     ( be . getRightExpression (  )  )  )  ;", "if    ( list . getExpressions (  )  . isEmpty (  )  )     {", "final   ClassExpression   ce    =    new   ClassExpression ( left . getType (  )  . makeArray (  )  )  ;", "ce . setSourcePosition ( be )  ;", "return   ce ;", "} else    {", "boolean   map    =    true ;", "for    ( Expression   expression    :    list . getExpressions (  )  )     {", "if    (  !  ( expression   instanceof   MapEntryExpression )  )     {", "map    =    false ;", "break ;", "}", "}", "if    ( map )     {", "final   MapExpression   me    =    new   MapExpression (  )  ;", "for    ( Expression   expression    :    list . getExpressions (  )  )     {", "me . addMapEntryExpression (  (  ( MapEntryExpression )     ( transform ( expression )  )  )  )  ;", "}", "me . setSourcePosition ( list )  ;", "final   CastExpression   ce    =    new   CastExpression ( left . getType (  )  ,    me )  ;", "ce . setSourcePosition ( be )  ;", "return   ce ;", "}", "}", "} else", "if    (  ( be . getRightExpression (  )  )    instanceof   SpreadMapExpression )     {", "SpreadMapExpression   mapExpression    =     (  ( SpreadMapExpression )     ( be . getRightExpression (  )  )  )  ;", "Expression   right    =    transform ( mapExpression . getExpression (  )  )  ;", "Expression   ce    =    new   CastExpression ( left . getType (  )  ,    right )  ;", "ce . setSourcePosition ( be )  ;", "return   ce ;", "}", "if    (  ( be . getRightExpression (  )  )    instanceof   MapEntryExpression )     {", "final   MapExpression   me    =    new   MapExpression (  )  ;", "me . addMapEntryExpression (  (  ( MapEntryExpression )     ( transform ( be . getRightExpression (  )  )  )  )  )  ;", "me . setSourcePosition ( be . getRightExpression (  )  )  ;", "final   CastExpression   ce    =    new   CastExpression ( left . getType (  )  ,    me )  ;", "ce . setSourcePosition ( be )  ;", "return   ce ;", "}", "}", "Expression   right    =    transform ( be . getRightExpression (  )  )  ;", "be . setLeftExpression ( left )  ;", "be . setRightExpression ( right )  ;", "return   be ;", "}", "METHOD_END"], "methodName": ["transformBinaryExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "boolean   oldInClosure    =    inClosure ;", "inClosure    =    true ;", "Parameter [  ]    paras    =    ce . getParameters (  )  ;", "if    ( paras    !  =    null )     {", "for    ( Parameter   para    :    paras )     {", "ClassNode   t    =    para . getType (  )  ;", "rOrFail ( t ,    ce )  ;", "visitAnnotations ( para )  ;", "if    ( para . hasInitialExpression (  )  )     {", "Object   initialVal    =    para . getInitialExpression (  )  ;", "if    ( initialVal   instanceof   Expression )     {", "para . setInitialExpression ( transform (  (  ( Expression )     ( initialVal )  )  )  )  ;", "}", "}", "visitAnnotations ( para )  ;", "}", "}", "Statement   code    =    ce . getCode (  )  ;", "if    ( code    !  =    null )     {", "code . visit ( this )  ;", "}", "inClosure    =    oldInClosure ;", "return   ce ;", "}", "METHOD_END"], "methodName": ["transformClosureExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNode   type    =    cce . getType (  )  ;", "rOrFail ( type ,    cce )  ;", "if    ( Modifier . isAbstract ( type . getModifiers (  )  )  )     {", "addError (  (  (  \" You   cannot   create   an   instance   from   the   abstract    \"     +     ( getDescription ( type )  )  )     +     \"  .  \"  )  ,    cce )  ;", "}", "Expression   ret    =    cce . transformExpression ( this )  ;", "return   ret ;", "}", "METHOD_END"], "methodName": ["transformConstructorCallExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "visitAnnotations ( de )  ;", "Expression   oldLeft    =    de . getLeftExpression (  )  ;", "checkingVariableTypeInDeclaration    =    true ;", "Expression   left    =    transform ( oldLeft )  ;", "checkingVariableTypeInDeclaration    =    false ;", "if    ( left   instanceof   ClassExpression )     {", "ClassExpression   ce    =     (  ( ClassExpression )     ( left )  )  ;", "addError (  (  \" you   tried   to   assign   a   value   to   the   class    \"     +     ( ce . getType (  )  . getName (  )  )  )  ,    oldLeft )  ;", "return   de ;", "}", "Expression   right    =    transform ( de . getRightExpression (  )  )  ;", "if    ( right    =  =     ( de . getRightExpression (  )  )  )     {", "fixDeclaringClass ( de )  ;", "return   de ;", "}", "DeclarationExpression   newDeclExpr    =    new   DeclarationExpression ( left ,    de . getOperation (  )  ,    right )  ;", "newDeclExpr . setDeclaringClass ( de . getDeclaringClass (  )  )  ;", "fixDeclaringClass ( newDeclExpr )  ;", "newDeclExpr . setSourcePosition ( de )  ;", "newDeclExpr . addAnnotations ( de . getAnnotations (  )  )  ;", "return   newDeclExpr ;", "}", "METHOD_END"], "methodName": ["transformDeclarationExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "if    ( exp   instanceof   PropertyExpression )     {", "PropertyExpression   pe    =     (  ( PropertyExpression )     ( exp )  )  ;", "if    (  ( pe . getObjectExpression (  )  )    instanceof   ClassExpression )     {", "ClassExpression   ce    =     (  ( ClassExpression )     ( pe . getObjectExpression (  )  )  )  ;", "ClassNode   type    =    ce . getType (  )  ;", "if    ( type . isEnum (  )  )     {", "return   exp ;", "}", "FieldNode   fn    =    type . getField ( pe . getPropertyAsString (  )  )  ;", "if    (  (  (  ( fn    !  =    null )     &  &     (  !  ( fn . isEnum (  )  )  )  )     &  &     ( fn . isStatic (  )  )  )     &  &     ( fn . isFinal (  )  )  )     {", "if    (  ( fn . getInitialValueExpression (  )  )    instanceof   ConstantExpression )     {", "return   fn . getInitialValueExpression (  )  ;", "}", "}", "}", "} else", "if    ( exp   instanceof   ListExpression )     {", "ListExpression   le    =     (  ( ListExpression )     ( exp )  )  ;", "ListExpression   result    =    new   ListExpression (  )  ;", "for    ( Expression   e    :    le . getExpressions (  )  )     {", "result . addExpression ( transformInlineConstants ( e )  )  ;", "}", "return   result ;", "} else", "if    ( exp   instanceof   AnnotationConstantExpression )     {", "ConstantExpression   ce    =     (  ( ConstantExpression )     ( exp )  )  ;", "if    (  ( ce . getValue (  )  )    instanceof   AnnotationNode )     {", "AnnotationNode   an    =     (  ( AnnotationNode )     ( ce . getValue (  )  )  )  ;", "for    ( Entry < String ,    Expression >    member    :    an . getMembers (  )  . entrySet (  )  )     {", "member . setValue ( transformInlineConstants ( member . getValue (  )  )  )  ;", "}", "}", "}", "return   exp ;", "}", "METHOD_END"], "methodName": ["transformInlineConstants"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "Expression   args    =    transform ( mce . getArguments (  )  )  ;", "Expression   method    =    transform ( mce . getMethod (  )  )  ;", "Expression   object    =    transform ( mce . getObjectExpression (  )  )  ;", "rGenericsTypes ( mce . getGenericsTypes (  )  )  ;", "MethodCallExpression   result    =    new   MethodCallExpression ( object ,    method ,    args )  ;", "result . setSafe ( mce . isSafe (  )  )  ;", "result . setImplicitThis ( mce . isImplicitThis (  )  )  ;", "result . setSpreadSafe ( mce . isSpreadSafe (  )  )  ;", "result . setSourcePosition ( mce )  ;", "result . setGenericsTypes ( mce . getGenericsTypes (  )  )  ;", "result . setMethodTarget ( mce . getMethodTarget (  )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["transformMethodCallExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "boolean   itlp    =    isTopLevelProperty ;", "boolean   ipe    =    inPropertyExpression ;", "Expression   objectExpression    =    pe . getObjectExpression (  )  ;", "inPropertyExpression    =    true ;", "isTopLevelProperty    =     ( objectExpression . getClass (  )  )     !  =     ( PropertyExpression . class )  ;", "objectExpression    =    transform ( objectExpression )  ;", "inPropertyExpression    =    false ;", "Expression   property    =    transform ( pe . getProperty (  )  )  ;", "isTopLevelProperty    =    itlp ;", "inPropertyExpression    =    ipe ;", "boolean   spreadSafe    =    pe . isSpreadSafe (  )  ;", "PropertyExpression   old    =    pe ;", "pe    =    new   PropertyExpression ( objectExpression ,    property ,    pe . isSafe (  )  )  ;", "pe . setSpreadSafe ( spreadSafe )  ;", "pe . setSourcePosition ( old )  ;", "String   className    =    lookupClassName ( pe )  ;", "if    ( className    !  =    null )     {", "ClassNode   type    =    ClassHelper . make ( className )  ;", "if    ( resolve ( type )  )     {", "Expression   ret    =    new   ClassExpression ( type )  ;", "ret . setSourcePosition ( pe )  ;", "return   ret ;", "}", "}", "if    (  ( objectExpression   instanceof   ClassExpression )     &  &     (  ( pe . getPropertyAsString (  )  )     !  =    null )  )     {", "ClassExpression   ce    =     (  ( ClassExpression )     ( objectExpression )  )  ;", "ClassNode   type    =    new    . ConstructedNestedClass ( ce . getType (  )  ,    pe . getPropertyAsString (  )  )  ;", "if    ( resolve ( type ,    false ,    false ,    false )  )     {", "Expression   ret    =    new   ClassExpression ( type )  ;", "ret . setSourcePosition ( ce )  ;", "return   ret ;", "}", "}", "Expression   ret    =    pe ;", "checkThisAndSuperAsPropertyAccess ( pe )  ;", "if    ( isTopLevelProperty )     {", "ret    =    correctClassClassChain ( pe )  ;", "}", "return   ret ;", "}", "METHOD_END"], "methodName": ["transformPropertyExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "visitAnnotations ( ve )  ;", "Variable   v    =    ve . getAccessedVariable (  )  ;", "if    (  (  !  ( v   instanceof   DynamicVariable )  )     &  &     (  !  ( checkingVariableTypeInDeclaration )  )  )     {", "return   ve ;", "}", "if    ( v   instanceof   DynamicVariable )     {", "String   name    =    ve . getName (  )  ;", "ClassNode   t    =    ClassHelper . make ( name )  ;", "boolean   isClass    =    t . isResolved (  )  ;", "if    (  ! isClass )     {", "if    ( Character . isLowerCase ( name . charAt (  0  )  )  )     {", "t    =    new    . LowerCaseClass ( name )  ;", "}", "isClass    =    resolve ( t )  ;", "if    (  ! isClass )     {", "isClass    =    resolveToNestedOfCurrent ( t )  ;", "}", "}", "if    ( isClass )     {", "for    ( VariableScope   scope    =    currentScope ;     ( scope    !  =    null )     &  &     (  !  ( scope . isRoot (  )  )  )  ;    scope    =    scope . getParent (  )  )     {", "if    ( scope . isRoot (  )  )     {", "break ;", "}", "if    (  ( scope . removeReferencedClassVariable ( ve . getName (  )  )  )     =  =    null )     {", "break ;", "}", "}", "ClassExpression   ce    =    new   ClassExpression ( t )  ;", "ce . setSourcePosition ( ve )  ;", "return   ce ;", "}", "}", "resolveOrFail ( ve . getType (  )  ,    ve )  ;", "ClassNode   origin    =    ve . getOriginType (  )  ;", "if    ( origin    !  =     ( ve . getType (  )  )  )     {", "resolveOrFail ( origin ,    ve )  ;", "}", "return   ve ;", "}", "METHOD_END"], "methodName": ["transformVariableExpression"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "List < AnnotationNode >    annotations    =    node . getAnnotations (  )  ;", "if    ( annotations . isEmpty (  )  )     {", "return ;", "}", "Map < String ,    AnnotationNode >    tmpAnnotations    =    new   HashMap < String ,    AnnotationNode >  (  )  ;", "ClassNode   annType ;", "for    ( AnnotationNode   an    :    annotations )     {", "if    ( an . isBuiltIn (  )  )     {", "continue ;", "}", "annType    =    an . getClassNode (  )  ;", "resolveOrFail ( annType ,     \"  ,       unable   to   find   class   for   annotation \"  ,    an )  ;", "for    ( Map . Entry < String ,    Expression >    member    :    an . getMembers (  )  . entrySet (  )  )     {", "Expression   newValue    =    transform ( member . getValue (  )  )  ;", "newValue    =    transformInlineConstants ( newValue )  ;", "member . setValue ( newValue )  ;", "checkAnnotationMemberValue ( newValue )  ;", "}", "if    ( annType . isd (  )  )     {", "Class   annTypeClass    =    annType . getTypeClass (  )  ;", "Retention   retAnn    =     (  ( Retention )     ( annTypeClass . getAnnotation ( Retention . class )  )  )  ;", "if    (  ( retAnn    !  =    null )     &  &     ( retAnn . value (  )  . equals ( RetentionPolicy . RUNTIME )  )  )     {", "AnnotationNode   anyPrevAnnNode    =    tmpAnnotations . put ( annTypeClass . getName (  )  ,    an )  ;", "if    ( anyPrevAnnNode    !  =    null )     {", "addError (  (  \" Cannot   specify   duplicate   annotation   on   the   same   member    :     \"     +     ( annType . getName (  )  )  )  ,    an )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["visitAnnotations"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "VariableScope   oldScope    =    currentScope ;", "currentScope    =    block . getVariableScope (  )  ;", "super . vBlockStatement ( block )  ;", "currentScope    =    oldScope ;", "}", "METHOD_END"], "methodName": ["visitBlockStatement"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "resolveOrFail ( cs . getExceptionType (  )  ,    cs )  ;", "if    (  ( cs . getExceptionType (  )  )     =  =     ( ClassHelper . DYNAMIC _ TYPE )  )     {", "cs . getVariable (  )  . setType ( ClassHelper . make ( Exception . class )  )  ;", "}", "super . visitCatchStatement ( cs )  ;", "}", "METHOD_END"], "methodName": ["visitCatchStatement"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNode   oldNode    =    currentClass ;", "if    ( node   instanceof   InnerClassNode )     {", "if    ( Modifier . isStatic ( node . getModifiers (  )  )  )     {", "genericParameterNames    =    new   HashMap < String ,    GenericsType >  (  )  ;", "}", "} else    {", "genericParameterNames    =    new   HashMap < String ,    GenericsType >  (  )  ;", "}", "currentClass    =    node ;", "resolveGenericsHeader ( node . getGenericsTypes (  )  )  ;", "ModuleNode   module    =    node . getModule (  )  ;", "if    (  !  ( module . hasImportsResolved (  )  )  )     {", "for    ( ImportNode   importNode    :    module . getImports (  )  )     {", "currImportNode    =    importNode ;", "ClassNode   type    =    importNode . getType (  )  ;", "if    ( resolve ( type ,    false ,    false ,    true )  )     {", "currImportNode    =    null ;", "continue ;", "}", "currImportNode    =    null ;", "addError (  (  \" unable   to   resolve   class    \"     +     ( type . getName (  )  )  )  ,    type )  ;", "}", "for    ( ImportNode   importNode    :    module . getStaticStarImports (  )  . values (  )  )     {", "ClassNode   type    =    importNode . getType (  )  ;", "if    ( resolve ( type ,    false ,    false ,    true )  )     {", "continue ;", "}", "if    (  (  ( type . getPackageName (  )  )     =  =    null )     &  &     (  ( node . getPackageName (  )  )     !  =    null )  )     {", "String   oldTypeName    =    type . getName (  )  ;", "type . setName (  (  (  ( node . getPackageName (  )  )     +     \"  .  \"  )     +    oldTypeName )  )  ;", "if    ( resolve ( type ,    false ,    false ,    true )  )     {", "continue ;", "}", "type . setName ( oldTypeName )  ;", "}", "addError (  (  \" unable   to   resolve   class    \"     +     ( type . getName (  )  )  )  ,    type )  ;", "}", "for    ( ImportNode   importNode    :    module . getStaticImports (  )  . values (  )  )     {", "ClassNode   type    =    importNode . getType (  )  ;", "if    ( resolve ( type ,    true ,    true ,    true )  )     {", "continue ;", "}", "addError (  (  \" unable   to   resolve   class    \"     +     ( type . getName (  )  )  )  ,    type )  ;", "}", "for    ( ImportNode   importNode    :    module . getStaticStarImports (  )  . values (  )  )     {", "ClassNode   type    =    importNode . getType (  )  ;", "if    ( resolve ( type ,    true ,    true ,    true )  )     {", "continue ;", "}", "addError (  (  \" unable   to   resolve   class    \"     +     ( type . getName (  )  )  )  ,    type )  ;", "}", "module . setImportsResolved ( true )  ;", "}", "ClassNode   sn    =    node . getUnresolvedSuperClass (  )  ;", "if    ( sn    !  =    null )     {", "resolveOrFail ( sn ,    node ,    true )  ;", "}", "for    ( ClassNode   anInterface    :    node . getInterfaces (  )  )     {", "resolveOrFail ( anInterface ,    node ,    true )  ;", "}", "checkCyclicInheritence ( node ,    node . getUnresolvedSuperClass (  )  ,    node . getInterfaces (  )  )  ;", "super . visitClass ( node )  ;", "currentClass    =    oldNode ;", "}", "METHOD_END"], "methodName": ["visitClass"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "VariableScope   oldScope    =    currentScope ;", "currentScope    =    node . getVariableScope (  )  ;", "Map < String ,    GenericsType >    oldPNames    =    genericParameterNames ;", "genericParameterNames    =    new   HashMap < String ,    GenericsType >  ( genericParameterNames )  ;", "rGenericsHeader ( node . getGenericsTypes (  )  )  ;", "Parameter [  ]    paras    =    node . getParameters (  )  ;", "for    ( Parameter   p    :    paras )     {", "p . setInitialExpression ( transform ( p . getInitialExpression (  )  )  )  ;", "rOrFail ( p . getType (  )  ,    p . getType (  )  )  ;", "visitAnnotations ( p )  ;", "}", "ClassNode [  ]    exceptions    =    node . getExceptions (  )  ;", "for    ( ClassNode   t    :    exceptions )     {", "rOrFail ( t ,    node )  ;", "}", "rOrFail ( node . getReturnType (  )  ,    node )  ;", "MethodNode   oldCurrentMethod    =    currentMethod ;", "currentMethod    =    node ;", "super . visitConstructorOrMethod ( node ,    isConstructor )  ;", "currentMethod    =    oldCurrentMethod ;", "genericParameterNames    =    oldPNames ;", "currentScope    =    oldScope ;", "}", "METHOD_END"], "methodName": ["visitConstructorOrMethod"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNode   t    =    node . getType (  )  ;", "if    (  !  ( fieldTypesChecked . contains ( node )  )  )     {", "rOrFail ( t ,    node )  ;", "}", "super . visitField ( node )  ;", "}", "METHOD_END"], "methodName": ["visitField"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "resolveOrFail ( forLoop . getVariableType (  )  ,    forLoop )  ;", "super . visitForLoop ( forLoop )  ;", "}", "METHOD_END"], "methodName": ["visitForLoop"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "ClassNode   t    =    node . getType (  )  ;", "rOrFail ( t ,    node )  ;", "super . visitProperty ( node )  ;", "fieldTypesChecked . add ( node . getField (  )  )  ;", "}", "METHOD_END"], "methodName": ["visitProperty"], "fileName": "org.gradle.groovy.scripts.internal.GradleResolveVisitor"}, {"methodBody": ["METHOD_START", "{", "return   imperativeStatementDetected ;", "}", "METHOD_END"], "methodName": ["isImperativeStatementDetected"], "fileName": "org.gradle.groovy.scripts.internal.ImperativeStatementDetectingTransformer"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \"  % s % n % nSee    % s   for   information   on   the   pluginManagement    {  }    block % n % n \"  ,    failureMessage ,    documentationRegistry . getDocumentationFor (  \" plugins \"  ,     \" sec : plugin _ management \"  )  )  ;", "}", "METHOD_END"], "methodName": ["makePluginManagementError"], "fileName": "org.gradle.groovy.scripts.internal.InitialPassStatementTransformer"}, {"methodBody": ["METHOD_START", "{", "ScriptBlock   scriptBlock    =    AstUtils . detectScriptBlock ( statement ,    scriptBlockNames )  ;", "if    ( scriptBlock    =  =    null )     {", "seenNonClasspathStatement    =    true ;", "return   null ;", "} else    {", "if    ( scriptBlock . getName (  )  . equals (  . PLUGINS )  )     {", "String   failMessage    =    null ;", "if    (  !  ( scriptTarget . getSupportsPluginsBlock (  )  )  )     {", "failMessage    =    pluginBlockMetadataExtractor . formatErrorMessage (  \" Only   Project   build   scripts   can   contain   plugins    {  }    blocks \"  )  ;", "} else    {", "seenPluginsBlock    =    true ;", "if    ( seenNonClasspathStatement )     {", "failMessage    =    String . format ( pluginBlockMetadataExtractor . formatErrorMessage (  \" only    % s    {  }    and   other    % s    {  }    script   blocks   are   allowed   before    % s    {  }    blocks ,    no   other   statements   are   allowed \"  )  ,    scriptTarget . getClasspathBlockName (  )  ,     . PLUGINS ,     . PLUGINS )  ;", "} else    {", "pluginBlockMetadataExtractor . extract ( sourceUnit ,    scriptBlock )  ;", "}", "}", "if    ( failMessage    !  =    null )     {", "sourceUnit . getErrorCollector (  )  . addError ( new   SyntaxException ( failMessage ,    statement . getLineNumber (  )  ,    statement . getColumnNumber (  )  )  ,    sourceUnit )  ;", "}", "return   null ;", "} else", "if    ( scriptBlock . getName (  )  . equals (  . PLUGIN _ MANAGEMENT )  )     {", "String   failureMessage    =    null ;", "if    (  !  ( scriptTarget . getSupportsPluginManagementBlock (  )  )  )     {", "failureMessage    =     \" Only   Settings   scripts   can   contain   a   pluginManagement    {  }    block .  \"  ;", "} else", "if    (  (  ( seenClasspathBlock )     |  |     ( seenNonClasspathStatement )  )     |  |     ( seenPluginsBlock )  )     {", "failureMessage    =    String . format (  \" The    % s    {  }    block   must   appear   before   any   other   statements   in   the   script .  \"  ,     . PLUGIN _ MANAGEMENT )  ;", "} else", "if    ( seenPluginManagementBlock )     {", "failureMessage    =    String . format (  \" At   most ,    one    % s    {  }    block   may   appear   in   the   script .  \"  ,     . PLUGIN _ MANAGEMENT )  ;", "}", "if    ( failureMessage    !  =    null )     {", "sourceUnit . getErrorCollector (  )  . addError ( new   SyntaxException ( makePluginManagementError ( failureMessage )  ,    statement . getLineNumber (  )  ,    statement . getColumnNumber (  )  )  ,    sourceUnit )  ;", "}", "seenPluginManagementBlock    =    true ;", "return   statement ;", "} else    {", "if    ( seenPluginsBlock )     {", "String   message    =    String . format ( pluginBlockMetadataExtractor . formatErrorMessage (  \" all    % s    {  }    blocks   must   appear   before   any    % s    {  }    blocks   in   the   script \"  )  ,    scriptTarget . getClasspathBlockName (  )  ,     . PLUGINS )  ;", "sourceUnit . getErrorCollector (  )  . addError ( new   SyntaxException ( message ,    statement . getLineNumber (  )  ,    statement . getColumnNumber (  )  )  ,    sourceUnit )  ;", "}", "seenClasspathBlock    =    true ;", "return   statement ;", "}", "}", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.groovy.scripts.internal.InitialPassStatementTransformer"}, {"methodBody": ["METHOD_START", "{", "if    ( classLoader    !  =    null )     {", "knowns . put ( classLoader ,    id )  ;", "}", "}", "METHOD_END"], "methodName": ["addClassLoader"], "fileName": "org.gradle.groovy.scripts.internal.RegistryAwareClassLoaderHierarchyHasher"}, {"methodBody": ["METHOD_START", "{", "Map < ClassLoader ,    String >    knownClassLoaders    =    Maps . newHashMap (  )  ;", "String   javaVmVersion    =    String . format (  \"  % s |  % s |  % s \"  ,    System . getProperty (  \" name \"  )  ,    System . getProperty (  \" vendor \"  )  ,    System . getProperty (  \" vendor \"  )  )  ;", "ClassLoader   systemClassLoader    =    ClassLoader . getSystemClassLoader (  )  ;", "if    ( systemClassLoader    !  =    null )     {", ". addClassLoader ( knownClassLoaders ,    systemClassLoader ,     (  \" system - app \"     +    javaVmVersion )  )  ;", ". addClassLoader ( knownClassLoaders ,    systemClassLoader . getParent (  )  ,     (  \" system - ext \"     +    javaVmVersion )  )  ;", "}", "String   gradleVersion    =    GradleVersion . current (  )  . getVersion (  )  ;", ". addClassLoader ( knownClassLoaders ,    registry . getRuntimeClassLoader (  )  ,     (  \" runtime :  \"     +    gradleVersion )  )  ;", ". addClassLoader ( knownClassLoaders ,    registry . getGradleApiClassLoader (  )  ,     (  \" gradle - api :  \"     +    gradleVersion )  )  ;", ". addClassLoader ( knownClassLoaders ,    registry . getGradleCoreApiClassLoader (  )  ,     (  \" gradle - core - api :  \"     +    gradleVersion )  )  ;", ". addClassLoader ( knownClassLoaders ,    registry . getPluginsClassLoader (  )  ,     (  \" plugins :  \"     +    gradleVersion )  )  ;", "return   knownClassLoaders ;", "}", "METHOD_END"], "methodName": ["collectKnownClassLoaders"], "fileName": "org.gradle.groovy.scripts.internal.RegistryAwareClassLoaderHierarchyHasher"}, {"methodBody": ["METHOD_START", "{", "AstUtils . filterAndTransformStatements ( source ,    transformer )  ;", "Iterator < ImportNode >    iter    =    source . getAST (  )  . getImports (  )  . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "ImportNode   importedClass    =    iter . next (  )  ;", "if    (  !  ( AstUtils . isVisible ( source ,    importedClass . getClassName (  )  )  )  )     {", "try    {", "Field   field    =    ModuleNode . class . getDeclaredField (  \" imports \"  )  ;", "field . setAccessible ( true )  ;", "Map   value    =     (  ( Map )     ( field . get ( source . getAST (  )  )  )  )  ;", "value . remove ( importedClass . getAlias (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}", "iter    =    source . getAST (  )  . getStaticImports (  )  . values (  )  . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "ImportNode   importedClass    =    iter . next (  )  ;", "if    (  !  ( AstUtils . isVisible ( source ,    importedClass . getClassName (  )  )  )  )     {", "iter . remove (  )  ;", "}", "}", "iter    =    source . getAST (  )  . getStaticStarImports (  )  . values (  )  . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "ImportNode   importedClass    =    iter . next (  )  ;", "if    (  !  ( AstUtils . isVisible ( source ,    importedClass . getClassName (  )  )  )  )     {", "iter . remove (  )  ;", "}", "}", "ClassNode   scriptClass    =    AstUtils . getScriptClass ( source )  ;", "Iterator < ClassNode >    classes    =    source . getAST (  )  . getClasses (  )  . iterator (  )  ;", "while    ( classes . hasNext (  )  )     {", "ClassNode   classNode    =    classes . next (  )  ;", "if    ( classNode    !  =    scriptClass )     {", "classes . remove (  )  ;", "}", "}", "if    ( scriptClass    !  =    null )     {", "for    ( MethodNode   methodNode    :    new   ArrayList < MethodNode >  ( scriptClass . getMethods (  )  )  )     {", "if    (  !  ( methodNode . getName (  )  . equals (  \" run \"  )  )  )     {", "AstUtils . removeMethod ( scriptClass ,    methodNode )  ;", "}", "}", "}", "source . getAST (  )  . getMethods (  )  . clear (  )  ;", "}", "METHOD_END"], "methodName": ["call"], "fileName": "org.gradle.groovy.scripts.internal.SubsetScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "return   Phases . CONVERSION ;", "}", "METHOD_END"], "methodName": ["getPhase"], "fileName": "org.gradle.groovy.scripts.internal.SubsetScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "AstUtils . visitScriptCode ( source ,    new   TaskDefinitionScriptTransformer . TaskDefinitionTransformer (  )  )  ;", "}", "METHOD_END"], "methodName": ["call"], "fileName": "org.gradle.groovy.scripts.internal.TaskDefinitionScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "return   Phases . CANONICALIZATION ;", "}", "METHOD_END"], "methodName": ["getPhase"], "fileName": "org.gradle.groovy.scripts.internal.TaskDefinitionScriptTransformer"}, {"methodBody": ["METHOD_START", "{", "checkPreconditions ( registry )  ;", "List < Identifier >    matches    =    new   ArrayList < Identifier >  (  )  ;", "select ( registry ,    matches )  ;", "return    !  ( matches . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["containsProject"], "fileName": "org.gradle.initialization.AbstractProjectSpec"}, {"methodBody": ["METHOD_START", "{", "checkPreconditions ( registry )  ;", "List < T >    matches    =    new   ArrayList < T >  (  )  ;", "select ( registry ,    matches )  ;", "if    ( matches . isEmpty (  )  )     {", "throw   new   InvalidUserDataException ( formatNoMatchesMessage (  )  )  ;", "}", "if    (  ( matches . size (  )  )     !  =     1  )     {", "throw   new   InvalidUserDataException ( formatMultipleMatchesMessage ( matches )  )  ;", "}", "return   matches . get (  0  )  ;", "}", "METHOD_END"], "methodName": ["selectProject"], "fileName": "org.gradle.initialization.AbstractProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Multiple   projects   in   this   build   have   build   file    '  % s '  :     % s \"  ,    buildFile ,    matches )  ;", "}", "METHOD_END"], "methodName": ["formatMultipleMatchesMessage"], "fileName": "org.gradle.initialization.BuildFileProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" No   projects   in   this   build   have   build   file    '  % s '  .  \"  ,    buildFile )  ;", "}", "METHOD_END"], "methodName": ["formatNoMatchesMessage"], "fileName": "org.gradle.initialization.BuildFileProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   BuildLayoutParametersBuildOptions . options ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.initialization.BuildLayoutParametersBuildOptions"}, {"methodBody": ["METHOD_START", "{", "actualStartParameter    =    new   StartParameterInternal (  )  ;", "actualStartParameter . setCurrentDir ( currentDir )  ;", "c . convert ( Arrays . asList ( args )  ,    actualStartParameter )  ;", "checkStartParameter ( actualStartParameter )  ;", "}", "METHOD_END"], "methodName": ["checkConversion"], "fileName": "org.gradle.initialization.CommandLineConverterTestSupport"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( expectedBuildFile ,    startParameter . getBuildFile (  )  )  ;", "assertEquals ( expectedTaskNames ,    startParameter . getTaskNames (  )  )  ;", "assertEquals ( buildProjectDependencies ,    startParameter . isBuildProjectDependencies (  )  )  ;", "if    (  ( expectedCurrentDir )     !  =    null )     {", "assertEquals ( expectedCurrentDir . getAbsoluteFile (  )  ,    startParameter . getCurrentDir (  )  . getAbsoluteFile (  )  )  ;", "}", "assertEquals ( expectedProjectDir ,    startParameter . getProjectDir (  )  )  ;", "assertEquals ( expectedSearchUpwards ,    startParameter . isSearchUpwards (  )  )  ;", "assertEquals ( expectedProjectProperties ,    startParameter . getProjectProperties (  )  )  ;", "assertEquals ( expectedSystemProperties ,    startParameter . getSystemPropertiesArgs (  )  )  ;", "assertEquals ( expectedGUserHome . getAbsoluteFile (  )  ,    startParameter . getGUserHomeDir (  )  . getAbsoluteFile (  )  )  ;", "assertEquals ( expectedLogLevel ,    startParameter . getLogLevel (  )  )  ;", "assertEquals ( expectedConsoleOutput ,    startParameter . getConsoleOutput (  )  )  ;", "assertEquals ( expectedDryRun ,    startParameter . isDryRun (  )  )  ;", "assertEquals ( expectedShowStackTrace ,    startParameter . getShowStacktrace (  )  )  ;", "assertEquals ( expectedExcludedTasks ,    startParameter . getExcludedTaskNames (  )  )  ;", "assertEquals ( expectedInitScripts ,    startParameter . getInitScripts (  )  )  ;", "assertEquals ( expectedProfile ,    startParameter . isProfile (  )  )  ;", "assertEquals ( expectedContinue ,    startParameter . isContinueOnFailure (  )  )  ;", "assertEquals ( expectedOffline ,    startParameter . isOffline (  )  )  ;", "assertEquals ( expectedRecompileScripts ,    startParameter . isRecompileScripts (  )  )  ;", "assertEquals ( expectedRerunTasks ,    startParameter . isRerunTasks (  )  )  ;", "assertEquals ( expectedRefreshDependencies ,    startParameter . isRefreshDependencies (  )  )  ;", "assertEquals ( expectedProjectCacheDir ,    startParameter . getProjectCacheDir (  )  )  ;", "assertEquals ( expectedConfigureOnDemand ,    startParameter . isConfigureOnDemand (  )  )  ;", "assertEquals ( expectedMaxWorkersCount ,    startParameter . getMaxWorkerCount (  )  )  ;", "assertEquals ( expectedContinuous ,    startParameter . isContinuous (  )  )  ;", "assertEquals ( expectedParticipants ,    startParameter . getIncludedBuilds (  )  )  ;", "}", "METHOD_END"], "methodName": ["checkStartParameter"], "fileName": "org.gradle.initialization.CommandLineConverterTestSupport"}, {"methodBody": ["METHOD_START", "{", "boolean   returnValue ;", "synchronized ( lock )     {", "returnValue    =    cancelled ;", "if    (  !  ( cancelled )  )     {", "callbacks . add ( cHandler )  ;", "}", "}", "if    ( returnValue )     {", "cHandler . run (  )  ;", "}", "return   returnValue ;", "}", "METHOD_END"], "methodName": ["addCallback"], "fileName": "org.gradle.initialization.DefaultBuildCancellationToken"}, {"methodBody": ["METHOD_START", "{", "List < Runnable >    toCall    =    new   ArrayList < Runnable >  (  )  ;", "synchronized ( lock )     {", "if    ( cancelled )     {", "return ;", "}", "cancelled    =    true ;", "toCall . addAll ( callbacks )  ;", "callbacks . clear (  )  ;", "}", "List < Throwable >    failures    =    new   ArrayList < Throwable >  (  )  ;", "for    ( Runnable   callback    :    toCall )     {", "try    {", "callback . run (  )  ;", "}    catch    ( Throwable   ex )     {", "failures . add ( ex )  ;", "}", "}", "if    (  !  ( failures . isEmpty (  )  )  )     {", "throw   new   DefaultMultiCauseException (  \" Failed   to   run   c   actions .  \"  ,    failures )  ;", "}", "}", "METHOD_END"], "methodName": ["cancel"], "fileName": "org.gradle.initialization.DefaultBuildCancellationToken"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "return   ced ;", "}", "}", "METHOD_END"], "methodName": ["isCancellationRequested"], "fileName": "org.gradle.initialization.DefaultBuildCancellationToken"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "callbacks . remove ( cHandler )  ;", "}", "}", "METHOD_END"], "methodName": ["removeCallback"], "fileName": "org.gradle.initialization.DefaultBuildCancellationToken"}, {"methodBody": ["METHOD_START", "{", "return   new   Clock ( startTime )  ;", "}", "METHOD_END"], "methodName": ["getBuildTimeClock"], "fileName": "org.gradle.initialization.DefaultBuildRequestMetaData"}, {"methodBody": ["METHOD_START", "{", "return   clientMetaData ;", "}", "METHOD_END"], "methodName": ["getClient"], "fileName": "org.gradle.initialization.DefaultBuildRequestMetaData"}, {"methodBody": ["METHOD_START", "{", "FilteringClassLoader . Spec   apiSpec    =    new   FilteringClassLoader . Spec (  )  ;", "GradleApiSpecProvider . Spec   apiAggregate    =    new   GradleApiSpecAggregator ( classLoader )  . aggregate (  )  ;", "for    ( String   resourcePrefix    :    apiAggregate . getExportedResourcePrefixes (  )  )     {", "apiSpec . allowResources ( resourcePrefix )  ;", "}", "for    ( String   packageName    :    apiAggregate . getExportedPackages (  )  )     {", "apiSpec . allowPackage ( packageName )  ;", "}", "return   apiSpec ;", "}", "METHOD_END"], "methodName": ["apiSpecFor"], "fileName": "org.gradle.initialization.DefaultClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   new   CachingClassLoader ( new   FilteringClassLoader ( parent ,    spec )  )  ;", "}", "METHOD_END"], "methodName": ["restrictTo"], "fileName": "org.gradle.initialization.DefaultClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   DefaultClassLoaderRegistry . restrictTo ( DefaultClassLoaderRegistry . apiSpecFor ( classLoader )  ,    classLoader )  ;", "}", "METHOD_END"], "methodName": ["restrictToGradleApi"], "fileName": "org.gradle.initialization.DefaultClassLoaderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   coreAndPluginsScope ;", "}", "METHOD_END"], "methodName": ["getCoreAndPluginsScope"], "fileName": "org.gradle.initialization.DefaultClassLoaderScopeRegistry"}, {"methodBody": ["METHOD_START", "{", "return   coreScope ;", "}", "METHOD_END"], "methodName": ["getCoreScope"], "fileName": "org.gradle.initialization.DefaultClassLoaderScopeRegistry"}, {"methodBody": ["METHOD_START", "{", "loggingConfigurationCommandLineConverter . configure ( parser )  ;", "parallelConfigurationCommandLineConverter . configure ( parser )  ;", "systemPropertiesCommandLineConverter . configure ( parser )  ;", "projectPropertiesCommandLineConverter . configure ( parser )  ;", "layou . configure ( parser )  ;", "parser . allowMixedSubcommandsAndOptions (  )  ;", "for    ( BuildOption <  ?    extends   StartParameter >    option    :    buildOptions )     {", "option . configure ( parser )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.initialization.DefaultCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "loggingConfigurationCommandLineConverter . convert ( options ,    startParameter )  ;", "parallelConfigurationCommandLineConverter . convert ( options ,    startParameter )  ;", "Transformer < File ,    String >    resolver    =    new   BasicFileResolver ( startParameter . getCurrentDir (  )  )  ;", "Map < String ,    String >    systemProperties    =    systemPropertiesCommandLineConverter . convert ( options ,    new   HashMap < String ,    String >  (  )  )  ;", "convertCommandLineSystemProperties ( systemProperties ,    startParameter ,    resolver )  ;", "Map < String ,    String >    projectProperties    =    projectPropertiesCommandLineConverter . convert ( options ,    new   HashMap < String ,    String >  (  )  )  ;", "startParameter . getProjectProperties (  )  . putAll ( projectProperties )  ;", "BuildLayoutParameters   layout    =    new   BuildLayoutParameters (  )  . setGradleUserHomeDir ( startParameter . getGradleUserHomeDir (  )  )  . setProjectDir ( startParameter . getProjectDir (  )  )  . setCurrentDir ( startParameter . getCurrentDir (  )  )  ;", "layou . convert ( options ,    layout )  ;", "startParameter . setGradleUserHomeDir ( layout . getGradleUserHomeDir (  )  )  ;", "if    (  ( layout . getProjectDir (  )  )     !  =    null )     {", "startParameter . setProjectDir ( layout . getProjectDir (  )  )  ;", "}", "startParameter . setSearchUpwards ( layout . getSearchUpwards (  )  )  ;", "if    (  !  ( options . getExtraArguments (  )  . isEmpty (  )  )  )     {", "startParameter . setTaskNames ( options . getExtraArguments (  )  )  ;", "}", "for    ( BuildOption < StartParameterInternal >    option    :    buildOptions )     {", "option . applyFromCommandLine ( options ,    startParameter )  ;", "}", "for    ( String   deprecation    :    layout . getDeprecations (  )  )     {", "startParameter . addDeprecation ( deprecation )  ;", "}", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.initialization.DefaultCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "startParameter . getSystemPropertiesArgs (  )  . putAll ( systemProperties )  ;", "if    ( systemProperties . containsKey ( StartParameter . GRADLE _ USER _ HOME _ PROPERTY _ KEY )  )     {", "startParameter . setGUserHomeDir ( resolver . transform ( systemProperties . get ( StartParameter . GRADLE _ USER _ HOME _ PROPERTY _ KEY )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["convertCommandLineSystemProperties"], "fileName": "org.gradle.initialization.DefaultCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "return   layoutCommandLineConverter ;", "}", "METHOD_END"], "methodName": ["getLayoutConverter"], "fileName": "org.gradle.initialization.DefaultCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "return   systemPropertiesCommandLineConverter ;", "}", "METHOD_END"], "methodName": ["getSystemPropertiesConverter"], "fileName": "org.gradle.initialization.DefaultCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "expectedGradleUserHome    =    testDir . file (  \" home \"  )  ;", "String   propName    =     \" user . home \"  ;", "String   propValue    =     \" home 2  \"  ;", "expectedSystemProperties    =    WrapUtil . toMap ( propName ,    propValue )  ;", "checkConversion (  \"  - D \"  ,     (  ( propName    +     \"  =  \"  )     +    propValue )  ,     \"  - g \"  ,    expectedGradleUserHome . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["privilegeCmdLineOptionOverSystemPrefForGradleUserHome"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - A \"  )  ;", "}", "METHOD_END"], "methodName": ["withAParameterWithoutArgument"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedConsoleOutput    =    ConsoleOutput . Rich ;", "checksion (  \"  -  - console \"  ,     \" rich \"  )  ;", "}", "METHOD_END"], "methodName": ["withColor"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedConsoleOutput    =    ConsoleOutput . Verbose ;", "checksion (  \"  -  - console \"  ,     \" verbose \"  )  ;", "}", "METHOD_END"], "methodName": ["withColorVerbose"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "File   build 1     =    currentDir . getParentFile (  )  . file (  \" build 1  \"  )  ;", "expectedParticipants . add ( build 1  )  ;", "checksion (  \"  -  - include - build \"  ,     \"  .  .  / build 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["withCompositeBuild"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedConfigureOnDemand    =    true ;", "checksion (  \"  -  - configure - on - demand \"  )  ;", "}", "METHOD_END"], "methodName": ["withConfigureOnDemand"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedContinue    =    true ;", "checksion (  \"  -  - continue \"  )  ;", "}", "METHOD_END"], "methodName": ["withContinue"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedContinuous    =    true ;", "checksion (  \"  -  - continuous \"  )  ;", "}", "METHOD_END"], "methodName": ["withContinuous"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedContinuous    =    true ;", "checksion (  \"  - t \"  )  ;", "}", "METHOD_END"], "methodName": ["withContinuousShortFlag"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedLogLevel    =    LogLevel . DEBUG ;", "checksion (  \"  - d \"  )  ;", "}", "METHOD_END"], "methodName": ["withDebugLoggingOptions"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedDryRun    =    true ;", "checksion (  \"  -  - dry - run \"  )  ;", "}", "METHOD_END"], "methodName": ["withDryRun"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedDryRun    =    true ;", "checksion (  \"  - m \"  )  ;", "}", "METHOD_END"], "methodName": ["withDryRunShortFlag"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - e \"  ,     \" someScript \"  ,     \"  - u \"  ,     \" clean \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmbeddedScriptAndConflictingNoSearchUpwardsOption"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - e \"  ,     \" someScript \"  ,     \"  - bsomeFile \"  ,     \" clean \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmbeddedScriptAndConflictingSpecifyBuildFileOption"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - e \"  ,     \" someScript \"  ,     \"  - csomeFile \"  ,     \" clean \"  )  ;", "}", "METHOD_END"], "methodName": ["withEmbeddedScriptAndConflictingSpecifySettingsFileOption"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedExcludedTasks . add (  \" excluded \"  )  ;", "checksion (  \"  - x \"  ,     \" excluded \"  )  ;", "expectedExcludedTasks . add (  \" excluded 2  \"  )  ;", "checksion (  \"  - x \"  ,     \" excluded \"  ,     \"  - x \"  ,     \" excluded 2  \"  )  ;", "}", "METHOD_END"], "methodName": ["withExcludeTask"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedLogLevel    =    LogLevel . INFO ;", "checksion (  \"  - i \"  )  ;", "}", "METHOD_END"], "methodName": ["withInfoLoggingOptions"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "File   script 1     =    currentDir . file (  \" init 1  . gradle \"  )  ;", "expectedInitScripts . add ( script 1  )  ;", "checkConversion (  \"  - Iinit 1  . gradle \"  )  ;", "File   script 2     =    currentDir . file (  \" init 2  . gradle \"  )  ;", "expectedInitScripts . add ( script 2  )  ;", "checkConversion (  \"  - Iinit 1  . gradle \"  ,     \"  - Iinit 2  . gradle \"  )  ;", "}", "METHOD_END"], "methodName": ["withInitScripts"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  -  - max - workers \"  ,     \" foo \"  )  ;", "}", "METHOD_END"], "methodName": ["withInvalidMaxWorkers"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - p \"  )  ;", "}", "METHOD_END"], "methodName": ["withLowerPParameterWithoutArgument"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedMaxWorkersCount    =     5  ;", "checksion (  \"  -  - max - workers \"  ,     \"  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["withMaxWorkers"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedConsoleOutput    =    ConsoleOutput . Plain ;", "checksion (  \"  -  - console \"  ,     \" plain \"  )  ;", "}", "METHOD_END"], "methodName": ["withNoColor"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "buildProjectDependencies    =    false ;", "checksion (  \"  -  - no - rebuild \"  )  ;", "}", "METHOD_END"], "methodName": ["withNoProjectDependencyRebuild"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "buildProjectDependencies    =    false ;", "checksion (  \"  - a \"  )  ;", "}", "METHOD_END"], "methodName": ["withNoProjectDependencyRebuildShortFlag"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedOffline    =    true ;", "checksion (  \"  -  - offline \"  )  ;", "checksion (  \"  - offline \"  )  ;", "}", "METHOD_END"], "methodName": ["withOffline"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedParallelProjectExecution    =    true ;", "checksion (  \"  -  - parallel \"  )  ;", "}", "METHOD_END"], "methodName": ["withParallelExecutor"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedProfile    =    true ;", "checksion (  \"  -  - profile \"  )  ;", "}", "METHOD_END"], "methodName": ["withProfile"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedLogLevel    =    LogLevel . QUIET ;", "checksion (  \"  - q \"  )  ;", "}", "METHOD_END"], "methodName": ["withQuietLoggingOptions"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedRecompileScripts    =    true ;", "checksion (  \"  -  - recompile - scripts \"  )  ;", "}", "METHOD_END"], "methodName": ["withRecompileScripts"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedRefreshDependencies    =    true ;", "checksion (  \"  -  - refresh - dependencies \"  )  ;", "checksion (  \"  - refresh - dependencies \"  )  ;", "}", "METHOD_END"], "methodName": ["withRefreshDependencies"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedRerunTasks    =    true ;", "checksion (  \"  -  - rerun - tasks \"  )  ;", "}", "METHOD_END"], "methodName": ["withRerunTasks"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedSearchUpwards    =    false ;", "checksion (  \"  - u \"  )  ;", "}", "METHOD_END"], "methodName": ["withSearchUpwardsFlagSet"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedShowStackTrace    =    ShowStacktrace . ALWAYS _ FULL ;", "checksion (  \"  - S \"  )  ;", "}", "METHOD_END"], "methodName": ["withShowFullStacktrace"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedShowStackTrace    =    ShowStacktrace . ALWAYS ;", "checksion (  \"  - s \"  )  ;", "}", "METHOD_END"], "methodName": ["withShowStacktrace"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - sf \"  )  ;", "}", "METHOD_END"], "methodName": ["withShowStacktraceAndShowFullStacktraceShouldThrowCommandLineArgumentEx"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedBuildFile    =    testDir . file (  \" somename \"  )  ;", "expectedCurrentDir    =    expectedBuildFile . getParentFile (  )  ;", "expectedProjectDir    =    expectedCurrentDir ;", "checksion (  \"  - b \"  ,    expectedBuildFile . getAbsolutePath (  )  )  ;", "expectedBuildFile    =    currentDir . file (  \" somename \"  )  ;", "expectedCurrentDir    =    expectedBuildFile . getParentFile (  )  ;", "expectedProjectDir    =    expectedCurrentDir ;", "checksion (  \"  - b \"  ,     \" somename \"  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedBuildFileName"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedGradleUserHome    =    testDir . file (  \" home \"  )  ;", "checksion (  \"  - g \"  ,    expectedGradleUserHome . getAbsolutePath (  )  )  ;", "expectedGradleUserHome    =    currentDir . file (  \" home \"  )  ;", "checksion (  \"  - g \"  ,     \" home \"  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedGradleUserHomeDirectory"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedGradleUserHome    =    testDir . file (  \" home \"  )  ;", "String   propName    =     \" user . home \"  ;", "String   propValue    =    expectedGradleUserHome . getAbsolutePath (  )  ;", "expectedSystemProperties    =    WrapUtil . toMap ( propName ,    propValue )  ;", "checkConversion (  \"  - D \"  ,     (  ( propName    +     \"  =  \"  )     +    propValue )  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedGradleUserHomeDirectoryBySystemProperty"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedProjectCacheDir    =    new   File ( currentDir ,     \"  . foo \"  )  ;", "checksion (  \"  -  - project - cache - dir \"  ,     \"  . foo \"  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedProjectCacheDir"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedCurrentDir    =    testDir . file (  \" project - dir \"  )  ;", "expectedProjectDir    =    expectedCurrentDir ;", "checksion (  \"  - p \"  ,    expectedCurrentDir . getAbsolutePath (  )  )  ;", "expectedCurrentDir    =    currentDir . file (  \" project - dir \"  )  ;", "expectedProjectDir    =    expectedCurrentDir ;", "checksion (  \"  - p \"  ,     \" project - dir \"  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedProjectDirectory"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "File   expectedSettingsFile    =    currentDir . file (  \" somesettings \"  )  ;", "expectedCurrentDir    =    expectedSettingsFile . getParentFile (  )  ;", "checksion (  \"  - c \"  ,     \" somesettings \"  )  ;", "Assert . assertThat ( actualStartParameter . getSettingsFile (  )  ,    Matchers . equalTo (  (  ( File )     ( expectedSettingsFile )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["withSpecifiedSettingsFileName"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "final   String   prop 1     =     \" prop 1  \"  ;", "final   String   valueProp 1     =     \" value 1  \"  ;", "final   String   prop 2     =     \" prop 2  \"  ;", "final   String   valueProp 2     =     \" value 2  \"  ;", "expectedProjectProperties    =    WrapUtil . toMap ( prop 1  ,    valueProp 1  )  ;", "expectedProjectProperties . put ( prop 2  ,    valueProp 2  )  ;", "checksion (  \"  - P \"  ,     (  ( prop 1     +     \"  =  \"  )     +    valueProp 1  )  ,     \"  - P \"  ,     (  ( prop 2     +     \"  =  \"  )     +    valueProp 2  )  )  ;", "}", "METHOD_END"], "methodName": ["withStartProperties"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "final   String   prop 1     =     \" gradle . prop 1  \"  ;", "final   String   valueProp 1     =     \" value 1  \"  ;", "final   String   prop 2     =     \" gradle . prop 2  \"  ;", "final   String   valueProp 2     =     \" value 2  \"  ;", "expectedSystemProperties    =    WrapUtil . toMap ( prop 1  ,    valueProp 1  )  ;", "expectedSystemProperties . put ( prop 2  ,    valueProp 2  )  ;", "checkConversion (  \"  - D \"  ,     (  ( prop 1     +     \"  =  \"  )     +    valueProp 1  )  ,     \"  - D \"  ,     (  ( prop 2     +     \"  =  \"  )     +    valueProp 2  )  )  ;", "}", "METHOD_END"], "methodName": ["withSystemProperties"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedTaskNames    =    WrapUtil . toList (  \" someTask \"  ,     \"  -  - some - task - option \"  )  ;", "checksion (  \" someTask \"  ,     \"  -  - some - task - option \"  )  ;", "}", "METHOD_END"], "methodName": ["withTaskAndTaskOption"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedTaskNames    =    WrapUtil . toList (  \" a \"  ,     \" b \"  )  ;", "checksion (  \" a \"  ,     \" b \"  )  ;", "}", "METHOD_END"], "methodName": ["withTaskNames"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - C \"  ,     \" unknown \"  )  ;", "}", "METHOD_END"], "methodName": ["withUnknownCacheFlags"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  -  - unknown \"  )  ;", "}", "METHOD_END"], "methodName": ["withUnknownOption"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  \"  - a \"  ,     \"  - Atask 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["withUpperAAndLowerAParameter"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "expectedLogLevel    =    LogLevel . WARN ;", "checksion (  \"  - w \"  )  ;", "}", "METHOD_END"], "methodName": ["withWarnLoggingOptions"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "checkConversion (  )  ;", "}", "METHOD_END"], "methodName": ["withoutAnyOptions"], "fileName": "org.gradle.initialization.DefaultCommandLineConverterTest"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    ( gkeeper . equals ( openedBy )  )     {", "openedBy    =    null ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.initialization.DefaultContinuousExecutionGate"}, {"methodBody": ["METHOD_START", "{", "return    ( openedBy )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isClosed"], "fileName": "org.gradle.initialization.DefaultContinuousExecutionGate"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    ( isClosed (  )  )     {", "openedBy    =    gkeeper ;", "opened . signalAll (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.initialization.DefaultContinuousExecutionGate"}, {"methodBody": ["METHOD_START", "{", "Throwable   locationAware    =    null ;", "Throwable   result    =    null ;", "Throwable   contextMatch    =    null ;", "for    ( Throwable   current    =    exception ;    current    !  =    null ;    current    =    current . getCause (  )  )     {", "if    ( current   instanceof   LocationAwareException )     {", "locationAware    =    current ;", "} else", "if    (  ( current   instanceof   GradleScriptException )     |  |     ( current   instanceof   TaskExecutionException )  )     {", "result    =    current ;", "} else", "if    (  ( contextMatch    =  =    null )     &  &     (  ( current . getClass (  )  . getAnnotation ( ternal . exceptions . Contextual . class )  )     !  =    null )  )     {", "contextMatch    =    current ;", "}", "}", "if    ( locationAware    !  =    null )     {", "return   locationAware ;", "} else", "if    ( result    !  =    null )     {", "return   result ;", "} else", "if    ( contextMatch    !  =    null )     {", "return   contextMatch ;", "} else    {", "return   exception ;", "}", "}", "METHOD_END"], "methodName": ["findDeepestRootException"], "fileName": "org.gradle.initialization.DefaultExceptionAnalyser"}, {"methodBody": ["METHOD_START", "{", "Throwable   actualException    =    findDeepestRootException ( exception )  ;", "if    ( actualException   instanceof   LocationAwareException )     {", "return   actualException ;", "}", "ScriptSource   source    =    null ;", "Integer   lineNumber    =    null ;", "if    ( actualException   instanceof   ScriptCompilationException )     {", "ScriptCompilationException   scriptCompilationException    =     (  ( ScriptCompilationException )     ( actualException )  )  ;", "source    =    scriptCompilationException . getScriptSource (  )  ;", "lineNumber    =    scriptCompilationException . getLineNumber (  )  ;", "}", "if    ( source    =  =    null )     {", "for    ( Throwable   currentException    =    actualException ;    currentException    !  =    null ;    currentException    =    currentException . getCause (  )  )     {", "for    ( StackTraceElement   element    :    currentException . getStackTrace (  )  )     {", "if    (  (  ( element . getLineNumber (  )  )     >  =     0  )     &  &     ( scripts . containsKey ( element . getFileName (  )  )  )  )     {", "source    =    scripts . get ( element . getFileName (  )  )  ;", "lineNumber    =    element . getLineNumber (  )  ;", "break ;", "}", "}", "}", "}", "return   new   LocationAwareException ( actualException ,    source ,    lineNumber )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.initialization.DefaultExceptionAnalyser"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     =  =     ( DefaultGradleLauncher . Stage . Load )  )     {", "buildOperationExecutor . run ( new   DefaultGradleLauncher . ConfigureBuild (  )  )  ;", "stage    =    DefaultGradleLauncher . Stage . Configure ;", "}", "}", "METHOD_END"], "methodName": ["configureBuild"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     =  =     ( DefaultGradleLauncher . Stage . Configure )  )     {", "buildOperationExecutor . run ( new   DefaultGradleLauncher . CalculateTaskGraph (  )  )  ;", "stage    =    DefaultGradleLauncher . Stage . TaskGraph ;", "}", "}", "METHOD_END"], "methodName": ["constructTaskGraph"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "if    ( isNestedBuild (  )  )     {", "Path   contextPath    =    findIdentityPath (  )  ;", "String   context    =     ( contextPath    =  =    null )     ?    getStartParameter (  )  . getCurrentDir (  )  . getName (  )     :    contextPath . getPath (  )  ;", "return    (  ( descriptor    +     \"     (  \"  )     +    context )     +     \"  )  \"  ;", "}", "return   descriptor ;", "}", "METHOD_END"], "methodName": ["contextualize"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "try    {", "loadSettings (  )  ;", "if    ( upTo    =  =     (  . Stage . Load )  )     {", "return ;", "}", "configureBuild (  )  ;", "if    ( upTo    =  =     (  . Stage . Configure )  )     {", "return ;", "}", "constructTaskGraph (  )  ;", "if    ( upTo    =  =     (  . Stage . TaskGraph )  )     {", "return ;", "}", "runTasks (  )  ;", "finishBuild (  )  ;", "}    catch    ( Throwable   t )     {", "Throwable   failure    =    exceptionAnalyser . transform ( t )  ;", "finishBuild ( new   BuildResult ( upTo . name (  )  ,    gradle ,    failure )  )  ;", "throw   new   ReportedException ( failure )  ;", "}", "}", "METHOD_END"], "methodName": ["doBuildStages"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "doBuildStages ( DefaultGradleLauncher . Stage . Build )  ;", "return   gradle ;", "}", "METHOD_END"], "methodName": ["executeTasks"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     =  =     ( DefaultGradleLauncher . Stage . Finished )  )     {", "return ;", "}", "if    (  !  ( isNestedBuild (  )  )  )     {", "gradle . getServices (  )  . get ( IncludedBuildControllers . class )  . stopTaskExecution (  )  ;", "}", "buildListener . buildFinished ( result )  ;", "stage    =    DefaultGradleLauncher . Stage . Finished ;", "}", "METHOD_END"], "methodName": ["finishBuild"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "return   gradle . getStartParameter (  )  . isConfigureOnDemand (  )  ;", "}", "METHOD_END"], "methodName": ["isConfigureOnDemand"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "return    ( gradle . getParent (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isNestedBuild"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     =  =    null )     {", "buildListener . buildStarted ( gradle )  ;", "buildOperationExecutor . run ( new    . LoadBuild (  )  )  ;", "stage    =     . Stage . Load ;", "}", "}", "METHOD_END"], "methodName": ["loadSettings"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "buildListener . projectsEvaluated ( gradle )  ;", "}", "METHOD_END"], "methodName": ["projectsEvaluated"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( stage )     !  =     ( DefaultGradleLauncher . Stage . TaskGraph )  )     {", "throw   new   IllegalStateException (  (  \" Cannot   execute   tasks :    current   stage    =     \"     +     ( stage )  )  )  ;", "}", "buildOperationExecutor . run ( new   DefaultGradleLauncher . ExecuteTasks (  )  )  ;", "stage    =    DefaultGradleLauncher . Stage . Build ;", "}", "METHOD_END"], "methodName": ["runTasks"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "try    {", "CompositeStoppable . stoppable ( buildServices )  . add ( servicesToStop )  . stop (  )  ;", "}    finally    {", "buildCompleListener . completed (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.initialization.DefaultGradleLauncher"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   services    =    parent . getGradle (  )  . getServices (  )  ;", "BuildRequestMetaData   requestMetaData    =    new   DefaultBuildRequestMetaData ( services . get ( BuildClientMetaData . class )  )  ;", "BuildCancellationToken   cancellationToken    =    services . get ( BuildCancellationToken . class )  ;", "BuildEventConsumer   buildEventConsumer    =    services . get ( BuildEventConsumer . class )  ;", "return   doNewInstance ( buildDefinition ,    parent ,    cancellationToken ,    requestMetaData ,    buildEventConsumer ,    buildTreeScopeServices ,    servicesToStop )  ;", "}", "METHOD_END"], "methodName": ["createChildInstance"], "fileName": "org.gradle.initialization.DefaultGradleLauncherFactory"}, {"methodBody": ["METHOD_START", "{", "BuildScopeServices   serviceRegistry    =    new   BuildScopeServices ( buildTreeScopeServices )  ;", "serviceRegistry . add ( BuildDefinition . class ,    buildDefinition )  ;", "serviceRegistry . add ( BuildRequestMetaData . class ,    requestMetaData )  ;", "serviceRegistry . add ( BuildClientMetaData . class ,    requestMetaData . getClient (  )  )  ;", "serviceRegistry . add ( BuildEventConsumer . class ,    buildEventConsumer )  ;", "serviceRegistry . add ( BuildCancellationToken . class ,    cancellationToken )  ;", "serviceRegistry . add ( BuildIdentity . class ,    new   DefaultBuildIdentity ( buildDefinition ,     ( parent    =  =    null )  )  )  ;", ". NestedBuildFactoryImpl   nestedBuildFactory    =    new    . NestedBuildFactoryImpl ( buildTreeScopeServices )  ;", "serviceRegistry . add ( NestedBuildFactory . class ,    nestedBuildFactory )  ;", "StartParameter   startParameter    =    buildDefinition . getStartParameter (  )  ;", "ListenerManager   listenerManager    =    serviceRegistry . get ( ListenerManager . class )  ;", "LoggerProvider   loggerProvider    =     ( parent    =  =    null )     ?    buildProgressLogger    :    LoggerProvider . NO _ OP ;", "listenerManager . useLogger ( new   TaskExecutionLogger ( serviceRegistry . get ( ProgressLoggerFactory . class )  ,    loggerProvider )  )  ;", "if    ( parent    =  =    null )     {", "BuildStartedTime   buildStartedTime    =    serviceRegistry . get ( BuildStartedTime . class )  ;", "Clock   clock    =    serviceRegistry . get ( Clock . class )  ;", "listenerManager . useLogger ( new   BuildLogger ( Logging . getLogger ( BuildLogger . class )  ,    serviceRegistry . get ( StyledTextOutputFactory . class )  ,    startParameter ,    requestMetaData ,    buildStartedTime ,    clock )  )  ;", "}", "listenerManager . addListener ( serviceRegistry . get ( TaskExecutionStatisticsEventAdapter . class )  )  ;", "listenerManager . addListener ( new   TaskExecutionStatisticsReporter ( serviceRegistry . get ( StyledTextOutputFactory . class )  )  )  ;", "listenerManager . addListener ( serviceRegistry . get ( ProfileEventAdapter . class )  )  ;", "if    ( startParameter . isProfile (  )  )     {", "listenerManager . addListener ( new   ReportGeneratingProfileListener ( serviceRegistry . get ( StyledTextOutputFactory . class )  )  )  ;", "}", "ScriptUsageLocationReporter   usageLocationReporter    =    new   ScriptUsageLocationReporter (  )  ;", "listenerManager . addListener ( usageLocationReporter )  ;", "ShowStacktrace   showStacktrace    =    startParameter . getShowStacktrace (  )  ;", "switch    ( showStacktrace )     {", "case   ALWAYS    :", "case   ALWAYS _ FULL    :", "LoggingDeprecatedFeatureHandler . setTraceLoggingEnabled ( true )  ;", "break ;", "default    :", "LoggingDeprecatedFeatureHandler . setTraceLoggingEnabled ( false )  ;", "}", "DeprecationLogger . init ( usageLocationReporter ,    startParameter . getWarningMode (  )  )  ;", "SettingsLoaderFactory   settingsLoaderFactory    =    serviceRegistry . get ( SettingsLoaderFactory . class )  ;", "SettingsLoader   settingsLoader    =     ( parent    !  =    null )     ?    settingsLoaderFactory . forNestedBuild (  )     :    settingsLoaderFactory . forTopLevelBuild (  )  ;", "GradleInternal   parentBuild    =     ( parent    =  =    null )     ?    null    :    parent . getGradle (  )  ;", "GradleInternal   gradle    =    serviceRegistry . get ( Instantiator . class )  . newInstance ( DefaultGradle . class ,    parentBuild ,    startParameter ,    serviceRegistry . get ( ServiceRegistryFactory . class )  )  ;", "DefaultGradleLauncher   gradleLauncher    =    new   DefaultGradleLauncher ( gradle ,    serviceRegistry . get ( InitScriptHandler . class )  ,    settingsLoader ,    serviceRegistry . get ( BuildLoader . class )  ,    serviceRegistry . get ( BuildConfigurer . class )  ,    serviceRegistry . get ( ExceptionAnalyser . class )  ,    gradle . getBuildListenerBroadcaster (  )  ,    listenerManager . getBroadcaster ( ModelConfigurationListener . class )  ,    listenerManager . getBroadcaster ( BuildCompletionListener . class )  ,    serviceRegistry . get ( BuildOperationExecutor . class )  ,    gradle . getServices (  )  . get ( BuildConfigurationActionExecuter . class )  ,    gradle . getServices (  )  . get ( BuildExecuter . class )  ,    serviceRegistry ,    servicesToStop )  ;", "nestedBuildFactory . setParent ( gradleLauncher )  ;", "return   gradleLauncher ;", "}", "METHOD_END"], "methodName": ["doNewInstance"], "fileName": "org.gradle.initialization.DefaultGradleLauncherFactory"}, {"methodBody": ["METHOD_START", "{", "for    ( File   propertyFile    :    files )     {", "if    ( propertyFile . isFile (  )  )     {", "properties    =    GUtil . load ( propertyFile )  ;", "target . putAll ( new   HashMap ( properties )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addGradleProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "for    ( String   key    :    properties . keySet (  )  )     {", "if    ( key . startsWith (  (  ( Project . SYSTEM _ PROP _ PREFIX )     +     '  .  '  )  )  )     {", "System . setProperty ( key . substring (  (  ( Project . SYSTEM _ PROP _ PREFIX )     +     '  .  '  )  . length (  )  )  ,    properties . get ( key )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["addSystemPropertiesFromGradleProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "return   System . getenv (  )  ;", "}", "METHOD_END"], "methodName": ["getAllEnvProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getAllSystemProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    envProjectProperties    =    new   HashMap < String ,    String >  (  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    envProperties . entrySet (  )  )     {", "if    (  ( entry . getKey (  )  . startsWith ( IGradlePropertiesLoader . ENV _ PROJECT _ PROPERTIES _ PREFIX )  )     &  &     (  ( entry . getKey (  )  . length (  )  )     >     ( IGradlePropertiesLoader . ENV _ PROJECT _ PROPERTIES _ PREFIX . length (  )  )  )  )     {", "envProjectProperties . put ( entry . getKey (  )  . substring ( IGradlePropertiesLoader . ENV _ PROJECT _ PROPERTIES _ PREFIX . length (  )  )  ,    entry . getValue (  )  )  ;", "}", "}", ". LOGGER . debug (  \" Found   env   project   properties :     {  }  \"  ,    envProjectProperties . keySet (  )  )  ;", "return   envProjectProperties ;", "}", "METHOD_END"], "methodName": ["getEnvProjectProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    systemProjectProperties    =    new   HashMap < String ,    String >  (  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    systemProperties . entrySet (  )  )     {", "if    (  ( entry . getKey (  )  . startsWith ( IGradlePropertiesLoader . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX )  )     &  &     (  ( entry . getKey (  )  . length (  )  )     >     ( IGradlePropertiesLoader . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX . length (  )  )  )  )     {", "systemProjectProperties . put ( entry . getKey (  )  . substring ( IGradlePropertiesLoader . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX . length (  )  )  ,    entry . getValue (  )  )  ;", "}", "}", ". LOGGER . debug (  \" Found   system   project   properties :     {  }  \"  ,    systemProjectProperties . keySet (  )  )  ;", "return   systemProjectProperties ;", "}", "METHOD_END"], "methodName": ["getSystemProjectProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "loadProperties ( settingsDir ,    startParameter ,    getAllSystemProperties (  )  ,    getAllEnvProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "defaultProperties . clear (  )  ;", "overrideProperties . clear (  )  ;", "add ( defaultProperties ,    new   File ( settingsDir ,    Project . GRADLE _ PROPERTIES )  )  ;", "add ( overrideProperties ,    new   File ( startParameter . getGradleUserHomeDir (  )  ,    Project . GRADLE _ PROPERTIES )  )  ;", "setSystemProperties ( startParameter . getSystemPropertiesArgs (  )  )  ;", "overrideProperties . putAll ( getEnvProjectProperties ( envProperties )  )  ;", "overrideProperties . putAll ( getSystemProjectProperties ( systemProperties )  )  ;", "overrideProperties . putAll ( startParameter . getProjectProperties (  )  )  ;", "}", "METHOD_END"], "methodName": ["loadProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    result    =    new   HashMap < String ,    String >  (  )  ;", "result . putAll ( defaultProperties )  ;", "result . putAll ( properties )  ;", "result . putAll ( overrid )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["mergeProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "addSystemPropertiesFromGradleProperties ( defaultProperties )  ;", "addSystemPropertiesFromGradleProperties ( overrideProperties )  ;", "System . getProperties (  )  . putAll ( properties )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoader"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" gradle - loader - test \"  ,     \" value \"  )  ;", "assertTrue ( g . getAllSystemProperties (  )  . containsKey (  \" gradle - loader - test \"  )  )  ;", "assertEquals (  \" value \"  ,    g . getAllSystemProperties (  )  . get (  \" gradle - loader - test \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildSystemProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "Map < String ,    String >    projectProperties    =    GUtil . map (  \" prop \"  ,     \" project   value \"  )  ;", "envProperties    =    GUtil . map (  (  ( I . ENV _ PROJECT _ PROPERTIES _ PREFIX )     +     \" prop \"  )  ,     \" env   value \"  )  ;", "gradlePropertiesLoader . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    gradlePropertiesLoader . mergeProperties ( projectProperties )  ;", "assertEquals (  \" env   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["environmentVariablesHavePrecedenceOverProjectProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "tmpDir . getTestDirectory (  )  . deleteDir (  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "}", "METHOD_END"], "methodName": ["loadPropertiesWithNoExceptionForNonExistingUserHomeAndSettingsDir"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "startParameter . setSystemPropertiesArgs ( WrapUtil . toMap (  \" systemPropArgKey \"  ,     \" systemPropArgValue \"  )  )  ;", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  (  ( Project . SYSTEM _ PROP _ PREFIX )     +     \"  . userSystemProp \"  )  ,     \" userSystemValue \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  (  ( Project . SYSTEM _ PROP _ PREFIX )     +     \"  . userSystemProp \"  )  ,     \" settingsSystemValue \"  ,     (  ( Project . SYSTEM _ PROP _ PREFIX )     +     \"  . settingsSystemProp 2  \"  )  ,     \" settingsSystemValue 2  \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "assertEquals (  \" userSystemValue \"  ,    System . getProperty (  \" userSystemProp \"  )  )  ;", "assertEquals (  \" settingsSystemValue 2  \"  ,    System . getProperty (  \" settingsSystemProp 2  \"  )  )  ;", "assertEquals (  \" systemPropArgValue \"  ,    System . getProperty (  \" systemPropArgKey \"  )  )  ;", "}", "METHOD_END"], "methodName": ["loadSetsSystemProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "envProperties    =    GUtil . map (  (  ( IGradlePropertiesLoader . ENV _ PROJECT _ PROPERTIES _ PREFIX )     +     \" envProp \"  )  ,     \" env   value \"  ,     \" ignoreMe \"  ,     \" ignored \"  )  ;", "gradlePropertiesLoader . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    gradlePropertiesLoader . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" env   value \"  ,    properties . get (  \" envProp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeAddsPropertiesFromEnvironmentVariablesWithPrefix"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( settingsDir ,    GUtil . map (  \" settingsProp \"  ,     \" settings   value \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" settings   value \"  ,    properties . get (  \" settingsProp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeAddsPropertiesFromSettingsPropertiesFile"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "startParameter . setProjectProperties ( GUtil . map (  \" paramProp \"  ,     \" param   value \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" param   value \"  ,    properties . get (  \" paramProp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeAddsPropertiesFromStartParameter"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "systemProperties    =    GUtil . map (  (  ( IGradlePropertiesLoader . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX )     +     \" systemProp \"  )  ,     \" system   value \"  ,     \" ignoreMe \"  ,     \" ignored \"  )  ;", "gradlePropertiesLoader . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    gradlePropertiesLoader . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" system   value \"  ,    properties . get (  \" systemProp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeAddsPropertiesFromSystemPropertiesWithPrefix"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" userProp \"  ,     \" user   value \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" user   value \"  ,    properties . get (  \" userProp \"  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeAddsPropertiesFromUserPropertiesFile"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "Map < String ,    String >    projectProperties    =    GUtil . map (  \" prop \"  ,     \" project   value \"  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( projectProperties )  ;", "assertEquals (  \" project   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["projectPropertiesHavePrecedenceOverSettingsPropertiesFile"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop 1  \"  ,     \" value \"  ,     \" prop 2  \"  ,     \" value \"  )  )  ;", "File   otherSettingsDir    =    tmpDir . createDir (  \" otherSettingsDir \"  )  ;", "writePropertyFile ( otherSettingsDir ,    GUtil . map (  \" prop 1  \"  ,     \" otherValue \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" value \"  ,    properties . get (  \" prop 1  \"  )  )  ;", "assertEquals (  \" value \"  ,    properties . get (  \" prop 2  \"  )  )  ;", "g . loadProperties ( otherSettingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" otherValue \"  ,    properties . get (  \" prop 1  \"  )  )  ;", "assertNull ( properties . get (  \" prop 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["reloadsProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "gradleUserHomeDir    =    tmpDir . createDir (  \" gradleUserHome \"  )  ;", "settingsDir    =    tmpDir . createDir (  \" settingsDir \"  )  ;", "gradlePropertiesLoader    =    new    ( startParameter )  ;", "startParameter . setGradleUserHomeDir ( gradleUserHomeDir )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "Map < String ,    String >    projectProperties    =    GUtil . map (  \" prop \"  ,     \" project   value \"  )  ;", "envProperties    =    GUtil . map (  (  ( I . ENV _ PROJECT _ PROPERTIES _ PREFIX )     +     \" prop \"  )  ,     \" env   value \"  )  ;", "systemProperties    =    GUtil . map (  (  ( I . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX )     +     \" prop \"  )  ,     \" system   value \"  )  ;", "startParameter . setProjectProperties ( GUtil . map (  \" prop \"  ,     \" param   value \"  )  )  ;", "gradlePropertiesLoader . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    gradlePropertiesLoader . mergeProperties ( projectProperties )  ;", "assertEquals (  \" param   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["startParameterPropertiesHavePrecedenceOverSystemProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" systemProp . prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" systemProp . prop \"  ,     \" settings   value \"  )  )  ;", "systemProperties    =    GUtil . map (  \" prop \"  ,     \" system   value \"  )  ;", "startParameter . setSystemPropertiesArgs ( WrapUtil . toMap (  \" prop \"  ,     \" commandline   value \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "assertEquals (  \" commandline   value \"  ,    System . getProperty (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["startParameterSystemPropertiesHavePrecedenceOverPropertiesFiles"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "Map < String ,    String >    projectProperties    =    GUtil . map (  \" prop \"  ,     \" project   value \"  )  ;", "envProperties    =    GUtil . map (  (  ( I . ENV _ PROJECT _ PROPERTIES _ PREFIX )     +     \" prop \"  )  ,     \" env   value \"  )  ;", "systemProperties    =    GUtil . map (  (  ( I . SYSTEM _ PROJECT _ PROPERTIES _ PREFIX )     +     \" prop \"  )  ,     \" system   value \"  )  ;", "gradlePropertiesLoader . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    gradlePropertiesLoader . mergeProperties ( projectProperties )  ;", "assertEquals (  \" system   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["systemPropertiesHavePrecedenceOverEnvironmentVariables"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "Map < String ,    String >    projectProperties    =    GUtil . map (  \" prop \"  ,     \" project   value \"  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( projectProperties )  ;", "assertEquals (  \" user   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["userPropertiesFileHasPrecedenceOverProjectProperties"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "writePropertyFile ( gradleUserHomeDir ,    GUtil . map (  \" prop \"  ,     \" user   value \"  )  )  ;", "writePropertyFile ( settingsDir ,    GUtil . map (  \" prop \"  ,     \" settings   value \"  )  )  ;", "g . loadProperties ( settingsDir ,    startParameter ,    systemProperties ,    envProperties )  ;", "Map < String ,    String >    properties    =    g . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \" user   value \"  ,    properties . get (  \" prop \"  )  )  ;", "}", "METHOD_END"], "methodName": ["userPropertiesFileHasPrecedenceOverSettingsPropertiesFile"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "Properties   properties    =    new   Properties (  )  ;", "properties . putAll ( propertiesMap )  ;", "GUtil . sav ( properties ,    new   File ( location ,    Project . GRADLE _ PROPERTIES )  )  ;", "}", "METHOD_END"], "methodName": ["writePropertyFile"], "fileName": "org.gradle.initialization.DefaultGradlePropertiesLoaderTest"}, {"methodBody": ["METHOD_START", "{", "File   toolsJar    =    Jvm . current (  )  . getToolsJar (  )  ;", "if    ( toolsJar    !  =    null )     {", "final   ClassLoader   systemClassLoaderParent    =    classLoaderFactory . getIsolatedSystemClassLoader (  )  ;", "ClasspathUtil . addUrl (  (  ( URLClassLoader )     ( systemClassLoaderParent )  )  ,    new   ClassPath ( toolsJar )  . getAsURLs (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initializeJdkTools"], "fileName": "org.gradle.initialization.DefaultJdkToolsInitializer"}, {"methodBody": ["METHOD_START", "{", "Set < String >    classNames    =    new   HashSet < String >  (  )  ;", "URL   resource    =     . class . getResource ( resourceName )  ;", "try    {", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( resource . openStream (  )  )  )  ;", "try    {", "String   line ;", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "classNames . add ( line . trim (  )  )  ;", "}", "}    finally    {", "reader . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "throw   new   GradleException (  (  (  \" Could   not   load   class   names   from    '  \"     +    resource )     +     \"  '  .  \"  )  ,    e )  ;", "}", "return   classNames ;", "}", "METHOD_END"], "methodName": ["readClassNames"], "fileName": "org.gradle.initialization.DefaultLegacyTypesSupport"}, {"methodBody": ["METHOD_START", "{", "return   this . path . child ( path )  ;", "}", "METHOD_END"], "methodName": ["absolutePath"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buildFileName )     !  =    null )     {", "return   new   File ( getProjectDir (  )  ,    buildFileName )  ;", "}", "File   buildScriptFile    =    scriptFileResolver . resolveScriptFile ( getProjectDir (  )  ,     . BUILD _ SCRIPT _ BASENAME )  ;", "if    ( buildScriptFile    !  =    null )     {", "return   buildScriptFile ;", "}", "return   new   File ( getProjectDir (  )  ,    Project . DEFAULT _ BUILD _ FILE )  ;", "}", "METHOD_END"], "methodName": ["buildFile"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  ( o    =  =    null )     |  |     (  ( getClass (  )  )     !  =     ( o . getClass (  )  )  )  )     {", "return   false ;", "}", "that    =     (  (  )     ( o )  )  ;", "return    ( Objects . equal ( this . getParent (  )  ,    that . getParent (  )  )  )     &  &     ( Objects . equal ( this . getName (  )  ,    that . getName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   FileUtils . normalize ( buildFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildFile"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   buildFile (  )  . getName (  )  ;", "}", "METHOD_END"], "methodName": ["getBuildFileName"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getChildren"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   name ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParent"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   parent ;", "}", "METHOD_END"], "methodName": ["getParentIdentifier"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   path . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   projectDescriptorRegistry ;", "}", "METHOD_END"], "methodName": ["getProjectDescriptorRegistry"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( canonicalDir )     =  =    null )     {", "canonicalDir    =    fileResolver . resolve ( dir )  ;", "}", "return   canonicalDir ;", "}", "METHOD_END"], "methodName": ["getProjectDir"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   Objects . hashCode ( this . getParent (  )  ,    this . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return    ( parent )     =  =    null ;", "}", "METHOD_END"], "methodName": ["isRootDescriptor"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( isRootDescriptor (  )  )     {", "return   path    =    Path . ROOT ;", "} else    {", "return   parent . absolutePath ( name )  ;", "}", "}", "METHOD_END"], "methodName": ["path"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . buildFileName    =    name ;", "}", "METHOD_END"], "methodName": ["setBuildFileName"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "NameValidator . validate ( name ,     \" project   name \"  ,    DefaultProjectDescriptor . INVALID _ NAME _ IN _ INCLUDE _ HINT )  ;", "projectDescriptorRegistry . changeDescriptorPath ( path ,    path ( name )  )  ;", "this . name    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . path    =    path ;", "}", "METHOD_END"], "methodName": ["setPath"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . projectDescriptorRegistry    =    projectDescriptorRegistry ;", "}", "METHOD_END"], "methodName": ["setProjectDescriptorRegistry"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "this . canonicalDir    =    null ;", "this . dir    =    dir ;", "}", "METHOD_END"], "methodName": ["setProjectDir"], "fileName": "org.gradle.initialization.DefaultProjectDescriptor"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDescriptor   projectDescriptor    =    removeProject ( oldPath . toString (  )  )  ;", "projectDescriptor . setPath ( newPath )  ;", "addProject ( projectDescriptor )  ;", "}", "METHOD_END"], "methodName": ["changeDescriptorPath"], "fileName": "org.gradle.initialization.DefaultProjectDescriptorRegistry"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDescriptor   rootProject    =    new   DefaultProjectDescriptor ( null ,     \" testName \"  ,    DefaultProjectDescriptorRegistryTest . TEST _ DIR ,    registry ,    DefaultProjectDescriptorRegistryTest . FILE _ RESOLVER )  ;", "registry . addProject ( rootProject )  ;", "assertSame ( rootProject ,    registry . getProject ( rootProject . getPath (  )  )  )  ;", "assertSame ( rootProject ,    registry . getProject ( rootProject . getProjectDir (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["addProjectDescriptor"], "fileName": "org.gradle.initialization.DefaultProjectDescriptorRegistryTest"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDescriptor   project    =    new   DefaultProjectDescriptor ( null ,     \" name \"  ,    DefaultProjectDescriptorRegistryTest . TEST _ DIR ,    registry ,    DefaultProjectDescriptorRegistryTest . FILE _ RESOLVER )  ;", "registry . addProject ( project )  ;", "registry . changeDescriptorPath ( Path . path (  \"  :  \"  )  ,    Path . path (  \"  : newPath \"  )  )  ;", "assertThat ( registry . getRootProject (  )  ,    nullValue (  )  )  ;", "assertThat ( registry . getProject (  \"  :  \"  )  ,    nullValue (  )  )  ;", "assertThat ( registry . getProject (  \"  : newPath \"  )  ,    sameInstance ( project )  )  ;", "}", "METHOD_END"], "methodName": ["changeProjectDescriptorPath"], "fileName": "org.gradle.initialization.DefaultProjectDescriptorRegistryTest"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Multiple   projects   in   this   build   have   project   directory    '  % s '  :     % s \"  ,    currentDir ,    matches )  ;", "}", "METHOD_END"], "methodName": ["formatMultipleMatchesMessage"], "fileName": "org.gradle.initialization.DefaultProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" No   projects   in   this   build   have   project   directory    '  % s '  .  \"  ,    currentDir )  ;", "}", "METHOD_END"], "methodName": ["formatNoMatchesMessage"], "fileName": "org.gradle.initialization.DefaultProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectDescriptor ( parent ,    name ,    dir ,    getProjectDescriptorRegistry (  )  ,    getFileResolver (  )  )  ;", "}", "METHOD_END"], "methodName": ["createProjectDescriptor"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   getProjectDescriptorRegistry (  )  . getProject ( projectDir )  ;", "}", "METHOD_END"], "methodName": ["findProject"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   getProjectDescriptorRegistry (  )  . getProject ( path )  ;", "}", "METHOD_END"], "methodName": ["findProject"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   settingsClassLoaderScope ;", "}", "METHOD_END"], "methodName": ["getClassLoaderScope"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   defaultProjectDescriptor ;", "}", "METHOD_END"], "methodName": ["getDefaultProject"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   gradle ;", "}", "METHOD_END"], "methodName": ["getGradle"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getPluginManager"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectDescriptorRegistry"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   getProjectDescriptorRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["getProjectRegistry"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   buildRootClassLoaderScope ;", "}", "METHOD_END"], "methodName": ["getRootClassLoaderScope"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   rootProjectDescriptor . getProjectDir (  )  ;", "}", "METHOD_END"], "methodName": ["getRootDir"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   rootProjectDescriptor ;", "}", "METHOD_END"], "methodName": ["getRootProject"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptHandlerFactory"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptPluginFactory"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   services ;", "}", "METHOD_END"], "methodName": ["getServices"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   this ;", "}", "METHOD_END"], "methodName": ["getSettings"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   settingsDir ;", "}", "METHOD_END"], "methodName": ["getSettingsDir"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   settingsScript ;", "}", "METHOD_END"], "methodName": ["getSettingsScript"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["getStartParameter"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "for    ( String   projectPath    :    projectPaths )     {", "String   subPath    =     \"  \"  ;", "String [  ]    pathElements    =    removeTrailingColon ( projectPath )  . split (  \"  :  \"  )  ;", "ProjectDescriptor   parentProjectDescriptor    =    rootProjectDescriptor ;", "for    ( String   pathElement    :    pathElements )     {", "subPath    =     ( subPath    +     \"  :  \"  )     +    pathElement ;", "ProjectDescriptor   projectDescriptor    =    getProjectDescriptorRegistry (  )  . getProject ( subPath )  ;", "if    ( projectDescriptor    =  =    null )     {", "parentProjectDescriptor    =    createProjectDescriptor ( parentProjectDescriptor ,    pathElement ,    new   File ( parentProjectDescriptor . getProjectDir (  )  ,    pathElement )  )  ;", "} else    {", "parentProjectDescriptor    =    projectDescriptor ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["include"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "for    ( String   projectName    :    projectNames )     {", "createProjectDescriptor ( rootProjectDescriptor ,    projectName ,    new   File ( rootProjectDescriptor . getProjectDir (  )  . getParentFile (  )  ,    projectName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["includeFlat"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDescriptor   projectDescriptor    =    getProjectDescriptorRegistry (  )  . getProject ( projectDir )  ;", "if    ( projectDescriptor    =  =    null )     {", "throw   new   UnknownProjectException ( String . format (  \" Project   with   path    '  % s '    could   not   be   found .  \"  ,    projectDir )  )  ;", "}", "return   projectDescriptor ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "DefaultProjectDescriptor   projectDescriptor    =    getProjectDescriptorRegistry (  )  . getProject ( path )  ;", "if    ( projectDescriptor    =  =    null )     {", "throw   new   UnknownProjectException ( String . format (  \" Project   with   path    '  % s '    could   not   be   found .  \"  ,    path )  )  ;", "}", "return   projectDescriptor ;", "}", "METHOD_END"], "methodName": ["project"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "if    ( projectPath . startsWith (  \"  :  \"  )  )     {", "return   projectPath . substr (  1  )  ;", "}", "return   projectPath ;", "}", "METHOD_END"], "methodName": ["removeTrailingColon"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "this . defaultProjectDescriptor    =    defaultProjectDescriptor ;", "}", "METHOD_END"], "methodName": ["setDefaultProject"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "this . rootProjectDescriptor    =    rootProjectDescriptor ;", "}", "METHOD_END"], "methodName": ["setRootProjectDescriptor"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "this . settingsDir    =    settingsDir ;", "}", "METHOD_END"], "methodName": ["setSettingsDir"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "this . settingsScript    =    settingsScript ;", "}", "METHOD_END"], "methodName": ["setSettingsScript"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "this . startParameter    =    startParameter ;", "}", "METHOD_END"], "methodName": ["setStartParameter"], "fileName": "org.gradle.initialization.DefaultSettings"}, {"methodBody": ["METHOD_START", "{", "return   layoutFactory . getLayoutFor ( new   BuildLayoutConfiguration ( startParameter )  )  ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.initialization.DefaultSettingsFinder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( startParameter . getSettingsFile (  )  )     !  =    null )     {", "return ;", "}", "File   projectDir    =     (  ( startParameter . getProjectDir (  )  )     =  =    null )     ?    startParameter . getCurrentDir (  )     :    startParameter . getProjectDir (  )  ;", "if    ( settings . getSettingsDir (  )  . equals ( projectDir )  )     {", "return ;", "}", "for    ( ProjectDescriptor   project    :    settings . getProjectRegistry (  )  . getAllProjects (  )  )     {", "if    ( project . getProjectDir (  )  . equals ( projectDir )  )     {", "return ;", "}", "}", "DeprecationLogger . nagUserWith (  (  \" Support   for   nested   build   without   a   settings   file   was   deprecated   and   will   be   removed   in   Gradle    5  .  0  .    You   should   create   a   empty   settings   file   in    \"     +     ( projectDir . getAbsolutePath (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["deprecateWarningIfNecessary"], "fileName": "org.gradle.initialization.DefaultSettingsLoader"}, {"methodBody": ["METHOD_START", "{", "return   settingsFinder . find ( startParameter )  ;", "}", "METHOD_END"], "methodName": ["findSettings"], "fileName": "org.gradle.initialization.DefaultSettingsLoader"}, {"methodBody": ["METHOD_START", "{", "SettingsLocation   settingsLocation    =    findSettings ( startParameter )  ;", "ClassLoaderScope   buildSourceClassLoaderScope    =    buildSourceBuilder . buildAndCreateClassLoader ( gradle ,    settingsLocation . getSettingsDir (  )  ,    startParameter )  ;", "return   settingsProcessor . process ( gradle ,    settingsLocation ,    buildSourceClassLoaderScope ,    startParameter )  ;", "}", "METHOD_END"], "methodName": ["findSettingsAndLoadIfAppropriate"], "fileName": "org.gradle.initialization.DefaultSettingsLoader"}, {"methodBody": ["METHOD_START", "{", "settings . setDefaultProject ( spec . selectProject ( settings . getProjectRegistry (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultProject"], "fileName": "org.gradle.initialization.DefaultSettingsLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   CompositeBuildSettingsLoader ( defaultSettingsLoader (  )  ,    nestedBuildFactory ,    includedBuildRegistry )  ;", "}", "METHOD_END"], "methodName": ["compositeBuildSettingsLoader"], "fileName": "org.gradle.initialization.DefaultSettingsLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "final   DefaultSettingsLoader   delegate    =    new   DefaultSettingsLoader ( settingsFinder ,    settingsProcessor ,    buildSourceBuilder )  ;", "return   new   SettingsLoader (  )     {", "@ Override", "public   SettingsInternal   findAndLoadSettings ( GradleInternal   gradle )     {", "SettingsInternal   settings    =    delegate . findAndLoadSettings ( gradle )  ;", "gradle . setSettings ( settings )  ;", "return   settings ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["defaultSettingsLoader"], "fileName": "org.gradle.initialization.DefaultSettingsLoaderFactory"}, {"methodBody": ["METHOD_START", "{", "List < Class <  ?    extends   GradleApiSpecProvider >  >    providers    =    providers (  )  ;", "if    ( providers . isEmpty (  )  )     {", "return   emptySpec (  )  ;", "}", "if    (  ( providers . size (  )  )     =  =     1  )     {", "return   specFrom ( providers . get (  0  )  )  ;", "}", "return   mergeSpecsOf ( providers )  ;", "}", "METHOD_END"], "methodName": ["aggregate"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "return   new   GradleApiSpecProvider . SpecAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["emptySpec"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "return   INSTANCE . newInstance ( providerClass )  ;", "}", "METHOD_END"], "methodName": ["instantiate"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "final   ImmutableSet . Builder < String >    exportedPackages    =    ImmutableSet . builder (  )  ;", "final   ImmutableSet . Builder < String >    exportedResourcePrefixes    =    ImmutableSet . builder (  )  ;", "for    ( Class <  ?    extends   GradleApiSpecProvider >    provider    :    providers )     {", "GradleApiSpecProvider . Spec   spec    =    specFrom ( provider )  ;", "exportedPackages . addAll ( spec . getExportedPackages (  )  )  ;", "exportedResourcePrefixes . addAll ( spec . getExportedResourcePrefixes (  )  )  ;", "}", "return   new    . DefaultSpec ( exportedPackages . build (  )  ,    exportedResourcePrefixes . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["mergeSpecsOf"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServiceLocator ( classLoader )  . implementationsOf ( GradleApiSpecProvider . class )  ;", "}", "METHOD_END"], "methodName": ["providers"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "return   instantiate ( provider )  . get (  )  ;", "}", "METHOD_END"], "methodName": ["specFrom"], "fileName": "org.gradle.initialization.GradleApiSpecAggregator"}, {"methodBody": ["METHOD_START", "{", "return   getBuildscript (  )  ;", "}", "METHOD_END"], "methodName": ["getInitscript"], "fileName": "org.gradle.initialization.InitScript"}, {"methodBody": ["METHOD_START", "{", "buildscript ( configureClosure )  ;", "}", "METHOD_END"], "methodName": ["initscript"], "fileName": "org.gradle.initialization.InitScript"}, {"methodBody": ["METHOD_START", "{", "return    \" initialization   script \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.initialization.InitScript"}, {"methodBody": ["METHOD_START", "{", "final   List < File >    initScripts    =    gradle . getStartParameter (  )  . getAllInitScripts (  )  ;", "if    ( initScripts . isEmpty (  )  )     {", "return ;", "}", "buildOperationExecutor . run ( new   RunnableBuildOperation (  )     {", "@ Override", "public   void   run ( BuildOperationContext   context )     {", "BasicTextResourceLoader   resourceLoader    =    new   BasicTextResourceLoader (  )  ;", "for    ( File   script    :    initScripts )     {", "TextResource   resource    =    resourceLoader . loadFile (  \"    script \"  ,    script )  ;", "processor . process ( new   TextResourceScriptSource ( resource )  ,    gradle )  ;", "}", "}", "@ Override", "public   Builder   description (  )     {", "return   BuildOperationDescriptor . displayName (  \" Run   init   scripts \"  )  . progressDisplayName (  \" Running   init   scripts \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["executeScripts"], "fileName": "org.gradle.initialization.InitScriptHandler"}, {"methodBody": ["METHOD_START", "{", "for    ( ProjectDescriptor   childProjectDescriptor    :    parentProjectDescriptor . getChildren (  )  )     {", "ProjectInternal   childProject    =    projectFactory . createProject ( childProjectDescriptor ,    parent ,     ,    parent . getClassLoaderScope (  )  . createChild (  (  \" project -  \"     +     ( childProjectDescriptor . getName (  )  )  )  )  ,    buildRootClassLoaderScope )  ;", "addProjects ( childProject ,    childProjectDescriptor ,     ,    buildRootClassLoaderScope )  ;", "}", "}", "METHOD_END"], "methodName": ["addProjects"], "fileName": "org.gradle.initialization.InstantiatingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "gradle . setDefaultProject ( gradle . getRootProject (  )  . getProjectRegistry (  )  . getProject ( defaultProject . getPath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["attachDefaultProject"], "fileName": "org.gradle.initialization.InstantiatingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "ProjectInternal   rootProject    =    projectFactory . createProject ( rootProjectDescriptor ,    null ,       buildRootClassLoaderScope . createChild (  \" root - project \"  )  ,    buildRootClassLoaderScope )  ;", "setRootProject ( rootProject )  ;", "addProjects ( rootProject ,    rootProjectDescriptor ,       buildRootClassLoaderScope )  ;", "}", "METHOD_END"], "methodName": ["createProjects"], "fileName": "org.gradle.initialization.InstantiatingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "createProjects ( rootProjectDescriptor ,    gradle ,    buildRootClassLoaderScope )  ;", "attachDefaultProject ( defaultProject ,    gradle )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "org.gradle.initialization.InstantiatingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < BuildLayoutParameters >    option    :    buildOptions )     {", "option . configure ( parser )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.initialization.LayoutCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < BuildLayoutParameters >    option    :    buildOptions )     {", "option . applyFrom ( options ,    target )  ;", "}", "return   target ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.initialization.LayoutCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( exception   instanceof   MultipleBuildFailures )     {", "MultipleBuildFailures   multipleBuildFailures    =     (  ( MultipleBuildFailures )     ( exception )  )  ;", "List < Throwable >    transformedCauses    =    new   ArrayList < Throwable >  ( multipleBuildFailures . getCauses (  )  . size (  )  )  ;", "for    ( Throwable   cause    :    multipleBuildFailures . getCauses (  )  )     {", "transformedCauses . add ( transform ( cause )  )  ;", "}", "multipleBuildFailures . replaceCauses ( transformedCauses )  ;", "return   exception ;", "}", "return   delegate . transform ( exception )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.initialization.MultipleBuildFailuresExceptionAnalyser"}, {"methodBody": ["METHOD_START", "{", "ImmutableSortedSet . Builder < LoadProjectsBuildOperationType . Result . Project >    builder    =    new   ImmutableSortedSet . Builder < LoadProjectsBuildOperationType . Result . Project >  ( NotifyingBuildLoader . PROJECT _ COMPARATOR )  ;", "for    ( Project   child    :    children )     {", "builder . add ( convert ( child )  )  ;", "}", "return   builder . build (  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.initialization.NotifyingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   NotifyingBuildLoader . BuildStructureOperationProject ( project . getName (  )  ,    project . getPath (  )  ,     (  ( ProjectInternal )     ( project )  )  . getIdentityPath (  )  . toString (  )  ,    project . getProjectDir (  )  . getAbsolutePath (  )  ,    project . getBuildFile (  )  . getAbsolutePath (  )  ,    convert ( project . getChildProjects (  )  . values (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.initialization.NotifyingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "String   buildPath    =    gradle . getIdentityPath (  )  . toString (  )  ;", "LoadProjectsBuildOperationType . Result . Project   rootProject    =    convert ( gradle . getRootProject (  )  )  ;", "return   new    . BuildStructureOperationResult ( rootProject ,    buildPath )  ;", "}", "METHOD_END"], "methodName": ["createOperationResult"], "fileName": "org.gradle.initialization.NotifyingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "return   ParallelismBuildOptions . options ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.initialization.ParallelismBuildOptions"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < ParallelismConfiguration >    option    :    buildOptions )     {", "option . configure ( parser )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.initialization.ParallelismConfigurationCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildOption < ParallelismConfiguration >    option    :    buildOptions )     {", "option . applyFromCommandLine ( options ,    target )  ;", "}", "return   target ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.initialization.ParallelismConfigurationCommandLineConverter"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" Multiple   projects   in   this   build   have   project   directory    '  % s '  :     % s \"  ,    dir ,    matches )  ;", "}", "METHOD_END"], "methodName": ["formatMultipleMatchesMessage"], "fileName": "org.gradle.initialization.ProjectDirectoryProjectSpec"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \" No   projects   in   this   build   have   project   directory    '  % s '  .  \"  ,    dir )  ;", "}", "METHOD_END"], "methodName": ["formatNoMatchesMessage"], "fileName": "org.gradle.initialization.ProjectDirectoryProjectSpec"}, {"methodBody": ["METHOD_START", "{", "Properties   projectProperties    =    new   Properties (  )  ;", "File   projectPropertiesFile    =    new   File ( project . getProjectDir (  )  ,    Project . GRADLE _ PROPERTIES )  ;", ". LOGGER . debug (  \" Looking   for   project   properties   from :     {  }  \"  ,    projectPropertiesFile )  ;", "if    ( projectPropertiesFile . isFile (  )  )     {", "projectProperties    =    GUtil . loadProperties ( projectPropertiesFile )  ;", ". LOGGER . debug (  \" Adding   project   properties    ( if   not   overwritten   by   user   properties )  :     {  }  \"  ,    projectProperties . keySet (  )  )  ;", "} else    {", ". LOGGER . debug (  \" project   property   file   does   not   exists .    We   continue !  \"  )  ;", "}", "Map < String ,    String >    mergedProperties    =    propertiesLoader . mergeProperties ( new   HashMap ( projectProperties )  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    mergedProperties . entrySet (  )  )     {", "applicator . configureProperty ( project ,    entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addPropertiesToProject"], "fileName": "org.gradle.initialization.ProjectPropertySettingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "addPropertiesToProject ( project ,    applicator )  ;", "for    ( Project   childProject    :    project . getChildProjects (  )  . values (  )  )     {", "seties ( childProject ,    applicator )  ;", "}", "}", "METHOD_END"], "methodName": ["setProjectProperties"], "fileName": "org.gradle.initialization.ProjectPropertySettingBuildLoader"}, {"methodBody": ["METHOD_START", "{", "File   explicitProjectDir    =    startParameter . getProjectDir (  )  ;", "File   explicitBuildFile    =    startParameter . getBuildFile (  )  ;", "if    ( explicitBuildFile    !  =    null )     {", "return   new   BuildFile ( explicitBuildFile )  ;", "}", "if    ( explicitProjectDir    !  =    null )     {", "return   new   ProjectDirectory ( explicitProjectDir )  ;", "}", "return   new   Default ( startParameter . getCurrentDir (  )  ,    settings )  ;", "}", "METHOD_END"], "methodName": ["forStartParameter"], "fileName": "org.gradle.initialization.ProjectSpecs"}, {"methodBody": ["METHOD_START", "{", "propertiesLoader . loadProperties ( settingsLocation . getSettingsDir (  )  )  ;", "return   processor . process ( gradle ,    settingsLocation ,    buildRootClassLoaderScope ,    startParameter )  ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.initialization.PropertiesLoadingSettingsProcessor"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   settingsScriptSource    =    settingsLocation . getSettingsScriptSource (  )  ;", "ClassLoaderScope   settingsClassLoaderScope    =    settings . getClassLoaderScope (  )  ;", "ScriptPlugin   configurer    =    configurerFactory . create ( settingsScriptSource ,    settings . getBuildscript (  )  ,    settingsClassLoaderScope ,    settings . getRootClassLoaderScope (  )  ,    true )  ;", "configurer . apply ( settings )  ;", "}", "METHOD_END"], "methodName": ["applySettingsScript"], "fileName": "org.gradle.initialization.ScriptEvaluatingSettingsProcessor"}, {"methodBody": ["METHOD_START", "{", "Timer   settingsProcessingClock    =    Time . startTimer (  )  ;", "Map < String ,    String >    properties    =    propertiesLoader . mergeProperties ( Collections .  < String ,    String > emptyMap (  )  )  ;", "SettingsInternal   settings    =    settingsFactory . createSettings ( gradle ,    settingsLocation . getSettingsDir (  )  ,    settingsLocation . getSettingsScriptSource (  )  ,    properties ,    startParameter ,    buildRootClassLoaderScope )  ;", "applySettingsScript ( settingsLocation ,    settings )  ;", ". LOGGER . debug (  \" Timing :    Processing   settings   took :     {  }  \"  ,    settingsProcessingClock . getElapsed (  )  )  ;", "return   settings ;", "}", "METHOD_END"], "methodName": ["process"], "fileName": "org.gradle.initialization.ScriptEvaluatingSettingsProcessor"}, {"methodBody": ["METHOD_START", "{", "ClassLoaderScope   settingsClassLoaderScope    =    buildRootClassLoaderScope . createChild (  \" settings \"  )  ;", "ScriptHandlerInternal   settingsScriptHandler    =    scriptHandlerFactory . create ( settingsScript ,    settingsClassLoaderScope )  ;", "Default   settings    =    instantiator . newInstance ( Default . class ,    serviceRegistryFactory ,    gradle ,    settingsClassLoaderScope ,    buildRootClassLoaderScope ,    settingsScriptHandler ,    settingsDir ,    settingsScript ,    startParameter )  ;", "DynamicObject   dynamicObject    =     (  ( DynamicObjectAware )     ( settings )  )  . getAsDynamicObject (  )  ;", "(  ( ExtensibleDynamicObject )     ( dynamicObject )  )  . addProperties ( gradleProperties )  ;", "return   settings ;", "}", "METHOD_END"], "methodName": ["createSettings"], "fileName": "org.gradle.initialization.SettingsFactory"}, {"methodBody": ["METHOD_START", "{", "return   settingsDir ;", "}", "METHOD_END"], "methodName": ["getSettingsDir"], "fileName": "org.gradle.initialization.SettingsLocation"}, {"methodBody": ["METHOD_START", "{", "return   settingsScriptSource ;", "}", "METHOD_END"], "methodName": ["getSettingsScriptSource"], "fileName": "org.gradle.initialization.SettingsLocation"}, {"methodBody": ["METHOD_START", "{", "return   getScriptTarget (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.initialization.SettingsScript"}, {"methodBody": ["METHOD_START", "{", "return   StackTraceUtils . deepSanitize ( analyser . transform ( exception )  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.initialization.StackTraceSanitizingExceptionAnalyser"}, {"methodBody": ["METHOD_START", "{", "return   StartParameterBuildOptions . options ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.initialization.StartParameterBuildOptions"}, {"methodBody": ["METHOD_START", "{", "File   buildSrcDir    =    new   File ( rootDir ,    DefaultSettings . DEFAULT _ BUILD _ SRC _ DIR )  ;", "ClassPath   classpath    =    createClasspath ( gradle ,    buildSrcDir ,    containingBuildParameters )  ;", "return   classLoaderScope . createChild ( buildSrcDir . getAbsolutePath (  )  )  . export ( classpath )  . lock (  )  ;", "}", "METHOD_END"], "methodName": ["buildAndCreateClassLoader"], "fileName": "org.gradle.initialization.buildsrc.BuildSourceBuilder"}, {"methodBody": ["METHOD_START", "{", "BuildController   buildController    =    createBuildController ( buildDefinition )  ;", "try    {", "File   lockTarget    =    new   File ( buildDefinition . getBuildRootDir (  )  ,     \"  . gradle / noVersion / buildSrc \"  )  ;", "FileLock   lock    =    fileLockManager . lock ( lockTarget ,     . LOCK _ OPTIONS ,     \" buildSrc   build   lock \"  )  ;", "try    {", "return   new   BuildSrcUpdateFactory ( buildController ,    buildSrcBuildListenerFactory ,    cachedClasspathTransformer )  . create (  )  ;", "}    finally    {", "lock . close (  )  ;", "}", "}    finally    {", "buildController . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildBuildSrc"], "fileName": "org.gradle.initialization.buildsrc.BuildSourceBuilder"}, {"methodBody": ["METHOD_START", "{", "GradleLauncher   gradleLauncher    =    nestedBuildFactory . nestedInstance ( buildDefinition )  ;", "StartParameter   startParameter    =    buildDefinition . getStartParameter (  )  ;", "GradleInternal   build    =    gradleLauncher . getGradle (  )  ;", "if    (  ( build . getParent (  )  . findIdentityPath (  )  )     =  =    null )     {", "Path   path    =    build . getParent (  )  . getParent (  )  . getIdentityPath (  )  . child ( startParameter . getCurrentDir (  )  . getParentFile (  )  . getName (  )  )  . child ( startParameter . getCurrentDir (  )  . getName (  )  )  ;", "build . setIdentityPath ( path )  ;", "}", "return   gradleLauncher ;", "}", "METHOD_END"], "methodName": ["buildGradleLauncher"], "fileName": "org.gradle.initialization.buildsrc.BuildSourceBuilder"}, {"methodBody": ["METHOD_START", "{", "GradleLauncher   gradleLauncher    =    buildGradleLauncher ( buildDefinition )  ;", "return   new   GradleBuildController ( gradleLauncher )  ;", "}", "METHOD_END"], "methodName": ["createBuildController"], "fileName": "org.gradle.initialization.buildsrc.BuildSourceBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( buildSrcDir . isDirectory (  )  )  )     {", ". LOGGER . debug (  \" Gradle   source   dir   does   not   exist .    We   leave .  \"  )  ;", "return   ClassPath . EMPTY ;", "}", "final   StartParameter   buildSrcStartParameter    =    containingBuildParameters . newBuild (  )  ;", "buildSrcStartParameter . setCurrentDir ( buildSrcDir )  ;", "buildSrcStartParameter . setProjectProperties ( containingBuildParameters . getProjectProperties (  )  )  ;", "buildSrcStartParameter . setSearchUpwards ( false )  ;", "buildSrcStartParameter . setProfile ( containingBuildParameters . isProfile (  )  )  ;", "final   BuildDefinition   buildDefinition    =    BuildDefinition . fromStartParameterForBuild ( buildSrcStartParameter ,    buildSrcDir ,    DefaultPluginRequests . EMPTY )  ;", "assert    ( buildSrcStartParameter . getBuildFile (  )  )     =  =    null ;", "return   buildOperationExecutor . call ( new   CallableBuildOperation < ClassPath >  (  )     {", "@ Override", "public   ClassPath   call ( BuildOperationContext   context )     {", "ClassPath   classPath    =    buildBuildSrc ( buildDefinition )  ;", "context . setResult (  . BUILD _ BUILDSRC _ RESULT )  ;", "return   classPath ;", "}", "@ Override", "public   Builder   description (  )     {", "return   BuildOperationDescriptor . displayName (  \" Build   buildSrc \"  )  . progressDisplayName (  \" Building   buildSrc \"  )  . details ( new   BuildBuildSrcBuildOperationType . Details (  )     {", "@ Override", "public   String   getBuildPath (  )     {", "return   gradle . getIdentityPath (  )  . toString (  )  ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createBuildSourceClasspath"], "fileName": "org.gradle.initialization.buildsrc.BuildSourceBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildSrcBuildListenerFactory . Listener ( buildSrcRootProjectConfiguration )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.initialization.buildsrc.BuildSrcBuildListenerFactory"}, {"methodBody": ["METHOD_START", "{", "BuildSrcBuildListenerFactory . Listener   listener    =    listenerFactory . create (  )  ;", "GradleInternal   gradle    =    buildController . getGradle (  )  ;", "gradle . addListener ( listener )  ;", "buildController . run (  )  ;", "return   listener . getRuntimeClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.initialization.buildsrc.BuildSrcUpdateFactory"}, {"methodBody": ["METHOD_START", "{", "Collection < File >    classpath    =    build (  )  ;", ". LOGGER . debug (  \" Gradle   source   classpath   is :     {  }  \"  ,    classpath )  ;", "return   cachedClasspathTransformer . transform ( new   DefaultClassPath ( classpath )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.initialization.buildsrc.BuildSrcUpdateFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( dependencies . isEmpty (  )  )     {", "return   DefaultPluginRequests . EMPTY ;", "}", "return   new   DefaultPluginRequests ( listPluginRequests (  )  )  ;", "}", "METHOD_END"], "methodName": ["getRequests"], "fileName": "org.gradle.initialization.definition.DefaultInjectedPluginDependencies"}, {"methodBody": ["METHOD_START", "{", "List < PluginRequestInternal >    pluginRequests    =    CollectionUtils . collect ( dependencies ,    new   Transformer < PluginRequestInternal ,    DefaultInjectedPluginDependency >  (  )     {", "public   PluginRequestInternal   transform ( DefaultInjectedPluginDependency   original )     {", "return   new   SelfResolvingPluginRequest ( original . getId (  )  ,    classLoaderScope )  ;", "}", "}  )  ;", "Map < PluginId ,    Collection < PluginRequestInternal >  >    groupedById    =    CollectionUtils . groupBy ( pluginRequests ,    new   Transformer < PluginId ,    PluginRequestInternal >  (  )     {", "public   PluginId   transform ( PluginRequestInternal   pluginRequest )     {", "return   pluginRequest . getId (  )  ;", "}", "}  )  ;", "for    ( PluginId   key    :    groupedById . keySet (  )  )     {", "Collection < PluginRequestInternal >    pluginRequestsForId    =    groupedById . get ( key )  ;", "if    (  ( pluginRequestsForId . size (  )  )     >     1  )     {", "PluginRequestInternal   first    =    pluginRequests . get (  0  )  ;", "throw   new   InvalidPluginRequestException ( first ,     (  (  \" Plugin   with   id    '  \"     +    key )     +     \"  '    was   already   requested .  \"  )  )  ;", "}", "}", "return   pluginRequests ;", "}", "METHOD_END"], "methodName": ["listPluginRequests"], "fileName": "org.gradle.initialization.definition.DefaultInjectedPluginDependencies"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.initialization.definition.DefaultInjectedPluginDependency"}, {"methodBody": ["METHOD_START", "{", "return   classLoaderScope ;", "}", "METHOD_END"], "methodName": ["getClassLoaderScope"], "fileName": "org.gradle.initialization.definition.SelfResolvingPluginRequest"}, {"methodBody": ["METHOD_START", "{", "return   rootDirectory ;", "}", "METHOD_END"], "methodName": ["getRootDirectory"], "fileName": "org.gradle.initialization.layout.BuildLayout"}, {"methodBody": ["METHOD_START", "{", "return   currentDir ;", "}", "METHOD_END"], "methodName": ["getCurrentDir"], "fileName": "org.gradle.initialization.layout.BuildLayoutConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   settingsFile ;", "}", "METHOD_END"], "methodName": ["getSettingsFile"], "fileName": "org.gradle.initialization.layout.BuildLayoutConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   searchUpwards ;", "}", "METHOD_END"], "methodName": ["isSearchUpwards"], "fileName": "org.gradle.initialization.layout.BuildLayoutConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   useEmptySettings ;", "}", "METHOD_END"], "methodName": ["isUseEmptySettings"], "fileName": "org.gradle.initialization.layout.BuildLayoutConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildLayout ( configuration . getCurrentDir (  )  ,    configuration . getCurrentDir (  )  ,    settingsFile )  ;", "}", "METHOD_END"], "methodName": ["buildLayoutFrom"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptFileResolver (  )  . resolveScriptFile ( directory ,    BuildLayoutFactory . DEFAULT _ SETTINGS _ FILE _ BASENAME )  ;", "}", "METHOD_END"], "methodName": ["findExistingSettingsFileIn"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "return   getLayoutFor ( currentDir ,     ( searchUpwards    ?    null    :    currentDir . getParentFile (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getLayoutFor"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "File   settingsFile    =    findExistingSettingsFileIn ( currentDir )  ;", "if    ( settingsFile    !  =    null )     {", "return    ( currentDir ,    settingsFile )  ;", "}", "for    ( File   candidate    =    currentDir . getParentFile (  )  ;     ( candidate    !  =    null )     &  &     (  !  ( candidate . equals ( stopAt )  )  )  ;    candidate    =    candidate . getParentFile (  )  )     {", "settingsFile    =    findExistingSettingsFileIn ( candidate )  ;", "if    ( settingsFile    =  =    null )     {", "settingsFile    =    findExistingSettingsFileIn ( new   File ( candidate ,     \" master \"  )  )  ;", "}", "if    ( settingsFile    !  =    null )     {", "return    ( candidate ,    settingsFile )  ;", "}", "}", "return    ( currentDir ,    new   File ( currentDir ,    Settings . DEFAULT _ SETTINGS _ FILE )  )  ;", "}", "METHOD_END"], "methodName": ["getLayoutFor"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( configuration . isUseEmptySettings (  )  )     {", "return   brom ( configuration ,    null )  ;", "}", "File   explicitSettingsFile    =    configuration . getSettingsFile (  )  ;", "if    ( explicitSettingsFile    !  =    null )     {", "if    (  !  ( explicitSettingsFile . isFile (  )  )  )     {", "throw   new   MissingResourceException ( explicitSettingsFile . toURI (  )  ,    String . format (  \" Could   not   read   settings   file    '  % s '    as   it   does   not   exist .  \"  ,    explicitSettingsFile . getAbsolutePath (  )  )  )  ;", "}", "return   brom ( configuration ,    explicitSettingsFile )  ;", "}", "File   currentDir    =    configuration . getCurrentDir (  )  ;", "boolean   searchUpwards    =    configuration . isSearchUpwards (  )  ;", "return   getLayoutFor ( currentDir ,     ( searchUpwards    ?    null    :    currentDir . getParentFile (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getLayoutFor"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildLayout ( rootDir ,    settingsFile . getParentFile (  )  ,    FileUtils . canonicalize ( settingsFile )  )  ;", "}", "METHOD_END"], "methodName": ["layout"], "fileName": "org.gradle.initialization.layout.BuildLayoutFactory"}, {"methodBody": ["METHOD_START", "{", "return   dir ;", "}", "METHOD_END"], "methodName": ["getDir"], "fileName": "org.gradle.initialization.layout.ProjectCacheDir"}, {"methodBody": ["METHOD_START", "{", "resolution . text (  \"    Run   with    \"  )  ;", "resolution . withStyle ( UserInput )  . format (  \"  -  -  % s \"  ,    StartParameterBuildOptionScanOption . LONG _ OPTION )  ;", "resolution . text (  \"    to   get   full   insights .  \"  )  ;", "}", "METHOD_END"], "methodName": ["addBuildScanMessage"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "Throwable   failure    =    result . getFailure (  )  ;", "if    ( failure    =  =    null )     {", "return ;", "}", "execute ( failure )  ;", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "BuildExceptionReporter . FailureDetails   details    =    new   BuildExceptionReporter . FailureDetails ( failure )  ;", "reportBuildFailure ( granularity ,    failure ,    details )  ;", "return   details ;", "}", "METHOD_END"], "methodName": ["constructFailureDetails"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "if    ( failure   instanceof   MultipleBuildFailures )     {", "List < Throwable >    flattenedFailures    =    new   ArrayList < Throwable >  (  )  ;", "flattenMultipleBuildFailures (  (  ( MultipleBuildFailures )     ( failure )  )  ,    flattenedFailures )  ;", "renderMultiples ( flattenedFailures )  ;", "return ;", "}", "renderSingle ( failure )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "BufferingStyledTextOutput   resolution    =    details . resolution ;", "if    (  ( details . failure )    instanceof   FailureResolutionAware )     {", "(  ( FailureResolutionAware )     ( details . failure )  )  . appendResolution ( resolution ,    clientMetaData )  ;", "if    ( resolution . getHasContent (  )  )     {", "resolution . append (  '     '  )  ;", "}", "}", "if    (  ( details . exceptionStyle )     =  =     (  . ExceptionStyle . NONE )  )     {", "resolution . text (  \" Run   with    \"  )  ;", "resolution . withStyle ( UserInput )  . format (  \"  -  -  % s \"  ,    STACKTRACE _ LONG _ OPTION )  ;", "resolution . text (  \"    option   to   get   the   stack   trace .     \"  )  ;", "}", "if    (  ( loggingConfiguration . getLogLevel (  )  )     !  =     ( LogLevel . DEBUG )  )     {", "resolution . text (  \" Run   with    \"  )  ;", "if    (  ( loggingConfiguration . getLogLevel (  )  )     !  =     ( LogLevel . INFO )  )     {", "resolution . withStyle ( UserInput )  . format (  \"  -  -  % s \"  ,    INFO _ LONG _ OPTION )  ;", "resolution . text (  \"    or    \"  )  ;", "}", "resolution . withStyle ( UserInput )  . format (  \"  -  -  % s \"  ,    DEBUG _ LONG _ OPTION )  ;", "resolution . text (  \"    option   to   get   more   log   output .  \"  )  ;", "}", "addBuildScanMessage ( resolution )  ;", "}", "METHOD_END"], "methodName": ["fillInFailureResolution"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "for    ( Throwable   cause    :    multipleFailures . getCauses (  )  )     {", "if    ( cause   instanceof   MultipleFailures )     {", "flattenMultipleFailures (  (  ( MultipleFailures )     ( cause )  )  ,    flattenedFailures )  ;", "} else    {", "flattenedFailures . add ( cause )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["flattenMultipleBuildFailures"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "details . summary . format (  \"  % s   failed   with   an   exception .  \"  ,    granularity )  ;", "fillInFailureResolution ( details )  ;", "if    ( failure   instanceof   LocationAware )     {", "final   LocationAware   script    =     (  ( LocationAware )     ( failure )  )  ;", "details . failure    =    script . getCause (  )  ;", "if    (  ( script . getLocation (  )  )     !  =    null )     {", "details . location . text ( script . getLocation (  )  )  ;", "}", "script . visitReportableCauses ( new   TreeVisitor < Throwable >  (  )     {", "int   depth ;", "@ Override", "public   void   node ( final   Throwable   node )     {", "if    ( node    =  =    script )     {", "details . details . text ( getMessage ( script . getCause (  )  )  )  ;", "} else    {", "final   LinePrefixingStyledTextOutput   output    =    getLinePrefixingStyledTextOutput (  )  ;", "output . text ( getMessage ( node )  )  ;", "}", "}", "@ Override", "public   void   startChildren (  )     {", "( depth )  +  +  ;", "}", "@ Override", "public   void   endChildren (  )     {", "( depth )  -  -  ;", "}", "private   LinePrefixingStyledTextOutput   getLinePrefixingStyledTextOutput (  )     {", "details . details . format (  \"  % n \"  )  ;", "StringBuilder   prefix    =    new   StringBuilder (  )  ;", "for    ( int   i    =     1  ;    i    <     ( depth )  ;    i +  +  )     {", "prefix . append (  \"           \"  )  ;", "}", "details . details . text ( prefix )  ;", "prefix . append (  \"        \"  )  ;", "details . details . style ( Info )  . text (  \"  >     \"  )  . style ( Normal )  ;", "return   new   LinePrefixingStyledTextOutput ( details . details ,    prefix ,    false )  ;", "}", "}  )  ;", "} else    {", "details . details . text ( getMessage ( failure )  )  ;", "}", "}", "METHOD_END"], "methodName": ["formatGenericFailure"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "String   message    =    throwable . getMessage (  )  ;", "if    ( GUtil . isTrue ( message )  )     {", "return   message ;", "}", "return   String . format (  \"  % s    ( no   error   message )  \"  ,    throwable . getClass (  )  . getName (  )  )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "StyledTextOutput   output    =    textOutputFactory . create ( BuildExceptionReporter . class ,    ERROR )  ;", "output . println (  )  ;", "output . withStyle ( Failure )  . format (  \" FAILURE :    Build   completed   with    % s   failures .  \"  ,    flattenedFailures . size (  )  )  ;", "output . println (  )  ;", "for    ( int   i    =     0  ;    i    <     ( flattenedFailures . size (  )  )  ;    i +  +  )     {", "Throwable   cause    =    flattenedFailures . get ( i )  ;", "BuildExceptionReporter . FailureDetails   details    =    constructFailureDetails (  \" Task \"  ,    cause )  ;", "output . println (  )  ;", "output . withStyle ( Failure )  . format (  \"  % s :     \"  ,     ( i    +     1  )  )  ;", "details . summary . writeTo ( output . withStyle ( Failure )  )  ;", "output . println (  )  ;", "output . text (  \"  -  -  -  -  -  -  -  -  -  -  -  \"  )  ;", "writeFailureDetails ( output ,    details )  ;", "output . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "}", "writeGeneralTips ( output )  ;", "}", "METHOD_END"], "methodName": ["renderMultipleBuildExceptions"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "StyledTextOutput   output    =    textOutputFactory . create ( BuildExceptionReporter . class ,    ERROR )  ;", "BuildExceptionReporter . FailureDetails   details    =    constructFailureDetails (  \" Build \"  ,    failure )  ;", "output . println (  )  ;", "output . withStyle ( Failure )  . text (  \" FAILURE :     \"  )  ;", "details . summary . writeTo ( output . withStyle ( Failure )  )  ;", "output . println (  )  ;", "writeFailureDetails ( output ,    details )  ;", "writeGeneralTips ( output )  ;", "}", "METHOD_END"], "methodName": ["renderSingleBuildException"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( loggingConfiguration . getShowStacktrace (  )  )     !  =     ( ShowStacktrace . INTERNAL _ EXCEPTIONS )  )     {", "details . exceptionStyle    =     . ExceptionStyle . FULL ;", "}", "formatGenericFailure ( granularity ,    failure ,    details )  ;", "}", "METHOD_END"], "methodName": ["reportBuildFailure"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "if    ( details . location . getHasContent (  )  )     {", "output . println (  )  ;", "output . println (  \"  *    Where :  \"  )  ;", "details . location . writeTo ( output )  ;", "output . println (  )  ;", "}", "if    ( details . details . getHasContent (  )  )     {", "output . println (  )  ;", "output . println (  \"  *    What   went   wrong :  \"  )  ;", "details . details . writeTo ( output )  ;", "output . println (  )  ;", "}", "if    ( details . resolution . getHasContent (  )  )     {", "output . println (  )  ;", "output . println (  \"  *    Try :  \"  )  ;", "details . resolution . writeTo ( output )  ;", "output . println (  )  ;", "}", "Throwable   exception    =    null ;", "switch    ( details . exceptionStyle )     {", "case   NONE    :", "break ;", "case   FULL    :", "exception    =    details . failure ;", "break ;", "}", "if    ( exception    !  =    null )     {", "output . println (  )  ;", "output . println (  \"  *       is :  \"  )  ;", "output . exception ( exception )  ;", "output . println (  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeFailureDetails"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "resolution . println (  )  ;", "resolution . text (  \"  *    Get   more   help   at    \"  )  ;", "resolution . withStyle ( UserInput )  . text (  \" https :  /  / helporg \"  )  ;", "resolution . println (  )  ;", "}", "METHOD_END"], "methodName": ["writeGeneralTips"], "fileName": "org.gradle.internal.buildevents.BuildExceptionReporter"}, {"methodBody": ["METHOD_START", "{", "for    ( BuildListener   logger    :    resultLoggers )     {", "logger . buildFinished ( result )  ;", "}", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "StartParameter   startParameter    =    gradle . getStartParameter (  )  ;", "logger . info (  \" Starting   Build \"  )  ;", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  \" Gradle   user   home :     {  }  \"  ,    startParameter . getGradleUserHomeDir (  )  )  ;", "logger . debug (  \" Current   dir :     {  }  \"  ,    startParameter . getCurrentDir (  )  )  ;", "logger . debug (  \" Settings   file :     {  }  \"  ,    startParameter . getSettingsFile (  )  )  ;", "logger . debug (  \" Build   file :     {  }  \"  ,    startParameter . getBuildFile (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildStarted"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  \" Tasks   to   be   executed :     {  }  \"  ,    graph . getAllTasks (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["graphPopulated"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "logger . info (  \" All   projects   evaluated .  \"  )  ;", "}", "METHOD_END"], "methodName": ["projectsEvaluated"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isInfoEnabled (  )  )     {", "ProjectIprojectI =     (  ( ProjectI    ( gradle . getRootProject (  )  )  )  ;", "logger . info (  \" Projects   loaded .    Root   project   using    {  }  .  \"  ,    projectIgetBuildScriptSource (  )  . getDisplayName (  )  )  ;", "logger . info (  \" Included   projects :     {  }  \"  ,    projectIgetAllprojects (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["projectsLoaded"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "SettingsIsettingsI =     (  ( SettingsI    ( settings )  )  ;", "if    ( logger . isInfoEnabled (  )  )     {", "logger . info (  \" Settings   evaluated   using    {  }  .  \"  ,    settingsIgetSettingsScript (  )  . getDisplayName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["settingsEvaluated"], "fileName": "org.gradle.internal.buildevents.BuildLogger"}, {"methodBody": ["METHOD_START", "{", "SingleMessageLogger . reportSuppressedDeprecations (  )  ;", "boolean   buildSucceeded    =     ( result . getFailure (  )  )     =  =    null ;", "StyledTextOutput   textOutput    =    textOutputFactory . create (  . class ,     ( buildSucceeded    ?    LogLevel . LIFECYCLE    :    LogLevel . ERROR )  )  ;", "textOutput . println (  )  ;", "String   action    =    result . getAction (  )  . toUpperCase (  )  ;", "if    ( buildSucceeded )     {", "textOutput . withStyle ( Style . SuccessHeader )  . text (  ( action    +     \"    SUCCESSFUL \"  )  )  ;", "} else    {", "textOutput . withStyle ( Style . FailureHeader )  . text (  ( action    +     \"    FAILED \"  )  )  ;", "}", "long   buildDurationMillis    =     ( clock . getCurrentTime (  )  )     -     ( buildStartedTime . getStartTime (  )  )  ;", "textOutput . formatln (  \"    in    % s \"  ,    durationFormatter . format ( buildDurationMillis )  )  ;", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.internal.buildevents.BuildResultLogger"}, {"methodBody": ["METHOD_START", "{", "return   startTime ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.internal.buildevents.BuildStartedTime"}, {"methodBody": ["METHOD_START", "{", "this . startTime    =    startTime ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.gradle.internal.buildevents.BuildStartedTime"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildStartedTime ( startTime )  ;", "}", "METHOD_END"], "methodName": ["startingAt"], "fileName": "org.gradle.internal.buildevents.BuildStartedTime"}, {"methodBody": ["METHOD_START", "{", "ProgressLogger   currentTask    =    currentTasks . remove ( task )  ;", "boolean   failed    =     ( state . getFailure (  )  )     !  =    null ;", "String   taskMessage    =     ( failed )     ?     \" FAILED \"     :    state . getSkipMessage (  )  ;", "currentTask . completed ( taskMessage ,    failed )  ;", "}", "METHOD_END"], "methodName": ["afterExecute"], "fileName": "org.gradle.internal.buildevents.TaskExecutionLogger"}, {"methodBody": ["METHOD_START", "{", "assert    !  ( currentTasks . containsKey ( task )  )  ;", "ProgressLogger   currentTask    =    progressLoggerFactory . newOperation (  . class ,    parentLoggerProvider . getLogger (  )  )  ;", "String   displayName    =    getDisplayName (  (  ( TaskInternal )     ( task )  )  )  ;", "currentTask . setDescription (  \" Execute    \"  . concat ( displayName )  )  ;", "currentTask . setShortDescription ( displayName )  ;", "currentTask . setLoggingHeader ( displayName )  ;", "currentTask . started (  )  ;", "currentTasks . put ( task ,    currentTask )  ;", "}", "METHOD_END"], "methodName": ["beforeExecute"], "fileName": "org.gradle.internal.buildevents.TaskExecutionLogger"}, {"methodBody": ["METHOD_START", "{", "return   task . getIdentityPath (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.internal.buildevents.TaskExecutionLogger"}, {"methodBody": ["METHOD_START", "{", "int   total    =    statistics . getTotalTaskCount (  )  ;", "if    ( total    >     0  )     {", "String   pluralizedTasks    =     ( total    >     1  )     ?     \" tasks \"     :     \" task \"  ;", "StyledTextOutput   textOutput    =    textOutputFactory . create ( BuildResultLogger . class ,    LIFECYCLE )  ;", "textOutput . format (  \"  % d   actionable    % s :  \"  ,    total ,    pluralizedTasks )  ;", "boolean   printedDetail    =     . formatDetail ( textOutput ,    statistics . getExecutedTasksCount (  )  ,     \" executed \"  ,    false )  ;", "printedDetail    =     . formatDetail ( textOutput ,    statistics . getFromCacheTaskCount (  )  ,     \" from   cache \"  ,    printedDetail )  ;", ". formatDetail ( textOutput ,    statistics . getUpToDateTaskCount (  )  ,     \" up - to - date \"  ,    printedDetail )  ;", "textOutput . println (  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.internal.buildevents.TaskExecutionStatisticsReporter"}, {"methodBody": ["METHOD_START", "{", "if    ( count    =  =     0  )     {", "return   alreadyPrdDetail ;", "}", "if    ( alreadyPrdDetail )     {", "textOutput . format (  \"  ,  \"  )  ;", "}", "textOutput . format (  \"     % d    % s \"  ,    count ,    title )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["formatDetail"], "fileName": "org.gradle.internal.buildevents.TaskExecutionStatisticsReporter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resolvedPaths )     =  =    null )     {", "Set < String >    result    =    new   LinkedHashSet < String >  (  )  ;", "for    ( FileCollection   o    :    os )     {", "for    ( File   file    :    o )     {", "result . add ( file . getAbsolutePath (  )  )  ;", "}", "}", "resolvedPaths    =    result ;", "}", "}", "METHOD_END"], "methodName": ["doResolvePaths"], "fileName": "org.gradle.internal.cleanup.DefaultBuildOutputCleanupRegistry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resolvedPaths )     =  =    null )     {", "doResolvePaths (  )  ;", "}", "return   resolvedPaths ;", "}", "METHOD_END"], "methodName": ["getResolvedPaths"], "fileName": "org.gradle.internal.cleanup.DefaultBuildOutputCleanupRegistry"}, {"methodBody": ["METHOD_START", "{", "return   accessKey ;", "}", "METHOD_END"], "methodName": ["getAccessKey"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "return   secretKey ;", "}", "METHOD_END"], "methodName": ["getSecretKey"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "return   sessionToken ;", "}", "METHOD_END"], "methodName": ["getSessionToken"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "this . accessKey    =    accessKey ;", "}", "METHOD_END"], "methodName": ["setAccessKey"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "this . secretKey    =    secretKey ;", "}", "METHOD_END"], "methodName": ["setSecretKey"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "this . sessionToken    =    token ;", "}", "METHOD_END"], "methodName": ["setSessionToken"], "fileName": "org.gradle.internal.credentials.DefaultAwsCredentials"}, {"methodBody": ["METHOD_START", "{", "if    (  ( getCause (  )  )    instanceof   FailureResolutionAware )     {", "FailureResolutionAware   resolutionAware    =     (  ( FailureResolutionAware )     ( getCause (  )  )  )  ;", "resolutionAware . appendResolution ( output ,    clientMetaData )  ;", "}", "}", "METHOD_END"], "methodName": ["appendResolution"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( t . getCause (  )  )     =  =    null )     {", "return   null ;", "}", "Throwable   cause    =    t . getCause (  )  ;", "if    (  ( cause . getClass (  )  . getAnnot ( Contextual . class )  )     !  =    null )     {", "return   cause ;", "}", "return   findNearestContextualCause ( cause )  ;", "}", "METHOD_END"], "methodName": ["findNearestContextualCause"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "return   lineNumber ;", "}", "METHOD_END"], "methodName": ["getLineNumber"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( sourceDisplayName )     =  =    null )     {", "return   null ;", "}", "String   sourceMsg    =    StringUtils . capitalize ( sourceDisplayName )  ;", "if    (  ( lineNumber )     =  =    null )     {", "return   sourceMsg ;", "}", "return   String . format (  \"  % s   line :     % d \"  ,    sourceMsg ,    lineNumber )  ;", "}", "METHOD_END"], "methodName": ["getLocation"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "String   location    =    getLocation (  )  ;", "String   message    =    getCause (  )  . getMessage (  )  ;", "if    (  ( location    =  =    null )     &  &     ( message    =  =    null )  )     {", "return   null ;", "}", "if    ( location    =  =    null )     {", "return   message ;", "}", "if    ( message    =  =    null )     {", "return   location ;", "}", "return   String . format (  \"  % s % n % s \"  ,    location ,    message )  ;", "}", "METHOD_END"], "methodName": ["getMessage"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "final   List < Throwable >    causes    =    new   ArrayList < Throwable >  (  )  ;", "visitCauses ( getCause (  )  ,    new   TreeVisitor < Throwable >  (  )     {", "@ Override", "public   void   node ( Throwable   node )     {", "causes . add ( node )  ;", "}", "}  )  ;", "return   causes ;", "}", "METHOD_END"], "methodName": ["getReportableCauses"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "return   sourceDisplayName ;", "}", "METHOD_END"], "methodName": ["getSourceDisplayName"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "if    ( t   instanceof   MultiCauseException )     {", "MultiCauseException   multiCauseException    =     (  ( MultiCauseException )     ( t )  )  ;", "List <  ?    extends   Throwable >    causes    =    multiCauseException . getCauses (  )  ;", "if    (  !  ( causes . isEmpty (  )  )  )     {", "visitor . startChildren (  )  ;", "for    ( Throwable   cause    :    causes )     {", "visitor . node ( cause )  ;", "if    (  ( cause . getClass (  )  . getAnnotation ( Contextual . class )  )     !  =    null )     {", "visitCauses ( cause ,    visitor )  ;", "}", "}", "visitor . endChildren (  )  ;", "}", "return ;", "}", "if    (  ( t . getCause (  )  )     !  =    null )     {", "visitor . startChildren (  )  ;", "Throwable   next    =    findNearestContextualCause ( t )  ;", "if    ( next    !  =    null )     {", "visitor . node ( next )  ;", "visitCauses ( next ,    visitor )  ;", "} else    {", "visitor . node ( t . getCause (  )  )  ;", "}", "visitor . endChildren (  )  ;", "}", "}", "METHOD_END"], "methodName": ["visitCauses"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "visitor . node ( this )  ;", "visitCauses ( getCause (  )  ,    visitor )  ;", "}", "METHOD_END"], "methodName": ["visitReportableCauses"], "fileName": "org.gradle.internal.exceptions.LocationAwareException"}, {"methodBody": ["METHOD_START", "{", "List < StackTraceElement >    stack    =    usage . getStack (  )  ;", "if    ( stack . isEmpty (  )  )     {", "return ;", "}", "StackTraceElement   directCaller    =    stack . get (  0  )  ;", "if    ( ss . containsKey ( directCaller . getFileName (  )  )  )     {", "reportStackTraceElement ( directCaller ,    target )  ;", "return ;", "}", "int   caller    =     1  ;", "while    (  ( caller    <     ( stack . size (  )  )  )     &  &     ( stack . get ( caller )  . getClassName (  )  . equals ( directCaller . getClassName (  )  )  )  )     {", "caller +  +  ;", "}", "if    ( caller    =  =     ( stack . size (  )  )  )     {", "return ;", "}", "StackTraceElement   indirectCaller    =    stack . get ( caller )  ;", "if    ( ss . containsKey ( indirectCaller . getFileName (  )  )  )     {", "reportStackTraceElement ( indirectCaller ,    target )  ;", "}", "}", "METHOD_END"], "methodName": ["doReportLocation"], "fileName": "org.gradle.internal.featurelifecycle.ScriptUsageLocationReporter"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "doReport ( usage ,    target )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["reportLocation"], "fileName": "org.gradle.internal.featurelifecycle.ScriptUsageLocationReporter"}, {"methodBody": ["METHOD_START", "{", "ScriptSource   scriptSource    =    scripts . get ( stackTraceElement . getFileName (  )  )  ;", "target . append ( StringUtils . capitalize ( scriptSource . getDisplayName (  )  )  )  ;", "if    (  ( stackTraceElement . getLineNumber (  )  )     >     0  )     {", "target . append (  \"  :    line    \"  )  ;", "target . append ( stackTraceElement . getLineNumber (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["reportStackTraceElement"], "fileName": "org.gradle.internal.featurelifecycle.ScriptUsageLocationReporter"}, {"methodBody": ["METHOD_START", "{", "HashCode   hashValue    =    fileHasher . hash ( original )  ;", "File   baseDir    =    baseDirFactory . create (  )  ;", "File   cachedFile    =    new   File ( baseDir ,     (  (  ( hashValue . toString (  )  )     +     '  /  '  )     +     ( original . getName (  )  )  )  )  ;", "if    (  !  ( cachedFile . isFile (  )  )  )     {", "GFileUtils . copyFile ( original ,    cachedFile )  ;", "}", "return   cachedFile ;", "}", "METHOD_END"], "methodName": ["getCachedJar"], "fileName": "org.gradle.internal.file.JarCache"}, {"methodBody": ["METHOD_START", "{", "eventDeliveryLock . lock (  )  ;", "try    {", "this . eventListener    =    eventListener ;", "for    ( FileWatcherEvent   event    :    eventsBeforeListening )     {", "eventListener . on ( event )  ;", "}", "eventsBeforeListening . clear (  )  ;", "}    finally    {", "eventDeliveryLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["attachEventListener"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "eventDeliveryLock . lock (  )  ;", "try    {", "if    (  ( eventListener )     !  =    null )     {", "eventListener . on ( event )  ;", "} else    {", "eventsBeforeListening . add ( event )  ;", "}", "}    finally    {", "eventDeliveryLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["deliverEvent"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "eventDeliveryLock . lock (  )  ;", "try    {", "this . eventLiner    =    null ;", "}    finally    {", "eventDeliveryLock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["detachEventListener"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "return    ( System . nanoTime (  )  )     /     1  0  0  0  0  0  0 L ;", "}", "METHOD_END"], "methodName": ["monotonicClockMillis"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    DefaultFileSystemChangeWaiter . monotonicClockMillis (  )  ;", "return    (  ( lastChangeAtValue    =  =     0  )     |  |     ( now    <    lastChangeAtValue )  )     |  |     (  ( now    -    lastChangeAtValue )     <     ( quietPeriodMillis )  )  ;", "}", "METHOD_END"], "methodName": ["shouldKeepWaitingForQuietPeriod"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "DefaultFileSystemChangeWaiter . signal ( lock ,    condition ,    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["signal"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "boolean   interrupted    =    Thread . interrupted (  )  ;", "lock . lock (  )  ;", "try    {", "runnable . run (  )  ;", "condition . signal (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "if    ( interrupted )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["signal"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "Runnable   cancellationHandler    =    new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", ". signal ( lock ,    condition )  ;", "}", "}  ;", "try    {", "attachEventListener ( eventListener )  ;", "if    ( cancellationToken . isCancellationRequested (  )  )     {", "return ;", "}", "cancellationToken . addCallback ( cancellationHandler )  ;", "notifier . run (  )  ;", "lock . lock (  )  ;", "try    {", "long   lastChangeAtValue    =    lastChangeAt . get (  )  ;", "while    (  (  !  ( cancellationToken . isCancellationRequested (  )  )  )     &  &     ( waitingForChanges ( lastChangeAtValue )  )  )     {", "condition . await ( quietPeriodMillis ,    TimeUnit . MILLISECONDS )  ;", "lastChangeAtValue    =    lastChangeAt . get (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "Throwable   throwable    =    error . get (  )  ;", "if    ( throwable    !  =    null )     {", "throw   throwable ;", "}", "}    catch    ( Throwable   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    finally    {", "detachEventListener (  )  ;", "cancellationToken . removeCallback ( cancellationHandler )  ;", "watcher . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["wait"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "return    (  ( error . get (  )  )     =  =    null )     &  &     ( shouldKeepWaitingForQuietPeriod ( lastChangeAtValue )  )  ;", "}", "METHOD_END"], "methodName": ["waitingForChanges"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiter"}, {"methodBody": ["METHOD_START", "{", "return   Long . getLong ( DefaultFileSystemChangeWaiterFactory . QUIET _ PERIOD _ SYSPROP ,     2  5  0 L )  ;", "}", "METHOD_END"], "methodName": ["getDefaultQuietPeriod"], "fileName": "org.gradle.internal.filewatch.DefaultFileSystemChangeWaiterFactory"}, {"methodBody": ["METHOD_START", "{", "logger . formatln ( message ,    objects )  ;", "}", "METHOD_END"], "methodName": ["logOutput"], "fileName": "org.gradle.internal.filewatch.DefaultFileWatcherEventListener"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < File ,    FileWatcherEvent . Type >    entry    :    aggregatedEvents . entrySet (  )  )     {", "FileWatcherEvent . Type   changeType    =    entry . getValue (  )  ;", "File   file    =    entry . getKey (  )  ;", "showIndividualChange ( logger ,    file ,    changeType )  ;", "}", "if    (  ( moreChangesCount )     >     0  )     {", "logOutput ( logger ,     \" and   some   more   changes \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["reportChanges"], "fileName": "org.gradle.internal.filewatch.DefaultFileWatcherEventListener"}, {"methodBody": ["METHOD_START", "{", "if    ( DefaultFileWatcherEventListener . IS _ MAC _ OSX )     {", "return   true ;", "}", "return    (  ( event . getType (  )  )     !  =     ( FileWatcherEvent . Type . CREATE )  )     |  |     ( event . getFile (  )  . isDirectory (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldIncreaseChangesCount"], "fileName": "org.gradle.internal.filewatch.DefaultFileWatcherEventListener"}, {"methodBody": ["METHOD_START", "{", "String   changeDescription ;", "switch    ( changeType )     {", "case   CREATE    :", "changeDescription    =     \" new    \"     +     ( file . isDirectory (  )     ?     \" directory \"     :     \" file \"  )  ;", "break ;", "case   DELETE    :", "changeDescription    =     \" deleted \"  ;", "break ;", "case   MODIFY    :", "d    :", "changeDescription    =     \" modified \"  ;", "}", "logOutput ( logger ,     \"  % s :     % s \"  ,    changeDescription ,    file . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["showIndividualChange"], "fileName": "org.gradle.internal.filewatch.DefaultFileWatcherEventListener"}, {"methodBody": ["METHOD_START", "{", "return   new   Jdk 7 FileWatcherFactory ( executor ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["createFileWatcherFactory"], "fileName": "org.gradle.internal.filewatch.DefaultFileWatcherFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   FileWatcherEvent ( FileWatcherEvent . Type . CREATE ,    file )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "return   new   FileWatcherEvent ( FileWatcherEvent . Type . DELETE ,    file )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "return   new   FileWatcherEvent ( FileWatcherEvent . Type . MODIFY ,    file )  ;", "}", "METHOD_END"], "methodName": ["modify"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "return   new   FileWatcherEvent ( FileWatcherEvent . Type . UNDEFINED ,    null )  ;", "}", "METHOD_END"], "methodName": ["undefined"], "fileName": "org.gradle.internal.filewatch.FileWatcherEvent"}, {"methodBody": ["METHOD_START", "{", "listenerManager . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.gradle.internal.filewatch.PendingChangesManager"}, {"methodBody": ["METHOD_START", "{", "listenerManager . removeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.gradle.internal.filewatch.PendingChangesManager"}, {"methodBody": ["METHOD_START", "{", "return   new   WatchPointsRegistry . Delta ( fileSystemSubset ,    ImmutableSet . copyOf ( currentWatchPoints )  )  ;", "}", "METHOD_END"], "methodName": ["appendFileSystemSubset"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "return    ( combinedRootsSubset . contains ( file )  )     |  |     ( WatchPointsRegistry . isAncestorOfAnyRoot ( file ,    roots ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["inCombinedRootsOrAncestorOfAnyRoot"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "return   WatchPointsRegistry . isAncestorOfAnyRoot ( file ,    roots ,    false )  ;", "}", "METHOD_END"], "methodName": ["isAncestorOfAnyRoot"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "String   absolutePathWithSeparator    =     ( file . getAbsolutePath (  )  )     +     ( File . separator )  ;", "for    ( File   root    :    roots )     {", "if    (  ( acceptItSelf    &  &     ( root . equals ( file )  )  )     |  |     ( root . getAbsolutePath (  )  . startsWith ( absolutePathWithSeparator )  )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isAncestorOfAnyRoot"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "return   rootSubset . contains ( file )  ;", "}", "METHOD_END"], "methodName": ["shouldFire"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "final   boolean   result    =     ( rootSubset . isInRootsOrAncestorOrAnyRoot ( directory )  )     |  |     ( WatchPointsRegistry . isAncestorOfAnyRoot ( directory ,    allRequestedRoots ,    true )  )  ;", "if    (  (  ! result )     &  &     ( WatchPointsRegistry . LOG . isDebugEnabled (  )  )  )     {", "WatchPointsRegistry . LOG . debug (  \" not   watching   directory :     {  }    allRequestedRoots :     {  }    roots :     {  }    unfiltered :     {  }  \"  ,    directory ,    allRequestedRoots ,    rootSubset . roots ,    rootSubset . combinedFileSystemSubset )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["shouldWatch"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchPointsRegistry"}, {"methodBody": ["METHOD_START", "{", "for    ( FileWatcherEvent   event    :    events )     {", "if    (  !  ( isRunning (  )  )  )     {", ". LOGGER . debug (  \" File   watching   isn ' t   running ,    breaking   out   of   event   delivery .  \"  )  ;", "break ;", "}", "if    (  . LOGGER . isDebugEnabled (  )  )     {", ". LOGGER . debug (  \" Received   file   system   event :     {  }  \"  ,    event )  ;", "}", "watchServiceRegistrar . onChange ( fileWatcher ,    event )  ;", "}", "}", "METHOD_END"], "methodName": ["deliverEvents"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "SoftReference < Thread >    threadSoftReference    =    pollerThreadReference . getAndSet ( null )  ;", "if    ( threadSoftReference    !  =    null )     {", "Thread   pollerThread    =    threadSoftReference . get (  )  ;", "if    (  ( pollerThread    !  =    null )     &  &     ( pollerThread    !  =     ( Thread . currentThread (  )  )  )  )     {", ". LOGGER . debug (  \" Interrupting   poller   thread    '  {  }  '  \"  ,    pollerThread . getName (  )  )  ;", "pollerThread . interrupt (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["interruptPollerThread"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "return    ( running . get (  )  )     &  &     (  !  ( Thread . currentThread (  )  . isInterrupted (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isRunning"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "while    ( isRunning (  )  )     {", "try    {", "List < FileWatcherEvent >    events    =    poller . takeEvents (  )  ;", "if    ( events    !  =    null )     {", "deliverEvents ( events )  ;", "}", "}    catch    ( ClosedWatchServiceException   e )     {", ". LOGGER . debug (  \" Received   ClosedWatchServiceException ,    stopping \"  )  ;", "stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["pumpEvents"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "if    ( started . compareAndSet ( false ,    true )  )     {", "final   ListenableFuture <  ?  >    runLoopFuture    =    executorService . submit ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "if    (  !  ( stopped . get (  )  )  )     {", "pollerThreadReference . set ( new   SoftReference < Thread >  ( Thread . currentThread (  )  )  )  ;", "running . set ( true )  ;", "try    {", "try    {", "pumpEvents (  )  ;", "}    catch    ( InterruptedException   e )     {", "}    catch    ( Throwable   t )     {", "if    (  !  (  ( Throwables . getRootCause ( t )  )    instanceof   InterruptedException )  )     {", "stop (  )  ;", "onError . execute ( t )  ;", "}", "}", "}    finally    {", "stop (  )  ;", "}", "}", "}", "}  )  ;", "Futures . addCallback ( runLoopFuture ,    new   com . google . common . util . concurrent . FutureCallback < Object >  (  )     {", "@ Override", "public   void   onSuccess ( Object   result )     {", "running . set ( false )  ;", "}", "@ Override", "public   void   onFailure ( Throwable   t )     {", "running . set ( false )  ;", "}", "}  )  ;", "return   f ;", "} else    {", "throw   new   IllegalStateException (  \" file   watcher   is   started \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "if    ( stopped . compareAndSet ( false ,    true )  )     {", "if    ( running . compareAndSet ( true ,    false )  )     {", ". LOGGER . debug (  \" Stopping   file   watching \"  )  ;", "interruptPollerThread (  )  ;", "try    {", "watchService . close (  )  ;", "}    catch    ( IOException   e )     {", "}    catch    ( ClosedWatchServiceException   e )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceFileWatcherBacking"}, {"methodBody": ["METHOD_START", "{", "final   Path   watchedPath    =     (  ( Path )     ( watchKey . watchable (  )  )  )  ;", "Transformer < FileWatcherEvent ,    WatchEvent <  ?  >  >    watchEventTransformer    =    new   Transformer < FileWatcherEvent ,    WatchEvent <  ?  >  >  (  )     {", "@ Override", "public   FileWatcherEvent   transform ( WatchEvent <  ?  >    event )     {", "WatchEvent . Kind   kind    =    event . kind (  )  ;", "File   file    =    null ;", "if    (  ( kind . type (  )  )     =  =     ( Path . class )  )     {", "WatchEvent < Path >    ev    =    Cast . uncheckedCast ( event )  ;", "file    =    watchedPath . resolve ( ev . context (  )  )  . toFile (  )  ;", "}", "return   toEvent ( kind ,    file )  ;", "}", "}  ;", "List < WatchEvent <  ?  >  >    watchEvents    =    watchKey . pollEvents (  )  ;", "watchKey . reset (  )  ;", "if    ( watchEvents . isEmpty (  )  )     {", "return   Collections . singletonList ( FileWatcherEvent . delete ( watchedPath . toFile (  )  )  )  ;", "} else    {", "return   CollectionUtils . collect ( watchEvents ,    watchEventTransformer )  ;", "}", "}", "METHOD_END"], "methodName": ["handleWatchKey"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServicePoller"}, {"methodBody": ["METHOD_START", "{", "WatchKey   watchKey    =    watchService . poll ( WatchServicePoller . POLL _ TIMEOUT _ SECONDS ,    TimeUnit . SECONDS )  ;", "if    ( watchKey    !  =    null )     {", "return   handleWatchKey ( watchKey )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["takeEvents"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServicePoller"}, {"methodBody": ["METHOD_START", "{", "if    ( kind    =  =     ( StandardWatchEventKinds . ENTRY _ CREATE )  )     {", "return   FileWatcherEvent . create ( file )  ;", "} else", "if    ( kind    =  =     ( StandardWatchEventKinds . ENTRY _ DELETE )  )     {", "return   FileWatcherEvent . delete ( file )  ;", "} else", "if    ( kind    =  =     ( StandardWatchEventKinds . ENTRY _ MODIFY )  )     {", "return   FileWatcherEvent . modify ( file )  ;", "} else", "if    ( kind    =  =     ( StandardWatchEventKinds . OVERFLOW )  )     {", "return   FileWatcherEvent . undefined (  )  ;", "} else    {", "throw   new   IllegalStateException (  (  \" Unknown   watch   kind    \"     +    kind )  )  ;", "}", "}", "METHOD_END"], "methodName": ["toEvent"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServicePoller"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( Thread . currentThread (  )  . isInterrupted (  )  )  )     {", "try    {", "delegate . onChange ( watcher ,    event )  ;", "}    catch    ( RuntimeException   e )     {", "if    (  ( Throwables . getRootCause ( e )  )    instanceof   InterruptedException )     {", "return ;", "}", "throw   e ;", "}", "} else    {", ". LOG . debug (  \" Skipping   event   delivery   since   current   thread   is   interrupted .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["deliverEventToDelegate"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "List < File >    currentWatchPoints    =    new   LinkedList < File >  (  )  ;", "for    ( Map . Entry < Path ,    WatchKey >    entry    :    watchKeys . entrySet (  )  )     {", "if    ( entry . getValue (  )  . isValid (  )  )     {", "currentWatchPoints . add ( entry . getKey (  )  . toFile (  )  )  ;", "}", "}", "return   currentWatchPoints ;", "}", "METHOD_END"], "methodName": ["getCurrentWatchPoints"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "try    {", "return    (  ( Event . Modifier )     ( Enum . valueOf (  (  ( Class < Enum >  )     ( Class . forName ( className )  )  )  ,    enumName )  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["instantiateEnum"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    ( JavaVersion . current (  )  . isJava 9 Compatible (  )  )     {", "return   new   WatchEvent . Modifier [  ]  {        }  ;", "} else    {", "WatchEvent . Modifier   highSensitive    =     . instantiateEnum (  \" com . sun . nio . file . SensitivityWatchEventModifier \"  ,     \" HIGH \"  )  ;", "if    (  . FILE _ TREE _ WATCHING _ SUPPORTED )     {", "WatchEvent . Modifier   fileTree    =     . instantiateEnum (  \" com . sun . nio . file . ExtendedWatchEventModifier \"  ,     \" FILE _ TREE \"  )  ;", "return   new   WatchEvent . Modifier [  ]  {    fileTree ,    highSensitive    }  ;", "} else    {", "return   new   WatchEvent . Modifier [  ]  {    highSensitive    }  ;", "}", "}", "}", "METHOD_END"], "methodName": ["instantiateWatchModifiers"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "return    ( Thread . currentThread (  )  . isInterrupted (  )  )     |  |     (  !  ( watcher . isRunning (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isStopRequested"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "if    ( watchPointsRegistry . shouldFire ( event . getFile (  )  )  )     {", ". LOG . debug (  \" Calling   onChange   with   event    {  }  \"  ,    event )  ;", "deliverEventToDelegate ( watcher ,    event )  ;", "} else    {", ". LOG . debug (  \" Ignoring   event    {  }  \"  ,    event )  ;", "}", "}", "METHOD_END"], "methodName": ["maybeFire"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "WatchServiceRegistrar . LOG . debug (  \" Begin    -    maybeWatchNewDirectory    {  }  \"  ,    dir )  ;", "if    ( isStopRequested ( watcher )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Stop   requested ,    returning .  \"  )  ;", "return ;", "}", "if    (  !  ( watchPointsRegistry . shouldWatch ( dir )  )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Ignoring   watching    {  }  \"  ,    dir )  ;", "return ;", "}", "if    ( dir . exists (  )  )     {", "if    (  !  ( WatchServiceRegistrar . FILE _ TREE _ WATCHING _ SUPPORTED )  )     {", "watchDir ( dir . toPath (  )  )  ;", "}", "File [  ]    contents    =    dir . listFiles (  )  ;", "if    ( contents    !  =    null )     {", "for    ( File   file    :    contents )     {", "if    ( isStopRequested ( watcher )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Stop   requested ,    returning .  \"  )  ;", "return ;", "}", "maybeFire ( watcher ,    FileWatcherEvent . create ( file )  )  ;", "if    ( file . isDirectory (  )  )     {", "maybeWatchNewDirectory ( watcher ,    file )  ;", "}", "}", "}", "}", "WatchServiceRegistrar . LOG . debug (  \" End    -    maybeWatchNewDirectory    {  }  \"  ,    dir )  ;", "}", "METHOD_END"], "methodName": ["maybeWatchNewDirectory"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", ". LOG . debug (  \" Begin    -    adding   watches   for    {  }  \"  ,    fileSystemSubset )  ;", "final   WatchPointsRegistry . Delta   delta    =    watchPointsRegistry . appendFileSystemSubset ( fileSystemSubset ,    getCurrentWatchPoints (  )  )  ;", "Iterable <  ?    extends   File >    startingWatchPoints    =    delta . getStartingWatchPoints (  )  ;", "for    ( File   dir    :    startingWatchPoints )     {", ". LOG . debug (  \" Begin    -    handling   starting   point    {  }  \"  ,    dir )  ;", "final   Path   dirPath    =    dir . toPath (  )  ;", "watchDir ( dirPath )  ;", "if    (  !  (  . FILE _ TREE _ WATCHING _ SUPPORTED )  )     {", "Files . walkFileTree ( dirPath ,    new   SimpleFileVisitor < Path >  (  )     {", "@ Override", "public   FileVisitResult   preVisitDirectory ( Path   path ,    BasicFileAttributes   attrs )    throws   IOException    {", "if    (  !  ( path . equals ( dirPath )  )  )     {", "if    ( delta . shouldWatch ( path . toFile (  )  )  )     {", "watchDir ( path )  ;", "return   FileVisitResult . CONTINUE ;", "} else    {", ". LOG . debug (  \" Skipping   watching   for    {  }  ,    filtered   by   WatchPointsRegistry \"  ,    path )  ;", "return   FileVisitResult . SKIP _ SUBTREE ;", "}", "} else    {", "return   FileVisitResult . CONTINUE ;", "}", "}", "}  )  ;", "}", ". LOG . debug (  \" End    -    handling   starting   point    {  }  \"  ,    dir )  ;", "}", ". LOG . debug (  \" End    -    adding   watches   for    {  }  \"  ,    fileSystemSubset )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["watch"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "WatchServiceRegistrar . LOG . debug (  \" Registering   watch   for    {  }  \"  ,    dir )  ;", "if    ( Thread . currentThread (  )  . isInterrupted (  )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Skipping   adding   watch   since   current   thread   is   interrupted .  \"  )  ;", "}", "for    ( Path   path    =    dir ;    path    !  =    null ;    path    =     ( WatchServiceRegistrar . FILE _ TREE _ WATCHING _ SUPPORTED )     ?    path . getParent (  )     :    null )     {", "WatchKey   previousWatchKey    =    watchKeys . get ( path )  ;", "if    (  ( previousWatchKey    !  =    null )     &  &     ( previousWatchKey . isValid (  )  )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Directory    {  }    is   already   watched   and   the   watch   is   valid ,    not   adding   another   one .  \"  ,    path )  ;", "return ;", "}", "}", "int   retryCount    =     0  ;", "IOException   lastException    =    null ;", "while    (  ( retryCount +  +  )     <     2  )     {", "try    {", "WatchKey   watchKey    =    dir . register ( watchService ,    WatchServiceRegistrar . WATCH _ KINDS ,    WatchServiceRegistrar . WATCH _ MODIFIERS )  ;", "watchKeys . put ( dir ,    watchKey )  ;", "return ;", "}    catch    ( IOException   e )     {", "WatchServiceRegistrar . LOG . debug (  (  \" Exception   in   registering   for   watching   of    \"     +    dir )  ,    e )  ;", "lastException    =    e ;", "if    ( e   instanceof   NoSuchFileException )     {", "WatchServiceRegistrar . LOG . debug (  \" Return   silently   since   directory   doesn ' t   exist .  \"  )  ;", "return ;", "}", "if    (  (  ( e   instanceof   FileSystemException )     &  &     (  ( e . getMessage (  )  )     !  =    null )  )     &  &     ( e . getMessage (  )  . contains (  \" Bad   file   descriptor \"  )  )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Retrying   after    ' Bad   file   descriptor '  \"  )  ;", "continue ;", "}", "if    (  !  ( Files . exists ( dir )  )  )     {", "WatchServiceRegistrar . LOG . debug (  \" Return   silently   since   directory   doesn ' t   exist .  \"  )  ;", "return ;", "} else    {", "throw   e ;", "}", "}", "}", "WatchServiceRegistrar . LOG . debug (  \" Retry   count   exceeded ,    throwing   last   exception \"  )  ;", "throw   lastException ;", "}", "METHOD_END"], "methodName": ["watchDir"], "fileName": "org.gradle.internal.filewatch.jdk7.WatchServiceRegistrar"}, {"methodBody": ["METHOD_START", "{", "add ( Arrays . asList ( values )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.graph.CachingDirectedGraphWalker"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( startNodes ,    values )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.graph.CachingDirectedGraphWalker"}, {"methodBody": ["METHOD_START", "{", "int   componentCount    =     0  ;", "Map < N ,     . NodeDetails < N ,    T >  >    seenNodes    =    new   HashMap < N ,     . NodeDetails < N ,    T >  >  (  )  ;", "Map < Integer ,     . NodeDetails < N ,    T >  >    components    =    new   HashMap < Integer ,     . NodeDetails < N ,    T >  >  (  )  ;", "Deque < N >    queue    =    new   ArrayDeque < N >  ( startNodes )  ;", "while    (  !  ( queue . isEmpty (  )  )  )     {", "N   node    =    queue . getFirst (  )  ;", ". NodeDetails < N ,    T >    details    =    seenNodes . get ( node )  ;", "if    ( details    =  =    null )     {", "details    =    new    . NodeDetails < N ,    T >  ( node ,     ( componentCount +  +  )  )  ;", "seenNodes . put ( node ,    details )  ;", "components . put ( details . component ,    details )  ;", "Set < T >    cacheValues    =    cachedNodeValues . get ( node )  ;", "if    ( cacheValues    !  =    null )     {", "details . values    =    cacheValues ;", "details . finished    =    true ;", "queue . removeFirst (  )  ;", "continue ;", "}", "graph . getNodeValues ( node ,    details . values ,    details . successors )  ;", "for    ( N   connectedNode    :    details . successors )     {", ". NodeDetails < N ,    T >    connectedNodeDetails    =    seenNodes . get ( connectedNode )  ;", "if    ( connectedNodeDetails    =  =    null )     {", "queue . addFirst ( connectedNode )  ;", "} else", "if    (  !  ( connectedNodeDetails . finished )  )     {", "details . stronglyConnected    =    true ;", "}", "}", "} else    {", "queue . removeFirst (  )  ;", "if    ( cachedNodeValues . containsKey ( node )  )     {", "continue ;", "}", "for    ( N   connectedNode    :    details . successors )     {", ". NodeDetails < N ,    T >    connectedNodeDetails    =    seenNodes . get ( connectedNode )  ;", "if    (  !  ( connectedNodeDetails . finished )  )     {", "int   minSeen    =    Math . min ( details . minSeen ,    connectedNodeDetails . minSeen )  ;", "details . minSeen    =    minSeen ;", "connectedNodeDetails . minSeen    =    minSeen ;", "details . stronglyConnected    =    true ;", "}", "details . values . addAll ( connectedNodeDetails . values )  ;", "graph . getEdgeValues ( node ,    connectedNode ,    details . values )  ;", "}", "if    (  ( details . minSeen )     !  =     ( details . component )  )     {", ". NodeDetails < N ,    T >    rootDetails    =    components . get ( details . minSeen )  ;", "rootDetails . values . addAll ( details . values )  ;", "details . values . clear (  )  ;", "rootDetails . componentMembers . addAll ( details . componentMembers )  ;", "} else    {", "for    (  . NodeDetails < N ,    T >    componentMember    :    details . componentMembers )     {", "cachedNodeValues . put ( componentMember . node ,    details . values )  ;", "componentMember . finished    =    true ;", "components . remove ( componentMember . component )  ;", "}", "if    ( details . stronglyConnected )     {", "strongComponents . add ( details )  ;", "}", "}", "}", "}", "Set < T >    values    =    new   LinkedHashSet < T >  (  )  ;", "for    ( N   startNode    :    startNodes )     {", "values . addAll ( cachedNodeValues . get ( startNode )  )  ;", "}", "return   values ;", "}", "METHOD_END"], "methodName": ["doSearch"], "fileName": "org.gradle.internal.graph.CachingDirectedGraphWalker"}, {"methodBody": ["METHOD_START", "{", "findValues (  )  ;", "List < Set < N >  >    result    =    new   ArrayList < Set < N >  >  (  )  ;", "for    (  . NodeDetails < N ,    T >    nodeDetails    :    strongComponents )     {", "Set < N >    componentMembers    =    new   LinkedHashSet < N >  (  )  ;", "for    (  . NodeDetails < N ,    T >    componentMember    :    nodeDetails . componentMembers )     {", "componentMembers . add ( componentMember . node )  ;", "}", "result . add ( componentMembers )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["findCycles"], "fileName": "org.gradle.internal.graph.CachingDirectedGraphWalker"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   doSearch (  )  ;", "}    fily    {", "startNodes . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["findValues"], "fileName": "org.gradle.internal.graph.CachingDirectedGraphWalker"}, {"methodBody": ["METHOD_START", "{", "renderTo ( root ,    new   StreamingStyledTextOutput ( output )  )  ;", "}", "METHOD_END"], "methodName": ["renderTo"], "fileName": "org.gradle.internal.graph.DirectedGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "final   boolean   alreadySeen    =     !  ( rendered . add ( node )  )  ;", "g . visit ( new   Action < StyledTextOutput >  (  )     {", "public   void   execute ( StyledTextOutput   output )     {", "nodeRenderer . renderTo ( node ,    output )  ;", "if    ( alreadySeen )     {", "output . text (  \"     (  *  )  \"  )  ;", "}", "}", "}  ,    lastChild )  ;", "if    ( alreadySeen )     {", "omittedDetails    =    true ;", "return ;", "}", "List < N >    children    =    new   ArrayList < N >  (  )  ;", "graph . getNodeValues ( node ,    new   HashSet < Object >  (  )  ,    children )  ;", "if    ( children . isEmpty (  )  )     {", "return ;", "}", "g . startChildren (  )  ;", "for    ( int   i    =     0  ;    i    <     ( children . size (  )  )  ;    i +  +  )     {", "N   child    =    children . get ( i )  ;", "renderTo ( child ,    g ,    rendered ,     ( i    =  =     (  ( children . size (  )  )     -     1  )  )  )  ;", "}", "g . completeChildren (  )  ;", "}", "METHOD_END"], "methodName": ["renderTo"], "fileName": "org.gradle.internal.graph.DirectedGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "GraphRenderer   renderer    =    new   GraphRenderer ( output )  ;", "Set < N >    rendered    =    new   HashSet < N >  (  )  ;", "omittedDetails    =    false ;", "renderTo ( root ,    renderer ,    rendered ,    false )  ;", "if    ( omittedDetails )     {", "output . println (  )  ;", "output . withStyle ( Style . Info )  . println (  \"  (  *  )     -    details   omitted    ( listed   previously )  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["renderTo"], "fileName": "org.gradle.internal.graph.DirectedGraphRenderer"}, {"methodBody": ["METHOD_START", "{", "Set < N >    reachableNodes    =    nodes . get ( node )  ;", "reachableNodes . add ( node )  ;", "Set < N >    reachableStartNodes    =    new   LinkedHashSet < N >  ( topLevelNodes )  ;", "reachableStartNodes . retainAll ( reachableNodes )  ;", "reachableStartNodes . remove ( node )  ;", "for    ( N   startNode    :    reachableStartNodes )     {", "reachableNodes . removeAll ( calculateReachableNodes ( nodes ,    startNode ,    topLevelNodes )  )  ;", "}", "return   reachableNodes ;", "}", "METHOD_END"], "methodName": ["calculateReachableNodes"], "fileName": "org.gradle.internal.graph.GraphAggregator"}, {"methodBody": ["METHOD_START", "{", "Map < N ,    Set < N >  >    reachableByNode    =    new   HashMap < N ,    Set < N >  >  (  )  ;", "Set < N >    topLevelNodes    =    new   LinkedHashSet < N >  ( allNodes )  ;", "for    ( N   node    :    allNodes )     {", "Set < N >    reachableNodes    =    graphWalker . add ( node )  . findValues (  )  ;", "reachableByNode . put ( node ,    reachableNodes )  ;", "topLevelNodes . removeAll ( reachableNodes )  ;", "}", "topLevelNodes . addAll ( startNodes )  ;", "Map < N ,    Set < N >  >    nodes    =    new   HashMap < N ,    Set < N >  >  (  )  ;", "for    ( N   node    :    topLevelNodes )     {", "nodes . put ( node ,    calculateReachableNodes ( reachableByNode ,    node ,    topLevelNodes )  )  ;", "}", "return   new    . Result < N >  ( nodes ,    topLevelNodes )  ;", "}", "METHOD_END"], "methodName": ["group"], "fileName": "org.gradle.internal.graph.GraphAggregator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( prefix . length (  )  )     =  =     0  )     {", "seenRootChildren    =    false ;", "} else    {", "prefix . setLength (  (  ( prefix . length (  )  )     -     5  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["completeChildren"], "fileName": "org.gradle.internal.graph.GraphRenderer"}, {"methodBody": ["METHOD_START", "{", "return   output ;", "}", "METHOD_END"], "methodName": ["getOutput"], "fileName": "org.gradle.internal.graph.GraphRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( seenRootChildren )     {", "prefix . app (  ( lastChild    ?     \"                 \"     :     \"  |              \"  )  )  ;", "}", "seenRootChildren    =    true ;", "}", "METHOD_END"], "methodName": ["startChildren"], "fileName": "org.gradle.internal.graph.GraphRenderer"}, {"methodBody": ["METHOD_START", "{", "if    ( seenRootChildren )     {", "output . withStyStyInfo )  . text (  (  ( prefix )     +     ( lastChild    ?     \"  \\  \\  -  -  -     \"     :     \"  +  -  -  -     \"  )  )  )  ;", "}", "this . lastChild    =    lastChild ;", "node . execute ( output )  ;", "output . println (  )  ;", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.internal.graph.GraphRenderer"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    takeBuffer (  )  ;", "try    {", "Hasher   hasher    =    hasherFactory . create (  )  ;", "while    ( true )     {", "int   nread    =    inpu . read ( buffer )  ;", "if    ( nread    <     0  )     {", "break ;", "}", "outpu . write ( buffer ,     0  ,    nread )  ;", "hasher . putBytes ( buffer ,     0  ,    nread )  ;", "}", "return   hasher . hash (  )  ;", "}    finally    {", "returnBuffer ( buffer )  ;", "}", "}", "METHOD_END"], "methodName": ["doHash"], "fileName": "org.gradle.internal.hash.DefaultStreamHasher"}, {"methodBody": ["METHOD_START", "{", "buffers . offer ( buffer )  ;", "}", "METHOD_END"], "methodName": ["returnBuffer"], "fileName": "org.gradle.internal.hash.DefaultStreamHasher"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    buffers . poll (  )  ;", "if    ( buffer    =  =    null )     {", "buffer    =    new   byte [  8  1  9  2  ]  ;", "}", "return   buffer ;", "}", "METHOD_END"], "methodName": ["takeBuffer"], "fileName": "org.gradle.internal.hash.DefaultStreamHasher"}, {"methodBody": ["METHOD_START", "{", "writeRaw (  \"  <  ! DOCTYPE   html >  \"  )  ;", "}", "METHOD_END"], "methodName": ["writeHtmlHeader"], "fileName": "org.gradle.internal.html.SimpleHtmlWriter"}, {"methodBody": ["METHOD_START", "{", "JarFile   jarFile    =    null ;", "try    {", "jarFile    =    new   JarFile ( jar )  ;", "JarEntry   markerFile    =    jarFile . getJarEntry (  . MARKER _ FILENAME )  ;", "if    ( markerFile    !  =    null )     {", "return   true ;", "}", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    finally    {", "if    ( jarFile    !  =    null )     {", "try    {", "jarFile . close (  )  ;", "}    catch    ( IOException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["findMarkerFileInJar"], "fileName": "org.gradle.internal.installation.GradleRuntimeShadedJarDetector"}, {"methodBody": ["METHOD_START", "{", "return    ( location . getProtocol (  )  . equals ( GradleRuntimeShadedJarDetector . FILE _ PROTOCOL )  )     &  &     ( location . getPath (  )  . endsWith ( GradleRuntimeShadedJarDetector . JAR _ FILE _ EXTENSION )  )  ;", "}", "METHOD_END"], "methodName": ["isJarUrl"], "fileName": "org.gradle.internal.installation.GradleRuntimeShadedJarDetector"}, {"methodBody": ["METHOD_START", "{", "if    ( clazz    =  =    null )     {", "throw   new   IllegalArgumentException (  \" Need   to   provide   valid   class   reference \"  )  ;", "}", "CodeSource   codeSource    =    clazz . getProtectionDomain (  )  . getCodeSource (  )  ;", "if    ( codeSource    !  =    null )     {", "URL   location    =    codeSource . getLocation (  )  ;", "if    (  . isJarUrl ( location )  )     {", "try    {", "return    . findMarkerFileInJar ( new   File ( location . toURI (  )  )  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isLoadedFrom"], "fileName": "org.gradle.internal.installation.GradleRuntimeShadedJarDetector"}, {"methodBody": ["METHOD_START", "{", "return   doBuild ( new   Callable < GradleInternal >  (  )     {", "@ Override", "public   GradleInternal   call (  )    throws   Exception    {", "GradleInternal   gradle    =    getLauncher (  )  . getConfiguredBuild (  )  ;", "getLauncher (  )  . finishBuild (  )  ;", "return   gradle ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.internal.invocation.GradleBuildController"}, {"methodBody": ["METHOD_START", "{", "GradleInternal   gradle    =    getGradle (  )  ;", "BuildOperationExecutor   buildOperationExecutor    =    gradle . getServices (  )  . get ( BuildOperationExecutor . class )  ;", "gradle . setBuildOperation ( buildOperationExecutor . getCurrentOperation (  )  )  ;", "try    {", "return   workerLeaseService . withLocks ( Collections . singleton ( workerLeaseService . getWorkerLease (  )  )  ,    build )  ;", "}    finally    {", "gradle . setBuildOperation ( null )  ;", "state    =     . State . Completed ;", "}", "}", "METHOD_END"], "methodName": ["doBuild"], "fileName": "org.gradle.internal.invocation.GradleBuildController"}, {"methodBody": ["METHOD_START", "{", "return   getLauncher (  )  . getGradle (  )  ;", "}", "METHOD_END"], "methodName": ["getGradle"], "fileName": "org.gradle.internal.invocation.GradleBuildController"}, {"methodBody": ["METHOD_START", "{", "if    (  ( state )     =  =     ( GradleBuildController . State . Completed )  )     {", "throw   new   IllegalStateException (  \" Cannot   use   launcher   after   build   has   completed .  \"  )  ;", "}", "return   gradleLauncher ;", "}", "METHOD_END"], "methodName": ["getLauncher"], "fileName": "org.gradle.internal.invocation.GradleBuildController"}, {"methodBody": ["METHOD_START", "{", "return   doBuild ( new   Callable < GradleInternal >  (  )     {", "@ Override", "public   GradleInternal   call (  )    throws   Exception    {", "return   getLauncher (  )  . executeTasks (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.internal.invocation.GradleBuildController"}, {"methodBody": ["METHOD_START", "{", "JavaVersion   current    =    JavaVersion . current (  )  ;", "if    (  ( current . compareTo ( minVersion )  )     >  =     0  )     {", "return ;", "}", "throw   new    ( String . format (  \"  % s    % s   requires   Java    % s   or   later   to   run .    You   are   currently   using   Java    % s .  \"  ,    component ,    GradleVersion . current (  )  . getVersion (  )  ,    minVersion . getMajorVersion (  )  ,    current . getMajorVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertUsingVersion"], "fileName": "org.gradle.internal.jvm.UnsupportedJavaRuntimeException"}, {"methodBody": ["METHOD_START", "{", "if    (  ( configuredVersion . compareTo ( minVersion )  )     >  =     0  )     {", "return ;", "}", "throw   new    ( String . format (  \"  % s    % s   requires   Java    % s   or   later   to   run .    Your   build   is   currently   configured   to   use   Java    % s .  \"  ,    component ,    GradleVersion . current (  )  . getVersion (  )  ,    minVersion . getMajorVersion (  )  ,    configuredVersion . getMajorVersion (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertUsingVersion"], "fileName": "org.gradle.internal.jvm.UnsupportedJavaRuntimeException"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( JavaVersion . current (  )  . isJava 8 Compatible (  )  )  )     {", "DeprecationLogger . nagUserWith (  . JAVA 7  _ DEPRECATION _ WARNING _ DOC )  ;", "}", "}", "METHOD_END"], "methodName": ["javaDeprecationWarning"], "fileName": "org.gradle.internal.jvm.UnsupportedJavaRuntimeException"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    publicType    =    getPublicType (  )  ;", "boolean   includeDisplayName    =    hasUsefulDisplayName (  )  ;", "if    (  ( publicType    !  =    null )     &  &    includeDisplayName )     {", "return   new   MissingPropertyException ( String . format (  \" Could   not   get   unknown   property    '  % s '    for    % s   of   type    % s .  \"  ,    name ,    getDisplayName (  )  ,    publicType . getName (  )  )  ,    name ,    publicType )  ;", "} else", "if    ( publicType    !  =    null )     {", "return   new   MissingPropertyException ( String . format (  \" Could   not   get   unknown   property    '  % s '    for      of   type    % s .  \"  ,    name ,    publicType . getName (  )  )  ,    name ,    publicType )  ;", "} else    {", "return   new   MissingPropertyException ( String . format (  \" Could   not   get   unknown   property    '  % s '    for    % s .  \"  ,    name ,    getDisplayName (  )  )  ,    name ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["getMissingProperty"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getPublicType"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    publicType    =    getPublicType (  )  ;", "boolean   includeDisplayName    =    hasUsefulDisplayName (  )  ;", "if    (  ( publicType    !  =    null )     &  &    includeDisplayName )     {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   get   the   value   of   write - only   property    '  % s '    for    % s   of   type    % s .  \"  ,    name ,    getDisplayName (  )  ,    publicType . getName (  )  )  )  ;", "} else", "if    ( publicType    !  =    null )     {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   get   the   value   of   write - only   property    '  % s '    for      of   type    % s .  \"  ,    name ,    publicType . getName (  )  )  )  ;", "} else    {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   get   the   value   of   write - only   property    '  % s '    for    % s .  \"  ,    name ,    getDisplayName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getWriteOnlyProperty"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["hasUsefulDisplayName"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    publicType    =    getPublicType (  )  ;", "boolean   includeDisplayName    =    hasUsefulDisplayName (  )  ;", "final   String   message ;", "if    (  ( publicType    !  =    null )     &  &    includeDisplayName )     {", "message    =    String . format (  \" Could   not   find   method    % s (  )    for   arguments    % s   on    % s   of   type    % s .  \"  ,    name ,    Arrays . toString ( params )  ,    getDisplayName (  )  ,    publicType . getName (  )  )  ;", "} else", "if    ( publicType    !  =    null )     {", "message    =    String . format (  \" Could   not   find   method    % s (  )    for   arguments    % s   on   object   of   type    % s .  \"  ,    name ,    Arrays . toString ( params )  ,    publicType . getName (  )  )  ;", "} else    {", "message    =    String . format (  \" Could   not   find   method    % s (  )    for   arguments    % s   on    % s .  \"  ,    name ,    Arrays . toString ( params )  ,    getDisplayName (  )  )  ;", "}", "return   new    . CustomMessageMissingMethodException ( name ,    publicType ,    message ,    params )  ;", "}", "METHOD_END"], "methodName": ["methodMissingException"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    publicType    =    getPublicType (  )  ;", "boolean   includeDisplayName    =    hasUsefulDisplayName (  )  ;", "if    (  ( publicType    !  =    null )     &  &    includeDisplayName )     {", "return   new   MissingPropertyException ( String . format (  \" Could   not   set   unknown   property    '  % s '    for    % s   of   type    % s .  \"  ,    name ,    getDisplayName (  )  ,    publicType . getName (  )  )  ,    name ,    publicType )  ;", "} else", "if    ( publicType    !  =    null )     {", "return   new   MissingPropertyException ( String . format (  \" Could   not   set   unknown   property    '  % s '    for      of   type    % s .  \"  ,    name ,    publicType . getName (  )  )  ,    name ,    publicType )  ;", "} else    {", "return   new   MissingPropertyException ( String . format (  \" Could   not   set   unknown   property    '  % s '    for    % s .  \"  ,    name ,    getDisplayName (  )  )  ,    name ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["setMissingProperty"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    publicType    =    getPublicType (  )  ;", "boolean   includeDisplayName    =    hasUsefulDisplayName (  )  ;", "if    (  ( publicType    !  =    null )     &  &    includeDisplayName )     {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   set   the   value   of   read - only   property    '  % s '    for    % s   of   type    % s .  \"  ,    name ,    getDisplayName (  )  ,    publicType . getName (  )  )  )  ;", "} else", "if    ( publicType    !  =    null )     {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   set   the   value   of   read - only   property    '  % s '    for      of   type    % s .  \"  ,    name ,    publicType . getName (  )  )  )  ;", "} else    {", "return   new   GroovyRuntimeException ( String . format (  \" Cannot   set   the   value   of   read - only   property    '  % s '    for    % s .  \"  ,    name ,    getDisplayName (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setReadOnlyProperty"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObject"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( object . hasMethod (  \" method \"  ,     \" a \"  )  )  ;", "try    {", "object . invokeMethod (  \" method \"  ,     \" b \"  )  ;", "fail (  )  ;", "}    catch    ( MissingMethodException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   find   method   method (  )    for   arguments    [ b ]    on    < display - name >  .  \"  )  )  ;", "}", "DynamicInvokeResult   result    =    object . tryInvokeMethod (  \" method \"  ,     \" c \"  )  ;", "assertFalse ( result . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasNoMethods"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( object . hasProperty (  \" something \"  )  )  ;", "assertTrue ( object . getProperties (  )  . isEmpty (  )  )  ;", "try    {", "object . getProperty (  \" something \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   get   unknown   property    ' something '    for    < display - name >  .  \"  )  )  ;", "}", "DynamicInvokeResult   result    =    object . tryGetProperty (  \" something \"  )  ;", "assertFalse ( result . isFound (  )  )  ;", "try    {", "object . setProperty (  \" something \"  ,     \" value \"  )  ;", "fail (  )  ;", "}    catch    ( MissingPropertyException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  \" Could   not   set   unknown   property    ' something '    for    < display - name >  .  \"  )  )  ;", "}", "result    =    object . trySetProperty (  \" something \"  ,     \" value \"  )  ;", "assertFalse ( result . isFound (  )  )  ;", "}", "METHOD_END"], "methodName": ["hasNoProperties"], "fileName": "org.gradle.internal.metaobject.AbstractDynamicObjectTest"}, {"methodBody": ["METHOD_START", "{", "if    ( bean   instanceof   Class )     {", "return   new    . ClassAdapter (  (  ( Class <  ?  >  )     ( bean )  )  )  ;", "} else", "if    ( bean   instanceof   Map )     {", "return   new    . MapAdapter (  )  ;", "} else", "if    (  (  ( bean   instanceof   DynamicObject )     |  |     ( bean   instanceof   DynamicObjectAware )  )     |  |     (  !  ( bean   instanceof   groovy . lang . GroovyObject )  )  )     {", "return   new    . MetaClassAdapter (  )  ;", "}", "return   new    . GroovyObjectAdapter (  )  ;", "}", "METHOD_END"], "methodName": ["determineDelegate"], "fileName": "org.gradle.internal.metaobject.BeanDynamicObject"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bean )    instanceof   GroovyObject )     {", "return    (  ( GroovyObject )     ( bean )  )  . getMetaClass (  )  ;", "} else    {", "return   GroovySystem . getMetaClassRegistry (  )  . getMetaClass ( bean . getClass (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["getMetaClass"], "fileName": "org.gradle.internal.metaobject.BeanDynamicObject"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( includeProperties )  )     {", "return   this ;", "}", "if    (  ( withNoProperties )     =  =    null )     {", "withNoProperties    =    new    ( bean ,    publicType ,    false ,    implementsMissing ,    propertySetTransformer ,    argsTransformer )  ;", "}", "return   withNoProperties ;", "}", "METHOD_END"], "methodName": ["withNoProperties"], "fileName": "org.gradle.internal.metaobject.BeanDynamicObject"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( implementsMissing )  )     {", "return   this ;", "}", "if    (  ( withNoImplementsMissing )     =  =    null )     {", "withNoImplementsMissing    =    new    ( bean ,    publicType ,    includeProperties ,    false ,    propertySetTransformer ,    argsTransformer )  ;", "}", "return   withNoImplementsMissing ;", "}", "METHOD_END"], "methodName": ["withNotImplementsMissing"], "fileName": "org.gradle.internal.metaobject.BeanDynamicObject"}, {"methodBody": ["METHOD_START", "{", "this . objects    =    objects ;", "updateObjects    =    objects ;", "}", "METHOD_END"], "methodName": ["setObjects"], "fileName": "org.gradle.internal.metaobject.CompositeDynamicObject"}, {"methodBody": ["METHOD_START", "{", "this . updateObjects    =    objects ;", "}", "METHOD_END"], "methodName": ["setObjectsForUpdate"], "fileName": "org.gradle.internal.metaobject.CompositeDynamicObject"}, {"methodBody": ["METHOD_START", "{", "return   DynamicInvokeResult . notFound (  )  ;", "}", "METHOD_END"], "methodName": ["_configure"], "fileName": "org.gradle.internal.metaobject.ConfigureDelegate"}, {"methodBody": ["METHOD_START", "{", "return   DynamicInvokeResult . notFound (  )  ;", "}", "METHOD_END"], "methodName": ["_configure"], "fileName": "org.gradle.internal.metaobject.ConfigureDelegate"}, {"methodBody": ["METHOD_START", "{", "boolean   isAlreadyConfiguring    =     _ configuring ;", "_ configuring    =    true ;", "try    {", "DynamicInvokeResult   result    =     _ delegate . tryGetProperty ( name )  ;", "if    ( result . isFound (  )  )     {", "return   result . getValue (  )  ;", "}", "result    =     _ owner . tryGetProperty ( name )  ;", "if    ( result . isFound (  )  )     {", "return   result . getValue (  )  ;", "}", "if    (  ! isAlreadyConfiguring )     {", "result    =     _ configure ( name )  ;", "if    ( result . isFound (  )  )     {", "return   result . getValue (  )  ;", "}", "}", "throw    _ delegate . getMissingProperty ( name )  ;", "}    finally    {", "_ configuring    =    isAlreadyConfiguring ;", "}", "}", "METHOD_END"], "methodName": ["getProperty"], "fileName": "org.gradle.internal.metaobject.ConfigureDelegate"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent    !  =    null )     &  &     (  !  ( parent . isRunning (  )  )  )  )     {", "String   parentName    =    parent . getDescrip (  )  . getDisplayName (  )  ;", "throw   new   IllegalStateExcep ( String . format ( message ,    child . getDisplayName (  )  ,    parentName )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertParentRunning"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "OperationIdentifier   id    =    new   OperationIdentifier ( buildOperationIdFactory . nextId (  )  )  ;", ". BuildOperationState   current    =    maybeStartUnmanagedThreadOperation ( parent )  ;", "return   descriptorBuilder . build ( id ,     ( current    =  =    null    ?    null    :    current . getDescription (  )  . getId (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createDescriptor"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "BuildOperationDescriptor   descriptor    =    currentOperation . getDescription (  )  ;", "ProgressLogger   progressLogger    =    progressLoggerFactory . newOperation (  . class ,    descriptor )  ;", "return   progressLogger . start ( descriptor . getDisplayName (  )  ,    descriptor . getProgressDisplayName (  )  )  ;", "}", "METHOD_END"], "methodName": ["createProgressLogger"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "assert    ( getCurrentBuildOperation (  )  )     =  =    null ;", "OperationIdentifier   rootBuildOpId    =    new   OperationIdentifier ( DefaultBuildOperationIdFactory . ROOT _ BUILD _ OPERATION _ ID _ VALUE )  ;", ". BuildOperationState   operation    =    new    . BuildOperationState ( BuildOperationDescriptor . displayName ( displayName )  . build ( rootBuildOpId ,    null )  ,    clock . getCurrentTime (  )  )  ;", "operation . setRunning ( true )  ;", "setCurrentBuildOperation ( operation )  ;", "}", "METHOD_END"], "methodName": ["createRunningRootOperation"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "failIfInResourceLockTransform (  )  ;", "BuildOperationDescriptor . Builder   descriptorBuilder    =    buildOperation . description (  )  ;", ". BuildOperationState   parent    =     (  (  . BuildOperationState )     ( descriptorBuilder . getParentState (  )  )  )  ;", "if    ( parent    =  =    null )     {", "parent    =    defaultParent ;", "}", "BuildOperationDescriptor   descriptor    =    createDescriptor ( descriptorBuilder ,    parent )  ;", ". BuildOperationState   newOperation    =    new    . BuildOperationState ( descriptor ,    clock . getCurrentTime (  )  )  ;", "assertParentRunning (  \" Cannot   start   operation    (  % s )    as   parent   operation    (  % s )    has   already   completed .  \"  ,    descriptor ,    parent )  ;", "newOperation . setRunning ( true )  ;", ". BuildOperationState   parentOperation    =    getCurrentBuildOperation (  )  ;", "setCurrentBuildOperation ( newOperation )  ;", "try    {", "listener . started ( descriptor ,    new   OperationStartEvent ( newOperation . getStartTime (  )  )  )  ;", "ProgressLogger   progressLogger    =    createProgressLogger ( newOperation )  ;", "Throwable   failure    =    null ;", ". DefaultBuildOperationContext   context    =    new    . DefaultBuildOperationContext (  )  ;", ". LOGGER . debug (  \" Build   operation    '  {  }  '    started \"  ,    descriptor . getDisplayName (  )  )  ;", "try    {", "worker . execute ( buildOperation ,    context )  ;", "}    catch    ( Throwable   t )     {", "context . thrown ( t )  ;", "failure    =    t ;", "}", ". LOGGER . debug (  \" Completing   Build   operation    '  {  }  '  \"  ,    descriptor . getDisplayName (  )  )  ;", "progressLogger . completed ( context . status ,     (  ( context . failure )     !  =    null )  )  ;", "listener . finished ( descriptor ,    new   OperationFinishEvent ( newOperation . getStartTime (  )  ,    clock . getCurrentTime (  )  ,    context . failure ,    context . result )  )  ;", "assertParentRunning (  \" Parent   operation    (  %  2  $ s )    completed   before   this   operation    (  %  1  $ s )  .  \"  ,    descriptor ,    parent )  ;", "if    ( failure    !  =    null )     {", "throw   UncheckedException . throwAsUncheckedException ( failure ,    true )  ;", "}", "}    finally    {", "setCurrentBuildOperation ( parentOperation )  ;", "newOperation . setRunning ( false )  ;", ". LOGGER . debug (  \" Build   operation    '  {  }  '    completed \"  ,    descriptor . getDisplayName (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "failIfInResourceLockTransform (  )  ;", "BuildOperationQueue < O >    queue    =    buildOperationQueueFactory . create ( fixedSizePool ,    worker )  ;", "List < GradleException >    failures    =    Lists . newArrayList (  )  ;", "try    {", "queueAction . execute ( queue )  ;", "}    catch    ( Exception   e )     {", "failures . add ( new   BuildOperationQueueFailure (  (  \" There   was   a   failure   while   populating   the   build   operation   queue :     \"     +     ( e . getMessage (  )  )  )  ,    e )  )  ;", "queue . cancel (  )  ;", "}", "try    {", "queue . waitForCompletion (  )  ;", "}    catch    ( MultipleBuildOperationFailures   e )     {", "failures . add ( e )  ;", "}", "if    (  ( failures . size (  )  )     =  =     1  )     {", "throw   failures . get (  0  )  ;", "} else", "if    (  ( failures . size (  )  )     >     1  )     {", "throw   new   DefaultMultiCauseException (  . formatMultipleFailureMessage ( failures )  ,    failures )  ;", "}", "}", "METHOD_END"], "methodName": ["executeInParallel"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resourceLockCoordinationService . getCurrent (  )  )     !  =    null )     {", "throw   new   ResourceDeadlockException (  \" An   attempt   was   made   to   execute   build      inside   of   a   resource   lock   transform .       Aborting   to   avoid   a   deadlock .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["failIfInResourceLockTransform"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "return   StringUtils . join ( CollectionUtils . collect ( failures ,    new   Transformer < String ,    GradleException >  (  )     {", "@ Override", "public   String   transform ( GradleException   e )     {", "return   e . getMessage (  )  ;", "}", "}  )  ,     (  (  (  . LINE _ SEPARATOR )     +     \" AND \"  )     +     (  . LINE _ SEPARATOR )  )  )  ;", "}", "METHOD_END"], "methodName": ["formatMultipleFailureMessage"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DefaultBuildOperationExecutor . BuildOperationState )     ( currentBuildOperationRef . get (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentBuildOperation"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( GradleThread . isManaged (  )  )  )     &  &     ( parentState    =  =    null )  )     {", "parentState    =     . UnmanagedThreadOperation . create ( clock )  ;", "parentState . setRunning ( true )  ;", "setCurrentBuildOperation ( parentState )  ;", "listener . started ( parentState . getDescription (  )  ,    new   OperationStartEvent ( parentState . getStartTime (  )  )  )  ;", "}", "return   parentState ;", "}", "METHOD_END"], "methodName": ["maybeStartUnmanagedThreadOperation"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "DefaultBuildOperationExecutor . BuildOperationState   current    =    getCurrentBuildOperation (  )  ;", "if    ( current   instanceof   DefaultBuildOperationExecutor . UnmanagedThreadOperation )     {", "try    {", "listener . finished ( current . getDescription (  )  ,    new   OperationFinishEvent ( current . getStartTime (  )  ,    clock . getCurrentTime (  )  ,    null ,    null )  )  ;", "}    finally    {", "setCurrentBuildOperation ( null )  ;", "current . setRunning ( false )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["maybeStopUnmanagedThreadOperation"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "currentBuildOperationRef . set ( parentState )  ;", "}", "METHOD_END"], "methodName": ["setCurrentBuildOperation"], "fileName": "org.gradle.internal.operations.DefaultBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "return   log . getDescriptors (  )  ;", "}", "METHOD_END"], "methodName": ["getOperations"], "fileName": "org.gradle.internal.operations.TestBuildOperationExecutor"}, {"methodBody": ["METHOD_START", "{", "return   maximumFailures ;", "}", "METHOD_END"], "methodName": ["getMaximumFailedOperationsShown"], "fileName": "org.gradle.internal.operations.logging.BuildOperationLogInfo"}, {"methodBody": ["METHOD_START", "{", "return   outputFile ;", "}", "METHOD_END"], "methodName": ["getOutputFile"], "fileName": "org.gradle.internal.operations.logging.BuildOperationLogInfo"}, {"methodBody": ["METHOD_START", "{", "return   taskName ;", "}", "METHOD_END"], "methodName": ["getTaskName"], "fileName": "org.gradle.internal.operations.logging.BuildOperationLogInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  \" log   for    \"     +     ( getTaskName (  )  )  )     +     \"    to    \"  )     +     ( getOutputFile (  )  . getAbsolutePath (  )  )  )     +     \"  ,    showing   up   to    \"  )     +     ( getMaximumFailedOperationsShown (  )  )  )     +     \"    failures \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.internal.operations.logging.BuildOperationLogInfo"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   logWriter    =    null ;", "try    {", "logWriter    =    new   PrintWriter ( new   FileWriter ( outputFile )  ,    true )  ;", "}    catch    ( IOExcep   e )     {", "UncheckedExcep . throwAsUncheckedExcep ( e )  ;", "}", "return   logWriter ;", "}", "METHOD_END"], "methodName": ["createWriter"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLogger"}, {"methodBody": ["METHOD_START", "{", "return   new   ConsoleRenderer (  )  . asClickableFileUrl ( configuration . getOutputFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["getLogLocation"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLogger"}, {"methodBody": ["METHOD_START", "{", "logger . log ( logLevel ,    message )  ;", "logWriter . println ( message )  ;", "}", "METHOD_END"], "methodName": ["logInBoth"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( numberOfFailedOperationsSeen )     <     ( configuration . getMaximumFailedOperationsShown (  )  )  )     {", "logger . log ( ERROR ,    output )  ;", "}", "logWriter . println ( output )  ;", "( numberOfFailedOperationsSeen )  +  +  ;", "}", "METHOD_END"], "methodName": ["maybeShowFailure"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLogger"}, {"methodBody": ["METHOD_START", "{", "logger . log ( INFO ,    output )  ;", "logWriter . println ( output )  ;", "}", "METHOD_END"], "methodName": ["maybeShowSuccess"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLogger"}, {"methodBody": ["METHOD_START", "{", "final   BuildOperationLogInfo   configuration ;", "if    ( logger . isDebugEnabled (  )  )     {", "configuration    =    new   BuildOperationLogInfo ( taskName ,    outputFile ,    Integer . MAX _ VALUE )  ;", "} else    {", "configuration    =    new   BuildOperationLogInfo ( taskName ,    outputFile ,    maximumFailures )  ;", "}", "return   configuration ;", "}", "METHOD_END"], "methodName": ["createLogInfo"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLoggerFactory"}, {"methodBody": ["METHOD_START", "{", "GFileUtils . mkdirs ( outputDir )  ;", "return   new   File ( outputDir ,     \" output . txt \"  )  ;", "}", "METHOD_END"], "methodName": ["createOutputFile"], "fileName": "org.gradle.internal.operations.logging.DefaultBuildOperationLoggerFactory"}, {"methodBody": ["METHOD_START", "{", "buildOperationListener . progress ( buildOperationId ,    new   OperationProgressEvent ( event . getTimestamp (  )  ,    event )  )  ;", "}", "METHOD_END"], "methodName": ["emit"], "fileName": "org.gradle.internal.operations.logging.LoggingBuildOperationProgressBroadcaster"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildOperationNotificationListener 2  (  )     {", "@ Override", "public   void   started ( BuildOperationStartedNotification   notification )     {", "listener . started ( notification )  ;", "}", "@ Override", "public   void   progress ( BuildOperationProgressNotification   notification )     {", "}", "@ Override", "public   void   finished ( BuildOperationFinishedNotification   notification )     {", "listener . finished ( notification )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["adapt"], "fileName": "org.gradle.internal.operations.notify.BuildOperationNotificationBridge"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . notificationListener )     !  =    null )     {", "throw   new   IllegalStateException (  (  (  \" listener   is   already   registered    ( implementation   class    \"     +     ( this . notificationListener . getClass (  )  . getName (  )  )  )     +     \"  )  \"  )  )  ;", "}", "this . notificationListener    =    notificationListener ;", "}", "METHOD_END"], "methodName": ["assignSingleListener"], "fileName": "org.gradle.internal.operations.notify.BuildOperationNotificationBridge"}, {"methodBody": ["METHOD_START", "{", "return   registrar ;", "}", "METHOD_END"], "methodName": ["getRegistrar"], "fileName": "org.gradle.internal.operations.notify.BuildOperationNotificationBridge"}, {"methodBody": ["METHOD_START", "{", "return    ( detailsClassName )     =  =    null    ?    null    :    getClass (  )  . getClassLoader (  )  . loadClass ( detailsClassName )  ;", "}", "METHOD_END"], "methodName": ["getDetailsType"], "fileName": "org.gradle.internal.operations.trace.BuildOperationRecord"}, {"methodBody": ["METHOD_START", "{", "return    ( resultClassName )     =  =    null    ?    null    :    getClass (  )  . getClassLoader (  )  . loadClass ( resultClassName )  ;", "}", "METHOD_END"], "methodName": ["getResultType"], "fileName": "org.gradle.internal.operations.trace.BuildOperationRecord"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    detailsType    =    getDetailsType (  )  ;", "return    ( detailsType    !  =    null )     &  &     ( clazz . isAssignableFrom ( detailsType )  )  ;", "}", "METHOD_END"], "methodName": ["hasDetailsOfType"], "fileName": "org.gradle.internal.operations.trace.BuildOperationRecord"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    map    =    new   LinkedHashMap < String ,    Object >  (  )  ;", "map . put (  \" displayName \"  ,    displayName )  ;", "map . put (  \" id \"  ,    id )  ;", "if    (  ( parentId )     !  =    null )     {", "map . put (  \" parentId \"  ,    parentId )  ;", "}", "map . put (  \" startTime \"  ,    startTime )  ;", "map . put (  \" endTime \"  ,    endTime )  ;", "map . put (  \" duration \"  ,     (  ( endTime )     -     ( startTime )  )  )  ;", "if    (  ( details )     !  =    null )     {", "map . put (  \" details \"  ,    details )  ;", "map . put (  \" detailsClassName \"  ,    detailsClassName )  ;", "}", "if    (  ( result )     !  =    null )     {", "map . put (  \" result \"  ,    result )  ;", "map . put (  \" resultClassName \"  ,    resultClassName )  ;", "}", "if    (  ( failure )     !  =    null )     {", "map . put (  \" failure \"  ,    failure )  ;", "}", "if    (  !  ( progress . isEmpty (  )  )  )     {", "map . put (  \" progress \"  ,    Lists . transform ( progress ,    new   com . google . common . base . Function <  . Progress ,    Map < String ,     ?  >  >  (  )     {", "@ Override", "public   Map < String ,     ?  >    apply (  . Progress   input )     {", "return   input . toSerializable (  )  ;", "}", "}  )  )  ;", "}", "if    (  !  ( children . isEmpty (  )  )  )     {", "map . put (  \" children \"  ,    Lists . transform ( children ,    new   com . google . common . base . Function <  ,    Map < String ,     ?  >  >  (  )     {", "@ Override", "public   Map < String ,     ?  >    apply (    input )     {", "return   input . toSerializable (  )  ;", "}", "}  )  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["toSerializable"], "fileName": "org.gradle.internal.operations.trace.BuildOperationRecord"}, {"methodBody": ["METHOD_START", "{", "return   new   File (  (  (  ( base    =  =    null )     |  |     ( base . trim (  )  . isEmpty (  )  )     ?     \" operations \"     :    base )     +    suffix )  )  . getAbsoluteFile (  )  ;", "}", "METHOD_END"], "methodName": ["file"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "return   BuildOperationTrace . file ( basePath ,     \"  - log . txt \"  )  ;", "}", "METHOD_END"], "methodName": ["logFile"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "List < BuildOperationRecord >    roots    =    BuildOperationTrace . readLogToTreeRoots ( BuildOperationTrace . logFile ( basePath )  )  ;", "return   new   BuildOperationTree ( roots )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   JsonSlurper   slurper    =    new   JsonSlurper (  )  ;", "final   List < BuildOperationRecord >    roots    =    new   ArrayList < BuildOperationRecord >  (  )  ;", "final   Map < Object ,     . PendingOperation >    pendings    =    new   HashMap < Object ,     . PendingOperation >  (  )  ;", "final   Map < Object ,    List < BuildOperationRecord >  >    childrens    =    new   HashMap < Object ,    List < BuildOperationRecord >  >  (  )  ;", "Files . asCharSource ( logFile ,    UTF _  8  )  . readLines ( new   com . google . common . io . LineProcessor < Void >  (  )     {", "@ Override", "public   boolean   processLine (  @ SuppressWarnings (  \" NullableProblems \"  )", "String   line )     {", "Map < String ,     ?  >    map    =    Cast . uncheckedCast ( slurper . parseText ( line )  )  ;", "if    ( map . containsKey (  \" startTime \"  )  )     {", "SerializedOperationStart   serialized    =    new   SerializedOperationStart ( map )  ;", "pendings . put ( serialized . id ,    new    . PendingOperation ( serialized )  )  ;", "childrens . put ( serialized . id ,    new   LinkedList < BuildOperationRecord >  (  )  )  ;", "} else", "if    ( map . containsKey (  \" time \"  )  )     {", "SerializedOperationProgress   serialized    =    new   SerializedOperationProgress ( map )  ;", ". PendingOperation   pending    =    pendings . get ( serialized . id )  ;", "assert   pending    !  =    null    :     \" did   not   find   owner   of   progress   event   with   ID    \"     +     ( serialized . id )  ;", "pending . progress . add ( serialized )  ;", "} else    {", "SerializedOperationFinish   finish    =    new   SerializedOperationFinish ( map )  ;", ". PendingOperation   pending    =    pendings . remove ( finish . id )  ;", "assert   pending    !  =    null ;", "List < BuildOperationRecord >    children    =    childrens . remove ( finish . id )  ;", "assert   children    !  =    null ;", "SerializedOperationStart   start    =    pending . start ;", "Map < String ,     ?  >    detailsMap    =    Cast . uncheckedCast ( start . details )  ;", "Map < String ,     ?  >    resultMap    =    Cast . uncheckedCast ( finish . result )  ;", "List < BuildOperationRecord . Progress >    progresses    =    new   ArrayList < BuildOperationRecord . Progress >  (  )  ;", "for    ( SerializedOperationProgress   progress    :    pending . progress )     {", "Map < String ,     ?  >    progressDetailsMap    =    Cast . uncheckedCast ( progress . details )  ;", "progresses . add ( new   BuildOperationRecord . Progress ( progress . time ,    progressDetailsMap ,    progress . detailsClassName )  )  ;", "}", "BuildOperationRecord   record    =    new   BuildOperationRecord ( start . id ,    start . parentId ,    start . displayName ,    start . startTime ,    finish . endTime ,     ( detailsMap    =  =    null    ?    null    :    unmodifiableMap ( detailsMap )  )  ,    start . detailsClassName ,     ( resultMap    =  =    null    ?    null    :    unmodifiableMap ( resultMap )  )  ,    finish . resultClassName ,    finish . failureMsg ,    progresses ,    BuildOperationRecord . ORDERING . immutableSortedCopy ( children )  )  ;", "if    (  ( start . parentId )     =  =    null )     {", "roots . add ( record )  ;", "} else    {", "List < BuildOperationRecord >    parentChildren    =    childrens . get ( start . parentId )  ;", "assert   parentChildren    !  =    null    :     (  (  \" parentChildren    !  =    null    '  \"     +    line )     +     \"  '    from    \"  )     +    logFile ;", "parentChildren . add ( record )  ;", "}", "}", "return   true ;", "}", "@ Override", "public   Void   getResult (  )     {", "return   null ;", "}", "}  )  ;", "assert   pendings . isEmpty (  )  ;", "return   roots ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["readLogToTreeRoots"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "try    {", "String   rawJson    =    JsonOutput . toJson ( BuildOperationTree . serialize ( roots )  )  ;", "String   prettyJson    =    JsonOutput . prettyPrint ( rawJson )  ;", "Files . asCharSink (  . file ( basePath ,     \"  - tree . json \"  )  ,    UTF _  8  )  . write ( prettyJson )  ;", "}    catch    ( OutOfMemoryError   e )     {", "System . err . println (  \" Failed   to   write   build   operation   trace   JSON   due   to   out   of   memory .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDetailTree"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "Files . asCharSink ( BuildOperationTrace . file ( basePath ,     \"  - tree . txt \"  )  ,    UTF _  8  )  . writeLines ( new   Iterable < String >  (  )     {", "@ Override", "@ Nonnull", "public   Iterator < String >    iterator (  )     {", "final   Deque < Queue < BuildOperationRecord >  >    stack    =    new   ArrayDeque < Queue < BuildOperationRecord >  >  ( Collections . singleton ( new   ArrayDeque < BuildOperationRecord >  ( roots )  )  )  ;", "final   StringBuilder   stringBuilder    =    new   StringBuilder (  )  ;", "return   new   Iterator < String >  (  )     {", "@ Override", "public   boolean   hasNext (  )     {", "if    ( stack . isEmpty (  )  )     {", "return   false ;", "} else", "if    ( stack . peek (  )  . isEmpty (  )  )     {", "stack . pop (  )  ;", "return   hasNext (  )  ;", "} else    {", "return   true ;", "}", "}", "@ Override", "public   String   next (  )     {", "Queue < BuildOperationRecord >    children    =    stack . peek (  )  ;", "BuildOperationRecord   record    =    children . poll (  )  ;", "stringBuilder . setLength (  0  )  ;", "int   indents    =     ( stack . size (  )  )     -     1  ;", "for    ( int   i    =     0  ;    i    <    indents ;     +  + i )     {", "stringBuilder . append (  \"        \"  )  ;", "}", "if    (  !  ( record . children . isEmpty (  )  )  )     {", "stack . addFirst ( new   ArrayDeque < BuildOperationRecord >  ( record . children )  )  ;", "}", "stringBuilder . append ( record . displayName )  ;", "if    (  ( record . details )     !  =    null )     {", "stringBuilder . append (  \"     \"  )  ;", "stringBuilder . append ( JsonOutput . toJson ( record . details )  )  ;", "}", "if    (  ( record . result )     !  =    null )     {", "stringBuilder . append (  \"     \"  )  ;", "stringBuilder . append ( JsonOutput . toJson ( record . result )  )  ;", "}", "stringBuilder . append (  \"     [  \"  )  ;", "stringBuilder . append (  (  ( record . endTime )     -     ( record . startTime )  )  )  ;", "stringBuilder . append (  \" ms ]  \"  )  ;", "stringBuilder . append (  \"     (  \"  )  ;", "stringBuilder . append ( record . id )  ;", "stringBuilder . append (  \"  )  \"  )  ;", "if    (  !  ( record . progress . isEmpty (  )  )  )     {", "for    ( BuildOperationRecord . Progress   progress    :    record . progress )     {", "stringBuilder . append ( LINE _ SEPARATOR . value (  )  )  ;", "for    ( int   i    =     0  ;    i    <    indents ;     +  + i )     {", "stringBuilder . append (  \"        \"  )  ;", "}", "stringBuilder . append (  \"  -     \"  )  . append ( progress . details )  . append (  \"     [  \"  )  . append (  (  ( progress . time )     -     ( record . startTime )  )  )  . append (  \"  ]  \"  )  ;", "}", "}", "return   stringBuilder . toString (  )  ;", "}", "@ Override", "public   void   remove (  )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["writeSummaryTree"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTrace"}, {"methodBody": ["METHOD_START", "{", "return   Lists . transform ( roots ,    new   com . google . common . base . Function < BuildOperationRecord ,    Map < String ,     ?  >  >  (  )     {", "@ Override", "public   Map < String ,     ?  >    apply ( BuildOperationRecord   input )     {", "return   input . toSerializable (  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTree"}, {"methodBody": ["METHOD_START", "{", "records . put ( record . id ,    record )  ;", "for    ( Record   child    :    record . children )     {", "visit ( records ,    child )  ;", "}", "}", "METHOD_END"], "methodName": ["visit"], "fileName": "org.gradle.internal.operations.trace.BuildOperationTree"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Object >    map    =    ImmutableMap . builder (  )  ;", "map . put (  \" id \"  ,    id )  ;", "if    (  ( result )     !  =    null )     {", "map . put (  \" result \"  ,    result )  ;", "map . put (  \" resultClassName \"  ,    resultClassName )  ;", "}", "if    (  ( failureMsg )     !  =    null )     {", "map . put (  \" failure \"  ,    failureMsg )  ;", "}", "map . put (  \" endTime \"  ,    endTime )  ;", "return   map . build (  )  ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationFinish"}, {"methodBody": ["METHOD_START", "{", "if    ( result   instanceof   ResolveConfigurationDependenciesBuildOperationType . Result )     {", "ResolveConfigurationDependenciesBuildOperationType . Result   cast    =     (  ( ResolveConfigurationDependenciesBuildOperationType . Result )     ( result )  )  ;", "return   Collections . singletonMap (  \" resolvedDependenciesCount \"  ,    cast . getRootComponent (  )  . getDependencies (  )  . size (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationFinish"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Object >    map    =    ImmutableMap . builder (  )  ;", "if    (  ( details )     !  =    null )     {", "map . put (  \" details \"  ,    details )  ;", "map . put (  \" detailsClassName \"  ,    detailsClassName )  ;", "}", "map . put (  \" id \"  ,    id )  ;", "map . put (  \" time \"  ,    time )  ;", "return   map . build (  )  ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationProgress"}, {"methodBody": ["METHOD_START", "{", "return   details ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationProgress"}, {"methodBody": ["METHOD_START", "{", "Builder < String ,    Object >    map    =    ImmutableMap . builder (  )  ;", "map . put (  \" displayName \"  ,    displayName )  ;", "if    (  ( details )     !  =    null )     {", "map . put (  \" details \"  ,    details )  ;", "map . put (  \" detailsClassName \"  ,    detailsClassName )  ;", "}", "map . put (  \" id \"  ,    id )  ;", "if    (  ( parentId )     !  =    null )     {", "map . put (  \" parentId \"  ,    parentId )  ;", "}", "map . put (  \" sTime \"  ,    sTime )  ;", "return   map . build (  )  ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationStart"}, {"methodBody": ["METHOD_START", "{", "if    ( details   instanceof   ExecuteTaskBuildOperationType . Details )     {", "ExecuteTaskBuildOperationType . Details   cast    =     (  ( ExecuteTaskBuildOperationType . Details )     ( details )  )  ;", "Map < String ,    Object >    map    =    new   HashMap < String ,    Object >  (  )  ;", "map . put (  \" buildPath \"  ,    cast . getBuildPath (  )  )  ;", "map . put (  \" taskPath \"  ,    cast . getTaskPath (  )  )  ;", "map . put (  \" taskClass \"  ,    cast . getTaskClass (  )  . getName (  )  )  ;", "map . put (  \" taskId \"  ,    cast . getTaskId (  )  )  ;", "return   map ;", "}", "if    ( details   instanceof   ApplyPluginBuildOperationType . Details )     {", "ApplyPluginBuildOperationType . Details   cast    =     (  ( ApplyPluginBuildOperationType . Details )     ( details )  )  ;", "Map < String ,    Object >    map    =    new   HashMap < String ,    Object >  (  )  ;", "map . put (  \" pluginId \"  ,    cast . getPluginId (  )  )  ;", "map . put (  \" pluginClass \"  ,    cast . getPluginClass (  )  . getName (  )  )  ;", "map . put (  \" targetType \"  ,    cast . getTargetType (  )  )  ;", "map . put (  \" targetPath \"  ,    cast . getTargetPath (  )  )  ;", "map . put (  \" buildPath \"  ,    cast . getBuildPath (  )  )  ;", "return   map ;", "}", "return   details ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.operations.trace.SerializedOperationStart"}, {"methodBody": ["METHOD_START", "{", "return    (  ( rootGradle )     !  =    null )     &  &     ( graph    =  =     ( rootGradle . getTaskGraph (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isRootTaskGraph"], "fileName": "org.gradle.internal.progress.BuildProgressFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootTaskGraphPopulated )  )     {", "b . progress (  \"  \"  ,    false )  ;", "}", "}", "METHOD_END"], "methodName": ["afterEvaluate"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "buildProgress . progress (  \"  \"  ,    taskFailed )  ;", "}", "METHOD_END"], "methodName": ["afterExecute"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootBuildInitComplete )  )     {", "afterExecute ( taskFailed )  ;", "}", "}", "METHOD_END"], "methodName": ["afterNestedExecute"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buildProgress )     !  =    null )     {", "buildProgress . completed (  . WAITING _ PHASE _ DESCRIPTION ,    false )  ;", "}", "buildProgress    =    null ;", "}", "METHOD_END"], "methodName": ["beforeComplete"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "buildProgress    =    loggerProvider . start ( BuildProgressLogger . INITIALIZATION _ PHASE _ DESCRIPTION ,    BuildProgressLogger . INITIALIZATION _ PHASE _ SHORT _ DESCRIPTION ,     0  )  ;", "}", "METHOD_END"], "methodName": ["buildStarted"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buildProgress )     =  =    null )     {", "throw   new   IllegalStateException (  \" Build   logger   is   unavailable    ( it   hasn ' t   started   or   is   already   completed )  .  \"  )  ;", "}", "return   buildProgress ;", "}", "METHOD_END"], "methodName": ["getLogger"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "rootTaskGraphPopulated    =    true ;", "buildProgress . completed (  )  ;", "buildProgress    =    loggerProvider . start (  . EXECUTION _ PHASE _ DESCRIPTION ,     . EXECUTION _ PHASE _ SHORT _ DESCRIPTION ,    totalTasks )  ;", "}", "METHOD_END"], "methodName": ["graphPopulated"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( rootBuildInitComplete )  )     {", "buildProgress . completed (  )  ;", "buildProgress    =    loggerProvider . start (  . INITIALIZATION _ PHASE _ DESCRIPTION ,     . INITIALIZATION _ PHASE _ SHORT _ DESCRIPTION ,    totalTasks )  ;", "}", "}", "METHOD_END"], "methodName": ["nestedTaskGraphPopulated"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "rootBuildInitComplete    =    true ;", "buildProgress . completed (  )  ;", "buildProgress    =    loggerProvider . start (  . CONFIGURATION _ PHASE _ DESCRIPTION ,     . CONFIGURATION _ PHASE _ SHORT _ DESCRIPTION ,    totalProjects )  ;", "}", "METHOD_END"], "methodName": ["projectsLoaded"], "fileName": "org.gradle.internal.progress.BuildProgressLogger"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( prefix )     +     \"     \"  )     +     (  ( int )     (  (  ( current )     *     1  0  0  .  0  )     /     ( total )  )  )  )     +     \"  %  \"  ;", "}", "METHOD_END"], "methodName": ["getProgress"], "fileName": "org.gradle.internal.progress.PercentageProgressFormatter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     =  =     ( total )  )     {", "throw   new   IllegalStateException (  (  \" Cannot   increment   beyond   the   total   of :     \"     +     ( total )  )  )  ;", "}", "( current )  +  +  ;", "}", "METHOD_END"], "methodName": ["increment"], "fileName": "org.gradle.internal.progress.PercentageProgressFormatter"}, {"methodBody": ["METHOD_START", "{", "increment (  )  ;", "return   get (  )  ;", "}", "METHOD_END"], "methodName": ["incrementAndGetProgress"], "fileName": "org.gradle.internal.progress.PercentageProgressFormatter"}, {"methodBody": ["METHOD_START", "{", "return   progressLoggerFactory . newOperation ( loggerClazz )  . start ( description ,    shortDescription ,    totalProgress )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.internal.progress.ProgressLoggerProvider"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  ( current )     +     \"  /  \"  )     +     ( total )  )     +     \"     \"  )     +     ( postfix )  ;", "}", "METHOD_END"], "methodName": ["getProgress"], "fileName": "org.gradle.internal.progress.SimpleProgressFormatter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current )     =  =     ( total )  )     {", "throw   new   IllegalStateException (  (  \" Cannot   increment   beyond   the   total   of :     \"     +     ( total )  )  )  ;", "}", "( current )  +  +  ;", "return   get (  )  ;", "}", "METHOD_END"], "methodName": ["incrementAndGetProgress"], "fileName": "org.gradle.internal.progress.SimpleProgressFormatter"}, {"methodBody": ["METHOD_START", "{", "file . delete (  )  ;", "}", "METHOD_END"], "methodName": ["deleteFileQuietly"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "GFileUtils . parentMkdirs ( destination )  ;", "File   inProgressMarkerFile    =    getInProgressMarkerFile ( destination )  ;", "GFileUtils . touch ( inProgressMarkerFile )  ;", "try    {", "FileUtils . deleteQuietly ( destination )  ;", "action . execute ( destination )  ;", "}    catch    ( Throwable   t )     {", "FileUtils . deleteQuietly ( destination )  ;", "throw   UncheckedException . throwAsUncheckedException ( t )  ;", "}    finally    {", ". deleteFileQuietly ( inProgressMarkerFile )  ;", "}", "}", "METHOD_END"], "methodName": ["doAdd"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "File   destination    =    getFile ( path )  ;", "doAdd ( destination ,    action )  ;", "return   entryAt ( path )  ;", "}", "METHOD_END"], "methodName": ["doAdd"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   entryAt ( RelativePathUtil . relativePath ( baseDir ,    file )  )  ;", "}", "METHOD_END"], "methodName": ["entryAt"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultLocallyAvailableResource ( getFile ( path )  )  ;", "}", "METHOD_END"], "methodName": ["entryAt"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   new   SingleIncludePatternFileTree ( baseDir ,    pattern )  ;", "}", "METHOD_END"], "methodName": ["findFiles"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   baseDir ;", "}", "METHOD_END"], "methodName": ["getBaseDir"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( baseDir ,    path )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "File   file    =    getFile ( path )  ;", "File   markerFile    =    getInProgressMarkerFile ( file )  ;", "if    ( markerFile . exists (  )  )     {", ". deleteFileQuietly ( file )  ;", ". deleteFileQuietly ( markerFile )  ;", "}", "return   file ;", "}", "METHOD_END"], "methodName": ["getFileWhileCleaningInProgress"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( file . getParent (  )  ,     (  ( file . getName (  )  )     +     ( DefaultPathKeyFileStore . IN _ PROGRESS _ MARKER _ FILE _ SUFFIX )  )  )  ;", "}", "METHOD_END"], "methodName": ["getInProgressMarkerFile"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   getInProgressMarkerFile ( file )  . exists (  )  ;", "}", "METHOD_END"], "methodName": ["isInProgressFile"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   FileUtils . hasExtension ( file ,    DefaultPathKeyFileStore . IN _ PROGRESS _ MARKER _ FILE _ SUFFIX )  ;", "}", "METHOD_END"], "methodName": ["isInProgressMarkerFile"], "fileName": "org.gradle.internal.resource.local.DefaultPathKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "final   File   tempFile    =    getTempFile (  )  ;", "addAction . execute ( tempFile )  ;", "final   String   gKey    =    toPath ( key ,    getChecksum ( tempFile )  )  ;", "return   delegate . move ( gKey ,    tempFile )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "return   HashUtil . createHash ( contentFile ,     \" SHA 1  \"  )  . asHexString (  )  ;", "}", "METHOD_END"], "methodName": ["getChecksum"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "return   temporaryFileProvider . createTemporaryFile (  \" filestore \"  ,     \" bin \"  )  ;", "}", "METHOD_END"], "methodName": ["getTempFile"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "return   delegate . move ( toPath ( key ,    getChecksum ( source )  )  ,    source )  ;", "}", "METHOD_END"], "methodName": ["move"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "return   delegate . search ( toPath ( key ,     \"  *  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["search"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "String   group    =    grouper . transform ( key )  ;", "String   name    =    namer . transform ( key )  ;", "return    (  (  ( group    +     \"  /  \"  )     +    checksumPart )     +     \"  /  \"  )     +    name ;", "}", "METHOD_END"], "methodName": ["toPath"], "fileName": "org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore"}, {"methodBody": ["METHOD_START", "{", "return   delegate . add ( normalizePath ( key )  ,    addAction )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.internal.resource.local.PathNormalisingKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   delegate . move ( normalizePath ( key )  ,    source )  ;", "}", "METHOD_END"], "methodName": ["move"], "fileName": "org.gradle.internal.resource.local.PathNormalisingKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   path . replaceAll (  \"  [  ^  \\  \\ d \\  \\ w \\  \\  .  /  ]  \"  ,     \"  _  \"  )  ;", "}", "METHOD_END"], "methodName": ["normalizePath"], "fileName": "org.gradle.internal.resource.local.PathNormalisingKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   path . replaceAll (  \"  [  ^  \\  \\ d \\  \\ w \\  \\  .  \\  \\  *  /  ]  \"  ,     \"  _  \"  )  ;", "}", "METHOD_END"], "methodName": ["normalizeSearchPath"], "fileName": "org.gradle.internal.resource.local.PathNormalisingKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "return   delegate . search ( normalizeSearchPath ( key )  )  ;", "}", "METHOD_END"], "methodName": ["search"], "fileName": "org.gradle.internal.resource.local.PathNormalisingKeyFileStore"}, {"methodBody": ["METHOD_START", "{", "registration . addProvider ( new   BuildScanConfigServices (  )  )  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.internal.scan.BuildScanServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildScanBuildStartedTime ( buildStartedTime )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanBuildStartedTime"], "fileName": "org.gradle.internal.scan.BuildScanServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildScanClock ( clock )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanClock"], "fileName": "org.gradle.internal.scan.BuildScanServices"}, {"methodBody": ["METHOD_START", "{", "return    ( pluginVersion . compareTo ( BuildScanConfigManager . FIRST _ VERSION _ AWARE _ OF _ UNSUPPORTED )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["isPluginAwareOfUnsupported"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigManager"}, {"methodBody": ["METHOD_START", "{", "listenerManager . addListener ( new   BuildAdapter (  )     {", "@ Override", "public   void   projectsEvaluated ( Gradle   gradle )     {", "if    (  (  ( gradle . getParent (  )  )     =  =    null )     &  &     (  !  ( collected )  )  )     {", ". LOGGER . warn (  (  (  (  \" Build   scan   cannot   be   created   because   the   build   scan   plugin   was   not   applied .  \\ n \"     +     \" For   more   information   on   how   to   apply   the   build   scan   plugin ,    please   visit    \"  )     +     (  . HELP _ LINK )  )     +     \"  .  \"  )  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["warnIfBuildScanPluginNotApplied"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigManager"}, {"methodBody": ["METHOD_START", "{", "return   new   Factory < BuildScanConfig . Attributes >  (  )     {", "@ Override", "public   BuildScanConfig . Attributes   create (  )     {", "VcsResolver   vcsResolver    =     (  ( GradleInternal )     ( gradle )  )  . getServices (  )  . get ( VcsResolver . class )  ;", "final   boolean   hasRules    =    vcsResolver . hasRules (  )  ;", "return   new   BuildScanConfig . Attributes (  )     {", "@ Override", "public   boolean   isRootProjectHasVcsMappings (  )     {", "return   hasRules ;", "}", "}  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createBuildScanConfigAttributes"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildScanConfigManager ( startParameter ,    listenerManager ,    compatibility ,    serviceRegistry . getFactory ( BuildScanConfig . Attributes . class )  )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanConfigManager"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildScanPluginCompatibility (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanPluginCompatibility"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildScanRequestLegacyBridge ( compatibilityEnforcer )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanRequest"], "fileName": "org.gradle.internal.scan.config.BuildScanConfigServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( pluginVersion . compareTo ( BuildScanPluginCompatibility . MIN _ SUPPORTED _ VERSION )  )     <     0  )     {", "return   BuildScanPluginCompatibility . UNSUPPORTED _ PLUGIN _ VERSION _ MESSAGE ;", "}", "if    (  (  ( pluginVersion . compareTo ( BuildScanPluginCompatibility . MIN _ VERSION _ AWARE _ OF _ VCS _ MAPPINGS )  )     <     0  )     &  &     ( attributes . isRootProjectHasVcsMappings (  )  )  )     {", "return   BuildScanPluginCompatibility . UNSUPPORTED _ VCS _ MAPPINGS _ MESSAGE ;", "}", "if    ( Boolean . getBoolean ( BuildScanPluginCompatibility . UNSUPPORTED _ TOGGLE )  )     {", "return   BuildScanPluginCompatibility . UNSUPPORTED _ TOGGLE _ MESSAGE ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["unsupportedReason"], "fileName": "org.gradle.internal.scan.config.BuildScanPluginCompatibility"}, {"methodBody": ["METHOD_START", "{", "return   new   UnsupportedBuildScanPluginVersionException ( BuildScanPluginCompatibility . UNSUPPORTED _ PLUGIN _ VERSION _ MESSAGE )  ;", "}", "METHOD_END"], "methodName": ["unsupportedVersionException"], "fileName": "org.gradle.internal.scan.config.BuildScanPluginCompatibility"}, {"methodBody": ["METHOD_START", "{", "PersistentStateCache < UniqueId >    store    =    store ( params )  ;", "return   store . maybeUpdate ( new   PersistentStateCache . UpdateAction < UniqueId >  (  )     {", "@ Override", "public   UniqueId   update ( UniqueId   oldValue )     {", "if    ( oldValue    =  =    null )     {", "return   generator . create (  )  ;", "} else    {", "return   oldValue ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.internal.scopeids.DefaultPersistentScopeIdLoader"}, {"methodBody": ["METHOD_START", "{", "File   file    =    cacheScopeMapping . getBaseDirectory ( params . cacheScopeMarker ,    params . fileName ,    SharedCache )  ;", "return   storeFactory . create ( file ,    params . description )  ;", "}", "METHOD_END"], "methodName": ["store"], "fileName": "org.gradle.internal.scopeids.DefaultPersistentScopeIdLoader"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["userScopeCacheScopeMarker"], "fileName": "org.gradle.internal.scopeids.DefaultPersistentScopeIdLoader"}, {"methodBody": ["METHOD_START", "{", "return   projectCacheDir . getDir (  )  ;", "}", "METHOD_END"], "methodName": ["workspaceScopeCacheScopeMarker"], "fileName": "org.gradle.internal.scopeids.DefaultPersistentScopeIdLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   FileIntegrityViolationSuppressingPersistentStateCacheDecorator < UniqueId >  ( new   SimpleStateCache < UniqueId >  ( file ,    new   OnDemandFileAccess ( file ,    description ,    fileLockManager )  ,    UniqueIdSerializer . INSTANCE ,    chmod )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.internal.scopeids.PersistentScopeIdStoreFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPersistentScopeIdLoader ( projectCacheDir ,    cacheScopeMapping ,    persistentScopeIdStoreFactory ,    UniqueId . factory (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPersistentScopeIdLoader"], "fileName": "org.gradle.internal.scopeids.ScopeIdsServices"}, {"methodBody": ["METHOD_START", "{", "return   new   PersistentScopeIdStoreFactory ( chmod ,    fileLockManager )  ;", "}", "METHOD_END"], "methodName": ["createPersistentScopeIdStoreFactory"], "fileName": "org.gradle.internal.scopeids.ScopeIdsServices"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.internal.scopeids.id.ScopeId"}, {"methodBody": ["METHOD_START", "{", "return   new   DocumentationRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["createDocumentationRegistry"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExecActionFactory ( fileResolver )  ;", "}", "METHOD_END"], "methodName": ["createExecFactory"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExecutorFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createExecutorFactory"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileLockContentionHandler ( executorFactory ,    inetAddressFactory )  ;", "}", "METHOD_END"], "methodName": ["createFileLockContentionHandler"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileLockManager ( new   DefaultProcessMetaDataProvider ( processEnvironment )  ,    fileLockContentionHandler )  ;", "}", "METHOD_END"], "methodName": ["createFileLockManager"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileLookup ( fileSystem ,    patternSetFactory )  ;", "}", "METHOD_END"], "methodName": ["createFileLookup"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   lookup . getFileResolver (  )  ;", "}", "METHOD_END"], "methodName": ["createFileResolver"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   messagingServices . get ( InetAddressFactory . class )  ;", "}", "METHOD_END"], "methodName": ["createInetAddressFactory"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CachingJvmVersionDetector ( new   DefaultJvmVersionDetector ( execHandleFactory )  )  ;", "}", "METHOD_END"], "methodName": ["createJvmVersionDetector"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultListenerManager (  )  ;", "}", "METHOD_END"], "methodName": ["createListenerManager"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   MessagingServices (  )  ;", "}", "METHOD_END"], "methodName": ["createMessagingServices"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   PatternSets . getPatternSetFactory ( patternSpecFactory )  ;", "}", "METHOD_END"], "methodName": ["createPatternSetFactory"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   PatternSpecFactory . INSTANCE ;", "}", "METHOD_END"], "methodName": ["createPatternSpecFactory"], "fileName": "org.gradle.internal.service.scopes.BasicGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "registries . stop (  )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServiceRegistryFactory"}, {"methodBody": ["METHOD_START", "{", "if    ( domainObject   instanceof   GradleInternal )     {", "Gradles   gradleServices    =    new   Gradles ( services ,     (  ( GradleInternal )     ( domainObject )  )  )  ;", "registries . add ( gradleServices )  ;", "return   gradleServices ;", "}", "if    ( domainObject   instanceof   SettingsInternal )     {", "Settingss   settingsServices    =    new   Settingss ( services ,     (  ( SettingsInternal )     ( domainObject )  )  )  ;", "registries . add ( settingsServices )  ;", "return   settingsServices ;", "}", "throw   new   IllegalArgumentException ( String . format (  \" Cannot   create   services   for   unknown   domain   object   of   type    % s .  \"  ,    domainObject . getClass (  )  . getSimpleName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createFor"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServiceRegistryFactory"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultActorFactory ( get ( ExecutorFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["createActorFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultAuthenticationSchemeRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["createAuthenticationSchemeRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildConfigurer ( projectConfigurer )  ;", "}", "METHOD_END"], "methodName": ["createBuildConfigurer"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   NotifyingBuildLoader ( new   ProjectPropertySettingBuildLoader ( propertiesLoader ,    new   InstantiatingBuildLoader ( projectFactory )  )  ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createBuildLoader"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildOperationLoggerFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationLoggerFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildScanUserInputHandler ( userInputHandler )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanUserInputHandler"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "ToolingModelBuilderRegistry   registry    =    new   DefaultToolingModelBuilderRegistry (  )  ;", "for    ( ToolingModelBuilderRegistryAction   registryAction    :    registryActions )     {", "registryAction . execute ( registry )  ;", "}", "return   registry ;", "}", "METHOD_END"], "methodName": ["createBuildScopedToolingModelBuilders"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClassLoaderScopeRegistry ( classLoaderRegistry ,    classLoaderCache )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderScopeRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "ModuleRegistry   moduleRegistry    =    get ( ModuleRegistry . class )  ;", "return   new   DefaultClassPathRegistry ( new   DefaultClassPathProvider ( moduleRegistry )  ,    new   DependencyClassPathProvider ( moduleRegistry ,    get ( PluginModuleRegistry . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createClassPathRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultComponentTypeRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["createComponentTypeRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildScopeServices . DependencyMetaDataProviderImpl (  )  ;", "}", "METHOD_END"], "methodName": ["createDependencyMetaDataProvider"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "CacheValidator   scriptCacheInvalidator    =    new   CacheValidator (  )     {", "public   boolean   isValid (  )     {", "return    !  ( startParame . isRecompileScripts (  )  )  ;", "}", "}  ;", "return   new   FileCacheBackedScriptClassCompiler ( cacheRepository ,    scriptCacheInvalidator ,    new   DefaultScriptCompilationHandler ( classLoaderCache ,    importsReader )  ,    progressLoggerFactory ,    hasher ,    classLoaderCache ,    classLoaderHierarchyHasher )  ;", "}", "METHOD_END"], "methodName": ["createFileCacheBackedScriptClassCompiler"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultGradlePropertiesLoader ( get ( StartParameter . class )  )  ;", "}", "METHOD_END"], "methodName": ["createGradlePropertiesLoader"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   AnnotationProcessingTaskFactory ( taskClassInfoStore ,    new   TaskFactory ( get ( ClassGenerator . class )  )  )  ;", "}", "METHOD_END"], "methodName": ["createITaskFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   InitScriptHandler ( new   DefaultInitScriptProcessor ( scriptPluginFactory ,    scriptHandlerFactory )  ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createInitScriptHandler"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultIsolatedAntBuilder ( classPathRegistry ,    classLoaderFactory ,    moduleRegistry )  ;", "}", "METHOD_END"], "methodName": ["createIsolatedAntBuilder"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   listenerManager . createChild (  )  ;", "}", "METHOD_END"], "methodName": ["createListenerManager"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   PluginInspector ( modelRuleSourceDetector )  ;", "}", "METHOD_END"], "methodName": ["createPluginInspector"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPluginRegistry ( pluginInspector ,    scopeRegistry . getCoreAndPluginsScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPluginRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProfileEventAdapter ( get ( BuildStartedTime . class )  ,    get ( Clock . class )  ,    get ( ListenerManager . class )  . getBroadcaster ( ProfileListener . class )  )  ;", "}", "METHOD_END"], "methodName": ["createProfileEventAdapter"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectAccessListener (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectAccessListener"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskPathProjectEvaluator ( cancellationToken )  ;", "}", "METHOD_END"], "methodName": ["createProjectConfigurer"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "ConfigureActionsProjectEvaluator   withActionsEvaluator    =    new   ConfigureActionsProjectEvaluator ( PluginsProjectConfigureActions . from ( cachingServiceLocator )  ,    new   BuildScriptProcessor ( scriptPluginFactory )  ,    new   DelayedConfigurationActions (  )  )  ;", "return   new   LifecycleProjectEvaluator ( buildOperationExecutor ,    withActionsEvaluator )  ;", "}", "METHOD_END"], "methodName": ["createProjectEvaluator"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectFactory ( instantiator ,    projectRegistry )  ;", "}", "METHOD_END"], "methodName": ["createProjectFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectRegistry < ProjectInternal >  (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectTaskLister (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectTaskLister"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPropertyMetadataStore ( annotationHandlers )  ;", "}", "METHOD_END"], "methodName": ["createPropertyMetadataStore"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPropertyWalker ( propertyMetadataStore )  ;", "}", "METHOD_END"], "methodName": ["createPropertyWalker"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptClassPathResolver ( initializers )  ;", "}", "METHOD_END"], "methodName": ["createScriptClassPathResolver"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "ScriptExecutionListener   scriptExecutionListener    =    listenerManager . getBroadcaster ( ScriptExecutionListener . class )  ;", "return   new   DefaultScriptCompilerFactory ( new   InMemoryCachingScriptClassCompiler ( cache ,    scriptCompiler )  ,    new   DefaultScriptRunnerFactory ( scriptExecutionListener ,    DirectInstantiator . INSTANCE )  )  ;", "}", "METHOD_END"], "methodName": ["createScriptCompileFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptHandlerFactory ( get ( DependencyManagementServices . class )  ,    get ( FileResolver . class )  ,    get ( DependencyMetaDataProvider . class )  ,    get ( ScriptClassPathResolver . class )  )  ;", "}", "METHOD_END"], "methodName": ["createScriptHandlerFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "DefaultScriptPluginFactory   defaultScriptPluginFactory    =    defaultScriptPluginFactory (  )  ;", "ScriptPluginFactorySelector . ProviderInstantiator   instantiator    =    ScriptPluginFactorySelector . defaultProviderInstantiatorFor ( instantiatorFactory . inject ( this )  )  ;", "ScriptPluginFactorySelector   scriptPluginFactorySelector    =    new   ScriptPluginFactorySelector ( defaultScriptPluginFactory ,    instantiator ,    bOperationExecutor )  ;", "defaultScriptPluginFactory . setScriptPluginFactory ( scriptPluginFactorySelector )  ;", "return   scriptPluginFactorySelector ;", "}", "METHOD_END"], "methodName": ["createScriptPluginFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildScopeServiceRegistryFactory ( services )  ;", "}", "METHOD_END"], "methodName": ["createServiceRegistryFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultSettingsLoaderFactory ( new   DefaultSettingsFinder ( buildLayoutFactory )  ,    settingsProcessor ,    new   BuildSourceBuilder ( nestedBuildFactory ,    classLoaderScopeRegistry . getCoreAndPluginsScope (  )  ,    fileLockManager ,    buildOperationExecutor ,    cachedClasspathTransformer ,    new   BuildSrcBuildListenerFactory ( PluginsProjectConfigureActions . of ( BuildSrcProjectConfigurationAction . class ,    cachingServiceLocator )  )  )  ,    nestedBuildFactory ,    includedBuildRegistry )  ;", "}", "METHOD_END"], "methodName": ["createSettingsLoaderFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildOperationSettingsProcessor ( new   RootBuildCacheControllerSettingsProcessor ( new   SettingsEvaluatedCallbackFiringSettingsProcessor ( new   PropertiesLoadingSettingsProcessor ( new   ScriptEvaluatingSettingsProcessor ( scriptPluginFactory ,    new   SettingsFactory ( instantiator ,    serviceRegistryFactory ,    scriptHandlerFactory )  ,    propertiesLoader )  ,    propertiesLoader )  )  )  ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createSettingsProcessor"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskClassInfoStore (  )  ;", "}", "METHOD_END"], "methodName": ["createTaskClassInfoStore"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskExecutionStatisticsEventAdapter ( listenerManager . getBroadcaster ( TaskExecutionStatisticsListener . class )  )  ;", "}", "METHOD_END"], "methodName": ["createTaskExecutionStatisticsEventAdapter"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskStatistics (  )  ;", "}", "METHOD_END"], "methodName": ["createTaskStatistics"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( startParameter . isInteractive (  )  )  )     {", "return   new   NonInteractiveUserInputHandler (  )  ;", "}", "return   new   DefaultUserInputHandler ( outputEventListenerManager . getBroadcaster (  )  ,    new   DefaultUserInputReader (  )  )  ;", "}", "METHOD_END"], "methodName": ["createUserInputHandler"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptPluginFactory ( get ( ScriptCompilerFactory . class )  ,    getFactory ( LoggingManagerInternal . class )  ,    get ( Instantiator . class )  ,    get ( ScriptHandlerFactory . class )  ,    get ( PluginRequestApplicator . class )  ,    get ( FileLookup . class )  ,    get ( DirectoryFileTreeFactory . class )  ,    get ( DocumentationRegistry . class )  ,    get ( ModelRuleSourceDetector . class )  ,    get ( ProviderFactory . class )  ,    get ( TextResourceLoader . class )  ,    get ( StreamHasher . class )  ,    get ( FileHasher . class )  ,    get ( ExecFactory . class )  ,    get ( AutoAppliedPluginHandler . class )  )  ;", "}", "METHOD_END"], "methodName": ["defaultScriptPluginFactory"], "fileName": "org.gradle.internal.service.scopes.BuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultAsyncWorkTracker ( projectLeaseRegistry )  ;", "}", "METHOD_END"], "methodName": ["createAsyncWorkTracker"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "long   currentTime    =    clock . getCurrentTime (  )  ;", "return   tartedTime . startingAt ( Math . min ( currentTime ,    buildRequestMetaData . getStartTime (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuildStartedTime"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "BuildLayout   buildLayout    =    buildLayoutFactory . getLayoutFor ( new   BuildLayoutConfiguration ( startParameter )  )  ;", "File   cacheDir    =     (  ( startParameter . getProjectCacheDir (  )  )     !  =    null )     ?    startParameter . getProjectCacheDir (  )     :    new   File ( buildLayout . getRootDirectory (  )  ,     \"  \"  )  ;", "return   new   ProjectCacheDir ( cacheDir )  ;", "}", "METHOD_END"], "methodName": ["createCacheLayout"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClasspathSnapshotter ( resourceSnapshotterCacheService ,    directoryFileTreeFactory ,    fileSystemSnapshotter ,    stringInterner )  ;", "}", "METHOD_END"], "methodName": ["createClasspathSnapshotter"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CleanupActionFactory ( buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createCleanupActionFactory"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCompileClasspathSnapshotter ( resourceSnapshotterCacheService ,    directoryFileTreeFactory ,    fileSystemSnapshotter ,    stringInterner )  ;", "}", "METHOD_END"], "methodName": ["createCompileClasspathSnapshotter"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "File   cacheDir    =    cacheScopeMapping . getBaseDirectory ( projectCacheDir . getDir (  )  ,     \" fileHashes \"  ,    CachePerVersion )  ;", "return   new   CrossBuildFileHashCache ( cacheDir ,    cacheRepository ,    inMemoryCacheDecoratorFactory )  ;", "}", "METHOD_END"], "methodName": ["createCrossBuildFileHashCache"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildOperationCrossProjectConfigurator ( buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createCrossProjectConfigurator"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDeploymentRegistry ( pendingChangesManager ,    buildOperationExecutor ,    objectFactory )  ;", "}", "METHOD_END"], "methodName": ["createDeploymentRegistry"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   FeaturePreviews (  )  ;", "}", "METHOD_END"], "methodName": ["createExperimentalFeatures"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CachingFileHasher ( new   DefaultFileHasher ( streamHasher )  ,    cacheAccess ,    stringInterner ,    fileTimeStampInspector ,     \" fileHashes \"  ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["createFileSnapshotter"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileSystemSnapshotter ( hasher ,    stringInterner ,    fileSystem ,    directoryFileTreeFactory ,    fileSystemMirror )  ;", "}", "METHOD_END"], "methodName": ["createFileSystemSnapshotter"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "File   workDir    =    cacheScopeMapping . getBaseDirectory ( projectCacheDir . getDir (  )  ,     \" fileChanges \"  ,    CachePerVersion )  ;", "copeFileTimeStampInspector   timeStampInspector    =    new   copeFileTimeStampInspector ( workDir )  ;", "listenerManager . addListener ( timeStampInspector )  ;", "return   timeStampInspector ;", "}", "METHOD_END"], "methodName": ["createFileTimeStampInspector"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "String   gradleVersion    =    GradleVersion . current (  )  . getVersion (  )  ;", "return   new   DefaultGeneratedGradleJarCache ( cacheRepository ,    gradleVersion )  ;", "}", "METHOD_END"], "methodName": ["createGeneratedGradleJarCache"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultGenericFileCollectionSnapshotter ( stringInterner ,    directoryFileTreeFactory ,    fileSystemSnapshotter )  ;", "}", "METHOD_END"], "methodName": ["createGenericFileCollectionSnapshotter"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultImmutableAttributesFactory ( isolatableFactory ,    NamedObjectInstantiator . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createImmutableAttributesFactory"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   parent . createChild (  )  ;", "}", "METHOD_END"], "methodName": ["createListenerManager"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   PendingChangesManager ( listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createPendingChangesManager"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "PersistentIndexedCache < HashCode ,    HashCode >    resourceHashesCache    =    store . createCache (  \" resourceHashesCache \"  ,    HashCode . class ,    new   HashCodeSerializer (  )  ,     8  0  0  0  0  0  ,    true )  ;", "return   new   ResourceSnapshotterCach ( resourceHashesCache )  ;", "}", "METHOD_END"], "methodName": ["createResourceSnapshotterCacheService"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptSourceHasher ( fileHasher ,    contentHasherFactory )  ;", "}", "METHOD_END"], "methodName": ["createScriptSourceHasher"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   persistentScopeIdLoader . getUser (  )  ;", "}", "METHOD_END"], "methodName": ["createUserScopeId"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   persistentScopeIdLoader . getWorkspace (  )  ;", "}", "METHOD_END"], "methodName": ["createWorkspaceScopeId"], "fileName": "org.gradle.internal.service.scopes.BuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "ExceptionAnalyser   exceptionAnalyser    =    new   MultipleBuildFailuresExceptionAnalyser ( new   DefaultExceptionAnalyser ( listenerManager )  )  ;", "if    (  ( loggingConfiguration . getShowStacktrace (  )  )     !  =     ( ShowStacktrace . ALWAYS _ FULL )  )     {", "exceptionAnalyser    =    new   StackTraceSanitizingExceptionAnalyser ( exceptionAnalyser )  ;", "}", "return   exceptionAnalyser ;", "}", "METHOD_END"], "methodName": ["createExceptionAnalyser"], "fileName": "org.gradle.internal.service.scopes.BuildTreeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectStateAccess (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectStateAccess"], "fileName": "org.gradle.internal.service.scopes.BuildTreeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DelegatingBuildOperationExecutor ( services . get ( BuildOperationExecutor . class )  )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationExecutor"], "fileName": "org.gradle.internal.service.scopes.CrossBuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   buildOperationListenerManager ;", "}", "METHOD_END"], "methodName": ["createBuildOperationListenerManager"], "fileName": "org.gradle.internal.service.scopes.CrossBuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   buildOperationNotificationBridge . getRegistrar (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationNotificationListenerRegistrar"], "fileName": "org.gradle.internal.service.scopes.CrossBuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   services . get ( GradleLauncherFactory . class )  ;", "}", "METHOD_END"], "methodName": ["createGradleLauncherFactory"], "fileName": "org.gradle.internal.service.scopes.CrossBuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   StopShieldingWorkerLeaseService ( services . get ( WorkerLeaseService . class )  )  ;", "}", "METHOD_END"], "methodName": ["createWorkerLeaseService"], "fileName": "org.gradle.internal.service.scopes.CrossBuildSessionScopeServices"}, {"methodBody": ["METHOD_START", "{", "final   List < PluginServiceRegistry >    pluginServiceFactories    =    new   DefaultServiceLocator ( classLoaderRegistry . getRuntimeClassLoader (  )  ,    classLoaderRegistry . getPluginsClassLoader (  )  )  . getAll ( PluginServiceRegistry . class )  ;", "for    ( PluginServiceRegistry   pluginServiceRegistry    :    pluginServiceFactories )     {", "registration . add ( PluginServiceRegistry . class ,    pluginServiceRegistry )  ;", "pluginServiceRegistry . registerGlobal ( registration )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BuildLayoutFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildLayoutFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildOperationIdFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationIdProvider"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildOperationListenerManager (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationService"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "BuildProgressLogger   buildProgressLogger    =    new   BuildProgressLogger ( progressLoggerFactory )  ;", "listenerManager . addListener ( new   BuildProgressFil ( buildProgressLogger )  )  ;", "listenerManager . useLogger ( new   ProjectEvaluationLogger ( progressLoggerFactory )  )  ;", "return   buildProgressLogger ;", "}", "METHOD_END"], "methodName": ["createBuildProgressLogger"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCacheFactory ( fileLockManager ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createCacheFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   AsmBackedClassGenerator (  )  ;", "}", "METHOD_END"], "methodName": ["createClassGenerator"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "if    ( GradleRuntimeShadedJarDetector . isLoadedFrom ( getClass (  )  )  )     {", "return   new   FlatClassLoaderRegistry ( getClass (  )  . getClassLoader (  )  )  ;", "}", "return   new   DefaultClassLoaderRegistry ( classPathRegistry ,    legacyTypesSupport )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClassPathRegistry ( new   DefaultClassPathProvider ( moduleRegistry )  ,    new   DynamicModulesClassPathProvider ( moduleRegistry ,    pluginModuleRegistry )  )  ;", "}", "METHOD_END"], "methodName": ["createClassPathRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   Time . clock (  )  ;", "}", "METHOD_END"], "methodName": ["createClock"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCommandLineConverter (  )  ;", "}", "METHOD_END"], "methodName": ["createCommandLine2StartParameterConverter"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CrossBuildInMemoryCacheFactory ( listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createCrossBuildInMemoryCacheFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   CurrentBuildOperationRef . instance (  )  ;", "}", "METHOD_END"], "methodName": ["createCurrentBuildOperationRef"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   CurrentGradleInstallation . locate (  )  ;", "}", "METHOD_END"], "methodName": ["createCurrentGradleInstallation"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultDirectoryFileTreeFactory ( patternSetFactory ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["createDirectoryFileTreeFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileCollectionFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createFileCollectionFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileWatcherFactory ( executorFactory ,    fileSystem )  ;", "}", "METHOD_END"], "methodName": ["createFileWatcherFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   environment ;", "}", "METHOD_END"], "methodName": ["createGradleBuildEnvironment"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultGradleUserHomeScopeServiceRegistry ( globalServices ,    new   GradleUserHomeScopeServices ( globalServices )  )  ;", "}", "METHOD_END"], "methodName": ["createGradleUserHomeScopeServiceRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultContentHasherFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createHasherFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultImportsReader (  )  ;", "}", "METHOD_END"], "methodName": ["createImportsReader"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   InMemoryCacheDecoratorFactory ( environment . isLongLivingProcess (  )  ,    cacheFactory )  ;", "}", "METHOD_END"], "methodName": ["createInMemoryTaskArtifactCache"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   instantiatorFactory . decorate (  )  ;", "}", "METHOD_END"], "methodName": ["createInstantiator"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultInstantiatorFactory ( classGenerator ,    cacheFactory )  ;", "}", "METHOD_END"], "methodName": ["createInstantiatorFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultJdkToolsInitializer ( new   DefaultClassLoaderFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["createJdkToolsInitializer"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultJvmMemoryInfo (  )  ;", "}", "METHOD_END"], "methodName": ["createJvmMemoryInfo"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultLegacyTypesSupport (  )  ;", "}", "METHOD_END"], "methodName": ["createLegacyTypesSupport"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   loggingManagerFactory . create (  )  ;", "}", "METHOD_END"], "methodName": ["createLoggingManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ManagedProxyFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createManagedProxyFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultParallelismConfigurationManager ( listenerManager )  ;", "}", "METHOD_END"], "methodName": ["createMaxWorkersManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultMemoryManager ( osMemoryInfo ,    jvmMemoryInfo ,    listenerManager ,    executorFactory )  ;", "}", "METHOD_END"], "methodName": ["createMemoryManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   messagingServices . get ( MessagingServer . class )  ;", "}", "METHOD_END"], "methodName": ["createMessagingServer"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "List < MethodModelRuleExtractor >    coreExtractors    =    MethodModelRuleExtractors . coreExtractors ( modelSchemaStore )  ;", "return   new   model . internal . inspect . ModelRuleExtractor ( Iterables . concat ( coreExtractors ,    extractors )  ,    managedProxyFactory ,    modelSchemaStore ,    structBindingsStore )  ;", "}", "METHOD_END"], "methodName": ["createModelRuleInspector"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelRuleSourceDetector (  )  ;", "}", "METHOD_END"], "methodName": ["createModelRuleSourceDetector"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ModelSchemaAspectExtractor ( strategies )  ;", "}", "METHOD_END"], "methodName": ["createModelSchemaAspectExtractor"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   DefaultModelSchemaExtractor . withDefaultStrategies ( strategies ,    aspectExtractor )  ;", "}", "METHOD_END"], "methodName": ["createModelSchemaExtractor"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModelSchemaStore ( modelSchemaExtractor )  ;", "}", "METHOD_END"], "methodName": ["createModelSchemaStore"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModuleRegistry ( additionalModuleClassPath ,    currentGradleInstallation . getInstallation (  )  )  ;", "}", "METHOD_END"], "methodName": ["createModuleRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultObjectFactory ( instantiatorFactory . injectAndDecorate ( services )  ,    NamedObjectInstantiator . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createObjectFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultOsMemoryInfo (  )  ;", "}", "METHOD_END"], "methodName": ["createOsMemoryInfo"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CachingPatternSpecFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createPatternSpecFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPluginModuleRegistry ( moduleRegistry )  ;", "}", "METHOD_END"], "methodName": ["createPluginModuleRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   CachingServiceLocator . of ( new   DefaultServiceLocator ( registry . getPluginsClassLoader (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createPluginsServiceLocator"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProviderFactory (  )  ;", "}", "METHOD_END"], "methodName": ["createProviderFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultStreamHasher ( hasherFactory )  ;", "}", "METHOD_END"], "methodName": ["createStreamHasher"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   StringInterner (  )  ;", "}", "METHOD_END"], "methodName": ["createStringInterner"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultStructBindingsStore ( schemaStore )  ;", "}", "METHOD_END"], "methodName": ["createStructBindingsStore"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskInputsListener (  )  ;", "}", "METHOD_END"], "methodName": ["createTaskInputsListener"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TmpDirTemporaryFileProvider (  )  ;", "}", "METHOD_END"], "methodName": ["createTemporaryFileProvider"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultResourceLockCoordinationService (  )  ;", "}", "METHOD_END"], "methodName": ["createWorkerLeaseCoordinationService"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   registry ( true )  ;", "}", "METHOD_END"], "methodName": ["longLivingProcessRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( CacheFactory . class )  ,    instanceOf ( DefaultCacheFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesACacheFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ClassGenerator . class )  ,    instanceOf ( AsmBackedClassGenerator . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAClassGenerator"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ClassLoaderRegistry . class )  ,    instanceOf ( DefaultClassLoaderRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAClassLoaderRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ClassPathRegistry . class )  ,    instanceOf ( DefaultClassPathRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAClassPathRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( CurrentGradleInstallation . class )  ,    instanceOf ( CurrentGradleInstallation . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesACurrentGradleInstallation"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( DocumentationRegistry . class )  ,    instanceOf ( DocumentationRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesADocumentationRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( FileLockManager . class )  ,    instanceOf ( DefaultFileLockManager . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAFileLockManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( FileLookup . class )  ,    instanceOf ( DefaultFileLookup . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAFileLookup"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( FileResolver . class )  ,    instanceOf ( IdentityFileResolver . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAFileResolver"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( FileSystem . class )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["providesAFileSystem"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( JvmMemoryInfo . class )  ,    instanceOf ( DefaultJvmMemoryInfo . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAJvmMemoryInfo"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ListenerManager . class )  ,    instanceOf ( DefaultListenerManager . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAListenerManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . getFactory ( LoggingManagerInternal . class )  ,    instanceOf ( DefaultLoggingManagerFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesALoggingManagerFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( MemoryManager . class )  ,    instanceOf ( DefaultMemoryManager . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAMemoryManager"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( MessagingServer . class )  ,    instanceOf ( MessagingServer . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAMessagingServer"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ModuleRegistry . class )  ,    instanceOf ( DefaultModuleRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAModuleRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( PluginModuleRegistry . class )  ,    instanceOf ( DefaultPluginModuleRegistry . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAPluginModuleRegistry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ProcessEnvironment . class )  ,    notNullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["providesAProcessEnvironment"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ProgressLoggerFactory . class )  ,    instanceOf ( DefaultProgressLoggerFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAProgressLoggerFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( ExecutorFactory . class )  ,    instanceOf ( DefaultExecutorFactory . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAnExecutorFactory"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( Instantiator . class )  ,    instanceOf ( ClassGeneratorBackedInstantiator . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAnInstantiator"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( OsMemoryInfo . class )  ,    instanceOf ( DefaultOsMemoryInfo . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesAnOsMemoryInfo"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( registry (  )  . get ( CommandLineConverter . class )  ,    instanceOf ( DefaultCommandLineConverter . class )  )  ;", "}", "METHOD_END"], "methodName": ["providesCommandLineArgsConverter"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "return   registry ( false )  ;", "}", "METHOD_END"], "methodName": ["registry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultServiceRegistry ( LoggingServiceRegistry . newEmbeddableLogging (  )  ,    NativeServicesTestFixture . getInstance (  )  )  . addProvider ( new   GlobalScopeServices ( longLiving )  )  ;", "}", "METHOD_END"], "methodName": ["registry"], "fileName": "org.gradle.internal.service.scopes.GlobalScopeServicesTest"}, {"methodBody": ["METHOD_START", "{", "List < BuildConfigurationAction >    taskSelectionActions    =    new   LinkedList < BuildConfigurationAction >  (  )  ;", "taskSelectionActions . add ( new   DefaultTasksBuildExecutionAction ( projectConfigurer )  )  ;", "taskSelectionActions . add ( new   TaskNameResolvingBuildConfigurationAction ( commandLineTaskPar )  )  ;", "return   new   DefaultBuildConfigurationActionExecuter ( Arrays . asList ( new   ExcludedTaskFilteringBuildConfigurationAction ( taskSelector )  )  ,    taskSelectionActions )  ;", "}", "METHOD_END"], "methodName": ["createBuildConfigurationActionExecuter"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildExecuter ( Arrays . asList ( new   DryRunBuildExecutionAction ( textOutputFactory )  ,    new   SelectedTaskExecutionAction (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createBuildExecuter"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildOutputCleanupRegistry ( fileResolver )  ;", "}", "METHOD_END"], "methodName": ["createBuildOutputCleanupRegistry"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildScanScopeIds ( buildInvocationScopeId ,    workspaceScopeId ,    userScopeId )  ;", "}", "METHOD_END"], "methodName": ["createBuildScanScopeIds"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( gradle . getParent (  )  )     =  =    null )     {", "return   new   BuildInvocationScopeId ( UniqueId . generate (  )  )  ;", "} else    {", "return   gradle . getRoot (  )  . get (  )  . get ( BuildInvocationScopeId . class )  ;", "}", "}", "METHOD_END"], "methodName": ["createBuildScopeId"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CommandLineTaskParser ( new   CommandLineTaskConfigurer ( optionReader )  ,    taskSelector )  ;", "}", "METHOD_END"], "methodName": ["createCommandLineTaskParser"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   ConfigurationTargetIdentifier . of ( gradle )  ;", "}", "METHOD_END"], "methodName": ["createConfigurationTargetIdentifier"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileContentCacheFactory ( listenerManager ,    fileSystemSnapshotter ,    cacheRepository ,    inMemoryCacheDecoratorFactory ,    gradle )  ;", "}", "METHOD_END"], "methodName": ["createFileContentCacheFactory"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   OptionReader (  )  ;", "}", "METHOD_END"], "methodName": ["createOptionReader"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "PluginTarget   target    =    new   ImperativeOnlyPluginTarget < GradleInternal >  ( gradleInternal )  ;", "return   instantiator . newInstance ( DefaultPluginManager . class ,    pluginRegistry ,    instantiatorFactory . inject ( this )  ,    target ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createPluginManager"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   parentRegistry . createChild ( get ( GradleInternal . class )  . getClassLoaderScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPluginRegistry"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectFinder (  )     {", "public   ProjectI   getProject ( String   path )     {", "return   gradle . getRootProject (  )  . project ( path )  ;", "}", "@ Override", "public   ProjectI   findProject ( String   path )     {", "return   gradle . getRootProject (  )  . findProject ( path )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createProjectFinder"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "final   Factory < LoggingManagerInternal >    loggingManagerInternalFactory    =    getFactory ( LoggingManagerInternal . class )  ;", "return   new   ServiceRegistryFactory (  )     {", "public   ServiceRegistry   createFor ( Object   domainObject )     {", "if    ( domainObject   instanceof   ProjectInternal )     {", "Project   project    =    new   Project ( services ,     (  ( ProjectInternal )     ( domainObject )  )  ,    loggingManagerInternalFactory )  ;", "registries . add ( project )  ;", "return   project ;", "}", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createServiceRegistryFactory"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "Factory < TaskExecuter >    taskExecuterFactory    =    new   Factory < TaskExecuter >  (  )     {", "@ Override", "public   TaskExecuter   create (  )     {", "return   get ( TaskExecuter . class )  ;", "}", "}  ;", "return   new   DefaultTaskGraphExecuter ( listenerManager ,    taskPlanExecutor ,    taskExecuterFactory ,    cancellationToken ,    buildOperationExecutor ,    workerLeas ,    coordinationService ,    gradleInternal )  ;", "}", "METHOD_END"], "methodName": ["createTaskGraphExecuter"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskSelector ( gradle ,    projectConfigurer )  ;", "}", "METHOD_END"], "methodName": ["createTaskSelector"], "fileName": "org.gradle.internal.service.scopes.GradleScopeServices"}, {"methodBody": ["METHOD_START", "{", "registration . addProvider ( new   CacheRepositoryServices ( userHomeDirProvider . getGradleUserHomeDirectory (  )  ,    null )  )  ;", "for    ( PluginServiceRegistry   plugin    :    globalServices . getAll ( PluginServiceRegistry . class )  )     {", "plugin . registerervices ( registration )  ;", "}", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultCachedClasspathTransformer ( cacheRepository ,    new   JarCache ( fileHasher )  ,    fileStores )  ;", "}", "METHOD_END"], "methodName": ["createCachedClasspathTransformer"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "CachingFileHasher   fileHasher    =    new   CachingFileHasher ( new   DefaultFileHasher ( streamHasher )  ,    fileStore ,    stringInterner ,    fileTimeStampInspector ,     \" fileHashes \"  ,    fileSystem )  ;", "fileTimeStampInspector . attach ( fileHasher )  ;", "return   fileHasher ;", "}", "METHOD_END"], "methodName": ["createCachingFileHasher"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CrossBuildInMemoryCachingScriptClassCache ( hasher ,    cacheFactory )  ;", "}", "METHOD_END"], "methodName": ["createCachingScriptCompiler"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClassLoaderCache ( classLoaderFactory ,    classpathHasher )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderCache"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultHashingClassLoaderFactory ( classpathHasher )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderFactory"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   RegistryAwareClassLoaderHierarchyHasher ( registry ,    classLoaderHasher )  ;", "}", "METHOD_END"], "methodName": ["createClassLoaderHierarchyHasher"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultClassPathRegistry ( new   DefaultClassPathProvider ( moduleRegistry )  ,    workerProcessClassPathProvider )  ;", "}", "METHOD_END"], "methodName": ["createClassPathRegistry"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "PersistentIndexedCache < HashCode ,    HashCode >    jarCache    =    store . createCache (  \" resourceHashesCache \"  ,    HashCode . class ,    new   HashCodeSerializer (  )  ,     4  0  0  0  0  0  ,    true )  ;", "ClasspathSnapshotter   snapshotter    =    new   DefaultClasspathSnapshotter ( new   ResourceSnapshotterCach ( jarCache )  ,    directoryFileTreeFactory ,    fileSystemSnapshotter ,    stringInterner )  ;", "return   new   DefaultClasspathHasher ( snapshotter )  ;", "}", "METHOD_END"], "methodName": ["createClasspathHasher"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CrossBuildFileHashCache ( null ,    cacheRepository ,    inMemoryCacheDecoratorFactory )  ;", "}", "METHOD_END"], "methodName": ["createCrossBuildFileHashCache"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "DefaultFileSystemMirror   fileSystemMirror    =    new   DefaultFileSystemMirror ( fileStores )  ;", "listenerManager . addListener ( fileSystemMirror )  ;", "return   fileSystemMirror ;", "}", "METHOD_END"], "methodName": ["createFileSystemMirror"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileSystemSnapshotter ( hasher ,    stringInterner ,    fileSystem ,    directoryFileTreeFactory ,    fileSystemMirror )  ;", "}", "METHOD_END"], "methodName": ["createFileSystemSnapshotter"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "GlobalScopeFileTimeStampInspector   timeStampInspector    =    new   GlobalScopeFileTimeStampInspector ( cacheScopeMapping )  ;", "listenerManager . addListener ( timeStampInspector )  ;", "return   timeStampInspector ;", "}", "METHOD_END"], "methodName": ["createFileTimestampInspector"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultGenericFileCollectionSnapshotter ( stringInterner ,    directoryFileTreeFactory ,    fileSystemSnapshotter )  ;", "}", "METHOD_END"], "methodName": ["createGenericFileCollectionSnapshotter"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   parent . createChild (  )  ;", "}", "METHOD_END"], "methodName": ["createListenerManager"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultScriptSourceHasher ( fileHasher ,    contentHasherFactory )  ;", "}", "METHOD_END"], "methodName": ["createScriptSourceHasher"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ValueSnapshotter ( classLoaderHierarchyHasher ,    NamedObjectInstantiator . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createValueSnapshotter"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   WorkerProcessClassPathProvider ( cacheRepository )  ;", "}", "METHOD_END"], "methodName": ["createWorkerProcessClassPathProvider"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultWorkerProcessFactory ( loggingManagerInternal ,    messagingServer ,    classPathRegistry ,    new   LongIdGenerator (  )  ,    gradleUserHomeDirProvider . getGradleUserHomeDirectory (  )  ,    temporaryFileProvider ,    execHandleFactory ,    jvmVersionDetector ,    outputEventListener ,    memoryManager )  ;", "}", "METHOD_END"], "methodName": ["createWorkerProcessFactory"], "fileName": "org.gradle.internal.service.scopes.GradleUserHomeScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultAntBuilderFactory ( project ,    new   DefaultAntLoggingAdapterFactory (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAntBuilderFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ComponentRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["createComponentRegistry"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   ConfigurationTargetIdentifier . of ( project )  ;", "}", "METHOD_END"], "methodName": ["createConfigurationTargetIdentifier"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DeferredProjectConfiguration ( project )  ;", "}", "METHOD_END"], "methodName": ["createDeferredProjectConfiguration"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectScopeServices . ProjectBackedModuleMetaDataProvider (  )  ;", "}", "METHOD_END"], "methodName": ["createDependencyMetaDataProvider"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultFileOperations ( fileResolver ,    project . getTasks (  )  ,    temporaryFileProvider ,    instantiator ,    fileLookup ,    directoryFileTreeFactory ,    streamHasher ,    fileHasher ,    execFactory )  ;", "}", "METHOD_END"], "methodName": ["createFileOperations"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseDirFileResolver ( get ( FileSystem . class )  ,    project . getProjectDir (  )  ,    patternSetFactory )  ;", "}", "METHOD_END"], "methodName": ["createFileResolver"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   instantiator . newInstance ( DefaultInputNormalizationHandler . class ,    runtimeClasspathNormalizationStrategy )  ;", "}", "METHOD_END"], "methodName": ["createInputNormalizationHandler"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   loggingManagerInternalFactory . create (  )  ;", "}", "METHOD_END"], "methodName": ["createLoggingManager"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultModelRegistry ( ruleExtractor ,    project . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["createModelRegistry"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    instantiatorFactory . injectAndDecorate ( this )  ;", "return   new   DefaultObjectFactory ( instantiator ,    NamedObjectInstantiator . INSTANCE )  ;", "}", "METHOD_END"], "methodName": ["createObjectFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "PluginTarget   target    =    new   RuleBasedPluginTarget < ProjectInternal >  ( project ,    get ( ModelRuleExtractor . class )  ,    get ( ModelRuleSourceDetector . class )  )  ;", "return   instantiator . newInstance ( DefaultPluginManager . class ,    get ( PluginRegistry . class )  ,    instantiatorFactory . inject ( this )  ,    target ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createPluginManager"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "PluginRegistry   parentRegistry ;", "if    (  ( project . getParent (  )  )     =  =    null )     {", "parentRegistry    =    rootRegistry ;", "} else    {", "parentRegistry    =    project . getParent (  )  . get (  )  . get ( PluginRegistry . class )  ;", "}", "return   parentRegistry . createChild ( project . getClassLoaderScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPluginRegistry"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectConfigurationActionContainer (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectConfigurationActionContainer"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectFinder (  )     {", "public   ProjectInternal   getProject ( String   path )     {", "return   project . project ( path )  ;", "}", "@ Override", "public   ProjectInternal   findProject ( String   path )     {", "return   project . findProject ( path )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createProjectFinder"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectLayout ( project . getProjectDir (  )  ,    fileResolver ,    project . getTasks (  )  )  ;", "}", "METHOD_END"], "methodName": ["createProjectLayout"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   instantiator . newInstance ( DefaultRuntimeClasspathNormalization . class )  ;", "}", "METHOD_END"], "methodName": ["createRuntimeClasspathNormalizationStrategy"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "ScriptHandlerFactory   factory    =    new   DefaultScriptHandlerFactory ( get ( DependencyManagementServices . class )  ,    get ( FileResolver . class )  ,    get ( DependencyMetaDataProvider . class )  ,    get ( ScriptClassPathResolver . class )  )  ;", "return   factory . create ( project . getBuildScriptSource (  )  ,    project . getClassLoaderScope (  )  ,    new    . ScriptScopedContext ( project )  )  ;", "}", "METHOD_END"], "methodName": ["createScriptHandler"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   ServiceRegistryFactory (  )     {", "public   ServiceRegistry   createFor ( Object   domainObject )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createServiceRegistryFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "Instantiator   instantiator    =    get ( Instantiator . class )  ;", "return   instantiator . newInstance ( DefaultSoftwareComponentContainer . class ,    instantiator )  ;", "}", "METHOD_END"], "methodName": ["createSoftwareComponentContainer"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultSourceDirectorySetFactory ( fileResolver ,    directoryFileTreeFactory )  ;", "}", "METHOD_END"], "methodName": ["createSourceDirectorySetFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskContainerFactory ( get ( ModelRegistry . class )  ,    get ( Instantiator . class )  ,    get ( ITaskFactory . class )  ,    project ,    get ( ProjectAccessListener . class )  ,    taskStatistics )  ;", "}", "METHOD_END"], "methodName": ["createTaskContainerInternal"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   parentFactory . createChild ( project ,    get ( InstantiatorFactory . class )  . injectAndDecorate ( this )  )  ;", "}", "METHOD_END"], "methodName": ["createTaskFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTemporaryFileProvider ( new   Factory < File >  (  )     {", "public   File   create (  )     {", "return   new   File ( project . getBuildDir (  )  ,     \" tmp \"  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["createTemporaryFileProvider"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTypeConverter ( fileResolver )  ;", "}", "METHOD_END"], "methodName": ["createTypeConverter"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   execFactory . forContext ( get ( FileResolver . class )  ,    get ( InstantiatorFactory . class )  . decorate (  )  )  ;", "}", "METHOD_END"], "methodName": ["decorateExecFactory"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultToolingModelBuilderRegistry ( buildScopedToolingModelBuilders )  ;", "}", "METHOD_END"], "methodName": ["decorateToolingModelRegistry"], "fileName": "org.gradle.internal.service.scopes.ProjectScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   ConfigurationTargetIdentifier . of ( settings )  ;", "}", "METHOD_END"], "methodName": ["createConfigurationTargetIdentifier"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   BaseDirFileResolver ( get ( FileSystem . class )  ,    settings . getSettingsDir (  )  ,    getFactory ( PatternSet . class )  )  ;", "}", "METHOD_END"], "methodName": ["createFileResolver"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   settings . getGradle (  )  ;", "}", "METHOD_END"], "methodName": ["createGradleInternal"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "PluginTarget   target    =    new   ImperativeOnlyPluginTarget < SettingsInternal >  ( settings )  ;", "return   instantiator . newInstance ( DefaultPluginManager . class ,    pluginRegistry ,    instantiatorFactory . inject ( this )  ,    target ,    buildOperationExecutor )  ;", "}", "METHOD_END"], "methodName": ["createPluginManager"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   parentRegistry . createChild ( settings . getClassLoaderScope (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPluginRegistry"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultProjectDescriptorRegistry (  )  ;", "}", "METHOD_END"], "methodName": ["createProjectDescriptorRegistry"], "fileName": "org.gradle.internal.service.scopes.SettingsScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultTaskHistoryStore ( gradle ,    cacheRepository ,    inMemoryCacheDecoratorFactory )  ;", "}", "METHOD_END"], "methodName": ["createCacheAccess"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "List < FileSnapshottingPropertyAnnotationHandler >    handlers    =    serviceRegistry . getAll ( FileSnapshottingPropertyAnnotationHandler . class )  ;", "ImmutableList . Builder < FileCollectionSnapshotter >    snapshotterImplementations    =    ImmutableList . builder (  )  ;", "snapshotterImplementations . add ( serviceRegistry . get ( GenericFileCollectionSnapshotter . class )  )  ;", "for    ( FileSnapshottingPropertyAnnotationHandler   handler    :    handlers )     {", "snapshotterImplementations . add ( serviceRegistry . get ( handler . getSnapshotterImplementationType (  )  )  )  ;", "}", "return   new   DefaultFileCollectionSnapshotterRegistry ( snapshotterImplementations . build (  )  )  ;", "}", "METHOD_END"], "methodName": ["createFileCollectionSnapshotterRegistry"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "TaskCacheKeyCalculator   taskCacheKeyCalculator    =    new   TaskCacheKeyCalculator ( startParameter . isBuildCacheDebugLogging (  )  )  ;", "return   new   ShortCircuitTaskArtifactStateRepository ( startParameter ,    instantiator ,    new   DefaultTaskArtifactStateRepository ( taskHistoryRepository ,    instantiator ,    taskOutputsRepository ,    taskCacheKeyCalculator )  )  ;", "}", "METHOD_END"], "methodName": ["createTaskArtifactStateRepository"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "boolean   buildCacheEnabled    =    buildCacheController . isEnabled (  )  ;", "boolean   scanPluginApplied    =    buildScanPlugin . isBuildScanPluginApplied (  )  ;", "TaskOutputChangesListener   taskOutputChangesListener    =    listenerManager . getBroadcaster ( TaskOutputChangesListener . class )  ;", "TaskExecuter   executer    =    new   ExecuteActionsTaskExecuter ( taskOutputChangesListener ,    listenerManager . getBroadcaster ( TaskActionListener . class )  ,    buildOperationExecutor ,    asyncWorkTracker ,    buildInvocationScopeId )  ;", "executer    =    new   OutputDirectoryCreatingTaskExecuter ( executer )  ;", "if    ( buildCacheEnabled )     {", "executer    =    new   SkipCachedTaskExecuter ( buildCacheController ,    taskOutputChangesListener ,    taskOutputCacheCommandFactory ,    executer )  ;", "}", "executer    =    new   SkipUpToDateTaskExecuter ( executer )  ;", "executer    =    new   ResolveTaskOutputCachingStateExecuter ( buildCacheEnabled ,    executer )  ;", "if    ( buildCacheEnabled    |  |    scanPluginApplied )     {", "executer    =    new   ResolveBuildCacheKeyExecuter ( executer ,    buildOperationExecutor ,    buildCacheController . isEmitDebugLogging (  )  )  ;", "}", "executer    =    new   ValidatingTaskExecuter ( executer )  ;", "executer    =    new   SkipEmptySourceFilesTaskExecuter ( inputsListener ,    cleanupRegistry ,    taskOutputChangesListener ,    executer ,    buildInvocationScopeId )  ;", "executer    =    new   FinalizeInputFilePropertiesTaskExecuter ( executer )  ;", "executer    =    new   CleanupStaleOutputsExecuter ( cleanupRegistry ,    taskOutputFilesRepository ,    buildOperationExecutor ,    taskOutputChangesListener ,    executer )  ;", "executer    =    new   ResolveTaskArtifactStateTaskExecuter ( repository ,    resolver ,    propertyWalker ,    executer )  ;", "executer    =    new   SkipTaskWithNoActionsExecuter ( tGraph ,    executer )  ;", "executer    =    new   SkipOnlyIfTaskExecuter ( executer )  ;", "executer    =    new   ExecuteAtMostOnceTaskExecuter ( executer )  ;", "executer    =    new   CatchExceptionTaskExecuter ( executer )  ;", "return   executer ;", "}", "METHOD_END"], "methodName": ["createTaskExecuter"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TaskPlanExecutorFactory ( parallelismConfigurationManager ,    executorFactory ,    workerLeaseService )  . create (  )  ;", "}", "METHOD_END"], "methodName": ["createTaskExecutorFactory"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "SerializerRegistry   serializerRegistry    =    new   DefaultSerializerRegistry (  )  ;", "for    ( FileCollecnapshotter   snapshotter    :    fileCollecnapshotterRegistry . getAllSnapshotters (  )  )     {", "snapshotter . registerSerializers ( serializerRegistry )  ;", "}", "return   new   CacheBackedTaskHistoryRepository ( cacheAccess ,    serializerRegistry . build ( FileCollecnapshot . class )  ,    stringInterner ,    classLoaderHierarchyHasher ,    valueSnapshotter ,    snapshotterRegistry ,    fileCollectionFactory )  ;", "}", "METHOD_END"], "methodName": ["createTaskHistoryRepository"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "PersistentCache   cacheAccess    =    cacheRepository . cache ( gradle ,     \" buildOutputCleanup \"  )  . withCrossVersionCache ( DefaultTarget )  . withDisplayName (  \" Build   Output   Cleanup   Cache \"  )  . withLockOptions ( mode ( None )  )  . withProperties ( Collections . singletonMap (  \" gradle . version \"  ,    GradleVersion . current (  )  . getVersion (  )  )  )  . open (  )  ;", "return   new   DefaultTaskOutputFilesRepository ( cacheAccess ,    fileSystemSnapshotter ,    inMemoryCacheDecoratorFactory )  ;", "}", "METHOD_END"], "methodName": ["createTaskOutputFilesRepository"], "fileName": "org.gradle.internal.service.scopes.TaskExecutionServices"}, {"methodBody": ["METHOD_START", "{", "if    (  ( current . state )     =  =     ( TreeFormatter . State . CollectValue )  )     {", "if    ( current . valueWritten )     {", "original . append ( text )  ;", "} else    {", "current . value . append ( text )  ;", "}", "} else    {", "throw   new   IllegalStateException (  \" Cannot   append   text   to   node .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["append"], "fileName": "org.gradle.internal.text.TreeFormatter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( node . prefix )     =  =    null )     {", "node . prefix    =     ( node . isTopLevelNode (  )  )     ?     \"  \"     :     ( node . parent . prefix )     +     \"              \"  ;", "}", "StyledTextOutput   output    =    new   logging . text . LinePrefixingStyledTextOutput ( original ,    node . prefix ,    false )  ;", "if    (  !  ( node . valueWritten )  )     {", "output . append ( node . parent . prefix )  ;", "output . append (  \"        -     \"  )  ;", "output . append ( node . value )  ;", "}", "if    ( node . canCollapseFirstChild (  )  )     {", "output . append (  \"  :     \"  )  ;", "TreeFormatter . Node   firstChild    =    node . firstChild ;", "output . append ( firstChild . value )  ;", "firstChild . valueWritten    =    true ;", "firstChild . prefix    =    node . prefix ;", "writeNode ( firstChild )  ;", "} else", "if    (  ( node . firstChild )     !  =    null )     {", "original . format (  \"  :  % n \"  )  ;", "writeNode ( node . firstChild )  ;", "}", "if    (  ( node . nextSibling )     !  =    null )     {", "original . format (  \"  % n \"  )  ;", "writeNode ( node . nextSibling )  ;", "}", "}", "METHOD_END"], "methodName": ["writeNode"], "fileName": "org.gradle.internal.text.TreeFormatter"}, {"methodBody": ["METHOD_START", "{", "current    +  =    diff ;", "}", "METHOD_END"], "methodName": ["increment"], "fileName": "org.gradle.internal.time.MockClock"}, {"methodBody": ["METHOD_START", "{", "Spec < T >    spec    =    Specs . convertClosureToSpec ( notation )  ;", "result . converted ( spec )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.internal.typeconversion.ClosureToSpecNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( type )  . noImplicitConverters (  )  . converter ( converter )  . toComposite (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "if    ( type . isInstance ( notation )  )     {", "return   notation ;", "}", "if    (  (  ! primitive )     &  &     ( notation    =  =    null )  )     {", "return   null ;", "}", "if    ( type . isEnum (  )  )     {", "Class <  ?    extends   Enum >    enumType    =    Cast . uncheckedCast ( type )  ;", "return   convertEnum ( enumType ,    notation )  ;", "}", "NotationParser < Object ,     ?  >    parser ;", "parser    =    parsers . get (  ( primitive    ?     . UNBOXED _ TYPES . get ( type )     :    type )  )  ;", "if    ( parser    =  =    null )     {", "throw   new   IllegalArgumentException (  (  \" Don ' t   know   how   to   convert   to   type    \"     +     ( type . getName (  )  )  )  )  ;", "}", "return   parser . parseNotation ( notation )  ;", "}", "METHOD_END"], "methodName": ["convert"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "return   NotationParserBuilder . toType ( type )  . noImplicitConverters (  )  . fromCharSequence ( new   EnumFromCharSequenceNotationParser < T >  ( type )  )  . toComposite (  )  . parseNotation ( notation )  ;", "}", "METHOD_END"], "methodName": ["convertEnum"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "parsers . put ( type ,    DefaultTypeConverter . build ( converter ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["registerConverter"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "registerConverter ( new   DefaultTypeConverter . DoubleNumberConverter ( Double . class )  ,    Double . class )  ;", "registerConverter ( new   DefaultTypeConverter . DoubleNumberConverter ( double . class )  ,    double . class )  ;", "registerConverter ( new   DefaultTypeConverter . FloatNumberConverter ( Float . class )  ,    Float . class )  ;", "registerConverter ( new   DefaultTypeConverter . FloatNumberConverter ( float . class )  ,    float . class )  ;", "registerConverter ( new   DefaultTypeConverter . IntegerNumberConverter ( Integer . class )  ,    Integer . class )  ;", "registerConverter ( new   DefaultTypeConverter . IntegerNumberConverter ( int . class )  ,    int . class )  ;", "registerConverter ( new   DefaultTypeConverter . LongNumberConverter ( Long . class )  ,    Long . class )  ;", "registerConverter ( new   DefaultTypeConverter . LongNumberConverter ( long . class )  ,    long . class )  ;", "registerConverter ( new   DefaultTypeConverter . ShortNumberConverter ( Short . class )  ,    Short . class )  ;", "registerConverter ( new   DefaultTypeConverter . ShortNumberConverter ( short . class )  ,    short . class )  ;", "registerConverter ( new   DefaultTypeConverter . ByteNumberConverter ( Byte . class )  ,    Byte . class )  ;", "registerConverter ( new   DefaultTypeConverter . ByteNumberConverter ( byte . class )  ,    byte . class )  ;", "registerConverter ( new   DefaultTypeConverter . BigDecimalNumberConverter (  )  ,    BigDecimal . class )  ;", "registerConverter ( new   DefaultTypeConverter . BigIntegerNumberConverter (  )  ,    BigInteger . class )  ;", "DefaultTypeConverter . CharSequenceConverter < Boolean >    booleanConverter    =    new   DefaultTypeConverter . BooleanConverter (  )  ;", "registerStringConverter ( booleanConverter ,    Boolean . class )  ;", "registerStringConverter ( booleanConverter ,    boolean . class )  ;", "registerStringConverter ( new   DefaultTypeConverter . CharacterConverter ( Character . class ,    Character . class )  ,    Character . class )  ;", "registerStringConverter ( new   DefaultTypeConverter . CharacterConverter ( Character . class ,    char . class )  ,    char . class )  ;", "registerConverter ( new   DefaultTypeConverter . StringConverter (  )  ,    String . class )  ;", "}", "METHOD_END"], "methodName": ["registerConverters"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "parsers . put ( type ,    DefaultTypeConverter . build ( new   CharSequenceNotationConverter < Object ,    T >  ( converter )  ,    type )  )  ;", "}", "METHOD_END"], "methodName": ["registerStringConverter"], "fileName": "org.gradle.internal.typeconversion.DefaultTypeConverter"}, {"methodBody": ["METHOD_START", "{", "Object   value    =    args . get ( key )  ;", "String   str    =     ( value    !  =    null )     ?    value . toString (  )     :    null ;", "if    (  ( str    !  =    null )     &  &     (  ( str . length (  )  )     =  =     0  )  )     {", "return   null ;", "}", "return   str ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.gradle.internal.typeconversion.MapNotationConverter"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    mutableValues    =    new   HashMap < String ,    Object >  ( values )  ;", "Set < String >    missing    =    null ;", ". ConvertMethod   convertMethod    =    null ;", "Method   method    =    null ;", "while    ( method    =  =    null )     {", "convertMethod    =     . ConvertMethod . of ( this . getClass (  )  )  ;", "method    =    convertMethod . getMethod (  )  ;", "}", "Class <  ?  >  [  ]    parameterTypes    =    method . getParameterTypes (  )  ;", "Object [  ]    params    =    new   Object [ parameterTypes . length ]  ;", "String [  ]    keyNames    =    convertMethod . keyNames ;", "boolean [  ]    optionals    =    convertMethod . optional ;", "for    ( int   i    =     0  ;    i    <     ( params . length )  ;    i +  +  )     {", "String   keyName    =    keyNames [ i ]  ;", "boolean   optional    =    optionals [ i ]  ;", "Class <  ?  >    type    =    parameterTypes [ i ]  ;", "Object   value ;", "if    ( type    =  =     ( String . class )  )     {", "value    =    get ( mutableValues ,    keyName )  ;", "} else    {", "value    =    type . cast ( mutableValues . get ( keyName )  )  ;", "}", "if    (  (  ! optional )     &  &     ( value    =  =    null )  )     {", "if    ( missing    =  =    null )     {", "missing    =    new   TreeSet < String >  (  )  ;", "}", "missing . add ( keyName )  ;", "}", "mutableValues . remove ( keyName )  ;", "params [ i ]     =    value ;", "}", "if    ( missing    !  =    null )     {", "throw   new   InvalidUserDataException ( String . format (  \" Required   keys    % s   are   missing   from   map    % s .  \"  ,    missing ,    values )  )  ;", "}", "T   result ;", "try    {", "result    =     (  ( T )     ( method . invoke ( this ,    params )  )  )  ;", "}    catch    ( IllegalAccessException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}    catch    ( InvocationTargetException   e )     {", "throw   UncheckedException . unwrapAndRethrow ( e )  ;", "}", "ConfigureUtil . configureByMap ( mutableValues ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["parseType"], "fileName": "org.gradle.internal.typeconversion.MapNotationConverter"}, {"methodBody": ["METHOD_START", "{", "return   timeUnit ;", "}", "METHOD_END"], "methodName": ["getTimeUnit"], "fileName": "org.gradle.internal.typeconversion.NormalizedTimeUnit"}, {"methodBody": ["METHOD_START", "{", "return   value ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "org.gradle.internal.typeconversion.NormalizedTimeUnit"}, {"methodBody": ["METHOD_START", "{", "return   new   NormalizedTimeUnit ( value ,    TimeUnit . MILLISECONDS )  ;", "}", "METHOD_END"], "methodName": ["millis"], "fileName": "org.gradle.internal.typeconversion.NormalizedTimeUnit"}, {"methodBody": ["METHOD_START", "{", "String   candidate    =    notation . toString (  )  . toUpperCase (  )  ;", "if    ( candidate . equals (  \" DAYS \"  )  )     {", "return   Normalized . millis (  (  (  (  ( value    *     2  4  )     *     6  0  )     *     6  0  )     *     1  0  0  0  )  )  ;", "} else", "if    ( candidate . equals (  \" HOURS \"  )  )     {", "return   Normalized . millis (  (  (  ( value    *     6  0  )     *     6  0  )     *     1  0  0  0  )  )  ;", "} else", "if    ( candidate . equals (  \" MINUTES \"  )  )     {", "return   Normalized . millis (  (  ( value    *     6  0  )     *     1  0  0  0  )  )  ;", "}", "try    {", "return   new   Normalized ( value ,     . valueOf ( candidate )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   InvalidUserDataException (  (  \" Unable   to   parse   provided    :     \"     +    notation )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["parseNotation"], "fileName": "org.gradle.internal.typeconversion.TimeUnitsParser"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "waiting . add ( operation )  ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startWaiting"], "fileName": "org.gradle.internal.work.DefaultAsyncWorkTracker"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "waiting . remove ( operation )  ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopWaiting"], "fileName": "org.gradle.internal.work.DefaultAsyncWorkTracker"}, {"methodBody": ["METHOD_START", "{", "final   List < Throwable >    failures    =    Lists . newArrayList (  )  ;", "for    ( Completion   item    :    workItems )     {", "try    {", "item . waitForCompletion (  )  ;", "}    catch    ( Throwable   t )     {", "failures . add ( t )  ;", "}", "}", "if    (  ( failures . size (  )  )     >     0  )     {", "throw   new   DefaultMultiCauseException (  \" There   were   failures   while   executing   asynchronous   work :  \"  ,    failures )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForItemsAndGatherFailures"], "fileName": "org.gradle.internal.work.DefaultAsyncWorkTracker"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlValidation . isValidXmlName ( name )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Invalid   attribute   name :     '  % s '  \"  ,    name )  )  ;", "}", "if    (  ( context )     !  =     (  . Context . StartTag )  )     {", "throw   new   IllegalStateException (  (  (  (  (  \" Cannot   write   attribute    [  \"     +    name )     +     \"  :  \"  )     +    value )     +     \"  ]  .    You   should   write   start   element   first .  \"  )  )  ;", "}", "writeRaw (  \"     \"  )  ;", "writeRaw ( name )  ;", "writeRaw (  \"  =  \\  \"  \"  )  ;", "writeXmlAttributeEncoded ( value )  ;", "writeRaw (  \"  \\  \"  \"  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["attribute"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "characters ( characters ,     0  ,    characters . length )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["characters"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . CData )  )     {", "writeCDATA ( characters ,    start ,    count )  ;", "} else    {", "maybeStartText (  )  ;", "writeXmlEncoded ( characters ,    start ,    count )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["characters"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . CData )  )     {", "writeCDATA ( characters )  ;", "} else    {", "maybeStartText (  )  ;", "writeXmlEncoded ( characters )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["characters"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     !  =     ( SimpleMarkupWriter . Context . CData )  )     {", "throw   new   IllegalStateException (  \" Cannot   end   CDATA   node ,    as   not   currently   in   a   CDATA   node .  \"  )  ;", "}", "writeRaw (  \"  ]  ]  >  \"  )  ;", "context    =    SimpleMarkupWriter . Context . Text ;", "return   this ;", "}", "METHOD_END"], "methodName": ["endCDATA"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . Outside )  )     {", "throw   new   IllegalStateException (  \" Cannot   end   element ,    as   there   are   no   started   elements .  \"  )  ;", "}", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . CData )  )     {", "throw   new   IllegalStateException (  \" Cannot   end   element ,    as   current   CDATA   node   has   not   been   closed .  \"  )  ;", "}", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . StartTag )  )     {", "writeRaw (  \"  /  >  \"  )  ;", "elements . removeLast (  )  ;", "} else    {", "if    (  (  ( context )     !  =     ( SimpleMarkupWriter . Context . Text )  )     &  &     (  ( indent )     !  =    null )  )     {", "writeRaw ( SimpleMarkupWriter . LINE _ SEPARATOR )  ;", "for    ( int   i    =     1  ;    i    <     ( elements . size (  )  )  ;    i +  +  )     {", "writeRaw ( indent )  ;", "}", "}", "writeRaw (  \"  <  /  \"  )  ;", "writeRaw ( elements . removeLast (  )  )  ;", "writeRaw (  \"  >  \"  )  ;", "}", "if    ( elements . isEmpty (  )  )     {", "if    (  ( indent )     !  =    null )     {", "writeRaw ( SimpleMarkupWriter . LINE _ SEPARATOR )  ;", "}", "output . flush (  )  ;", "context    =    SimpleMarkupWriter . Context . Outside ;", "} else    {", "context    =    SimpleMarkupWriter . Context . ElementContent ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["endElement"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . StartTag )  )     {", "writeRaw (  \"  >  \"  )  ;", "context    =    SimpleMarkupWriter . Context . ElementContent ;", "}", "}", "METHOD_END"], "methodName": ["maybeFinishStartTag"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . Outside )  )     {", "throw   new   IllegalStateException (  \" Cannot   write   text ,    as   there   are   no   started   elements .  \"  )  ;", "}", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . StartTag )  )     {", "writeRaw (  \"  >  \"  )  ;", "}", "context    =    SimpleMarkupWriter . Context . Text ;", "}", "METHOD_END"], "methodName": ["maybeStartText"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "switch    ( ch )     {", "case    '  ]  '     :", "( squareBrackets )  +  +  ;", "return   false ;", "case    '  >  '     :", "if    (  ( squareBrackets )     >  =     2  )     {", "squareBrackets    =     0  ;", "return   true ;", "}", "return   false ;", "default    :", "squareBrackets    =     0  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["needsCDATAEscaping"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( context )     =  =     ( SimpleMarkupWriter . Context . CData )  )     {", "throw   new   IllegalStateException (  \" Cannot   start   CDATA   node ,    as   current   CDATA   node   has   not   been   closed .  \"  )  ;", "}", "maybeFinishStartTag (  )  ;", "writeRaw (  \"  <  !  [ CDATA [  \"  )  ;", "context    =    SimpleMarkupWriter . Context . CData ;", "squareBrackets    =     0  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["startCDATA"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( XmlValidation . isValidXmlName ( name )  )  )     {", "throw   new   IllegalArgumentException ( String . format (  \" Invalid   element   name :     '  % s '  \"  ,    name )  )  ;", "}", "if    (  ( context )     =  =     (  . Context . CData )  )     {", "throw   new   IllegalStateException (  \" Cannot   start   element ,    as   current   CDATA   node   has   not   been   closed .  \"  )  ;", "}", "maybeFinishStartTag (  )  ;", "if    (  ( indent )     !  =    null )     {", "writeRaw (  . LINE _ SEPARATOR )  ;", "for    ( int   i    =     0  ;    i    <     ( elements . size (  )  )  ;    i +  +  )     {", "writeRaw ( indent )  ;", "}", "}", "context    =     . Context . StartTag ;", "elements . add ( name )  ;", "writeRaw (  \"  <  \"  )  ;", "writeRaw ( name )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["startElement"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( needsCDATAEscaping ( ch )  )     {", "wRaw (  \"  ]  ]  >  <  !  [ CDATA [  >  \"  )  ;", "} else", "if    (  !  ( XmlValidation . isLegalCharacter ( ch )  )  )     {", "wRaw (  '  ?  '  )  ;", "} else", "if    ( XmlValidation . isRestrictedCharacter ( ch )  )     {", "wRaw (  \"  ]  ]  >  \"  )  ;", "wCharacterReference ( ch )  ;", "wRaw (  \"  <  !  [ CDATA [  \"  )  ;", "} else    {", "wRaw ( ch )  ;", "}", "}", "METHOD_END"], "methodName": ["writeCDATA"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "int   end    =    offset    +    count ;", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "wCDATA ( cdata [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeCDATA"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "int   len    =    cdata . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "wCDATA ( cdata . charAt ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeCDATA"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "writeRaw (  \"  &  # x \"  )  ;", "writeRaw ( Integer . toHexString ( ch )  )  ;", "writeRaw (  \"  ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["writeCharacterReference"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "output . write ( c )  ;", "}", "METHOD_END"], "methodName": ["writeRaw"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "output . write ( message )  ;", "}", "METHOD_END"], "methodName": ["writeRaw"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( ch    =  =     9  )     {", "wRaw (  \"  &  #  9  ;  \"  )  ;", "} else", "if    ( ch    =  =     1  0  )     {", "wRaw (  \"  &  #  1  0  ;  \"  )  ;", "} else", "if    ( ch    =  =     1  3  )     {", "wRaw (  \"  &  #  1  3  ;  \"  )  ;", "} else    {", "wXmlEncoded ( ch )  ;", "}", "}", "METHOD_END"], "methodName": ["writeXmlAttributeEncoded"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "assert   message    !  =    null ;", "int   len    =    message . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "wXmlAttributeEncoded ( message . charAt ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeXmlAttributeEncoded"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "if    ( ch    =  =     '  <  '  )     {", "wRaw (  \"  & lt ;  \"  )  ;", "} else", "if    ( ch    =  =     '  >  '  )     {", "wRaw (  \"  & gt ;  \"  )  ;", "} else", "if    ( ch    =  =     '  &  '  )     {", "wRaw (  \"  & amp ;  \"  )  ;", "} else", "if    ( ch    =  =     '  \"  '  )     {", "wRaw (  \"  & quot ;  \"  )  ;", "} else", "if    (  !  ( XmlValidation . isLegalCharacter ( ch )  )  )     {", "wRaw (  '  ?  '  )  ;", "} else", "if    ( XmlValidation . isRestrictedCharacter ( ch )  )     {", "wCharacterReference ( ch )  ;", "} else    {", "wRaw ( ch )  ;", "}", "}", "METHOD_END"], "methodName": ["writeXmlEncoded"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "int   end    =    offset    +    count ;", "for    ( int   i    =    offset ;    i    <    end ;    i +  +  )     {", "wXmlEncoded ( message [ i ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeXmlEncoded"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "assert   message    !  =    null ;", "int   len    =    message . length (  )  ;", "for    ( int   i    =     0  ;    i    <    len ;    i +  +  )     {", "wXmlEncoded ( message . charAt ( i )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeXmlEncoded"], "fileName": "org.gradle.internal.xml.SimpleMarkupWriter"}, {"methodBody": ["METHOD_START", "{", "writeRaw (  \"  <  ? xml   version =  \\  \"  1  .  0  \\  \"    encoding =  \\  \"  \"  )  ;", "writeRaw ( encoding )  ;", "writeRaw (  \"  \\  \"  ?  >  \"  )  ;", "}", "METHOD_END"], "methodName": ["writeXmlDeclaration"], "fileName": "org.gradle.internal.xml.SimpleXmlWriter"}, {"methodBody": ["METHOD_START", "{", "actions . add ( ConfigureUtil . configureUsing ( closure )  )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "actions . add ( provider )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "return   doTransform ( new   XmlTransformer . XmlProviderImpl ( original )  )  ;", "}", "METHOD_END"], "methodName": ["doTransform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "return   doTransform ( new   XmlTransformer . XmlProviderImpl ( original )  )  ;", "}", "METHOD_END"], "methodName": ["doTransform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "return   doTransform ( new   XmlTransformer . XmlProviderImpl ( original )  )  ;", "}", "METHOD_END"], "methodName": ["doTransform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "provider . apply ( actions )  ;", "return   provider ;", "}", "METHOD_END"], "methodName": ["doTransform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "this . indentation    =    indentation ;", "}", "METHOD_END"], "methodName": ["setIndentation"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "IoActions . writeTextFile ( destination ,    encoding ,    new   Action < Writer >  (  )     {", "public   void   execute ( Writer   writer )     {", "transform ( writer ,    encoding ,    generator )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "IoActions . writeTextFile ( destination ,    new   Action < Writer >  (  )     {", "public   void   execute ( Writer   writer )     {", "transform ( writer ,    generator )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "generator . execute ( stringWriter )  ;", "do ( stringWriter . toString (  )  )  . writeTo ( destination ,    encoding )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "generator . execute ( stringWriter )  ;", "t ( stringWriter . toString (  )  ,    destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "return   doTransform ( original )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "doTransform ( original )  . writeTo ( destination )  ;", "}", "METHOD_END"], "methodName": ["transform"], "fileName": "org.gradle.internal.xml.XmlTransformer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( c    =  =     9  )     |  |     ( c    =  =     1  0  )  )     |  |     ( c    =  =     1  3  )  )     {", "retu   true ;", "} else", "if    ( c    <     3  2  )     {", "retu   false ;", "} else", "if    ( c    <  =     5  5  2  9  5  )     {", "retu   true ;", "} else", "if    ( c    <     5  7  3  4  4  )     {", "retu   false ;", "} else", "if    ( c    <  =     6  5  5  3  3  )     {", "retu   true ;", "} else", "if    ( c    <     6  5  5  3  6  )     {", "retu   false ;", "} else", "if    ( c    <  =     1  1  1  4  1  1  1  )     {", "retu   true ;", "}", "retu   false ;", "}", "METHOD_END"], "methodName": ["isLegalCharacter"], "fileName": "org.gradle.internal.xml.XmlValidation"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( c    =  =     9  )     |  |     ( c    =  =     1  0  )  )     |  |     ( c    =  =     1  3  )  )     |  |     ( c    =  =     1  3  3  )  )     {", "retu   false ;", "} else", "if    ( c    <  =     3  1  )     {", "retu   true ;", "} else", "if    ( c    <     1  2  7  )     {", "retu   false ;", "} else", "if    ( c    <  =     1  5  9  )     {", "retu   true ;", "}", "retu   false ;", "}", "METHOD_END"], "methodName": ["isRestrictedCharacter"], "fileName": "org.gradle.internal.xml.XmlValidation"}, {"methodBody": ["METHOD_START", "{", "if    ( XmlValidation . isValidNameStartChar ( ch )  )     {", "return   true ;", "}", "if    (  ( ch    >  =     '  0  '  )     &  &     ( ch    <  =     '  9  '  )  )     {", "return   true ;", "}", "if    (  (  ( ch    =  =     '  -  '  )     |  |     ( ch    =  =     '  .  '  )  )     |  |     ( ch    =  =     '  \\ u 0  0 b 7  '  )  )     {", "return   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  3  0  0  '  )     &  &     ( ch    <  =     '  \\ u 0  3  6 f '  )  )     {", "return   true ;", "}", "if    (  ( ch    >  =     '  \\ u 2  0  3 f '  )     &  &     ( ch    <  =     '  \\ u 2  0  4  0  '  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isValidNameChar"], "fileName": "org.gradle.internal.xml.XmlValidation"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ch    >  =     ' A '  )     &  &     ( ch    <  =     ' Z '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     ' a '  )     &  &     ( ch    <  =     ' z '  )  )     {", "retu   true ;", "}", "if    (  ( ch    =  =     '  :  '  )     |  |     ( ch    =  =     '  _  '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  0 c 0  '  )     &  &     ( ch    <  =     '  \\ u 0  0 d 6  '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  0 d 8  '  )     &  &     ( ch    <  =     '  \\ u 0  0 f 6  '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  0 f 8  '  )     &  &     ( ch    <  =     '  \\ u 0  2 ff '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  3  7  0  '  )     &  &     ( ch    <  =     '  \\ u 0  3  7 d '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 0  3  7 f '  )     &  &     ( ch    <  =     '  \\ u 1 fff '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 2  0  0 c '  )     &  &     ( ch    <  =     '  \\ u 2  0  0 d '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 2  0  7  0  '  )     &  &     ( ch    <  =     '  \\ u 2  1  8 f '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 2 c 0  0  '  )     &  &     ( ch    <  =     '  \\ u 2 fef '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ u 3  0  0  1  '  )     &  &     ( ch    <  =     '  \\ ud 7 ff '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ uf 9  0  0  '  )     &  &     ( ch    <  =     '  \\ ufdcf '  )  )     {", "retu   true ;", "}", "if    (  ( ch    >  =     '  \\ ufdf 0  '  )     &  &     ( ch    <  =     '  \\ ufffd '  )  )     {", "retu   true ;", "}", "retu   false ;", "}", "METHOD_END"], "methodName": ["isValidNameStartChar"], "fileName": "org.gradle.internal.xml.XmlValidation"}, {"methodBody": ["METHOD_START", "{", "int   pos    =     0  ;", "int   nsPos    =     0  ;", "int   nsCount    =     0  ;", "for    (  ;    pos    <     ( name . length (  )  )  ;    pos +  +  )     {", "char   ch    =    name . charAt ( pos )  ;", "if    ( ch    =  =     '  :  '  )     {", "nsCount +  +  ;", "if    ( nsCount    >     1  )     {", "return   false ;", "}", "if    ( pos    >     0  )     {", "nsPos    =    pos    +     1  ;", "}", "} else", "if    ( pos    =  =    nsPos )     {", "if    (  !  (  . isValidNameStartChar ( ch )  )  )     {", "return   false ;", "}", "} else    {", "if    (  !  (  . isValidNameChar ( ch )  )  )     {", "return   false ;", "}", "}", "}", "return   pos    !  =    nsPos ;", "}", "METHOD_END"], "methodName": ["isValidXmlName"], "fileName": "org.gradle.internal.xml.XmlValidation"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentGradleInstallation"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getFileResolver"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getListenerManager"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getPluginManager"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getResourceLoader"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptHandlerFactory"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getScriptPluginFactory"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getServiceRegistryFactory"], "fileName": "org.gradle.invocation.DefaultGradle"}, {"methodBody": ["METHOD_START", "{", "if    ( message . getMethod (  )  . getName (  )  . equals ( methodName )  )     {", "Object [  ]    parameters    =    message . getArguments (  )  ;", "if    (  ( closure . getMaximumNumberOfParameters (  )  )     <     ( parameters . length )  )     {", "parameters    =    Arrays . asList ( parameters )  . subList (  0  ,    closure . getMaximumNumberOfParameters (  )  )  . toArray (  )  ;", "}", "closure . call ( parameters )  ;", "}", "}", "METHOD_END"], "methodName": ["dispatch"], "fileName": "org.gradle.listener.ClosureBackedMethodInvocationDispatch"}, {"methodBody": ["METHOD_START", "{", "final   ModelPath   containerPath    =    containerReference . getPath (  )  ;", "final   ModelType < C >    containerType    =    containerReference . getType (  )  ;", "assert   containerPath    !  =    null    :     \" container   reference   path   cannot   be   null \"  ;", "return   ModelRegistrations . of ( containerPath )  . action ( ModelActionRole . Create ,    new   Action < MutableModelNode >  (  )     {", "public   void   execute ( final   MutableModelNode   containerNode )     {", "final   C   container    =    containerFactory . transform ( containerNode )  ;", "containerNode . setPrivateData ( containerType ,    container )  ;", "}", "}  )  . action ( ModelActionRole . Create ,    new   Action < MutableModelNode >  (  )     {", "@ Override", "public   void   execute ( final   MutableModelNode   containerNode )     {", "C   container    =    containerNode . getPrivateData ( containerType )  ;", "container . whenElementKnown ( new   Action < DefaultNamedDomainObjectCollection . ElementInfo < I >  >  (  )     {", "@ Override", "public   void   execute ( DefaultNamedDomainObjectCollection . ElementInfo < I >    info )     {", "final   String   name    =    info . getName (  )  ;", "if    (  !  ( containerNode . isMutable (  )  )  )     {", "return ;", "}", "if    (  !  ( containerNode . hasLink ( name )  )  )     {", "ModelRegistration   itemRegistration    =    ModelRegistrations . unmanagedInstanceOf ( ModelReference . of ( containerPath . child ( name )  ,     (  ( Class )     ( info . getType (  )  )  )  )  ,    new    . ExtractFromParentContainer < I ,    C >  ( name ,    containerType )  )  . descriptor ( new   SimpleModelRuleDescriptor ( new   Factory < String >  (  )     {", "@ Override", "public   String   create (  )     {", "return   itemDescriptorGenerator . transform ( name )  ;", "}", "}  )  )  . build (  )  ;", "containerNode . addLink ( itemRegistration )  ;", "}", "}", "}  )  ;", "container . whenObjectRemoved ( new   Action < I >  (  )     {", "public   void   execute ( I   item )     {", "String   name    =    namer . determineName ( item )  ;", "containerNode . removeLink ( name )  ;", "}", "}  )  ;", "}", "}  )  . descriptor ( descriptor )  ;", "}", "METHOD_END"], "methodName": ["registration"], "fileName": "org.gradle.model.collection.internal.BridgedCollections"}, {"methodBody": ["METHOD_START", "{", "return   runtimeClasspathNormalizationStrategy ;", "}", "METHOD_END"], "methodName": ["getRuntimeClasspathNormalizationStrategy"], "fileName": "org.gradle.normalization.internal.InputNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   runtimeClasspathResourceHasher ;", "}", "METHOD_END"], "methodName": ["getRuntimeClasspathResourceHasher"], "fileName": "org.gradle.normalization.internal.RuntimeClasspathNormalizationStrategy"}, {"methodBody": ["METHOD_START", "{", "return   reason ;", "}", "METHOD_END"], "methodName": ["getReason"], "fileName": "org.gradle.plugin.internal.InvalidPluginIdException"}, {"methodBody": ["METHOD_START", "{", "return   toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.plugin.management.internal.DefaultPluginRequest"}, {"methodBody": ["METHOD_START", "{", "return   id ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.gradle.plugin.management.internal.DefaultPluginRequest"}, {"methodBody": ["METHOD_START", "{", "return   pluginRequest ;", "}", "METHOD_END"], "methodName": ["getPluginRequest"], "fileName": "org.gradle.plugin.management.internal.InvalidPluginRequestException"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" Plugin   id   contains   invalid   char    '  \"     +    invalidChar )     +     \"  '     ( only    \"  )     +     ( DefaultPluginId . PLUGIN _ ID _ VALID _ CHARS _ DESCRIPTION )  )     +     \"    characters   are   valid )  \"  ;", "}", "METHOD_END"], "methodName": ["invalidPluginIdCharMessage"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginId"}, {"methodBody": ["METHOD_START", "{", "return   value . contains ( DefaultPluginId . SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["isQualified"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginId"}, {"methodBody": ["METHOD_START", "{", "DefaultPluginId . validate ( value )  ;", "return   new   DefaultPluginId ( value )  ;", "}", "METHOD_END"], "methodName": ["of"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginId"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultPluginId ( value )  ;", "}", "METHOD_END"], "methodName": ["unvalidated"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginId"}, {"methodBody": ["METHOD_START", "{", "if    (  ( value . startsWith ( DefaultPluginId . SEPARATOR )  )     |  |     ( value . endsWith ( DefaultPluginId . SEPARATOR )  )  )     {", "throw   new   InvalidPluginIdException ( value ,    DefaultPluginId . ID _ SEPARATOR _ ON _ START _ OR _ END )  ;", "} else", "if    ( value . contains (  (  ( DefaultPluginId . SEPARATOR )     +     ( DefaultPluginId . SEPARATOR )  )  )  )     {", "throw   new   InvalidPluginIdException ( value ,    DefaultPluginId . DOUBLE _ SEPARATOR )  ;", "} else    {", "int   invalidCharIndex    =    DefaultPluginId . INVALID _ PLUGIN _ ID _ CHAR _ MATCHER . indexIn ( value )  ;", "if    ( invalidCharIndex    >  =     0  )     {", "char   invalidChar    =    value . charAt ( invalidCharIndex )  ;", "throw   new   InvalidPluginIdException ( value ,    DefaultPluginId . invalidPluginIdCharMessage ( invalidChar )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.plugin.use.internal.DefaultPluginId"}, {"methodBody": ["METHOD_START", "{", "return   classPath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.plugin.use.internal.InjectedPluginClasspath"}, {"methodBody": ["METHOD_START", "{", "return   new   PluginDependenciesSpec (  )     {", "public   PluginDependencySpec   id ( String   id )     {", ". DependencySpecImpl   spec    =    new    . DependencySpecImpl ( id ,    lineNumber )  ;", "specs . add ( spec )  ;", "return   spec ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createSpec"], "fileName": "org.gradle.plugin.use.internal.PluginRequestCollector"}, {"methodBody": ["METHOD_START", "{", "if    ( specs . isEmpty (  )  )     {", "return   Defaults . EMPTY ;", "}", "return   new   Defaults ( lists (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPluginRequests"], "fileName": "org.gradle.plugin.use.internal.PluginRequestCollector"}, {"methodBody": ["METHOD_START", "{", "List < PluginRequestInternal >    pluginRequests    =    CollectionUtils . collect ( specs ,    new   Transformer < PluginRequestInternal ,    PluginRequestCollector . DependencySpecImpl >  (  )     {", "public   PluginRequestInternal   transform ( PluginRequestCollector . DependencySpecImpl   original )     {", "return   new   DefaultPluginRequest ( original . id ,    original . version ,    original . apply ,    original . lineNumber ,    scriptSource )  ;", "}", "}  )  ;", "Map < PluginId ,    Collection < PluginRequestInternal >  >    groupedById    =    CollectionUtils . groupBy ( pluginRequests ,    new   Transformer < PluginId ,    PluginRequestInternal >  (  )     {", "public   PluginId   transform ( PluginRequestInternal   pluginRequest )     {", "return   pluginRequest . getId (  )  ;", "}", "}  )  ;", "for    ( PluginId   key    :    groupedById . keySet (  )  )     {", "Collection < PluginRequestInternal >    pluginRequestsForId    =    groupedById . get ( key )  ;", "if    (  ( pluginRequestsForId . size (  )  )     >     1  )     {", "Iterator < PluginRequestInternal >    iterator    =    pluginRequestsForId . iterator (  )  ;", "PluginRequestInternal   first    =    iterator . next (  )  ;", "PluginRequestInternal   second    =    iterator . next (  )  ;", "InvalidPluginRequestException   exception    =    new   InvalidPluginRequestException ( second ,     (  (  (  \" Plugin   with   id    '  \"     +    key )     +     \"  '    was   already   requested   at   line    \"  )     +     ( first . getLineNumber (  )  )  )  )  ;", "throw   new   LocationAwareException ( exception ,    second . getScriptDisplayName (  )  ,    second . getLineNumber (  )  )  ;", "}", "}", "return   pluginRequests ;", "}", "METHOD_END"], "methodName": ["listPluginRequests"], "fileName": "org.gradle.plugin.use.internal.PluginRequestCollector"}, {"methodBody": ["METHOD_START", "{", "ClosureExpression   closureArg    =    scriptBlock . getClosureExpression (  )  ;", "closureArg . getCode (  )  . visit ( new   RestrictiveCodeVisitor ( sourceUnit ,    formatErrorMessage (  . BASE _ MESSAGE )  )     {", "@ Override", "public   void   visitBlockStatement ( BlockStatement   block )     {", "for    ( Statement   statement    :    block . getStatements (  )  )     {", "statement . visit ( this )  ;", "}", "}", "@ Override", "public   void   visitMethodCallExpression ( MethodCallExpression   call )     {", "if    (  !  ( call . isImplicitThis (  )  )  )     {", "Expression   target    =    call . getObjectExpression (  )  ;", "if    (  !  ( target   instanceof   MethodCallExpression )  )     {", "restrict ( target ,    formatErrorMessage (  . BASE _ MESSAGE )  )  ;", "return ;", "}", "visitMethodCallExpression (  (  ( MethodCallExpression )     ( target )  )  )  ;", "}", "if    (  ( call . getMethod (  )  )    instanceof   ConstantExpression )     {", "ConstantExpression   methodName    =     (  ( ConstantExpression )     ( call . getMethod (  )  )  )  ;", "if    ( AstUtils . isOfType ( methodName ,    String . class )  )     {", "String   methodNameText    =    methodName . getText (  )  ;", "if    (  ( methodNameText . equals (  \" id \"  )  )     |  |     ( methodNameText . equals (  \" version \"  )  )  )     {", "ConstantExpression   argumentExpression    =    AstUtils . hasSingleConstantArgOfType ( call ,    String . class )  ;", "if    ( argumentExpression    =  =    null )     {", "restrict ( call ,    formatErrorMessage (  . NEED _ SINGLE _ STRING )  )  ;", "return ;", "}", "String   argStringValue    =    argumentExpression . getValue (  )  . toString (  )  ;", "if    (  ( argStringValue . length (  )  )     =  =     0  )     {", "restrict ( argumentExpression ,    formatErrorMessage (  . NEED _ SINGLE _ STRING )  )  ;", "return ;", "}", "if    ( methodName . getText (  )  . equals (  \" id \"  )  )     {", "if    ( call . isImplicitThis (  )  )     {", "try    {", "DefaultPluginId . validate ( argStringValue )  ;", "call . setNodeMetaData ( PluginDependencySpec . class ,    pluginRequestCollector . createSpec ( call . getLineNumber (  )  )  . id ( argStringValue )  )  ;", "}    catch    ( InvalidPluginIdException   e )     {", "restrict ( argumentExpression ,    formatErrorMessage ( e . getReason (  )  )  )  ;", "}", "} else    {", "restrict ( call ,    formatErrorMessage (  . BASE _ MESSAGE )  )  ;", "}", "}", "if    ( methodName . getText (  )  . equals (  \" version \"  )  )     {", "PluginDependencySpec   spec    =    getSpecFor ( call )  ;", "if    ( spec    =  =    null )     {", "return ;", "}", "spec . version ( argStringValue )  ;", "call . setNodeMetaData ( PluginDependencySpec . class ,    spec )  ;", "}", "} else", "if    ( methodNameText . equals (  \" apply \"  )  )     {", "ConstantExpression   arguments    =    AstUtils . hasSingleConstantArgOfType ( call ,    boolean . class )  ;", "if    ( arguments    =  =    null )     {", "restrict ( call ,    formatErrorMessage (  . NEED _ SINGLE _ BOOLEAN )  )  ;", "return ;", "}", "PluginDependencySpec   spec    =    getSpecFor ( call )  ;", "if    ( spec    =  =    null )     {", "return ;", "}", "spec . apply (  (  ( Boolean )     ( arguments . getValue (  )  )  )  )  ;", "} else    {", "if    (  !  ( call . isImplicitThis (  )  )  )     {", "restrict ( methodName ,    formatErrorMessage (  . EXTENDED _ MESSAGE )  )  ;", "} else    {", "restrict ( methodName ,    formatErrorMessage (  . BASE _ MESSAGE )  )  ;", "}", "}", "} else    {", "restrict ( methodName ,    formatErrorMessage (  . NOT _ LITERAL _ ID _ METHOD _ NAME )  )  ;", "}", "} else    {", "restrict ( call )  ;", "}", "}", "private   PluginDependencySpec   getSpecFor ( MethodCallExpression   call )     {", "Expression   objectExpression    =    call . getObjectExpression (  )  ;", "if    ( objectExpression   instanceof   MethodCallExpression )     {", "return   objectExpression . getNodeMetaData ( PluginDependencySpec . class )  ;", "} else    {", "restrict ( call ,    formatErrorMessage (  . BASE _ MESSAGE )  )  ;", "return   null ;", "}", "}", "@ Override", "public   void   visitExpressionStatement ( ExpressionStatement   statement )     {", "statement . getExpression (  )  . visit ( this )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["extract"], "fileName": "org.gradle.plugin.use.internal.PluginUseScriptBlockMetadataExtractor"}, {"methodBody": ["METHOD_START", "{", "return   String . format (  \"  % s % n % nSee    % s   for   information   on   the   plugins    {  }    block % n % n \"  ,    message ,    documentationRegistry . getDocumentationFor (  \" plugins \"  ,     \" sec : plugins _ block \"  )  )  ;", "}", "METHOD_END"], "methodName": ["formatErrorMessage"], "fileName": "org.gradle.plugin.use.internal.PluginUseScriptBlockMetadataExtractor"}, {"methodBody": ["METHOD_START", "{", "return   pluginRequestCollector . getPluginRequests (  )  ;", "}", "METHOD_END"], "methodName": ["getPluginRequests"], "fileName": "org.gradle.plugin.use.internal.PluginUseScriptBlockMetadataExtractor"}, {"methodBody": ["METHOD_START", "{", "String   executable    =    getExecutable (  )  ;", "if    ( StringUtils . isEmpty ( executable )  )     {", "throw   new   IllegalStateException (  \" execCommand    =  =    null !  \"  )  ;", "}", "StreamsHandler   effectiveOutputHandler    =    getEffectiveStreamsHandler (  )  ;", "return   new   Defaul ( getDisplayName (  )  ,    getWorkingDir (  )  ,    executable ,    getAllArguments (  )  ,    getActualEnvironment (  )  ,    effectiveOutputHandler ,    inputHandler ,    listeners ,    redirectErrorStream ,    timeoutMillis ,    daemon ,    executor )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "List < String >    commandLine    =    new   ArrayList < String >  (  )  ;", "commandLine . add ( geutable (  )  )  ;", "commandLine . addAll ( getAllArguments (  )  )  ;", "return   commandLine ;", "}", "METHOD_END"], "methodName": ["getCommandLine"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return    ( displayName )     =  =    null    ?    String . format (  \" command    '  % s '  \"  ,    getExecutable (  )  )     :    displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "StreamsHandler   effectiveHandler ;", "if    (  ( this . streamsHandler )     !  =    null )     {", "effectiveHandler    =    this . streamsHandler ;", "} else    {", "boolean   shouldReadErrorStream    =     !  ( redirectErrorStream )  ;", "effectiveHandler    =    new   OutputStreamsForwarder ( standardOutput ,    errorOutput ,    shouldReadErrorStream )  ;", "}", "return   effectiveHandler ;", "}", "METHOD_END"], "methodName": ["getEffectiveStreamsHandler"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   errorOutput ;", "}", "METHOD_END"], "methodName": ["getErrorOutput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   inputHandler ;", "}", "METHOD_END"], "methodName": ["getInputHandler"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   input ;", "}", "METHOD_END"], "methodName": ["getStandardInput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   standardOutput ;", "}", "METHOD_END"], "methodName": ["getStandardOutput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   ignoreExitValue ;", "}", "METHOD_END"], "methodName": ["isIgnoreExitValue"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( listeners )     =  =    null )     {", "throw   new   IllegalArgumenception (  \" listeners    =  =    null !  \"  )  ;", "}", "this . listeners . add ( listener )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["listener"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . redirectErrorStream    =    true ;", "return   this ;", "}", "METHOD_END"], "methodName": ["redirectErrorStream"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . displayName    =    displayName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDisplayName"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( outputStream    =  =    null )     {", "throw   new   IllegalArgumenception (  \" outputStream    =  =    null !  \"  )  ;", "}", "this . errorOutput    =    outputStream ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setErrorOutput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . ignoreExitValue    =    ignoreExitValue ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIgnoreExitValue"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . input    =    inputStream ;", "this . inputr    =    new   ForwardStdinStreamsr ( inputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardInput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( outputStream    =  =    null )     {", "throw   new   IllegalArgumenception (  \" outputStream    =  =    null !  \"  )  ;", "}", "this . standardOutput    =    outputStream ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardOutput"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . timeoutMillis    =    timeoutMillis ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . streamsHandler    =    streamsHandler ;", "return   this ;", "}", "METHOD_END"], "methodName": ["streamsHandler"], "fileName": "org.gradle.process.internal.AbstractExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   RuntimeException (  \" broken \"  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.BrokenRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "TestListenerInterface   sender    =    workerProcessContext . getServerConnection (  )  . addOutgoing ( TestListenerInterface . class )  ;", "workerProcessContext . getServerConnection (  )  . connect (  )  ;", "sender . send (  \" message    1  \"  ,     1  )  ;", "sender . send (  \" message    2  \"  ,     2  )  ;", "Runtime . getRuntime (  )  . halt (  1  2  3  4  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.CrashingRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "return   jvm ;", "}", "METHOD_END"], "methodName": ["getJvm"], "fileName": "org.gradle.process.internal.CurrentProcess"}, {"methodBody": ["METHOD_START", "{", "return   effectiveJvmOptions ;", "}", "METHOD_END"], "methodName": ["getJvmOptions"], "fileName": "org.gradle.process.internal.CurrentProcess"}, {"methodBody": ["METHOD_START", "{", "JvmOptions   jvmOptions    =    new   JvmOptions ( new   IdentityFileResolver (  )  )  ;", "jvmOptions . setAllJvmArgs ( ManagementFactory . getRuntimeMXBean (  )  . getInputArguments (  )  )  ;", "return   jvmOptions ;", "}", "METHOD_END"], "methodName": ["inferJvmOptions"], "fileName": "org.gradle.process.internal.CurrentProcess"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    build (  )  ;", "ExecResult   execResult    =    execHandle . start (  )  . waitForFinish (  )  ;", "if    (  !  ( isIgnoreExitValue (  )  )  )     {", "execResult . assertNormalExitValue (  )  ;", "}", "return   execResult ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.DefaultExecAction"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    ( stateIn ( SUCCEEDED ,    FAILED ,    ABORTED )  )     {", "return ;", "}", "if    (  !  ( stateIn ( STARTED ,    DETACHED )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   abort   process    '  % s '    because   it   is   not   in   started   or   detached   state \"  ,    displayName )  )  ;", "}", "this . eRunner . abortProcess (  )  ;", "this . waitForFinish (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["abort"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( exitCode    =  =     0  )     {", "exitCode    =     -  1  ;", "}", "setEndStaInfo ( ABORTED ,    exitCode ,    null )  ;", "}", "METHOD_END"], "methodName": ["aborted"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "broadcast . add ( listener )  ;", "}", "METHOD_END"], "methodName": ["addListener"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "setEndStateInfo ( DETACHED ,     0  ,    null )  ;", "}", "METHOD_END"], "methodName": ["detached"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   failureCause    !  =    null    ?    new   ExecException ( failureMessageFor ( currentState )  ,    failureCause )     :    null ;", "}", "METHOD_END"], "methodName": ["execExceptionFor"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "setEndStateInfo ( FAILED ,     (  -  1  )  ,    failureCause )  ;", "}", "METHOD_END"], "methodName": ["failed"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   currentState    =  =     ( ExecHandleState . STARTING )     ?    String . format (  \" A   problem   occurred   starting   process    '  % s '  \"  ,    displayName )     :    String . format (  \" A   problem   occurred   waiting   for   process    '  % s '    to   complete .  \"  ,    displayName )  ;", "}", "METHOD_END"], "methodName": ["failureMessageFor"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "if    ( exitCode    !  =     0  )     {", "setEndStaInfo ( FAILED ,    exitCode ,    null )  ;", "} else    {", "setEndStaInfo ( SUCCEEDED ,     0  ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["finished"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( arguments )  ;", "}", "METHOD_END"], "methodName": ["getArguments"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   command ;", "}", "METHOD_END"], "methodName": ["getCommand"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["getDirectory"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   displayName ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableMap ( environment )  ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   redirectErrorStream ;", "}", "METHOD_END"], "methodName": ["getRedirectErrorStream"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "return   state ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   timeoutMillis ;", "}", "METHOD_END"], "methodName": ["getTimeout"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "return   daemon ;", "}", "METHOD_END"], "methodName": ["isDaemon"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "broadcast . remove ( listener )  ;", "}", "METHOD_END"], "methodName": ["removeListener"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "return   eResult . rethrowFailure (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["result"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "ShutdownHookActionRegister . removeAction ( shutdownHookAction )  ;", "ExecHandleState   currentState ;", "lock . lock (  )  ;", "try    {", "currentState    =    this . state ;", "}    finally    {", "lock . unlock (  )  ;", "}", ". ExecResultImpl   newResult    =    new    . ExecResultImpl ( exitValue ,    execExceptionFor ( failureCause ,    currentState )  ,    displayName )  ;", "if    (  (  !  ( currentState . isTerminal (  )  )  )     &  &     ( newState    !  =     ( ExecHandleState . DETACHED )  )  )     {", "try    {", "broadcast . getSource (  )  . executionFinished ( this ,    newResult )  ;", "}    catch    ( Exception   e )     {", "newResult    =    new    . ExecResultImpl ( exitValue ,    execExceptionFor ( e ,    currentState )  ,    displayName )  ;", "}", "}", "lock . lock (  )  ;", "try    {", "setState ( newState )  ;", "this . execResult    =    newResult ;", "}    finally    {", "lock . unlock (  )  ;", "}", ". LOGGER . debug (  \" Process    '  {  }  '    finished   with   exit   value    {  }     ( state :     {  }  )  \"  ,    displayName ,    exitValue ,    newState )  ;", "}", "METHOD_END"], "methodName": ["setEndStateInfo"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", ". LOGGER . debug (  \" Changing   state   to :     {  }  \"  ,    state )  ;", "this . state    =    state ;", "this . stateChanged . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "DefaultExecHandle . LOGGER . info (  \" Starting   process    '  {  }  '  .    Working   directory :     {  }    Command :     {  }  \"  ,    displayName ,    directory ,     (  (  ( command )     +     '     '  )     +     ( Joiner . on (  '     '  )  . useForNull (  \" null \"  )  . join ( arguments )  )  )  )  ;", "if    ( DefaultExecHandle . LOGGER . isDebugEnabled (  )  )     {", "DefaultExecHandle . LOGGER . debug (  \" Environment   for   process    '  {  }  '  :     {  }  \"  ,    displayName ,    environment )  ;", "}", "lock . lock (  )  ;", "try    {", "if    (  !  ( stateIn ( INIT )  )  )     {", "throw   new   IllegalStateException ( String . format (  \" Cannot   start   process    '  % s '    because   it   has   already   been   started \"  ,    displayName )  )  ;", "}", "setState ( STARTING )  ;", "execHandleRunner    =    new   ExecHandleRunner ( this ,    new   DefaultExecHandle . CompositeStreamsHandler (  )  ,    processLauncher ,    executor )  ;", "executor . execute ( new   CurrentBuildOperationPreservingRunnable ( execHandleRunner )  )  ;", "while    ( stateIn ( STARTING )  )     {", "DefaultExecHandle . LOGGER . debug (  \" Waiting   until   process   started :     {  }  .  \"  ,    displayName )  ;", "try    {", "stateChanged . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "if    (  ( execResult )     !  =    null )     {", "execResult . rethrowFailure (  )  ;", "}", "DefaultExecHandle . LOGGER . info (  \" Successfully   started   process    '  {  }  '  \"  ,    displayName )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "ShutdownHookActionRegister . addAction ( shutdownHookAction )  ;", "setState ( STARTED )  ;", "broadcast . getSource (  )  . executionStarted ( this )  ;", "}", "METHOD_END"], "methodName": ["started"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "return   Arrays . asList ( states )  . contains ( this . state )  ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stateIn"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "while    (  !  ( state . isTerminal (  )  )  )     {", "try    {", "stateChanged . await (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "return   result (  )  ;", "}", "METHOD_END"], "methodName": ["waitForFinish"], "fileName": "org.gradle.process.internal.DefaultExecHandle"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( arguments ,    args )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( args    =  =    null )     {", "throw   new   IllegalArgumenception (  \" args    =  =    null !  \"  )  ;", "}", "this . arguments . addAll ( Arrays . asList ( args )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "List < Object >    argsList    =    Lists . newArrayList ( args )  ;", "eutable ( argsList . get (  0  )  )  ;", "setArgs ( argsList . subList (  1  ,    argsList . size (  )  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["commandLine"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "commandLine ( Arrays . asList ( arguments )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["commandLine"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . executable ( executable )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["executable"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   ArrayList < String >  (  )  ;", "for    ( Object   argument    :    arguments )     {", "args . add ( argument . toString (  )  )  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . listener ( listener )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["listener"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . redirectErrorStream (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["redirectErrorStream"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . arguments . clear (  )  ;", "GUtil . addToCollection ( this . arguments ,    arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . arguments . clear (  )  ;", "this . arguments . addAll ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "commandLine ( args )  ;", "}", "METHOD_END"], "methodName": ["setCommandLine"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "commandLine ( args )  ;", "}", "METHOD_END"], "methodName": ["setCommandLine"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "commandLine ( args )  ;", "}", "METHOD_END"], "methodName": ["setCommandLine"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . daemon    =    daemon ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDaemon"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . setStandardInput ( inputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardInput"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . setStandardOutput ( outputStream )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStandardOutput"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "super . setTimeout ( timeoutMillis )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.gradle.process.internal.DefaultExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "ExecHandle   execHandle    =    build (  )  ;", "ExecResult   execResult    =    execHandle . start (  )  . waitForFinish (  )  ;", "if    (  !  ( isIgnoreExitValue (  )  )  )     {", "execResult . assertNormalExitValue (  )  ;", "}", "return   execResult ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.DefaultJavaExecAction"}, {"methodBody": ["METHOD_START", "{", "options . bootstrapClasspath ( classpath )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bootstrapClasspath"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "super . copyTo ( target )  ;", "o . copyTo ( target )  ;", "if    (  ( jvmArgumentProviders )     !  =    null )     {", "for    ( CommandLineArgumentProvider   jvmArgumentProvider    :    jvmArgumentProviders )     {", "target . jvmArgs ( jvmArgumentProvider . asArguments (  )  )  ;", "}", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "if    ( DefaultJavaForkOptions . hasJvmArgumentProviders ( this )  )     {", "JvmOptions   copy    =    options . createCopy (  )  ;", "for    ( CommandLineArgumentProvider   jvmArgumentProvider    :    jvmArgumentProviders )     {", "copy . jvmArgs ( jvmArgumentProvider . asArguments (  )  )  ;", "}", "return   copy . getAllJvmArgs (  )  ;", "} else    {", "return   options . getAllJvmArgs (  )  ;", "}", "}", "METHOD_END"], "methodName": ["getAllJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getBootstrapClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getBootstrapClasspath"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getDebug (  )  ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getDefaultCharacterEncoding (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getEnableAssertions (  )  ;", "}", "METHOD_END"], "methodName": ["getEnableAssertions"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getMaxHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxHeapSize"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getMinHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeapSize"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return   options . getMutableSystemProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getSystemProperties"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return    ( forkOptions   instanceof   DefaultJavaForkOptions )     &  &     ( DefaultJavaForkOptions . hasJvmArgumentProviders (  (  ( DefaultJavaForkOptions )     ( forkOptions )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasJvmArgumentProviders"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "return    (  ( forkOptions . jvmArgumentProviders )     !  =    null )     &  &     (  !  ( forkOptions . jvmArgumentProviders . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasJvmArgumentProviders"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . jvmArgs ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( Arrays . asList ( arguments )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setAllJvmArgs ( arguments )  ;", "if    (  . hasJvmArgumentProviders ( this )  )     {", "jvmArgumentProviders . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setAllJvmArgs ( arguments )  ;", "if    (  . hasJvmArgumentProviders ( this )  )     {", "jvmArgumentProviders . clear (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setBootstrapClasspath ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setBootstrapClasspath"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setDebug ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setDefaultCharacterEncoding ( defaultCharacterEncoding )  ;", "}", "METHOD_END"], "methodName": ["setDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setEnableAssertions ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setEnableAssertions"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setMaxHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxHeapSize"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setMinHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMinHeapSize"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . setSystemProperties ( properties )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperties"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . systemProperties ( properties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperties"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "options . systemProperty ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperty"], "fileName": "org.gradle.process.internal.DefaultJavaForkOptions"}, {"methodBody": ["METHOD_START", "{", "target . setExecutable ( executable )  ;", "target . setWingDir ( getWingDir (  )  )  ;", "target . setEnvironment ( getEnvironment (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "getEnvironment (  )  . put ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["environment"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "getEnvironment (  )  . putAll ( environmentVariables )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["environment"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "setExecutable ( executable )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["executable"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    actu =    new   HashMap < String ,    String >  (  )  ;", "for    ( Map . Entry < String ,    Object >    entry    :    getEnvironment (  )  . entrySet (  )  )     {", "actuput ( entry . getKey (  )  ,    String . veOf ( entry . getVe (  )  )  )  ;", "}", "return   actu", "}", "METHOD_END"], "methodName": ["getActualEnvironment"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( environment )     =  =    null )     {", "setEnvironment ( Jvm . current (  )  . getInheritableEnvironmentVariables ( System . getenv (  )  )  )  ;", "}", "return   environment ;", "}", "METHOD_END"], "methodName": ["getEnvironment"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "return    ( executable )     =  =    null    ?    null    :    executable . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getExecutable"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( workingDir )     =  =    null )     {", "workingDir    =    resolver . resolve (  \"  .  \"  )  ;", "}", "return   workingDir ;", "}", "METHOD_END"], "methodName": ["getWorkingDir"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "environment    =    Maps . newHashMap ( environmentVariables )  ;", "}", "METHOD_END"], "methodName": ["setEnvironment"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "this . executable    =    executable ;", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "this . executable    =    executable ;", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "this . workingDir    =    resolver . resolve ( dir )  ;", "}", "METHOD_END"], "methodName": ["setWorkingDir"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "this . workingDir    =    resolver . resolve ( dir )  ;", "}", "METHOD_END"], "methodName": ["setWorkingDir"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "setWorkingDir ( dir )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["workingDir"], "fileName": "org.gradle.process.internal.DefaultProcessForkOptions"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "aborted    =    true ;", "if    (  ( process )     !  =    null )     {", ". LOGGER . debug (  \" Abort   requested .    Destroying   process :     {  }  .  \"  ,    execHandle . getDisplayName (  )  )  ;", "process . destroy (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["abortProcess"], "fileName": "org.gradle.process.internal.ExecHandleRunner"}, {"methodBody": ["METHOD_START", "{", "if    ( aborted )     {", "e . aborted ( exitValue )  ;", "} else    {", "e . finished ( exitValue )  ;", "}", "}", "METHOD_END"], "methodName": ["completed"], "fileName": "org.gradle.process.internal.ExecHandleRunner"}, {"methodBody": ["METHOD_START", "{", "execHandle . detached (  )  ;", "}", "METHOD_END"], "methodName": ["detached"], "fileName": "org.gradle.process.internal.ExecHandleRunner"}, {"methodBody": ["METHOD_START", "{", "try    {", "ProcessBuilder   processBuilder    =    processBuilderFactory . createProcessBuilder ( execHandle )  ;", "Process   process    =    processLauncher . start ( processBuilder )  ;", "streamsHandler . connectStreams ( process ,    execHandle . getDisplayName (  )  ,    executor )  ;", "setProcess ( process )  ;", "execHandle . started (  )  ;", ". LOGGER . debug (  \" waiting   until   streams   are   handled .  .  .  \"  )  ;", "streamsHandler . start (  )  ;", "if    ( execHandle . isDaemon (  )  )     {", "streamsHandler . stop (  )  ;", "detached (  )  ;", "} else    {", "int   exitValue    =    process . waitFor (  )  ;", "streamsHandler . stop (  )  ;", "completed ( exitValue )  ;", "}", "}    catch    ( Throwable   t )     {", "execHandle . failed ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.process.internal.ExecHandleRunner"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "this    =  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setProcess"], "fileName": "org.gradle.process.internal.ExecHandleRunner"}, {"methodBody": ["METHOD_START", "{", "try    {", "execHandle . abort (  )  ;", "}    catch    ( Throwable   t )     {", ". LOGGER . error (  (  \" failed   to   abort    \"     +     ( execHandle )  )  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.process.internal.ExecHandleShutdownHookAction"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( applicationArgs ,    true ,    args )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "args ( Arrays . asList ( args )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["args"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "bootstrapClasspath ( classpath )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["bootstrapClasspath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mainClass )     =  =    null )     {", "throw   new   IllegalStateException (  \" No   main   class   specified \"  )  ;", "}", "return   super . b (  )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "classpath    =    classpath . plus ( fileResolver . resolveFiles ( paths )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["classpath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "List < String >    allArgs    =    new   ArrayList < String >  ( getAllJvmArgs (  )  )  ;", "if    (  !  ( classpath . isEmpty (  )  )  )     {", "allArgs . add (  \"  - cp \"  )  ;", "allArgs . add ( CollectionUtils . join ( FiathSeparator ,    classpath )  )  ;", "}", "return   allArgs ;", "}", "METHOD_END"], "methodName": ["getAllJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "List < String >    a    =    new   ArrayList < String >  (  )  ;", "for    ( Object   applicationA :    applicationA )     {", "a . add ( applicationAtoString (  )  )  ;", "}", "return   a ;", "}", "METHOD_END"], "methodName": ["getArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getBootstrapClasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getBootstrapClasspath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getDebug (  )  ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getDefaultCharacterEncoding (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getEnableAssertions (  )  ;", "}", "METHOD_END"], "methodName": ["getEnableAssertions"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getJvmArgs (  )  ;", "}", "METHOD_END"], "methodName": ["getJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   mainClass ;", "}", "METHOD_END"], "methodName": ["getMain"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getMaxHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMaxHeapSize"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getMinHeapSize (  )  ;", "}", "METHOD_END"], "methodName": ["getMinHeapSize"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "return   getSystemProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getSystemProperties"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( arguments )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . applicationArgs . clear (  )  ;", "args ( applicationArgs )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . applicationArgs . clear (  )  ;", "args ( applicationArgs )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setBootstrapClasspath ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setBootstrapClasspath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setDebug ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setDefaultCharacterEncoding ( defaultCharacterEncoding )  ;", "}", "METHOD_END"], "methodName": ["setDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setEnableAssertions ( enabled )  ;", "}", "METHOD_END"], "methodName": ["setEnableAssertions"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setJvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "this . mainClass    =    mainClassName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMain"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setMaxHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMaxHeapSize"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setMinHeapSize ( heapSize )  ;", "}", "METHOD_END"], "methodName": ["setMinHeapSize"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "setSystemProperties ( properties )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperties"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "systemProperties ( properties )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperties"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "systemProperty ( name ,    value )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["systemProperty"], "fileName": "org.gradle.process.internal.JavaExecHandleBuilder"}, {"methodBody": ["METHOD_START", "{", "internalGetBootstrapCLasspath (  )  . from ( classpath )  ;", "}", "METHOD_END"], "methodName": ["bootstrapClasspath"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "target . setJvmArgs ( extraJvmArgs )  ;", "target . setSystemProperties ( mutableSystemProperties )  ;", "target . setMinHeapSize ( minHeapSize )  ;", "target . setMaxHeapSize ( maxHeapSize )  ;", "target . setBootstrapClasspath ( getBootstrapClasspath (  )  )  ;", "target . setEnableAsser ( asserEnabled )  ;", "target . setDebug ( debug )  ;", "target . systemProperties ( immutableSystemProperties )  ;", "}", "METHOD_END"], "methodName": ["copyTo"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "JvmOptions   target    =    new   JvmOptions ( resolver )  ;", "target . setJvmArgs ( extraJvmArgs )  ;", "target . setSystemProperties ( mutableSystemProperties )  ;", "target . setMinHeapSize ( minHeapSize )  ;", "target . setMaxHeapSize ( maxHeapSize )  ;", "if    (  ( bootstrapClasspath )     !  =    null )     {", "target . setBootstrapClasspath ( getBootstrapClasspath (  )  )  ;", "}", "target . setEnableAssertions ( assertionsEnabled )  ;", "target . setDebug ( debug )  ;", "target . systemProperties ( immutableSystemProperties )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["createCopy"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,     ?  >    entry    :    properties . entrySet (  )  )     {", "if    (  (  ( entry . getValue (  )  )     !  =    null )     &  &     (  ( entry . getValue (  )  . toString (  )  . length (  )  )     >     0  )  )     {", "args . add (  (  (  (  \"  - D \"     +     ( entry . getKey (  )  )  )     +     \"  =  \"  )     +     ( entry . getValue (  )  . toString (  )  )  )  )  ;", "} else    {", "args . add (  (  \"  - D \"     +     ( entry . getKey (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["formatSystemProperties"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   ArgumentsSplitter . split ( input )  ;", "}", "METHOD_END"], "methodName": ["fromString"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   ArrayList < String >  ( getJvmArgs (  )  )  ;", "args . addAll ( getManagedJvmArgs (  )  )  ;", "return   args ;", "}", "METHOD_END"], "methodName": ["getAllImmutableJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   LinkedList < String >  (  )  ;", "formatSystemProperties ( getMutableSystemProperties (  )  ,    args )  ;", "args . addAll ( getAllImmutableArgs (  )  )  ;", "return   args ;", "}", "METHOD_END"], "methodName": ["getAllJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   internalGetBootstrapCLasspath (  )  ;", "}", "METHOD_END"], "methodName": ["getBootstrapClasspath"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   debug ;", "}", "METHOD_END"], "methodName": ["getDebug"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   immutableSystemProperties . get ( JvmOptions . FILE _ ENCODING _ KEY )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   assertionsEnabled ;", "}", "METHOD_END"], "methodName": ["getEnableAssertions"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   immutableSystemProperties ;", "}", "METHOD_END"], "methodName": ["getImmutableSystemProperties"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   ArrayList < String >  (  )  ;", "for    ( Object   extraArg    :    extraArgs )     {", "args . add ( extraArg . toString (  )  )  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "List < String >    args    =    new   ArrayList < String >  (  )  ;", "if    (  ( minHeapSize )     !  =    null )     {", "args . add (  (  (  . XMS _ PREFIX )     +     ( minHeapSize )  )  )  ;", "}", "if    (  ( maxHeapSize )     !  =    null )     {", "args . add (  (  (  . XMX _ PREFIX )     +     ( maxHeapSize )  )  )  ;", "}", "if    (  (  ( bootstrapClasspath )     !  =    null )     &  &     (  !  ( bootstrapClasspath . isEmpty (  )  )  )  )     {", "args . add (  (  (  . BOOTCLASSPATH _ PREFIX )     +     ( bootstrapClasspath . getAsPath (  )  )  )  )  ;", "}", "formatSystemProperties ( immutableSystemProperties ,    args )  ;", "if    ( assertionsEnabled )     {", "args . add (  \"  - ea \"  )  ;", "}", "if    ( debug )     {", "args . add (  \"  - agentlib : jdwp = transport = dt _ socket , server = y , suspend = y , address =  5  0  0  5  \"  )  ;", "}", "return   args ;", "}", "METHOD_END"], "methodName": ["getManagedJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   maxHeapSize ;", "}", "METHOD_END"], "methodName": ["getMaxHeapSize"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   minHeapSize ;", "}", "METHOD_END"], "methodName": ["getMinHeapSize"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "return   mutableSystemProperties ;", "}", "METHOD_END"], "methodName": ["getMutableSystemProperties"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "if    (  ( bootstrapClasspath )     =  =    null )     {", "bootstrapClasspath    =    new   DefaultConfigurableFileCollec ( resolver ,    null )  ;", "}", "return   bootstrapClasspath ;", "}", "METHOD_END"], "methodName": ["internalGetBootstrapCLasspath"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   argument    :    arguments )     {", "String   argStr    =    argument . toString (  )  ;", "if    (  ( argStr . equals (  \"  - ea \"  )  )     |  |     ( argStr . equals (  \"  - enableassertions \"  )  )  )     {", "assertionsEnabled    =    true ;", "} else", "if    (  ( argStr . equals (  \"  - da \"  )  )     |  |     ( argStr . equals (  \"  - disableassertions \"  )  )  )     {", "assertionsEnabled    =    false ;", "} else", "if    ( argStr . startsWith (  . XMS _ PREFIX )  )     {", "minHeapSize    =    argStr . substring (  . XMS _ PREFIX . length (  )  )  ;", "} else", "if    ( argStr . startsWith (  . XMX _ PREFIX )  )     {", "maxHeapSize    =    argStr . substring (  . XMX _ PREFIX . length (  )  )  ;", "} else", "if    ( argStr . startsWith (  . BOOTCLASSPATH _ PREFIX )  )     {", "String [  ]    bootClasspath    =    split ( argStr . substring (  . BOOTCLASSPATH _ PREFIX . length (  )  )  ,    pathSeparatorChar )  ;", "setBootstrapClasspath (  (  ( Object [  ]  )     ( bootClasspath )  )  )  ;", "} else", "if    ( argStr . startsWith (  \"  - D \"  )  )     {", "String   keyValue    =    argStr . substring (  2  )  ;", "int   equalsIndex    =    keyValue . indexOf (  \"  =  \"  )  ;", "if    ( equalsIndex    =  =     (  -  1  )  )     {", "systemProperty ( keyValue ,     \"  \"  )  ;", "} else    {", "systemProperty ( keyValue . substring (  0  ,    equalsIndex )  ,    keyValue . substring (  ( equalsIndex    +     1  )  )  )  ;", "}", "} else    {", "extraJvmArgs . add ( argument )  ;", "}", "}", "boolean   xdebugFound    =    false ;", "boolean   xrunjdwpFound    =    false ;", "boolean   xagentlibJdwpFound    =    false ;", "Set < Object >    matches    =    new   HashSet < Object >  (  )  ;", "for    ( Object   extraJvmArg    :    extraJvmArgs )     {", "if    ( extraJvmArg . toString (  )  . equals (  \"  - Xdebug \"  )  )     {", "xdebugFound    =    true ;", "matches . add ( extraJvmArg )  ;", "} else", "if    ( extraJvmArg . toString (  )  . equals (  \"  - Xrunjdwp : transport = dt _ socket , server = y , suspend = y , address =  5  0  0  5  \"  )  )     {", "xrunjdwpFound    =    true ;", "matches . add ( extraJvmArg )  ;", "} else", "if    ( extraJvmArg . toString (  )  . equals (  \"  - agentlib : jdwp = transport = dt _ socket , server = y , suspend = y , address =  5  0  0  5  \"  )  )     {", "xagentlibJdwpFound    =    true ;", "matches . add ( extraJvmArg )  ;", "}", "}", "if    (  ( xdebugFound    &  &    xrunjdwpFound )     |  |    xagentlibJdwpFound )     {", "debug    =    true ;", "extraJvmArgs . removeAll ( matches )  ;", "}", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "jvmArgs ( Arrays . asList ( arguments )  )  ;", "}", "METHOD_END"], "methodName": ["jvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "mutableSystemProperties . clear (  )  ;", "minHeapSize    =    null ;", "maxHeapSize    =    null ;", "extraJvmArgs . clear (  )  ;", "asserEnabled    =    false ;", "debug    =    false ;", "jvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setAllJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "internalGetBootstrapCLasspath (  )  . setFrom ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setBootstrapClasspath"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "internalGetBootstrapCLasspath (  )  . setFrom ( classpath )  ;", "}", "METHOD_END"], "methodName": ["setBootstrapClasspath"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "debug    =    enabled ;", "}", "METHOD_END"], "methodName": ["setDebug"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "immutableSystemProperties . put ( JvmOptions . FILE _ ENCODING _ KEY ,     ( GUtil . isTrue ( defaultCharacterEncoding )     ?    defaultCharacterEncoding    :    Charset . defaultCharset (  )  . name (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setDefaultCharacterEncoding"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "assertionsEnabled    =    enabled ;", "}", "METHOD_END"], "methodName": ["setEnableAssertions"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "extraJvmArgs . clear (  )  ;", "jvmArgs ( arguments )  ;", "}", "METHOD_END"], "methodName": ["setJvmArgs"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "this . maxHeapSize    =    heapSize ;", "}", "METHOD_END"], "methodName": ["setMaxHeapSize"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "this . minHeapSize    =    heapSize ;", "}", "METHOD_END"], "methodName": ["setMinHeapSize"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "mutableSystemProperties . clear (  )  ;", "systemProperties ( perties )  ;", "}", "METHOD_END"], "methodName": ["setSystemProperties"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "for    ( Map . Entry < String ,     ?  >    entry    :    properties . entrySet (  )  )     {", "systemProperty ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["systemProperties"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "if    ( JvmOptions . IMMUTABLE _ SYSTEM _ PROPERTIES . contains ( name )  )     {", "immutableSystemProperties . put ( name ,    value )  ;", "} else    {", "mutableSystemProperties . put ( name ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["systemProperty"], "fileName": "org.gradle.process.internal.JvmOptions"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "new   Thread ( new   Runnable (  )     {", "public   void   run (  )     {", "latch . countDown (  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "System . out . println (  (  (  \" m    \"     +    i )     +     \"  .  .  .  \"  )  )  ;", "}", "}", "}  )  . start (  )  ;", "try    {", "latch . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.MessageProducingProcess"}, {"methodBody": ["METHOD_START", "{", "final   Lock   lock    =    new   ReentrantLock (  )  ;", "lock . lock (  )  ;", "new   Thread ( new   Runnable (  )     {", "public   void   run (  )     {", "lock . lock (  )  ;", "}", "}  )  . start (  )  ;", "TestListenerInterface   sender    =    workerContext . getServerConnection (  )  . addOutgoing ( TestListenerInterface . class )  ;", "workerContext . getServerConnection (  )  . connect (  )  ;", "sender . send (  \" message    1  \"  ,     1  )  ;", "sender . send (  \" message    2  \"  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.NoCleanUpRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.NotDeserializable"}, {"methodBody": ["METHOD_START", "{", "throw   new   IOException (  \" Broken \"  )  ;", "}", "METHOD_END"], "methodName": ["readObject"], "fileName": "org.gradle.process.internal.NotDeserializable"}, {"methodBody": ["METHOD_START", "{", "TestListenerInterface   sender    =    workerProcessContext . getServerConnection (  )  . addOutgoing ( TestListenerInterface . class )  ;", "workerProcessContext . getServerConnection (  )  . connect (  )  ;", "sender . send (  \" other    1  \"  ,     1  )  ;", "sender . send (  \" other    2  \"  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.OtherRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "stopReceived    =    new   CountDownLatch (  1  )  ;", "workerContext . getServerConnection (  )  . addIncoming ( TestListenerInterface . class ,    this )  ;", "workerContext . getServerConnection (  )  . connect (  )  ;", "try    {", "stopReceived . await (  )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.PingRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( this . count ,    count )  ;", "( this . count )  +  +  ;", "if    ( mage . equals (  \" stop \"  )  )     {", "assertEquals (  4  ,    this . count )  ;", "stopReceived . countDown (  )  ;", "}", "}", "METHOD_END"], "methodName": ["send"], "fileName": "org.gradle.process.internal.PingRemoteProcess"}, {"methodBody": ["METHOD_START", "{", "List < String >    commandWithArguments    =    new   ArrayList < String >  (  )  ;", "commandWithArguments . add ( processSettings . getCommand (  )  )  ;", "commandWithArguments . addAll ( processSettings . getArguments (  )  )  ;", "processBuilder    =    new    ( commandWithArguments )  ;", "processBuilder . directory ( processSettings . getDirectory (  )  )  ;", "processBuilder . redirectErrorStream ( processSettings . getRedirectErrorStream (  )  )  ;", "Map < String ,    String >    environment    =    processBuilder . environment (  )  ;", "environment . clear (  )  ;", "environment . putAll ( processSettings . getEnvironment (  )  )  ;", "return   processBuilder ;", "}", "METHOD_END"], "methodName": ["createProcessBuilder"], "fileName": "org.gradle.process.internal.ProcessBuilderFactory"}, {"methodBody": ["METHOD_START", "{", "assertThat ( System . getProperty (  \" test . system . property \"  )  ,    equalTo (  \" value \"  )  )  ;", "assertThat ( System . getenv (  )  . get (  \" TEST _ ENV _ VAR \"  )  ,    equalTo (  \" value \"  )  )  ;", "ClassLoader   antClassLoader    =    Project . class . getClassLoader (  )  ;", "ClassLoader   thisClassLoader    =    getClass (  )  . getClassLoader (  )  ;", "ClassLoader   systemClassLoader    =    ClassLoader . getSystemClassLoader (  )  ;", "assertThat ( antClassLoader ,    sameInstance ( systemClassLoader )  )  ;", "assertThat ( thisClassLoader ,    not ( sameInstance ( systemClassLoader )  )  )  ;", "assertThat ( thisClassLoader . getParent (  )  . getParent (  )  ,    equalTo ( systemClassLoader )  )  ;", "try    {", "assertThat ( thisClassLoader . loadClass ( Project . class . getName (  )  )  ,    sameInstance (  (  ( Object )     ( Project . class )  )  )  )  ;", "}    catch    ( ClassNotFoundException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "TestListenerInterface   sender    =    workerContext . getServerConnection (  )  . addOutgoing ( TestListenerInterface . class )  ;", "workerContext . getServerConnection (  )  . connect (  )  ;", "sender . send (  \" message    1  \"  ,     1  )  ;", "sender . send (  \" message    2  \"  ,     2  )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.RemoteProcess"}, {"methodBody": ["METHOD_START", "{", "System . out . print (  (  \" output   args :     \"     +     ( Arrays . asList ( args )  )  )  )  ;", "System . err . print (  (  \" error   args :     \"     +     ( Arrays . asList ( args )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.gradle.process.internal.TestApp"}, {"methodBody": ["METHOD_START", "{", "ShutdownHookActionRegister . INSTANCE . shutdownHookActions . add ( shutdownHookAction )  ;", "}", "METHOD_END"], "methodName": ["addAction"], "fileName": "org.gradle.process.internal.shutdown.ShutdownHookActionRegister"}, {"methodBody": ["METHOD_START", "{", "ShutdownHookActionRegister . INSTANCE . shutdownHookActions . remove ( shutdownHookAction )  ;", "}", "METHOD_END"], "methodName": ["removeAction"], "fileName": "org.gradle.process.internal.shutdown.ShutdownHookActionRegister"}, {"methodBody": ["METHOD_START", "{", "inputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["closeInput"], "fileName": "org.gradle.process.internal.streams.ExecOutputHandleRunner"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    buffer    =    new   byte [ bufferSize ]  ;", "try    {", "while    ( true )     {", "int   nread    =    inputStream . read ( buffer )  ;", "if    ( nread    <     0  )     {", "break ;", "}", "outputStream . write ( buffer ,     0  ,    nread )  ;", "outputStream . flush (  )  ;", "}", "CompositeStoppable . stoppable ( inputStream ,    outputStream )  . stop (  )  ;", "}    catch    ( Throwable   t )     {", "if    ( wasInterrupted ( t )  )     {", "return ;", "}", ". LOGGER . error ( String . format (  \" Could   not    % s .  \"  ,    displayName )  ,    t )  ;", "}", "}", "METHOD_END"], "methodName": ["forwardContent"], "fileName": "org.gradle.process.internal.streams.ExecOutputHandleRunner"}, {"methodBody": ["METHOD_START", "{", "try    {", "forwardCont (  )  ;", "}    finally    {", "completed . countDown (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.process.internal.streams.ExecOutputHandleRunner"}, {"methodBody": ["METHOD_START", "{", "return    ( t   instanceof   IOException )     &  &     (  \" Interrupted   system   call \"  . equals ( t . getMessage (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["wasInterrupted"], "fileName": "org.gradle.process.internal.streams.ExecOutputHandleRunner"}, {"methodBody": ["METHOD_START", "{", "executor . execute ( standardInputWriter )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.process.internal.streams.ForwardStdinStreamsHandler"}, {"methodBody": ["METHOD_START", "{", "try    {", "standardInputWriter . closeInput (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "try    {", "completed . await (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   new   UncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.process.internal.streams.ForwardStdinStreamsHandler"}, {"methodBody": ["METHOD_START", "{", "if    ( readErrorStream )     {", "executor . execute ( wrapInBuildOperation ( standardErrorReader )  )  ;", "}", "executor . execute ( wrapInBuildOperation ( standardOutputReader )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.process.internal.streams.OutputStreamsForwarder"}, {"methodBody": ["METHOD_START", "{", "try    {", "completed . await (  )  ;", "}    catch    ( IruptedException   e )     {", "throw   new   UncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.gradle.process.internal.streams.OutputStreamsForwarder"}, {"methodBody": ["METHOD_START", "{", "return   new   CurrentBuildOperationPreservingRunnable ( runnable )  ;", "}", "METHOD_END"], "methodName": ["wrapInBuildOperation"], "fileName": "org.gradle.process.internal.streams.OutputStreamsForwarder"}, {"methodBody": ["METHOD_START", "{", "return   new   ByteArrayInputStream ( new   byte [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["emptyInput"], "fileName": "org.gradle.process.internal.streams.SafeStreams"}, {"methodBody": ["METHOD_START", "{", "return   new   FilterOutputStream ( System . err )     {", "@ Override", "public   void   close (  )    throws   IOException    {", "}", "}  ;", "}", "METHOD_END"], "methodName": ["systemErr"], "fileName": "org.gradle.process.internal.streams.SafeStreams"}, {"methodBody": ["METHOD_START", "{", "return   new   FilterOutputStream ( System . out )     {", "@ Override", "public   void   close (  )    throws   IOException    {", "}", "}  ;", "}", "METHOD_END"], "methodName": ["systemOut"], "fileName": "org.gradle.process.internal.streams.SafeStreams"}, {"methodBody": ["METHOD_START", "{", "if    (  ( left    =  =    null )     |  |     ( right    =  =    null )  )     {", "return   true ;", "} else    {", "return   left . equals ( right )  ;", "}", "}", "METHOD_END"], "methodName": ["canBeMerged"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( left    =  =    null )     |  |     ( right    =  =    null )  )     {", "return   true ;", "} else    {", "return    . normalized ( left )  . equals (  . normalized ( right )  )  ;", "}", "}", "METHOD_END"], "methodName": ["canBeMerged"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "for    ( String   rightKey    :    right . keySet (  )  )     {", "if    (  !  (  . normalized ( left . keySet (  )  )  . contains (  . normalized ( rightKey )  )  )  )     {", "return   false ;", "} else    {", "for    ( String   leftKey    :    left . keySet (  )  )     {", "if    (  (  . normalized ( leftKey )  . equals (  . normalized ( rightKey )  )  )     &  &     (  !  ( left . get ( leftKey )  . equals ( right . get ( rightKey )  )  )  )  )     {", "return   false ;", "}", "}", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsAll"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( heapSize    =  =    null )     {", "return    -  1  ;", "}", "String   normalized    =    heapSize . trim (  )  . toLowerCase (  )  ;", "try    {", "if    ( normalized . endsWith (  \" m \"  )  )     {", "return   Integer . parseInt ( normalized . substring (  0  ,     (  ( normalized . length (  )  )     -     1  )  )  )  ;", "}", "if    ( normalized . endsWith (  \" g \"  )  )     {", "return    ( Integer . parseInt ( normalized . substring (  0  ,     (  ( normalized . length (  )  )     -     1  )  )  )  )     *     1  0  2  4  ;", "}", "}    catch    ( NumberFormatExce   e )     {", "throw   new   InvalidUserDataExce (  (  \" Cannot   parse   heap   size :     \"     +    heapSize )  ,    e )  ;", "}", "throw   new   InvalidUserDataExce (  (  \" Cannot   parse   heap   size :     \"     +    heapSize )  )  ;", "}", "METHOD_END"], "methodName": ["getHeapSizeMb"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "int   mergedHeapSizeMb    =    Math . max ( MergeOptionsUtil . getHeapSizeMb ( heapSize 1  )  ,    MergeOptionsUtil . getHeapSizeMb ( heapSize 2  )  )  ;", "return   mergedHeapSizeMb    =  =     (  -  1  )     ?    null    :     ( String . valueOf ( mergedHeapSizeMb )  )     +     \" m \"  ;", "}", "METHOD_END"], "methodName": ["mergeHeapSize"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "Set < String >    normalized    =    Sets . newLinkedHashSet (  )  ;", "for    ( String   string    :    strings )     {", "normalized . add (  . normalized ( string )  )  ;", "}", "return   normalized ;", "}", "METHOD_END"], "methodName": ["normalized"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "return   nullToEmpty ( string )  . trim (  )  ;", "}", "METHOD_END"], "methodName": ["normalized"], "fileName": "org.gradle.process.internal.util.MergeOptionsUtil"}, {"methodBody": ["METHOD_START", "{", "CompositeStoppable   stoppable ;", "lock . lock (  )  ;", "try    {", "stoppable    =    CompositeStoppable . stoppable ( acceptor ,    connection )  ;", "}    finally    {", "this . connection    =    null ;", "this . acceptor    =    null ;", "lock . unlock (  )  ;", "}", "stoppable . stop (  )  ;", "execHanabort (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "running    =    true ;", "}    finally    {", "lock . unlock (  )  ;", "}", "execHandle . start (  )  ;", "Date   connectExpiry    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( connectTimeout )  )  )  ;", "lock . lock (  )  ;", "try    {", "while    (  (  ( connection )     =  =    null )     &  &     ( running )  )     {", "try    {", "if    (  !  ( condition . awaitUntil ( connectExpiry )  )  )     {", "throw   new   ExecException ( String . format (  (  \" Unable   to   connect   to   the   child   process    \\  '  % s \\  '  .  \\ n \"     +     (  (  \" It   is   likely   that   the   child   process   have   crashed    -    please   find   the   stack   trace   in   the   build   log .  \\ n \"     +     \" This   exception   might   occur   when   the   build   machine   is   extremely   loaded .  \\ n \"  )     +     \" The   connection   attempt   hit   a   timeout   after    %  .  1 f   seconds    ( last   known   process   state :     % s ,    running :     % s )  .  \"  )  )  ,    execHandle ,     (  (  ( double )     ( connectTimeout )  )     /     1  0  0  0  )  ,    execHandle . getState (  )  ,    running )  )  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "if    (  ( connection )     =  =    null )     {", "if    (  ( processFailure )     !  =    null )     {", "throw   UncheckedException . throwAsUncheckedException ( processFailure )  ;", "} else    {", "throw   new   ExecException ( String . format (  \" Never   received   a   connection   from    % s .  \"  ,    execHandle )  )  ;", "}", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doStart"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "return   connection ;", "}", "METHOD_END"], "methodName": ["getConnection"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "onConnect ( connection ,    null )  ;", "}", "METHOD_END"], "methodName": ["onConnect"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "AsyncStoppable   stoppable ;", "lock . lock (  )  ;", "try    {", ". LOGGER . debug (  \" Received   connection    {  }    from    {  }  \"  ,    connection ,    execHandle )  ;", "if    (  ( connectionHandler    !  =    null )     &  &     ( running )  )     {", "connectionHandler . run (  )  ;", "}", "this . connection    =    connection ;", "if    ( aborted )     {", "connection . abort (  )  ;", "}", "condition . signalAll (  )  ;", "stoppable    =    acceptor ;", "}    finally    {", "lock . unlock (  )  ;", "}", "if    ( stoppable    !  =    null )     {", "stoppable . requestStop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onConnect"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "try    {", "execResult . rethrowFailure (  )  . assertNormalExitValue (  )  ;", "}    catch    ( Throwable   e )     {", "Failure    =    e ;", "}", "running    =    false ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["onProcessStop"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "this . execHandle    =    execHandle ;", "execHandle . addListener ( new   ExecHandleListener (  )     {", "public   void   executionStarted ( ExecHandle   execHandle )     {", "}", "public   void   executionFinished ( ExecHandle   execHandle ,    ExecResult   execResult )     {", "onStop ( execResult )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["setExecHandle"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "try    {", "doStart (  )  ;", "}    catch    ( Thwable   t )     {", "cleanup (  )  ;", "thw   UncheckedException . thwAsUncheckedException ( t )  ;", "}", "return   this ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "this . acceptor    =    acceptor ;", "}    fily    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["startAccepting"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   execHanwaitForFinish (  )  . assertNormalExitValue (  )  ;", "}    finally    {", "cleanup (  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForStop"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcess"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( applicationClasspath ,    files )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["applicationClasspath"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   applicationClasspath ;", "}", "METHOD_END"], "methodName": ["getApplicationClasspath"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   baseName ;", "}", "METHOD_END"], "methodName": ["getBaseName"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   connectTimeoutSeconds ;", "}", "METHOD_END"], "methodName": ["getConnectTimeoutSeconds"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   gradleUserHomeDir ;", "}", "METHOD_END"], "methodName": ["getGradleUserHomeDir"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   implementationClassPath ;", "}", "METHOD_END"], "methodName": ["getImplementationClassPath"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   javaCommand ;", "}", "METHOD_END"], "methodName": ["getJavaCommand"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   logLevel ;", "}", "METHOD_END"], "methodName": ["getLogLevel"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   packages ;", "}", "METHOD_END"], "methodName": ["getSharedPackages"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "return   action ;", "}", "METHOD_END"], "methodName": ["getWorker"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . baseName    =    baseName ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBaseName"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeoutSeconds    =    connectTimeoutSeconds ;", "}", "METHOD_END"], "methodName": ["setConnectTimeoutSeconds"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . gradleUserHomeDir    =    gradleUserHomeDir ;", "}", "METHOD_END"], "methodName": ["setGradleUserHomeDir"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . implementationClassPath    =    implementationClassPath ;", "}", "METHOD_END"], "methodName": ["setImplementationClasspath"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . logLevel    =    logLevel ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setLogLevel"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "GUtil . addToCollection ( this . packages ,    packages )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sharedPackages"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "sharedPackages ( Arrays . asList ( packages )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["sharedPackages"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "this . action    =    action ;", "return   this ;", "}", "METHOD_END"], "methodName": ["worker"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessBuilder"}, {"methodBody": ["METHOD_START", "{", "DefaultWorkerProcessBuilder   builder    =    new   DefaultWorkerProcessBuilder ( execHandleFactory ,    server ,    idGenerator ,    workerImplementationFactory ,    outputEventListener ,    memoryManager )  ;", "builder . setLogLevel ( loggingManager . getLevel (  )  )  ;", "builder . setGradleUserHomeDir ( gradleUserHomeDir )  ;", "builder . setConnectTimeoutSeconds ( connectTimeoutSeconds )  ;", "return   builder ;", "}", "METHOD_END"], "methodName": ["newWorkerProcessBuilder"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessFactory"}, {"methodBody": ["METHOD_START", "{", "this . connectTimeoutSeconds    =    connectTimeoutSeconds ;", "}", "METHOD_END"], "methodName": ["setConnectTimeoutSeconds"], "fileName": "org.gradle.process.internal.worker.DefaultWorkerProcessFactory"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    (  )  . run (  )  ;", "System . exit (  0  )  ;", "}    catch    ( Throwable   throwable )     {", "throwable . printStackTrace ( System . err )  ;", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.gradle.process.internal.worker.GradleWorkerMain"}, {"methodBody": ["METHOD_START", "{", "DataInputStream   instr    =    new   DataInputStream ( new   EncodedStream . EncodedInput ( System . in )  )  ;", "int   sharedPackagesCount    =    instr . readInt (  )  ;", "List < String >    sharedPackages    =    new   ArrayList < String >  ( sharedPackagesCount )  ;", "for    ( int   i    =     0  ;    i    <    sharedPackagesCount ;    i +  +  )     {", "sharedPackages . add ( instr . readUTF (  )  )  ;", "}", "int   classPathLength    =    instr . readInt (  )  ;", "URL [  ]    implementationClassPath    =    new   URL [ classPathLength ]  ;", "for    ( int   i    =     0  ;    i    <    classPathLength ;    i +  +  )     {", "String   url    =    instr . readUTF (  )  ;", "implementationClassPath [ i ]     =    new   URL ( url )  ;", "}", "FilteringClassLoader . Spec   filteringClassLoaderSpec    =    new   FilteringClassLoader . Spec (  )  ;", "for    ( String   sharedPackage    :    sharedPackages )     {", "filteringClassLoaderSpec . allowPackage ( sharedPackage )  ;", "}", "FilteringClassLoader   filteringClassLoader    =    new   FilteringClassLoader ( getClass (  )  . getClassLoader (  )  ,    filteringClassLoaderSpec )  ;", "URLClassLoader   classLoader    =    new   URLClassLoader ( implementationClassPath ,    filteringClassLoader )  ;", "Class <  ?    extends   Callable >    workerClass    =    classLoader . loadClass (  \" child . SystemApplicationClassLoaderWorker \"  )  . asSubclass ( Callable . class )  ;", "Callable < Void >    main    =    workerClass . getConstructor ( DataInputStream . class )  . newInstance ( instr )  ;", "main . call (  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.process.internal.worker.GradleWorkerMain"}, {"methodBody": ["METHOD_START", "{", "DefaultSerializerRegistry   registry    =    new   DefaultSerializerRegistry ( false )  ;", "registry . register ( JvmMemoryStatus . class ,    new    . JvmMemoryStatusSerializer (  )  )  ;", "return   registry ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.process.internal.worker.WorkerJvmMemoryInfoSerializer"}, {"methodBody": ["METHOD_START", "{", "DefaultSerializerRegistry   registry    =    new   DefaultSerializerRegistry ( false )  ;", "BaseSerializerFactory   factory    =    new   BaseSerializerFactory (  )  ;", "Serializer < LogLevel >    logLevelSerializer    =    factory . getSerializerFor ( LogLevel . class )  ;", "Serializer < Throwable >    throwableSerializer    =    factory . getSerializerFor ( Throwable . class )  ;", "registry . register ( LogEvent . class ,    new   internal . logging . serializer . LogEventSerializer ( logLevelSerializer ,    throwableSerializer )  )  ;", "registry . register ( StyledTextOutputEvent . class ,    new   internal . logging . serializer . StyledTextOutputEventSerializer ( logLevelSerializer ,    new   internal . serialize . ListSerializer < StyledTextOutputEvent . Span >  ( new   internal . logging . serializer . SpanSerializer ( factory . getSerializerFor ( Style . class )  )  )  )  )  ;", "registry . register ( LogLevelChangeEvent . class ,    new   internal . logging . serializer . LogLevelChangeEventSerializer ( logLevelSerializer )  )  ;", "return   registry ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.gradle.process.internal.worker.WorkerLoggingSerializer"}, {"methodBody": ["METHOD_START", "{", "return   new   WorkerProcessException ( String . format (  \" Failed   to   run    % s \"  ,    workerDisplayName )  ,    failure )  ;", "}", "METHOD_END"], "methodName": ["runFailed"], "fileName": "org.gradle.process.internal.worker.WorkerProcessException"}, {"methodBody": ["METHOD_START", "{", "final   ObjectConnection   clientConnection    =    workerContext . getServerConnection (  )  ;", "final   ServiceRegistry   serviceRegistry    =    workerContext . getServiceRegistry (  )  ;", ". LOGGER . debug (  \" Starting    {  }  .  \"  ,    displayName )  ;", "WorkerProcessContext   context    =    new   WorkerProcessContext (  )     {", "public   ObjectConnection   getServerConnection (  )     {", "return   clientConnection ;", "}", "public   ClassLoader   getApplicationClassLoader (  )     {", "return   workerContext . getApplicationClassLoader (  )  ;", "}", "public   Object   getWorkerId (  )     {", "return   workerId ;", "}", "public   String   getDisplayName (  )     {", "return   displayName ;", "}", "@ Override", "public   ServiceRegistry   getServiceRegistry (  )     {", "return   serviceRegistry ;", "}", "}  ;", "ClassLoader   contextClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "Thread . currentThread (  )  . setContextClassLoader ( action . getClass (  )  . getClassLoader (  )  )  ;", "NativeServices . initialize ( gradleUserHomeDir ,    false )  ;", "try    {", "action . execute ( context )  ;", "}    finally    {", "Thread . currentThread (  )  . setContextClassLoader ( contextClassLoader )  ;", "}", ". LOGGER . debug (  \" Completed    {  }  .  \"  ,    displayName )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.process.internal.worker.child.ActionExecutionWorker"}, {"methodBody": ["METHOD_START", "{", "JavaVersion   executableVersion    =    jvmVersionDetector . getJavaVersion ( execSpec . getExecutable (  )  )  ;", "return    ( executableVersion    !  =    null )     &  &     ( executableVersion . isJava 9 Compatible (  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldUseOptionsFile"], "fileName": "org.gradle.process.internal.worker.child.ApplicationClassesInSystemClassLoaderWorkerImplementationFactory"}, {"methodBody": ["METHOD_START", "{", "List < File >    classpath    =    new   ArrayList < File >  (  (  ( workerMainClassPath . size (  )  )     +     ( applicationClasspath . size (  )  )  )  )  ;", "classpath . addAll ( workerMainClassPath )  ;", "classpath . addAll ( applicationClasspath )  ;", "List < String >    argumentList    =    Arrays . asList (  \"  - cp \"  ,    Joiner . on ( File . pathSeparator )  . join ( classpath )  )  ;", "return   ArgWriter . argsFileGenerator ( optionsFile ,    ArgWriter . unixStyleFactory (  )  )  . transform ( argumentList )  ;", "}", "METHOD_END"], "methodName": ["writeOptionsFile"], "fileName": "org.gradle.process.internal.worker.child.ApplicationClassesInSystemClassLoaderWorkerImplementationFactory"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getProperty (  \" stuck \"  )  )     !  =    null )     {", "Thread . sleep (  3  0  0  0  0  )  ;", "return   null ;", "}", "Decoder   decoder    =    new   InputStreamBackedDecoder ( configInputStream )  ;", "int   logLevel    =    decoder . readSmallInt (  )  ;", "LoggingManagerInternal   loggingManager    =    createLoggingManager (  )  ;", "loggingManager . setLevelInternal ( LogLevel . values (  )  [ logLevel ]  )  . start (  )  ;", "boolean   shouldPublishJvmMemoryInfo    =    decoder . readBoolean (  )  ;", "String   gradleUserHomeDirPath    =    decoder . readString (  )  ;", "File   gradleUserHomeDir    =    new   File ( gradleUserHomeDirPath )  ;", "MultiChoiceAddress   serverAddress    =    new   MultiChoiceAddressSerializer (  )  . read ( decoder )  ;", "MessagingServices   messagingServices    =    new   MessagingServices (  )  ;", "final    . WorkerServices   workerServices    =    new    . WorkerServices ( messagingServices ,    gradleUserHomeDir )  ;", "ObjectConnection   connection    =    null ;", "WorkerLogEventListener   workerLogEventListener    =    null ;", "try    {", "byte [  ]    serializedWorker    =    decoder . readBinary (  )  ;", "Action < WorkerContext >    action ;", "try    {", "ObjectInputStream   instr    =    new   ClassLoaderObjectInputStream ( new   ByteArrayInputStream ( serializedWorker )  ,    getClass (  )  . getClassLoader (  )  )  ;", "action    =     (  ( Action < WorkerContext >  )     ( instr . readObject (  )  )  )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "connection    =    messagingServices . get ( MessagingClient . class )  . getConnection ( serverAddress )  ;", "workerLogEventListener    =    configureLogging ( loggingManager ,    connection )  ;", "if    ( shouldPublishJvmMemoryInfo )     {", "configureWorkerJvmMemoryInfoEvents ( workerServices ,    connection )  ;", "}", "final   ObjectConnection   serverConnection    =    connection ;", "action . execute ( new   WorkerContext (  )     {", "public   ClassLoader   getApplicationClassLoader (  )     {", "return   ClassLoader . getSystemClassLoader (  )  ;", "}", "@ Override", "public   ObjectConnection   getServerConnection (  )     {", "return   serverConnection ;", "}", "@ Override", "public   ServiceRegistry   getServiceRegistry (  )     {", "return   workerServices ;", "}", "}  )  ;", "}    finally    {", "if    ( workerLogEventListener    !  =    null )     {", "loggingManager . removeOutputEventListener ( workerLogEventListener )  ;", "}", "if    ( connection    !  =    null )     {", "connection . stop (  )  ;", "}", "messagingServices . close (  )  ;", "loggingManager . stop (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["call"], "fileName": "org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"}, {"methodBody": ["METHOD_START", "{", "connection . useParameterSerializers ( WorkerLoggingSerializer . create (  )  )  ;", "WorkerLoggingProtocol   workerLoggingProtocol    =    connection . addOutgoing ( WorkerLoggingProtocol . class )  ;", "WorkerLogEventListener   workerLogEventListener    =    new   WorkerLogEventListener ( workerLoggingProtocol )  ;", "loggingManager . addOutputEventListener ( workerLogEventListener )  ;", "return   workerLogEventListener ;", "}", "METHOD_END"], "methodName": ["configureLogging"], "fileName": "org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"}, {"methodBody": ["METHOD_START", "{", "connection . useParameterSerializers ( WorkerJvmMemoryInfoSerializer . create (  )  )  ;", "final   WorkerJvmMemoryInfoProtocol   workerJvmMemoryInfoProtocol    =    connection . addOutgoing ( WorkerJvmMemoryInfoProtocol . class )  ;", "services . get ( MemoryManager . class )  . addListener ( new   JvmMemoryStatusListener (  )     {", "@ Override", "public   void   onJvmMemoryStatus ( JvmMemoryStatus   jvmMemoryStatus )     {", "workerJvmMemoryInfoProtocol . sendJvmMemoryStatus ( jvmMemoryStatus )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["configureWorkerJvmMemoryInfoEvents"], "fileName": "org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"}, {"methodBody": ["METHOD_START", "{", "LoggingManagerInternal   loggingManagerInternal    =    LoggingServiceRegistry . newEmbeddableLogging (  )  . newInstance ( LoggingManagerInternal . class )  ;", "loggingManagerInternal . captureSystemSources (  )  ;", "return   loggingManagerInternal ;", "}", "METHOD_END"], "methodName": ["createLoggingManager"], "fileName": "org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker"}, {"methodBody": ["METHOD_START", "{", "synchronized ( lock )     {", "try    {", "if    (  ( workerCache )     !  =    null )     {", "workerCache . close (  )  ;", "}", "}    finally    {", "workerCache    =    null ;", "worker    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.gradle.process.internal.worker.child.WorkerProcessClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( name . equals (  \" WORKER _ MAIN \"  )  )     {", "synchronized ( lock )     {", "if    (  ( workerClassPath )     =  =    null )     {", "workerClassPathCache    =    cacheRepository . cache (  \" workerMain \"  )  . withInitializer ( new    . CacheInitializer (  )  )  . open (  )  ;", "workerClassPath    =    new   DefaultClassPath (  . jarFile ( workerClassPathCache )  )  ;", "}", ". LOGGER . debug (  \" Using   worker   process   classpath :     {  }  \"  ,    workerClassPath )  ;", "return   workerClassPath ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findClassPath"], "fileName": "org.gradle.process.internal.worker.child.WorkerProcessClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( cache . getBaseDir (  )  ,     \" gradle - worker . jar \"  )  ;", "}", "METHOD_END"], "methodName": ["jarFile"], "fileName": "org.gradle.process.internal.worker.child.WorkerProcessClassPathProvider"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  ( next )     =  =    null )     {", "next    =    received . take (  )  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "return    ( next )     !  =     (  . END )  ;", "}", "METHOD_END"], "methodName": ["awaitNextResult"], "fileName": "org.gradle.process.internal.worker.request.Receiver"}, {"methodBody": ["METHOD_START", "{", "awaitNextResult (  )  ;", "Object   next    =    this . next ;", "if    ( next    =  =     (  . END )  )     {", "throw   new   IllegalStateException (  \" No   response   received .  \"  )  ;", "}", "this . next    =    null ;", "if    ( next   instanceof    . Failure )     {", ". Failure   failure    =     (  (  . Failure )     ( next )  )  ;", "throw   failure . failure ;", "}", "return   next    =  =     (  . NULL )     ?    null    :    next ;", "}", "METHOD_END"], "methodName": ["getNextResult"], "fileName": "org.gradle.process.internal.worker.request.Receiver"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    ( String   name    :    startParameter . getExcludedTaskNames (  )  )     {", "sb . append (  \"  - x    \"  )  ;", "sb . append ( name )  ;", "sb . append (  \"     \"  )  ;", "}", "for    ( String   name    :    startParameter . getTaskNames (  )  )     {", "sb . append ( name )  ;", "sb . append (  \"     \"  )  ;", "}", "String   tasks    =    sb . toString (  )  ;", "if    (  ( tasks . length (  )  )     =  =     0  )     {", "tasks    =     \"  ( no   tasks   specified )  \"  ;", "}", "return    \" d   build :     \"     +    tasks ;", "}", "METHOD_END"], "methodName": ["getBuildDescription"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return   buildStarted ;", "}", "METHOD_END"], "methodName": ["getBuildStarted"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    \" Started   on :     \"     +     ( BuildProfile . DATE _ FORMAT . format ( buildStarted )  )  ;", "}", "METHOD_END"], "methodName": ["getBuildStartedDescription"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "ContinuousOperation   profile    =    dependencySets . get ( dependencySetDescription )  ;", "if    ( profile    =  =    null )     {", "profile    =    new   ContinuousOperation ( dependencySetDescription )  ;", "dependencySets . put ( dependencySetDescription ,    profile )  ;", "}", "return   profile ;", "}", "METHOD_END"], "methodName": ["getDependencySetProfile"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "final   List < ContinuousOperation >    profiles    =    CollectionUtils . sort ( dependencySets . values (  )  ,    Operation . slowestFirst (  )  )  ;", "return   new   CompositeOperation < ContinuousOperation >  ( profiles )  ;", "}", "METHOD_END"], "methodName": ["getDependencySets"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    ( projectsEvaluated )     -     ( projectsLoaded )  ;", "}", "METHOD_END"], "methodName": ["getElapsedProjectsConfiguration"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    ( projectsLoaded )     -     ( settingsEvaluated )  ;", "}", "METHOD_END"], "methodName": ["getElapsedProjectsLoading"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    ( settingsEvaluated )     -     ( buildStarted )  ;", "}", "METHOD_END"], "methodName": ["getElapsedSettings"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    ( buildStarted )     -     ( profilingStarted )  ;", "}", "METHOD_END"], "methodName": ["getElapsedStartup"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    ( buildFinished )     -     ( profilingStarted )  ;", "}", "METHOD_END"], "methodName": ["getElapsedTotal"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "long   result    =     0  ;", "for    ( Project   project    :    projects . values (  )  )     {", "result    +  =    project . getElapsedTime (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getElapsedTotalExecutionTime"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "List < Operation >    operations    =    new   ArrayList < Operation >  (  )  ;", "for    ( Project   project    :    projects . values (  )  )     {", "operations . add ( project . getConfigurationOperation (  )  )  ;", "}", "operations    =    CollectionUtils . sort ( operations ,    Operation . slowestFirst (  )  )  ;", "return   new   CompositeOperation < Operation >  ( operations )  ;", "}", "METHOD_END"], "methodName": ["getProjectConfiguration"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "ProjectProfile   result    =    projects . get ( projectPath )  ;", "if    ( result    =  =    null )     {", "result    =    new   ProjectProfile ( projectPath )  ;", "projects . put ( projectPath ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getProjectProfile"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return   CollectionUtils . sort ( projects . values (  )  ,    Operation . slowestFirst (  )  )  ;", "}", "METHOD_END"], "methodName": ["getProjects"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return   startParameter ;", "}", "METHOD_END"], "methodName": ["getStartParameter"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return   successful ;", "}", "METHOD_END"], "methodName": ["isSuccessful"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . buildFinished    =    buildFinished ;", "}", "METHOD_END"], "methodName": ["setBuildFinished"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . buildStarted    =    buildStarted ;", "}", "METHOD_END"], "methodName": ["setBuildStarted"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . profilingStarted    =    profilingStarted ;", "}", "METHOD_END"], "methodName": ["setProfilingStarted"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . projectsEvaluated    =    projectsEvaluated ;", "}", "METHOD_END"], "methodName": ["setProjectsEvaluated"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . projectsLoaded    =    projectsLoaded ;", "}", "METHOD_END"], "methodName": ["setProjectsLoaded"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . settingsEvaluated    =    settingsEvaluated ;", "}", "METHOD_END"], "methodName": ["setSettingsEvaluated"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "this . successful    =    successful ;", "}", "METHOD_END"], "methodName": ["setSuccessful"], "fileName": "org.gradle.profile.BuildProfile"}, {"methodBody": ["METHOD_START", "{", "return    \"  < composite   operation >  \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.profile.CompositeOperation"}, {"methodBody": ["METHOD_START", "{", "return   children ;", "}", "METHOD_END"], "methodName": ["getOperations"], "fileName": "org.gradle.profile.CompositeOperation"}, {"methodBody": ["METHOD_START", "{", "return   children . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["iterator"], "fileName": "org.gradle.profile.CompositeOperation"}, {"methodBody": ["METHOD_START", "{", "return   description ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.profile.ContinuousOperation"}, {"methodBody": ["METHOD_START", "{", "return    ( finish )     -     ( start )  ;", "}", "METHOD_END"], "methodName": ["getElapsedTime"], "fileName": "org.gradle.profile.ContinuousOperation"}, {"methodBody": ["METHOD_START", "{", "return   start ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.profile.ContinuousOperation"}, {"methodBody": ["METHOD_START", "{", "this . finish    =    finish ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFinish"], "fileName": "org.gradle.profile.ContinuousOperation"}, {"methodBody": ["METHOD_START", "{", "this . start    =    start ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStart"], "fileName": "org.gradle.profile.ContinuousOperation"}, {"methodBody": ["METHOD_START", "{", "return   new   Comparator < Operation >  (  )     {", "public   int   compare ( Operation   o 1  ,    Operation   o 2  )     {", "long   byElapsedTime    =     ( o 2  . getElapsedTime (  )  )     -     ( o 1  . getElapsedTime (  )  )  ;", "if    ( byElapsedTime    >     0  )     {", "return    1  ;", "} else", "if    ( byElapsedTime    <     0  )     {", "return    -  1  ;", "}", "return   o 1  . getDescription (  )  . compareTo ( o 2  . getDescription (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["slowestFirst"], "fileName": "org.gradle.profile.Operation"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "ProjectPprojectP =    buildPgetProjectPproject . getPath (  )  )  ;", "projectPgetConfigurationOperation (  )  . setFinish ( now )  ;", "}", "METHOD_END"], "methodName": ["afterEvaluate"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "Project   project    =    task . getProject (  )  ;", "ProjectPprojectP =    buildPgetProjectPproject . getPath (  )  )  ;", "TaskExecution   taskExecution    =    projectPgetTaskPtask . getPath (  )  )  ;", "taskExecution . setFinish ( now )  ;", "taskExecution . completed ( state )  ;", "}", "METHOD_END"], "methodName": ["afterExecute"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "buildPgetDependencySetPdependencies . getPath (  )  )  . setFinish ( now )  ;", "}", "METHOD_END"], "methodName": ["afterResolve"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "buildPgetProjectPproject . getPath (  )  )  . getConfigurationOperation (  )  . setStart ( now )  ;", "}", "METHOD_END"], "methodName": ["beforeEvaluate"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "Project   project    =    task . getProject (  )  ;", "ProjectPprojectP =    buildPgetProjectPproject . getPath (  )  )  ;", "projectPgetTaskPtask . getPath (  )  )  . setStart ( now )  ;", "}", "METHOD_END"], "methodName": ["beforeExecute"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "buildPgetDependencySetPdependencies . getPath (  )  )  . setStart ( now )  ;", "}", "METHOD_END"], "methodName": ["beforeResolve"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "buildProfile . setSuccessful (  (  ( result . getFailure (  )  )     =  =    null )  )  ;", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "long   now    =    clock . getCurrentTime (  )  ;", "buildProfile    =    new   BuildProfile ( getStartParameter (  )  )  ;", "buildProfile . setBuildStarted ( now )  ;", "buildProfile . setProfilingStarted ( buildStartedTime . getStartTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["buildStarted"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "if    (  ( buildProfile )     !  =    null )     {", "buildProfile . setBuildFinished ( clock . getCurrentTime (  )  )  ;", "try    {", "listener . buildFinished ( buildProfile )  ;", "}    finally    {", "buildProfile    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["completed"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "buildProfile . setProjectsEvaluated ( clock . getCurrentTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectsEvaluated"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "buildProfile . setProjectsLoaded ( clock . getCurrentTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["projectsLoaded"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "buildProfile . setSettingsEvaluated ( clock . getCurrentTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["settingsEvaluated"], "fileName": "org.gradle.profile.ProfileEventAdapter"}, {"methodBody": ["METHOD_START", "{", "HtmlReportRenderer   renderer    =    new   HtmlReportRenderer (  )  ;", "renderer . renderSinglePage ( buildProfile ,    new    . ProfilePageRenderer (  )  ,    file )  ;", "}", "METHOD_END"], "methodName": ["writeTo"], "fileName": "org.gradle.profile.ProfileReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   configurationOperation ;", "}", "METHOD_END"], "methodName": ["getConfigurationOperation"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "return   projectPath ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "return   getTasks (  )  . getElapsedTime (  )  ;", "}", "METHOD_END"], "methodName": ["getElapsedTime"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "return   projectPath ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "TaskExecution   result    =    tasks . get ( taskPath )  ;", "if    ( result    =  =    null )     {", "result    =    new   TaskExecution ( taskPath )  ;", "tasks . put ( taskPath ,    result )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getTaskProfile"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "List < TaskExecution >    taskExecutions    =    CollectionUtils . sort ( tasks . values (  )  ,    Operation . slowestFirst (  )  )  ;", "return   new   CompositeOperation < TaskExecution >  ( taskExecutions )  ;", "}", "METHOD_END"], "methodName": ["getTasks"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "return   projectPath ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.profile.ProjectProfile"}, {"methodBody": ["METHOD_START", "{", "ProfileReportRenderer   renderer    =    new   ProfileReportRenderer (  )  ;", "File   file    =    new   File ( buildDir ,     (  (  \" reports / profile / profile -  \"     +     (  . FILE _ DATE _ FORMAT . format ( new   Date ( buildProfile . getBuildStarted (  )  )  )  )  )     +     \"  . html \"  )  )  ;", "renderer . writeTo ( buildProfile ,    file )  ;", "renderReportUrl ( file )  ;", "}", "METHOD_END"], "methodName": ["buildFinished"], "fileName": "org.gradle.profile.ReportGeneratingProfileListener"}, {"methodBody": ["METHOD_START", "{", "StyledTextOutput   textOutput    =    textOutputFactory . create ( ReportGeneratingProfileListener . class ,    LIFECYCLE )  ;", "textOutput . println (  )  ;", "String   reportUrl    =    new   ConsoleRenderer (  )  . asClickableFileUrl ( reportFile )  ;", "textOutput . formatln (  \" See   the   profiling   report   at :     % s \"  ,    reportUrl )  ;", "textOutput . text (  \" A   fine - grained   performance   profile   is   available :    use   the    \"  )  ;", "textOutput . withStyle ( Style . UserInput )  . format (  \"  -  -  % s \"  ,    StartParameterBuildOptions . BuildScanOption . LONG _ OPTION )  ;", "textOutput . text (  \"    option .  \"  )  ;", "textOutput . println (  )  ;", "}", "METHOD_END"], "methodName": ["renderReportUrl"], "fileName": "org.gradle.profile.ReportGeneratingProfileListener"}, {"methodBody": ["METHOD_START", "{", "this . state    =    state ;", "return   this ;", "}", "METHOD_END"], "methodName": ["completed"], "fileName": "org.gradle.profile.TaskExecution"}, {"methodBody": ["METHOD_START", "{", "return   path ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "org.gradle.profile.TaskExecution"}, {"methodBody": ["METHOD_START", "{", "return   state ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.gradle.profile.TaskExecution"}, {"methodBody": ["METHOD_START", "{", "return   state . getSkipped (  )     ?    state . getSkipMessage (  )     :    state . getDidWork (  )     ?     \"  \"     :    TaskExecution . NO _ WORK _ MESSAGE ;", "}", "METHOD_END"], "methodName": ["getStatus"], "fileName": "org.gradle.profile.TaskExecution"}, {"methodBody": ["METHOD_START", "{", "if    ( duration    =  =     0  )     {", "return    \"  0 s \"  ;", "}", "StringBuilder   result    =    new   StringBuilder (  )  ;", "long   days    =    duration    /     (  . MILLIS _ PER _ DAY )  ;", "duration    =    duration    %     (  . MILLIS _ PER _ DAY )  ;", "if    ( days    >     0  )     {", "result . append ( days )  ;", "result . append (  \" d \"  )  ;", "}", "long   hours    =    duration    /     (  . MILLIS _ PER _ HOUR )  ;", "duration    =    duration    %     (  . MILLIS _ PER _ HOUR )  ;", "if    (  ( hours    >     0  )     |  |     (  ( result . length (  )  )     >     0  )  )     {", "result . append ( hours )  ;", "result . append (  \" h \"  )  ;", "}", "long   minutes    =    duration    /     (  . MILLIS _ PER _ MINUTE )  ;", "duration    =    duration    %     (  . MILLIS _ PER _ MINUTE )  ;", "if    (  ( minutes    >     0  )     |  |     (  ( result . length (  )  )     >     0  )  )     {", "result . append ( minutes )  ;", "result . append (  \" m \"  )  ;", "}", "int   secondsScale    =     (  ( result . length (  )  )     >     0  )     ?     2     :     3  ;", "result . append ( BigDecimal . valueOf ( duration )  . divide ( BigDecimal . valueOf (  . MILLIS _ PER _ SECOND )  )  . setScale ( secondsScale ,    BigDecimal . ROUND _ HALF _ UP )  )  ;", "result . append (  \" s \"  )  ;", "return   result . toString (  )  ;", "}", "METHOD_END"], "methodName": ["format"], "fileName": "org.gradle.reporting.DurationFormatter"}, {"methodBody": ["METHOD_START", "{", "try    {", "outputDirectory . mkdirs (  )  ;", ". DefaultHtmlReportContext   context    =    new    . DefaultHtmlReportContext ( outputDirectory )  ;", "renderer . render ( model ,    context )  ;", "for    (  . Resource   resource    :    context . resources . values (  )  )     {", "File   destFile    =    new   File ( outputDirectory ,    resource . path )  ;", "if    (  !  ( destFile . exists (  )  )  )     {", "GFileUtils . copyURLToFile ( resource . source ,    destFile )  ;", "}", "}", "}    catch    ( IOException   e )     {", "throw   new   UncheckedIOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["render"], "fileName": "org.gradle.reporting.HtmlReportRenderer"}, {"methodBody": ["METHOD_START", "{", "render ( model ,    new   ReportRenderer < T ,    HtmlReportBuilder >  (  )     {", "@ Override", "public   void   render ( T   model ,    HtmlReportBuilder   output )    throws   IOException    {", "output . renderRawHtmlPage ( outputFile . getName (  )  ,    model ,    renderer )  ;", "}", "}  ,    outputFile . getParentFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderRawSinglePage"], "fileName": "org.gradle.reporting.HtmlReportRenderer"}, {"methodBody": ["METHOD_START", "{", "render ( model ,    new   ReportRenderer < T ,    HtmlReportBuilder >  (  )     {", "@ Override", "public   void   render ( T   model ,    HtmlReportBuilder   output )    throws   IOException    {", "output . renderHtmlPage ( outputFile . getName (  )  ,    model ,    renderer )  ;", "}", "}  ,    outputFile . getParentFile (  )  )  ;", "}", "METHOD_END"], "methodName": ["renderSinglePage"], "fileName": "org.gradle.reporting.HtmlReportRenderer"}, {"methodBody": ["METHOD_START", "{", "return   model ;", "}", "METHOD_END"], "methodName": ["getModel"], "fileName": "org.gradle.reporting.TabbedPageRenderer"}, {"methodBody": ["METHOD_START", "{", "return   getTitle (  )  ;", "}", "METHOD_END"], "methodName": ["getPageTitle"], "fileName": "org.gradle.reporting.TabbedPageRenderer"}, {"methodBody": ["METHOD_START", "{", "tabs . add ( new   TabDefinition ( title ,    contentRenderer )  )  ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.gradle.reporting.TabsRenderer"}, {"methodBody": ["METHOD_START", "{", "tabs . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.gradle.reporting.TabsRenderer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( parent )     !  =    null )     {", "return   impl . createChild ( name ,    parent ,    projectDir )  ;", "}", "return   impl . create ( name ,    projectDir ,    gradleUserHomeDir )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   ProjectBuilder (  )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "gradleUserHomeDir    =    dir ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withGradleUserHomeDir"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "this . name    =    name ;", "ren   this ;", "}", "METHOD_END"], "methodName": ["withName"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "this . parent    =    parent ;", "ren   this ;", "}", "METHOD_END"], "methodName": ["withParent"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "projectDir    =    dir ;", "return   this ;", "}", "METHOD_END"], "methodName": ["withProjectDir"], "fileName": "org.gradle.testfixtures.ProjectBuilder"}, {"methodBody": ["METHOD_START", "{", "return   new   InMemoryCacheFactory . InMemoryCache ( cacheDir ,    displayName ,    CleanupAction . NO _ OP )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.gradle.testfixtures.internal.InMemoryCacheFactory"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Set < K >  )     ( entries . keySet (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["keySet"], "fileName": "org.gradle.testfixtures.internal.InMemoryIndexedCache"}, {"methodBody": ["METHOD_START", "{", "ProjectInternal   parentProject    =     (  ( ProjectInternal )     ( parent )  )  ;", "projectDir    =     ( projectDir    !  =    null )     ?    projectDir . getAbsoluteFile (  )     :    new   File ( parentProject . getProjectDir (  )  ,    name )  ;", "DefaultProject   project    =     . CLASS _ GENERATOR . newInstance ( DefaultProject . class ,    name ,    parentProject ,    projectDir ,    new   File ( projectDir ,     \" build . gradle \"  )  ,    new   StringScriptSource (  \" test   build   file \"  ,    null )  ,    parentProject . getGradle (  )  ,    parentProject . getGradle (  )  . getServiceRegistryFactory (  )  ,    parentProject . getClassLoaderScope (  )  . createChild (  (  \" project -  \"     +    name )  )  ,    parentProject . getBaseClassLoaderScope (  )  )  ;", "parentProject . addChildProject ( project )  ;", "parentProject . getProjectRegistry (  )  . addProject ( project )  ;", "return   project ;", "}", "METHOD_END"], "methodName": ["createChildProject"], "fileName": "org.gradle.testfixtures.internal.ProjectBuilderImpl"}, {"methodBody": ["METHOD_START", "{", "File   projectDir    =    prepareProjectDir ( inputProjectDir )  ;", "final   File   homeDir    =    new   File ( projectDir ,     \" gradleHome \"  )  ;", "StartParameter   startParameter    =    new   StartParameterInternal (  )  ;", "File   userHomeDir    =     ( gradleUserHomeDir    =  =    null )     ?    new   File ( projectDir ,     \" userHome \"  )     :    FileUtils . canonicalize ( gradleUserHomeDir )  ;", "startParameter . setGradleUserHomeDir ( userHomeDir )  ;", "NativeServices . initialize ( userHomeDir )  ;", "BuildRequestMetaData   buildRequestMetaData    =    new   DefaultBuildRequestMetaData ( Time . currentTimeMillis (  )  )  ;", "CrossBuildSessionScopeServices   crossBuildSessionScopeServices    =    new   CrossBuildSessionScopeServices ( getGlobalServices (  )  ,    startParameter )  ;", "ServiceRegistry   userHomeServices    =    getUserHomeServices ( userHomeDir )  ;", "BuildSessionScopeServices   buildSessionScopeServices    =    new   BuildSessionScopeServices ( userHomeServices ,    crossBuildSessionScopeServices ,    startParameter ,    buildRequestMetaData ,    ClassPath . EMPTY )  ;", "BuildTreeScopeServices   buildTreeScopeServices    =    new   BuildTreeScopeServices ( buildSessionScopeServices )  ;", "ServiceRegistry   topLevelRegistry    =    new   TestBuildScopeServices ( buildTreeScopeServices ,    homeDir )  ;", "GradleInternal   gradle    =     . CLASS _ GENERATOR . newInstance ( DefaultGradle . class ,    null ,    startParameter ,    topLevelRegistry . get ( ServiceRegistryFactory . class )  )  ;", "DefaultProjectDescriptor   projectDescriptor    =    new   DefaultProjectDescriptor ( null ,    name ,    projectDir ,    new   DefaultProjectDescriptorRegistry (  )  ,    topLevelRegistry . get ( FileResolver . class )  )  ;", "ClassLoaderScope   baseScope    =    gradle . getClassLoaderScope (  )  ;", "ClassLoaderScope   rootProjectScope    =    baseScope . createChild (  \" root - project \"  )  ;", "ProjectInternal   project    =    topLevelRegistry . get ( IProjectFactory . class )  . createProject ( projectDescriptor ,    null ,    gradle ,    rootProjectScope ,    baseScope )  ;", "gradle . setRootProject ( project )  ;", "gradle . setDefaultProject ( project )  ;", "ResourceLockCoordinationService   coordinationService    =    topLevelRegistry . get ( ResourceLockCoordinationService . class )  ;", "WorkerLeaseService   workerLeaseService    =    topLevelRegistry . get ( WorkerLeaseService . class )  ;", "coordinationService . withStateLock ( DefaultResourceLockCoordinationService . lock ( workerLeaseService . getWorkerLease (  )  )  )  ;", "return   project ;", "}", "METHOD_END"], "methodName": ["createProject"], "fileName": "org.gradle.testfixtures.internal.ProjectBuilderImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( ProjectBuilderImpl . globalServices )     =  =    null )     {", "ProjectBuilderImpl . globalServices    =    ServiceRegistryBuilder . builder (  )  . displayName (  \" global   services \"  )  . parent ( LoggingServiceRegistry . newNestedLogging (  )  )  . parent ( NativeServices . getInstance (  )  )  . provider ( new   TestGlobalScopeServices (  )  )  . build (  )  ;", "ProjectBuilderImpl . globalServices . get ( LegacyTypesSupport . class )  . injectEmptyInterfacesIntoClassLoader ( getClass (  )  . getClassLoader (  )  )  ;", "}", "return   ProjectBuilderImpl . globalServices ;", "}", "METHOD_END"], "methodName": ["getGlobalServices"], "fileName": "org.gradle.testfixtures.internal.ProjectBuilderImpl"}, {"methodBody": ["METHOD_START", "{", "ServiceRegistry   globalServices    =    getGlobalServices (  )  ;", "GUserHomeScopeServiceRegistry   userHomeScopeServiceRegistry    =    globalServices . get ( GUserHomeScopeServiceRegistry . class )  ;", "return   userHomeScopeServiceRegistry . getServicesFor ( userHomeDir )  ;", "}", "METHOD_END"], "methodName": ["getUserHomeServices"], "fileName": "org.gradle.testfixtures.internal.ProjectBuilderImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( projectDir    =  =    null )     {", "TemporaryFileProvider   temporaryFileProvider    =    new   TmpDirTemporaryFileProvider (  )  ;", "projectDir    =    temporaryFileProvider . createTemporaryDirectory (  \" gradle \"  ,     \" projectDir \"  )  ;", "projectDir . deleteOnExit (  )  ;", "} else    {", "projectDir    =    FileUtils . canonicalize ( projectDir )  ;", "}", "return   projectDir ;", "}", "METHOD_END"], "methodName": ["prepareProjectDir"], "fileName": "org.gradle.testfixtures.internal.ProjectBuilderImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildCancellationToken (  )  ;", "}", "METHOD_END"], "methodName": ["createBuildCancellationToken"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   BuildDefinition . fromStartParameter ( startParameter )  ;", "}", "METHOD_END"], "methodName": ["createBuildDefinition"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultBuildIdentity ( buildDefinition ,    true )  ;", "}", "METHOD_END"], "methodName": ["createBuildIdentity"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   GradleLauncherMetaData (  )  ;", "}", "METHOD_END"], "methodName": ["createClientMetaData"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   CurrentGradleInstallation ( new   GradleInstallation ( homeDir )  )  ;", "}", "METHOD_END"], "methodName": ["createCurrentGradleInstallation"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   NestedBuildFactory (  )     {", "@ Override", "public   GradleLauncher   nestedInstance ( BuildDefinition   buildDefinition )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "@ Override", "public   BuildController   nestedBuildController ( BuildDefinition   buildDefinition )     {", "throw   new   UnsupportedOperationException (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["createNestedBuildFactory"], "fileName": "org.gradle.testfixtures.internal.TestBuildScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   new   TestGlobalScopeServices . ProjectBuilderBuildOperationExecutor ( listenerManager . getBroadcaster ( BuildOperationListener . class )  ,    clock ,    progressLoggerFactory ,    new   DefaultBuildOperationQueueFactory ( workerLeaseService )  ,    executorFactory ,    resourceLockCoordinationService ,    parallelismConfigurationManager )  ;", "}", "METHOD_END"], "methodName": ["createBuildOperationExecutor"], "fileName": "org.gradle.testfixtures.internal.TestGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "return   loggingManagerFactory . create (  )  ;", "}", "METHOD_END"], "methodName": ["createLoggingManager"], "fileName": "org.gradle.testfixtures.internal.TestGlobalScopeServices"}, {"methodBody": ["METHOD_START", "{", "ToolingModelBuilder   match    =    null ;", "for    ( ToolingModelBuilder   builder    :    builders )     {", "if    ( builder . canBuild ( modelName )  )     {", "if    ( match    !  =    null )     {", "throw   new   UnsupportedOperationException ( String . format (  \" Multiple   builders   are   available   to   build   a   model   of   type    '  % s '  .  \"  ,    modelName )  )  ;", "}", "match    =    builder ;", "}", "}", "if    ( match    !  =    null )     {", "return   match ;", "}", "if    (  ( parent )     !  =    null )     {", "return   parent . getBuilder ( modelName )  ;", "}", "throw   new   UnknownModelException ( String . format (  \" No   builders   are   available   to   build   a   model   of   type    '  % s '  .  \"  ,    modelName )  )  ;", "}", "METHOD_END"], "methodName": ["getBuilder"], "fileName": "org.gradle.tooling.provider.model.internal.DefaultToolingModelBuilderRegistry"}, {"methodBody": ["METHOD_START", "{", "builders . add ( builder )  ;", "}", "METHOD_END"], "methodName": ["register"], "fileName": "org.gradle.tooling.provider.model.internal.DefaultToolingModelBuilderRegistry"}, {"methodBody": ["METHOD_START", "{", "return   fixedTime ;", "}", "METHOD_END"], "methodName": ["getCurrentTime"], "fileName": "org.gradle.util.BuildCommencedTimeProvider"}, {"methodBody": ["METHOD_START", "{", "return   startTime ;", "}", "METHOD_END"], "methodName": ["getStartTime"], "fileName": "org.gradle.util.Clock"}, {"methodBody": ["METHOD_START", "{", "if    ( configureClosure    =  =    null )     {", "return   target ;", "}", "if    ( target   instanceof   Configurable )     {", "(  ( Configurable )     ( target )  )  . configure ( configureClosure )  ;", "} else    {", ". configureTarget ( configureClosure ,    target ,    new   ConfigureDelegate ( configureClosure ,    target )  )  ;", "}", "return   target ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( properties . isEmpty (  )  )     {", "return   delegate ;", "}", "DynamicObject   dynamicObject    =    DynamicObjectUasDynamicObject ( delegate )  ;", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    properties . entrySet (  )  )     {", "String   name    =    entry . getKey (  )  . toString (  )  ;", "Object   value    =    entry . getValue (  )  ;", "DynamicInvokeResult   result    =    dynamicObject . trySetProperty ( name ,    value )  ;", "if    ( result . isFound (  )  )     {", "continue ;", "}", "result    =    dynamicObject . tryInvokeMethod ( name ,    value )  ;", "if    (  !  ( result . isFound (  )  )  )     {", "throw   dynamicObject . setMissingProperty ( name )  ;", "}", "}", "return   delegate ;", "}", "METHOD_END"], "methodName": ["configureByMap"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( mandatoryKeys . isEmpty (  )  )  )     {", "Collection < String >    missingKeys    =    CollectionUtils . toStringList ( mandatoryKeys )  ;", "missingKeys . removeAll ( CollectionUtils . toStringList ( properties . keySet (  )  )  )  ;", "if    (  !  ( missingKeys . isEmpty (  )  )  )     {", "throw   new    . IncompleteInputException (  (  \" Input   configuration   map   does   not   contain   following   mandatory   keys :     \"     +    missingKeys )  ,    missingKeys )  ;", "}", "}", "return    . configureByMap ( properties ,    delegate )  ;", "}", "METHOD_END"], "methodName": ["configureByMap"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( configureClosure    =  =    null )     {", "return   target ;", "}", ". configureTarget ( configureClosure ,    target ,    new   ConfigureDelegate ( configureClosure ,    target )  )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["configureSelf"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( configureClosure    =  =    null )     {", "return   target ;", "}", ". configureTarget ( configureClosure ,    target ,    closureDelegate )  ;", "return   target ;", "}", "METHOD_END"], "methodName": ["configureSelf"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( configureClosure   instanceof   GeneratedClosure )  )     {", "new   ClosureBackedAction < T >  ( configureClosure ,    Closure . DELEGATE _ FIRST ,    false )  . execute ( target )  ;", "return ;", "}", "Closure   withNewOwner    =    configureClosure . rehydrate ( target ,    closureDelegate ,    configureClosure . getThisObject (  )  )  ;", "new   ClosureBackedAction < T >  ( withNewOwner ,    Closure . OWNER _ ONLY ,    false )  . execute ( target )  ;", "}", "METHOD_END"], "methodName": ["configureTarget"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( configureClosure    =  =    null )     {", "return   Actions . doNothing (  )  ;", "}", "return   new    . WrappedConfigureAction < T >  ( configureClosure )  ;", "}", "METHOD_END"], "methodName": ["configureUsing"], "fileName": "org.gradle.util.ConfigureUtil"}, {"methodBody": ["METHOD_START", "{", "Object   current    =    path ;", "while    ( current    !  =    null )     {", "if    ( current   instanceof   Callable )     {", "current    =    GUtil . uncheckedCall (  (  ( Callable )     ( current )  )  )  ;", "} else", "if    ( current   instanceof   api . provider . Provider )     {", "return    (  ( api . provider . Provider <  ?  >  )     ( current )  )  . get (  )  ;", "} else", "if    ( current   instanceof   internal . Factory )     {", "return    (  ( internal . Factory )     ( current )  )  . create (  )  ;", "} else    {", "return   current ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["unpack"], "fileName": "org.gradle.util.DeferredUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( obj 1    instanceof   Enum )  )     |  |     (  !  ( obj 2    instanceof   Enum )  )  )     {", "return   false ;", "}", "Enum   e 1     =     (  ( Enum )     ( obj 1  )  )  ;", "Enum   e 2     =     (  ( Enum )     ( obj 2  )  )  ;", "return    (  ( e 1  . getDeclaringClass (  )  . getCanonicalName (  )  . equals ( e 2  . getDeclaringClass (  )  . getCanonicalName (  )  )  )     &  &     (  ( e 1  . ordinal (  )  )     =  =     ( e 2  . ordinal (  )  )  )  )     &  &     ( e 1  . name (  )  . equals ( e 2  . name (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkEnumEquality"], "fileName": "org.gradle.util.DiffUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( ObjectUtils . equals ( obj 1  ,    obj 2  )  )     |  |     ( DiffUtil . checkEnumEquality ( obj 1  ,    obj 2  )  )  ;", "}", "METHOD_END"], "methodName": ["checkEquality"], "fileName": "org.gradle.util.DiffUtil"}, {"methodBody": ["METHOD_START", "{", "Map < K ,    V >    added    =    new   HashMap < K ,    V >  ( newMap )  ;", "added . keySet (  )  . removeAll ( oldMap . keySet (  )  )  ;", "for    ( Map . Entry < K ,    V >    entry    :    added . entrySet (  )  )     {", "changeListener . added ( entry )  ;", "}", "Map < K ,    V >    removed    =    new   HashMap < K ,    V >  ( oldMap )  ;", "removed . keySet (  )  . removeAll ( newMap . keySet (  )  )  ;", "for    ( Map . Entry < K ,    V >    entry    :    removed . entrySet (  )  )     {", "changeListener . removed ( entry )  ;", "}", "Map < K ,    V >    same    =    new   HashMap < K ,    V >  ( newMap )  ;", "same . keySet (  )  . retainAll ( oldMap . keySet (  )  )  ;", "for    ( Map . Entry < K ,    V >    entry    :    same . entrySet (  )  )     {", "if    (  !  (  . checkEquality ( entry . getValue (  )  ,    oldMap . get ( entry . getKey (  )  )  )  )  )     {", "changeListener . changed ( entry )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["diff"], "fileName": "org.gradle.util.DiffUtil"}, {"methodBody": ["METHOD_START", "{", "Set < T >    added    =    new   HashSet < T >  ( newSet )  ;", "added . removeAll ( oldSet )  ;", "for    ( T   t    :    added )     {", "changeListener . added ( t )  ;", "}", "Set < T >    removed    =    new   HashSet < T >  ( oldSet )  ;", "removed . removeAll ( newSet )  ;", "for    ( T   t    :    removed )     {", "changeListener . removed ( t )  ;", "}", "}", "METHOD_END"], "methodName": ["diff"], "fileName": "org.gradle.util.DiffUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   new   URI (  (  (  (  (  (  (  ( repositoryUrl    +     \"  /  \"  )     +    archiveName )     +     \"  -  \"  )     +     ( version . getVersion (  )  )  )     +     \"  -  \"  )     +    archiveClassifier )     +     \"  . zip \"  )  )  ;", "}    catch    ( URISyntaxExcep   e )     {", "throw   UncheckedExcep . throwAsUncheckedExcep ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getDistribution"], "fileName": "org.gradle.util.DistributionLocator"}, {"methodBody": ["METHOD_START", "{", "return   getDistributionFor ( version ,     \" bin \"  )  ;", "}", "METHOD_END"], "methodName": ["getDistributionFor"], "fileName": "org.gradle.util.DistributionLocator"}, {"methodBody": ["METHOD_START", "{", "return   getDistribution ( getDistributionRepository ( version )  ,    version ,     \" gradle \"  ,    type )  ;", "}", "METHOD_END"], "methodName": ["getDistributionFor"], "fileName": "org.gradle.util.DistributionLocator"}, {"methodBody": ["METHOD_START", "{", "if    ( version . isSnapshot (  )  )     {", "return    . SNAPSHOT _ REPOSITORY ;", "} else    {", "return    . RELEASE _ REPOSITORY ;", "}", "}", "METHOD_END"], "methodName": ["getDistributionRepository"], "fileName": "org.gradle.util.DistributionLocator"}, {"methodBody": ["METHOD_START", "{", "boolean   entryExtracted    =    false ;", "ZipInputStream   zipStream    =    null ;", "BufferedOutputStream   extractTargetStream    =    null ;", "try    {", "zipStream    =    new   ZipInputStream ( new   FileInputStream ( jarFile )  )  ;", "extractTargetStream    =    new   BufferedOutputStream ( new   FileOutputStream ( extractToFile )  )  ;", "boolean   classFileExtracted    =    false ;", "boolean   zipStreamEndReached    =    false ;", "while    (  (  ! classFileExtracted )     &  &     (  ! zipStreamEndReached )  )     {", "final   ZipEntry   candidateZipEntry    =    zipStream . getNextEntry (  )  ;", "if    ( candidateZipEntry    =  =    null )     {", "zipStreamEndReached    =    true ;", "} else    {", "if    ( candidateZipEntry . getName (  )  . equals ( entryName )  )     {", "IOs . copy ( zipStream ,    extractTargetStream )  ;", "classFileExtracted    =    true ;", "entryExtracted    =    true ;", "}", "}", "}", "}    finally    {", "IOs . closeQuietly ( zipStream )  ;", "IOs . closeQuietly ( extractTargetStream )  ;", "}", "return   entryExtracted ;", "}", "METHOD_END"], "methodName": ["extractZipEntry"], "fileName": "org.gradle.util.JarUtil"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,     \"  -  \"  )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    1  -  \"  )  ;", "}", "}  )  ;", "outputStream . write (  \" line    \"  . getBytes (  )  )  ;", "outputStream . write (  \"  1  - line    2  \"  . getBytes (  )  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    2  -  \"  )  ;", "}", "}  )  ;", "outputStream . write (  \"  -  \"  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["buffersTextUntilEndOfLineReached"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . endOfStream ( null )  ;", "}", "}  )  ;", "outputStream . close (  )  ;", "outputStream . write (  \" ignore   me \"  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["cannotWriteAfterClose"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "final   String   separator    =    new   String ( new   byte [  ]  {     '  \\ r '  ,     '  \\ n '     }  )  ;", "System . setProperty (  \" line . separator \"  ,    separator )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  (  \" line    1  \"     +    separator )  )  ;", "one ( action )  . text (  (  \" line    2  \"     +    separator )  )  ;", "}", "}  )  ;", "outputStream . write (  (  (  (  \" line    1  \"     +    separator )     +     \" line    2  \"  )     +    separator )  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["handlesMultiCharacterLineSeparator"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,     \"  -  \"  )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    1  -  \"  )  ;", "one ( action )  . text (  \" line    2  -  \"  )  ;", "}", "}  )  ;", "outputStream . write ( String . format (  \" line    1  - line    2  -  \"  )  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["handlesSingleCharacterLineSeparator"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text ( TextUtil . toPlatformLineSeparators (  \" line    1  \\ n \"  )  )  ;", "one ( action )  . text ( TextUtil . toPlatformLineSeparators (  \" line    2  \\ n \"  )  )  ;", "}", "}  )  ;", "outputStream . write ( TextUtil . toPlatformLineSeparators (  \" line    1  \\ nline    2  \\ n \"  )  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["logsEachLineAsASeparateLogMessage"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,     \"  -  \"  )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \"  -  \"  )  ;", "one ( action )  . text (  \"  -  \"  )  ;", "}", "}  )  ;", "outputStream . write (  \"  -  -  \"  . getBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["logsEmptyLines"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,     \"  -  \"  )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" a   line   longer   than    8    bytes   long -  \"  )  ;", "one ( action )  . text (  \" line    2  \"  )  ;", "}", "}  )  ;", "outputStream . write (  \" a   line   longer   than    8    bytes   long -  \"  . getBytes (  )  )  ;", "outputStream . write (  \" line    2  \"  . getBytes (  )  )  ;", "outputStream . flush (  )  ;", "}", "METHOD_END"], "methodName": ["logsLineWhichIsLongerThanInitialBufferLength"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,     \"  -  \"  )  ;", "outputStream    =    new    ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    1  -  \"  )  ;", "one ( action )  . endOfStream ( null )  ;", "}", "}  )  ;", "outputStream . write (  \" line    1  -  \"  . getBytes (  )  )  ;", "outputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["logsNothingOnCloseWhenCompleteLineHasBeenWrittenToStream"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . endOfStream ( null )  ;", "}", "}  )  ;", "outputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["logsNothingOnCloseWhenNothingHasBeenWrittenToStream"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    1  \"  )  ;", "one ( action )  . endOfStream ( null )  ;", "}", "}  )  ;", "outputStream . write (  \" line    1  \"  . getBytes (  )  )  ;", "outputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["logsPartialLineOnClose"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \" line    1  \"  )  ;", "}", "}  )  ;", "outputStream . write (  \" line    1  \"  . getBytes (  )  )  ;", "outputStream . flush (  )  ;", "}", "METHOD_END"], "methodName": ["logsPartialLineOnFlush"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "eol    =    SystemProperties . getInstance (  )  . getLineSeparator (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "LineBufferingOutputStream   outputStream    =    new   LineBufferingOutputStream ( action ,     8  ,     1  3  )  ;", "context . checking ( new   Expectations (  )     {", "{", "one ( action )  . text (  \"  1  2  3  4  5  6  7  8  9  0  1  2  3  \"  )  ;", "one ( action )  . text (  \"  4  5  6  7  8  9  0  1  2  3  4  5  6  \"  )  ;", "one ( action )  . text (  \"  7  8  9  \"  )  ;", "one ( action )  . endOfStream ( null )  ;", "}", "}  )  ;", "outputStream . write (  \"  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  \"  . getBytes (  )  )  ;", "outputStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["splitsLongLines"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" line . separator \"  ,    eol )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.gradle.util.LineBufferingOutputStreamTest"}, {"methodBody": ["METHOD_START", "{", "singleScheduledActions . add ( command )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.util.MockExecutor"}, {"methodBody": ["METHOD_START", "{", "runNow ( fixedScheduledActions )  ;", "}", "METHOD_END"], "methodName": ["runFixedScheduledActionsNow"], "fileName": "org.gradle.util.MockExecutor"}, {"methodBody": ["METHOD_START", "{", "while    (  !  ( actions . isEmpty (  )  )  )     {", "actions . remove (  0  )  . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["runNow"], "fileName": "org.gradle.util.MockExecutor"}, {"methodBody": ["METHOD_START", "{", "runNow ( singleScheduledActions )  ;", "}", "METHOD_END"], "methodName": ["runSingleScheduledActionsNow"], "fileName": "org.gradle.util.MockExecutor"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "turn   getTick ( tick )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["clockTick"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "syncPoint . expectBlocks ( action )  ;", "}", "METHOD_END"], "methodName": ["expectBlocks"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "expectLater ( tick )  ;", "closure . call (  )  ;", "shouldBeAt ( tick )  ;", "}", "METHOD_END"], "methodName": ["expectBlocksUntil"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "final   Thread   targetThread    =    Thread . currentThread (  )  ;", ". LOGGER . debug (  \" Thread    {  }    expecting   tick    {  }  \"  ,    targetThread ,    tick )  ;", "start ( new   Runnable (  )     {", "public   void   run (  )     {", "try    {", "Thread . sleep (  5  0  0 L )  ;", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "lock . lock (  )  ;", "try    {", ". ClockTickImpl   clockTick    =    getTick ( tick )  ;", "if    (  !  ( clockTick . isImmediatelyAfter ( currentTick )  )  )     {", "throw   new   RuntimeException ( String . format (  \" Cannot   wait   for    % s ,    as   clock   is   currently   at    % s .  \"  ,    clockTick ,    currentTick )  )  ;", "}", "if    (  !  ( active . contains ( targetThread )  )  )     {", "throw   new   RuntimeException (  \" Cannot   wait   for   clock   tick   from   a   thread   which   is   not   a   test   thread .  \"  )  ;", "}", "synching . add ( targetThread )  ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["expectLater"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "Date   start    =    new   Date (  )  ;", ". ThreadHandle   threadHandle    =    start ( closure )  ;", "threadHandle . waitFor (  )  ;", "Date   end    =    new   Date (  )  ;", "long   actual    =     ( end . getTime (  )  )     -     ( start . getTime (  )  )  ;", "long   expected    =    units . toMillis ( value )  ;", "if    ( actual    <     ( expected    -     2  0  0  )  )     {", "throw   new   RuntimeException ( String . format (  \" Action   did   not   block   for   expected   time .    Expected    ~     % d   ms ,    was    % d   ms .  \"  ,    expected ,    actual )  )  ;", "}", "if    ( actual    >     ( expected    +     1  2  0  0  )  )     {", "throw   new   RuntimeException ( String . format (  \" Action   did   not   complete   within   expected   time .    Expected    ~     % d   ms ,    was    % d   ms .  \"  ,    expected ,    actual )  )  ;", "}", "return   threadHandle ;", "}", "METHOD_END"], "methodName": ["expectTimesOut"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "syncPoint . expectUnblocks ( action )  ;", "}", "METHOD_END"], "methodName": ["expectUnblocks"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executor )     =  =    null )     {", "executor    =    new    . ExecutorImpl (  )  ;", "}", "return   executor ;", "}", "METHOD_END"], "methodName": ["getExecutor"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "return   new   DefaultExecutorFactory (  )     {", "@ Override", "protected   ExecutorService   createExecutor ( String   displayName )     {", "return   new    . ExecutorImpl (  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getExecutorFactory"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "MultithreadedTestRule . ClockTickImpl   clockTick    =    ticks . get ( tick )  ;", "if    ( clockTick    =  =    null )     {", "clockTick    =    new   MultithreadedTestRule . ClockTickImpl ( tick )  ;", "ticks . put ( tick ,    clockTick )  ;", "}", "return   clockTick ;", "}", "METHOD_END"], "methodName": ["getTick"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "Runnable   task    =    new   Runnable (  )     {", "public   void   run (  )     {", "closure . call (  )  ;", "}", "}  ;", "return   start ( task )  . waitFor (  )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    (  ( currentTick )     !  =     ( getTick ( tick )  )  )     {", "ow   new   RuntimeException ( String . format (  \" Expected   clock   to   be   at    % s ,    but   is   at    % s .  \"  ,    tick ,    currentTick )  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shouldBeAt"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "Runnable   task    =    new   Runnable (  )     {", "public   void   run (  )     {", "closure . call (  )  ;", "}", "}  ;", "return   start ( task )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "final   Thread   thread    =    new   Thread (  )     {", "@ Override", "public   String   toString (  )     {", "return    \" test   thread    \"     +     ( getId (  )  )  ;", "}", "public   void   run (  )     {", "Throwable   failure    =    null ;", "try    {", "try    {", "task . run (  )  ;", "}    catch    ( InvokerInvocationException   e )     {", "failure    =    e . getCause (  )  ;", "}    catch    ( Throwable   throwable )     {", "failure    =    throwable ;", "}", "}    finally    {", "testThreadFinished ( this ,    failure )  ;", "}", "}", "}  ;", "testThreadStarted ( thread )  ;", "thread . start (  )  ;", "return   new    . ThreadHandleImpl ( thread )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "MultithreadedTestRule . LOGGER . debug (  \" Thread    {  }    synching   at   tick    {  }  \"  ,    Thread . currentThread (  )  ,    tick )  ;", "lock . lock (  )  ;", "try    {", "MultithreadedTestRule . ClockTickImpl   clockTick    =    getTick ( tick )  ;", "if    (  !  ( clockTick . isImmediatelyAfter ( currentTick )  )  )     {", "throw   new   RuntimeException ( String . format (  \" Cannot   wait   for    % s ,    as   clock   is   currently   at    % s .  \"  ,    clockTick ,    currentTick )  )  ;", "}", "if    (  !  ( active . contains ( Thread . currentThread (  )  )  )  )     {", "throw   new   RuntimeException (  \" Cannot   wait   for   clock   tick   from   a   thread   which   is   not   a   test   thread .  \"  )  ;", "}", "Date   expiry    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     ( MultithreadedTestRule . MAX _ WAIT _ TIME )  )  )  ;", "synching . add ( Thread . currentThread (  )  )  ;", "condition . signalAll (  )  ;", "while    (  (  ( failures . isEmpty (  )  )     &  &     (  ( currentTick )     !  =    clockTick )  )     &  &     (  !  ( clockTick . allThreadsSynced ( synching ,    active )  )  )  )     {", "try    {", "boolean   signalled    =    condition . awaitUntil ( expiry )  ;", "if    (  ! signalled )     {", "throw   new   RuntimeException ( String . format (  \" Timeout   waiting   for   all   threads   to   reach    % s .    Currently   at    % s .  \"  ,    clockTick ,    currentTick )  )  ;", "}", "}    catch    ( InterruptedException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "if    (  !  ( failures . isEmpty (  )  )  )     {", "throw   new   RuntimeException ( String . format (  \" Could   not   wait   for   all   threads   to   reach    % s ,    as   a   failure   has   occurred   in   another   test   thread .  \"  ,    clockTick )  )  ;", "}", "if    ( clockTick . isImmediatelyAfter ( currentTick )  )     {", "currentTick    =    clockTick ;", "synching . clear (  )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "MultithreadedTestRule . LOGGER . debug (  \" Thread    {  }    sync   done \"  ,    Thread . currentThread (  )  )  ;", "}", "METHOD_END"], "methodName": ["syncAt"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "active . remove ( thread )  ;", "Matcher <  ?    extends   Throwable >    matcher    =    expectedFailure . get (  )  ;", "if    ( failure    !  =    null )     {", "if    (  ( matcher    !  =    null )     &  &     ( matcher . matches ( failure )  )  )     {", ". LOGGER . debug (  \" Finished    {  }    with   expected   failure .  \"  ,    thread )  ;", "} else    {", ". LOGGER . error ( String . format (  \" Failure   in    % s \"  ,    thread )  ,    failure )  ;", "failures . add ( failure )  ;", "}", "} else    {", "if    ( matcher    !  =    null )     {", "String   message    =    String . format (  \" Did   not   get   expected   failure   in    % s \"  ,    thread )  ;", ". LOGGER . error ( message )  ;", "failures . add ( new   AssertionFailedError ( message )  )  ;", "} else    {", ". LOGGER . debug (  \" Finished    {  }  \"  ,    thread )  ;", "}", "}", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testThreadFinished"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "if    ( stopped )     {", "throw   new   IllegalStateException (  \" Cannot   start   new   threads ,    as   this   test   case   has   been   stopped .  \"  )  ;", "}", ". LOGGER . debug (  \" Started    {  }  \"  ,    thread )  ;", "active . add ( thread )  ;", "condition . signalAll (  )  ;", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testThreadStarted"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "Date   expiry    =    new   Date (  (  ( System . currentTimeMillis (  )  )     +     (  2     *     ( MultithreadedTestRule . MAX _ WAIT _ TIME )  )  )  )  ;", "lock . lock (  )  ;", "try    {", "MultithreadedTestRule . LOGGER . debug (  \" Waiting   for   test   threads   complete .  \"  )  ;", "if    ( active . contains ( Thread . currentThread (  )  )  )     {", "throw   new   RuntimeException (  \" A   test   thread   cannot   wait   for   test   threads   to   complete .  \"  )  ;", "}", "try    {", "while    (  !  ( active . isEmpty (  )  )  )     {", "boolean   signaled    =    condition . awaitUntil ( expiry )  ;", "if    (  ! signaled )     {", "failures . add ( new   RuntimeException (  \" Timeout   waiting   for   threads   to   finish .  \"  )  )  ;", "break ;", "}", "}", "}    catch    ( InterruptedException   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "MultithreadedTestRule . LOGGER . debug (  \" All   test   threads   complete .  \"  )  ;", "if    (  !  ( failures . isEmpty (  )  )  )     {", "Throwable   failure    =    failures . get (  0  )  ;", "failures . clear (  )  ;", "if    ( failure   instanceof   RuntimeException )     {", "throw    (  ( RuntimeException )     ( failure )  )  ;", "}", "if    ( failure   instanceof   Error )     {", "throw    (  ( Error )     ( failure )  )  ;", "}", "throw   new   RuntimeException (  \" An   unexpected   exception   occurred   in   a   test   thread .  \"  ,    failure )  ;", "}", "}    finally    {", "lock . unlock (  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForAll"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "lock . lock (  )  ;", "try    {", "opped    =    true ;", "}    finally    {", "lock . unlock (  )  ;", "}", "waitForAll (  )  ;", "}", "METHOD_END"], "methodName": ["waitForStop"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "expectedFailure . set ( matcher )  ;", "}", "METHOD_END"], "methodName": ["willFailWith"], "fileName": "org.gradle.util.MultithreadedTestRule"}, {"methodBody": ["METHOD_START", "{", "this . pattern    =    pattern ;", "matches . clear (  )  ;", "candidates . clear (  )  ;", "if    ( items . contains ( pattern )  )     {", "matches . add ( pattern )  ;", "return   pattern ;", "}", "if    (  ( pattern . length (  )  )     =  =     0  )     {", "return   null ;", "}", "Pattern   camelCasePattern    =     . getPatternForName ( pattern )  ;", "Pattern   normalisedCamelCasePattern    =    Pattern . compile ( camelCasePattern . pattern (  )  ,    Pattern . CASE _ INSENSITIVE )  ;", "String   normalisedPattern    =    pattern . toUpperCase (  )  ;", "Set < String >    caseInsensitiveMatches    =    new   TreeSet < String >  (  )  ;", "Set < String >    caseSensitiveCamelCaseMatches    =    new   TreeSet < String >  (  )  ;", "Set < String >    caseInsensitiveCamelCaseMatches    =    new   TreeSet < String >  (  )  ;", "for    ( String   candidate    :    items )     {", "if    ( candidate . equalsIgnoreCase ( pattern )  )     {", "caseInsensitiveMatches . add ( candidate )  ;", "}", "if    ( camelCasePattern . matcher ( candidate )  . matches (  )  )     {", "caseSensitiveCamelCaseMatches . add ( candidate )  ;", "continue ;", "}", "if    ( normalisedCamelCasePattern . matcher ( candidate )  . lookingAt (  )  )     {", "caseInsensitiveCamelCaseMatches . add ( candidate )  ;", "continue ;", "}", "if    (  ( StringUtils . getLevenshteinDistance ( normalisedPattern ,    candidate . toUpperCase (  )  )  )     <  =     ( Math . min (  3  ,     (  ( pattern . length (  )  )     /     2  )  )  )  )     {", "candidates . add ( candidate )  ;", "}", "}", "if    (  !  ( caseInsensitiveMatches . isEmpty (  )  )  )     {", "matches . addAll ( caseInsensitiveMatches )  ;", "} else", "if    (  !  ( caseSensitiveCamelCaseMatches . isEmpty (  )  )  )     {", "matches . addAll ( caseSensitiveCamelCaseMatches )  ;", "} else    {", "matches . addAll ( caseInsensitiveCamelCaseMatches )  ;", "}", "if    (  ( matches . size (  )  )     =  =     1  )     {", "return   matches . first (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "String   name    =    find ( pattern ,    items . keySet (  )  )  ;", "if    ( name    !  =    null )     {", "return   items . get ( name )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["find"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "String   capItem    =    StringUtils . capitalize ( singularItemDescription )  ;", "if    (  !  ( ms . isEmpty (  )  )  )     {", "return   String . format (  \"  % s    '  % s '    is   ambiguous   in    % s .    Candidates   are :     % s .  \"  ,    capItem ,    pattern ,    container ,    GUtil . toString ( ms )  )  ;", "}", "if    (  !  ( candidates . isEmpty (  )  )  )     {", "return   String . format (  \"  % s    '  % s '    not   found   in    % s .    Some   candidates   are :     % s .  \"  ,    capItem ,    pattern ,    container ,    GUtil . toString ( candidates )  )  ;", "}", "return   String . format (  \"  % s    '  % s '    not   found   in    % s .  \"  ,    capItem ,    pattern ,    container )  ;", "}", "METHOD_END"], "methodName": ["formatErrorMessage"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "return   candidates ;", "}", "METHOD_END"], "methodName": ["getCandidates"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "return   matches ;", "}", "METHOD_END"], "methodName": ["getMatches"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "Pattern   boundaryPattern    =    Pattern . compile (  \"  (  (  ^  |  \\  \\ p { Punct }  )  \\  \\ p { javaLowerCase }  +  )  |  (  \\  \\ p { javaUpperCase }  \\  \\ p { javaLowerCase }  *  )  \"  )  ;", "matcher    =    boundaryPattern . matcher ( name )  ;", "int   pos    =     0  ;", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "while    ( matcher . find (  )  )     {", "String   prefix    =    name . substring ( pos ,    matcher . start (  )  )  ;", "if    (  ( prefix . length (  )  )     >     0  )     {", "builder . append ( Pattern . quote ( prefix )  )  ;", "}", "builder . append ( Pattern . quote ( matcher . group (  )  )  )  ;", "builder . append (  \"  [  \\  \\ p { javaLowerCase }  \\  \\ p { Digit }  ]  *  \"  )  ;", "pos    =    matcher . end (  )  ;", "}", "builder . append ( Pattern . quote ( name . substring ( pos ,    name . length (  )  )  )  )  ;", "return   Pattern . compile ( builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["getPatternForName"], "fileName": "org.gradle.util.NameMatcher"}, {"methodBody": ["METHOD_START", "{", "assertThat ( matcher . find ( name ,    WrapUtil . toList ( items )  )  ,    nullValue (  )  )  ;", "assertThat ( matcher . getMatches (  )  ,    s . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertDoesNotMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    allItems    =    newArrayList ( concat ( WrapUtil . toList ( match )  ,    WrapUtil . toList ( extraItems )  )  )  ;", "assertThat ( m . find ( name ,    allItems )  ,    equalTo ( match )  )  ;", "assertThat ( m . getMatches (  )  ,    equalTo ( WrapUtil . toSet ( match )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "matcher . find (  \" n \"  ,    WrapUtil . toList (  \" number \"  ,     \" name \"  ,     \" other \"  )  )  ;", "assertThat ( matcher . formatErrorMessage (  \" thing \"  ,     \" container \"  )  ,    equalTo (  \" Thing    ' n '    is   ambiguous   in   container .    Candidates   are :     ' name '  ,     ' number '  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildsErrorMessageForMultipleMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "matcher . find (  \" name \"  ,    WrapUtil . toList (  \" other \"  )  )  ;", "assertThat ( matcher . formatErrorMessage (  \" thing \"  ,     \" container \"  )  ,    equalTo (  \" Thing    ' name '    not   found   in   container .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildsErrorMessageForNoMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "matcher . find (  \" name \"  ,    WrapUtil . toList (  \" other \"  ,     \" lame \"  ,     \" tame \"  )  )  ;", "assertThat ( matcher . formatErrorMessage (  \" thing \"  ,     \" container \"  )  ,    equalTo (  \" Thing    ' name '    not   found   in   container .    Some   candidates   are :     ' lame '  ,     ' tame '  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["buildsErrorMessageForPotentialMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( matcher . find (  \" sN \"  ,    WrapUtil . toList (  \" someName \"  ,     \" soNa \"  ,     \" other \"  )  )  ,    nullValue (  )  )  ;", "assertThat ( matcher . getMatches (  )  ,    equalTo ( WrapUtil . toSet (  \" someName \"  ,     \" soNa \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSelectItemsWhenMultipleCamelCaseMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( matcher . find (  \" someName \"  ,    WrapUtil . toList (  \" somename \"  ,     \" SomeName \"  ,     \" other \"  )  )  ,    nullValue (  )  )  ;", "assertThat ( matcher . getMatches (  )  ,    equalTo ( WrapUtil . toSet (  \" somename \"  ,     \" SomeName \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSelectItemsWhenMultipleCaseInsensitiveMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertDoesNotMatch (  \" name \"  )  ;", "assertDoesNotMatch (  \" name \"  ,     \" other \"  )  ;", "assertDoesNotMatch (  \" name \"  ,     \" na \"  )  ;", "assertDoesNotMatch (  \" sN \"  ,     \" otherName \"  )  ;", "assertDoesNotMatch (  \" sN \"  ,     \" someThing \"  )  ;", "assertDoesNotMatch (  \" soN \"  ,     \" saN \"  )  ;", "assertDoesNotMatch (  \" soN \"  ,     \" saName \"  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSelectItemsWhenNoMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    items    =    GUtil . map (  \" someName \"  ,     9  ,     \" soName \"  ,     1  0  )  ;", "Integer   match    =    m . find (  \" soNa \"  ,    items )  ;", "assertThat ( match ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSelectMapEntryWhenMultiplePartialMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "Integer   match    =    matcher . find (  \" soNa \"  ,    Collections . singletonMap (  \" does   not   match \"  ,     9  )  )  ;", "assertThat ( match ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["doesNotSelectMapEntryWhenNoMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertDoesNotMatch (  \"  \"  ,     \" something \"  )  ;", "}", "METHOD_END"], "methodName": ["emptyPatternDoesNotSelectAnything"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertDoesNotMatch (  \" name \\  \\ othername \"  ,     \" other \"  )  ;", "}", "METHOD_END"], "methodName": ["escapesRegexpChars"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" somename \"  ,     \" someName \"  ,     \" someNameWithExtra \"  )  ;", "assertMatches (  \" soNa \"  ,     \" sona \"  ,     \" someName \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersCaseInsensitiveMatchOverCamelCaseMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" soNa \"  ,     \" someName \"  ,     \" somename \"  )  ;", "assertMatches (  \" SN \"  ,     \" SomeName \"  ,     \" someName \"  )  ;", "assertMatches (  \" na 1  \"  ,     \" name 1  \"  ,     \" Name 1  \"  ,     \" NAME 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersCaseSensitiveCamelCaseMatchOverCaseInsensitiveCamelCaseMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" sName \"  ,     \" sName \"  ,     \" someName \"  ,     \" sNames \"  )  ;", "assertMatches (  \" so   Name \"  ,     \" so   Name \"  ,     \" some   Name \"  ,     \" so   name \"  )  ;", "assertMatches (  \" ABC \"  ,     \" ABC \"  ,     \" AaBbCc \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersExactMatchOverCamelCaseMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" name \"  ,     \" name \"  ,     \" Name \"  ,     \" NAME \"  )  ;", "assertMatches (  \" someName \"  ,     \" someName \"  ,     \" SomeName \"  ,     \" somename \"  ,     \" SOMENAME \"  )  ;", "assertMatches (  \" some   Name \"  ,     \" some   Name \"  ,     \" Some   Name \"  ,     \" some   name \"  ,     \" SOME   NAME \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersExactMatchOverCaseInsensitiveMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" name \"  ,     \" name \"  ,     \" nam \"  ,     \" n \"  ,     \" NAM \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersExactMatchOverPartialMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" someName \"  ,     \" someName \"  ,     \" someNameWithExtra \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersExactMatchOverPrefixMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" sN \"  ,     \" someName \"  ,     \" someNameWithExtra \"  )  ;", "assertMatches (  \" name \"  ,     \" names \"  ,     \" nameWithExtra \"  )  ;", "assertMatches (  \" s _ n \"  ,     \" some _ name \"  ,     \" some _ name _ with _ extra \"  )  ;", "}", "METHOD_END"], "methodName": ["prefersFullCamelCaseMatchOverCamelCasePrefix"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( matcher . find (  \" name \"  ,    WrapUtil . toList (  \" tame \"  ,     \" lame \"  ,     \" other \"  )  )  ,    nullValue (  )  )  ;", "assertThat ( matcher . getMatches (  )  ,    s . isEmpty (  )  )  ;", "assertThat ( matcher . getCandidates (  )  ,    equalTo ( WrapUtil . toSet (  \" tame \"  ,     \" lame \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["reportsPotentialMatches"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" name \"  ,     \" name \"  )  ;", "assertMatches (  \" name \"  ,     \" name \"  ,     \" other \"  )  ;", "}", "METHOD_END"], "methodName": ["selectsExactMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" sN \"  ,     \" someName \"  )  ;", "assertMatches (  \" soN \"  ,     \" someName \"  )  ;", "assertMatches (  \" SN \"  ,     \" someName \"  )  ;", "assertMatches (  \" SN \"  ,     \" SomeName \"  )  ;", "assertMatches (  \" SN \"  ,     \" SomeNameWithExtraStuff \"  )  ;", "assertMatches (  \" so _ n \"  ,     \" some _ name \"  )  ;", "assertMatches (  \" so _ n \"  ,     \" some _ Name \"  )  ;", "assertMatches (  \" so _ n _ wi _ ext \"  ,     \" some _ Name _ with _ EXTRA \"  )  ;", "assertMatches (  \" so . n \"  ,     \" some . name \"  )  ;", "assertMatches (  \" so   n \"  ,     \" some   name \"  )  ;", "assertMatches (  \" ABC \"  ,     \" ABC \"  )  ;", "assertMatches (  \" a 9 N \"  ,     \" a 9 Name \"  )  ;", "assertMatches (  \" a 9 N \"  ,     \" abc 9 Name \"  )  ;", "assertMatches (  \" a 9 n \"  ,     \" abc 9 Name \"  )  ;", "}", "METHOD_END"], "methodName": ["selectsItemWithMatchingCamelCasePrefix"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "assertMatches (  \" na \"  ,     \" name \"  )  ;", "assertMatches (  \" na \"  ,     \" name \"  ,     \" other \"  )  ;", "assertMatches (  \" na \"  ,     \" Name \"  )  ;", "assertMatches (  \" NA \"  ,     \" name \"  )  ;", "assertMatches (  \" somena \"  ,     \" someName \"  )  ;", "assertMatches (  \" somena \"  ,     \" SomeName \"  )  ;", "assertMatches (  \" somena \"  ,     \" SomeName \"  )  ;", "assertMatches (  \" some   na \"  ,     \" Some   Name \"  )  ;", "}", "METHOD_END"], "methodName": ["selectsItemWithMatchingPrefix"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "Integer   match    =    matcher . find (  \" name \"  ,    Collections . singletonMap (  \" name \"  ,     9  )  )  ;", "assertThat ( match ,    equalTo (  9  )  )  ;", "}", "METHOD_END"], "methodName": ["selectsMapEntryWhenExactMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "Integer   match    =    matcher . find (  \" soNa \"  ,    Collections . singletonMap (  \" someName \"  ,     9  )  )  ;", "assertThat ( match ,    equalTo (  9  )  )  ;", "}", "METHOD_END"], "methodName": ["selectsMapEntryWhenOnePartialMatch"], "fileName": "org.gradle.util.NameMatcherTest"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtils . isEmpty ( name )  )     {", "DeprecationLogger . nagUserOfDeprecatedThing (  (  (  \" The    \"     +    nameDescription )     +     \"    is   empty \"  )  ,    fixSuggestion )  ;", "} else", "if    ( StringUtils . containsAny ( name ,     . FORBIDDEN _ CHARACTERS )  )     {", "DeprecationLogger . nagUserOfDeprecatedThing (  (  (  (  (  (  \" The    \"     +    nameDescription )     +     \"     '  \"  )     +    name )     +     \"  '    contains   at   least   one   of   the   following   characters :     \"  )     +     ( toString (  . FORBIDDEN _ CHARACTERS )  )  )  ,    fixSuggestion )  ;", "} else", "if    (  (  ( name . charAt (  0  )  )     =  =     (  . FORBIDDEN _ LEADING _ AND _ TRAILING _ CHARACTER )  )     |  |     (  ( name . charAt (  (  ( name . length (  )  )     -     1  )  )  )     =  =     (  . FORBIDDEN _ LEADING _ AND _ TRAILING _ CHARACTER )  )  )     {", "DeprecationLogger . nagUserOfDeprecatedThing (  (  (  (  (  (  (  \" The    \"     +    nameDescription )     +     \"     '  \"  )     +    name )     +     \"  '    starts   or   ends   with   a    '  \"  )     +     (  . FORBIDDEN _ LEADING _ AND _ TRAILING _ CHARACTER )  )     +     \"  '  \"  )  ,    fixSuggestion )  ;", "}", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "org.gradle.util.NameValidator"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   FileUtils . get ( from ,    to )  ;", "}    catch    ( Exception   e )     {", "throw   UncheckedException . throwAsUncheckedException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["relativePath"], "fileName": "org.gradle.util.RelativePathUtil"}, {"methodBody": ["METHOD_START", "{", "T   orginalValue    =    getter . call (  )  ;", "setter . execute ( value )  ;", "try    {", "return   whiled . call (  )  ;", "}    finally    {", "setter . execute ( orginalValue )  ;", "}", "}", "METHOD_END"], "methodName": ["swap"], "fileName": "org.gradle.util.Swapper"}, {"methodBody": ["METHOD_START", "{", "if    (  ( major )     !  =     ( other . major )  )     {", "return    ( major )     -     ( other . major )  ;", "}", "if    (  ( minor )     !  =     ( other . minor )  )     {", "return    ( minor )     -     ( other . minor )  ;", "}", "if    (  ( micro )     !  =     ( other . micro )  )     {", "return    ( micro )     -     ( other . micro )  ;", "}", "if    (  ( patch )     !  =     ( other . patch )  )     {", "return    ( patch )     -     ( other . patch )  ;", "}", "return   Ordering . natural (  )  . nullsLast (  )  . compare ( toLowerCase ( qualifier )  ,    toLowerCase ( other . qualifier )  )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return    ( other   instanceof   VersionNumber )     &  &     (  ( compareTo (  (  ( VersionNumber )     ( other )  )  )  )     =  =     0  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   new   VersionNumber ( major ,    minor ,    micro ,    patch ,    null ,    scheme )  ;", "}", "METHOD_END"], "methodName": ["getBaseVersion"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   major ;", "}", "METHOD_END"], "methodName": ["getMajor"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   micro ;", "}", "METHOD_END"], "methodName": ["getMicro"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   minor ;", "}", "METHOD_END"], "methodName": ["getMinor"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   patch ;", "}", "METHOD_END"], "methodName": ["getPatch"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   qualifier ;", "}", "METHOD_END"], "methodName": ["getQualifier"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "int   result    =    major ;", "result    =     (  3  1     *    result )     +     ( minor )  ;", "result    =     (  3  1     *    result )     +     ( micro )  ;", "result    =     (  3  1     *    result )     +     ( patch )  ;", "result    =     (  3  1     *    result )     +     ( Objects . hashCode ( qualifier )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   VersionNumber . DEFAULT _ SCHEME . parse ( versionString )  ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   VersionNumber . DEFAULT _ SCHEME ;", "}", "METHOD_END"], "methodName": ["scheme"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   string    =  =    null    ?    null    :    string . toLowerCase (  )  ;", "}", "METHOD_END"], "methodName": ["toLowerCase"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   scheme . format ( this )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   new   VersionNumber ( major ,     0  ,     0  ,     0  ,    null ,    VersionNumber . DEFAULT _ SCHEME )  ;", "}", "METHOD_END"], "methodName": ["version"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   VersionNumber . PATCH _ SCHEME ;", "}", "METHOD_END"], "methodName": ["withPatchNumber"], "fileName": "org.gradle.util.VersionNumber"}, {"methodBody": ["METHOD_START", "{", "return   new   LinkedHashSet < T >  ( c )  ;", "}", "METHOD_END"], "methodName": ["asSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "return   items ;", "}", "METHOD_END"], "methodName": ["toArray"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "DefaultDomainObjectSet < T >    set    =    new   DefaultDomainObjectSet < T >  ( type )  ;", "set . addAll ( Arys . asList ( items )  )  ;", "return   set ;", "}", "METHOD_END"], "methodName": ["toDomainObjectSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "Map < K ,    V >    map    =    new   LinkedHashMap < K ,    V >  (  )  ;", "map . put ( key ,    value )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["toLinkedMap"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "Set < T >    coll    =    new   LinkedHashSet < T >  (  )  ;", "Collections . dAll ( coll ,    items )  ;", "return   coll ;", "}", "METHOD_END"], "methodName": ["toLinkedSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "ArrayList < T >    coll    =    new   ArrayList < T >  (  )  ;", "Collections . addAll ( coll ,    items )  ;", "return   coll ;", "}", "METHOD_END"], "methodName": ["toList"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "ArrayList < T >    coll    =    new   ArrayList < T >  (  )  ;", "for    ( T   item    :    items )     {", "coll . add ( item )  ;", "}", "return   coll ;", "}", "METHOD_END"], "methodName": ["toList"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "Map < K ,    V >    map    =    new   HashMap < K ,    V >  (  )  ;", "map . put ( key ,    value )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["toMap"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "DefaultNamedDomainObjectSet < T >    domainObjectSet    =    new   DefaultNamedDomainObjectSet < T >  ( type ,    DirectInstantiator . INSTANCE )  ;", "Collections . addAll ( domainObjectSet ,    items )  ;", "return   domainObjectSet ;", "}", "METHOD_END"], "methodName": ["toNamedDomainObjectSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( key ,    value )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["toProperties"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "Set < T >    coll    =    new   HashSet < T >  (  )  ;", "Collections . dAll ( coll ,    items )  ;", "return   coll ;", "}", "METHOD_END"], "methodName": ["toSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "SortedMap < K ,    V >    map    =    new   TreeMap < K ,    V >  (  )  ;", "map . put ( key ,    value )  ;", "return   map ;", "}", "METHOD_END"], "methodName": ["toSortedMap"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "SortedSet < T >    coll    =    new   TreeSet < T >  (  )  ;", "Collections . addAll ( coll ,    items )  ;", "return   coll ;", "}", "METHOD_END"], "methodName": ["toSortedSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "SortedSet < T >    coll    =    new   TreeSet < T >  ( comp )  ;", "Collections . addAll ( coll ,    items )  ;", "return   coll ;", "}", "METHOD_END"], "methodName": ["toSortedSet"], "fileName": "org.gradle.util.WrapUtil"}, {"methodBody": ["METHOD_START", "{", "List < String >    commandLineArguments    =    new   ArrayList < String >  (  )  ;", "Character   currentQuote    =    null ;", "StringBuilder   currentOption    =    new   StringBuilder (  )  ;", "boolean   hasOption    =    false ;", "for    ( int   index    =     0  ;    index    <     ( arguments . length (  )  )  ;    index +  +  )     {", "char   c    =    arguments . charAt ( index )  ;", "if    (  ( currentQuote    =  =    null )     &  &     ( Character . isWhitespace ( c )  )  )     {", "if    ( hasOption )     {", "commandLineArguments . add ( currentOption . toString (  )  )  ;", "hasOption    =    false ;", "currentOption . setLength (  0  )  ;", "}", "} else", "if    (  ( currentQuote    =  =    null )     &  &     (  ( c    =  =     '  \"  '  )     |  |     ( c    =  =     '  \\  '  '  )  )  )     {", "currentQuote    =    c ;", "hasOption    =    true ;", "} else", "if    (  ( currentQuote    !  =    null )     &  &     ( c    =  =    currentQuote )  )     {", "currentQuote    =    null ;", "} else    {", "currentOption . append ( c )  ;", "hasOption    =    true ;", "}", "}", "if    ( hasOption )     {", "commandLineArguments . add ( currentOption . toString (  )  )  ;", "}", "return   commandLineArguments ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.gradle.util.internal.ArgumentsSplitter"}]