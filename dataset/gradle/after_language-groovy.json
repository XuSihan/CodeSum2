[{"methodBody": ["METHOD_START", "{", "final   File   tmpDir    =    new   File ( project . getBuildDir (  )  ,     \" tmp / groovydoc \"  )  ;", "FileOperations   fileOperations    =     (  ( ProjectInternal )     ( project )  )  ;", "fileOperations . delete ( tmpDir )  ;", "fileOperations . copy ( new   Action < CopySpec >  (  )     {", "public   void   execute ( CopySpec   copySpec )     {", "copySpec . from ( source )  . into ( tmpDir )  ;", "}", "}  )  ;", "List < File >    combinedClasspath    =    ImmutableList .  < File > builder (  )  . addAll ( classpath )  . addAll ( groovyClasspath )  . build (  )  ;", "VersionNumber   version    =    VersionNumber . parse ( getGroovyVersion ( combinedClasspath )  )  ;", "final   Map < String ,    Object >    args    =    Maps . newLinkedHashMap (  )  ;", "args . put (  \" sourcepath \"  ,    tmpDir . toString (  )  )  ;", "args . put (  \" destdir \"  ,    destDir )  ;", "args . put (  \" use \"  ,    use )  ;", "if    ( isAtLeast ( version ,     \"  2  .  4  .  6  \"  )  )     {", "args . put (  \" noTimestamp \"  ,    noTimestamp )  ;", "args . put (  \" noVersionStamp \"  ,    noVersionStamp )  ;", "}", "args . put (  \" private \"  ,    includePrivate )  ;", "AntGroovydoc . putIfNotNull ( args ,     \" windowtitle \"  ,    windowTitle )  ;", "AntGroovydoc . putIfNotNull ( args ,     \" doctitle \"  ,    docTitle )  ;", "AntGroovydoc . putIfNotNull ( args ,     \" header \"  ,    header )  ;", "AntGroovydoc . putIfNotNull ( args ,     \" footer \"  ,    footer )  ;", "if    ( overview    !  =    null )     {", "args . put (  \" overview \"  ,    overview )  ;", "}", "invokeGroovydoc ( links ,    combinedClasspath ,    args )  ;", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.gradle.api.internal.tasks.AntGroovydoc"}, {"methodBody": ["METHOD_START", "{", "File   temp ;", "final   String   tempPath ;", "try    {", "temp    =    File . createTempFile (  \" temp \"  ,     \"  \"  )  ;", "String   p    =    temp . getCanonicalPath (  )  ;", "tempPath    =     (  ( File . separatorChar )     =  =     '  /  '  )     ?    p    :    p . replace ( File . separatorChar ,     '  /  '  )  ;", "temp . deleteOnExit (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   GradleException (  \" Unable   to   create   temp   file   needed   for    \"  ,    e )  ;", "}", "ant . withClasspath ( combinedClasspath )  . execute ( new   groovy . lang . Closure < Object >  ( this ,    this )     {", "@ SuppressWarnings (  \" UnusedDeclaration \"  )", "public   Object   doCall ( Object   it )     {", "final   GroovyObjectSupport   antBuilder    =     (  ( GroovyObjectSupport )     ( it )  )  ;", "antBuilder . invokeMethod (  \" taskdef \"  ,    ImmutableMap . of (  \" name \"  ,     \" groovy \"  ,     \" classname \"  ,     \" Groovy \"  )  )  ;", "antBuilder . invokeMethod (  \" groovy \"  ,    new   Object [  ]  {     (  \" new   File (  '  \"     +    tempPath )     +     \"  '  )  . text    =    GroovySystem . version \"     }  )  ;", "return   null ;", "}", "}  )  ;", "try    {", "return   Files . toString ( temp ,    Charset . defaultCharset (  )  )  . trim (  )  ;", "}    catch    ( IOException   e )     {", "throw   new   GradleException (  \" Unable   to   find   Groovy   version   needed   for    \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getGroovyVersion"], "fileName": "org.gradle.api.internal.tasks.AntGroovydoc"}, {"methodBody": ["METHOD_START", "{", "ant . withClasspath ( combinedClasspath )  . execute ( new   groovy . lang . Closure < Object >  ( this ,    this )     {", "@ SuppressWarnings (  \" UnusedDeclaration \"  )", "public   Object   doCall ( Object   it )     {", "final   GroovyObjectSupport   antBuilder    =     (  ( GroovyObjectSupport )     ( it )  )  ;", "antBuilder . invokeMethod (  \" taskdef \"  ,    ImmutableMap . of (  \" name \"  ,     \" groovydoc \"  ,     \" classname \"  ,     \" \"  )  )  ;", "antBuilder . invokeMethod (  \" groovydoc \"  ,    new   Object [  ]  {    args ,    new   groovy . lang . Closure < Object >  ( this ,    this )     {", "public   Object   doCall ( Object   ignore )     {", "for    (  . Link   link    :    links )     {", "antBuilder . invokeMethod (  \" link \"  ,    new   Object [  ]  {    ImmutableMap . of (  \" packages \"  ,    Joiner . on (  \"  ,  \"  )  . join ( link . getPackages (  )  )  ,     \" href \"  ,    link . getUrl (  )  )     }  )  ;", "}", "return   null ;", "}", "}     }  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["invokeGroovydoc"], "fileName": "org.gradle.api.internal.tasks.AntGroovydoc"}, {"methodBody": ["METHOD_START", "{", "return    ( version . compareTo ( VersionNumber . parse ( versionString )  )  )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["isAtLeast"], "fileName": "org.gradle.api.internal.tasks.AntGroovydoc"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", "map . put ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["putIfNotNull"], "fileName": "org.gradle.api.internal.tasks.AntGroovydoc"}, {"methodBody": ["METHOD_START", "{", "VersionNumber   version    =    parseGroovyVersion (  )  ;", "if    (  ( version . compareTo ( VersionNumber . parse (  \"  2  .  1  \"  )  )  )     <     0  )     {", "throw   new   GradleException (  (  (  \" Using   a   Groovy   compiler   configuration   script   requires   Groovy    2  .  1  +    but   found   Groovy    \"     +    version )     +     \"  \"  )  )  ;", "}", "Binding   binding    =    new   Binding (  )  ;", "binding . setVariable (  \" configuration \"  ,    configuration )  ;", "Configuration   configuratorConfig    =    new   Configuration (  )  ;", "ImportCustomizer   customizer    =    new   ImportCustomizer (  )  ;", "customizer . addStaticStars (  \" CustomizationBuilder \"  )  ;", "configuratorConfig . addCompilationCustomizers ( customizer )  ;", "GroovyShell   shell    =    new   GroovyShell ( binding ,    configuratorConfig )  ;", "try    {", "shell . evaluate ( configScript )  ;", "}    catch    ( Exception   e )     {", "throw   new   GradleException (  (  \" Could   not   execute   Groovy   compiler   configuration   script :     \"     +     ( configScript . getAbsolutePath (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["applyConfigurationScript"], "fileName": "org.gradle.api.internal.tasks.compile.ApiGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "for    ( String   key    :    options . keySet (  )  )     {", "boolean   value    =    options . get ( key )  ;", "options . put ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["canonicalizeValues"], "fileName": "org.gradle.api.internal.tasks.compile.ApiGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "return   ClassLoaderUtils . getPlatformClassLoader (  )  ;", "}", "METHOD_END"], "methodName": ["getExtClassLoader"], "fileName": "org.gradle.api.internal.tasks.compile.ApiGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "String   version ;", "try    {", "version    =    System . getVersion (  )  ;", "}    catch    ( NoSuchMethodError   e )     {", "try    {", "Class <  ?  >    ih    =    Class . forName (  \" InvokerHelper \"  )  ;", "Method   getVersion    =    ih . getDeclaredMethod (  \" getVersion \"  )  ;", "version    =     (  ( String )     ( getVersion . invoke ( ih )  )  )  ;", "}    catch    ( Exception   e 1  )     {", "throw   new   GradleException (  \" Unable   to   determine      version .  \"  ,    e 1  )  ;", "}", "}", "return   VersionNumber . parse ( version )  ;", "}", "METHOD_END"], "methodName": ["parseGroovyVersion"], "fileName": "org.gradle.api.internal.tasks.compile.ApiGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "return    ( spec . getGroovyCompileOptions (  )  . isJavaAnnotationProcessing (  )  )     &  &     (  !  ( spec . getAnnotationProcessorPath (  )  . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["shouldProcessAnnotations"], "fileName": "org.gradle.api.internal.tasks.compile.ApiGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "this . compileOptions    =    compileOptions ;", "}", "METHOD_END"], "methodName": ["setGroovyCompileOptions"], "fileName": "org.gradle.api.internal.tasks.compile.DefaultGroovyJavaJointCompileSpec"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   delegate . execute ( spec )  ;", "}    catch    ( RuntimeException   e )     {", "if    (  (  ( spec . getCompileOptions (  )  . isFailOnError (  )  )     &  &     ( spec . getGroovyCompileOptions (  )  . isFailOnError (  )  )  )     |  |     (  !  ( CompilationFailedException . class . getName (  )  . equals ( e . getClass (  )  . getName (  )  )  )  )  )     {", "throw   e ;", "}", ". LOGGER . debug (  \" Ignoring   compilation   failure .  \"  )  ;", "return   WorkResults . didWork ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["delegateAndHandleErrors"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( NormalizingGroovyCompiler . LOGGER . isDebugEnabled (  )  )  )     {", "return ;", "}", "List < String >    compilerArgs    =    new   JavaCompilerArgumentsBuilder ( spec )  . includeLauncherOptions ( true )  . includeSourceFiles ( true )  . build (  )  ;", "String   joinedArgs    =    Joiner . on (  '     '  )  . join ( compilerArgs )  ;", "NormalizingGroovyCompiler . LOGGER . debug (  \" Java   compiler   arguments :     {  }  \"  ,    joinedArgs )  ;", "}", "METHOD_END"], "methodName": ["logCompilerArguments"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( spec . getGroovyCompileOptions (  )  . isListFiles (  )  )  )     {", "return ;", "}", "StringBuilder   builder    =    new   StringBuilder (  )  ;", "builder . append (  \" Source   files   to   be   compiled :  \"  )  ;", "for    ( File   file    :    spec . getSource (  )  )     {", "builder . append (  '  \\ n '  )  ;", "builder . append ( file )  ;", "}", ". LOGGER . quiet ( builder . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["logSourceFiles"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "final   List < String >    fileExtensions    =    CollectionUtils . collect ( spec . getGroovyCompileOptions (  )  . getFileExtensions (  )  ,    new   Transformer < String ,    String >  (  )     {", "@ Override", "public   String   transform ( String   extension )     {", "return    '  .  '     +    extension ;", "}", "}  )  ;", "FileCollection   filtered    =    spec . getSource (  )  . filter ( new   Spec < File >  (  )     {", "public   boolean   isSatisfiedBy ( File   element )     {", "for    ( String   fileExtension    :    fileExtensions )     {", "if    ( hasExtension ( element ,    fileExtension )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "}  )  ;", "spec . setSource ( new   file . collections . SimpleFileCollection ( filtered . getFiles (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveAndFilterSourceFiles"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "List < File >    classPath    =    Lists . newArrayList ( spec . getCompileClasspath (  )  )  ;", "classPath . add ( spec . getDestinationDir (  )  )  ;", "spec . setCompileClasspath ( classPath )  ;", "}", "METHOD_END"], "methodName": ["resolveClasspath"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "spec . getCompileOptions (  )  . setCompilerArgs ( CollectionUtils . toStringList ( spec . getCompileOptions (  )  . getCompilerArgs (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["resolveNonStringsInCompilerArgs"], "fileName": "org.gradle.api.internal.tasks.compile.NormalizingGroovyCompiler"}, {"methodBody": ["METHOD_START", "{", "AnnotationProcessorPathFactory   annotationProcessorPathFactory    =    getServices (  )  . get ( AnnotationProcessorPathFactory . class )  ;", "FileCollection   processorClasspath    =    annotationProcessorPathFactory . getEffectiveAnnotationProcessorClasspath ( Options ,    getClasspath (  )  )  ;", "return   Lists . newArrayList ( processorClasspath )  ;", "}", "METHOD_END"], "methodName": ["calculateAnnotationProcessorClasspath"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "if    ( getGroovyClasspath (  )  . isEmpty (  )  )     {", "throw   new   InvalidUserDataException (  (  (  (  \"  '  \"     +     ( getName (  )  )  )     +     \"  . groovyClasspath '    must   not   be   empty .    If   a   Groovy   compile   dependency   is   provided ,     \"  )     +     \" the    ' groovy - base '    plugin   will   attempt   to   configure    ' groovyClasspath '    automatically .    Alternatively ,    you   may   configure    ' groovyClasspath '    explicitly .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkGroovyClasspathIsNonEmpty"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "DefaultGroovyJavaJointCompileSpec   spec    =    new   DefaultGroovyJavaJointCompileSpecFactory ( compileOptions )  . create (  )  ;", "spec . setSource ( getSource (  )  )  ;", "spec . setDestinationDir ( getDestinationDir (  )  )  ;", "spec . setWorkingDir ( getProject (  )  . getProjectDir (  )  )  ;", "spec . setTempDir ( getTemporaryDir (  )  )  ;", "spec . setCompileClasspath ( ImmutableList . copyOf ( getClasspath (  )  )  )  ;", "spec . setSourceCompatibility ( getSourceCompatibility (  )  )  ;", "spec . setTargetCompatibility ( getTargetCompatibility (  )  )  ;", "spec . setAnnotationProcessorPath ( calculateAnnotationProcessorClasspath (  )  )  ;", "spec . setGroovyClasspath ( Lists . newArrayList ( getGroovyClasspath (  )  )  )  ;", "spec . setCompileOptions ( compileOptions )  ;", "spec . setOptions ( groovyCompileOptions )  ;", "if    (  ( spec . getOptions (  )  . getStubDir (  )  )     =  =    null )     {", "File   dir    =    new   File ( getTemporaryDir (  )  ,     \" groovy - java - stubs \"  )  ;", "GFileUtils . mkdirs ( dir )  ;", "spec . getOptions (  )  . setStubDir ( dir )  ;", "}", "return   spec ;", "}", "METHOD_END"], "methodName": ["createSpec"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   getCompiler ( createSpec (  )  )  ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "if    (  ( compiler )     =  =    null )     {", "ProjectInternal   projectInternal    =     (  ( ProjectInternal )     ( getProject (  )  )  )  ;", "WorkerDaemonFactory   workerDaemonFactory    =    getServices (  )  . get ( WorkerDaemonFactory . class )  ;", "IsolatedClassloaderWorkerFactory   inProcessWorkerFactory    =    getServices (  )  . get ( IsolatedClassloaderWorkerFactory . class )  ;", "FileResolver   fileResolver    =    getServices (  )  . get ( FileResolver . class )  ;", "GroovyCompilerFactory   groovyCompilerFactory    =    new   GroovyCompilerFactory ( projectInternal ,    workerDaemonFactory ,    inProcessWorkerFactory ,    fileResolver )  ;", "Compiler < GroovyJavaJointCompileSpec >    delegatingCompiler    =    groovyCompilerFactory . newCompiler ( spec )  ;", "compiler    =    new   internal . tasks . compile . CleaningGroovyCompiler ( delegatingCompiler ,    getOutputs (  )  )  ;", "}", "return   compiler ;", "}", "METHOD_END"], "methodName": ["getCompiler"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   groovyClasspath ;", "}", "METHOD_END"], "methodName": ["getGroovyClasspath"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   JavaVersion . current (  )  . getMajorVersion (  )  ;", "}", "METHOD_END"], "methodName": ["getGroovyCompilerJvmVersion"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   groovyCompileOptions ;", "}", "METHOD_END"], "methodName": ["getGroovyOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   getJavaToolChainFactory (  )  . forCompileOptions ( getOptions (  )  )  ;", "}", "METHOD_END"], "methodName": ["getJavaToolChain"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["getJavaToolChainFactory"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "return   compileOptions ;", "}", "METHOD_END"], "methodName": ["getOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "this . compiler    =    compiler ;", "}", "METHOD_END"], "methodName": ["setCompiler"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "this . groovyClasspath    =    groovyClasspath ;", "}", "METHOD_END"], "methodName": ["setGroovyClasspath"], "fileName": "org.gradle.api.tasks.compile.GroovyCompile"}, {"methodBody": ["METHOD_START", "{", "fork    =    true ;", "fork . define ( forkArgs )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["fork"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   configurationScript ;", "}", "METHOD_END"], "methodName": ["getConfigurationScript"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   encoding ;", "}", "METHOD_END"], "methodName": ["getEncoding"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   fileExtensions ;", "}", "METHOD_END"], "methodName": ["getFileExtensions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   forkOptions ;", "}", "METHOD_END"], "methodName": ["getForkOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   optimizationOptions ;", "}", "METHOD_END"], "methodName": ["getOptimizationOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   stubDir ;", "}", "METHOD_END"], "methodName": ["getStubDir"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   failOnError ;", "}", "METHOD_END"], "methodName": ["isFailOnError"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   fork ;", "}", "METHOD_END"], "methodName": ["isFork"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   javaAnnotationProcessing ;", "}", "METHOD_END"], "methodName": ["isJavaAnnotationProcessing"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   keepStubs ;", "}", "METHOD_END"], "methodName": ["isKeepStubs"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   listFiles ;", "}", "METHOD_END"], "methodName": ["isListFiles"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "return   verbose ;", "}", "METHOD_END"], "methodName": ["isVerbose"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . configurationScript    =    configurationFile ;", "}", "METHOD_END"], "methodName": ["setConfigurationScript"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . encoding    =    encoding ;", "}", "METHOD_END"], "methodName": ["setEncoding"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . failOnError    =    failOnError ;", "}", "METHOD_END"], "methodName": ["setFailOnError"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . fileExtensions    =    fileExtensions ;", "}", "METHOD_END"], "methodName": ["setFileExtensions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . fork    =    fork ;", "}", "METHOD_END"], "methodName": ["setFork"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . forkOptions    =    forkOptions ;", "}", "METHOD_END"], "methodName": ["setForkOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . javaAnnotationProcessing    =    javaAnnotationProcessing ;", "}", "METHOD_END"], "methodName": ["setJavaAnnotationProcessing"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . keepStubs    =    keepStubs ;", "}", "METHOD_END"], "methodName": ["setKeepStubs"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . listFiles    =    listFiles ;", "}", "METHOD_END"], "methodName": ["setListFiles"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . optimizationOptions    =    optimizationOptions ;", "}", "METHOD_END"], "methodName": ["setOptimizationOptions"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . stubDir    =    stubDir ;", "}", "METHOD_END"], "methodName": ["setStubDir"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "this . verbose    =    verbose ;", "}", "METHOD_END"], "methodName": ["setVerbose"], "fileName": "org.gradle.api.tasks.compile.GroovyCompileOptions"}, {"methodBody": ["METHOD_START", "{", "if    ( classpath . isEmpty (  )  )     {", "throw   new   InvalidUserDataException (  \" You   must   assign   a      library   to   the   groovy   configuration !  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkGroovyClasspathNonEmpty"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "checkGroovyClasspathNonEmpty ( getGroovyClasspath (  )  . getFiles (  )  )  ;", "getAnt (  )  . execute ( getSource (  )  ,    getDestinationDir (  )  ,    isUse (  )  ,    isNoTimestamp (  )  ,    isNoVersionStamp (  )  ,    getWindowTitle (  )  ,    getDocTitle (  )  ,    getHeader (  )  ,    getFooter (  )  ,    getPathToOverview (  )  ,    isIncludePrivate (  )  ,    getLinks (  )  ,    getGroovyClasspath (  )  ,    getClasspath (  )  ,    getProject (  )  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "if    (  ( antGroovydoc )     =  =    null )     {", "IsolatedAntBuilder   antBuilder    =    getServices (  )  . get ( IsolatedAntBuilder . class )  ;", "ClassPathRegistry   classPathRegistry    =    getServices (  )  . get ( ClassPathRegistry . class )  ;", "antGroovydoc    =    new   AntGroovydoc ( antBuilder ,    classPathRegistry )  ;", "}", "return   antGroovydoc ;", "}", "METHOD_END"], "methodName": ["getAntGroovydoc"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   classpath ;", "}", "METHOD_END"], "methodName": ["getClasspath"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   destinationDir ;", "}", "METHOD_END"], "methodName": ["getDestinationDir"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   docTitle ;", "}", "METHOD_END"], "methodName": ["getDocTitle"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   footer ;", "}", "METHOD_END"], "methodName": ["getFooter"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   groovyClasspath ;", "}", "METHOD_END"], "methodName": ["getGroovyClasspath"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   header ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableSet ( links )  ;", "}", "METHOD_END"], "methodName": ["getLinks"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   overview ;", "}", "METHOD_END"], "methodName": ["getOverviewText"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "TextResource   overview    =    getOverviewText (  )  ;", "if    ( overview    !  =    null )     {", "return   overview . asFile (  )  . getAbsolutePath (  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPathToOverview"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   windowTitle ;", "}", "METHOD_END"], "methodName": ["getWindowTitle"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   includePrivate ;", "}", "METHOD_END"], "methodName": ["isIncludePrivate"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   noTimestamp ;", "}", "METHOD_END"], "methodName": ["isNoTimestamp"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   noVersionStamp ;", "}", "METHOD_END"], "methodName": ["isNoVersionStamp"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "return   use ;", "}", "METHOD_END"], "methodName": ["isUse"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "links . add ( new   Groovydoc . Link ( url ,    packages )  )  ;", "}", "METHOD_END"], "methodName": ["link"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . antGroovydoc    =    antGroovydoc ;", "}", "METHOD_END"], "methodName": ["setAntGroovydoc"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . classpath    =    classpath ;", "}", "METHOD_END"], "methodName": ["setClasspath"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . destinationDir    =    destinationDir ;", "}", "METHOD_END"], "methodName": ["setDestinationDir"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . docTitle    =    docTitle ;", "}", "METHOD_END"], "methodName": ["setDocTitle"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . footer    =    footer ;", "}", "METHOD_END"], "methodName": ["setFooter"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . groovyClasspath    =    groovyClasspath ;", "}", "METHOD_END"], "methodName": ["setGroovyClasspath"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . header    =    header ;", "}", "METHOD_END"], "methodName": ["setHeader"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . includePrivate    =    includePrivate ;", "}", "METHOD_END"], "methodName": ["setIncludePrivate"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . links    =    links ;", "}", "METHOD_END"], "methodName": ["setLinks"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . noTimestamp    =    noTimestamp ;", "}", "METHOD_END"], "methodName": ["setNoTimestamp"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . noVersionStamp    =    noVersionStamp ;", "}", "METHOD_END"], "methodName": ["setNoVersionStamp"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . overview    =    overviewText ;", "}", "METHOD_END"], "methodName": ["setOverviewText"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . use    =    use ;", "}", "METHOD_END"], "methodName": ["setUse"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}, {"methodBody": ["METHOD_START", "{", "this . windowTitle    =    windowTitle ;", "}", "METHOD_END"], "methodName": ["setWindowTitle"], "fileName": "org.gradle.api.tasks.javadoc.Groovydoc"}]