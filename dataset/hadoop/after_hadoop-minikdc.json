[{"methodBody": ["METHOD_START", "{", "conf    =    MiniKdc . createConf (  )  ;", "}", "METHOD_END"], "methodName": ["createMiniKdcConf"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "workDir    =    new   File ( System . getProperty (  \" test . dir \"  ,     \" target \"  )  )  ;", "}", "METHOD_END"], "methodName": ["createTestDir"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "return   conf ;", "}", "METHOD_END"], "methodName": ["getConf"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "return   kdc ;", "}", "METHOD_END"], "methodName": ["getKdc"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "return   workDir ;", "}", "METHOD_END"], "methodName": ["getWorkDir"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "createTestDir (  )  ;", "createMiniKdcConf (  )  ;", "kdc    =    new   MiniKdc ( conf ,    workDir )  ;", "kdc . start (  )  ;", "}", "METHOD_END"], "methodName": ["startMiniKdc"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "if    (  (     !  =    null )     {", "stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopMiniKdc"], "fileName": "org.apache.hadoop.minikdc.KerberosSecurityTestcase"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Properties )     ( MiniKdc . DEFAULT _ CONFIG . clone (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["createConf"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "String   generatedPassword    =    UUID . randomUUID (  )  . toString (  )  ;", "Keytab   keytab    =    new   Keytab (  )  ;", "List < KeytabEntry >    entries    =    new   ArrayList < KeytabEntry >  (  )  ;", "for    ( String   principal    :    principals )     {", "createPrincipal ( principal ,    generatedPassword )  ;", "principal    =     ( principal    +     \"  @  \"  )     +     ( getRealm (  )  )  ;", "KerberosTime   timestamp    =    new   KerberosTime (  )  ;", "for    ( Map . Entry < EncryptionType ,    EncryptionKey >    entry    :    KerberosKeyFactory . getKerberosKeys ( principal ,    generatedPassword )  . entrySet (  )  )     {", "EncryptionKey   ekey    =    entry . getValue (  )  ;", "byte   keyVersion    =     (  ( byte )     ( ekey . getKeyVersion (  )  )  )  ;", "entries . add ( new   KeytabEntry ( principal ,     1 L ,    timestamp ,    keyVersion ,    ekey )  )  ;", "}", "}", "keytab . setEntries ( entries )  ;", "keytab . write ( keytabFile )  ;", "}", "METHOD_END"], "methodName": ["createPrincipal"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "String   orgName    =    conf . getProperty ( MiniKdc . ORG _ NAME )  ;", "String   orgDomain    =    conf . getProperty ( MiniKdc . ORG _ DOMAIN )  ;", "String   baseDn    =     (  (  \" ou = users , dc =  \"     +     ( toLowerCase (  )  )  )     +     \"  , dc =  \"  )     +     ( toLowerCase (  )  )  ;", "String   content    =     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" dn :    uid =  \"     +    principal )     +     \"  ,  \"  )     +    baseDn )     +     \"  \\ n \"  )     +     \" objectClass :    top \\ n \"  )     +     \" objectClass :    person \\ n \"  )     +     \" objectClass :    inetOrgPerson \\ n \"  )     +     \" objectClass :    krb 5 principal \\ n \"  )     +     \" objectClass :    krb 5 kdcentry \\ n \"  )     +     \" cn :     \"  )     +    principal )     +     \"  \\ n \"  )     +     \" sn :     \"  )     +    principal )     +     \"  \\ n \"  )     +     \" uid :     \"  )     +    principal )     +     \"  \\ n \"  )     +     \" userPassword :     \"  )     +    password )     +     \"  \\ n \"  )     +     \" krb 5 PrincipalName :     \"  )     +    principal )     +     \"  @  \"  )     +     ( getRealm (  )  )  )     +     \"  \\ n \"  )     +     \" krb 5 KeyVersionNumber :     0  \"  ;", "for    ( LdifEntry   ldifEntry    :    new   LdifReader ( new   StringReader ( content )  )  )     {", "ds . getAdminSession (  )  . add ( new   directory . api . ldap . model . entry . DefaultEntry ( ds . getSchemaManager (  )  ,    ldifEntry . getEntry (  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createPrincipal"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "if    ( f . isFile (  )  )     {", "if    (  !  ( f . delete (  )  )  )     {", ". LOG . warn (  (  \" WARNING :    cannot   delete   file    \"     +     ( f . getAbsolutePath (  )  )  )  )  ;", "}", "} else    {", "for    ( File   c    :    f . listFiles (  )  )     {", "delete ( c )  ;", "}", "if    (  !  ( f . delete (  )  )  )     {", ". LOG . warn (  (  \" WARNING :    cannot   delete   directory    \"     +     ( f . getAbsolutePath (  )  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "return   conf . getProperty ( MiniKdc . KDC _ BIND _ ADDRESS )  ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "return   krb 5 conf ;", "}", "METHOD_END"], "methodName": ["getKrb5conf"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "return   port ;", "}", "METHOD_END"], "methodName": ["getPort"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "return   realm ;", "}", "METHOD_END"], "methodName": ["getRealm"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "ds    =    new   DefaultDirectoryService (  )  ;", "ds . setInstanceLayout ( new   InstanceLayout ( workDir )  )  ;", "CacheService   cacheService    =    new   CacheService (  )  ;", "ds . setCacheService ( cacheService )  ;", "InstanceLayout   instanceLayout    =    ds . getInstanceLayout (  )  ;", "File   schemaPartitionDirectory    =    new   File ( instanceLayout . getPartitionsDirectory (  )  ,     \" schema \"  )  ;", "SchemaLdifExtractor   extractor    =    new   directory . api . ldap . schemaextractor . impl . DefaultSchemaLdifExtractor ( instanceLayout . getPartitionsDirectory (  )  )  ;", "extractor . extractOrCopy (  )  ;", "SchemaLoader   loader    =    new   LdifSchemaLoader ( schemaPartitionDirectory )  ;", "SchemaManager   schemaManager    =    new   directory . api . ldap . schemamanager . impl . DefaultSchemaManager ( loader )  ;", "schemaManager . loadAllEnabled (  )  ;", "ds . setSchemaManager ( schemaManager )  ;", "LdifPartition   schemaLdifPartition    =    new   LdifPartition ( schemaManager )  ;", "schemaLdifPartition . setPartitionPath ( schemaPartitionDirectory . toURI (  )  )  ;", "SchemaPartition   schemaPartition    =    new   SchemaPartition ( schemaManager )  ;", "schemaPartition . setWrappedPartition ( schemaLdifPartition )  ;", "ds . setSchemaPartition ( schemaPartition )  ;", "JdbmPartition   systemPartition    =    new   JdbmPartition ( ds . getSchemaManager (  )  )  ;", "systemPartition . setId (  \" system \"  )  ;", "systemPartition . setPartitionPath ( new   File ( ds . getInstanceLayout (  )  . getPartitionsDirectory (  )  ,    systemPartition . getId (  )  )  . toURI (  )  )  ;", "systemPartition . setSuffixDn ( new   Dn ( ServerDNConstants . SYSTEM _ DN )  )  ;", "systemPartition . setSchemaManager ( ds . getSchemaManager (  )  )  ;", "ds . setSystemPartition ( systemPartition )  ;", "ds . getChangeLog (  )  . setEnabled ( false )  ;", "ds . setDenormalizeOpAttrsEnabled ( true )  ;", "ds . addLast ( new   KeyDerivationInterceptor (  )  )  ;", "String   orgName    =    conf . getProperty ( MiniKdc . ORG _ NAME )  . toLowerCase (  )  ;", "String   orgDomain    =    conf . getProperty ( MiniKdc . ORG _ DOMAIN )  . toLowerCase (  )  ;", "JdbmPartition   partition    =    new   JdbmPartition ( ds . getSchemaManager (  )  )  ;", "partition . setId ( orgName )  ;", "partition . setPartitionPath ( new   File ( ds . getInstanceLayout (  )  . getPartitionsDirectory (  )  ,    orgName )  . toURI (  )  )  ;", "partition . setSuffixDn ( new   Dn (  (  (  (  \" dc =  \"     +    orgName )     +     \"  , dc =  \"  )     +    orgDomain )  )  )  ;", "ds . addPartition ( partition )  ;", "Set < Index <  ?  ,     ?  ,    String >  >    indexedAttributes    =    new   HashSet < Index <  ?  ,     ?  ,    String >  >  (  )  ;", "indexedAttributes . add ( new   directory . server . core . partition . impl . btree . jdbm . JdbmIndex < String ,    Entry >  (  \" objectClass \"  ,    false )  )  ;", "indexedAttributes . add ( new   directory . server . core . partition . impl . btree . jdbm . JdbmIndex < String ,    Entry >  (  \" dc \"  ,    false )  )  ;", "indexedAttributes . add ( new   directory . server . core . partition . impl . btree . jdbm . JdbmIndex < String ,    Entry >  (  \" ou \"  ,    false )  )  ;", "partition . setIndexedAttributes ( indexedAttributes )  ;", "ds . setInstanceId ( conf . getProperty ( MiniKdc . INSTANCE )  )  ;", "ds . startup (  )  ;", "Dn   dn    =    new   Dn (  (  (  (  \" dc =  \"     +    orgName )     +     \"  , dc =  \"  )     +    orgDomain )  )  ;", "Entry   entry    =    ds . newEntry ( dn )  ;", "entry . add (  \" objectClass \"  ,     \" top \"  ,     \" domain \"  )  ;", "entry . add (  \" dc \"  ,    orgName )  ;", "ds . getAdminSession (  )  . add ( entry )  ;", "}", "METHOD_END"], "methodName": ["initDirectoryService"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "String   orgName    =    conf . getProperty ( MiniKdc . ORG _ NAME )  ;", "String   orgDomain    =    conf . getProperty ( MiniKdc . ORG _ DOMAIN )  ;", "String   bindAddress    =    conf . getProperty ( MiniKdc . KDC _ BIND _ ADDRESS )  ;", "final   Map < String ,    String >    map    =    new   HashMap < String ,    String >  (  )  ;", "map . put (  \"  0  \"  ,    toLowerCase (  )  )  ;", "map . put (  \"  1  \"  ,    toLowerCase (  )  )  ;", "map . put (  \"  2  \"  ,    toUpperCase (  )  )  ;", "map . put (  \"  3  \"  ,    toUpperCase (  )  )  ;", "map . put (  \"  4  \"  ,    bindAddress )  ;", "ClassLoader   cl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "InputStream   is 1     =    cl . getResourceAsStream (  \" minikdc . ldiff \"  )  ;", "SchemaManager   schemaManager    =    ds . getSchemaManager (  )  ;", "LdifReader   reader    =    null ;", "try    {", "final   String   content    =    StrSubstitutor . replace ( IOUtils . toString ( is 1  )  ,    map )  ;", "reader    =    new   LdifReader ( new   StringReader ( content )  )  ;", "for    ( LdifEntry   ldifEntry    :    reader )     {", "ds . getAdminSession (  )  . add ( new   directory . api . ldap . model . entry . DefaultEntry ( schemaManager ,    ldifEntry . getEntry (  )  )  )  ;", "}", "}    finally    {", "IOUtils . closeQuietly ( reader )  ;", "IOUtils . closeQuietly ( is 1  )  ;", "}", "kdc    =    new   KdcServer (  )  ;", "kdc . setDirectoryService ( ds )  ;", "String   transport    =    conf . getProperty ( MiniKdc . TRANSPORT )  ;", "if    ( transport . trim (  )  . equals (  \" TCP \"  )  )     {", "kdc . addTransports ( new   TcpTransport ( bindAddress ,    port ,     3  ,     5  0  )  )  ;", "} else", "if    ( transport . trim (  )  . equals (  \" UDP \"  )  )     {", "kdc . addTransports ( new   directory . server . protocol . shared . transport . UdpTransport ( port )  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  \" Invalid   transport :     \"     +    transport )  )  ;", "}", "kdc . setServiceName ( conf . getProperty ( MiniKdc . INSTANCE )  )  ;", "kdc . getConfig (  )  . setMaximumRenewableLifetime ( Long . parseLong ( conf . getProperty ( MiniKdc . MAX _ RENEWABLE _ LIFETIME )  )  )  ;", "kdc . getConfig (  )  . setMaximumTicketLifetime ( Long . parseLong ( conf . getProperty ( MiniKdc . MAX _ TICKET _ LIFETIME )  )  )  ;", "kdc . getConfig (  )  . setPaEncTimestampRequired ( false )  ;", "kdc . start (  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "InputStream   is 2     =    cl . getResourceAsStream (  \" minikdc - krb 5  . conf \"  )  ;", "BufferedReader   r    =    null ;", "try    {", "r    =    new   BufferedReader ( new   InputStreamReader ( is 2  ,    Charsets . UTF _  8  )  )  ;", "String   line    =    r . readLine (  )  ;", "while    ( line    !  =    null )     {", "sb . append ( line )  . append (  \"  {  3  }  \"  )  ;", "line    =    r . readLine (  )  ;", "}", "}    finally    {", "IOUtils . closeQuietly ( r )  ;", "IOUtils . closeQuietly ( is 2  )  ;", "}", "krb 5 conf    =    new   File ( workDir ,     \" krb 5  . conf \"  )  . getAbsoluteFile (  )  ;", "FileUtils . writeStringToFile ( krb 5 conf ,    MessageFormat . format ( sb . toString (  )  ,    getRealm (  )  ,    getHost (  )  ,    Integer . toString ( getPort (  )  )  ,    System . getProperty (  \" line . separator \"  )  )  )  ;", "System . setProperty (  \" conf \"  ,    krb 5 conf . getAbsolutePath (  )  )  ;", "System . setProperty (  \" sun . security . krb 5  . debug \"  ,    conf . getProperty ( MiniKdc . DEBUG ,     \" false \"  )  )  ;", "Class <  ?  >    classRef ;", "if    ( System . getProperty (  \" vendor \"  )  . contains (  \" IBM \"  )  )     {", "classRef    =    Class . forName (  \" com . ibm . security . krb 5  . internal . Config \"  )  ;", "} else    {", "classRef    =    Class . forName (  \" sun . security . krb 5  . Config \"  )  ;", "}", "Method   refreshMethod    =    classRef . getMethod (  \" refresh \"  ,    new   Class [  0  ]  )  ;", "refreshMethod . invoke ( classRef ,    new   Object [  0  ]  )  ;", "MiniKdc . LOG . info (  \" MiniKdc   listening   at   port :     {  }  \"  ,    getPort (  )  )  ;", "MiniKdc . LOG . info (  \" MiniKdc   setting   JVM   krb 5  . conf   to :     {  }  \"  ,    krb 5 conf . getAbsolutePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["initKDCServer"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     <     4  )     {", "System . out . println (  (  \" Arguments :     < WORKDIR >     < MINIKDCPROPERTIES >     \"     +     \"  < KEYTABFILE >     [  < PRINCIPALS >  ]  +  \"  )  )  ;", "System . exit (  1  )  ;", "}", "File   workDir    =    new   File ( args [  0  ]  )  ;", "if    (  !  ( workDir . exists (  )  )  )     {", "throw   new   RuntimeException (  (  \" Specified   work   directory   does   not   exists :     \"     +     ( workDir . getAbsolutePath (  )  )  )  )  ;", "}", "Properties   conf    =     . createConf (  )  ;", "File   file    =    new   File ( args [  1  ]  )  ;", "if    (  !  ( file . exists (  )  )  )     {", "throw   new   RuntimeException (  (  \" Specified   configuration   does   not   exists :     \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "}", "Properties   userConf    =    new   Properties (  )  ;", "InputStreamReader   r    =    null ;", "try    {", "r    =    new   InputStreamReader ( new   FileInputStream ( file )  ,    Charsets . UTF _  8  )  ;", "userConf . load ( r )  ;", "}    finally    {", "if    ( r    !  =    null )     {", "r . close (  )  ;", "}", "}", "for    ( Map . Entry <  ?  ,     ?  >    entry    :    userConf . entrySet (  )  )     {", "conf . put ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "final      miniKdc    =    new    ( conf ,    workDir )  ;", "miniKdc . start (  )  ;", "File   krb 5 conf    =    new   File ( workDir ,     \" krb 5  . conf \"  )  ;", "if    ( miniKdc . getKrb 5 conf (  )  . renameTo ( krb 5 conf )  )     {", "File   keytabFile    =    new   File ( args [  2  ]  )  . getAbsoluteFile (  )  ;", "String [  ]    principals    =    new   String [  ( args . length )     -     3  ]  ;", "System . arraycopy ( args ,     3  ,    principals ,     0  ,     (  ( args . length )     -     3  )  )  ;", "miniKdc . createPrincipal ( keytabFile ,    principals )  ;", "System . out . println (  )  ;", "System . out . println (  \" Standalone      Running \"  )  ;", "System . out . println (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \"  )  ;", "System . out . println (  (  \"       Realm                                  :     \"     +     ( miniKdc . getRealm (  )  )  )  )  ;", "System . out . println (  (  (  (  \"       Running   at                   :     \"     +     ( miniKdc . getHost (  )  )  )     +     \"  :  \"  )     +     ( miniKdc . getHost (  )  )  )  )  ;", "System . out . println (  (  \"       krb 5 conf                         :     \"     +    krb 5 conf )  )  ;", "System . out . println (  )  ;", "System . out . println (  (  \"       created   keytab       :     \"     +    keytabFile )  )  ;", "System . out . println (  (  \"       with   principals    :     \"     +     ( Arrays . asList ( principals )  )  )  )  ;", "System . out . println (  )  ;", "System . out . println (  \"    Do    < CTRL - C >    or   kill    < PID >    to   stop   it \"  )  ;", "System . out . println (  \"  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  \"  )  ;", "System . out . println (  )  ;", "Runtime . getRuntime (  )  . addShutdownHook ( new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "miniKdc . stop (  )  ;", "}", "}  )  ;", "} else    {", "throw   new   RuntimeException (  (  \" Cannot   rename   KDC ' s   krb 5 conf   to    \"     +     ( krb 5 conf . getAbsolutePath (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "if    (  ( kdc )     !  =    null )     {", "throw   new   RuntimeException (  \" Already   started \"  )  ;", "}", "initDirectoryService (  )  ;", "initKDCServer (  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "if    (  ( kdc )     !  =    null )     {", "System . getProperties (  )  . remove (  \" conf \"  )  ;", "System . getProperties (  )  . remove (  \" sun . security . krb 5  . debug \"  )  ;", "kdc . stop (  )  ;", "try    {", "ds . shutdown (  )  ;", "}    catch    ( Exception   ex )     {", ". LOG . error (  \" Could   not   shutdown   ApacheDS   properly :     {  }  \"  ,    ex . toString (  )  ,    ex )  ;", "}", "}", "delete ( workDir )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.apache.hadoop.minikdc.MiniKdc"}, {"methodBody": ["METHOD_START", "{", "MiniKdc   kdc    =    getKdc (  )  ;", "File   workDir    =    getWorkDir (  )  ;", "LoginContext   loginContext    =    null ;", "try    {", "String   principal    =     \" foo \"  ;", "File   keytab    =    new   File ( workDir ,     \" foo . keytab \"  )  ;", "kdc . createPrincipal ( keytab ,    principal )  ;", "Set < Principal >    principals    =    new   HashSet < Principal >  (  )  ;", "principals . add ( new   KerberosPrincipal ( principal )  )  ;", "Subject   subject    =    new   Subject ( false ,    principals ,    new   HashSet < Object >  (  )  ,    new   HashSet < Object >  (  )  )  ;", "loginContext    =    new   LoginContext (  \"  \"  ,    subject ,    null ,     . KerberosConfiguration . createClientConfig ( principal ,    keytab )  )  ;", "loginContext . login (  )  ;", "subject    =    loginContext . getSubject (  )  ;", "Assert . assertEquals (  1  ,    subject . getPrincipals (  )  . size (  )  )  ;", "Assert . assertEquals ( KerberosPrincipal . class ,    subject . getPrincipals (  )  . iterator (  )  . next (  )  . getClass (  )  )  ;", "Assert . assertEquals (  (  ( principal    +     \"  @  \"  )     +     ( kdc . getRealm (  )  )  )  ,    subject . getPrincipals (  )  . iterator (  )  . next (  )  . getName (  )  )  ;", "loginContext . logout (  )  ;", "subject    =    new   Subject ( false ,    principals ,    new   HashSet < Object >  (  )  ,    new   HashSet < Object >  (  )  )  ;", "loginContext    =    new   LoginContext (  \"  \"  ,    subject ,    null ,     . KerberosConfiguration . createServerConfig ( principal ,    keytab )  )  ;", "loginContext . login (  )  ;", "subject    =    loginContext . getSubject (  )  ;", "Assert . assertEquals (  1  ,    subject . getPrincipals (  )  . size (  )  )  ;", "Assert . assertEquals ( KerberosPrincipal . class ,    subject . getPrincipals (  )  . iterator (  )  . next (  )  . getClass (  )  )  ;", "Assert . assertEquals (  (  ( principal    +     \"  @  \"  )     +     ( kdc . getRealm (  )  )  )  ,    subject . getPrincipals (  )  . iterator (  )  . next (  )  . getName (  )  )  ;", "loginContext . logout (  )  ;", "}    finally    {", "if    ( loginContext    !  =    null )     {", "loginContext . logout (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testKerberosLogin"], "fileName": "org.apache.hadoop.minikdc.TestMiniKdc"}, {"methodBody": ["METHOD_START", "{", "MiniKdc   kdc    =    getKdc (  )  ;", "File   workDir    =    getWorkDir (  )  ;", "kdc . createPrincipal ( new   File ( workDir ,     \" keytab \"  )  ,     \" foo / bar \"  ,     \" bar / foo \"  )  ;", "Keytab   kt    =    Keytab . read ( new   File ( workDir ,     \" keytab \"  )  )  ;", "Set < String >    principals    =    new   HashSet < String >  (  )  ;", "for    ( KeytabEntry   entry    :    kt . getEntries (  )  )     {", "principals . add ( entry . getPrincipalName (  )  )  ;", "}", "Assert . assertEquals ( new   HashSet < String >  ( Arrays . asList (  (  \" foo \\  \\ bar @  \"     +     ( kdc . getRealm (  )  )  )  ,     (  \" bar \\  \\ foo @  \"     +     ( kdc . getRealm (  )  )  )  )  )  ,    principals )  ;", "}", "METHOD_END"], "methodName": ["testKeytabGen"], "fileName": "org.apache.hadoop.minikdc.TestMiniKdc"}, {"methodBody": ["METHOD_START", "{", "MiniKdc   kdc    =    getKdc (  )  ;", "Assert . assertNotSame (  0  ,    kdc . getPort (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMiniKdcStart"], "fileName": "org.apache.hadoop.minikdc.TestMiniKdc"}]