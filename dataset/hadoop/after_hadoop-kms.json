[{"methodBody": ["METHOD_START", "{", "assertAccess ( aclType ,    ugi ,    operation ,    null )  ;", "}", "METHOD_END"], "methodName": ["assertAccess"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( KMSWebApp . getACLs (  )  . hasAccess ( aclType ,    ugi )  )  )     {", "KMSWebApp . getUnauthorizedCallsMeter (  )  . mark (  )  ;", "kmsAudit . unauthorized ( ugi ,    operation ,    key )  ;", "throw   new   security . authorize . AuthorizationException ( String . format (  ( key    !  =    null    ?    KMS . UNAUTHORIZED _ MSG _ WITH _ KEY    :    KMS . UNAUTHORIZED _ MSG _ WITHOUT _ KEY )  ,    ugi . getShortUserName (  )  ,    operation ,    key )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertAccess"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "KMSWebApp . getAdminCallsMeter (  )  . mark (  )  ;", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "final   String   name    =     (  ( String )     ( jsonKey . get ( NAME _ FIELD )  )  )  ;", "KMSClientProvider . checkNotEmpty ( name ,    NAME _ FIELD )  ;", "assertAccess ( KMSACLs . Type . CREATE ,    user ,    KMS . KMSOp . CREATE _ KEY ,    name )  ;", "String   cipher    =     (  ( String )     ( jsonKey . get ( CIPHER _ FIELD )  )  )  ;", "final   String   material    =     (  ( String )     ( jsonKey . get ( MATERIAL _ FIELD )  )  )  ;", "int   length    =     ( jsonKey . containsKey ( LENGTH _ FIELD )  )     ?     (  ( Integer )     ( jsonKey . get ( LENGTH _ FIELD )  )  )     :     0  ;", "String   description    =     (  ( String )     ( jsonKey . get ( DESCRIPTION _ FIELD )  )  )  ;", "Map < String ,    String >    attributes    =     (  ( Map < String ,    String >  )     ( jsonKey . get ( ATTRIBUTES _ FIELD )  )  )  ;", "if    ( material    !  =    null )     {", "assertAccess ( KMSACLs . Type . SET _ KEY _ MATERIAL ,    user ,    KMS . KMSOp . CREATE _ KEY ,    name )  ;", "}", "final   KeyProvider . Options   options    =    new   KeyProvider . Options ( KMSWebApp . getConfiguration (  )  )  ;", "if    ( cipher    !  =    null )     {", "options . setCipher ( cipher )  ;", "}", "if    ( length    !  =     0  )     {", "options . setBitLength ( length )  ;", "}", "options . setDescription ( description )  ;", "options . setAttributes ( attributes )  ;", "KeyProvider . KeyVersion   keyVersion    =    user . doAs ( new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "KeyProvider . KeyVersion   keyVersion    =     ( material    !  =    null )     ?    provider . createKey ( name ,    Base 6  4  . decodeBase 6  4  ( material )  ,    options )     :    provider . createKey ( name ,    options )  ;", "provider . flush (  )  ;", "return   keyVersion ;", "}", "}  )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . CREATE _ KEY ,    name ,     (  (  (  \" UserProvidedMaterial :  \"     +     ( material    !  =    null )  )     +     \"    Description :  \"  )     +    description )  )  ;", "if    (  !  ( KMSWebApp . getACLs (  )  . hasAccess ( KMSACLs . Type . GET ,    user )  )  )     {", "keyVersion    =    KMS . removeKeyMaterial ( keyVersion )  ;", "}", "Map   json    =    KMSSJSONUtils . toJSON ( keyVersion )  ;", "String   requestURL    =    KMSMDCFilter . getURL (  )  ;", "int   idx    =    requestURL . lastIndexOf ( KEYS _ RESOURCE )  ;", "requestURL    =    requestURL . substring (  0  ,    idx )  ;", "String   keyURL    =     (  ( requestURL    +     ( KMSRESTConstants . KEY _ RESOURCE )  )     +     \"  /  \"  )     +    name ;", "return   Response . created ( KMS . getKeyURI ( name )  )  . type ( APPLICATION _ JSON )  . header (  \" Location \"  ,    keyURL )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( versionName ,     \" versionName \"  )  ;", "KMSClientProvider . checkNotNull ( eekOp ,     \" eekOp \"  )  ;", "final   String   keyName    =     (  ( String )     ( jsonPayload . get ( NAME _ FIELD )  )  )  ;", "String   ivStr    =     (  ( String )     ( jsonPayload . get ( IV _ FIELD )  )  )  ;", "String   encMaterialStr    =     (  ( String )     ( jsonPayload . get ( MATERIAL _ FIELD )  )  )  ;", "Object   retJSON ;", "if    ( eekOp . equals ( EEK _ DECRYPT )  )     {", "assertAccess ( KMSACLs . Type . DECRYPT _ EEK ,    user ,    KMS . KMSOp . DECRYPT _ EEK ,    keyName )  ;", "KMSClientProvider . checkNotNull ( ivStr ,    IV _ FIELD )  ;", "final   byte [  ]    iv    =    Base 6  4  . decodeBase 6  4  ( ivStr )  ;", "KMSClientProvider . checkNotNull ( encMaterialStr ,    MATERIAL _ FIELD )  ;", "final   byte [  ]    encMaterial    =    Base 6  4  . decodeBase 6  4  ( encMaterialStr )  ;", "KeyProvider . KeyVersion   retKeyVersion    =    user . doAs ( new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "return   provider . decryptEncryptedKey ( new   KMSClientProvidEncryptedKeyVersion ( keyName ,    versionName ,    iv ,    KeyProviderCryptoExtension . EEK ,    encMaterial )  )  ;", "}", "}  )  ;", "retJSON    =    KMSServerJSONUtils . toJSON ( retKeyVersion )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . DECRYPT _ EEK ,    keyName ,     \"  \"  )  ;", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Wrong    \"     +     ( KMSRESTConstants . EEK _ OP )  )     +     \"    value ,    it   must   be    \"  )     +     ( KMSRESTConstants . EEK _ GENERATE )  )     +     \"    or    \"  )     +     ( KMSRESTConstants . EEK _ DECRYPT )  )  )  ;", "}", "KMSWebApp . getDecryptEEKCallsMeter (  )  . mark (  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( retJSON )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["decryptEncryptedKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "WebApp . getAdminCallsMeter (  )  . mark (  )  ;", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "assertAccessACLs . Type . DELETE ,    user , Op . DELETE _ KEY ,    name )  ;", "ClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "user . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "provider . deleteKey ( name )  ;", "provider . flush (  )  ;", "return   null ;", "}", "}  )  ;", "kmsAudit . ok ( user , Op . DELETE _ KEY ,    name ,     \"  \"  )  ;", "return   Response . ok (  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["deleteKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "KMSClientProvider . checkNotNull ( edekOp ,     \" eekOp \"  )  ;", "Object   retJSON ;", "if    ( edekOp . equals ( EEK _ GENERATE )  )     {", "assertAccess ( KMSACLs . Type . GENERATE _ EEK ,    user ,    KMS . KMSOp . GENERATE _ EEK ,    name )  ;", "final   List < EnedKeyVersion >    retEdeks    =    new   LinkedList < EnedKeyVersion >  (  )  ;", "try    {", "user . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "for    ( int   i    =     0  ;    i    <    numKeys ;    i +  +  )     {", "retEdeks . add ( provider . generateEnedKey ( name )  )  ;", "}", "return   null ;", "}", "}  )  ;", "}    catch    ( Exception   e )     {", "throw   new   IOException ( e )  ;", "}", "kmsAudit . ok ( user ,    KMS . KMSOp . GENERATE _ EEK ,    name ,     \"  \"  )  ;", "retJSON    =    new   ArrayList (  )  ;", "for    ( EnedKeyVersion   edek    :    retEdeks )     {", "(  ( ArrayList )     ( retJSON )  )  . add ( KMSServerJSONUtils . toJSON ( edek )  )  ;", "}", "} else    {", "throw   new   IllegalArgumentException (  (  (  (  (  (  \" Wrong    \"     +     ( KMSRESTConstants . EEK _ OP )  )     +     \"    value ,    it   must   be    \"  )     +     ( KMSRESTConstants . EEK _ GENERATE )  )     +     \"    or    \"  )     +     ( KMSRESTConstants . EEK _ DECRYPT )  )  )  ;", "}", "KMSWebApp . getGenerateEEKCallsMeter (  )  . mark (  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( retJSON )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["generateEncryptedKeys"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "KMSWebApp . getKeyCallsMeter (  )  . mark (  )  ;", "assertAccess ( KMSACLs . Type . GET ,    user ,    KMS . KMSOp . GET _ CURRENT _ KEY ,    name )  ;", "KeyVersion   keyVersion    =    user . doAs ( new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "return   provider . getCurrentKey ( name )  ;", "}", "}  )  ;", "Object   json    =    KMSSJSONUtils . toJSON ( keyVersion )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . GET _ CURRENT _ KEY ,    name ,     \"  \"  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getCurrentVersion"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "return   getMetadata ( name )  ;", "}", "METHOD_END"], "methodName": ["getKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "WebApp . getAdminCallsMeter (  )  . mark (  )  ;", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "assertAccessACLs . Type . GET _ KEYS ,    user , Op . GET _ KEYS )  ;", "List < String >    json    =    user . doAs ( new   PrivilegedExceptionAction < List < String >  >  (  )     {", "@ Override", "public   List < String >    run (  )    throws   Exception    {", "return   provider . getKeys (  )  ;", "}", "}  )  ;", "kmsAudit . ok ( user , Op . GET _ KEYS ,     \"  \"  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getKeyNames"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "return   new   URI (  (  (  (  (  ( KMSRESTConstants . SERVICE _ VERSION )     +     \"  /  \"  )     +     ( KMSRESTConstants . KEY _ RESOURCE )  )     +     \"  /  \"  )     +    name )  )  ;", "}", "METHOD_END"], "methodName": ["getKeyURI"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( versionName ,     \" versionName \"  )  ;", "KMSWebApp . getKeyCallsMeter (  )  . mark (  )  ;", "assertAccess ( KMSACLs . Type . GET ,    user ,    KMS . KMSOp . GET _ KEY _ VERSION )  ;", "KeyVersion   keyVersion    =    user . doAs ( new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "return   provider . getKeyVersion ( versionName )  ;", "}", "}  )  ;", "if    ( keyVersion    !  =    null )     {", "kmsAudit . ok ( user ,    KMS . KMSOp . GET _ KEY _ VERSION ,    keyVersion . getName (  )  ,     \"  \"  )  ;", "}", "Object   json    =    KMSSJSONUtils . toJSON ( keyVersion )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getKeyVersion"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "KMSWebApp . getKeyCallsMeter (  )  . mark (  )  ;", "assertAccess ( KMSACLs . Type . GET ,    user ,    KMS . KMSOp . GET _ KEY _ VERSIONS ,    name )  ;", "List < KeyVersion >    ret    =    user . doAs ( new   PrivilegedExceptionAction < List < KeyVersion >  >  (  )     {", "@ Override", "public   List < KeyVersion >    run (  )    throws   Exception    {", "return   provider . getKeyVersions ( name )  ;", "}", "}  )  ;", "Object   json    =    KMSSJSONUtils . toJSON ( ret )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . GET _ KEY _ VERSIONS ,    name ,     \"  \"  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getKeyVersions"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "KMSWebApp . getAdminCallsMeter (  )  . mark (  )  ;", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "final   String [  ]    keyNames    =    keyNamesList . toArray ( new   String [ keyNamesList . size (  )  ]  )  ;", "assertAccess ( KMSACLs . Type . GET _ METADATA ,    user ,    KMS . KMSOp . GET _ KEYS _ METADATA )  ;", "KeyProvider [  ]    keysMeta    =    user . doAs ( new   PrivilegedExceptionAction < KeyProvider [  ]  >  (  )     {", "@ Override", "public   Metadata [  ]    run (  )    throws   Exception    {", "return   provider . getKeysMetadata ( keyNames )  ;", "}", "}  )  ;", "Object   json    =    KMSSJSONUtils . toJSON ( keyNames ,    keysMeta )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . GET _ KEYS _ METADATA ,     \"  \"  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getKeysMetadata"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "KMSClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "KMSWebApp . getAdminCallsMeter (  )  . mark (  )  ;", "assertAccess ( KMSACLs . Type . GET _ METADATA ,    user ,    KMS . KMSOp . GET _ METADATA ,    name )  ;", "KeyProvider . Metadata   metadata    =    user . doAs ( new   PrivilegedExceptionAction < KeyProvider . Metadata >  (  )     {", "@ Override", "public   Metadata   run (  )    throws   Exception    {", "return   provider . getMetadata ( name )  ;", "}", "}  )  ;", "Object   json    =    KMSSJSONUtils . toJSON ( name ,    metadata )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . GET _ METADATA ,    name ,     \"  \"  )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["getMetadata"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "return   new   KMSKeyVersion ( keyVersion . getName (  )  ,    keyVersion . getVersionName (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["removeKeyMaterial"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "KMSWebApp . getAdminCallsMeter (  )  . mark (  )  ;", "UserGroupInformation   user    =    HttpUserGroupInformation . get (  )  ;", "assertAccess ( KMSACLs . Type . ROLLOVER ,    user ,    KMS . KMSOp . ROLL _ NEW _ VERSION ,    name )  ;", "KMSClientProvider . checkNotEmpty ( name ,     \" name \"  )  ;", "final   String   material    =     (  ( String )     ( jsonMaterial . get ( MATERIAL _ FIELD )  )  )  ;", "if    ( material    !  =    null )     {", "assertAccess ( KMSACLs . Type . SET _ KEY _ MATERIAL ,    user ,    KMS . KMSOp . ROLL _ NEW _ VERSION ,    name )  ;", "}", "KeyProvider . KeyVersion   keyVersion    =    user . doAs ( new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "KeyVersion   keyVersion    =     ( material    !  =    null )     ?    provider . rollNewVersion ( name ,    Base 6  4  . decodeBase 6  4  ( material )  )     :    provider . rollNewVersion ( name )  ;", "provider . flush (  )  ;", "return   keyVersion ;", "}", "}  )  ;", "kmsAudit . ok ( user ,    KMS . KMSOp . ROLL _ NEW _ VERSION ,    name ,     (  (  (  \" UserProvidedMaterial :  \"     +     ( material    !  =    null )  )     +     \"    NewVersion :  \"  )     +     ( keyVersion . getVersionName (  )  )  )  )  ;", "if    (  !  ( KMSWebApp . getACLs (  )  . hasAccess ( KMSACLs . Type . GET ,    user )  )  )     {", "keyVersion    =    KMS . removeKeyMaterial ( keyVersion )  ;", "}", "Map   json    =    KMSSJSONUtils . toJSON ( keyVersion )  ;", "return   Response . ok (  )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["rolloverKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMS"}, {"methodBody": ["METHOD_START", "{", "return   acls . get ( type )  . isUserAllowed ( ugi )  ;", "}", "METHOD_END"], "methodName": ["hasAccess"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSACLs"}, {"methodBody": ["METHOD_START", "{", "KMSACLs . LOG . debug (  \" Loading   ACLs   file \"  )  ;", "lastReload    =    System . currentTimeMillis (  )  ;", "Configuration   conf    =    KMSConfiguration . getACLsConf (  )  ;", "conf . get ( KMSACLs . Type . CREATE . getConfigKey (  )  )  ;", "return   conf ;", "}", "METHOD_END"], "methodName": ["loadACLs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSACLs"}, {"methodBody": ["METHOD_START", "{", "Map < KMSACLs . Type ,    AccessControlList >    tempAcls    =    new   HashMap < KMSACLs . Type ,    AccessControlList >  (  )  ;", "for    ( KMSACLs . Type   aclType    :    KMSACLs . Type . values (  )  )     {", "String   aclStr    =    conf . get ( aclType . getConfigKey (  )  ,    KMSACLs . ACL _ DEFAULT )  ;", "tempAcls . put ( aclType ,    new   AccessControlList ( aclStr )  )  ;", "KMSACLs . LOG . info (  \"  '  {  }  '    ACL    '  {  }  '  \"  ,    aclType ,    aclStr )  ;", "}", "acls    =    tempAcls ;", "}", "METHOD_END"], "methodName": ["setACLs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSACLs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executorService )     =  =    null )     {", "executorService    =    Executors . newScheduledThreadPool (  1  )  ;", "executorService . scheduleAtFixedRate ( this ,     . RELOADER _ SLEEP _ MILLIS ,     . RELOADER _ SLEEP _ MILLIS ,    TimeUnit . MILLISECONDS )  ;", "}", "}", "METHOD_END"], "methodName": ["startReloader"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSACLs"}, {"methodBody": ["METHOD_START", "{", "if    (  ( executorService )     !  =    null )     {", "executorService . shutdownNow (  )  ;", "executorService    =    null ;", "}", "}", "METHOD_END"], "methodName": ["stopReloader"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSACLs"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( user    +     \"  #  \"  )     +    key )     +     \"  #  \"  )     +    op ;", "}", "METHOD_END"], "methodName": ["createCacheKey"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "op ( KMSAudit . OpStatus . ERROR ,    null ,    user . getShortUserName (  )  ,    null ,     (  (  (  (  \" Method :  '  \"     +    method )     +     \"  '    Exception :  '  \"  )     +    extraMsg )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["error"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "KMSAudit . AUDIT _ LOG . info (  \" OK [ op =  {  }  ,    key =  {  }  ,    user =  {  }  ,    accessCount =  {  }  ,    interval =  {  } ms ]     {  }  \"  ,    event . getOp (  )  ,    event . getKeyName (  )  ,    event . getUser (  )  ,    event . getAccessCount (  )  . get (  )  ,     (  ( System . currentTimeMillis (  )  )     -     ( event . getStartTime (  )  )  )  ,    event . getExtraMsg (  )  )  ;", "}", "METHOD_END"], "methodName": ["logEvent"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "op ( KMSAudit . OpStatus . OK ,    op ,    user . getShortUserName (  )  ,    null ,    extraMsg )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "op ( KMSAudit . OpStatus . OK ,    op ,    user . getShortUserName (  )  ,    key ,    extraMsg )  ;", "}", "METHOD_END"], "methodName": ["ok"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  (  !  ( Strings . isNullOrEmpty ( user )  )  )     &  &     (  !  ( Strings . isNullOrEmpty ( key )  )  )  )     &  &     ( op    !  =    null )  )     &  &     ( KMSAudit . AGGREGATE _ OPS _ WHITELIST . contains ( op )  )  )     {", "String   cacheKey    =    KMSAudit . createCacheKey ( user ,    key ,    op )  ;", "if    ( opStatus    =  =     ( KMSAudit . OpStatus . UNAUTHORIZED )  )     {", "cache . invalidate ( cacheKey )  ;", "KMSAudit . AUDIT _ LOG . info (  \" UNAUTHORIZED [ op =  {  }  ,    key =  {  }  ,    user =  {  }  ]     {  }  \"  ,    op ,    key ,    user ,    extraMsg )  ;", "} else    {", "try    {", "KMSAudit . AuditEvent   event    =    cache . get ( cacheKey ,    new   Callable < KMSAudit . AuditEvent >  (  )     {", "@ Override", "public   KMSAudit . AuditEvent   call (  )    throws   Exception    {", "return   new   KMSAudit . AuditEvent ( key ,    user ,    op ,    extraMsg )  ;", "}", "}  )  ;", "if    (  ( event . getAccessCount (  )  . incrementAndGet (  )  )     =  =     0  )     {", "event . getAccessCount (  )  . incrementAndGet (  )  ;", "logEvent ( event )  ;", "}", "}    catch    ( ExecutionException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "}", "} else    {", "List < String >    kvs    =    new   LinkedList < String >  (  )  ;", "if    ( op    !  =    null )     {", "kvs . add (  (  \" op =  \"     +    op )  )  ;", "}", "if    (  !  ( Strings . isNullOrEmpty ( key )  )  )     {", "kvs . add (  (  \" key =  \"     +    key )  )  ;", "}", "if    (  !  ( Strings . isNullOrEmpty ( user )  )  )     {", "kvs . add (  (  \" user =  \"     +    user )  )  ;", "}", "if    (  ( kvs . size (  )  )     =  =     0  )     {", "KMSAudit . AUDIT _ LOG . info (  \"  {  }     {  }  \"  ,    opStatus . toString (  )  ,    extraMsg )  ;", "} else    {", "String   join    =    Joiner . on (  \"  ,     \"  )  . join ( kvs )  ;", "KMSAudit . AUDIT _ LOG . info (  \"  {  }  [  {  }  ]     {  }  \"  ,    opStatus . toString (  )  ,    join ,    extraMsg )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["op"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "executor . shutdownNow (  )  ;", "}", "METHOD_END"], "methodName": ["shutdown"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "op ( KMSAudit . OpStatus . UNAUTHENTICATED ,    null ,    null ,    null ,     (  (  (  (  (  (  (  (  \" RemoteHost :  \"     +    remoteHost )     +     \"    Method :  \"  )     +    method )     +     \"    URL :  \"  )     +    url )     +     \"    ErrorMsg :  '  \"  )     +    extraMsg )     +     \"  '  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["unauthenticated"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "op ( KMSAudit . OpStatus . UNAUTHORIZED ,    op ,    user . getShortUserName (  )  ,    key ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["unauthorized"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAudit"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    proxyuserConf    =    KMSWebApp . getConfiguration (  )  . getValByRegex (  \"  \\  . kms \\  \\  . proxyuser \\  \\  .  \"  )  ;", "Configuration   conf    =    new   Configuration ( false )  ;", "for    ( Map . Entry < String ,    String >    entry    :    proxyuserConf . entrySet (  )  )     {", "conf . set ( entry . getKey (  )  . substring (  \" kms .  \"  . length (  )  )  ,    entry . getValue (  )  )  ;", "}", "return   conf ;", "}", "METHOD_END"], "methodName": ["getProxyuserConfiguration"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   KMSConfiguration . getConfiguration ( false ,    KMSConfiguration . KMS _ ACLS _ XML )  ;", "}", "METHOD_END"], "methodName": ["getACLsConf"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSConfiguration"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration ( loadHadoopDefaults )  ;", "String   confDir    =    System . getProperty (  . KMS _ CONFIG _ DIR )  ;", "if    ( confDir    !  =    null )     {", "try    {", "if    (  !  ( confDir . startsWith (  \"  /  \"  )  )  )     {", "throw   new   RuntimeException (  (  (  (  \" System   property    '  \"     +     (  . KMS _ CONFIG _ DIR )  )     +     \"  '    must   be   an   absolute   path :     \"  )     +    confDir )  )  ;", "}", "if    (  !  ( confDir . endsWith (  \"  /  \"  )  )  )     {", "confDir    +  =     \"  /  \"  ;", "}", "for    ( String   resource    :    resources )     {", "conf . addResource ( new   URL (  (  (  \" file :  /  /  \"     +    confDir )     +    resource )  )  )  ;", "}", "}    catch    ( MalformedURLException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "} else    {", "for    ( String   resource    :    resources )     {", "conf . addResource ( resource )  ;", "}", "}", "return   conf ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSConfiguration"}, {"methodBody": ["METHOD_START", "{", "return   KMSConfiguration . getConfiguration ( true ,     \" core - site . xml \"  ,    KMSConfiguration . KMS _ SITE _ XML )  ;", "}", "METHOD_END"], "methodName": ["getKMSConf"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSConfiguration"}, {"methodBody": ["METHOD_START", "{", "boolean   newer    =    false ;", "String   confDir    =    System . getProperty (  . KMS _ CONFIG _ DIR )  ;", "if    ( confDir    !  =    null )     {", "if    (  !  ( confDir . startsWith (  \"  /  \"  )  )  )     {", "throw   new   RuntimeException (  (  (  (  \" System   property    '  \"     +     (  . KMS _ CONFIG _ DIR )  )     +     \"  '    must   be   an   absolute   path :     \"  )     +    confDir )  )  ;", "}", "if    (  !  ( confDir . endsWith (  \"  /  \"  )  )  )     {", "confDir    +  =     \"  /  \"  ;", "}", "File   f    =    new   File ( confDir ,     . KMS _ ACLS _ XML )  ;", "newer    =     (  ( f . lastModified (  )  )     -    time )     >     1  0  0  ;", "}", "return   newer ;", "}", "METHOD_END"], "methodName": ["isACLsFileNewer"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSConfiguration"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    json    =    new   LinkedHashMap < String ,    Object >  (  )  ;", "json . put ( ERROR _ EXCEPTION _ JSON ,    ex . getClass (  )  . getName (  )  )  ;", "json . put ( ERROR _ MESSAGE _ JSON ,    getOneLineMessage ( ex )  )  ;", "log ( status ,    ex )  ;", "return   Respe . status ( status )  . type ( APPLICATION _ JSON )  . entity ( json )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["createResponse"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSExceptionsProvider"}, {"methodBody": ["METHOD_START", "{", "String   message    =    exception . getMessage (  )  ;", "if    ( message    !  =    null )     {", "int   i    =    message . indexOf (  . ENTER )  ;", "if    ( i    >     (  -  1  )  )     {", "message    =    message . substring (  0  ,    i )  ;", "}", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["getOneLineMessage"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSExceptionsProvider"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   ugi    =    KMSMDCFilter . getUgi (  )  ;", "String   method    =    KMSMDCFilter . getMethod (  )  ;", "String   url    =    KMSMDCFilter . getURL (  )  ;", "String   msg    =    getOneLineMessage ( ex )  ;", ". LOG . warn (  \" User :  '  {  }  '    Method :  {  }    URL :  {  }    Response :  {  }  -  {  }  \"  ,    ugi ,    method ,    url ,    status ,    msg ,    ex )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSExceptionsProvider"}, {"methodBody": ["METHOD_START", "{", "return   KMSMDCFilter . DATA _ TL . get (  )  . method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSMDCFilter"}, {"methodBody": ["METHOD_START", "{", "return   KMSMDCFilter . DATA _ TL . get (  )  . url . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getURL"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSMDCFilter"}, {"methodBody": ["METHOD_START", "{", "return   KMSMDCFilter . DATA _ TL . get (  )  . ugi ;", "}", "METHOD_END"], "methodName": ["getUgi"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSMDCFilter"}, {"methodBody": ["METHOD_START", "{", "Map   json    =    new   LinkedHashMap (  )  ;", "if    ( meta    !  =    null )     {", "json . put ( NAME _ FIELD ,    Name )  ;", "json . put ( CIPHER _ FIELD ,    meta . getCipher (  )  )  ;", "json . put ( LENGTH _ FIELD ,    meta . getBitLength (  )  )  ;", "json . put ( DESCRIPTION _ FIELD ,    meta . getDescription (  )  )  ;", "json . put ( ATTRIBUTES _ FIELD ,    meta . getAttributes (  )  )  ;", "json . put ( CREATED _ FIELD ,    meta . getCreated (  )  . getTime (  )  )  ;", "json . put ( VERSIONS _ FIELD ,     (  ( long )     ( meta . getVersions (  )  )  )  )  ;", "}", "return   json ;", "}", "METHOD_END"], "methodName": ["toJSON"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSServerJSONUtils"}, {"methodBody": ["METHOD_START", "{", "List   json    =    new   ArrayList (  )  ;", "for    ( int   i    =     0  ;    i    <     ( keyNames . length )  ;    i +  +  )     {", "json . add (  . toJSON ( keyNames [ i ]  ,    metas [ i ]  )  )  ;", "}", "return   json ;", "}", "METHOD_END"], "methodName": ["toJSON"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSServerJSONUtils"}, {"methodBody": ["METHOD_START", "{", "List   json    =    new   ArrayList (  )  ;", "if    ( keyVersions    !  =    null )     {", "for    ( KeyProvider . KeyVersion   version    :    keyVersions )     {", "json . add (  . toJSON ( version )  )  ;", "}", "}", "return   json ;", "}", "METHOD_END"], "methodName": ["toJSON"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSServerJSONUtils"}, {"methodBody": ["METHOD_START", "{", "Map   json    =    new   LinkedHashMap (  )  ;", "if    ( Version    !  =    null )     {", "json . put ( NAME _ FIELD ,    Version . getName (  )  )  ;", "json . put ( VERSION _ NAME _ FIELD ,    Version . getVersionName (  )  )  ;", "json . put ( MATERIAL _ FIELD ,    Base 6  4  . encodeBase 6  4 URLSafeString ( Version . getMaterial (  )  )  )  ;", "}", "return   json ;", "}", "METHOD_END"], "methodName": ["toJSON"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSServerJSONUtils"}, {"methodBody": ["METHOD_START", "{", "Map   json    =    new   LinkedHashMap (  )  ;", "if    ( encryptedKeyVersion    !  =    null )     {", "json . put ( VERSION _ NAME _ FIELD ,    encryptedKeyVersion . getEncryptionKeyVersionName (  )  )  ;", "json . put ( IV _ FIELD ,    Base 6  4  . encodeBase 6  4 URLSafeString ( encryptedKeyVersion . getEncryptedKeyIv (  )  )  )  ;", "json . put ( ENCRYPTED _ KEY _ VERSION _ FIELD ,     . toJSON ( encryptedKeyVersion . getEncryptedKeyVersion (  )  )  )  ;", "}", "return   json ;", "}", "METHOD_END"], "methodName": ["toJSON"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSServerJSONUtils"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . acls ;", "}", "METHOD_END"], "methodName": ["getACLs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . adminCallsMeter ;", "}", "METHOD_END"], "methodName": ["getAdminCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   new   Configuration ( KMSWebApp . kmsConf )  ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . decryptEEKCallsMeter ;", "}", "METHOD_END"], "methodName": ["getDecryptEEKCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . generateEEKCallsMeter ;", "}", "METHOD_END"], "methodName": ["getGenerateEEKCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . invalidCallsMeter ;", "}", "METHOD_END"], "methodName": ["getInvalidCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . kmsAudit ;", "}", "METHOD_END"], "methodName": ["getKMSAudit"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . keyCallsMeter ;", "}", "METHOD_END"], "methodName": ["getKeyCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . keyProviderCryptoExtension ;", "}", "METHOD_END"], "methodName": ["getKeyProvider"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . unauthenticatedCallsMeter ;", "}", "METHOD_END"], "methodName": ["getUnauthenticatedCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "return   KMSWebApp . unauthorizedCallsMeter ;", "}", "METHOD_END"], "methodName": ["getUnauthorizedCallsMeter"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "if    (  ( System . getProperty (  \" log 4 j . configuration \"  )  )     =  =    null )     {", "System . setProperty (  \" log 4 j . defaultInitOverride \"  ,     \" true \"  )  ;", "boolean   fromClasspath    =    true ;", "File   log 4 jConf    =    new   File ( confDir ,     . LOG 4 J _ PROPERTIES )  . getAbsoluteFile (  )  ;", "if    ( log 4 jConf . exists (  )  )     {", "PropertyConfigurator . configureAndWatch ( log 4 jConf . getPath (  )  ,     1  0  0  0  )  ;", "fromClasspath    =    false ;", "} else    {", "ClassLoader   cl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "URL   log 4 jUrl    =    cl . getResource (  . LOG 4 J _ PROPERTIES )  ;", "if    ( log 4 jUrl    !  =    null )     {", "PropertyConfigurator . configure ( log 4 jUrl )  ;", "}", "}", ". LOG    =    LoggerFactory . getLogger (  . class )  ;", ". LOG . debug (  \" KMS   log   starting \"  )  ;", "if    ( fromClasspath )     {", ". LOG . warn (  \" Log 4 j   configuration   file    '  {  }  '    not   found \"  ,     . LOG 4 J _ PROPERTIES )  ;", ". LOG . warn (  \" Logging   with   INFO   level   to   standard   output \"  )  ;", "}", "} else    {", ". LOG    =    LoggerFactory . getLogger (  . class )  ;", "}", "}", "METHOD_END"], "methodName": ["initLogging"], "fileName": "org.apache.hadoop.crypto.key.kms.server.KMSWebApp"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "rGroupInformationtConfiguration ( conf )  ;", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration ( false )  ;", "conf . set (  \" security . key . provider . path \"  ,     (  (  \" jceks :  /  / file @  /  \"     +     ( keyStoreDir . getAbsolutePath (  )  )  )     +     \"  / kms . keystore \"  )  )  ;", "conf . set (  \" kms . authentication . type \"  ,     \" simple \"  )  ;", "return   conf ;", "}", "METHOD_END"], "methodName": ["createBaseKMSConf"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "try    {", "boolean   ssl    =    keyStore    !  =    null ;", "InetAddress   localhost    =    InetAddress . getByName (  \" localhost \"  )  ;", "String   host    =     \" localhost \"  ;", "ServerSocket   ss    =    new   ServerSocket (  0  ,     5  0  ,    localhost )  ;", "int   port    =    ss . getLocalPort (  )  ;", "ss . close (  )  ;", "Server    =    new   Server (  0  )  ;", "if    (  ! ssl )     {", "getConnectors (  )  [  0  ]  . setHost ( host )  ;", "getConnectors (  )  [  0  ]  . setPort ( port )  ;", "} else    {", "SslSocketConnector   c    =    new   SslSocketConnector (  )  ;", "c . setHost ( host )  ;", "c . setPort ( port )  ;", "c . setNeedClientAuth ( false )  ;", "c . setKeystore ( keyStore )  ;", "c . setKeystoreType (  \" jks \"  )  ;", "c . setKeyPassword ( password )  ;", "setConnectors ( new   Connector [  ]  {    c    }  )  ;", "}", "return", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  (  \" Could   not   start   embedded   servlet   container ,     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["createJettyServer"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "String   str    =    kmsUrl . toString (  )  ;", "str    =    str . replaceFirst (  \"  :  /  /  \"  ,     \"  @  \"  )  ;", "return   new   URI (  (  \" kms :  /  /  \"     +    str )  )  ;", "}", "METHOD_END"], "methodName": ["createKMSUri"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Set < Principal >    principals    =    new   HashSet < Principal >  (  )  ;", "principals . add ( new   KerberosPrincipal ( user )  )  ;", "Subject   subject    =    new   Subject ( false ,    principals ,    new   HashSet < Object >  (  )  ,    new   HashSet < Object >  (  )  )  ;", "LoginContext   loginContext    =    new   LoginContext (  \"  \"  ,    subject ,    null ,     . KerberosConfiguration . createClientConfig ( user ,     . keytab )  )  ;", "try    {", "loginContext . login (  )  ;", "subject    =    loginContext . getSubject (  )  ;", "UserGroupInformation   ugi    =    UserGroupInformation . getUGIFromSubject ( subject )  ;", "return   ugi . doAs ( action )  ;", "}    finally    {", "loginContext . logout (  )  ;", "}", "}", "METHOD_END"], "methodName": ["doAs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "boolean   ssl    =     ( server . getConnectors (  )  [  0  ]  . getClass (  )  )     =  =     ( SslSocketConnector . class )  ;", "try    {", "String   scheme    =     ( ssl )     ?     \" https \"     :     \" http \"  ;", "return   new   URL (  (  (  (  ( scheme    +     \"  :  /  /  \"  )     +     ( server . getConnectors (  )  [  0  ]  . getHost (  )  )  )     +     \"  :  \"  )     +     ( server . getConnectors (  )  [  0  ]  . getPort (  )  )  )  )  ;", "}    catch    ( MalformedURLException   ex )     {", "throw   new   RuntimeException (  (  \" It   should   never   happen ,     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["getJettyURL"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File (  \" dummy \"  )  ;", "file    =    file . getAbsoluteFile (  )  ;", "file    =    file . getParentFile (  )  ;", "file    =    new   File ( file ,     \" target \"  )  ;", "file    =    new   File ( file ,    UUID . randomUUID (  )  . toString (  )  )  ;", "if    (  !  ( file . mkdirs (  )  )  )     {", "throw   new   RuntimeException (  (  \" Could   not   create   t   directory :     \"     +    file )  )  ;", "}", "return   file ;", "}", "METHOD_END"], "methodName": ["getTestDir"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "System . setProperty ( KMSConfiguration . KMS _ CONFIG _ DIR ,    confDir . getAbsolutePath (  )  )  ;", "System . setProperty (  \" log 4 j . configuration \"  ,     \" log 4 j . properties \"  )  ;", "Server   jetty    =     . createJettyServer ( keystore ,    password )  ;", "try    {", "ClassLoader   cl    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "URL   url    =    cl . getResource (  \" webapp \"  )  ;", "if    ( url    =  =    null )     {", "throw   new   RuntimeException (  \" Could   not   find   webapp /    dir   in   test   classpath \"  )  ;", "}", "WebAppContext   context    =    new   WebAppContext ( url . getPath (  )  ,     \"  / kms \"  )  ;", "jetty . addHandler ( context )  ;", "jetty . start (  )  ;", "url    =    new   URL (  . getJettyURL ( jetty )  ,     \" kms \"  )  ;", "System . out . println (  (  \" Test   KMS   running   at :     \"     +    url )  )  ;", "callable . kmsUrl    =    url ;", "callable . call (  )  ;", "}    finally    {", "if    (  ( jetty    !  =    null )     &  &     ( jetty . isRunning (  )  )  )     {", "try    {", "jetty . stop (  )  ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException (  (  \" Could   not   stop   embedded   Jetty ,     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["runServer"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "File   kdcDir    =    TestKMS . getTestDir (  )  ;", "Properties   kdcConf    =    MiniKdc . createConf (  )  ;", "TestKMS . kdc    =    new   MiniKdc ( kdcConf ,    kdcDir )  ;", "TestKMS . kdc . start (  )  ;", "TestKMS . keytab    =    new   File ( kdcDir ,     \" keytab \"  )  ;", "List < String >    principals    =    new   ArrayList < String >  (  )  ;", "principals . add (  \" HTTP / localhost \"  )  ;", "principals . add (  \" client \"  )  ;", "principals . add (  \" client / host \"  )  ;", "principals . add (  \" client 1  \"  )  ;", "for    ( KMSACLs . Type   type    :    KMSACLs . Type . values (  )  )     {", "principals . add ( type . toString (  )  )  ;", "}", "principals . add (  \" CREATE _ MATERIAL \"  )  ;", "principals . add (  \" ROLLOVER _ MATERIAL \"  )  ;", "TestKMS . kdc . createPrincipal ( TestKMS . keytab ,    principals . toArray ( new   String [ principals . size (  )  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["setUpMiniKdc"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "if    (  ( TestKMS . kdc )     !  =    null )     {", "TestKMS . kdc . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDownMiniKdc"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "UserGroupInformation . setConfiguration ( conf )  ;", "final   File   testDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( testDir )  ;", "conf . set (  \" hadoop . kms . authentication . type \"  ,     \" kerberos \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . keytab \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . principal \"  ,     \" HTTP / localhost \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . name . rules \"  ,     \" DEFAULT \"  )  ;", "for    ( KMSACLs . Type   type    :    KMSACLs . Type . values (  )  )     {", "conf . set ( type . getConfigKey (  )  ,    type . toString (  )  )  ;", "}", "conf . set ( KMSACLs . Type . CREATE . getConfigKey (  )  ,     (  ( KMSACLs . Type . CREATE . toString (  )  )     +     \"  , SET _ KEY _ MATERIAL \"  )  )  ;", "conf . set ( KMSACLs . Type . ROLLOVER . getConfigKey (  )  ,     (  ( KMSACLs . Type . ROLLOVER . toString (  )  )     +     \"  , SET _ KEY _ MATERIAL \"  )  )  ;", "writeConf ( testDir ,    conf )  ;", "runServer ( null ,    null ,    testDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "final   Configuration   conf    =    new   Configuration (  )  ;", "conf . setInt ( DEFAULT _ BITLENGTH _ NAME ,     1  2  8  )  ;", "final   URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "doAs (  \" client \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "kp . createKey (  \" k \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . createKey (  \" k \"  ,    new   byte [  1  6  ]  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . rollNewVersion (  \" k \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . rollNewVersion (  \" k \"  ,    new   byte [  1  6  ]  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getKeys (  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getKeysMetadata (  \" k \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getKeyVersion (  \" k @  0  \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getCurrentKey (  \" k \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getMetadata (  \" k \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "try    {", "kp . getKeyVersions (  \" k \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" CREATE \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProvider . KeyVersion   kv    =    kp . createKey (  \" k 0  \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" DELETE \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "kp . deleteKey (  \" k 0  \"  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" SET _ KEY _ MATERIAL \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProvider . KeyVersion   kv    =    kp . createKey (  \" k 1  \"  ,    new   byte [  1  6  ]  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" ROLLOVER \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProvider . KeyVersion   kv    =    kp . rollNewVersion (  \" k 1  \"  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" SET _ KEY _ MATERIAL \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProvider . KeyVersion   kv    =    kp . rollNewVersion (  \" k 1  \"  ,    new   byte [  1  6  ]  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "final   KeyVersion   currKv    =    doAs (  \" GET \"  ,    new   PrivilegedExceptionAction < KeyVersion >  (  )     {", "@ Override", "public   KeyVersion   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "kp . getKeyVersion (  \" k 1  @  0  \"  )  ;", "KeyVersion   kv    =    kp . getCurrentKey (  \" k 1  \"  )  ;", "return   kv ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . toString (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "final   EncryptedKeyVersion   encKv    =    doAs (  \" GENERATE _ EEK \"  ,    new   PrivilegedExceptionAction < EncryptedKeyVersion >  (  )     {", "@ Override", "public   EncryptedKeyVersion   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProviderCryptoExtension   kpCE    =    KeyProviderCryptoExtension . createKeyProviderCryptoExtension ( kp )  ;", "EncryptedKeyVersion   ek 1     =    kpCE . generateEncryptedKey ( currKv . getName (  )  )  ;", "return   ek 1  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . toString (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" DECRYPT _ EEK \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "KeyProviderCryptoExtension   kpCE    =    KeyProviderCryptoExtension . createKeyProviderCryptoExtension ( kp )  ;", "kpCE . decryptEncryptedKey ( encKv )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" GET _ KEYS \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "kp . getKeys (  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" GET _ METADATA \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "try    {", "kp . getMetadata (  \" k 1  \"  )  ;", "kp . getKeysMetadata (  \" k 1  \"  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "KMSWebApp . getACLs (  )  . stopReloader (  )  ;", "Thread . sleep (  1  0  )  ;", "conf . set ( KMSACLs . Type . CREATE . getConfigKey (  )  ,     \" foo \"  )  ;", "writeConf ( testDir ,    conf )  ;", "Thread . sleep (  1  0  0  0  )  ;", "KMSWebApp . getACLs (  )  . run (  )  ;", "doAs (  \" CREATE \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProvider . KeyVersion   kv    =    kp . createKey (  \" k 2  \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testACLs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "UserGroupInformation . setConfiguration ( conf )  ;", "final   File   testDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( testDir )  ;", "conf . set (  \" hadoop . kms . authentication . type \"  ,     \" kerberos \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . keytab \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . principal \"  ,     \" HTTP / localhost \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . name . rules \"  ,     \" DEFAULT \"  )  ;", "writeConf ( testDir ,    conf )  ;", "runServer ( null ,    null ,    testDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "final   Configuration   conf    =    new   Configuration (  )  ;", "conf . setInt ( DEFAULT _ BITLENGTH _ NAME ,     6  4  )  ;", "final   URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "final   Credentials   credentials    =    new   Credentials (  )  ;", "final   UserGroupInformation   nonKerberosUgi    =    UserGroupInformation . getCurrentUser (  )  ;", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "kp . createKey (  \" kA \"  ,    new   KeyProvider . Options ( conf )  )  ;", "}    catch    ( IOException   ex )     {", "System . out . println ( ex . getMessage (  )  )  ;", "}", "doAs (  \" client \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProviderDelegationTokenExtension   kpdte    =    KeyProviderDelegationTokenExtension . createKeyProviderDelegationTokenExtension ( kp )  ;", "kpdte . addDelegationTokens (  \" foo \"  ,    credentials )  ;", "return   null ;", "}", "}  )  ;", "nonKerberosUgi . addCredentials ( credentials )  ;", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "kp . createKey (  \" kA \"  ,    new   KeyProvider . Options ( conf )  )  ;", "}    catch    ( IOException   ex )     {", "System . out . println ( ex . getMessage (  )  )  ;", "}", "nonKerberosUgi . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "kp . createKey (  \" kD \"  ,    new   KeyProvider . Options ( conf )  )  ;", "return   null ;", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testDelegationTokenAccess"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "UserGroupInformation . setConfiguration ( conf )  ;", "File   confDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( confDir )  ;", "writeConf ( confDir ,    conf )  ;", "runServer ( null ,    null ,    confDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "Date   started    =    new   Date (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "Assert . assertTrue ( kp . getKeys (  )  . isEmpty (  )  )  ;", "Assert . assertEquals (  0  ,    kp . getKeysMetadata (  )  . length )  ;", "KeyProvider . Options   options    =    new   KeyProvider . Options ( conf )  ;", "options . setCipher (  \" AES / CTR / NoPadding \"  )  ;", "options . setBitLength (  1  2  8  )  ;", "options . setDescription (  \" l 1  \"  )  ;", "KeyProvider . KeyVersion   kv 0     =    kp . createKey (  \" k 1  \"  ,    options )  ;", "Assert . assertNotNull ( kv 0  )  ;", "Assert . assertNotNull ( kv 0  . getVersionName (  )  )  ;", "Assert . assertNotNull ( kv 0  . getMaterial (  )  )  ;", "KeyProvider . KeyVersion   kv 1     =    kp . getKeyVersion ( kv 0  . getVersionName (  )  )  ;", "Assert . assertEquals ( kv 0  . getVersionName (  )  ,    kv 1  . getVersionName (  )  )  ;", "Assert . assertNotNull ( kv 1  . getMaterial (  )  )  ;", "KeyProvider . KeyVersion   cv 1     =    kp . getCurrentKey (  \" k 1  \"  )  ;", "Assert . assertEquals ( kv 0  . getVersionName (  )  ,    cv 1  . getVersionName (  )  )  ;", "Assert . assertNotNull ( cv 1  . getMaterial (  )  )  ;", "KeyProvider . Metadata   m 1     =    kp . getMetadata (  \" k 1  \"  )  ;", "Assert . assertEquals (  \" AES / CTR / NoPadding \"  ,    m 1  . getCipher (  )  )  ;", "Assert . assertEquals (  \" AES \"  ,    m 1  . getAlgorithm (  )  )  ;", "Assert . assertEquals (  1  2  8  ,    m 1  . getBitLength (  )  )  ;", "Assert . assertEquals (  1  ,    m 1  . getVersions (  )  )  ;", "Assert . assertNotNull ( m 1  . getCreated (  )  )  ;", "Assert . assertTrue ( started . before ( m 1  . getCreated (  )  )  )  ;", "List < KeyProvider . KeyVersion >    lkv 1     =    kp . getKeyVersions (  \" k 1  \"  )  ;", "Assert . assertEquals (  1  ,    lkv 1  . size (  )  )  ;", "Assert . assertEquals ( kv 0  . getVersionName (  )  ,    lkv 1  . get (  0  )  . getVersionName (  )  )  ;", "Assert . assertNotNull ( kv 1  . getMaterial (  )  )  ;", "KeyProvider . KeyVersion   kv 2     =    kp . rollNewVersion (  \" k 1  \"  )  ;", "Assert . assertNotSame ( kv 0  . getVersionName (  )  ,    kv 2  . getVersionName (  )  )  ;", "Assert . assertNotNull ( kv 2  . getMaterial (  )  )  ;", "kv 2     =    kp . getKeyVersion ( kv 2  . getVersionName (  )  )  ;", "boolean   eq    =    true ;", "for    ( int   i    =     0  ;    i    <     ( kv 1  . getMaterial (  )  . length )  ;    i +  +  )     {", "eq    =    eq    &  &     (  ( kv 1  . getMaterial (  )  [ i ]  )     =  =     ( kv 2  . getMaterial (  )  [ i ]  )  )  ;", "}", "Assert . assertFalse ( eq )  ;", "KeyProvider . KeyVersion   cv 2     =    kp . getCurrentKey (  \" k 1  \"  )  ;", "Assert . assertEquals ( kv 2  . getVersionName (  )  ,    cv 2  . getVersionName (  )  )  ;", "Assert . assertNotNull ( cv 2  . getMaterial (  )  )  ;", "eq    =    true ;", "for    ( int   i    =     0  ;    i    <     ( kv 1  . getMaterial (  )  . length )  ;    i +  +  )     {", "eq    =    eq    &  &     (  ( cv 2  . getMaterial (  )  [ i ]  )     =  =     ( kv 2  . getMaterial (  )  [ i ]  )  )  ;", "}", "Assert . assertTrue ( eq )  ;", "List < KeyProvider . KeyVersion >    lkv 2     =    kp . getKeyVersions (  \" k 1  \"  )  ;", "Assert . assertEquals (  2  ,    lkv 2  . size (  )  )  ;", "Assert . assertEquals ( kv 1  . getVersionName (  )  ,    lkv 2  . get (  0  )  . getVersionName (  )  )  ;", "Assert . assertNotNull ( lkv 2  . get (  0  )  . getMaterial (  )  )  ;", "Assert . assertEquals ( kv 2  . getVersionName (  )  ,    lkv 2  . get (  1  )  . getVersionName (  )  )  ;", "Assert . assertNotNull ( lkv 2  . get (  1  )  . getMaterial (  )  )  ;", "KeyProvider . Metadata   m 2     =    kp . getMetadata (  \" k 1  \"  )  ;", "Assert . assertEquals (  \" AES / CTR / NoPadding \"  ,    m 2  . getCipher (  )  )  ;", "Assert . assertEquals (  \" AES \"  ,    m 2  . getAlgorithm (  )  )  ;", "Assert . assertEquals (  1  2  8  ,    m 2  . getBitLength (  )  )  ;", "Assert . assertEquals (  2  ,    m 2  . getVersions (  )  )  ;", "Assert . assertNotNull ( m 2  . getCreated (  )  )  ;", "Assert . assertTrue ( started . before ( m 2  . getCreated (  )  )  )  ;", "List < String >    ks 1     =    kp . getKeys (  )  ;", "Assert . assertEquals (  1  ,    ks 1  . size (  )  )  ;", "Assert . assertEquals (  \" k 1  \"  ,    ks 1  . get (  0  )  )  ;", "KeyProvider [  ]    kms 1     =    kp . getKeysMetadata (  \" k 1  \"  )  ;", "Assert . assertEquals (  1  ,    kms 1  . length )  ;", "Assert . assertEquals (  \" AES / CTR / NoPadding \"  ,    kms 1  [  0  ]  . getCipher (  )  )  ;", "Assert . assertEquals (  \" AES \"  ,    kms 1  [  0  ]  . getAlgorithm (  )  )  ;", "Assert . assertEquals (  1  2  8  ,    kms 1  [  0  ]  . getBitLength (  )  )  ;", "Assert . assertEquals (  2  ,    kms 1  [  0  ]  . getVersions (  )  )  ;", "Assert . assertNotNull ( kms 1  [  0  ]  . getCreated (  )  )  ;", "Assert . assertTrue ( started . before ( kms 1  [  0  ]  . getCreated (  )  )  )  ;", "KeyProvider . KeyVersion   kv    =    kp . getCurrentKey (  \" k 1  \"  )  ;", "KeyProviderCryptoExtension   kpExt    =    KeyProviderCryptoExtension . createKeyProviderCryptoExtension ( kp )  ;", "EncryptedKeyVersion   ek 1     =    kpExt . generateEncryptedKey ( kv . getName (  )  )  ;", "Assert . assertEquals ( EEK ,    ek 1  . getEncryptedKeyVersion (  )  . getVersionName (  )  )  ;", "Assert . assertNotNull ( ek 1  . getEncryptedKeyVersion (  )  . getMaterial (  )  )  ;", "Assert . assertEquals ( kv . getMaterial (  )  . length ,    ek 1  . getEncryptedKeyVersion (  )  . getMaterial (  )  . length )  ;", "KeyProvider . KeyVersion   k 1     =    kpExt . decryptEncryptedKey ( ek 1  )  ;", "Assert . assertEquals ( EK ,    k 1  . getVersionName (  )  )  ;", "KeyProvider . KeyVersion   k 1 a    =    kpExt . decryptEncryptedKey ( ek 1  )  ;", "Assert . assertArrayEquals ( k 1  . getMaterial (  )  ,    k 1 a . getMaterial (  )  )  ;", "Assert . assertEquals ( kv . getMaterial (  )  . length ,    k 1  . getMaterial (  )  . length )  ;", "EncryptedKeyVersion   ek 2     =    kpExt . generateEncryptedKey ( kv . getName (  )  )  ;", "KeyProvider . KeyVersion   k 2     =    kpExt . decryptEncryptedKey ( ek 2  )  ;", "boolean   isEq    =    true ;", "for    ( int   i    =     0  ;    isEq    &  &     ( i    <     ( ek 2  . getEncryptedKeyVersion (  )  . getMaterial (  )  . length )  )  ;    i +  +  )     {", "isEq    =     ( k 2  . getMaterial (  )  [ i ]  )     =  =     ( k 1  . getMaterial (  )  [ i ]  )  ;", "}", "Assert . assertFalse ( isEq )  ;", "kp . deleteKey (  \" k 1  \"  )  ;", "Assert . assertNull ( kp . getKeyVersion (  \" k 1  \"  )  )  ;", "Assert . assertNull ( kp . getKeyVersions (  \" k 1  \"  )  )  ;", "Assert . assertNull ( kp . getMetadata (  \" k 1  \"  )  )  ;", "Assert . assertTrue ( kp . getKeys (  )  . isEmpty (  )  )  ;", "Assert . assertEquals (  0  ,    kp . getKeysMetadata (  )  . length )  ;", "options    =    new   KeyProvider . Options ( conf )  ;", "options . setCipher (  \" AES / CTR / NoPadding \"  )  ;", "options . setBitLength (  1  2  8  )  ;", "kp . createKey (  \" k 2  \"  ,    options )  ;", "KeyProvider . Metadata   meta    =    kp . getMetadata (  \" k 2  \"  )  ;", "Assert . assertNull ( meta . getDescription (  )  )  ;", "Assert . assertTrue ( meta . getAttributes (  )  . isEmpty (  )  )  ;", "options    =    new   KeyProvider . Options ( conf )  ;", "options . setCipher (  \" AES / CTR / NoPadding \"  )  ;", "options . setBitLength (  1  2  8  )  ;", "options . setDescription (  \" d \"  )  ;", "kp . createKey (  \" k 3  \"  ,    options )  ;", "meta    =    kp . getMetadata (  \" k 3  \"  )  ;", "Assert . assertEquals (  \" d \"  ,    meta . getDescription (  )  )  ;", "Assert . assertTrue ( meta . getAttributes (  )  . isEmpty (  )  )  ;", "Map < String ,    String >    attributes    =    new   HashMap < String ,    String >  (  )  ;", "attributes . put (  \" a \"  ,     \" A \"  )  ;", "options    =    new   KeyProvider . Options ( conf )  ;", "options . setCipher (  \" AES / CTR / NoPadding \"  )  ;", "options . setBitLength (  1  2  8  )  ;", "options . setAttributes ( attributes )  ;", "kp . createKey (  \" k 4  \"  ,    options )  ;", "meta    =    kp . getMetadata (  \" k 4  \"  )  ;", "Assert . assertNull ( meta . getDescription (  )  )  ;", "Assert . assertEquals ( attributes ,    meta . getAttributes (  )  )  ;", "options    =    new   KeyProvider . Options ( conf )  ;", "options . setCipher (  \" AES / CTR / NoPadding \"  )  ;", "options . setBitLength (  1  2  8  )  ;", "options . setDescription (  \" d \"  )  ;", "options . setAttributes ( attributes )  ;", "kp . createKey (  \" k 5  \"  ,    options )  ;", "meta    =    kp . getMetadata (  \" k 5  \"  )  ;", "Assert . assertEquals (  \" d \"  ,    meta . getDescription (  )  )  ;", "Assert . assertEquals ( attributes ,    meta . getAttributes (  )  )  ;", "KeyProviderDelegationTokenExtension   kpdte    =    KeyProviderDelegationTokenExtension . createKeyProviderDelegationTokenExtension ( kp )  ;", "Credentials   credentials    =    new   Credentials (  )  ;", "kpdte . addDelegationTokens (  \" foo \"  ,    credentials )  ;", "Assert . assertEquals (  1  ,    credentials . getAllTokens (  )  . size (  )  )  ;", "InetSocketAddress   kmsAddr    =    new   InetSocketAddress ( getKMSUrl (  )  . getHost (  )  ,    getKMSUrl (  )  . getPort (  )  )  ;", "Assert . assertEquals ( new   Text (  \" kms - dt \"  )  ,    credentials . getToken ( SecurityUtil . buildTokenService ( kmsAddr )  )  . getKind (  )  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testKMSProvider"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "File   confDir    =    TestKMS . getTestDir (  )  ;", "Configuration   conf    =    createBaseKMSConf ( confDir )  ;", "conf . setInt ( TIMEOUT _ ATTR ,     1  )  ;", "writeConf ( confDir ,    conf )  ;", "ServerSocket   sock ;", "int   port ;", "try    {", "sock    =    new   ServerSocket (  0  ,     5  0  ,    InetAddress . getByName (  \" localhost \"  )  )  ;", "port    =    sock . getLocalPort (  )  ;", "}    catch    ( Exception   e )     {", "return ;", "}", "URL   url    =    new   URL (  (  (  \" http :  /  / localhost :  \"     +    port )     +     \"  / kms \"  )  )  ;", "URI   uri    =    createKMSUri ( url )  ;", "boolean   caughtTimeout    =    false ;", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "kp . getKeys (  )  ;", "}    catch    ( SocketTimeoutException   e )     {", "caughtTimeout    =    true ;", "}    catch    ( IOException   e )     {", "Assert . assertTrue (  (  \" Caught   unexpected   exception \"     +     ( e . toString (  )  )  )  ,    false )  ;", "}", "caughtTimeout    =    false ;", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProviderCryptoExtension . createKeyProviderCryptoExtension ( kp )  . generateEncryptedKey (  \" a \"  )  ;", "}    catch    ( SocketTimeoutException   e )     {", "caughtTimeout    =    true ;", "}    catch    ( IOException   e )     {", "Assert . assertTrue (  (  \" Caught   unexpected   exception \"     +     ( e . toString (  )  )  )  ,    false )  ;", "}", "caughtTimeout    =    false ;", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProviderCryptoExtension . createKeyProviderCryptoExtension ( kp )  . decryptEncryptedKey ( new   KMSClientProvider . KMSEncryptedKeyVersion (  \" a \"  ,     \" a \"  ,    new   byte [  ]  {     1  ,     2     }  ,     \" EEK \"  ,    new   byte [  ]  {     1  ,     2     }  )  )  ;", "}    catch    ( SocketTimeoutException   e )     {", "caughtTimeout    =    true ;", "}    catch    ( IOException   e )     {", "Assert . assertTrue (  (  \" Caught   unexpected   exception \"     +     ( e . toString (  )  )  )  ,    false )  ;", "}", "Assert . assertTrue ( caughtTimeout )  ;", "sock . close (  )  ;", "}", "METHOD_END"], "methodName": ["testKMSTimeout"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "UserGroupInformation . setConfiguration ( conf )  ;", "final   File   testDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( testDir )  ;", "conf . set (  \" hadoop . kms . authentication . type \"  ,     \" kerberos \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . keytab \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . principal \"  ,     \" HTTP / localhost \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . name . rules \"  ,     \" DEFAULT \"  )  ;", "conf . set (  \" hadoop . kms . proxyuser . client . users \"  ,     \" foo \"  )  ;", "conf . set (  \" hadoop . kms . proxyuser . client . hosts \"  ,     \"  *  \"  )  ;", "writeConf ( testDir ,    conf )  ;", "runServer ( null ,    null ,    testDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "final   Configuration   conf    =    new   Configuration (  )  ;", "conf . setInt ( DEFAULT _ BITLENGTH _ NAME ,     6  4  )  ;", "final   URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "UserGroupInformation   clientUgi    =    UserGroupInformation . loginUserFromKeytabAndReturnUGI (  \" client \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "clientUgi . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "final   KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "kp . createKey (  \" kAA \"  ,    new   KeyProvider . Options ( conf )  )  ;", "UserGroupInformation   fooUgi    =    UserGroupInformation . createRemoteUser (  \" foo \"  )  ;", "fooUgi . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "Assert . assertNotNull ( kp . createKey (  \" kBB \"  ,    new   KeyProvider . Options ( conf )  )  )  ;", "return   null ;", "}", "}  )  ;", "UserGroupInformation   foo 1 Ugi    =    UserGroupInformation . createRemoteUser (  \" foo 1  \"  )  ;", "foo 1 Ugi . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "try    {", "kp . createKey (  \" kCC \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthorizationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testProxyUser"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "UserGroupInformation . setConfiguration ( conf )  ;", "File   testDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( testDir )  ;", "conf . set (  \" hadoop . kms . authentication . type \"  ,     \" kerberos \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . keytab \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . principal \"  ,     \" HTTP / localhost \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . name . rules \"  ,     \" DEFAULT \"  )  ;", "for    ( KMSACLs . Type   type    :    KMSACLs . Type . values (  )  )     {", "conf . set ( type . getConfigKey (  )  ,     \"     \"  )  ;", "}", "conf . set ( KMSACLs . Type . CREATE . getConfigKey (  )  ,     \" client \"  )  ;", "writeConf ( testDir ,    conf )  ;", "runServer ( null ,    null ,    testDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "final   Configuration   conf    =    new   Configuration (  )  ;", "conf . setInt ( DEFAULT _ BITLENGTH _ NAME ,     1  2  8  )  ;", "conf . setInt ( DEFAULT _ BITLENGTH _ NAME ,     6  4  )  ;", "final   URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "doAs (  \" client \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProvider . KeyVersion   kv    =    kp . createKey (  \" ck 0  \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "doAs (  \" client / host \"  ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "try    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "KeyProvider . KeyVersion   kv    =    kp . createKey (  \" ck 1  \"  ,    new   KeyProvider . Options ( conf )  )  ;", "Assert . assertNull ( kv . getMaterial (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail ( ex . getMessage (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testServicePrincipalACLs"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "if    ( kerberos )     {", "conf . set (  \" hadoop . security . authentication \"  ,     \" kerberos \"  )  ;", "}", "UserGroupInformation . setConfiguration ( conf )  ;", "File   testDir    =    TestKMS . getTestDir (  )  ;", "conf    =    createBaseKMSConf ( testDir )  ;", "final   String   keystore ;", "final   String   password ;", "if    ( ssl )     {", "String   sslConfDir    =    KeyStoreTestUtil . getClasspathDir ( TestKMS . class )  ;", "KeyStoreTestUtil . setupSSLConfig ( testDir . getAbsolutePath (  )  ,    sslConfDir ,    conf ,    false )  ;", "keystore    =     ( testDir . getAbsolutePath (  )  )     +     \"  / serverKS . jks \"  ;", "password    =     \" serverP \"  ;", "} else    {", "keystore    =    null ;", "password    =    null ;", "}", "if    ( kerberos )     {", "conf . set (  \" hadoop . kms . authentication . type \"  ,     \" kerberos \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . keytab \"  ,    TestKMS . keytab . getAbsolutePath (  )  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . principal \"  ,     \" HTTP / localhost \"  )  ;", "conf . set (  \" hadoop . kms . authentication . kerberos . name . rules \"  ,     \" DEFAULT \"  )  ;", "}", "writeConf ( testDir ,    conf )  ;", "runServer ( keystore ,    password ,    testDir ,    new   TestKMS . KMSCallable (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "final   Configuration   conf    =    new   Configuration (  )  ;", "URL   url    =    getKMSUrl (  )  ;", "Assert . assertEquals (  ( keystore    !  =    null )  ,    url . getProtocol (  )  . equals (  \" https \"  )  )  ;", "final   URI   uri    =    createKMSUri ( getKMSUrl (  )  )  ;", "if    ( kerberos )     {", "for    ( String   user    :    new   String [  ]  {     \" client \"  ,     \" client / host \"     }  )     {", "doAs ( user ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "final   KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "Assert . assertTrue ( kp . getKeys (  )  . isEmpty (  )  )  ;", "return   null ;", "}", "}  )  ;", "}", "} else    {", "KeyProvider   kp    =    new   KMSClientProvider ( uri ,    conf )  ;", "Assert . assertTrue ( kp . getKeys (  )  . isEmpty (  )  )  ;", "}", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testStartStop"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "testStartStop ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testStartStopHttpKerberos"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "testStartStop ( false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testStartStopHttpPseudo"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "testStartStop ( true ,    true )  ;", "}", "METHOD_END"], "methodName": ["testStartStopHttpsKerberos"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "testStartStop ( true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testStartStopHttpsPseudo"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Writer   writer    =    new   FileWriter ( new   File ( confDir ,    KMSConfiguration . KMS _ SITE _ XML )  )  ;", "conf . writeXml ( writer )  ;", "writer . close (  )  ;", "writer    =    new   FileWriter ( new   File ( confDir ,    KMSConfiguration . KMS _ ACLS _ XML )  )  ;", "conf . writeXml ( writer )  ;", "writer . close (  )  ;", "writer    =    new   FileWriter ( new   File ( confDir ,     \" core - site . xml \"  )  )  ;", "new   Configuration ( false )  . writeXml ( writer )  ;", "writer . close (  )  ;", "}", "METHOD_END"], "methodName": ["writeConf"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMS"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration ( false )  ;", "for    (  . Type   type    :     . Type . values (  )  )     {", "conf . set ( type . getConfigKey (  )  ,     (  ( type . toString (  )  )     +     \"     \"  )  )  ;", "}", "acls    =    new    ( conf )  ;", "for    (  . Type   type    :     . Type . values (  )  )     {", "Assert . assertTrue ( acls . hasAccess ( type ,    UserGroupInformation . createRemoteUser ( type . toString (  )  )  )  )  ;", "Assert . assertFalse ( acls . hasAccess ( type ,    UserGroupInformation . createRemoteUser (  \" foo \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCustom"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSACLs"}, {"methodBody": ["METHOD_START", "{", "KMSACLs   acls    =    new   KMSACLs ( new   Configuration ( false )  )  ;", "for    ( KMSACLs . Type   type    :    KMSACLs . Type . values (  )  )     {", "Assert . assertTrue ( acls . hasAccess ( type ,    UserGroupInformation . createRemoteUser (  \" foo \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDefaults"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSACLs"}, {"methodBody": ["METHOD_START", "{", "System . setErr ( originalOut )  ;", "LogManager . resetConfiguration (  )  ;", "kms . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSAudit"}, {"methodBody": ["METHOD_START", "{", "capturedOut . flush (  )  ;", "String   logOutput    =    new   String ( memOut . toByteArray (  )  )  ;", "memOut    =    new   ByteArrayOutputStream (  )  ;", "filterOuttOutputStream ( memOut )  ;", "return   logOutput ;", "}", "METHOD_END"], "methodName": ["getAndResetLogOutput"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSAudit"}, {"methodBody": ["METHOD_START", "{", "originalOut    =    System . err ;", "memOut    =    new   ByteArrayOutputStream (  )  ;", "filterOut    =    new    . FilterOut ( memOut )  ;", "capturedOut    =    new   PrintStream ( filterOut )  ;", "System . setErr ( capturedOut )  ;", "PropertyConfigurator . configure ( Thread . currentThread (  )  . getContextClassLoader (  )  . getResourceAsStream (  \" log 4 j - kmsaudit . properties \"  )  )  ;", "this . kmsAudit    =    new   KMSAudit (  1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSAudit"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   luser    =    Mockito . mock ( UserGroupInformation . class )  ;", "Mockito . when ( luser . getShortUserName (  )  )  . thenReturn (  \" luser \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DELETE _ KEY ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . ROLL _ NEW _ VERSION ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "Thread . sleep (  1  5  0  0  )  ;", "kms . ok ( luser ,    KMS . KMSOp . DECRYPT _ EEK ,     \" k 1  \"  ,     \" testmsg \"  )  ;", "Thread . sleep (  1  5  0  0  )  ;", "String   out    =    getAndResetLogOutput (  )  ;", "System . out . println ( out )  ;", "Assert . assertTrue ( out . matches (  (  \" OK \\  \\  [ op = DECRYPT _ EEK ,    key = k 1  ,    user = luser ,    accessCount =  1  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"     +     (  (  (  \" OK \\  \\  [ op = DELETE _ KEY ,    key = k 1  ,    user = luser \\  \\  ]    testmsg \"     +     \" OK \\  \\  [ op = ROLL _ NEW _ VERSION ,    key = k 1  ,    user = luser \\  \\  ]    testmsg \"  )     +     \" OK \\  \\  [ op = DECRYPT _ EEK ,    key = k 1  ,    user = luser ,    accessCount =  6  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"  )     +     \" OK \\  \\  [ op = DECRYPT _ EEK ,    key = k 1  ,    user = luser ,    accessCount =  1  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAggregation"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSAudit"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation   luser    =    Mockito . mock ( UserGroupInformation . class )  ;", "Mockito . when ( luser . getShortUserName (  )  )  . thenReturn (  \" luser \"  )  ;", "kms . unauthorized ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 2  \"  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "kms . unauthorized ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  )  ;", "kms . ok ( luser ,    KMS . KMSOp . GENERATE _ EEK ,     \" k 3  \"  ,     \" testmsg \"  )  ;", "Thread . sleep (  2  0  0  0  )  ;", "String   out    =    getAndResetLogOutput (  )  ;", "System . out . println ( out )  ;", "Assert . assertTrue ( out . matches (  (  \" UNAUTHORIZED \\  \\  [ op = GENERATE _ EEK ,    key = k 2  ,    user = luser \\  \\  ]     \"     +     (  (  (  \" OK \\  \\  [ op = GENERATE _ EEK ,    key = k 3  ,    user = luser ,    accessCount =  1  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"     +     \" OK \\  \\  [ op = GENERATE _ EEK ,    key = k 3  ,    user = luser ,    accessCount =  5  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"  )     +     \" UNAUTHORIZED \\  \\  [ op = GENERATE _ EEK ,    key = k 3  ,    user = luser \\  \\  ]     \"  )     +     \" OK \\  \\  [ op = GENERATE _ EEK ,    key = k 3  ,    user = luser ,    accessCount =  1  ,    interval =  [  ^ m ]  {  1  ,  4  } ms \\  \\  ]    testmsg \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAggregationUnauth"], "fileName": "org.apache.hadoop.crypto.key.kms.server.TestKMSAudit"}]