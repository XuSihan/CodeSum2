[{"methodBody": ["METHOD_START", "{", "int   res    =    ToolRunner . run ( new   GetGroupsForTesting ( new   YarnConfiguration (  )  )  ,    argv )  ;", "System . exit ( res )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.client.GetGroupsForTesting"}, {"methodBody": ["METHOD_START", "{", "Thread   failoverThread    =    new   Thread (  )     {", "public   void   run (  )     {", "keepRunning    =    true ;", "while    ( keepRunning )     {", "if    ( cluster . getStartFailoverFlag (  )  )     {", "try    {", "explicitFailover (  )  ;", "keepRunning    =    false ;", "cluster . resetFailoverTriggeredFlag ( true )  ;", "}    catch    ( Exception   e )     {", "}    finally    {", "keepRunning    =    false ;", "}", "}", "try    {", "Thread . sleep (  5  0  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "}", "}  ;", "failoverThread . start (  )  ;", "return   failoverThread ;", "}", "METHOD_END"], "methodName": ["createAndStartFailoverThread"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "Configuration   configuration    =    new   YarnConfiguration ( conf )  ;", "YarnClient   client    =    YarnClient . createYarnClient (  )  ;", "client . init ( configuration )  ;", "client . start (  )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createAndStartYarnClient"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "int   activeRMIndex    =    cluster . getActiveRMIndex (  )  ;", "int   newActiveRMIndex    =     ( activeRMIndex    +     1  )     %     2  ;", "getAdminService ( activeRMIndex )  . transitionToStandby (  . req )  ;", "getAdminService ( newActiveRMIndex )  . transitionToActive (  . req )  ;", "assertEquals (  \" Failover   failed \"  ,    newActiveRMIndex ,    cluster . getActiveRMIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["explicitFailover"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "return   cluster . getResourceManager ( cluster . getActiveRMIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["getActiveRM"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "return   cluster . getResourceManager ( index )  . getRMContext (  )  . getRMAdminService (  )  ;", "}", "METHOD_END"], "methodName": ["getAdminService"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "conf . set ( HAUtil . addSuffix ( prefix ,    rmId )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["setConfForRM"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "setConfForRM ( rmId ,    RM _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ SCHEDULER _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ SCHEDULER _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ ADMIN _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ ADMIN _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ RESOURCE _ TRACKER _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ RESOURCE _ TRACKER _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ WEBAPP _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ WEBAPP _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ WEBAPP _ HTTPS _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ WEBAPP _ HTTPS _ PORT )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setRpcAddressForRM"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "failoverThread    =    null ;", "keepRunning    =    true ;", "conf    =    new   YarnConfiguration (  )  ;", "conf . setBoolean ( RM _ HA _ ENABLED ,    true )  ;", "conf . setInt ( CLIENT _ FAILOVER _ MAX _ ATTEMPTS ,     5  )  ;", "conf . set ( RM _ HA _ IDS ,     (  (  (  . RM 1  _ NODE _ ID )     +     \"  ,  \"  )     +     (  . RM 2  _ NODE _ ID )  )  )  ;", "setRpcAddressForRM (  . RM 1  _ NODE _ ID ,     . RM 1  _ PORT _ BASE )  ;", "setRpcAddressForRM (  . RM 2  _ NODE _ ID ,     . RM 2  _ PORT _ BASE )  ;", "conf . setLong ( CLIENT _ FAILOVER _ SLEEPTIME _ BASE _ MS ,     1  0  0 L )  ;", "conf . setBoolean ( YARN _ MINICLUSTER _ FIXED _ PORTS ,    true )  ;", "conf . setBoolean ( YARN _ MINICLUSTER _ USE _ RPC ,    true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "conf . setBoolean ( RECOVERY _ ENABLED ,    true )  ;", "conf . setBoolean ( AUTO _ FAILOVER _ ENABLED ,    false )  ;", "cluster    =    new    . MiniYARNClusterForHATesting ( TestRMFailover . class . getName (  )  ,     2  ,    numOfNMs ,     1  ,     1  ,    false ,    overrideClientRMService ,    overrideRTS ,    overrideApplicationMasterService )  ;", "cluster . resetStartFailoverFlag ( false )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "getAdminService (  0  )  . transitionToActive (  . req )  ;", "assertFalse (  \" RM   never   turned   active \"  ,     (  (  -  1  )     =  =     ( cluster . getActiveRMIndex (  )  )  )  )  ;", "verifyConnections (  )  ;", "explicitFailover (  )  ;", "verifyConnections (  )  ;", "failoverThread    =    createAndStartFailoverThread (  )  ;", "}", "METHOD_END"], "methodName": ["startHACluster"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "keepRunning    =    false ;", "if    (  ( failoverThread )     !  =    null )     {", "failoverThread . interrupt (  )  ;", "try    {", "failoverThread . join (  )  ;", "}    catch    ( InterruptedException   ex )     {", "LOG . error (  \" Error   joining   with   failover   thread \"  ,    ex )  ;", "}", "}", "cluster . stop (  )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "int   numRetries    =     3  ;", "while    (  ( numRetries -  -  )     >     0  )     {", "Configuration   conf    =    new   onf . YarnConfiguration ( this . conf )  ;", "YarnClient   client    =    createAndStartYarnClient ( conf )  ;", "try    {", "Thread . sleep (  1  0  0  )  ;", "client . getApplications (  )  ;", "return ;", "}    catch    ( Exception   e )     {", "LOG . error ( e . getMessage (  )  )  ;", "}    finally    {", "client . stop (  )  ;", "}", "}", "fail (  \" Client   couldn ' t   connect   to   the   Active   RM \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyClientConnection"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" NMs   failed   to   connect   to   the   RM \"  ,    cluster . waitForNodeManagersToConnect (  2  0  0  0  0  )  )  ;", "verifyCConnection (  )  ;", "}", "METHOD_END"], "methodName": ["verifyConnections"], "fileName": "org.apache.hadoop.yarn.client.ProtocolHATestBase"}, {"methodBody": ["METHOD_START", "{", "startHACluster (  1  ,    true ,    false ,    false )  ;", "Configuration   conf    =    new   onf . YarnConfiguration ( this . conf )  ;", "client    =    createAndStartYarnClient ( conf )  ;", "}", "METHOD_END"], "methodName": ["initiate"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "if    (  (     !  =    null )     {", "stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["shutDown"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "CancelDelegationTokenRequest   request    =    CancelDelegationTokenRequest . newInstance ( cluster . createFakeToken (  )  )  ;", "ClientRMProxy . createRMProxy ( this . conf ,     . class )  . cancelDelegationToken ( request )  ;", "}", "METHOD_END"], "methodName": ["testCancelDelegationTokenOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "client . killApplication ( cluster . createFakeAppId (  )  )  ;", "}", "METHOD_END"], "methodName": ["testForceKillApplicationOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "ApplicationAttemptReport   report    =    client . getApplicationAttemptReport ( cluster . createFakeApplicationAttemptId (  )  )  ;", "Assert . assertTrue (  ( report    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeApplicationAttemptReport (  )  ,    report )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttemptReportOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "List < ApplicationAttemptReport >    reports    =    client . getApplicationAttempts ( cluster . createFakeAppId (  )  )  ;", "Assert . assertTrue (  (  ( reports    !  =    null )     &  &     (  !  ( reports . isEmpty (  )  )  )  )  )  ;", "Assert . assertEquals ( cluster . createFakeApplicationAttemptReports (  )  ,    reports )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttemptsOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "ApplicationReport   report    =    client . getApplicationReport ( cluster . createFakeAppId (  )  )  ;", "Assert . assertTrue (  ( report    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeAppReport (  )  ,    report )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationReportOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "List < ApplicationReport >    reports    =    client . getApplications (  )  ;", "Assert . assertTrue (  (  ( reports    !  =    null )     &  &     (  !  ( reports . isEmpty (  )  )  )  )  )  ;", "Assert . assertEquals ( cluster . createFakeAppReports (  )  ,    reports )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationsOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "YarnClusterMetrics   clusterMetrics    =    client . getYarnClusterMetrics (  )  ;", "Assert . assertTrue (  ( clusterMetrics    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeYarnClusterMetrics (  )  ,    clusterMetrics )  ;", "}", "METHOD_END"], "methodName": ["testGetClusterMetricsOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "List < NodeReport >    reports    =    client . getNodeReports ( RUNNING )  ;", "Assert . assertTrue (  (  ( reports    !  =    null )     &  &     (  !  ( reports . isEmpty (  )  )  )  )  )  ;", "Assert . assertEquals ( cluster . createFakeNodeReports (  )  ,    reports )  ;", "}", "METHOD_END"], "methodName": ["testGetClusterNodesOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "ContainerReport   report    =    client . getContainerReport ( cluster . createFakeContainerId (  )  )  ;", "Assert . assertTrue (  ( report    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeContainerReport (  )  ,    report )  ;", "}", "METHOD_END"], "methodName": ["testGetContainerReportOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "List < ContainerReport >    reports    =    client . getContainers ( cluster . createFakeApplicationAttemptId (  )  )  ;", "Assert . assertTrue (  (  ( reports    !  =    null )     &  &     (  !  ( reports . isEmpty (  )  )  )  )  )  ;", "Assert . assertEquals ( cluster . createFakeContainerReports (  )  ,    reports )  ;", "}", "METHOD_END"], "methodName": ["testGetContainersOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "Token   token    =    client . getRMDelegationToken ( new   Text (  \"     \"  )  )  ;", "Assert . assertEquals ( token ,    cluster . createFakeToken (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetDelegationTokenOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "ApplicationId   appId    =    client . createApplication (  )  . getApplicationSubmissionContext (  )  . getApplicationId (  )  ;", "Assert . assertTrue (  ( appId    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeAppId (  )  ,    appId )  ;", "}", "METHOD_END"], "methodName": ["testGetNewApplicationOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "QueueInfo   queueInfo    =    client . getQueueInfo (  \" root \"  )  ;", "Assert . assertTrue (  ( queueInfo    !  =    null )  )  ;", "Assert . assertEquals ( cluster . createFakeQueueInfo (  )  ,    queueInfo )  ;", "}", "METHOD_END"], "methodName": ["testGetQueueInfoOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "List < QueueUserACLInfo >    queueUserAclsList    =    client . getQueueAclsInfo (  )  ;", "Assert . assertTrue (  (  ( queueUserAclsList    !  =    null )     &  &     (  !  ( queueUserAclsList . isEmpty (  )  )  )  )  )  ;", "Assert . assertEquals ( cluster . createFakeQueueUserACLInfoList (  )  ,    queueUserAclsList )  ;", "}", "METHOD_END"], "methodName": ["testGetQueueUserAclsOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "client . moveApplicationAcrossQueues ( cluster . createFakeAppId (  )  ,     \" root \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoveApplicationAcrossQueuesOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "RenewDelegationTokenRequest   request    =    RenewDelegationTokenRequest . newInstance ( cluster . createFakeToken (  )  )  ;", "long   newExpirationTime    =    ClientRMProxy . createRMProxy ( this . conf ,     . class )  . renewDelegationToken ( request )  . getNextExpirationTime (  )  ;", "Assert . assertEquals ( newExpirationTime ,    cluster . createNextExpirationTime (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenewDelegationTokenOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "ApplicationSubmissionContext   appContext    =    Records . newRecord ( ApplicationSubmissionContext . class )  ;", "appContext . seId ( cluster . createFakeAppId (  )  )  ;", "ContainerLaunchContext   amContainer    =    Records . newRecord ( ContainerLaunchContext . class )  ;", "appContext . setAMContainerSpec ( amContainer )  ;", "Resource   capability    =    Records . newRecord ( Resource . class )  ;", "capability . setMemory (  1  0  )  ;", "capability . setVirtualCores (  1  )  ;", "appContext . setResource ( capability )  ;", "ApplicationId   appId    =    client . submi ( appContext )  ;", "Assert . assertTrue ( getActiveRM (  )  . getRMContext (  )  . getRMApps (  )  . containsKey ( appId )  )  ;", "}", "METHOD_END"], "methodName": ["testSubmitApplicationOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationClientProtocolOnHA"}, {"methodBody": ["METHOD_START", "{", "startHACluster (  0  ,    false ,    false ,    true )  ;", "attemptId    =    this . cluster . createFakeApplicationAttemptId (  )  ;", "amClient    =    ClientRMProxy . createRMProxy ( this . conf ,    Protocol . class )  ;", "Token < AMRMTokenIdentifier >    appToken    =    this . cluster . getResourceManager (  )  . getRMContext (  )  . getAMRMTokenSecretManager (  )  . createAndGetAMRMToken ( attemptId )  ;", "appToken . setService ( new   Text (  \" appToken   service \"  )  )  ;", "UserGroupInformation . setLoginUser ( UserGroupInformation . createRemoteUser ( UserGroupInformation . getCurrentUser (  )  . getUserName (  )  )  )  ;", "UserGroupInformation . getCurrentUser (  )  . addToken ( appToken )  ;", "syncToken ( appToken )  ;", "}", "METHOD_END"], "methodName": ["initiate"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationMasterServiceOnHA"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . amClient )     !  =    null )     {", "RPC . stopProxy ( this . amClient )  ;", "}", "}", "METHOD_END"], "methodName": ["shutDown"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationMasterServiceOnHA"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( this . cluster . getNumOfResourceManager (  )  )  ;    i +  +  )     {", "this . cluster . getResourceManager ( i )  . getRMContext (  )  . getAMRMTokenSecretManager (  )  . addPersistedPassword ( token )  ;", "}", "}", "METHOD_END"], "methodName": ["syncToken"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationMasterServiceOnHA"}, {"methodBody": ["METHOD_START", "{", "AllocateRequest   request    =    AllocateRequest . newInstance (  0  ,     5  0  .  0 F ,    new   ArrayList < ResourceRequest >  (  )  ,    new   ArrayList < ContainerId >  (  )  ,    ResourceBlacklistRequest . newInstance ( new   ArrayList < String >  (  )  ,    new   ArrayList < String >  (  )  )  )  ;", "AllocateResponse   response    =    amClient . allocate ( request )  ;", "Assert . assertEquals ( response ,    this . cluster . createFakeAllocateResponse (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAllocateOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestApplicationMasterServiceOnHA"}, {"methodBody": ["METHOD_START", "{", "super . conf    =    this . conf ;", "}", "METHOD_END"], "methodName": ["setUpConf"], "fileName": "org.apache.hadoop.yarn.client.TestGetGroups"}, {"methodBody": ["METHOD_START", "{", "TestGetGroups . conf    =    new   YarnConfiguration (  )  ;", "TestGetGroups . resourceManager    =    new   ResourceManager (  )     {", "@ Override", "protected   void   doSecureLogin (  )    throws   IOException    {", "}", "}  ;", "TestGetGroups . resourceManager . init ( TestGetGroups . conf )  ;", "new   Thread (  )     {", "public   void   run (  )     {", "TestGetGroups . resourceManager . start (  )  ;", "}", "}  . start (  )  ;", "int   waitCount    =     0  ;", "while    (  (  ( TestGetGroups . resourceManager . getServiceState (  )  )     =  =     ( STATE . INITED )  )     &  &     (  ( waitCount +  +  )     <     1  0  )  )     {", "TestGetGroups . LOG . info (  \" Waiting   for   RM   to   start .  .  .  \"  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "}", "if    (  ( TestGetGroups . resourceManager . getServiceState (  )  )     !  =     ( STATE . STARTED )  )     {", "throw   new   IOException (  (  \" ResourceManager   failed   to   start .    Final   state   is    \"     +     ( TestGetGroups . resourceManager . getServiceState (  )  )  )  )  ;", "}", "TestGetGroups . LOG . info (  (  \" ResourceManager   RMAdmin   address :     \"     +     ( TestGetGroups . conf . get ( RM _ ADMIN _ ADDRESS )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setUpResourceManager"], "fileName": "org.apache.hadoop.yarn.client.TestGetGroups"}, {"methodBody": ["METHOD_START", "{", "if    (  ( TestGetGroups . resourceManager )     !  =    null )     {", "TestGetGroups . LOG . info (  \" Stopping   ResourceManager .  .  .  \"  )  ;", "TestGetGroups . resourceManager . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDownResourceManager"], "fileName": "org.apache.hadoop.yarn.client.TestGetGroups"}, {"methodBody": ["METHOD_START", "{", "admin    =    mock ( ResourceManagerAdministrationProtocol . class )  ;", "haadmin    =    mock ( HAServiceProtocol . class )  ;", "when ( haadmin . getServiceStatus (  )  )  . thenReturn ( new   ha . HAServiceStatus ( HAServiceState . INITIALIZING )  )  ;", "final   HAServiceTarget   haServiceTarget    =    mock ( HAServiceTarget . class )  ;", "when ( haServiceTarget . getProxy ( any ( Configuration . class )  ,    anyInt (  )  )  )  . thenReturn ( haadmin )  ;", "rmAdminCLI    =    new   RMAdminCLI ( new   Configuration (  )  )     {", "@ Override", "protected   ResourceManagerAdministrationProtocol   createAdminProtocol (  )    throws   IOException    {", "return   admin ;", "}", "@ Override", "protected   HAServiceTarget   resolveTarget ( String   rmId )     {", "return   haServiceTarget ;", "}", "}  ;", "YarnConfiguration   conf    =    new   YarnConfiguration (  )  ;", "conf . setBoolean ( RM _ HA _ ENABLED ,    true )  ;", "rmAdminCLIWithHAEnabled    =    new   RMAdminCLI ( conf )     {", "@ Override", "protected   ResourceManagerAdministrationProtocol   createAdminProtocol (  )    throws   IOException    {", "return   admin ;", "}", "@ Override", "protected   HAServiceTarget   resolveTarget ( String   rmId )     {", "return   haServiceTarget ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["configure"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - checkHealth \"  ,     \" rm 1  \"     }  ;", "assertEquals (  (  -  1  )  ,    rm . run ( args )  )  ;", "verify ( haadmin ,    never (  )  )  . monitorHealth (  )  ;", "assertEquals (  0  ,    rmWithHAEnabled . run ( args )  )  ;", "verify ( haadmin )  . monitorHealth (  )  ;", "}", "METHOD_END"], "methodName": ["testCheckHealth"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( resultCode ,    rmAdminCLI . run ( args )  )  ;", "assertTrue ( data . toString (  )  . contains ( template )  )  ;", "data . reset (  )  ;", "}", "METHOD_END"], "methodName": ["testError"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "PrintStream   oldErrPrintStream    =    System . err ;", "ByteArrayOutputStream   dataErr    =    new   ByteArrayOutputStream (  )  ;", "System . setErr ( new   PrintStream ( dataErr )  )  ;", "try    {", "when ( admin . refreshQueues ( any ( RefreshQueuesRequest . class )  )  )  . thenThrow ( new   IOException (  \" test   exception \"  )  )  ;", "String [  ]    args    =    new   String [  ]  {     \"  - refreshQueues \"     }  ;", "assertEquals (  (  -  1  )  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshQueues ( any ( RefreshQueuesRequest . class )  )  ;", "assertTrue ( dataErr . toString (  )  . contains (  \" refreshQueues :    test   exception \"  )  )  ;", "}    finally    {", "System . setErr ( oldErrPrintStream )  ;", "}", "}", "METHOD_END"], "methodName": ["testException"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "when ( admin . getGroupsForUser ( eq (  \" admin \"  )  )  )  . thenReturn ( new   String [  ]  {     \" group 1  \"  ,     \" group 2  \"     }  )  ;", "PrintStream   origOut    =    System . out ;", "PrintStream   out    =    mock ( PrintStream . class )  ;", "System . setOut ( out )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  - getGroups \"  ,     \" admin \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . getGroupsForUser ( eq (  \" admin \"  )  )  ;", "verify ( out )  . println ( argThat ( new   ArgumentMatcher < StringBuilder >  (  )     {", "@ Override", "public   boolean   matches ( Object   argument )     {", "return    (  \"  \"     +    argument )  . equals (  \" admin    :    group 1    group 2  \"  )  ;", "}", "}  )  )  ;", "}    finally    {", "System . setOut ( origOut )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetGroups"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - getServiceState \"  ,     \" rm 1  \"     }  ;", "assertEquals (  (  -  1  )  ,    rm . run ( args )  )  ;", "verify ( haadmin ,    never (  )  )  . getServiceStatus (  )  ;", "assertEquals (  0  ,    rmWithHAEnabled . run ( args )  )  ;", "verify ( haadmin )  . getServiceStatus (  )  ;", "}", "METHOD_END"], "methodName": ["testGetServiceState"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "PrintStream   oldOutPrintStream    =    System . out ;", "PrintStream   oldErrPrintStream    =    System . err ;", "ByteArrayOutputStream   dataOut    =    new   ByteArrayOutputStream (  )  ;", "ByteArrayOutputStream   dataErr    =    new   ByteArrayOutputStream (  )  ;", "System . setOut ( new   PrintStream ( dataOut )  )  ;", "System . setErr ( new   PrintStream ( dataErr )  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  - help \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "oldOutPrintStream . println ( dataOut )  ;", "assertTrue ( dataOut . toString (  )  . contains (  \" rmadmin   is   the   command   to   execute   YARN   administrative   commands .  \"  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \" yarn   rmadmin    [  - refreshQueues ]     [  - refreshNodes ]     [  - refreshSuper \"     +     (  (  \" UserGroupsConfiguration ]     [  - refreshUserToGroupsMappings ]     \"     +     \"  [  - refreshAdminAcls ]     [  - refreshServiceAcl ]     [  - getGroup \"  )     +     \"     [ username ]  ]     [  - help    [ cmd ]  ]  \"  )  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - refreshQueues :    Reload   the   queues '    acls ,    states   and   scheduler    \"     +     \" specific   properties .  \"  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - refreshNodes :    Refresh   the   hosts   information   at   the    \"     +     \" ResourceManager .  \"  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  \"  - refreshUserToGroupsMappings :    Refresh   user - to - groups   mappings \"  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - refreshSuperUserGroupsConfiguration :    Refresh   superuser   proxy \"     +     \"    groups   mappings \"  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - refreshAdminAcls :    Refresh   acls   for   administration   of    \"     +     \" ResourceManager \"  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - refreshServiceAcl :    Reload   the   service - level   authorization \"     +     \"    policy   file \"  )  )  )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \"  - help    [ cmd ]  :    Displays   help   for   the   given   command   or   all    \"     +     \" commands   if   none \"  )  )  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshQueues \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshQueues ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshNodes \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshNodes ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshUserToGroupsMappings \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshUserToGroupsMappings ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshSuperUserGroupsConfiguration \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshSuperUserGroupsConfiguration ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshAdminAcls \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshAdminAcls ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - refreshServiceAcl \"     }  ,     \" Usage :    yarn   rmadmin    [  - refreshServiceAcl ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - getGroups \"     }  ,     \" Usage :    yarn   rmadmin    [  - getGroups    [ username ]  ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - transitionToActive \"     }  ,     (  \" Usage :    yarn   rmadmin    [  - transitionToActive    < serviceId >  \"     +     \"     [  -  - forceactive ]  ]  \"  )  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - transitionToStandby \"     }  ,     \" Usage :    yarn   rmadmin    [  - transitionToStandby    < serviceId >  ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - getServiceState \"     }  ,     \" Usage :    yarn   rmadmin    [  - getServiceState    < serviceId >  ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - checkHealth \"     }  ,     \" Usage :    yarn   rmadmin    [  - checkHealth    < serviceId >  ]  \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - failover \"     }  ,     (  \" Usage :    yarn   rmadmin    \"     +     (  \"  [  - failover    [  -  - forcefence ]     [  -  - forceactive ]     \"     +     \"  < serviceId >     < serviceId >  ]  \"  )  )  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - help \"  ,     \"  - badParameter \"     }  ,     \" Usage :    yarn   rmadmin \"  ,    dataErr ,     0  )  ;", "testError ( new   String [  ]  {     \"  - badParameter \"     }  ,     \" badParameter :    Unknown   command \"  ,    dataErr ,     (  -  1  )  )  ;", "assertEquals (  0  ,    rmWithHAEnabled . run ( args )  )  ;", "oldOutPrintStream . println ( dataOut )  ;", "assertTrue ( dataOut . toString (  )  . contains (  (  \" yarn   rmadmin    [  - refreshQueues ]     [  - refreshNodes ]     [  - refreshSuper \"     +     (  (  (  (  (  \" UserGroupsConfiguration ]     [  - refreshUserToGroupsMappings ]     \"     +     \"  [  - refreshAdminAcls ]     [  - refreshServiceAcl ]     [  - getGroup \"  )     +     \"     [ username ]  ]     [  - help    [ cmd ]  ]     [  - transitionToActive    < serviceId >  \"  )     +     \"     [  -  - forceactive ]  ]     [  - transitionToStandby    < serviceId >  ]     [  - failover \"  )     +     \"     [  -  - forcefence ]     [  -  - forceactive ]     < serviceId >     < serviceId >  ]     \"  )     +     \"  [  - getServiceState    < serviceId >  ]     [  - checkHealth    < serviceId >  ]  \"  )  )  )  )  ;", "}    finally    {", "System . setOut ( oldOutPrintStream )  ;", "System . setErr ( oldErrPrintStream )  ;", "}", "}", "METHOD_END"], "methodName": ["testHelp"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshAdminAcls \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshAdminAcls ( any ( RefreshAdminAclsRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshAdminAcls"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshNodes \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshNodes ( any ( RefreshNodesRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshNodes"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshQueues \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshQueues ( any ( RefreshQueuesRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshQueues"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshServiceAcl \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshServiceAcls ( any ( RefreshServiceAclsRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshServiceAcl"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshSuperUserGroupsConfiguration \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshSuperUserGroupsConfiguration ( any ( RefreshSuperUserGroupsConfigurationRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshSuperUserGroupsConfiguration"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - refreshUserToGroupsMappings \"     }  ;", "assertEquals (  0  ,    rm . run ( args )  )  ;", "verify ( admin )  . refreshUserToGroupsMappings ( any ( RefreshUserToGroupsMappingsRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testRefreshUserToGroupsMappings"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - transitionToActive \"  ,     \" rm 1  \"     }  ;", "assertEquals (  (  -  1  )  ,    rm . run ( args )  )  ;", "verify ( haadmin ,    never (  )  )  . transitionToActive ( any ( StateChangeRequestInfo . class )  )  ;", "assertEquals (  0  ,    rmWithHAEnabled . run ( args )  )  ;", "verify ( haadmin )  . transitionToActive ( any ( StateChangeRequestInfo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testTransitionToActive"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  - transitionToStandby \"  ,     \" rm 1  \"     }  ;", "assertEquals (  (  -  1  )  ,    rm . run ( args )  )  ;", "verify ( haadmin ,    never (  )  )  . transitionToStandby ( any ( StateChangeRequestInfo . class )  )  ;", "assertEquals (  0  ,    rmWithHAEnabled . run ( args )  )  ;", "verify ( haadmin )  . transitionToStandby ( any ( StateChangeRequestInfo . class )  )  ;", "}", "METHOD_END"], "methodName": ["testTransitionToStandby"], "fileName": "org.apache.hadoop.yarn.client.TestRMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "int   activeRMIndex    =    cluster . getActiveRMIndex (  )  ;", "int   newActiveRMIndex    =     ( activeRMIndex    +     1  )     %     2  ;", "getAdminService ( activeRMIndex )  . transitionToStandby (  . req )  ;", "getAdminService ( newActiveRMIndex )  . transitionToActive (  . req )  ;", "assertEquals (  \" Failover   failed \"  ,    newActiveRMIndex ,    cluster . getActiveRMIndex (  )  )  ;", "}", "METHOD_END"], "methodName": ["explicitFailover"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "int   activeRMIndex    =    cluster . getActiveRMIndex (  )  ;", "cluster . stopResourceManager ( activeRMIndex )  ;", "assertEquals (  \"    failed \"  ,     (  ( activeRMIndex    +     1  )     %     2  )  ,    cluster . getActiveRMIndex (  )  )  ;", "cluster . restartResourceManager ( activeRMIndex )  ;", "}", "METHOD_END"], "methodName": ["failover"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "return   cluster . getResourceManager ( index )  . getRMContext (  )  . getRMAdminService (  )  ;", "}", "METHOD_END"], "methodName": ["getAdminService"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "String   fieldHeader    =    null ;", "try    {", "Map < String ,    List < String >  >    map    =    new   URL ( url )  . openConnection (  )  . getHeaderFields (  )  ;", "fieldHeader    =    map . get ( field )  . get (  0  )  ;", "}    catch    ( Exception   e )     {", "}", "return   fieldHeader ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "conf . set ( HAUtil . addSuffix ( prefix ,    rmId )  ,    value )  ;", "}", "METHOD_END"], "methodName": ["setConfForRM"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "setConfForRM ( rmId ,    RM _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ SCHEDULER _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ SCHEDULER _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ ADMIN _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ ADMIN _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ RESOURCE _ TRACKER _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ RESOURCE _ TRACKER _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ WEBAPP _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ WEBAPP _ PORT )  )  )  )  ;", "setConfForRM ( rmId ,    RM _ WEBAPP _ HTTPS _ ADDRESS ,     (  \"  0  .  0  .  0  .  0  :  \"     +     ( base    +     ( YarnConfiguration . DEFAULT _ RM _ WEBAPP _ HTTPS _ PORT )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setRpcAddressForRM"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "fakeAppId    =    ApplicationId . newInstance ( System . currentTimeMillis (  )  ,     0  )  ;", "conf    =    new   YarnConfiguration (  )  ;", "conf . setBoolean ( RM _ HA _ ENABLED ,    true )  ;", "conf . set ( RM _ HA _ IDS ,     (  (  (  . RM 1  _ NODE _ ID )     +     \"  ,  \"  )     +     (  . RM 2  _ NODE _ ID )  )  )  ;", "setRpcAddressForRM (  . RM 1  _ NODE _ ID ,     . RM 1  _ PORT _ BASE )  ;", "setRpcAddressForRM (  . RM 2  _ NODE _ ID ,     . RM 2  _ PORT _ BASE )  ;", "conf . setLong ( CLIENT _ FAILOVER _ SLEEPTIME _ BASE _ MS ,     1  0  0 L )  ;", "conf . setBoolean ( YARN _ MINICLUSTER _ FIXED _ PORTS ,    true )  ;", "conf . setBoolean ( YARN _ MINICLUSTER _ USE _ RPC ,    true )  ;", "cluster    =    new   MiniYARNCluster (  . class . getName (  )  ,     2  ,     1  ,     1  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "cluster . stop (  )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "conf . set ( RM _ CLUSTER _ ID ,     \" yarn - test - cluster \"  )  ;", "conf . set ( RM _ ZK _ ADDRESS ,    hostPort )  ;", "conf . setInt ( RM _ ZK _ TIMEOUT _ MS ,     2  0  0  0  )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "assertFalse (  \" RM   never   turned   active \"  ,     (  (  -  1  )     =  =     ( cluster . getActiveRMIndex (  )  )  )  )  ;", "verifyConnections (  )  ;", "f (  )  ;", "verifyConnections (  )  ;", "f (  )  ;", "verifyConnections (  )  ;", "ResourceManager   rm    =    cluster . getResourceManager ( cluster . getActiveRMIndex (  )  )  ;", "RMFatalEvent   event    =    new   RMFatalEvent ( RMFatalEventType . STATE _ STORE _ FENCED ,     \" Fake   RMFatalEvent \"  )  ;", "rm . getRMContext (  )  . getDispatcher (  )  . getEventHandler (  )  . handle ( event )  ;", "int   maxWaitingAttempts    =     2  0  0  0  ;", "while    (  ( maxWaitingAttempts -  -  )     >     0  )     {", "if    (  ( rm . getRMContext (  )  . getHAServiceState (  )  )     =  =     ( HAServiceState . STANDBY )  )     {", "break ;", "}", "Thread . sleep (  1  )  ;", "}", "Assert . assertFalse (  \" RM   didn ' t   transition   to   Standby    \"  ,     ( maxWaitingAttempts    =  =     0  )  )  ;", "verifyConnections (  )  ;", "}", "METHOD_END"], "methodName": ["testAutomaticFailover"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "conf . setBoolean ( AUTO _ FAILOVER _ ENABLED ,    false )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "getAdminService (  0  )  . transitionToActive (  . req )  ;", "assertFalse (  \" RM   never   turned   active \"  ,     (  (  -  1  )     =  =     ( cluster . getActiveRMIndex (  )  )  )  )  ;", "verifyConnections (  )  ;", "URL   wrongUrl    =    new   URL (  (  \" http :  /  /  0  .  0  .  0  .  0  :  1  8  0  8  8  / proxy /  \"     +     ( fakeAppId )  )  )  ;", "HttpURLConnection   proxyConn    =     (  ( HttpURLConnection )     ( wrongUrl . openConnection (  )  )  )  ;", "proxyConn . connect (  )  ;", "verifyResponse ( proxyConn )  ;", "explicitFailover (  )  ;", "verifyConnections (  )  ;", "proxyConn . connect (  )  ;", "verifyResponse ( proxyConn )  ;", "}", "METHOD_END"], "methodName": ["testEmbeddedWebAppProxy"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "conf . setBoolean ( AUTO _ FAILOVER _ ENABLED ,    false )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "getAdminService (  0  )  . transitionToActive (  . req )  ;", "assertFalse (  \" RM   never   turned   active \"  ,     (  (  -  1  )     =  =     ( cluster . getActiveRMIndex (  )  )  )  )  ;", "verifyConnections (  )  ;", "explicitFailover (  )  ;", "verifyConnections (  )  ;", "explicitFailover (  )  ;", "verifyConnections (  )  ;", "}", "METHOD_END"], "methodName": ["testExplicitFailover"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "cluster    =    new   MiniYARNCluster ( TestRMFailover . class . getName (  )  ,     2  ,     0  ,     1  ,     1  )  ;", "conf . setBoolean ( AUTO _ FAILOVER _ ENABLED ,    false )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "getAdminService (  0  )  . transitionToActive ( TestRMFailover . req )  ;", "String   rm 1 Url    =     \" http :  /  /  0  .  0  .  0  .  0  :  1  8  0  8  8  \"  ;", "String   rm 2 Url    =     \" http :  /  /  0  .  0  .  0  .  0  :  2  8  0  8  8  \"  ;", "String   header    =    TestRMFailover . getHeader (  \" Refresh \"  ,    rm 2 Url )  ;", "assertTrue ( header . contains (  (  \"  ;    url =  \"     +    rm 1 Url )  )  )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / metrics \"  )  )  ;", "assertTrue ( header . contains (  (  \"  ;    url =  \"     +    rm 1 Url )  )  )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / jmx \"  )  )  ;", "assertTrue ( header . contains (  (  \"  ;    url =  \"     +    rm 1 Url )  )  )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / cluster / cluster \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / conf \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / stacks \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / logLevel \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / static \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / logs \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / ws / v 1  / cluster / info \"  )  )  ;", "assertEquals ( null ,    header )  ;", "header    =    TestRMFailover . getHeader (  \" Refresh \"  ,     ( rm 2 Url    +     \"  / ws / v 1  / cluster / apps \"  )  )  ;", "assertTrue ( header . contains (  (  \"  ;    url =  \"     +    rm 1 Url )  )  )  ;", "}", "METHOD_END"], "methodName": ["testRMWebAppRedirect"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "conf . setBoolean ( AUTO _ FAILOVER _ ENABLED ,    false )  ;", "WebAppProxyServer   webAppProxyServer    =    new   WebAppProxyServer (  )  ;", "try    {", "conf . set ( PROXY _ ADDRESS ,     \"  0  .  0  .  0  .  0  :  9  0  9  9  \"  )  ;", "cluster . init ( conf )  ;", "cluster . start (  )  ;", "getAdminService (  0  )  . transitionToActive (  . req )  ;", "assertFalse (  \" RM   never   turned   active \"  ,     (  (  -  1  )     =  =     ( cluster . getActiveRMIndex (  )  )  )  )  ;", "verifyConnections (  )  ;", "webAppProxyServer . init ( conf )  ;", "Assert . assertEquals ( INITED ,    webAppProxyServer . getServiceState (  )  )  ;", "webAppProxyServer . start (  )  ;", "Assert . assertEquals ( STARTED ,    webAppProxyServer . getServiceState (  )  )  ;", "URL   wrongUrl    =    new   URL (  (  \" http :  /  /  0  .  0  .  0  .  0  :  9  0  9  9  / proxy /  \"     +     ( fakeAppId )  )  )  ;", "HttpURLConnection   proxyConn    =     (  ( HttpURLConnection )     ( wrongUrl . openConnection (  )  )  )  ;", "proxyConn . connect (  )  ;", "verifyResponse ( proxyConn )  ;", "explicitFailover (  )  ;", "verifyConnections (  )  ;", "proxyConn . connect (  )  ;", "verifyResponse ( proxyConn )  ;", "}    finally    {", "webAppProxyServer . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWebAppProxyInStandAloneMode"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "int   numRetries    =     3  ;", "while    (  ( numRetries -  -  )     >     0  )     {", "Configuration   conf    =    new   onf . YarnConfiguration ( this . conf )  ;", "YarnClient   client    =    YarnClient . createYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "try    {", "client . getApplications (  )  ;", "return ;", "}    catch    ( Exception   e )     {", "TestRMFailover . LOG . error ( e )  ;", "}    finally    {", "client . stop (  )  ;", "}", "}", "fail (  \" Client   couldn ' t   connect   to   the   Active   RM \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyClientConnection"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" NMs   failed   to   connect   to   the   RM \"  ,    cluster . waitForNodeManagersToConnect (  2  0  0  0  0  )  )  ;", "verifyCConnection (  )  ;", "}", "METHOD_END"], "methodName": ["verifyConnections"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" Not   Found \"  ,    response . getResponseMessage (  )  )  ;", "assertEquals (  4  0  4  ,    response . getResponseCode (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyResponse"], "fileName": "org.apache.hadoop.yarn.client.TestRMFailover"}, {"methodBody": ["METHOD_START", "{", "return   conf . getSocketAddr ( RM _ ADMIN _ ADDRESS ,    DEFAULT _ RM _ ADMIN _ ADDRESS ,    DEFAULT _ RM _ ADMIN _ PORT )  ;", "}", "METHOD_END"], "methodName": ["getProtocolAddress"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "Configuration . addDefaultResource (  \" config - with - security . xml \"  )  ;", "Configuration   configuration    =    new   YarnConfiguration (  )  ;", ". resourceManager    =    new   ResourceManager (  )     {", "@ Override", "protected   void   doSecureLogin (  )    throws   IOException    {", "}", "}  ;", ". resourceManager . init ( configuration )  ;", "new   Thread (  )     {", "public   void   run (  )     {", ". resourceManager . start (  )  ;", "}", "}  . start (  )  ;", "int   waitCount    =     0  ;", "while    (  (  (  . resourceManager . getServiceState (  )  )     =  =     ( STATE . INITED )  )     &  &     (  ( waitCount +  +  )     <     1  0  )  )     {", ". LOG . info (  \" Waiting   for   RM   to   start .  .  .  \"  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "}", "if    (  (  . resourceManager . getServiceState (  )  )     !  =     ( STATE . STARTED )  )     {", "throw   new   IOException (  (  \" ResourceManager   failed   to   start .    Final   state   is    \"     +     (  . resourceManager . getServiceState (  )  )  )  )  ;", "}", ". LOG . info (  (  \" ResourceManager   RMAdmin   address :     \"     +     ( configuration . get ( RM _ ADMIN _ ADDRESS )  )  )  )  ;", ". client    =    new   ResourceManagerAdministrationProtocolPBClientImpl (  1 L ,     . getProtocolAddress ( configuration )  ,    configuration )  ;", "}", "METHOD_END"], "methodName": ["setUpResourceManager"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( TestResourceManagerAdministrationProtocolPBClientImpl . resourceManager )     !  =    null )     {", "TestResourceManagerAdministrationProtocolPBClientImpl . LOG . info (  \" Stopping   ResourceManager .  .  .  \"  )  ;", "TestResourceManagerAdministrationProtocolPBClientImpl . resourceManager . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDownResourceManager"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "RefreshAdminAclsRequest   request    =    recordFactory . newRecordInstance ( RefreshAdminAclsRequest . class )  ;", "RefreshAdminAclsResponse   response    =     . client . refreshAdminAcls ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshAdminAcls"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "TestResourceManagerAdministrationProtocolPBClientImpl . resourceManager . getClientRMService (  )  ;", "RefreshNodesRequest   request    =    recordFactory . newRecordInstance ( RefreshNodesRequest . class )  ;", "RefreshNodesResponse   response    =    TestResourceManagerAdministrationProtocolPBClientImpl . client . refreshNodes ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshNodes"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "RefreshQueuesRequest   request    =    recordFactory . newRecordInstance ( RefreshQueuesRequest . class )  ;", "RefreshQueuesResponse   response    =     . client . refreshQueues ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshQueues"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "RefreshServiceAclsRequest   request    =    recordFactory . newRecordInstance ( RefreshServiceAclsRequest . class )  ;", "RefreshServiceAclsResponse   response    =     . client . refreshServiceAcls ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshServiceAcls"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "RefreshSuperUserGroupsConfigurationRequest   request    =    recordFactory . newRecordInstance ( RefreshSuperUserGroupsConfigurationRequest . class )  ;", "RefreshSuperUserGroupsConfigurationResponse   response    =     . client . refreshSuperUserGroupsConfiguration ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshSuperUserGroupsConfiguration"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "RefreshUserToGroupsMappingsRequest   request    =    recordFactory . newRecordInstance ( RefreshUserToGroupsMappingsRequest . class )  ;", "RefreshUserToGroupsMappingsResponse   response    =     . client . refreshUserToGroupsMappings ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testRefreshUserToGroupsMappings"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "UpdateNodeResourceRequest   request    =    recordFactory . newRecordInstance ( UpdateNodeResourceRequest . class )  ;", "UpdateNodeResourceResponse   response    =     . client . updateNodeResource ( request )  ;", "assertNotNull ( response )  ;", "}", "METHOD_END"], "methodName": ["testUpdateNodeResource"], "fileName": "org.apache.hadoop.yarn.client.TestResourceManagerAdministrationProtocolPBClientImpl"}, {"methodBody": ["METHOD_START", "{", "return   ServerRMProxy . createRMProxy ( this . conf ,    ResourceTracker . class )  ;", "}", "METHOD_END"], "methodName": ["getRMClient"], "fileName": "org.apache.hadoop.yarn.client.TestResourceTrackerOnHA"}, {"methodBody": ["METHOD_START", "{", "startHACluster (  0  ,    false ,    true ,    false )  ;", "this . r    =    getRMClient (  )  ;", "}", "METHOD_END"], "methodName": ["initiate"], "fileName": "org.apache.hadoop.yarn.client.TestResourceTrackerOnHA"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this . resourceTracker )     !  =    null )     {", "RPC . stopProxy ( this . resourceTracker )  ;", "}", "}", "METHOD_END"], "methodName": ["shutDown"], "fileName": "org.apache.hadoop.yarn.client.TestResourceTrackerOnHA"}, {"methodBody": ["METHOD_START", "{", "NodeId   nodeId    =    NodeId . newInstance (  \" localhost \"  ,     0  )  ;", "Resource   resource    =    Resource . newInstance (  2  0  4  8  ,     4  )  ;", "RegisterNodeManagerRequest   request    =    RegisterNodeManagerRequest . newInstance ( nodeId ,     0  ,    resource ,    YarnVersionInfo . getVersion (  )  ,    null ,    null )  ;", "r . registerNodeManager ( request )  ;", "Assert . assertTrue ( waitForNodeManagerToConnect (  1  0  0  0  0  ,    nodeId )  )  ;", "failoverThread    =    createAndStartFailoverThread (  )  ;", "NodeStatus   status    =    NodeStatus . newInstance ( NodeId . newInstance (  \" localhost \"  ,     0  )  ,     0  ,    null ,    null ,    null )  ;", "NodeHeartbeatRequest   request 2     =    NodeHeartbeatRequest . newInstance ( status ,    null ,    null )  ;", "r . nodeHeartbeat ( request 2  )  ;", "}", "METHOD_END"], "methodName": ["testResourceTrackerOnHA"], "fileName": "org.apache.hadoop.yarn.client.TestResourceTrackerOnHA"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( timeout    /     1  0  0  )  ;    i +  +  )     {", "if    ( getActiveRM (  )  . getRMContext (  )  . getRMNodes (  )  . containsKey ( nodeId )  )     {", "return   true ;", "}", "Thread . sleep (  1  0  0  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["waitForNodeManagerToConnect"], "fileName": "org.apache.hadoop.yarn.client.TestResourceTrackerOnHA"}, {"methodBody": ["METHOD_START", "{", "return   Token . newInstance ( new   byte [  0  ]  ,     \"  \"  ,    new   byte [  0  ]  ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["getDelegationToken"], "fileName": "org.apache.hadoop.yarn.client.TestYarnApiClasses"}, {"methodBody": ["METHOD_START", "{", "Token   token    =    getDelegationToken (  )  ;", "CancelDelegationTokenRequestPBImpl   original    =    new   CancelDelegationTokenRequestPBImpl (  )  ;", "original . setDelegationToken ( token )  ;", "CancelDelegationTokenRequestProto   protoType    =    original . getProto (  )  ;", "CancelDelegationTokenRequestPBImpl   copy    =    new   CancelDelegationTokenRequestPBImpl ( protoType )  ;", "rtNotNull ( copy . getDelegationToken (  )  )  ;", "rtEquals ( token ,    copy . getDelegationToken (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCancelDelegationTokenRequestPBImpl"], "fileName": "org.apache.hadoop.yarn.client.TestYarnApiClasses"}, {"methodBody": ["METHOD_START", "{", "Token   token    =    getDelegationToken (  )  ;", "RenewDelegationTokenRequestPBImpl   original    =    new   RenewDelegationTokenRequestPBImpl (  )  ;", "original . setDelegationToken ( token )  ;", "RenewDelegationTokenRequestProto   protoType    =    original . getProto (  )  ;", "RenewDelegationTokenRequestPBImpl   copy    =    new   RenewDelegationTokenRequestPBImpl ( protoType )  ;", "rtNotNull ( copy . getDelegationToken (  )  )  ;", "rtEquals ( token ,    copy . getDelegationToken (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRenewDelegationTokenRequestPBImpl"], "fileName": "org.apache.hadoop.yarn.client.TestYarnApiClasses"}, {"methodBody": ["METHOD_START", "{", "Resource   resource    =    recordFactory . newRecordInstance ( Resource . class )  ;", "Priority   priority    =    recordFactory . newRecordInstance ( Priority . class )  ;", "ResourceRequest   original    =    ResourceRequest . newInstance ( priority ,     \" localhost \"  ,    resource ,     2  )  ;", "ResourceRequest   copy    =    ResourceRequest . newInstance ( priority ,     \" localhost \"  ,    resource ,     2  )  ;", "assertTrue ( original . equals ( copy )  )  ;", "assertEquals (  0  ,    original . compareTo ( copy )  )  ;", "assertTrue (  (  ( original . hashCode (  )  )     =  =     ( copy . hashCode (  )  )  )  )  ;", "copy . setNumContainers (  1  )  ;", "assertFalse ( original . equals ( copy )  )  ;", "assertNotSame (  0  ,    original . compareTo ( copy )  )  ;", "assertFalse (  (  ( original . hashCode (  )  )     =  =     ( copy . hashCode (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testResourceRequest"], "fileName": "org.apache.hadoop.yarn.client.TestYarnApiClasses"}, {"methodBody": ["METHOD_START", "{", "AHSClient   client    =    new   AHSClientImpl (  )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createAHSClient"], "fileName": "org.apache.hadoop.yarn.client.api.AHSClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClient < T >    client    =    new   AMRMClientImpl < T >  (  )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createAMRMClient"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "return   nmTokenCache ;", "}", "METHOD_END"], "methodName": ["getNMTokenCache"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "this . nmTokenCache    =    nmTokenCache ;", "}", "METHOD_END"], "methodName": ["setNMTokenCache"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "waitFor ( check ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "waitFor ( check ,    checkEveryMillis ,     1  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( check ,     \" check   should   not   be   null \"  )  ;", "Preconditions . checkArgument (  ( checkEveryMillis    >  =     0  )  ,     \" checkEveryMillis   should   be   positive   value \"  )  ;", "Preconditions . checkArgument (  ( logInterval    >  =     0  )  ,     \" logInterval   should   be   positive   value \"  )  ;", "int   loggingCounter    =    logInterval ;", "do    {", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  \" Check   the   condition   for   main   loop .  \"  )  ;", "}", "boolean   result    =    check . get (  )  ;", "if    ( result )     {", ". LOG . info (  \" Exits   the   main   loop .  \"  )  ;", "return ;", "}", "if    (  (  -  - loggingCounter )     <  =     0  )     {", ". LOG . info (  \" Waiting   in   main   loop .  \"  )  ;", "loggingCounter    =    logInterval ;", "}", "Thread . sleep ( checkEveryMillis )  ;", "}    while    ( true    )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.AMRMClient"}, {"methodBody": ["METHOD_START", "{", "NMClient   client    =    new   NMClientImpl (  )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createNMClient"], "fileName": "org.apache.hadoop.yarn.client.api.NMClient"}, {"methodBody": ["METHOD_START", "{", "NMClient   client    =    new   NMClientImpl ( name )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createNMClient"], "fileName": "org.apache.hadoop.yarn.client.api.NMClient"}, {"methodBody": ["METHOD_START", "{", "return   nmTokenCache ;", "}", "METHOD_END"], "methodName": ["getNMTokenCache"], "fileName": "org.apache.hadoop.yarn.client.api.NMClient"}, {"methodBody": ["METHOD_START", "{", "this . nmTokenCache    =    nmTokenCache ;", "}", "METHOD_END"], "methodName": ["setNMTokenCache"], "fileName": "org.apache.hadoop.yarn.client.api.NMClient"}, {"methodBody": ["METHOD_START", "{", "nmTokens . clear (  )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "return   nmTokens . containsKey ( nodeAddr )  ;", "}", "METHOD_END"], "methodName": ["containsToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "return   NMTokenCache . NM _ TOKEN _ CACHE . getToken ( nodeAddr )  ;", "}", "METHOD_END"], "methodName": ["getNMToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "return   NMTokenCache . NM _ TOKEN _ CACHE ;", "}", "METHOD_END"], "methodName": ["getSingleton"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "return   nmTokens . get ( nodeAddr )  ;", "}", "METHOD_END"], "methodName": ["getToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "return   nmTokens . size (  )  ;", "}", "METHOD_END"], "methodName": ["numberOfTokensInCache"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "nmTokens . remove ( nodeAddr )  ;", "}", "METHOD_END"], "methodName": ["removeToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "NMTokenCache . NM _ TOKEN _ CACHE . setToken ( nodeAddr ,    token )  ;", "}", "METHOD_END"], "methodName": ["setNMToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "nmTokens . put ( nodeAddr ,    token )  ;", "}", "METHOD_END"], "methodName": ["setToken"], "fileName": "org.apache.hadoop.yarn.client.api.NMTokenCache"}, {"methodBody": ["METHOD_START", "{", "YarnClient   client    =    new   YarnClientImpl (  )  ;", "return   client ;", "}", "METHOD_END"], "methodName": ["createYarnClient"], "fileName": "org.apache.hadoop.yarn.client.api.YarnClient"}, {"methodBody": ["METHOD_START", "{", "return   appSubmissionContext ;", "}", "METHOD_END"], "methodName": ["getApplicationSubmissionContext"], "fileName": "org.apache.hadoop.yarn.client.api.YarnClientApplication"}, {"methodBody": ["METHOD_START", "{", "return   newAppResponse ;", "}", "METHOD_END"], "methodName": ["getNewApplicationResponse"], "fileName": "org.apache.hadoop.yarn.client.api.YarnClientApplication"}, {"methodBody": ["METHOD_START", "{", "return   new   AMRMClientAsyncImpl < T >  ( intervalMs ,    callbackHandler )  ;", "}", "METHOD_END"], "methodName": ["createAMRMClientAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "return   new   AMRMClientAsyncImpl < T >  ( client ,    intervalMs ,    callbackHandler )  ;", "}", "METHOD_END"], "methodName": ["createAMRMClientAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "heartbeatIntervalMs . set ( interval )  ;", "}", "METHOD_END"], "methodName": ["setHeartbeatInterval"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "waitFor ( check ,     1  0  0  0  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "waitFor ( check ,    checkEveryMillis ,     1  )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Preconditions . checkNotNull ( check ,     \" check   should   not   be   null \"  )  ;", "Preconditions . checkArgument (  ( checkEveryMillis    >  =     0  )  ,     \" checkEveryMillis   should   be   positive   value \"  )  ;", "Preconditions . checkArgument (  ( logInterval    >  =     0  )  ,     \" logInterval   should   be   positive   value \"  )  ;", "int   loggingCounter    =    logInterval ;", "do    {", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  \" Check   the   condition   for   main   loop .  \"  )  ;", "}", "boolean   result    =    check . get (  )  ;", "if    ( result )     {", ". LOG . info (  \" Exits   the   main   loop .  \"  )  ;", "return ;", "}", "if    (  (  -  - loggingCounter )     <  =     0  )     {", ". LOG . info (  \" Waiting   in   main   loop .  \"  )  ;", "loggingCounter    =    logInterval ;", "}", "Thread . sleep ( checkEveryMillis )  ;", "}    while    ( true    )  ;", "}", "METHOD_END"], "methodName": ["waitFor"], "fileName": "org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "return   new   NMClientAsyncImpl ( callbackHandler )  ;", "}", "METHOD_END"], "methodName": ["createNMClientAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.NMClientAsync"}, {"methodBody": ["METHOD_START", "{", "return   callbackHandler ;", "}", "METHOD_END"], "methodName": ["getCallbackHandler"], "fileName": "org.apache.hadoop.yarn.client.api.async.NMClientAsync"}, {"methodBody": ["METHOD_START", "{", "return   client ;", "}", "METHOD_END"], "methodName": ["getClient"], "fileName": "org.apache.hadoop.yarn.client.api.async.NMClientAsync"}, {"methodBody": ["METHOD_START", "{", "this . callbackHandler    =    callbackHandler ;", "}", "METHOD_END"], "methodName": ["setCallbackHandler"], "fileName": "org.apache.hadoop.yarn.client.api.async.NMClientAsync"}, {"methodBody": ["METHOD_START", "{", "this . client    =    client ;", "}", "METHOD_END"], "methodName": ["setClient"], "fileName": "org.apache.hadoop.yarn.client.api.async.NMClientAsync"}, {"methodBody": ["METHOD_START", "{", "client . addContainerRequest ( req )  ;", "}", "METHOD_END"], "methodName": ["addContainerRequest"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "return   client . getAvailableResources (  )  ;", "}", "METHOD_END"], "methodName": ["getAvailableResources"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "return   client . getClusterNodeCount (  )  ;", "}", "METHOD_END"], "methodName": ["getClusterNodeCount"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "return   client . getMatchingRequests ( priority ,    resourceName ,    capability )  ;", "}", "METHOD_END"], "methodName": ["getMatchingRequests"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "RegisterApplicationMasterResponse   response    =    client . registerApplicationMaster ( appHostName ,    appHostPort ,    appTrackingUrl )  ;", "heartbeatThread . start (  )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["registerApplicationMaster"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "client . releaseAssignedContainer ( containerId )  ;", "}", "METHOD_END"], "methodName": ["releaseAssignedContainer"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "client . removeContainerRequest ( req )  ;", "}", "METHOD_END"], "methodName": ["removeContainerRequest"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "heartbeatIntervalMs . set ( interval )  ;", "}", "METHOD_END"], "methodName": ["setHeartbeatInterval"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "synchronized ( unregisterHeartbeatLock )     {", "keepRunning    =    false ;", "unregisterApplicationMaster ( appStatus ,    appMessage ,    appTrackingUrl )  ;", "}", "}", "METHOD_END"], "methodName": ["unregisterApplicationMaster"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.AMRMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   NMClientAsyncImpl . ContainerEventProcessor ( event )  ;", "}", "METHOD_END"], "methodName": ["getContainerEventProcessor"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "events . put ( new    . ContainerEvent ( containerId ,    nodeId ,    null ,     . ContainerEventType . QUERY _ CONTAINER )  )  ;", "}    catch    ( InterruptedException   e )     {", ". LOG . warn (  (  (  \" Exception   when   scheduling   the   event   of   querying   the   status \"     +     \"    of   Container    \"  )     +    containerId )  )  ;", "callbackHandler . onGetContainerStatusError ( containerId ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["getContainerStatusAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( container . getState (  )  )     =  =     ( NMClientAsyncImpl . ContainerState . DONE )  )     |  |     (  ( container . getState (  )  )     =  =     ( NMClientAsyncImpl . ContainerState . FAILED )  )  ;", "}", "METHOD_END"], "methodName": ["isCompletelyDone"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( containers . putIfAbsent ( container . getId (  )  ,    new   NMClientAsyncImpl . StatefulContainer ( this ,    container . getId (  )  )  )  )     !  =    null )     {", "callbackHandler . onStartContainerError ( container . getId (  )  ,    RPCUtil . getRemoteException (  (  (  \" Container    \"     +     ( container . getId (  )  )  )     +     \"    is   already   started   or   scheduled   to   start \"  )  )  )  ;", "}", "try    {", "events . put ( new   NMClientAsyncImpl . StartContainerEvent ( container ,    containerLaunchContext )  )  ;", "}    catch    ( InterruptedException   e )     {", "NMClientAsyncImpl . LOG . warn (  (  \" Exception   when   scheduling   the   event   of   starting   Container    \"     +     ( container . getId (  )  )  )  )  ;", "callbackHandler . onStartContainerError ( container . getId (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["startContainerAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( containers . get ( containerId )  )     =  =    null )     {", "callbackHandler . onStopContainerError ( containerId ,    RPCUtil . getRemoteException (  (  (  \" Container    \"     +    containerId )     +     \"    is   neither   started   nor   scheduled   to   start \"  )  )  )  ;", "}", "try    {", "events . put ( new    . ContainerEvent ( containerId ,    nodeId ,    null ,     . ContainerEventType . STOP _ CONTAINER )  )  ;", "}    catch    ( InterruptedException   e )     {", ". LOG . warn (  (  \" Exception   when   scheduling   the   event   of   stopping   Container    \"     +    containerId )  )  ;", "callbackHandler . onStopContainerError ( containerId ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["stopContainerAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl"}, {"methodBody": ["METHOD_START", "{", "AllocateResponse   response    =    AllocateResponse . newInstance (  0  ,    completed ,    allocated ,    new   ArrayList < NodeReport >  (  )  ,    null ,    null ,     1  ,    null ,    nmTokens )  ;", "return   response ;", "}", "METHOD_END"], "methodName": ["createAllocateResponse"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "ApplicationId   applicationId    =    ApplicationId . newInstance ( timestamp ,    appId )  ;", "ApplicationAttemptId   applicationAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,    appAttemptId )  ;", "return   ContainerId . newInstance ( applicationAttemptId ,    containerId )  ;", "}", "METHOD_END"], "methodName": ["newContainerId"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "List < ContainerStatus >    completed    =    Arrays . asList ( ContainerStatus . newInstance ( TestAMRMClientAsync . newContainerId (  0  ,     0  ,     0  ,     0  )  ,    COMPLETE ,     \"  \"  ,     0  )  )  ;", "final   AllocateResponse   response    =    createAllocateResponse ( completed ,    new   ArrayList < api . records . Container >  (  )  ,    null )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( response )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     2  0  ,    callbackHandler )  ;", "callbackHandler . asynClient    =    asyncClient ;", "callbackHandler . throwOutException    =    true ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "synchronized ( callbackHandler . notifier )     {", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "while    (  ( callbackHandler . notify )     =  =    false )     {", "try    {", "callbackHandler . notifier . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "}", "verify ( callbackHandler ,    times (  0  )  )  . getProgress (  )  ;", "verify ( callbackHandler ,    times (  1  )  )  . onError ( any ( Exception . class )  )  ;", "Thread . sleep (  5  0  )  ;", "verify ( callbackHandler ,    times (  0  )  )  . getProgress (  )  ;", "verify ( callbackHandler ,    times (  1  )  )  . onError ( any ( Exception . class )  )  ;", "}", "METHOD_END"], "methodName": ["runCallBackThrowOutException"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", ". TestCallbackHandler   callbackHandler    =    new    . TestCallbackHandler (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenThrow ( ex )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     2  0  ,    callbackHandler )  ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "synchronized ( callbackHandler . notifier )     {", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "while    (  ( callbackHandler . savedException )     =  =    null )     {", "try    {", "callbackHandler . notifier . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "}", "Assert . assertTrue ( callbackHandler . savedException . getMessage (  )  . contains ( ex . getMessage (  )  )  )  ;", "asyncClient . stop (  )  ;", "Assert . assertTrue (  (  ( callbackHandler . callbackCount )     =  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["runHeartBeatThrowOutException"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AtomicBoolean   heartbeatBlock    =    new   AtomicBoolean ( true )  ;", "List < ContainerStatus >    completed 1     =    Arrays . asList ( ContainerStatus . newInstance (  . newContainerId (  0  ,     0  ,     0  ,     0  )  ,    COMPLETE ,     \"  \"  ,     0  )  )  ;", "List < Container >    allocated 1     =    Arrays . asList ( Container . newInstance ( null ,    null ,    null ,    null ,    null ,    null )  )  ;", "final   AllocateResponse   response 1     =    createAllocateResponse ( new   ArrayList < ContainerStatus >  (  )  ,    allocated 1  ,    null )  ;", "final   AllocateResponse   response 2     =    createAllocateResponse ( completed 1  ,    new   ArrayList < Container >  (  )  ,    null )  ;", "final   AllocateResponse   emptyResponse    =    createAllocateResponse ( new   ArrayList < ContainerStatus >  (  )  ,    new   ArrayList < Container >  (  )  ,    null )  ;", ". TestCallbackHandler   callbackHandler    =    new    . TestCallbackHandler (  )  ;", "final   AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "final   AtomicInteger   secondHeartbeatSync    =    new   AtomicInteger (  0  )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( response 1  )  . thenAnswer ( new   Answer < AllocateResponse >  (  )     {", "@ Override", "public   AllocateResponse   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "secondHeartbeatSync . incrementAndGet (  )  ;", "while    ( heartbeatBlock . get (  )  )     {", "synchronized ( heartbeatBlock )     {", "heartbeatBlock . wait (  )  ;", "}", "}", "secondHeartbeatSync . incrementAndGet (  )  ;", "return   response 2  ;", "}", "}  )  . thenReturn ( emptyResponse )  ;", "when ( client . registerApplicationMaster ( anyString (  )  ,    anyInt (  )  ,    anyString (  )  )  )  . thenReturn ( null )  ;", "when ( client . getAvailableResources (  )  )  . thenAnswer ( new   Answer < Resource >  (  )     {", "@ Override", "public   Resource   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "synchronized ( client )     {", "Thread . sleep (  1  0  )  ;", "}", "return   null ;", "}", "}  )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     2  0  ,    callbackHandler )  ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "while    (  ( secondHeartbeatSync . get (  )  )     <     1  )     {", "Thread . sleep (  1  0  )  ;", "}", "assert    ( secondHeartbeatSync . get (  )  )     <     2  ;", "asyncClient . getAvailableResources (  )  ;", "assert    ( secondHeartbeatSync . get (  )  )     <     2  ;", "synchronized ( heartbeatBlock )     {", "heartbeatBlock . set ( false )  ;", "heartbeatBlock . notifyAll (  )  ;", "}", "Assert . assertEquals ( null ,    callbackHandler . takeCompletedContainers (  )  )  ;", "while    (  ( callbackHandler . takeAllocatedContainers (  )  )     =  =    null )     {", "Assert . assertEquals ( null ,    callbackHandler . takeCompletedContainers (  )  )  ;", "Thread . sleep (  1  0  )  ;", "}", "while    (  ( callbackHandler . takeCompletedContainers (  )  )     =  =    null )     {", "Thread . sleep (  1  0  )  ;", "}", "asyncClient . stop (  )  ;", "Assert . assertEquals ( null ,    callbackHandler . takeAllocatedContainers (  )  )  ;", "Assert . assertEquals ( null ,    callbackHandler . takeCompletedContainers (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "String   exStr    =     \" TestException \"  ;", "YarnException   mockException    =    mock ( YarnException . class )  ;", "when ( mockException . getMessage (  )  )  . thenReturn ( exStr )  ;", "runHeartBeatThrowOutException ( mockException )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientAsyncException"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "String   exStr    =     \" TestRunTimeException \"  ;", "RuntimeException   mockRunTimeException    =    mock ( RuntimeException . class )  ;", "when ( mockRunTimeException . getMessage (  )  )  . thenReturn ( exStr )  ;", "runHeartBeatThrowOutException ( mockRunTimeException )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientAsyncRunTimeException"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "TestAMRMClientAsync . TestCallbackHandler   callbackHandler    =    new   TestAMRMClientAsync . TestCallbackHandler (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "final   AllocateResponse   shutDownResponse    =    createAllocateResponse ( new   ArrayList < api . records . ContainerStatus >  (  )  ,    new   ArrayList < api . records . Container >  (  )  ,    null )  ;", "shutDownResponse . setAMCommand ( AM _ SHUTDOWN )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( shutDownResponse )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     1  0  ,    callbackHandler )  ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "Thread . sleep (  5  0  )  ;", "verify ( client ,    times (  1  )  )  . allocate ( anyFloat (  )  )  ;", "asyncClient . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientAsyncShutDown"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   TestAMRMClientAsync . TestCallbackHandler   callbackHandler    =    new   TestAMRMClientAsync . TestCallbackHandler (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "final   AllocateResponse   shutDownResponse    =    createAllocateResponse ( new   ArrayList < api . records . ContainerStatus >  (  )  ,    new   ArrayList < api . records . Container >  (  )  ,    null )  ;", "shutDownResponse . setAMCommand ( AM _ SHUTDOWN )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( shutDownResponse )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     1  0  ,    callbackHandler )  ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "Supplier < Boolean >    checker    =    new   Supplier < Boolean >  (  )     {", "@ Override", "public   Boolean   get (  )     {", "return   callbackHandler . reboot ;", "}", "}  ;", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "asyncClient . waitFor ( checker )  ;", "asyncClient . stop (  )  ;", "Assert . assertTrue (  (  ( callbackHandler . callbackCount )     =  =     0  )  )  ;", "verify ( client ,    times (  1  )  )  . allocate ( anyFloat (  )  )  ;", "asyncClient . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientAsyncShutDownWithWaitFor"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "TestAMRMClientAsync . TestCallbackHandler 2    callbackHandler    =    new   TestAMRMClientAsync . TestCallbackHandler 2  (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "List < ContainerStatus >    completed    =    Arrays . asList ( ContainerStatus . newInstance ( TestAMRMClientAsync . newContainerId (  0  ,     0  ,     0  ,     0  )  ,    COMPLETE ,     \"  \"  ,     0  )  )  ;", "final   AllocateResponse   response    =    createAllocateResponse ( completed ,    new   ArrayList < api . records . Container >  (  )  ,    null )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( response )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     2  0  ,    callbackHandler )  ;", "callbackHandler . asynClient    =    asyncClient ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "synchronized ( callbackHandler . notifier )     {", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "while    (  ( callbackHandler . notify )     =  =    false )     {", "try    {", "callbackHandler . notifier . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testCallAMRMClientAsyncStopFromCallbackHandler"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   TestAMRMClientAsync . TestCallbackHandler 2    callbackHandler    =    new   TestAMRMClientAsync . TestCallbackHandler 2  (  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "AMRMClient < AMRMClient . ContainerRequest >    client    =    mock ( AMRMClientImpl . class )  ;", "List < ContainerStatus >    completed    =    Arrays . asList ( ContainerStatus . newInstance ( TestAMRMClientAsync . newContainerId (  0  ,     0  ,     0  ,     0  )  ,    COMPLETE ,     \"  \"  ,     0  )  )  ;", "final   AllocateResponse   response    =    createAllocateResponse ( completed ,    new   ArrayList < api . records . Container >  (  )  ,    null )  ;", "when ( client . allocate ( anyFloat (  )  )  )  . thenReturn ( response )  ;", "AMRMClientAsync < AMRMClient . ContainerRequest >    asyncClient    =    AMRMClientAsync . createAMRMClientAsync ( client ,     2  0  ,    callbackHandler )  ;", "callbackHandler . asynClient    =    asyncClient ;", "asyncClient . init ( conf )  ;", "asyncClient . start (  )  ;", "Supplier < Boolean >    checker    =    new   Supplier < Boolean >  (  )     {", "@ Override", "public   Boolean   get (  )     {", "return   callbackHandler . notify ;", "}", "}  ;", "asyncClient . registerApplicationMaster (  \" localhost \"  ,     1  2  3  4  ,    null )  ;", "asyncClient . waitFor ( checker )  ;", "Assert . assertTrue ( checker . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCallAMRMClientAsyncStopFromCallbackHandlerWithWaitFor"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClientAsync . TestCallbackHandler 2    callbackHandler    =    spy ( new   TestAMRMClientAsync . TestCallbackHandler 2  (  )  )  ;", "runCallBackThrowOutException ( callbackHandler )  ;", "}", "METHOD_END"], "methodName": ["testCallBackThrowOutException"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClientAsync . TestCallbackHandler 2    callbackHandler    =    spy ( new   TestAMRMClientAsync . TestCallbackHandler 2  (  )  )  ;", "callbackHandler . stop    =    false ;", "runCallBackThrowOutException ( callbackHandler )  ;", "}", "METHOD_END"], "methodName": ["testCallBackThrowOutExceptionNoStop"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestAMRMClientAsync"}, {"methodBody": ["METHOD_START", "{", "ApplicationId   appId    =    ApplicationId . newInstance ( System . currentTimeMillis (  )  ,     1  )  ;", "ApplicationAttemptId   attemptId    =    ApplicationAttemptId . newInstance ( appId ,     1  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( attemptId ,    i )  ;", "nodeId    =    NodeId . newInstance (  \" localhost \"  ,     0  )  ;", "containerToken    =    recordFactory . newRecordInstance ( Tokeass )  ;", "return   Container . newInstance ( containerId ,    nodeId ,    null ,    null ,    null ,    containerToken )  ;", "}", "METHOD_END"], "methodName": ["mockContainer"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestNMClientAsync"}, {"methodBody": ["METHOD_START", "{", "NMClient   client    =    mock ( NMClient . class )  ;", "switch    ( mode )     {", "case    0     :", "when ( client . startContainer ( any ( Container . class )  ,    any ( ContainerLaunchContext . class )  )  )  . thenReturn ( Collections .  < String ,    ByteBuffer > emptyMap (  )  )  ;", "when ( client . getContainerStatus ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  )  . thenReturn ( recordFactory . newRecordInstance ( ContainerStatus . class )  )  ;", "doNothing (  )  . when ( client )  . stopContainer ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  ;", "break ;", "case    1     :", "doThrow ( RPCUtil . getRemoteException (  \" Start   Exception \"  )  )  . when ( client )  . startContainer ( any ( Container . class )  ,    any ( ContainerLaunchContext . class )  )  ;", "doThrow ( RPCUtil . getRemoteException (  \" Query   Exception \"  )  )  . when ( client )  . getContainerStatus ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  ;", "doThrow ( RPCUtil . getRemoteException (  \" Stop   Exception \"  )  )  . when ( client )  . stopContainer ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  ;", "break ;", "case    2     :", "when ( client . startContainer ( any ( Container . class )  ,    any ( ContainerLaunchContext . class )  )  )  . thenReturn ( Collections .  < String ,    ByteBuffer > emptyMap (  )  )  ;", "when ( client . getContainerStatus ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  )  . thenReturn ( recordFactory . newRecordInstance ( ContainerStatus . class )  )  ;", "doThrow ( RPCUtil . getRemoteException (  \" Stop   Exception \"  )  )  . when ( client )  . stopContainer ( any ( ContainerId . class )  ,    any ( NodeId . class )  )  ;", "}", "return   client ;", "}", "METHOD_END"], "methodName": ["mockNMClient"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestNMClientAsync"}, {"methodBody": ["METHOD_START", "{", "ServiceOperations . stop ( asyncClient )  ;", "}", "METHOD_END"], "methodName": ["teardown"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestNMClientAsync"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setInt ( NM _ CLIENT _ ASYNC _ THREAD _ POOL _ MAX _ SIZE ,     1  0  )  ;", "int   expectedSuccess    =     4  0  ;", "int   expectedFailure    =     4  0  ;", "asyncClient    =    new    . MockNMClientAsync 1  ( expectedSuccess ,    expectedFailure )  ;", "asyncClient . init ( conf )  ;", "Assert . assertEquals (  \" The   max   thread   pool   size   is   not   correctly   set \"  ,     1  0  ,    asyncClient . maxThreadPoolSize )  ;", "asyncClient . start (  )  ;", "for    ( int   i    =     0  ;    i    <     ( expectedSuccess    +    expectedFailure )  ;     +  + i )     {", "if    ( i    =  =    expectedSuccess )     {", "while    (  !  (  (  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . isAllSuccessCallsExecuted (  )  )  )     {", "Thread . sleep (  1  0  )  ;", "}", "asyncClient . setClient ( mockNMClient (  1  )  )  ;", "}", "Container   container    =    mockContainer ( i )  ;", "ContainerLaunchContext   clc    =    recordFactory . newRecordInstance ( ContainerLaunchContext . class )  ;", "asyncClient . startContainerAsync ( container ,    clc )  ;", "}", "while    (  !  (  (  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . isStartAndQueryFailureCallsExecuted (  )  )  )     {", "Thread . sleep (  1  0  )  ;", "}", "asyncClient . setClient ( mockNMClient (  2  )  )  ;", "(  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . path    =    false ;", "for    ( int   i    =     0  ;    i    <    expectedFailure ;     +  + i )     {", "Container   container    =    mockContainer (  (  ( expectedSuccess    +    expectedFailure )     +    i )  )  ;", "ContainerLaunchContext   clc    =    recordFactory . newRecordInstance ( ContainerLaunchContext . class )  ;", "asyncClient . startContainerAsync ( container ,    clc )  ;", "}", "while    (  !  (  (  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . isStopFailureCallsExecuted (  )  )  )     {", "Thread . sleep (  1  0  )  ;", "}", "for    ( String   errorMsg    :     (  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . errorMsgs )     {", "System . out . println ( errorMsg )  ;", "}", "Assert . assertEquals (  \" Error   occurs   in   CallbackHandler \"  ,     0  ,     (  (  . TestCallbackHandler 1  )     ( asyncClient . getCallbackHandler (  )  )  )  . errorMsgs . size (  )  )  ;", "for    ( String   errorMsg    :     (  (  . MockNMClientAsync 1  )     ( asyncClient )  )  . errorMsgs )     {", "System . out . println ( errorMsg )  ;", "}", "Assert . assertEquals (  \" Error   occurs   in   ContainerEventProcessor \"  ,     0  ,     (  (  . MockNMClientAsync 1  )     ( asyncClient )  )  . errorMsgs . size (  )  )  ;", "while    (  ( asyncClient . containers . size (  )  )     >     0  )     {", "Thread . sleep (  1  0  )  ;", "}", "asyncClient . stop (  )  ;", "Assert . assertFalse (  \" The   thread   of   Container   Management   Event   Dispatcher   is   still   alive \"  ,    asyncClient . eventDispatcherThread . isAlive (  )  )  ;", "Assert . assertTrue (  \" The   thread   pool   is   not   shut   down \"  ,    asyncClient . threadPool . isShutdown (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNMClientAsync"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestNMClientAsync"}, {"methodBody": ["METHOD_START", "{", "CyclicBarrier   barrierA    =    new   CyclicBarrier (  2  )  ;", "CyclicBarrier   barrierB    =    new   CyclicBarrier (  2  )  ;", "CyclicBarrier   barrierC    =    new   CyclicBarrier (  2  )  ;", "asyncClient    =    new    . MockNMClientAsync 2  ( barrierA ,    barrierB ,    barrierC )  ;", "asyncClient . init ( new   Configuration (  )  )  ;", "asyncClient . start (  )  ;", "final   Container   container    =    mockContainer (  1  )  ;", "final   ContainerLaunchContext   clc    =    recordFactory . newRecordInstance ( ContainerLaunchContext . class )  ;", "Thread   t    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "asyncClient . startContainerAsync ( container ,    clc )  ;", "}", "}  ;", "t . start (  )  ;", "barrierA . await (  )  ;", "asyncClient . stopContainerAsync ( container . getId (  )  ,    container . getNodeId (  )  )  ;", "barrierC . await (  )  ;", "Assert . assertFalse (  \" Starting   and   stopping   should   be   out   of   order \"  ,     (  (  . TestCallbackHandler 2  )     ( asyncClient . getCallbackHandler (  )  )  )  . exceptionOccurred . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOutOfOrder"], "fileName": "org.apache.hadoop.yarn.client.api.async.impl.TestNMClientAsync"}, {"methodBody": ["METHOD_START", "{", "return   conf . getSocketAddr ( TIMELINE _ SERVICE _ ADDRESS ,    DEFAULT _ TIMELINE _ SERVICE _ ADDRESS ,    DEFAULT _ TIMELINE _ SERVICE _ PORT )  ;", "}", "METHOD_END"], "methodName": ["getAHSAddress"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AHSClientImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >  >    remoteRequests    =    this . remoteRequestsTable . get ( priority )  ;", "if    ( remoteRequests    =  =    null )     {", "remoteRequests    =    new   HashMap < String ,    TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >  >  (  )  ;", "this . remoteRequestsTable . put ( priority ,    remoteRequests )  ;", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . debug (  (  \" Added   priority =  \"     +    priority )  )  ;", "}", "}", "TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >    reqMap    =    remoteRequests . get ( resourceName )  ;", "if    ( reqMap    =  =    null )     {", "reqMap    =    new   TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >  ( new   ResourceReverseMemoryThenCpuComparator (  )  )  ;", "remoteRequests . put ( resourceName ,    reqMap )  ;", "}", "AMRMClientImpl < T >  . ResourceRequestInfo   resourceRequestInfo    =    reqMap . get ( capability )  ;", "if    ( resourceRequestInfo    =  =    null )     {", "resourceRequestInfo    =    new   ResourceRequestInfo ( priority ,    resourceName ,    capability ,    relaxLocality )  ;", "reqMap . put ( capability ,    resourceRequestInfo )  ;", "}", "resourceRequestInfo . remoteRequest . setNumContainers (  (  ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )     +     1  )  )  ;", "if    ( relaxLocality )     {", "resourceRequestInfo . containerRequests . add ( req )  ;", "}", "addResourceRequestToAsk ( resourceRequestInfo . remoteRequest )  ;", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . debug (  (  (  (  (  (  (  (  (  \" addResourceRequest :  \"     +     (  \"    applicationId =  \"     +     \"    priority =  \"  )  )     +     ( priority . getPriority (  )  )  )     +     \"    resourceName =  \"  )     +    resourceName )     +     \"    numContainers =  \"  )     +     ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )  )     +     \"     # asks =  \"  )     +     ( ask . size (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addResourceRequest"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( ask . contains ( remoteRequest )  )     {", "ask . remove ( remoteRequest )  ;", "}", "ask . add ( remoteRequest )  ;", "}", "METHOD_END"], "methodName": ["addResourceRequestToAsk"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "int   mem 0     =    arg 0  . getMemory (  )  ;", "int   mem 1     =    arg 1  . getMemory (  )  ;", "int   cpu 0     =    arg 0  . getVirtualCores (  )  ;", "int   cpu 1     =    arg 1  . getVirtualCores (  )  ;", "if    (  ( mem 0     <  =    mem 1  )     &  &     ( cpu 0     <  =    cpu 1  )  )     {", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["canFit"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >  >    remoteRequests    =    this . remoteRequestsTable . get ( priority )  ;", "if    ( remoteRequests    =  =    null )     {", "return ;", "}", "for    ( String   location    :    locations )     {", "TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >    reqs    =    remoteRequests . get ( location )  ;", "if    (  ( reqs    !  =    null )     &  &     (  !  ( reqs . isEmpty (  )  )  )  )     {", "boolean   existingRelaxLocality    =    reqs . values (  )  . iterator (  )  . next (  )  . remoteRequest . getRelaxLocality (  )  ;", "if    ( relaxLocality    !  =    existingRelaxLocality )     {", "throw   new   InvalidContainerRequestException (  (  (  (  (  (  (  (  \" Cannot   submit   a    \"     +     \" ContainerRequest   asking   for   location    \"  )     +    location )     +     \"    with   locality   relaxation    \"  )     +    relaxLocality )     +     \"    when   it   has    \"  )     +     \" already   been   requested   with   locality   relaxation    \"  )     +    existingRelaxLocality )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["checkLocalityRelaxationConflict"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    TreeMap < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >  >    remoteRequests    =    this . remoteRequestsTable . get ( priority )  ;", "if    ( remoteRequests    =  =    null )     {", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . debug (  (  (  \" Not   decrementing   resource   as   priority    \"     +    priority )     +     \"    is   not   present   in   request   table \"  )  )  ;", "}", "return ;", "}", "Map < Resource ,    AMRMClientImpl < T >  . ResourceRequestInfo >    reqMap    =    remoteRequests . get ( resourceName )  ;", "if    ( reqMap    =  =    null )     {", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . debug (  (  (  \" Not   decrementing   resource   as    \"     +    resourceName )     +     \"    is   not   present   in   request   table \"  )  )  ;", "}", "return ;", "}", "AMRMClientImpl < T >  . ResourceRequestInfo   resourceRequestInfo    =    reqMap . get ( capability )  ;", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . debug (  (  (  (  (  (  (  (  (  \" BEFORE   decResourceRequest :  \"     +     (  \"    applicationId =  \"     +     \"    priority =  \"  )  )     +     ( priority . getPriority (  )  )  )     +     \"    resourceName =  \"  )     +    resourceName )     +     \"    numContainers =  \"  )     +     ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )  )     +     \"     # asks =  \"  )     +     ( ask . size (  )  )  )  )  ;", "}", "resourceRequestInfo . remoteRequest . setNumContainers (  (  ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )     -     1  )  )  ;", "resourceRequestInfo . containerRequests . remove ( req )  ;", "if    (  ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )     <     0  )     {", "resourceRequestInfo . remoteRequest . setNumContainers (  0  )  ;", "}", "addResourceRequestToAsk ( resourceRequestInfo . remoteRequest )  ;", "if    (  ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )     =  =     0  )     {", "reqMap . remove ( capability )  ;", "if    (  ( reqMap . size (  )  )     =  =     0  )     {", "remoteRequests . remove ( resourceName )  ;", "}", "if    (  ( remoteRequests . size (  )  )     =  =     0  )     {", "remoteRequestsTable . remove ( priority )  ;", "}", "}", "if    ( AMRMClientImpl . LOG . isDebugEnabled (  )  )     {", "AMRMClientImpl . LOG . info (  (  (  (  (  (  (  (  (  \" AFTER   decResourceRequest :  \"     +     (  \"    applicationId =  \"     +     \"    priority =  \"  )  )     +     ( priority . getPriority (  )  )  )     +     \"    resourceName =  \"  )     +    resourceName )     +     \"    numContainers =  \"  )     +     ( resourceRequestInfo . remoteRequest . getNumContainers (  )  )  )     +     \"     # asks =  \"  )     +     ( ask . size (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["decResourceRequest"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( allocateResponse . getAMCommand (  )  )     !  =    null )     &  &     (  ( allocateResponse . getAMCommand (  )  )     =  =     ( AMCommand . AM _ RESYNC )  )  ;", "}", "METHOD_END"], "methodName": ["isResyncCommand"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( NMToken   token    :    nmTokens )     {", "String   nodeId    =    token . getNodeId (  )  . toString (  )  ;", "if    ( getNMTokenCache (  )  . containsToken ( nodeId )  )     {", ". LOG . info (  (  \" Replacing   token   for    :     \"     +    nodeId )  )  ;", "} else    {", ". LOG . info (  (  \" Received   new   token   for    :     \"     +    nodeId )  )  ;", "}", "getNMTokenCache (  )  . setToken ( nodeId ,    token . getToken (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["populateNMTokens"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "RegisterApplicationMasterRequest   request    =    RegisterApplicationMasterRequest . newInstance ( this . appHostName ,    this . appHostPort ,    this . appTrackingUrl )  ;", "RegisterApplicationMasterResponse   response    =    rmCregisterApplicationMaster ( request )  ;", "synchronized ( this )     {", "lastResponseId    =     0  ;", "if    (  !  ( response . getNMTokensFromPreviousAttempts (  )  . isEmpty (  )  )  )     {", "populateNMTokens ( response . getNMTokensFromPreviousAttempts (  )  )  ;", "}", "}", "return   response ;", "}", "METHOD_END"], "methodName": ["registerApplicationMaster"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( ContainerStatus   containerStatus    :    completedContainersStatuses )     {", "pendingRelease . remove ( containerStatus . getContainerId (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removePendingReleaseRequests"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "Set < String >    racks    =    new   HashSet < String >  (  )  ;", "if    ( nodes    !  =    null )     {", "for    ( String   node    :    nodes )     {", "String   rack    =    RackResolver . resolve ( node )  . getNetworkLocation (  )  ;", "if    ( rack    =  =    null )     {", ". LOG . warn (  (  (  \" Failed   to   resolve   rack   for   node    \"     +    node )     +     \"  .  \"  )  )  ;", "} else    {", "racks . add ( rack )  ;", "}", "}", "}", "return   racks ;", "}", "METHOD_END"], "methodName": ["resolveRacks"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "Token < AMRMTokenIdentifier >    amrmToken    =    new   Token < AMRMTokenIdentifier >  ( token . getIdentifier (  )  . array (  )  ,    token . getPassword (  )  . array (  )  ,    new   Text ( token . getKind (  )  )  ,    new   Text ( token . getService (  )  )  )  ;", "UserGroupInformation   currentUGI    =    UserGroupInformation . getCurrentUser (  )  ;", "if    ( UserGroupInformation . isSecurityEnabled (  )  )     {", "currentUGI    =    UserGroupInformation . getLoginUser (  )  ;", "}", "currentUGI . addToken ( amrmToken )  ;", "}", "METHOD_END"], "methodName": ["updateAMRMToken"], "fileName": "org.apache.hadoop.yarn.client.api.impl.AMRMClientImpl"}, {"methodBody": ["METHOD_START", "{", "ContainerManagementProtocolProxy . ContainerManagementProtocolProxyData   proxy    =    cmProxy . get ( containerManagerBindAddr )  ;", "while    (  ( proxy    !  =    null )     &  &     (  !  ( proxy . token . getIdentifier (  )  . equals ( nmTokenCache . getToken ( containerManagerBindAddr )  . getIdentifier (  )  )  )  )  )     {", "ContainerManagementProtocolProxy . LOG . info (  (  \" Refreshing   proxy   as   NMToken   got   updated   for   node    :     \"     +    containerManagerBindAddr )  )  ;", "if    (  !  ( proxy . scheduledForClose )  )     {", "removeProxy ( proxy )  ;", "} else    {", "try    {", "this . wait (  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "if    (  ( proxy . activeCallers )     <     0  )     {", "proxy    =    cmProxy . get ( containerManagerBindAddr )  ;", "}", "}", "if    ( proxy    =  =    null )     {", "proxy    =    new   ContainerManagementProtocolProxy . ContainerManagementProtocolProxyData ( rpc ,    containerManagerBindAddr ,    containerId ,    nmTokenCache . getToken ( containerManagerBindAddr )  )  ;", "if    (  ( cmProxy . size (  )  )     >     ( maxConnectedNMs )  )     {", "String   cmAddr    =    cmProxy . keySet (  )  . iterator (  )  . next (  )  ;", "removeProxy ( cmProxy . get ( cmAddr )  )  ;", "}", "cmProxy . put ( containerManagerBindAddr ,    proxy )  ;", "}", "( proxy . activeCallers )  +  +  ;", "updateLRUCache ( containerManagerBindAddr )  ;", "return   proxy ;", "}", "METHOD_END"], "methodName": ["getProxy"], "fileName": "org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy"}, {"methodBody": ["METHOD_START", "{", "( proxy . activeCallers )  -  -  ;", "if    (  ( proxy . scheduledForClose )     &  &     (  ( proxy . activeCallers )     <     0  )  )     {", ". LOG . info (  (  \" Closing   proxy    :     \"     +     ( proxy . containerManagerBindAddr )  )  )  ;", "cmProxy . remove ( proxy . containerManagerBindAddr )  ;", "try    {", "rpc . stopProxy ( proxy . getContainerManagementProtocol (  )  ,    conf )  ;", "}    finally    {", "this . notifyAll (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["mayBeCloseProxy"], "fileName": "org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( proxy . scheduledForClose )  )     {", "proxy . scheduledForClose    =    true ;", "mayBeClose ( proxy )  ;", "}", "}", "METHOD_END"], "methodName": ["removeProxy"], "fileName": "org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy"}, {"methodBody": ["METHOD_START", "{", "List < String >    nodeIds    =    new   ArrayList < String >  (  )  ;", "nodeIds . addAll ( this . cmProxy . keySet (  )  )  ;", "for    ( String   nodeId    :    nodeIds )     {", "Data   proxy    =    cmProxy . get ( nodeId )  ;", "proxy . activeCallers    =     0  ;", "try    {", "removeProxy ( proxy )  ;", "}    catch    ( Throwable   t )     {", ". LOG . error (  \" Error   closing   connection \"  ,    t )  ;", "}", "}", "cmProxy . clear (  )  ;", "}", "METHOD_END"], "methodName": ["stopAllProxies"], "fileName": "org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy"}, {"methodBody": ["METHOD_START", "{", "ContainerManagementProtocolProxy . ContainerManagementProtocolProxyData   proxy    =    cmProxy . remove ( containerManagerBindAddr )  ;", "cmProxy . put ( containerManagerBindAddr ,    proxy )  ;", "}", "METHOD_END"], "methodName": ["updateLRUCache"], "fileName": "org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy"}, {"methodBody": ["METHOD_START", "{", "if    (  ( startedContainers . putIfAbsent ( startedContainer . containerId ,    startedContainer )  )     !  =    null )     {", "throw   RPCUtil . getRemoteException (  (  (  \" Container    \"     +     ( startedContainer . containerId . toString (  )  )  )     +     \"    is   already   started \"  )  )  ;", "}", "startedContainers . put ( startedContainer . getContainerId (  )  ,    startedContainer )  ;", "}", "METHOD_END"], "methodName": ["addStartingContainer"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "for    ( NMClientImpl . StartedContainer   startedContainer    :    startedContainers . values (  )  )     {", "try    {", "stopContainer ( startedContainer . getContainerId (  )  ,    startedContainer . getNodeId (  )  )  ;", "}    catch    ( YarnException   e )     {", "NMClientImpl . LOG . error (  (  (  \" Failed   to   stop   Container    \"     +     ( startedContainer . getContainerId (  )  )  )     +     \" when   stopping   NMClientImpl \"  )  )  ;", "}    catch    ( IOException   e )     {", "NMClientImpl . LOG . error (  (  (  \" Failed   to   stop   Container    \"     +     ( startedContainer . getContainerId (  )  )  )     +     \" when   stopping   NMClientImpl \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["cleanupRunningContainers"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "NMClientImpl . StartedContainer   startedContainer    =    new   NMClientImpl . StartedContainer ( container . getId (  )  ,    container . getNodeId (  )  ,    container . getContainerToken (  )  )  ;", "return   startedContainer ;", "}", "METHOD_END"], "methodName": ["createStartedContainer"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "return   cleanupRunningContainers ;", "}", "METHOD_END"], "methodName": ["getCleanupRunningContainers"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "return   startedContainers . get ( containerId )  ;", "}", "METHOD_END"], "methodName": ["getStartedContainer"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( t   instanceof   YarnException )     {", "throw    (  ( YarnException )     ( t )  )  ;", "} else", "if    ( t   instanceof   security . token . SecretManager . InvalidToken )     {", "throw    (  ( security . token . SecretManager . InvalidToken )     ( t )  )  ;", "} else    {", "throw    (  ( IOException )     ( t )  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseAndThrowException"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "startedContainers . remove ( container . containerId )  ;", "}", "METHOD_END"], "methodName": ["removeStartedContainer"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "ContainerManagementProtocolProxy . ContainerManagementProtocolProxyData   proxy    =    null ;", "List < ContainerId >    containerIds    =    new   ArrayList < ContainerId >  (  )  ;", "containerIds . add ( containerId )  ;", "try    {", "proxy    =    cmProxy . getProxy ( nodeId . toString (  )  ,    containerId )  ;", "StopContainersResponse   response    =    proxy . getContainerManagementProtocol (  )  . stopContainers ( StopContainersRequest . newInstance ( containerIds )  )  ;", "if    (  (  ( response . getFailedRequests (  )  )     !  =    null )     &  &     ( response . getFailedRequests (  )  . containsKey ( containerId )  )  )     {", "Throwable   t    =    response . getFailedRequests (  )  . get ( containerId )  . deSerialize (  )  ;", "parseAndThrowException ( t )  ;", "}", "}    finally    {", "if    ( proxy    !  =    null )     {", "cmProxy . mayBeCloseProxy ( proxy )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["stopContainerInternal"], "fileName": "org.apache.hadoop.yarn.client.api.impl.NMClientImpl"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "client    =     . create (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testClientStop"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockAHSClient )     ( client )  )  . getReports (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ApplicationAttemptReport   report    =    client . getApplicationAttemptReport ( appAttemptId )  ;", "Assert . assertNotNull ( report )  ;", "Assert . assertEquals ( report . getApplicationAttemptId (  )  . toString (  )  ,    expectedReports . get (  0  )  . getCurrentApplicationAttemptId (  )  . toString (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttempt"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "List < ApplicationAttemptReport >    reports    =    client . getApplicationAttempts ( applicationId )  ;", "Assert . assertNotNull ( reports )  ;", "Assert . assertEquals ( reports . get (  0  )  . getApplicationAttemptId (  )  ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  )  ;", "Assert . assertEquals ( reports . get (  1  )  . getApplicationAttemptId (  )  ,    ApplicationAttemptId . newInstance ( applicationId ,     2  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttempts"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockAHSClient )     ( client )  )  . getReports (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationReport   report    =    client . getApplicationReport ( applicationId )  ;", "Assert . assertEquals ( report ,    expectedReports . get (  0  )  )  ;", "Assert . assertEquals ( report . getApplicationId (  )  . toString (  )  ,    expectedReports . get (  0  )  . getApplicationId (  )  . toString (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationReport"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockAHSClient )     ( client )  )  . getReports (  )  ;", "List < ApplicationReport >    reports    =    client . getApplications (  )  ;", "Assert . assertEquals ( reports ,    expectedReports )  ;", "reports    =    client . getApplications (  )  ;", "Assert . assertEquals ( reports . size (  )  ,     4  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplications"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockAHSClient )     ( client )  )  . getReports (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( appAttemptId ,     1  )  ;", "ContainerReport   report    =    client . getContainerReport ( containerId )  ;", "Assert . assertNotNull ( report )  ;", "Assert . assertEquals ( report . getContainerId (  )  . toString (  )  ,    ContainerId . newInstance ( expectedReports . get (  0  )  . getCurrentApplicationAttemptId (  )  ,     1  )  . toString (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainerReport"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   AHSClient   client    =    new    . MockAHSClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "List < ContainerReport >    reports    =    client . getContainers ( appAttemptId )  ;", "Assert . assertNotNull ( reports )  ;", "Assert . assertEquals ( reports . get (  0  )  . getContainerId (  )  ,    ContainerId . newInstance ( appAttemptId ,     1  )  )  ;", "Assert . assertEquals ( reports . get (  1  )  . getContainerId (  )  ,    ContainerId . newInstance ( appAttemptId ,     2  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainers"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAHSClient"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClient . yarnClient . killApplication ( TestAMRMClient . attemptId . getApplicationId (  )  )  ;", "TestAMRMClient . attemptId    =    null ;", "}", "METHOD_END"], "methodName": ["cancelApp"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "Credentials   credentials    =    UserGroupInformation . getCurrentUser (  )  . getCredentials (  )  ;", "Iterator < Token <  ?  >  >    iter    =    credentials . getAllTokens (  )  . iterator (  )  ;", "while    ( iter . hasNext (  )  )     {", "Token <  ?  >    token    =    iter . next (  )  ;", "if    ( token . getKind (  )  . equals ( KIND _ NAME )  )     {", "return    (  ( Token < TokenIdentifier >  )     ( token )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getAMRMToken"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "int   allocatedContainerCount    =     0  ;", "while    (  ( iterationsLeft -  -  )     >     0  )     {", "Log . info (  (  (  (  \"     =  =    alloc    \"     +    allocatedContainerCount )     +     \"    it   left    \"  )     +    iterationsLeft )  )  ;", "AllocateResponse   allocResponse    =    amClient . allocate (  0  .  1 F )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "assertEquals (  . nodeCount ,    amClient . getClusterNodeCount (  )  )  ;", "allocatedContainerCount    +  =    allocResponse . getAllocatedContainers (  )  . size (  )  ;", "if    ( allocatedContainerCount    =  =     0  )     {", "sleep (  1  0  0  )  ;", "}", "}", "return   allocatedContainerCount ;", "}", "METHOD_END"], "methodName": ["getAllocatedContainersNumber"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClient . conf    =    new   YarnConfiguration (  )  ;", "TestAMRMClient . conf . setLong ( RM _ AMRM _ TOKEN _ MASTER _ KEY _ ROLLING _ INTERVAL _ SECS ,    TestAMRMClient . rolling _ interval _ sec )  ;", "TestAMRMClient . conf . setLong ( RM _ AM _ EXPIRY _ INTERVAL _ MS ,    TestAMRMClient . am _ expire _ ms )  ;", "TestAMRMClient . conf . setInt ( RM _ NM _ HEARTBEAT _ INTERVAL _ MS ,     1  0  0  )  ;", "TestAMRMClient . conf . setLong ( NM _ LOG _ RETAIN _ SECONDS ,     1  )  ;", "TestAMRMClient . yarnCluster    =    new   MiniYARNCluster ( TestAMRMClient . class . getName (  )  ,    TestAMRMClient . nodeCount ,     1  ,     1  )  ;", "TestAMRMClient . yarnCluster . init ( TestAMRMClient . conf )  ;", "TestAMRMClient . yarnCluster . start (  )  ;", "TestAMRMClient . yarnClient    =    YarnClient . createYarnClient (  )  ;", "TestAMRMClient . yarnClient . init ( TestAMRMClient . conf )  ;", "TestAMRMClient . yarnClient . start (  )  ;", "TestAMRMClient . nodeReports    =    TestAMRMClient . yarnClient . getNodeReports ( RUNNING )  ;", "TestAMRMClient . priority    =    Priority . newInstance (  1  )  ;", "TestAMRMClient . priority 2     =    Priority . newInstance (  2  )  ;", "TestAMRMClient . capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "TestAMRMClient . node    =    TestAMRMClient . nodeReports . get (  0  )  . getNodeId (  )  . getHost (  )  ;", "TestAMRMClient . rack    =    TestAMRMClient . nodeReports . get (  0  )  . getRackName (  )  ;", "TestAMRMClient . nodes    =    new   String [  ]  {    TestAMRMClient . node    }  ;", "TestAMRMClient . racks    =    new   String [  ]  {    TestAMRMClient . rack    }  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thre . sleep ( sleepTime )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sleep"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "ApplicationSubmissionContext   appContext    =    TestAMRMClient . yarnClient . createApplication (  )  . getApplicationSubmissionContext (  )  ;", "ApplicationId   appId    =    appContext . getApplicationId (  )  ;", "appContext . setApplicationName (  \" Test \"  )  ;", "Priority   pri    =    Records . newRecord ( Priority . class )  ;", "pri . setPriority (  0  )  ;", "appContext . setPriority ( pri )  ;", "appContext . setQueue (  \" default \"  )  ;", "ContainerLaunchContext   amContainer    =    BuilderUtils . newContainerLaunchContext ( Collections .  < String ,    LocalResource > emptyMap (  )  ,    new   HashMap < String ,    String >  (  )  ,    Arrays . asList (  \" sleep \"  ,     \"  1  0  0  \"  )  ,    new   HashMap < String ,    ByteBuffer >  (  )  ,    null ,    new   HashMap < api . records . ApplicationAccessType ,    String >  (  )  )  ;", "appContext . setAMContainerSpec ( amContainer )  ;", "appContext . setResource ( Resource . newInstance (  1  0  2  4  ,     1  )  )  ;", "SubmitApplicationRequest   appRequest    =    Records . newRecord ( SubmitApplicationRequest . class )  ;", "appRequest . setApplicationSubmissionContext ( appContext )  ;", "TestAMRMClient . yarnClient . submitApplication ( appContext )  ;", "RMAppAttempt   appAttempt    =    null ;", "while    ( true )     {", "ApplicationReport   appReport    =    TestAMRMClient . yarnClient . getApplicationReport ( appId )  ;", "if    (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . ACCEPTED )  )     {", "TestAMRMClient . attemptId    =    appReport . getCurrentApplicationAttemptId (  )  ;", "appAttempt    =    TestAMRMClient . yarnCluster . getResourceManager (  )  . getRMContext (  )  . getRMApps (  )  . get ( TestAMRMClient . attemptId . getApplicationId (  )  )  . getCurrentAppAttempt (  )  ;", "while    ( true )     {", "if    (  ( appAttempt . getAppAttemptState (  )  )     =  =     ( RMAppAttemptState . LAUNCHED )  )     {", "break ;", "}", "}", "break ;", "}", "}", "UserGroupInformation . setLoginUser ( UserGroupInformation . createRemoteUser ( UserGroupInformation . getCurrentUser (  )  . getUserName (  )  )  )  ;", "UserGroupInformation . getCurrentUser (  )  . addToken ( appAttempt . getAMRMToken (  )  )  ;", "}", "METHOD_END"], "methodName": ["startApp"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( TestAMRMClient . yarnClient )     !  =    null )     &  &     (  ( TestAMRMClient . yarnClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "TestAMRMClient . yarnClient . stop (  )  ;", "}", "if    (  (  ( TestAMRMClient . yarnCluster )     !  =    null )     &  &     (  ( TestAMRMClient . yarnCluster . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "TestAMRMClient . yarnCluster . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =    AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  ;", "amClient . setNMTokenCache ( new   NMTokenCache (  )  )  ;", "Assert . assertNotSame ( NMTokenCache . getSingleton (  )  ,    amClient . getNMTokenCache (  )  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "testAllocation (  (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( amClient )  )  )  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClient"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =     (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  )  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "Priority   priority 1     =    Records . newRecord ( Priority . class )  ;", "priority 1  . setPriority (  2  )  ;", "AMRMClient . ContainerRequest   storedContainer 1     =    new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 2     =    new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 3     =    new   AMRMClient . ContainerRequest (  . capability ,    null ,    null ,    priority 1  )  ;", "amClient . addContainerRequest ( storedContainer 1  )  ;", "amClient . addContainerRequest ( storedContainer 2  )  ;", "amClient . addContainerRequest ( storedContainer 3  )  ;", "int   containersRequestedAny    =    amClient . remoteRequestsTable . get (  . priority )  . get ( ANY )  . get (  . capability )  . remoteRequest . getNumContainers (  )  ;", "assertEquals (  2  ,    containersRequestedAny )  ;", "containersRequestedAny    =    amClient . remoteRequestsTable . get ( priority 1  )  . get ( ANY )  . get (  . capability )  . remoteRequest . getNumContainers (  )  ;", "assertEquals (  1  ,    containersRequestedAny )  ;", "List <  ?    extends   Collection < AMRMClient . ContainerRequest >  >    matches    =    amClient . getMatchingRequests (  . priority ,     . node ,     . capability )  ;", "verifyMatches ( matches ,     2  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . rack ,     . capability )  ;", "verifyMatches ( matches ,     2  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,    ANY ,     . capability )  ;", "verifyMatches ( matches ,     2  )  ;", "matches    =    amClient . getMatchingRequests ( priority 1  ,     . rack ,     . capability )  ;", "assertTrue ( matches . isEmpty (  )  )  ;", "matches    =    amClient . getMatchingRequests ( priority 1  ,    ANY ,     . capability )  ;", "verifyMatches ( matches ,     1  )  ;", "amClient . removeContainerRequest ( storedContainer 3  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,     . capability )  ;", "verifyMatches ( matches ,     2  )  ;", "amClient . removeContainerRequest ( storedContainer 2  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,     . capability )  ;", "verifyMatches ( matches ,     1  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . rack ,     . capability )  ;", "verifyMatches ( matches ,     1  )  ;", "AMRMClient . ContainerRequest   storedRequest    =    matches . get (  0  )  . iterator (  )  . next (  )  ;", "assertEquals ( storedContainer 1  ,    storedRequest )  ;", "amClient . removeContainerRequest ( storedContainer 1  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,    ANY ,     . capability )  ;", "assertTrue ( matches . isEmpty (  )  )  ;", "matches    =    amClient . getMatchingRequests ( priority 1  ,    ANY ,     . capability )  ;", "assertTrue ( matches . isEmpty (  )  )  ;", "assertTrue ( amClient . remoteRequestsTable . isEmpty (  )  )  ;", "amClient . addContainerRequest ( storedContainer 1  )  ;", "amClient . addContainerRequest ( storedContainer 3  )  ;", "int   allocatedContainerCount    =     0  ;", "int   iterationsLeft    =     3  ;", "while    (  ( allocatedContainerCount    <     2  )     &  &     (  ( iterationsLeft -  -  )     >     0  )  )     {", "Log . info (  (  (  (  \"     =  =    alloc    \"     +    allocatedContainerCount )     +     \"    it   left    \"  )     +    iterationsLeft )  )  ;", "AllocateResponse   allocResponse    =    amClient . allocate (  0  .  1 F )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "assertEquals (  . nodeCount ,    amClient . getClusterNodeCount (  )  )  ;", "allocatedContainerCount    +  =    allocResponse . getAllocatedContainers (  )  . size (  )  ;", "for    ( Container   container    :    allocResponse . getAllocatedContainers (  )  )     {", "AMRMClient . ContainerRequest   expectedRequest    =     ( container . getPriority (  )  . equals ( storedContainer 1  . getPriority (  )  )  )     ?    storedContainer 1     :    storedContainer 3  ;", "matches    =    amClient . getMatchingRequests ( container . getPriority (  )  ,    ANY ,    container . getResource (  )  )  ;", "verifyMatches ( matches ,     1  )  ;", "AMRMClient . ContainerRequest   matchedRequest    =    matches . get (  0  )  . iterator (  )  . next (  )  ;", "assertEquals ( matchedRequest ,    expectedRequest )  ;", "amClient . removeContainerRequest ( matchedRequest )  ;", "amClient . releaseAssignedContainer ( container . getId (  )  )  ;", "}", "if    ( allocatedContainerCount    <    containersRequestedAny )     {", "sleep (  1  0  0  )  ;", "}", "}", "assertEquals (  2  ,    allocatedContainerCount )  ;", "AllocateResponse   allocResponse    =    amClient . allocate (  0  .  1 F )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    allocResponse . getAllocatedContainers (  )  . size (  )  )  ;", "assertTrue ( amClient . remoteRequestsTable . isEmpty (  )  )  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClientMatchStorage"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =    AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "Resource   capability 1     =    Resource . newInstance (  1  0  2  4  ,     2  )  ;", "Resource   capability 2     =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "Resource   capability 3     =    Resource . newInstance (  1  0  0  0  ,     2  )  ;", "Resource   capability 4     =    Resource . newInstance (  2  0  0  0  ,     1  )  ;", "Resource   capability 5     =    Resource . newInstance (  1  0  0  0  ,     3  )  ;", "Resource   capability 6     =    Resource . newInstance (  2  0  0  0  ,     1  )  ;", "Resource   capability 7     =    Resource . newInstance (  2  0  0  0  ,     1  )  ;", "AMRMClient . ContainerRequest   storedContainer 1     =    new   AMRMClient . ContainerRequest ( capability 1  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 2     =    new   AMRMClient . ContainerRequest ( capability 2  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 3     =    new   AMRMClient . ContainerRequest ( capability 3  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 4     =    new   AMRMClient . ContainerRequest ( capability 4  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 5     =    new   AMRMClient . ContainerRequest ( capability 5  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 6     =    new   AMRMClient . ContainerRequest ( capability 6  ,     . nodes ,     . racks ,     . priority )  ;", "AMRMClient . ContainerRequest   storedContainer 7     =    new   AMRMClient . ContainerRequest ( capability 7  ,     . nodes ,     . racks ,     . priority 2  ,    false )  ;", "amClient . addContainerRequest ( storedContainer 1  )  ;", "amClient . addContainerRequest ( storedContainer 2  )  ;", "amClient . addContainerRequest ( storedContainer 3  )  ;", "amClient . addContainerRequest ( storedContainer 4  )  ;", "amClient . addContainerRequest ( storedContainer 5  )  ;", "amClient . addContainerRequest ( storedContainer 6  )  ;", "amClient . addContainerRequest ( storedContainer 7  )  ;", "List <  ?    extends   Collection < AMRMClient . ContainerRequest >  >    matches ;", "AMRMClient . ContainerRequest   storedRequest ;", "Resource   testCapability 1     =    Resource . newInstance (  1  0  2  4  ,     2  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    testCapability 1  )  ;", "verifyMatches ( matches ,     1  )  ;", "storedRequest    =    matches . get (  0  )  . iterator (  )  . next (  )  ;", "assertEquals ( storedContainer 1  ,    storedRequest )  ;", "amClient . removeContainerRequest ( storedContainer 1  )  ;", "Resource   testCapability 2     =    Resource . newInstance (  2  0  0  0  ,     1  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    testCapability 2  )  ;", "verifyMatches ( matches ,     2  )  ;", "int   i    =     0  ;", "for    ( AMRMClient . ContainerRequest   storedRequest 1     :    matches . get (  0  )  )     {", "if    (  ( i +  +  )     =  =     0  )     {", "assertEquals ( storedContainer 4  ,    storedRequest 1  )  ;", "} else    {", "assertEquals ( storedContainer 6  ,    storedRequest 1  )  ;", "}", "}", "amClient . removeContainerRequest ( storedContainer 6  )  ;", "Resource   testCapability 3     =    Resource . newInstance (  4  0  0  0  ,     4  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    testCapability 3  )  ;", "assert    ( matches . size (  )  )     =  =     4  ;", "Resource   testCapability 4     =    Resource . newInstance (  1  0  2  4  ,     2  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    testCapability 4  )  ;", "assert    ( matches . size (  )  )     =  =     2  ;", "for    ( Collection < AMRMClient . ContainerRequest >    testSet    :    matches )     {", "assertEquals (  1  ,    testSet . size (  )  )  ;", "AMRMClient . ContainerRequest   testRequest    =    testSet . iterator (  )  . next (  )  ;", "assertTrue (  ( testRequest    !  =    storedContainer 4  )  )  ;", "assertTrue (  ( testRequest    !  =    storedContainer 5  )  )  ;", "assert    ( testRequest    =  =    storedContainer 2  )     |  |     ( testRequest    =  =    storedContainer 3  )  ;", "}", "Resource   testCapability 5     =    Resource . newInstance (  5  1  2  ,     4  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    testCapability 5  )  ;", "assert    ( matches . size (  )  )     =  =     0  ;", "Resource   testCapability 7     =    Resource . newInstance (  2  0  0  0  ,     1  )  ;", "matches    =    amClient . getMatchingRequests (  . priority 2  ,    ANY ,    testCapability 7  )  ;", "assert    ( matches . size (  )  )     =  =     0  ;", "matches    =    amClient . getMatchingRequests (  . priority 2  ,     . node ,    testCapability 7  )  ;", "assert    ( matches . size (  )  )     =  =     1  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClientMatchingFit"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     2  )  ;", "AMRMClient . ContainerRequest   storedContainer 1     =    new   AMRMClient . ContainerRequest ( capability ,     . nodes ,    null ,     . priority )  ;", "amClient . addContainerRequest ( storedContainer 1  )  ;", "List <  ?    extends   Collection < AMRMClient . ContainerRequest >  >    matches ;", "AMRMClient . ContainerRequest   storedRequest ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . node ,    capability )  ;", "verifyMatches ( matches ,     1  )  ;", "storedRequest    =    matches . get (  0  )  . iterator (  )  . next (  )  ;", "assertEquals ( storedContainer 1  ,    storedRequest )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . rack ,    capability )  ;", "verifyMatches ( matches ,     1  )  ;", "storedRequest    =    matches . get (  0  )  . iterator (  )  . next (  )  ;", "assertEquals ( storedContainer 1  ,    storedRequest )  ;", "amClient . removeContainerRequest ( storedContainer 1  )  ;", "matches    =    amClient . getMatchingRequests (  . priority ,     . rack ,    capability )  ;", "assertTrue ( matches . isEmpty (  )  )  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClientMatchingFitInferredRack"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "AMRMTokenSecretManager   amrmTokenSecretManager    =     . yarnCluster . getResourceManager (  )  . getRMContext (  )  . getAMRMTokenSecretManager (  )  ;", "amClient    =    AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "Long   startTime    =    System . currentTimeMillis (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "Token < AMRMTokenIdentifier >    amrmToken _  1     =    getAMRMToken (  )  ;", "Assert . assertNotNull ( amrmToken _  1  )  ;", "Assert . assertEquals ( amrmToken _  1  . decodeIdentifier (  )  . getKeyId (  )  ,    amrmTokenSecretManager . getMasterKey (  )  . getMasterKey (  )  . getKeyId (  )  )  ;", "while    (  (  ( System . currentTimeMillis (  )  )     -    startTime )     <     (  (  . rolling _ interval _ sec )     *     1  0  0  0  )  )     {", "amClient . allocate (  0  .  1 F )  ;", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "amClient . allocate (  0  .  1 F )  ;", "Token < AMRMTokenIdentifier >    amrmToken _  2     =    getAMRMToken (  )  ;", "Assert . assertNotNull ( amrmToken _  2  )  ;", "Assert . assertEquals ( amrmToken _  2  . decodeIdentifier (  )  . getKeyId (  )  ,    amrmTokenSecretManager . getMasterKey (  )  . getMasterKey (  )  . getKeyId (  )  )  ;", "Assert . assertNotEquals ( amrmToken _  1  ,    amrmToken _  2  )  ;", "amClient . allocate (  0  .  1 F )  ;", "while    ( true )     {", "if    (  ( amrmToken _  2  . decodeIdentifier (  )  . getKeyId (  )  )     !  =     ( amrmTokenSecretManager . getCurrnetMasterKeyData (  )  . getMasterKey (  )  . getKeyId (  )  )  )     {", "if    (  ( amrmTokenSecretManager . getNextMasterKeyData (  )  )     =  =    null )     {", "break ;", "} else", "if    (  ( amrmToken _  2  . decodeIdentifier (  )  . getKeyId (  )  )     !  =     ( amrmTokenSecretManager . getNextMasterKeyData (  )  . getMasterKey (  )  . getKeyId (  )  )  )     {", "break ;", "}", "}", "amClient . allocate (  0  .  1 F )  ;", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "try    {", "UserGroupInformation   testUser    =    UserGroupInformation . createRemoteUser (  \" testUser \"  )  ;", "SecurityUtil . setTokenService ( amrmToken _  2  ,     . yarnCluster . getResourceManager (  )  . getApplicationMasterService (  )  . getBindAddress (  )  )  ;", "testUser . addToken ( amrmToken _  2  )  ;", "testUser . doAs ( new   PrivilegedAction < ApplicationMasterProtocol >  (  )     {", "@ Override", "public   ApplicationMasterProtocol   run (  )     {", "return    (  ( ApplicationMasterProtocol )     ( YarnRPC . create (  . conf )  . getProxy ( ApplicationMasterProtocol . class ,     . yarnCluster . getResourceManager (  )  . getApplicationMasterService (  )  . getBindAddress (  )  ,     . conf )  )  )  ;", "}", "}  )  . allocate ( Records . newRecord ( AllocateRequest . class )  )  ;", "Assert . fail (  \" The   old   Token   should   not   work \"  )  ;", "}    catch    ( Exception   ex )     {", "Assert . assertTrue (  ( ex   instanceof   InvalidToken )  )  ;", "Assert . assertTrue ( ex . getMessage (  )  . contains (  (  \" Invalid   AMRMToken   from    \"     +     ( amrmToken _  2  . decodeIdentifier (  )  . getApplicationAttemptId (  )  )  )  )  )  ;", "}", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClientOnAMRMTokenRollOver"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =     (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  )  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "String [  ]    nodes    =    new   String [  ]  {     \" node 1  \"  ,     \" node 2  \"  ,     \" node 3  \"     }  ;", "List < String >    nodeList 0  1     =    new   ArrayList < String >  (  )  ;", "nodeList 0  1  . add ( nodes [  0  ]  )  ;", "nodeList 0  1  . add ( nodes [  1  ]  )  ;", "amClient . updateBlacklist ( nodeList 0  1  ,    null )  ;", "assertEquals (  2  ,    amClient . blacklistAdditions . size (  )  )  ;", "assertEquals (  0  ,    amClient . blacklistRemovals . size (  )  )  ;", "List < String >    nodeList 0  2     =    new   ArrayList < String >  (  )  ;", "nodeList 0  2  . add ( nodes [  0  ]  )  ;", "nodeList 0  2  . add ( nodes [  2  ]  )  ;", "amClient . updateBlacklist ( nodeList 0  2  ,    null )  ;", "assertEquals (  3  ,    amClient . blacklistAdditions . size (  )  )  ;", "assertEquals (  0  ,    amClient . blacklistRemovals . size (  )  )  ;", "List < String >    nodeList 1  2     =    new   ArrayList < String >  (  )  ;", "nodeList 1  2  . add ( nodes [  1  ]  )  ;", "nodeList 1  2  . add ( nodes [  2  ]  )  ;", "amClient . updateBlacklist ( null ,    nodeList 1  2  )  ;", "assertEquals (  1  ,    amClient . blacklistAdditions . size (  )  )  ;", "assertEquals (  2  ,    amClient . blacklistRemovals . size (  )  )  ;", "List < String >    nodeList 1     =    new   ArrayList < String >  (  )  ;", "nodeList 1  . add ( nodes [  1  ]  )  ;", "amClient . updateBlacklist ( nodeList 1  ,    null )  ;", "assertEquals (  2  ,    amClient . blacklistAdditions . size (  )  )  ;", "assertEquals (  1  ,    amClient . blacklistRemovals . size (  )  )  ;", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAMRMClientWithBlacklist"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "int   containersRequestedNode    =    amClient . remoteRequestsTable . get (  . priority )  . get (  . node )  . get (  . capability )  . remoteRequest . getNumContainers (  )  ;", "int   containersRequestedRack    =    amClient . remoteRequestsTable . get (  . priority )  . get (  . rack )  . get (  . capability )  . remoteRequest . getNumContainers (  )  ;", "int   containersRequestedAny    =    amClient . remoteRequestsTable . get (  . priority )  . get ( ANY )  . get (  . capability )  . remoteRequest . getNumContainers (  )  ;", "assertEquals (  2  ,    containersRequestedNode )  ;", "assertEquals (  2  ,    containersRequestedRack )  ;", "assertEquals (  2  ,    containersRequestedAny )  ;", "assertEquals (  3  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "int   allocatedContainerCount    =     0  ;", "int   iterationsLeft    =     3  ;", "Set < ContainerId >    releases    =    new   TreeSet < ContainerId >  (  )  ;", "amClient . getNMTokenCache (  )  . clearCache (  )  ;", "Assert . assertEquals (  0  ,    amClient . getNMTokenCache (  )  . numberOfTokensInCache (  )  )  ;", "HashMap < String ,    Token >    receivedNMTokens    =    new   HashMap < String ,    Token >  (  )  ;", "while    (  ( allocatedContainerCount    <    containersRequestedAny )     &  &     (  ( iterationsLeft -  -  )     >     0  )  )     {", "AllocateResponse   allocResponse    =    amClient . allocate (  0  .  1 F )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "assertEquals (  . nodeCount ,    amClient . getClusterNodeCount (  )  )  ;", "allocatedContainerCount    +  =    allocResponse . getAllocatedContainers (  )  . size (  )  ;", "for    ( Container   container    :    allocResponse . getAllocatedContainers (  )  )     {", "ContainerId   rejectContainerId    =    container . getId (  )  ;", "releases . add ( rejectContainerId )  ;", "amClient . releaseAssignedContainer ( rejectContainerId )  ;", "}", "for    ( NMToken   token    :    allocResponse . getNMTokens (  )  )     {", "String   nodeID    =    token . getNodeId (  )  . toString (  )  ;", "if    ( receivedNMTokens . containsKey ( nodeID )  )     {", "Assert . fail (  (  \" Received   token   again   for    :     \"     +    nodeID )  )  ;", "}", "receivedNMTokens . put ( nodeID ,    token . getToken (  )  )  ;", "}", "if    ( allocatedContainerCount    <    containersRequestedAny )     {", "sleep (  1  0  0  )  ;", "}", "}", "Assert . assertTrue (  (  (  ( receivedNMTokens . size (  )  )     >     0  )     &  &     (  ( receivedNMTokens . size (  )  )     <  =     (  . nodeCount )  )  )  )  ;", "assertEquals ( allocatedContainerCount ,    containersRequestedAny )  ;", "assertEquals (  2  ,    amClient . release . size (  )  )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "assertEquals (  3  ,    amClient . ask . size (  )  )  ;", "ResourceRequest   snoopRequest    =    amClient . ask . iterator (  )  . next (  )  ;", "assertEquals (  0  ,    snoopRequest . getNumContainers (  )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . addContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "snoopRequest    =    amClient . ask . iterator (  )  . next (  )  ;", "assertEquals (  2  ,    snoopRequest . getNumContainers (  )  )  ;", "ApplicationMasterProtocol   realRM    =    amClient . rmClient ;", "try    {", "ApplicationMasterProtocol   mockRM    =    mock ( ApplicationMasterProtocol . class )  ;", "when ( mockRM . allocate ( any ( AllocateRequest . class )  )  )  . thenAnswer ( new   Answer < AllocateResponse >  (  )     {", "public   AllocateResponse   answer ( InvocationOnMock   invocation )    throws   Exception    {", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "amClient . removeContainerRequest ( new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  )  ;", "throw   new   Exception (  )  ;", "}", "}  )  ;", "amClient . rmClient    =    mockRM ;", "amClient . allocate (  0  .  1 F )  ;", "}    catch    ( Exception   ioe )     {", "}    finally    {", "amClient . rmClient    =    realRM ;", "}", "assertEquals (  2  ,    amClient . release . size (  )  )  ;", "assertEquals (  3  ,    amClient . ask . size (  )  )  ;", "snoopRequest    =    amClient . ask . iterator (  )  . next (  )  ;", "assertEquals (  0  ,    snoopRequest . getNumContainers (  )  )  ;", "iterationsLeft    =     3  ;", "while    (  (  !  ( releases . isEmpty (  )  )  )     |  |     (  ( iterationsLeft -  -  )     >     0  )  )     {", "AllocateResponse   allocResponse    =    amClient . allocate (  0  .  1 F )  ;", "assertEquals (  0  ,    allocResponse . getAllocatedContainers (  )  . size (  )  )  ;", "if    (  ( allocResponse . getCompletedContainersStatuses (  )  . size (  )  )     >     0  )     {", "for    ( ContainerStatus   cStatus    :    allocResponse . getCompletedContainersStatuses (  )  )     {", "if    ( releases . contains ( cStatus . getContainerId (  )  )  )     {", "assertEquals ( cStatus . getState (  )  ,    COMPLETE )  ;", "assertEquals (  (  -  1  0  0  )  ,    cStatus . getExitStatus (  )  )  ;", "releases . remove ( cStatus . getContainerId (  )  )  ;", "}", "}", "}", "if    ( iterationsLeft    >     0  )     {", "sleep (  1  0  0  )  ;", "}", "}", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAllocation"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    amClient    =    null ;", "try    {", "amClient    =     (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  )  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "assertEquals (  0  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "AMRMClient . ContainerRequest   storedContainer 1     =    new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  ;", "amClient . addContainerRequest ( storedContainer 1  )  ;", "assertEquals (  3  ,    amClient . ask . size (  )  )  ;", "assertEquals (  0  ,    amClient . release . size (  )  )  ;", "List < String >    localNodeBlacklist    =    new   ArrayList < String >  (  )  ;", "localNodeBlacklist . add (  . node )  ;", "amClient . updateBlacklist ( localNodeBlacklist ,    null )  ;", "int   allocatedContainerCount    =    getAllocatedContainersNumber ( amClient ,     . DEFAULT _ ITERATION )  ;", "assertEquals (  0  ,    allocatedContainerCount )  ;", "amClient . updateBlacklist ( null ,    localNodeBlacklist )  ;", "AMRMClient . ContainerRequest   storedContainer 2     =    new   AMRMClient . ContainerRequest (  . capability ,     . nodes ,     . racks ,     . priority )  ;", "amClient . addContainerRequest ( storedContainer 2  )  ;", "allocatedContainerCount    =    getAllocatedContainersNumber ( amClient ,     . DEFAULT _ ITERATION )  ;", "assertEquals (  2  ,    allocatedContainerCount )  ;", "assertTrue ( amClient . blacklistAdditions . isEmpty (  )  )  ;", "assertTrue ( amClient . blacklistRemovals . isEmpty (  )  )  ;", "AMRMClient . ContainerRequest   invalidContainerRequest    =    new   AMRMClient . ContainerRequest ( Resource . newInstance (  (  -  1  0  2  4  )  ,     1  )  ,     . nodes ,     . racks ,     . priority )  ;", "amClient . addContainerRequest ( invalidContainerRequest )  ;", "amClient . updateBlacklist ( localNodeBlacklist ,    null )  ;", "try    {", "amClient . allocate (  0  .  1 F )  ;", "fail (  \" there   should   be   an   exception   here .  \"  )  ;", "}    catch    ( Exception   e )     {", "assertEquals (  1  ,    amClient . blacklistAdditions . size (  )  )  ;", "}", "}    finally    {", "if    (  ( amClient    !  =    null )     &  &     (  ( amClient . getServiceState (  )  )     =  =     ( STATE . STARTED )  )  )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testAllocationWithBlacklist"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    amClient    =    null ;", ". CountDownSupplier   countDownChecker    =    new    . CountDownSupplier (  )  ;", "try    {", "amClient    =     (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  )  )  ;", "amClient . init ( new   YarnConfiguration (  )  )  ;", "amClient . start (  )  ;", "amClient . waitFor ( countDownChecker ,     1  0  0  0  )  ;", "assertEquals (  3  ,    countDownChecker . counter )  ;", "}    finally    {", "if    ( amClient    !  =    null )     {", "amClient . stop (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testWaitFor"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  1  ,    matches . size (  )  )  ;", "assertEquals ( matches . get (  0  )  . size (  )  ,    matchSize )  ;", "}", "METHOD_END"], "methodName": ["verifyMatches"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClient"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    client    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setClass ( NET _ TOPOLOGY _ NODE _ SWITCH _ MAPPING _ IMPL _ KEY ,     . MyResolver . class ,    DNSToSwitchMapping . class )  ;", "client . init ( conf )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "AMRMClient . ContainerRequest   request 1     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( request 1  )  ;", "AMRMClient . ContainerRequest   request 2     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 3  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    true )  ;", "client . addContainerRequest ( request 2  )  ;", "}", "METHOD_END"], "methodName": ["testDifferentLocalityRelaxationSamePriority"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    client    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setClass ( NET _ TOPOLOGY _ NODE _ SWITCH _ MAPPING _ IMPL _ KEY ,     . MyResolver . class ,    DNSToSwitchMapping . class )  ;", "client . init ( conf )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "AMRMClient . ContainerRequest   nodeLevelRequest    =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( nodeLevelRequest )  ;", "verifyResourceRequest ( client ,    nodeLevelRequest ,    ANY ,    false )  ;", "verifyResourceRequest ( client ,    nodeLevelRequest ,     \"  / rack 1  \"  ,    false )  ;", "verifyResourceRequest ( client ,    nodeLevelRequest ,     \" host 1  \"  ,    true )  ;", "verifyResourceRequest ( client ,    nodeLevelRequest ,     \" host 2  \"  ,    true )  ;", "AMRMClient . ContainerRequest   nodeLevelRequest 2     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 2  \"  ,     \" host 3  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( nodeLevelRequest 2  )  ;", "AMRMClient . ContainerRequest   rackLevelRequest    =    new   AMRMClient . ContainerRequest ( capability ,    null ,    new   String [  ]  {     \"  / rack 3  \"  ,     \"  / rack 4  \"     }  ,    Priority . newInstance (  2  )  ,    false )  ;", "client . addContainerRequest ( rackLevelRequest )  ;", "verifyResourceRequest ( client ,    rackLevelRequest ,    ANY ,    false )  ;", "verifyResourceRequest ( client ,    rackLevelRequest ,     \"  / rack 3  \"  ,    true )  ;", "verifyResourceRequest ( client ,    rackLevelRequest ,     \"  / rack 4  \"  ,    true )  ;", "AMRMClient . ContainerRequest   rackLevelRequest 2     =    new   AMRMClient . ContainerRequest ( capability ,    null ,    new   String [  ]  {     \"  / rack 4  \"  ,     \"  / rack 5  \"     }  ,    Priority . newInstance (  2  )  ,    false )  ;", "client . addContainerRequest ( rackLevelRequest 2  )  ;", "AMRMClient . ContainerRequest   bothLevelRequest    =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 3  \"  ,     \" host 4  \"     }  ,    new   String [  ]  {     \" rack 1  \"  ,     \"  / otherrack \"     }  ,    Priority . newInstance (  3  )  ,    false )  ;", "client . addContainerRequest ( bothLevelRequest )  ;", "verifyResourceRequest ( client ,    bothLevelRequest ,    ANY ,    false )  ;", "verifyResourceRequest ( client ,    bothLevelRequest ,     \" rack 1  \"  ,    true )  ;", "verifyResourceRequest ( client ,    bothLevelRequest ,     \"  / otherrack \"  ,    true )  ;", "verifyResourceRequest ( client ,    bothLevelRequest ,     \" host 3  \"  ,    true )  ;", "verifyResourceRequest ( client ,    bothLevelRequest ,     \" host 4  \"  ,    true )  ;", "AMRMClient . ContainerRequest   bothLevelRequest 2     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 4  \"  ,     \" host 5  \"     }  ,    new   String [  ]  {     \" rack 1  \"  ,     \"  / otherrack 2  \"     }  ,    Priority . newInstance (  3  )  ,    false )  ;", "client . addContainerRequest ( bothLevelRequest 2  )  ;", "}", "METHOD_END"], "methodName": ["testDisableLocalityRelaxation"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    client    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setClass ( NET _ TOPOLOGY _ NODE _ SWITCH _ MAPPING _ IMPL _ KEY ,     . MyResolver . class ,    DNSToSwitchMapping . class )  ;", "client . init ( conf )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "AMRMClient . ContainerRequest   request    =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    new   String [  ]  {     \"  / rack 2  \"     }  ,    Priority . newInstance (  1  )  )  ;", "client . addContainerRequest ( request )  ;", "verifyResourceRequest ( client ,    request ,     \" host 1  \"  ,    true )  ;", "verifyResourceRequest ( client ,    request ,     \" host 2  \"  ,    true )  ;", "verifyResourceRequest ( client ,    request ,     \"  / rack 1  \"  ,    true )  ;", "verifyResourceRequest ( client ,    request ,     \"  / rack 2  \"  ,    true )  ;", "verifyResourceRequest ( client ,    request ,    ANY ,    true )  ;", "}", "METHOD_END"], "methodName": ["testFillInRacks"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    client    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setClass ( NET _ TOPOLOGY _ NODE _ SWITCH _ MAPPING _ IMPL _ KEY ,     . MyResolver . class ,    DNSToSwitchMapping . class )  ;", "client . init ( conf )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "AMRMClient . ContainerRequest   request 1     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( request 1  )  ;", "client . removeContainerRequest ( request 1  )  ;", "AMRMClient . ContainerRequest   request 2     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 3  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    true )  ;", "client . addContainerRequest ( request 2  )  ;", "client . removeContainerRequest ( request 2  )  ;", "AMRMClient . ContainerRequest   request 3     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( request 3  )  ;", "client . removeContainerRequest ( request 3  )  ;", "AMRMClient . ContainerRequest   request 4     =    new   AMRMClient . ContainerRequest ( capability ,    null ,    new   String [  ]  {     \" rack 1  \"     }  ,    Priority . newInstance (  1  )  ,    true )  ;", "client . addContainerRequest ( request 4  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidValidWhenOldRemoved"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "AMRMClientImpl < AMRMClient . ContainerRequest >    client    =    new   AMRMClientImpl < AMRMClient . ContainerRequest >  (  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setClass ( NET _ TOPOLOGY _ NODE _ SWITCH _ MAPPING _ IMPL _ KEY ,     . MyResolver . class ,    DNSToSwitchMapping . class )  ;", "client . init ( conf )  ;", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     1  )  ;", "AMRMClient . ContainerRequest   request 1     =    new   AMRMClient . ContainerRequest ( capability ,    new   String [  ]  {     \" host 1  \"  ,     \" host 2  \"     }  ,    null ,    Priority . newInstance (  1  )  ,    false )  ;", "client . addContainerRequest ( request 1  )  ;", "AMRMClient . ContainerRequest   request 2     =    new   AMRMClient . ContainerRequest ( capability ,    null ,    new   String [  ]  {     \" rack 1  \"     }  ,    Priority . newInstance (  1  )  ,    true )  ;", "client . addContainerRequest ( request 2  )  ;", "}", "METHOD_END"], "methodName": ["testLocalityRelaxationDifferentLevels"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "ResourceRequest   ask    =    client . remoteRequestsTable . get ( request . getPriority (  )  )  . get ( location )  . get ( request . getCapability (  )  )  . remoteRequest ;", "assertEquals ( location ,    ask . getResourceName (  )  )  ;", "assertEquals (  1  ,    ask . getNums (  )  )  ;", "assertEquals ( expectedRelaxLocality ,    ask . getRelaxLocality (  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyResourceRequest"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientContainerRequest"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( expectedAsk ,    rm . getMyFifoScheduler (  )  . lastAsk . size (  )  )  ;", "Assert . assertEquals ( expectedRelease ,    rm . getMyFifoScheduler (  )  . lastRelease . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertAsksAndReleases"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( expectedAdditions ,    rm . getMyFifoScheduler (  )  . lastBlacklistAdditions . size (  )  )  ;", "Assert . assertEquals ( expectedRemovals ,    rm . getMyFifoScheduler (  )  . lastBlacklistRemovals . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertBlacklistAdditionsAndRemovals"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "Resource   capability    =    Resource . newInstance ( memory ,     1  )  ;", "Priority   priorityOfContainer    =    Priority . newInstance ( priority )  ;", "return   new    . ContainerRequest ( capability ,    hosts ,    new   String [  ]  {    NetworkTopology . DEFAULT _ RACK    }  ,    priorityOfContainer )  ;", "}", "METHOD_END"], "methodName": ["createReq"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClientOnRMRestart . conf    =    new   Configuration (  )  ;", "TestAMRMClientOnRMRestart . conf . set ( RECOVERY _ ENABLED ,     \" true \"  )  ;", "TestAMRMClientOnRMRestart . conf . set ( RM _ STORE ,    MemoryRMStateStore . class . getName (  )  )  ;", "TestAMRMClientOnRMRestart . conf . setInt ( RM _ AM _ MAX _ ATTEMPTS ,    DEFAULT _ RM _ AM _ MAX _ ATTEMPTS )  ;", "TestAMRMClientOnRMRestart . conf . setBoolean ( RM _ WORK _ PRESERVING _ RECOVERY _ ENABLED ,    true )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "MemoryRMStateStore   memStore    =    new   MemoryRMStateStore (  )  ;", "memStore . init (  . conf )  ;", ". MyResourceManager   rm 1     =    new    . MyResourceManager (  . conf ,    memStore )  ;", "rm 1  . start (  )  ;", "DrainDispatcher   dispatcher    =     (  ( DrainDispatcher )     ( rm 1  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "RMApp   app    =    rm 1  . submitApp (  1  0  2  4  )  ;", "dispatcher . await (  )  ;", "MockNM   nm 1     =    new   MockNM (  \" h 1  :  1  2  3  4  \"  ,     1  5  1  2  0  ,    rm 1  . getResourceTrackerService (  )  )  ;", "nm 1  . registerNode (  )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "ApplicationAttemptId   appAttemptId    =    app . getCurrentAppAttempt (  )  . getAppAttemptId (  )  ;", "rm 1  . sendAMLaunched ( appAttemptId )  ;", "dispatcher . await (  )  ;", "Token < AMRMTokenIdentifier >    token    =    rm 1  . getRMContext (  )  . getRMApps (  )  . get ( appAttemptId . getApplicationId (  )  )  . getRMAppAttempt ( appAttemptId )  . getAMRMToken (  )  ;", "UserGroupInformation   ugi    =    UserGroupInformation . getCurrentUser (  )  ;", "ugi . addTokenIdentifier ( token . decodeIdentifier (  )  )  ;", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    new    . MyAMRMClientImpl ( rm 1  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" h 1  \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "amClient . allocate (  0  .  1 F )  ;", ". MyResourceManager   rm 2     =    new    . MyResourceManager (  . conf ,    memStore )  ;", "rm 2  . start (  )  ;", "nm 1  . setResourceTrackerService ( rm 2  . getResourceTrackerService (  )  )  ;", "(  (  . MyAMRMClientImpl )     ( amClient )  )  . updateRMProxy ( rm 2  )  ;", "dispatcher    =     (  ( DrainDispatcher )     ( rm 2  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "NodeHeartbeatResponse   hbResponse    =    nm 1  . nodeHeartbeat ( true )  ;", "Assert . assertEquals ( RESYNC ,    hbResponse . getNodeAction (  )  )  ;", "nm 1     =    new   MockNM (  \" h 1  :  1  2  3  4  \"  ,     1  0  2  4  0  ,    rm 2  . getResourceTrackerService (  )  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( appAttemptId ,     1  )  ;", "NMContainerStatus   containerReport    =    NMContainerStatus . newInstance ( containerId ,    RUNNING ,    Resource . newInstance (  1  0  2  4  ,     1  )  ,     \" recover   container \"  ,     0  ,    Priority . newInstance (  0  )  ,     0  )  ;", "nm 1  . registerNode ( Arrays . asList ( containerReport )  ,    null )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "rm 2  . waitForState ( appAttemptId ,    FINISHING )  ;", "nm 1  . nodeHeartbeat ( appAttemptId ,     1  ,    COMPLETE )  ;", "rm 2  . waitForState ( appAttemptId ,    FINISHED )  ;", "rm 2  . waitForState ( app . getApplicationId (  )  ,    RMAppState . FINISHED )  ;", "amClient . stop (  )  ;", "rm 1  . stop (  )  ;", "rm 2  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientForUnregisterAMOnRMRestart"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "TestAMRMClientOnRMRestart . conf . setLong ( RM _ AMRM _ TOKEN _ MASTER _ KEY _ ROLLING _ INTERVAL _ SECS ,    TestAMRMClientOnRMRestart . rolling _ interval _ sec )  ;", "TestAMRMClientOnRMRestart . conf . setLong ( RM _ AM _ EXPIRY _ INTERVAL _ MS ,    TestAMRMClientOnRMRestart . am _ expire _ ms )  ;", "MemoryRMStateStore   memStore    =    new   MemoryRMStateStore (  )  ;", "memStore . init ( TestAMRMClientOnRMRestart . conf )  ;", "TestAMRMClientOnRMRestart . MyResourceManager 2    rm 1     =    new   TestAMRMClientOnRMRestart . MyResourceManager 2  ( TestAMRMClientOnRMRestart . conf ,    memStore )  ;", "rm 1  . start (  )  ;", "DrainDispatcher   dispatcher    =     (  ( DrainDispatcher )     ( rm 1  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "Long   startTime    =    System . currentTimeMillis (  )  ;", "RMApp   app    =    rm 1  . submitApp (  1  0  2  4  )  ;", "dispatcher . await (  )  ;", "MockNM   nm 1     =    new   MockNM (  \" h 1  :  1  2  3  4  \"  ,     1  5  1  2  0  ,    rm 1  . getResourceTrackerService (  )  )  ;", "nm 1  . registerNode (  )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "ApplicationAttemptId   appAttemptId    =    app . getCurrentAppAttempt (  )  . getAppAttemptId (  )  ;", "rm 1  . sendAMLaunched ( appAttemptId )  ;", "dispatcher . await (  )  ;", "AMRMTokenSecretManager   amrmTokenSecretManagerForRM 1     =    rm 1  . getRMContext (  )  . getAMRMTokenSecretManager (  )  ;", "Token < AMRMTokenIdentifier >    token    =    amrmTokenSecretManagerForRM 1  . createAndGetAMRMToken ( appAttemptId )  ;", "UserGroupInformation   ugi    =    UserGroupInformation . getCurrentUser (  )  ;", "ugi . addTokenIdentifier ( token . decodeIdentifier (  )  )  ;", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    new   TestAMRMClientOnRMRestart . MyAMRMClientImpl ( rm 1  )  ;", "amClient . init ( TestAMRMClientOnRMRestart . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" h 1  \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "amClient . allocate (  0  .  1 F )  ;", "while    (  (  ( System . currentTimeMillis (  )  )     -    startTime )     <     (  ( TestAMRMClientOnRMRestart . rolling _ interval _ sec )     *     1  0  0  0  )  )     {", "amClient . allocate (  0  .  1 F )  ;", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "}", "Assert . assertTrue (  (  ( amrmTokenSecretManagerForRM 1  . getMasterKey (  )  . getMasterKey (  )  . getKeyId (  )  )     !  =     ( token . decodeIdentifier (  )  . getKeyId (  )  )  )  )  ;", "amClient . allocate (  0  .  1 F )  ;", "Token < AMRMTokenIdentifier >    newToken    =    amrmTokenSecretManagerForRM 1  . createAndGetAMRMToken ( appAttemptId )  ;", "int   waitCount    =     0  ;", "while    (  ( waitCount +  +  )     <  =     5  0  )     {", "if    (  ( amrmTokenSecretManagerForRM 1  . getCurrnetMasterKeyData (  )  . getMasterKey (  )  . getKeyId (  )  )     !  =     ( token . decodeIdentifier (  )  . getKeyId (  )  )  )     {", "break ;", "}", "try    {", "amClient . allocate (  0  .  1 F )  ;", "}    catch    ( Exception   ex )     {", "break ;", "}", "Thread . sleep (  5  0  0  )  ;", "}", "Assert . assertTrue (  (  ( amrmTokenSecretManagerForRM 1  . getNextMasterKeyData (  )  )     =  =    null )  )  ;", "Assert . assertTrue (  (  ( amrmTokenSecretManagerForRM 1  . getCurrnetMasterKeyData (  )  . getMasterKey (  )  . getKeyId (  )  )     =  =     ( newToken . decodeIdentifier (  )  . getKeyId (  )  )  )  )  ;", "TestAMRMClientOnRMRestart . conf . set ( RM _ SCHEDULER _ ADDRESS ,     \"  0  .  0  .  0  .  0  :  9  0  3  0  \"  )  ;", "final   TestAMRMClientOnRMRestart . MyResourceManager 2    rm 2     =    new   TestAMRMClientOnRMRestart . MyResourceManager 2  ( TestAMRMClientOnRMRestart . conf ,    memStore )  ;", "rm 2  . start (  )  ;", "nm 1  . setResourceTrackerService ( rm 2  . getResourceTrackerService (  )  )  ;", "(  ( TestAMRMClientOnRMRestart . MyAMRMClientImpl )     ( amClient )  )  . updateRMProxy ( rm 2  )  ;", "dispatcher    =     (  ( DrainDispatcher )     ( rm 2  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "AMRMTokenSecretManager   amrmTokenSecretManagerForRM 2     =    rm 2  . getRMContext (  )  . getAMRMTokenSecretManager (  )  ;", "Assert . assertTrue (  (  ( amrmTokenSecretManagerForRM 2  . getCurrnetMasterKeyData (  )  . getMasterKey (  )  . getKeyId (  )  )     =  =     ( newToken . decodeIdentifier (  )  . getKeyId (  )  )  )  )  ;", "Assert . assertTrue (  (  ( amrmTokenSecretManagerForRM 2  . getNextMasterKeyData (  )  )     =  =    null )  )  ;", "try    {", "UserGroupInformation   testUser    =    UserGroupInformation . createRemoteUser (  \" testUser \"  )  ;", "SecurityUtil . setTokenService ( token ,    rm 2  . getApplicationMasterService (  )  . getBindAddress (  )  )  ;", "testUser . addToken ( token )  ;", "testUser . doAs ( new   PrivilegedAction < ApplicationMasterProtocol >  (  )     {", "@ Override", "public   ApplicationMasterProtocol   run (  )     {", "return    (  ( ApplicationMasterProtocol )     ( YarnRPC . create ( TestAMRMClientOnRMRestart . conf )  . getProxy ( ApplicationMasterProtocol . class ,    rm 2  . getApplicationMasterService (  )  . getBindAddress (  )  ,    TestAMRMClientOnRMRestart . conf )  )  )  ;", "}", "}  )  . allocate ( Records . newRecord ( AllocateRequest . class )  )  ;", "Assert . fail (  \" The   old   Token   should   not   work \"  )  ;", "}    catch    ( Exception   ex )     {", "Assert . assertTrue (  ( ex   instanceof   InvalidToken )  )  ;", "Assert . assertTrue ( ex . getMessage (  )  . contains (  (  \" Invalid   AMRMToken   from    \"     +     ( token . decodeIdentifier (  )  . getApplicationAttemptId (  )  )  )  )  )  ;", "}", "amClient . allocate (  0  .  1 F )  ;", "amClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "amClient . stop (  )  ;", "rm 1  . stop (  )  ;", "rm 2  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientOnAMRMTokenRollOverOnRMRestart"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "UserGroupInformation . setLoginUser ( null )  ;", "MemoryRMStateStore   memStore    =    new   MemoryRMStateStore (  )  ;", "memStore . init (  . conf )  ;", ". MyResourceManager   rm 1     =    new    . MyResourceManager (  . conf ,    memStore )  ;", "rm 1  . start (  )  ;", "DrainDispatcher   dispatcher    =     (  ( DrainDispatcher )     ( rm 1  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "RMApp   app    =    rm 1  . submitApp (  1  0  2  4  )  ;", "dispatcher . await (  )  ;", "MockNM   nm 1     =    new   MockNM (  \" h 1  :  1  2  3  4  \"  ,     1  5  1  2  0  ,    rm 1  . getResourceTrackerService (  )  )  ;", "nm 1  . registerNode (  )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "ApplicationAttemptId   appAttemptId    =    app . getCurrentAppAttempt (  )  . getAppAttemptId (  )  ;", "rm 1  . sendAMLaunched ( appAttemptId )  ;", "dispatcher . await (  )  ;", "Token < AMRMTokenIdentifier >    token    =    rm 1  . getRMContext (  )  . getRMApps (  )  . get ( appAttemptId . getApplicationId (  )  )  . getRMAppAttempt ( appAttemptId )  . getAMRMToken (  )  ;", "UserGroupInformation   ugi    =    UserGroupInformation . getCurrentUser (  )  ;", "ugi . addTokenIdentifier ( token . decodeIdentifier (  )  )  ;", "AMRMClient < AMRMClient . ContainerRequest >    amClient    =    new    . MyAMRMClientImpl ( rm 1  )  ;", "amClient . init (  . conf )  ;", "amClient . start (  )  ;", "amClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "AMRMClient . ContainerRequest   cRequest 1     =    createReq (  1  ,     1  0  2  4  ,    new   String [  ]  {     \" h 1  \"     }  )  ;", "amClient . addContainerRequest ( cRequest 1  )  ;", "AMRMClient . ContainerRequest   cRequest 2     =    createReq (  1  ,     1  0  2  4  ,    new   String [  ]  {     \" h 1  \"  ,     \" h 2  \"     }  )  ;", "amClient . addContainerRequest ( cRequest 2  )  ;", "List < String >    blacklistAdditions    =    new   ArrayList < String >  (  )  ;", "List < String >    blacklistRemoval    =    new   ArrayList < String >  (  )  ;", "blacklistAdditions . add (  \" h 2  \"  )  ;", "blacklistRemoval . add (  \" h 1  0  \"  )  ;", "amClient . updateBlacklist ( blacklistAdditions ,    blacklistRemoval )  ;", "blacklistAdditions . remove (  \" h 2  \"  )  ;", "AllocateResponse   allocateResponse    =    amClient . allocate (  0  .  1 F )  ;", "dispatcher . await (  )  ;", "Assert . assertEquals (  \" No   of   assignments   must   be    0  \"  ,     0  ,    allocateResponse . getAllocatedContainers (  )  . size (  )  )  ;", ". assertAsksAndReleases (  4  ,     0  ,    rm 1  )  ;", ". assertBlacklistAdditionsAndRemovals (  1  ,     1  ,    rm 1  )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "allocateResponse    =    amClient . allocate (  0  .  2 F )  ;", "dispatcher . await (  )  ;", "Assert . assertEquals (  \" No   of   assignments   must   be    0  \"  ,     2  ,    allocateResponse . getAllocatedContainers (  )  . size (  )  )  ;", ". assertAsksAndReleases (  0  ,     0  ,    rm 1  )  ;", ". assertBlacklistAdditionsAndRemovals (  0  ,     0  ,    rm 1  )  ;", "List < Container >    allocatedContainers    =    allocateResponse . getAllocatedContainers (  )  ;", "amClient . removeContainerRequest ( cRequest 1  )  ;", "amClient . removeContainerRequest ( cRequest 2  )  ;", "allocateResponse    =    amClient . allocate (  0  .  2 F )  ;", "dispatcher . await (  )  ;", "Assert . assertEquals (  \" No   of   assignments   must   be    0  \"  ,     0  ,    allocateResponse . getAllocatedContainers (  )  . size (  )  )  ;", ". assertAsksAndReleases (  4  ,     0  ,    rm 1  )  ;", ". assertBlacklistAdditionsAndRemovals (  0  ,     0  ,    rm 1  )  ;", "AMRMClient . ContainerRequest   cRequest 3     =    createReq (  1  ,     1  0  2  4  ,    new   String [  ]  {     \" h 1  \"     }  )  ;", "amClient . addContainerRequest ( cRequest 3  )  ;", "int   pendingRelease    =     0  ;", "Iterator < Container >    it    =    allocatedContainers . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "amClient . releaseAssignedContainer ( it . next (  )  . getId (  )  )  ;", "pendingRelease +  +  ;", "it . remove (  )  ;", "break ;", "}", "allocateResponse    =    amClient . allocate (  0  .  3 F )  ;", "dispatcher . await (  )  ;", "Assert . assertEquals (  \" No   of   assignments   must   be    0  \"  ,     0  ,    allocateResponse . getAllocatedContainers (  )  . size (  )  )  ;", ". assertAsksAndReleases (  3  ,    pendingRelease ,    rm 1  )  ;", ". assertBlacklistAdditionsAndRemovals (  0  ,     0  ,    rm 1  )  ;", "int   completedContainer    =    allocateResponse . getCompletedContainersStatuses (  )  . size (  )  ;", "pendingRelease    -  =    completedContainer ;", ". MyResourceManager   rm 2     =    new    . MyResourceManager (  . conf ,    memStore )  ;", "rm 2  . start (  )  ;", "nm 1  . setResourceTrackerService ( rm 2  . getResourceTrackerService (  )  )  ;", "(  (  . MyAMRMClientImpl )     ( amClient )  )  . updateRMProxy ( rm 2  )  ;", "dispatcher    =     (  ( DrainDispatcher )     ( rm 2  . getRMContext (  )  . getDispatcher (  )  )  )  ;", "NodeHeartbeatResponse   hbResponse    =    nm 1  . nodeHeartbeat ( true )  ;", "Assert . assertEquals ( RESYNC ,    hbResponse . getNodeAction (  )  )  ;", "nm 1     =    new   MockNM (  \" h 1  :  1  2  3  4  \"  ,     1  0  2  4  0  ,    rm 2  . getResourceTrackerService (  )  )  ;", "nm 1  . registerNode (  )  ;", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "blacklistAdditions . add (  \" h 3  \"  )  ;", "amClient . updateBlacklist ( blacklistAdditions ,    null )  ;", "blacklistAdditions . remove (  \" h 3  \"  )  ;", "it    =    allocatedContainers . iterator (  )  ;", "while    ( it . hasNext (  )  )     {", "amClient . releaseAssignedContainer ( it . next (  )  . getId (  )  )  ;", "pendingRelease +  +  ;", "it . remove (  )  ;", "}", "AMRMClient . ContainerRequest   cRequest 4     =    createReq (  1  ,     1  0  2  4  ,    new   String [  ]  {     \" h 1  \"  ,     \" h 2  \"     }  )  ;", "amClient . addContainerRequest ( cRequest 4  )  ;", "allocateResponse    =    amClient . allocate (  0  .  3 F )  ;", "dispatcher . await (  )  ;", "completedContainer    =    allocateResponse . getCompletedContainersStatuses (  )  . size (  )  ;", "pendingRelease    -  =    completedContainer ;", ". assertAsksAndReleases (  4  ,    pendingRelease ,    rm 2  )  ;", ". assertBlacklistAdditionsAndRemovals (  2  ,     0  ,    rm 2  )  ;", "AMRMClient . ContainerRequest   cRequest 5     =    createReq (  1  ,     1  0  2  4  ,    new   String [  ]  {     \" h 1  \"  ,     \" h 2  \"  ,     \" h 3  \"     }  )  ;", "amClient . addContainerRequest ( cRequest 5  )  ;", "allocateResponse    =    amClient . allocate (  0  .  5 F )  ;", "dispatcher . await (  )  ;", "Assert . assertEquals (  \" No   of   assignments   must   be    0  \"  ,     0  ,    allocateResponse . getAllocatedContainers (  )  . size (  )  )  ;", ". assertAsksAndReleases (  5  ,     0  ,    rm 2  )  ;", ". assertBlacklistAdditionsAndRemovals (  0  ,     0  ,    rm 2  )  ;", "int   noAssignedContainer    =     0  ;", "int   count    =     5  ;", "while    (  ( count -  -  )     >     0  )     {", "nm 1  . nodeHeartbeat ( true )  ;", "dispatcher . await (  )  ;", "allocateResponse    =    amClient . allocate (  0  .  5 F )  ;", "dispatcher . await (  )  ;", "noAssignedContainer    +  =    allocateResponse . getAllocatedContainers (  )  . size (  )  ;", "if    ( noAssignedContainer    =  =     3  )     {", "break ;", "}", "Thread . sleep (  1  0  0  0  )  ;", "}", "Assert . assertEquals (  \" Number   of   container   should   be    3  \"  ,     3  ,    noAssignedContainer )  ;", "amClient . stop (  )  ;", "rm 1  . stop (  )  ;", "rm 2  . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAMRMClientResendsRequestsOnRMRestart"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart"}, {"methodBody": ["METHOD_START", "{", "Resource   capability    =    Resource . newInstance (  1  0  2  4  ,     0  )  ;", "Priority   priority    =    Priority . newInstance (  0  )  ;", "String   node    =    nodeReports . get (  0  )  . getNodeId (  )  . getHost (  )  ;", "String   rack    =    nodeReports . get (  0  )  . getRackName (  )  ;", "String [  ]    nodes    =    new   String [  ]  {    node    }  ;", "String [  ]    racks    =    new   String [  ]  {    rack    }  ;", "for    ( int   i    =     0  ;    i    <    num ;     +  + i )     {", "rmCddContainerRequest ( new   AMRMClient . ContainerRequest ( capability ,    nodes ,    racks ,    priority )  )  ;", "}", "int   containersRequestedAny    =    rmClient . remoteRequestsTable . get ( priority )  . get ( ANY )  . get ( capability )  . remoteRequest . getNumContainers (  )  ;", "int   allocatedContainerCount    =     0  ;", "int   iterationsLeft    =     2  ;", "Set < Container >    containers    =    new   TreeSet < Container >  (  )  ;", "while    (  ( allocatedContainerCount    <    containersRequestedAny )     &  &     ( iterationsLeft    >     0  )  )     {", "AllocateResponse   allocResponse    =    rmCllocate (  0  .  1 F )  ;", "allocatedContainerCount    +  =    allocResponse . getAllocatedContainers (  )  . size (  )  ;", "for    ( Container   container    :    allocResponse . getAllocatedContainers (  )  )     {", "containers . add ( container )  ;", "}", "if    (  !  ( allocResponse . getNMTokens (  )  . isEmpty (  )  )  )     {", "for    ( NMToken   token    :    allocResponse . getNMTokens (  )  )     {", "rmClient . getNMTokenCache (  )  . setToken ( token . getNodeId (  )  . toString (  )  ,    token . getToken (  )  )  ;", "}", "}", "if    ( allocatedContainerCount    <    containersRequestedAny )     {", "sleep (  1  0  0  0  )  ;", "}", "-  - iterationsLeft ;", "}", "return   containers ;", "}", "METHOD_END"], "methodName": ["allocateContainers"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "conf    =    new   YarnConfiguration (  )  ;", "yarnCluster    =    new   MiniYARNCluster ( TestAMRMClient . class . getName (  )  ,    nodeCount ,     1  ,     1  )  ;", "yarnCluster . init ( conf )  ;", "yarnCluster . start (  )  ;", "assertNotNull ( yarnCluster )  ;", "assertEquals ( STARTED ,    yarnCluster . getServiceState (  )  )  ;", "yarnClient    =     (  ( YarnClientImpl )     ( YarnClient . createYarnClient (  )  )  )  ;", "yarnClient . init ( conf )  ;", "yarnClient . start (  )  ;", "assertNotNull ( yarnClient )  ;", "assertEquals ( STARTED ,    yarnClient . getServiceState (  )  )  ;", "nodeReports    =    yarnClient . getNodeReports ( RUNNING )  ;", "ApplicationSubmissionContext   appContext    =    yarnClient . createApplication (  )  . getApplicationSubmissionContext (  )  ;", "ApplicationId   appId    =    appContext . getApplicationId (  )  ;", "appContext . setApplicationName (  \" Test \"  )  ;", "Priority   pri    =    Priority . newInstance (  0  )  ;", "appContext . setPriority ( pri )  ;", "appContext . setQueue (  \" default \"  )  ;", "ContainerLaunchContext   amContainer    =    Records . newRecord ( ContainerLaunchContext . class )  ;", "appContext . setAMContainerSpec ( amContainer )  ;", "appContext . setUnmanagedAM ( true )  ;", "SubmitApplicationRequest   appRequest    =    Records . newRecord ( SubmitApplicationRequest . class )  ;", "appRequest . setApplicationSubmissionContext ( appContext )  ;", "yarnClient . submitApplication ( appContext )  ;", "int   iterationsLeft    =     3  0  ;", "RMAppAttempt   appAttempt    =    null ;", "while    ( iterationsLeft    >     0  )     {", "ApplicationReport   appReport    =    yarnClient . getApplicationReport ( appId )  ;", "if    (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . ACCEPTED )  )     {", "attemptId    =    appReport . getCurrentApplicationAttemptId (  )  ;", "appAttempt    =    yarnCluster . getResourceManager (  )  . getRMContext (  )  . getRMApps (  )  . get ( attemptId . getApplicationId (  )  )  . getCurrentAppAttempt (  )  ;", "while    ( true )     {", "if    (  ( appAttempt . getAppAttemptState (  )  )     =  =     ( RMAppAttemptState . LAUNCHED )  )     {", "break ;", "}", "}", "break ;", "}", "sleep (  1  0  0  0  )  ;", "-  - iterationsLeft ;", "}", "if    ( iterationsLeft    =  =     0  )     {", "fail (  \" Application   hasn ' t   bee   started \"  )  ;", "}", "UserGroupInformation . setLoginUser ( UserGroupInformation . createRemoteUser ( UserGroupInformation . getCurrentUser (  )  . getUserName (  )  )  )  ;", "UserGroupInformation . getCurrentUser (  )  . addToken ( appAttempt . getAMRMToken (  )  )  ;", "nmTokenCache    =    new   NMTokenCache (  )  ;", "rmClient    =     (  ( AMRMClientImpl < AMRMClient . ContainerRequest >  )     ( AMRMClient .  < AMRMClient . ContainerRequest > createAMRMClient (  )  )  )  ;", "rmClient . setNMTokenCache ( nmTokenCache )  ;", "rmClient . init ( conf )  ;", "rmClient . start (  )  ;", "assertNotNull ( rmClient )  ;", "assertEquals ( STARTED ,    rmClient . getServiceState (  )  )  ;", "nmClient    =     (  ( Impl )     (  . create (  )  )  )  ;", "nmClient . setNMTokenCache ( rmClient . getNMTokenCache (  )  )  ;", "nmClient . init ( conf )  ;", "nmClient . start (  )  ;", "assertNotNull ( nmClient )  ;", "assertEquals ( STARTED ,    nmClient . getServiceState (  )  )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thre . sleep ( sleepTime )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "METHOD_END"], "methodName": ["sleep"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "assertNotNull (  \" Null   nmClient \"  ,    nmClient )  ;", "assertEquals (  1  ,    nmClient . startedContainers . size (  )  )  ;", "assertTrue ( nmClient . getCleanupRunningContainers (  )  . get (  )  )  ;", "nmClient . cleanupRunningContainersOnStop ( stopContainers )  ;", "assertEquals ( stopContainers ,    nmClient . getCleanupRunningContainers (  )  . get (  )  )  ;", "nmClient . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stopNmClient"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "rmClient . stop (  )  ;", "yarnClient . stop (  )  ;", "yarnCluster . stop (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "int   size    =    containers . size (  )  ;", "int   i    =     0  ;", "for    ( Container   container    :    containers )     {", "try    {", "nmCgetContainerStatus ( container . getId (  )  ,    container . getNodeId (  )  )  ;", "fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( YarnException   e )     {", "assertTrue (  \" The   thrown   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" is   not   handled   by   this   NodeManager \"  )  )  ;", "}", "try    {", "nmCstopContainer ( container . getId (  )  ,    container . getNodeId (  )  )  ;", "fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( YarnException   e )     {", "if    (  !  ( e . getMessage (  )  . contains (  \" is   not   handled   by   this   NodeManager \"  )  )  )     {", "throw    (  ( AssertionError )     ( new   AssertionError (  (  \" Exception   is   not   expected :     \"     +    e )  )  . initCause ( e )  )  )  ;", "}", "}", "Credentials   ts    =    new   Credentials (  )  ;", "DataOutputBuffer   dob    =    new   DataOutputBuffer (  )  ;", "ts . writeTokenStorageToStream ( dob )  ;", "ByteBuffer   securityTokens    =    ByteBuffer . wrap ( dob . getData (  )  ,     0  ,    dob . getLength (  )  )  ;", "ContainerLaunchContext   clc    =    Records . newRecord ( ContainerLaunchContext . class )  ;", "clc . setTokens ( securityTokens )  ;", "try    {", "nmCstartContainer ( container ,    clc )  ;", "}    catch    ( YarnException   e )     {", "throw    (  ( AssertionError )     ( new   AssertionError (  (  \" Exception   is   not   expected :     \"     +    e )  )  . initCause ( e )  )  )  ;", "}", "if    (  (  +  + i )     <    size )     {", "testGetContainerStatus ( container ,    i ,    RUNNING ,     \"  \"  ,    Arrays . asList ( new   Integer [  ]  {     -  1  0  0  0     }  )  )  ;", "try    {", "nmCstopContainer ( container . getId (  )  ,    container . getNodeId (  )  )  ;", "}    catch    ( YarnException   e )     {", "throw    (  ( AssertionError )     ( new   AssertionError (  (  \" Exception   is   not   expected :     \"     +    e )  )  . initCause ( e )  )  )  ;", "}", "try    {", "testGetContainerStatus ( container ,    i ,    COMPLETE ,     \" Container   killed   by   the   ApplicationMaster .  \"  ,    Arrays . asList ( new   Integer [  ]  {    ContainerExitStatus . KILLED _ BY _ APPMASTER    }  )  )  ;", "}    catch    ( YarnException   e )     {", "if    (  !  ( e . getMessage (  )  . contains (  \" was   recently   stopped   on   node   manager \"  )  )  )     {", "throw    (  ( AssertionError )     ( new   AssertionError (  (  \" Exception   is   not   expected :     \"     +    e )  )  . initCause ( e )  )  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testContainerManagement"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "try    {", "ContainerStatus   status    =    nmCgetContainerStatus ( container . getId (  )  ,    container . getNodeId (  )  )  ;", "if    (  ( status . getState (  )  )     =  =    state )     {", "assertEquals ( container . getId (  )  ,    status . getContainerId (  )  )  ;", "assertTrue (  (  (  (  \"  \"     +    index )     +     \"  :     \"  )     +     ( status . getDiagnostics (  )  )  )  ,    status . getDiagnostics (  )  . contains ( diagnostics )  )  ;", "assertTrue ( exitStatuses . contains ( status . getExitStatus (  )  )  )  ;", "break ;", "}", "Thread . sleep (  1  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testGetContainerStatus"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "rmClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "testContainerManagement ( nmClient ,    allocateContainers ( rmClient ,     5  )  )  ;", "rmClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "assertFalse ( nmClient . startedContainers . isEmpty (  )  )  ;", "nmClient . cleanupRunningContainersOnStop ( true )  ;", "assertTrue ( nmClient . getCleanupRunningContainers (  )  . get (  )  )  ;", "nmClient . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testNMClient"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "rmClient . registerApplicationMaster (  \" Host \"  ,     1  0  0  0  0  ,     \"  \"  )  ;", "testContainerManagement ( nmClient ,    allocateContainers ( rmClient ,     5  )  )  ;", "rmClient . unregisterApplicationMaster ( SUCCEEDED ,    null ,    null )  ;", "stopNmClient ( false )  ;", "assertFalse ( nmClient . startedContainers . isEmpty (  )  )  ;", "nmClient . cleanupRunningContainers (  )  ;", "assertEquals (  0  ,    nmClient . startedContainers . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNMClientNoCleanupOnStop"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestNMClient"}, {"methodBody": ["METHOD_START", "{", "YarnClientApplication   newApp    =    rmClient . createApplication (  )  ;", "ApplicationId   appId    =    newApp . getNewApplicationResponse (  )  . getApplicationId (  )  ;", "ApplicationSubmissionContext   appContext    =    Records . newRecord ( ApplicationSubmissionContext . class )  ;", "appContext . setApplicationId ( appId )  ;", "appContext . setApplicationName (  \" test \"  )  ;", "Priority   pri    =    Records . newRecord ( Priority . class )  ;", "pri . setPriority (  1  )  ;", "appContext . setPriority ( pri )  ;", "appContext . setQueue (  \" default \"  )  ;", "ContainerLaunchContext   amContainer    =    Records . newRecord ( ContainerLaunchContext . class )  ;", "appContext . setAMContainerSpec ( amContainer )  ;", "appContext . setResource ( Resource . newInstance (  1  0  2  4  ,     1  )  )  ;", "appContext . setUnmanagedAM ( unmanaged )  ;", "rmClient . submitApplication ( appContext )  ;", "return   appId ;", "}", "METHOD_END"], "methodName": ["createApp"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "MiniYARNCluster   cluster    =    new   MiniYARNCluster (  \" testMRAMTokens \"  ,     1  ,     1  ,     1  )  ;", "rmClient    =    null ;", "try    {", "cluster . init ( new   YarnConfiguration (  )  )  ;", "cluster . start (  )  ;", "final   Configuration   yarnConf    =    cluster . getConfig (  )  ;", "rmClient    =     . create (  )  ;", "rmClient . init ( yarnConf )  ;", "rmClient . start (  )  ;", "ApplicationId   appId    =    createApp ( rmClient ,    false )  ;", "waitTillAccepted ( rmClient ,    appId )  ;", "Assert . assertNull ( rmClient . getAMRMToken ( appId )  )  ;", "appId    =    createApp ( rmClient ,    true )  ;", "waitTillAccepted ( rmClient ,    appId )  ;", "long   start    =    System . currentTimeMillis (  )  ;", "while    (  ( rmClient . getAMRMToken ( appId )  )     =  =    null )     {", "if    (  (  ( System . currentTimeMillis (  )  )     -    start )     >     (  2  0     *     1  0  0  0  )  )     {", "Assert . fail (  \" AMRM   token   is   null \"  )  ;", "}", "Thread . sleep (  1  0  0  )  ;", "}", "Assert . assertNotNull ( rmClient . getAMRMToken ( appId )  )  ;", "UserGroupInformation   other    =    UserGroupInformation . createUserForTesting (  \" foo \"  ,    new   String [  ]  {        }  )  ;", "appId    =    other . doAs ( new   PrivilegedExceptionAction < ApplicationId >  (  )     {", "@ Override", "public   ApplicationId   run (  )    throws   Exception    {", "rmClient    =     . create (  )  ;", "rmClient . init ( yarnConf )  ;", "rmClient . start (  )  ;", "ApplicationId   appId    =    createApp ( rmClient ,    true )  ;", "waitTillAccepted ( rmClient ,    appId )  ;", "long   start    =    System . currentTimeMillis (  )  ;", "while    (  ( rmClient . getAMRMToken ( appId )  )     =  =    null )     {", "if    (  (  ( System . currentTimeMillis (  )  )     -    start )     >     (  2  0     *     1  0  0  0  )  )     {", "Assert . fail (  \" AMRM   token   is   null \"  )  ;", "}", "Thread . sleep (  1  0  0  )  ;", "}", "Assert . assertNotNull ( rmClient . getAMRMToken ( appId )  )  ;", "return   appId ;", "}", "}  )  ;", "Assert . assertNull ( rmClient . getAMRMToken ( appId )  )  ;", "}    finally    {", "if    ( rmClient    !  =    null )     {", "rmClient . stop (  )  ;", "}", "cluster . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAMMRTokens"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Logger   rootLogger    =    LogManager . getRootLogger (  )  ;", "rootLogger . setLevel ( Level . DEBUG )  ;", "MockRM   rm    =    new   MockRM (  )  ;", "rm . start (  )  ;", "RMApp   app    =    rm . submitApp (  2  0  0  0  )  ;", "RMApp   app 1     =    rm . submitApp (  2  0  0  ,     \" name \"  ,     \" user \"  ,    new   HashMap < api . records . ApplicationAccessType ,    String >  (  )  ,    false ,     \" default \"  ,     (  -  1  )  ,    null ,     \" MAPREDUCE \"  )  ;", "Assert . assertEquals (  \" YARN \"  ,    app . getApplicationType (  )  )  ;", "Assert . assertEquals (  \" MAPREDUCE \"  ,    app 1  . getApplicationType (  )  )  ;", "rm . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testApplicationType"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Logger   rootLogger    =    LogManager . getRootLogger (  )  ;", "rootLogger . setLevel ( Level . DEBUG )  ;", "MockRM   rm    =    new   MockRM (  )  ;", "rm . start (  )  ;", "RMApp   app 1     =    rm . submitApp (  2  0  0  ,     \" name \"  ,     \" user \"  ,    new   HashMap < api . records . ApplicationAccessType ,    String >  (  )  ,    false ,     \" default \"  ,     (  -  1  )  ,    null ,     \" MAPREDUCE - LENGTH - IS -  2  0  \"  )  ;", "Assert . assertEquals (  \" MAPREDUCE - LENGTH - IS -  \"  ,    app 1  . getApplicationType (  )  )  ;", "rm . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testApplicationTypeLimit"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "testAsyncAPIPollTimeoutHelper ( null ,    false )  ;", "testAsyncAPIPollTimeoutHelper (  0 L ,    true )  ;", "testAsyncAPIPollTimeoutHelper (  1 L ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAsyncAPIPollTimeout"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "YarnClientImpl   client    =    new   YarnClientImpl (  )  ;", "try    {", "Configuration   conf    =    new   Configuration (  )  ;", "if    ( valueForTimeout    !  =    null )     {", "conf . setLong ( YARN _ CLIENT _ APPLICATION _ CLIENT _ PROTOCOL _ POLL _ TIMEOUT _ MS ,    valueForTimeout )  ;", "}", "client . init ( conf )  ;", "Assert . assertEquals ( expectedTimeoutEnforcement ,    client . enforceAsyncAPITimeout (  )  )  ;", "}    finally    {", "IOUtils . closeQuietly ( client )  ;", "}", "}", "METHOD_END"], "methodName": ["testAsyncAPIPollTimeoutHelper"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "conf . setBoolean ( TIMELINE _ SERVICE _ ENABLED ,    true )  ;", "SecurityUtil . setAuthenticationMethod ( KERBEROS ,    conf )  ;", "final   Token < TimelineDelegationTokenIdentifier >    dToken    =    new   Token < TimelineDelegationTokenIdentifier >  (  )  ;", "Impl   client    =    new   Impl (  )     {", "@ Override", "protected   void   serviceInit ( Configuration   conf )    throws   Exception    {", "if    ( getConfig (  )  . getBoolean ( TIMELINE _ SERVICE _ ENABLED ,    DEFAULT _ TIMELINE _ SERVICE _ ENABLED )  )     {", "timelineServiceEnabled    =    true ;", "timelineClient    =    mock ( TimelineClient . class )  ;", "when ( timelineClient . getDelegationToken ( any ( String . class )  )  )  . thenReturn ( dToken )  ;", "timelineClient . init ( getConfig (  )  )  ;", "timelineService    =    TimelineUtils . buildTimelineTokenService ( getConfig (  )  )  ;", "}", "this . setConfig ( conf )  ;", "}", "@ Override", "protected   void   serviceStart (  )    throws   Exception    {", "rmClient    =    mock ( ApplicationClientProtocol . class )  ;", "}", "@ Override", "protected   void   serviceStop (  )    throws   Exception    {", "}", "@ Override", "public   ApplicationReport   getApplicationReport ( ApplicationId   appId )     {", "ApplicationReport   report    =    mock ( ApplicationReport . class )  ;", "when ( report . getYarnApplicationState (  )  )  . thenReturn ( SUBMITTED )  ;", "return   report ;", "}", "@ Override", "public   boolean   isSecurityEnabled (  )     {", "return   true ;", "}", "}  ;", "client . init ( conf )  ;", "client . start (  )  ;", "ApplicationSubmissionContext   context    =    mock ( ApplicationSubmissionContext . class )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  0  ,     1  )  ;", "when ( context . getApplicationId (  )  )  . thenReturn ( applicationId )  ;", "DataOutputBuffer   dob    =    new   DataOutputBuffer (  )  ;", "Credentials   credentials    =    new   Credentials (  )  ;", "credentials . writeTokenStorageToStream ( dob )  ;", "ByteBuffer   tokens    =    ByteBuffer . wrap ( dob . getData (  )  ,     0  ,    dob . getLength (  )  )  ;", "ContainerLaunchContext   clc    =    ContainerLaunchContext . newInstance ( null ,    null ,    null ,    null ,    tokens ,    null )  ;", "when ( context . getAMContainerSpec (  )  )  . thenReturn ( clc )  ;", "client . submitApplication ( context )  ;", "credentials    =    new   Credentials (  )  ;", "DataInputByteBuffer   dibb    =    new   DataInputByteBuffer (  )  ;", "tokens    =    clc . getTokens (  )  ;", "if    ( tokens    !  =    null )     {", "dibb . reset ( tokens )  ;", "credentials . readTokenStorageStream ( dibb )  ;", "tokens . rewind (  )  ;", "}", "Collection < Token <  ?    extends   TokenIdentifier >  >    dTokens    =    credentials . getAllTokens (  )  ;", "Assert . assertEquals (  1  ,    dTokens . size (  )  )  ;", "Assert . assertEquals ( dToken ,    dTokens . iterator (  )  . next (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testAutomaticTimelineDelegationTokenLoading"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "ResourceManager   rm    =    new   ResourceManager (  )  ;", "rm . init ( conf )  ;", "rm . start (  )  ;", "client    =     . create (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "client . stop (  )  ;", "rm . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testClientStop"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockYarnClient )     ( client )  )  . getReports (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ApplicationAttemptReport   report    =    client . getApplicationAttemptReport ( appAttemptId )  ;", "Assert . assertNotNull ( report )  ;", "Assert . assertEquals ( report . getApplicationAttemptId (  )  . toString (  )  ,    expectedReports . get (  0  )  . getCurrentApplicationAttemptId (  )  . toString (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttempt"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "List < ApplicationAttemptReport >    reports    =    client . getApplicationAttempts ( applicationId )  ;", "Assert . assertNotNull ( reports )  ;", "Assert . assertEquals ( reports . get (  0  )  . getApplicationAttemptId (  )  ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  )  ;", "Assert . assertEquals ( reports . get (  1  )  . getApplicationAttemptId (  )  ,    ApplicationAttemptId . newInstance ( applicationId ,     2  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttempts"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockYarnClient )     ( client )  )  . getReports (  )  ;", "List < ApplicationReport >    reports    =    client . getApplications (  )  ;", "Assert . assertEquals ( reports ,    expectedReports )  ;", "Set < String >    appTypes    =    new   HashSet < String >  (  )  ;", "appTypes . add (  \" YARN \"  )  ;", "appTypes . add (  \" NON - YARN \"  )  ;", "reports    =    client . getApplications ( appTypes ,    null )  ;", "Assert . assertEquals ( reports . size (  )  ,     2  )  ;", "Assert . assertTrue (  (  (  ( reports . get (  0  )  . getApplicationType (  )  . equals (  \" YARN \"  )  )     &  &     ( reports . get (  1  )  . getApplicationType (  )  . equals (  \" NON - YARN \"  )  )  )     |  |     (  ( reports . get (  1  )  . getApplicationType (  )  . equals (  \" YARN \"  )  )     &  &     ( reports . get (  0  )  . getApplicationType (  )  . equals (  \" NON - YARN \"  )  )  )  )  )  ;", "for    ( ApplicationReport   report    :    reports )     {", "Assert . assertTrue ( expectedReports . contains ( report )  )  ;", "}", "EnumSet < YarnApplicationState >    appStates    =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appStates . add ( FINISHED )  ;", "appStates . add ( FAILED )  ;", "reports    =    client . getApplications ( null ,    appStates )  ;", "Assert . assertEquals ( reports . size (  )  ,     2  )  ;", "Assert . assertTrue (  (  (  ( reports . get (  0  )  . getApplicationType (  )  . equals (  \" NON - YARN \"  )  )     &  &     ( reports . get (  1  )  . getApplicationType (  )  . equals (  \" NON - MAPREDUCE \"  )  )  )     |  |     (  ( reports . get (  1  )  . getApplicationType (  )  . equals (  \" NON - YARN \"  )  )     &  &     ( reports . get (  0  )  . getApplicationType (  )  . equals (  \" NON - MAPREDUCE \"  )  )  )  )  )  ;", "for    ( ApplicationReport   report    :    reports )     {", "Assert . assertTrue ( expectedReports . contains ( report )  )  ;", "}", "reports    =    client . getApplications ( appTypes ,    appStates )  ;", "Assert . assertEquals ( reports . size (  )  ,     1  )  ;", "Assert . assertTrue ( reports . get (  0  )  . getApplicationType (  )  . equals (  \" NON - YARN \"  )  )  ;", "for    ( ApplicationReport   report    :    reports )     {", "Assert . assertTrue ( expectedReports . contains ( report )  )  ;", "}", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplications"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "List < ApplicationReport >    expectedReports    =     (  (  . MockYarnClient )     ( client )  )  . getReports (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( appAttemptId ,     1  )  ;", "ContainerReport   report    =    client . getContainerReport ( containerId )  ;", "Assert . assertNotNull ( report )  ;", "Assert . assertEquals ( report . getContainerId (  )  . toString (  )  ,    ContainerId . newInstance ( expectedReports . get (  0  )  . getCurrentApplicationAttemptId (  )  ,     1  )  . toString (  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainerReport"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "List < ContainerReport >    reports    =    client . getContainers ( appAttemptId )  ;", "Assert . assertNotNull ( reports )  ;", "Assert . assertEquals ( reports . get (  0  )  . getContainerId (  )  ,    ContainerId . newInstance ( appAttemptId ,     1  )  )  ;", "Assert . assertEquals ( reports . get (  1  )  . getContainerId (  )  ,    ContainerId . newInstance ( appAttemptId ,     2  )  )  ;", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainers"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "MockRM   rm    =    new   MockRM (  )  ;", "rm . start (  )  ;", "RMApp   app    =    rm . submitApp (  2  0  0  0  )  ;", "Configuration   conf    =    new   Configuration (  )  ;", "@ SuppressWarnings (  \" resource \"  )", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "client . killApplication ( app . getApplicationId (  )  )  ;", "verify (  (  (  . MockYarnClient )     ( client )  )  . getRMClient (  )  ,    times (  2  )  )  . forceKillApplication ( any ( KillApplicationRequest . class )  )  ;", "}", "METHOD_END"], "methodName": ["testKillApplication"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   Configuration (  )  ;", "conf . setLong ( YARN _ CLIENT _ APP _ SUBMISSION _ POLL _ INTERVAL _ MS ,     1  0  0  )  ;", "final   YarnClient   client    =    new    . MockYarnClient (  )  ;", "client . init ( conf )  ;", "client . start (  )  ;", "YarnApplicationState [  ]    exitStates    =    new   YarnApplicationState [  ]  {    YarnApplicationState . SUBMITTED ,    YarnApplicationState . ACCEPTED ,    YarnApplicationState . RUNNING ,    YarnApplicationState . FINISHED ,    YarnApplicationState . FAILED ,    YarnApplicationState . KILLED    }  ;", "ApplicationSubmissionContext   contextWithoutApplicationId    =    mock ( ApplicationSubmissionContext . class )  ;", "try    {", "client . submitApplication ( contextWithoutApplicationId )  ;", "Assert . fail (  \" Should   throw   the   ApplicationIdNotProvidedException \"  )  ;", "}    catch    ( YarnException   e )     {", "Assert . assertTrue (  ( e   instanceof   ApplicationIdNotProvidedException )  )  ;", "Assert . assertTrue ( e . getMessage (  )  . contains (  \" ApplicationId   is   not   provided   in   ApplicationSubmissionContext \"  )  )  ;", "}    catch    ( IOException   e )     {", "Assert . fail (  \" IOException   is   not   expected .  \"  )  ;", "}", "for    ( int   i    =     0  ;    i    <     ( exitStates . length )  ;     +  + i )     {", "ApplicationSubmissionContext   context    =    mock ( ApplicationSubmissionContext . class )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance ( System . currentTimeMillis (  )  ,    i )  ;", "when ( context . getApplicationId (  )  )  . thenReturn ( applicationId )  ;", "(  (  . MockYarnClient )     ( client )  )  . setYarnApplicationState ( exitStates [ i ]  )  ;", "try    {", "client . submitApplication ( context )  ;", "}    catch    ( YarnException   e )     {", "Assert . fail (  \" Exception   is   not   expected .  \"  )  ;", "}    catch    ( IOException   e )     {", "Assert . fail (  \" Exception   is   not   expected .  \"  )  ;", "}", "verify (  (  (  . MockYarnClient )     ( client )  )  . mockReport ,    times (  (  (  4     *    i )     +     4  )  )  )  . getYarnApplicationState (  )  ;", "}", "client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["testSubmitApplication"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "try    {", "long   start    =    System . currentTimeMillis (  )  ;", "ApplicationReport   report    =    rmCgetApplicationReport ( appId )  ;", "while    (  ( YarnApplicationState . ACCEPTED )     !  =     ( report . getYarnApplicationState (  )  )  )     {", "if    (  (  ( System . currentTimeMillis (  )  )     -    start )     >     (  2  0     *     1  0  0  0  )  )     {", "throw   new   Exception (  (  (  \" App    '  \"     +    appId )     +     \"  '    time   out ,    failed   to   reach   ACCEPTED   state \"  )  )  ;", "}", "Thread . sleep (  2  0  0  )  ;", "report    =    rmCgetApplicationReport ( appId )  ;", "}", "}    catch    ( Exception   ex )     {", "throw   new   Exception ( ex )  ;", "}", "}", "METHOD_END"], "methodName": ["waitTillAccepted"], "fileName": "org.apache.hadoop.yarn.client.api.impl.TestYarnClient"}, {"methodBody": ["METHOD_START", "{", "Token < TimelineDelegationTokenIdentifier >    timelineDelegationToken    =    timelineClient . getDelegationToken ( UserGroupInformation . getCurrentUser (  )  . getUserName (  )  )  ;", "if    ( timelineDelegationToken    =  =    null )     {", "return ;", "}", "Credentials   credentials    =    new   Credentials (  )  ;", "DataInputByteBuffer   dibb    =    new   DataInputByteBuffer (  )  ;", "ByteBuffer   tokens    =    clc . getTokens (  )  ;", "if    ( tokens    !  =    null )     {", "dibb . reset ( tokens )  ;", "credentials . readTokenStorageStream ( dibb )  ;", "tokens . rewind (  )  ;", "}", "for    ( Token <  ?    extends   TokenIdentifier >    token    :    credentials . getAllTokens (  )  )     {", "TokenIdentifier   tokenIdentifier    =    token . decodeIdentifier (  )  ;", "if    ( tokenIdentifier   instanceof   TimelineDelegationTokenIdentifier )     {", "return ;", "}", "}", "credentials . addToken ( timelineService ,    timelineDelegationToken )  ;", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  (  \" Add   timline   delegation   token   into   credentials :     \"     +    timelineDelegationToken )  )  ;", "}", "DataOutputBuffer   dob    =    new   DataOutputBuffer (  )  ;", "credentials . writeTokenStorageToStream ( dob )  ;", "tokens    =    ByteBuffer . wrap ( dob . getData (  )  ,     0  ,    dob . getLength (  )  )  ;", "clc . setTokens ( tokens )  ;", "}", "METHOD_END"], "methodName": ["addTimelineDelegationToken"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( asyncApiPollTimeoutMillis )     >  =     0  ;", "}", "METHOD_END"], "methodName": ["enforceAsyncAPITimeout"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "Token   token    =    getApplicationReport ( appId )  . getAMRMToken (  )  ;", "security . token . Token < AMRMTokenIdentifier >    amrmToken    =    null ;", "if    ( token    !  =    null )     {", "amrmToken    =    ConverterUtils . convertFromYarn ( token ,     (  ( Text )     ( null )  )  )  ;", "}", "return   amrmToken ;", "}", "METHOD_END"], "methodName": ["getAMRMToken"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "List < QueueInfo >    childQueues    =    parent . getChildQueues (  )  ;", "for    ( QueueInfo   child    :    childQueues )     {", "queues . add ( child )  ;", "if    ( recursive )     {", "getChildQueues ( child ,    queues ,    recursive )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["getChildQueues"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "GetNewApplicationRequest   request    =    Records . newRecord ( GetNewApplicationRequest . class )  ;", "return   rm . getNewApplication ( request )  ;", "}", "METHOD_END"], "methodName": ["getNewApplication"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "GetQueueInfoRequest   request    =    Records . newRecord ( GetQueueInfoRequest . class )  ;", "request . setQueueName ( queueName )  ;", "request . setIncludeApplications ( includeApplications )  ;", "request . setIncludeChildQueues ( includeChildQueues )  ;", "request . setRecursive ( recursive )  ;", "return   request ;", "}", "METHOD_END"], "methodName": ["getQueueInfoRequest"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "return   UserGroupInformation . isSecurityEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["isSecurityEnabled"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "this . rmClient    =    rmClient ;", "}", "METHOD_END"], "methodName": ["setRMClient"], "fileName": "org.apache.hadoop.yarn.client.api.impl.YarnClientImpl"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  (  \" The   valid   application   state   can   be \"     +     \"    one   of   the   following :     \"  )  )  ;", "sb . append (  (  (  . ALLSTATES _ OPTION )     +     \"  ,  \"  )  )  ;", "for    ( YarnApplicationState   appState    :    YarnApplicationState . values (  )  )     {", "sb . append (  ( appState    +     \"  ,  \"  )  )  ;", "}", "String   output    =    sb . toString (  )  ;", "return   output . substring (  0  ,     (  ( output . length (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllValidApplicationStates"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationId   appId    =    ConverterUtils . toApplicationId ( applicationId )  ;", "ApplicationReport   appReport    =    null ;", "try    {", "appReport    =    client . getApplicationReport ( appId )  ;", "}    catch    ( ApplicationNotFoundException   e )     {", "sysout . println (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  )  ;", "throw   e ;", "}", "if    (  (  (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . FINISHED )  )     |  |     (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . KILLED )  )  )     |  |     (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . FAILED )  )  )     {", "sysout . println (  (  (  \" Application    \"     +    applicationId )     +     \"    has   already   finished    \"  )  )  ;", "} else    {", "sysout . println (  (  \" Killing   application    \"     +    applicationId )  )  ;", "client . killApplication ( appId )  ;", "}", "}", "METHOD_END"], "methodName": ["killApplication"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( sysout )  ;", "List < ApplicationAttemptReport >    appAttemptsReport    =    client . getApplicationAttempts ( ConverterUtils . toApplicationId ( applicationId )  )  ;", "writer . println (  (  (  \" Total   number   of   application   attempts    \"     +     \"  :  \"  )     +     ( appAttemptsReport . size (  )  )  )  )  ;", "writer . printf (  . APPLICATION _ ATTEMPTS _ PATTERN ,     \" ApplicationAttempt - Id \"  ,     \" State \"  ,     \" AM - Container - Id \"  ,     \" Tracking - URL \"  )  ;", "for    ( ApplicationAttemptReport   appAttemptReport    :    appAttemptsReport )     {", "writer . printf (  . APPLICATION _ ATTEMPTS _ PATTERN ,    appAttemptReport . getApplicationAttemptId (  )  ,    appAttemptReport . getYarnApplicationAttemptState (  )  ,    appAttemptReport . getAMContainerId (  )  . toString (  )  ,    appAttemptReport . getTrackingUrl (  )  )  ;", "}", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["listApplicationAttempts"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( sysout )  ;", "if    ( allAppStates )     {", "for    ( YarnApplicationState   appState    :    YarnApplicationState . values (  )  )     {", "appStates . add ( appState )  ;", "}", "} else    {", "if    ( appStates . isEmpty (  )  )     {", "appStates . add ( RUNNING )  ;", "appStates . add ( ACCEPTED )  ;", "appStates . add ( SUBMITTED )  ;", "}", "}", "List < ApplicationReport >    appsReport    =    client . getApplications ( appTypes ,    appStates )  ;", "writer . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appTypes )     +     \"    and   states :     \"  )     +    appStates )     +     \"  )  \"  )     +     \"  :  \"  )     +     ( appsReport . size (  )  )  )  )  ;", "writer . printf (  . APPLICATIONS _ PATTERN ,     \" Application - Id \"  ,     \" Application - Name \"  ,     \" Application - Type \"  ,     \" User \"  ,     \" Queue \"  ,     \" State \"  ,     \" Final - State \"  ,     \" Progress \"  ,     \" Tracking - URL \"  )  ;", "for    ( ApplicationReport   appReport    :    appsReport )     {", "DecimalFormat   formatter    =    new   DecimalFormat (  \"  #  #  #  .  #  #  %  \"  )  ;", "String   progress    =    formatter . format ( appReport . getProgress (  )  )  ;", "writer . printf (  . APPLICATIONS _ PATTERN ,    appReport . getApplicationId (  )  ,    appReport . getName (  )  ,    appReport . getApplicationType (  )  ,    appReport . getUser (  )  ,    appReport . getQueue (  )  ,    appReport . getYarnApplicationState (  )  ,    appReport . getFinalApplicationStatus (  )  ,    progress ,    appReport . getOriginalTrackingUrl (  )  )  ;", "}", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["listApplications"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( sysout )  ;", "List < ContainerReport >    appsReport    =    client . getContainers ( ConverterUtils . toApplicationAttemptId ( appAttemptId )  )  ;", "writer . println (  (  (  \" Total   number   of   containers    \"     +     \"  :  \"  )     +     ( appsReport . size (  )  )  )  )  ;", "writer . printf (  . CONTAINER _ PATTERN ,     \" Container - Id \"  ,     \" Start   Time \"  ,     \" Finish   Time \"  ,     \" State \"  ,     \" Host \"  ,     \" LOG - URL \"  )  ;", "for    ( ContainerReport   containerReport    :    appsReport )     {", "writer . printf (  . CONTAINER _ PATTERN ,    containerReport . getContainerId (  )  ,    containerReport . getCreationTime (  )  ,    containerReport . getFinishTime (  )  ,    containerReport . getContainerState (  )  ,    containerReport . getAssignedNode (  )  ,    containerReport . getLogUrl (  )  )  ;", "}", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["listContainers"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    new   ApplicationCLI (  )  ;", "cli . setSysOutPrintStream ( System . out )  ;", "cli . setSysErrPrintStream ( System . err )  ;", "int   res    =    ToolRunner . run ( cli ,    args )  ;", "cli . stop (  )  ;", "System . exit ( res )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationId   appId    =    ConverterUtils . toApplicationId ( applicationId )  ;", "ApplicationReport   appReport    =    client . getApplicationReport ( appId )  ;", "if    (  (  (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . FINISHED )  )     |  |     (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . KILLED )  )  )     |  |     (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . FAILED )  )  )     {", "sysout . println (  (  (  \" Application    \"     +    applicationId )     +     \"    has   already   finished    \"  )  )  ;", "} else    {", "sysout . println (  (  (  (  \" Moving   application    \"     +    applicationId )     +     \"    to   queue    \"  )     +    queue )  )  ;", "client . moveApplicationAcrossQueues ( appId ,    queue )  ;", "sysout . println (  \" Successfully   completed   move .  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["moveApplicationAcrossQueues"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationAttemptReport   appAttemptReport    =    client . getApplicationAttemptReport ( ConverterUtils . toApplicationAttemptId ( applicationAttemptId )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   appAttemptReportStr    =    new   PrintWriter ( baos )  ;", "if    ( appAttemptReport    !  =    null )     {", "appAttemptReportStr . println (  \" Application   Attempt   Report    :     \"  )  ;", "appAttemptReportStr . print (  \"  \\ tApplicationAttempt - Id    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getApplicationAttemptId (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tState    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getYarnApplicationAttemptState (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tAMContainer    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getAMContainerId (  )  . toString (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tTracking - URL    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getTrackingUrl (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tRPC   Port    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getRpcPort (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tAM   Host    :     \"  )  ;", "appAttemptReportStr . println ( appAttemptReport . getHost (  )  )  ;", "appAttemptReportStr . print (  \"  \\ tDiagnostics    :     \"  )  ;", "appAttemptReportStr . print ( appAttemptReport . getDiagnostics (  )  )  ;", "} else    {", "appAttemptReportStr . print (  (  (  \" Application   Attempt   with   id    '  \"     +    applicationAttemptId )     +     \"  '    doesn ' t   exist   in   History   Server .  \"  )  )  ;", "}", "appAttemptReportStr . close (  )  ;", "sysout . println ( baos . toString (  \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printApplicationAttemptReport"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationReport   appReport    =    client . getApplicationReport ( ConverterUtils . toApplicationId ( applicationId )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   appReportStr    =    new   PrintWriter ( baos )  ;", "if    ( appReport    !  =    null )     {", "appReportStr . println (  \" Application   Report    :     \"  )  ;", "appReportStr . print (  \"  \\ tApplication - Id    :     \"  )  ;", "appReportStr . println ( appReport . getApplicationId (  )  )  ;", "appReportStr . print (  \"  \\ tApplication - Name    :     \"  )  ;", "appReportStr . println ( appReport . getName (  )  )  ;", "appReportStr . print (  \"  \\ tApplication - Type    :     \"  )  ;", "appReportStr . println ( appReport . getApplicationType (  )  )  ;", "appReportStr . print (  \"  \\ tUser    :     \"  )  ;", "appReportStr . println ( appReport . getUser (  )  )  ;", "appReportStr . print (  \"  \\ tQueue    :     \"  )  ;", "appReportStr . println ( appReport . getQueue (  )  )  ;", "appReportStr . print (  \"  \\ tStart - Time    :     \"  )  ;", "appReportStr . println ( appReport . getStartTime (  )  )  ;", "appReportStr . print (  \"  \\ tFinish - Time    :     \"  )  ;", "appReportStr . println ( appReport . getFinishTime (  )  )  ;", "appReportStr . print (  \"  \\ tProgress    :     \"  )  ;", "DecimalFormat   formatter    =    new   DecimalFormat (  \"  #  #  #  .  #  #  %  \"  )  ;", "String   progress    =    formatter . format ( appReport . getProgress (  )  )  ;", "appReportStr . println ( progress )  ;", "appReportStr . print (  \"  \\ tState    :     \"  )  ;", "appReportStr . println ( appReport . getYarnApplicationState (  )  )  ;", "appReportStr . print (  \"  \\ tFinal - State    :     \"  )  ;", "appReportStr . println ( appReport . getFinalApplicationStatus (  )  )  ;", "appReportStr . print (  \"  \\ tTracking - URL    :     \"  )  ;", "appReportStr . println ( appReport . getOriginalTrackingUrl (  )  )  ;", "appReportStr . print (  \"  \\ tRPC   Port    :     \"  )  ;", "appReportStr . println ( appReport . getRpcPort (  )  )  ;", "appReportStr . print (  \"  \\ tAM   Host    :     \"  )  ;", "appReportStr . println ( appReport . getHost (  )  )  ;", "appReportStr . print (  \"  \\ tDiagnostics    :     \"  )  ;", "appReportStr . print ( appReport . getDiagnostics (  )  )  ;", "} else    {", "appReportStr . print (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  )  ;", "}", "appReportStr . close (  )  ;", "sysout . println ( baos . toString (  \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printApplicationReport"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "ContainerReport   containerReport    =    client . getContainerReport ( ConverterUtils . toContainerId ( containerId )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   containerReportStr    =    new   PrintWriter ( baos )  ;", "if    ( containerReport    !  =    null )     {", "containerReportStr . println (  \" Container   Report    :     \"  )  ;", "containerReportStr . print (  \"  \\ tContainer - Id    :     \"  )  ;", "containerReportStr . println ( containerReport . getContainerId (  )  )  ;", "containerReportStr . print (  \"  \\ tStart - Time    :     \"  )  ;", "containerReportStr . println ( containerReport . getCreationTime (  )  )  ;", "containerReportStr . print (  \"  \\ tFinish - Time    :     \"  )  ;", "containerReportStr . println ( containerReport . getFinishTime (  )  )  ;", "containerReportStr . print (  \"  \\ tState    :     \"  )  ;", "containerReportStr . println ( containerReport . getContainerState (  )  )  ;", "containerReportStr . print (  \"  \\ tLOG - URL    :     \"  )  ;", "containerReportStr . println ( containerReport . getLogUrl (  )  )  ;", "containerReportStr . print (  \"  \\ tHost    :     \"  )  ;", "containerReportStr . println ( containerReport . getAssignedNode (  )  )  ;", "containerReportStr . print (  \"  \\ tDiagnostics    :     \"  )  ;", "containerReportStr . print ( containerReport . getDiagnosticsInfo (  )  )  ;", "} else    {", "containerReportStr . print (  (  (  \" Container   with   id    '  \"     +    containerId )     +     \"  '    doesn ' t   exist   in   Hostory   Server .  \"  )  )  ;", "}", "containerReportStr . close (  )  ;", "sysout . println ( baos . toString (  \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printContainerReport"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "new   HelpFormatter (  )  . printHelp ( title ,    opts )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.client.cli.ApplicationCLI"}, {"methodBody": ["METHOD_START", "{", "YarnClient   yarnClient    =    YarnClient . createYarnClient (  )  ;", "yarnClient . init ( getConf (  )  )  ;", "yarnClient . start (  )  ;", "return   yarnClient ;", "}", "METHOD_END"], "methodName": ["createYarnClient"], "fileName": "org.apache.hadoop.yarn.client.cli.LogsCLI"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "logDumper    =    new    (  )  ;", "logDumper . setConf ( conf )  ;", "int   exitCode    =    logDumper . run ( args )  ;", "System . exit ( exitCode )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.client.cli.LogsCLI"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  \" Retrieve   logs   for   completed   YARN   applications .  \"  )  ;", "HelpFormatter   formatter    =    new   HelpFormatter (  )  ;", "formatter . printHelp (  \"    logs    - applicationId    < application   ID >     [ OPTIONS ]  \"  ,    new   Options (  )  )  ;", "formatter . setSyntaxPrefix (  \"  \"  )  ;", "formatter . printHelp (  \" general   options   are :  \"  ,    options )  ;", "}", "METHOD_END"], "methodName": ["printHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.LogsCLI"}, {"methodBody": ["METHOD_START", "{", "YarnClient   yarnClient    =    createYarnClient (  )  ;", "try    {", "ApplicationReport   appReport    =    yarnClient . getApplicationReport ( appId )  ;", "switch    ( appReport . getYarnApplicationState (  )  )     {", "case   NEW    :", "case   NEW _ SAVING    :", "case   ACCEPTED    :", "case   SUBMITTED    :", "case   RUNNING    :", "return    -  1  ;", "case   FAILED    :", "case   FINISHED    :", "case   KILLED    :", "default    :", "break ;", "}", "}    finally    {", "yarnCose (  )  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["verifyApplicationState"], "fileName": "org.apache.hadoop.yarn.client.cli.LogsCLI"}, {"methodBody": ["METHOD_START", "{", "PrintWriter   writer    =    new   PrintWriter ( sysout )  ;", "List < NodeReport >    nodesReport    =    getNodeReports ( nodeStates . toArray ( new   NodeState [  0  ]  )  )  ;", "writer . println (  (  \" Total   Nodes :  \"     +     ( nodesReport . size (  )  )  )  )  ;", "writer . printf ( NodeCLI . NODES _ PATTERN ,     \" Node - Id \"  ,     \" Node - State \"  ,     \" Node - Http - Address \"  ,     \" Number - of - Running - Containers \"  )  ;", "for    ( NodeReport   nodeReport    :    nodesReport )     {", "writer . printf ( NodeCLI . NODES _ PATTERN ,    nodeReport . getNodeId (  )  ,    nodeReport . getNodeState (  )  ,    nodeReport . getHttpAddress (  )  ,    nodeReport . getNumContainers (  )  )  ;", "}", "writer . flush (  )  ;", "}", "METHOD_END"], "methodName": ["listClusterNodes"], "fileName": "org.apache.hadoop.yarn.client.cli.NodeCLI"}, {"methodBody": ["METHOD_START", "{", "NodeCLI   cli    =    new   NodeCLI (  )  ;", "cli . setSysOutPrintStream ( System . out )  ;", "cli . setSysErrPrintStream ( System . err )  ;", "int   res    =    ToolRunner . run ( cli ,    args )  ;", "cli . stop (  )  ;", "System . exit ( res )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.client.cli.NodeCLI"}, {"methodBody": ["METHOD_START", "{", "NodeId   nodeId    =    ConverterUtils . toNodeId ( nodeIdStr )  ;", "List < NodeReport >    nodesReport    =    getNodeReports (  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   nodeReportStr    =    new   PrintWriter ( baos )  ;", "NodeReport   nodeReport    =    null ;", "for    ( NodeReport   report    :    nodesReport )     {", "if    (  !  ( report . getNodeId (  )  . equals ( nodeId )  )  )     {", "continue ;", "}", "nodeReport    =    report ;", "nodeReportStr . println (  \" Node   Report    :     \"  )  ;", "nodeReportStr . print (  \"  \\ tNode - Id    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getNodeId (  )  )  ;", "nodeReportStr . print (  \"  \\ tRack    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getRackName (  )  )  ;", "nodeReportStr . print (  \"  \\ tNode - State    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getNodeState (  )  )  ;", "nodeReportStr . print (  \"  \\ tNode - Http - Address    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getHttpAddress (  )  )  ;", "nodeReportStr . print (  \"  \\ tLast - Health - Update    :     \"  )  ;", "nodeReportStr . println ( DateFormatUtils . format ( new   Date ( nodeReport . getLastHealthReportTime (  )  )  ,     \" E   dd / MMM / yy   hh : mm : ss : SSzz \"  )  )  ;", "nodeReportStr . print (  \"  \\ tHealth - Report    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getHealthReport (  )  )  ;", "nodeReportStr . print (  \"  \\ tContainers    :     \"  )  ;", "nodeReportStr . println ( nodeReport . getNumContainers (  )  )  ;", "nodeReportStr . print (  \"  \\ tMemory - Used    :     \"  )  ;", "nodeReportStr . println (  (  ( nodeReport . getUsed (  )  )     =  =    null    ?     \"  0 MB \"     :     ( nodeReport . getUsed (  )  . getMemory (  )  )     +     \" MB \"  )  )  ;", "nodeReportStr . print (  \"  \\ tMemory - Capacity    :     \"  )  ;", "nodeReportStr . println (  (  ( nodeReport . getCapability (  )  . getMemory (  )  )     +     \" MB \"  )  )  ;", "nodeReportStr . print (  \"  \\ tCPU - Used    :     \"  )  ;", "nodeReportStr . println (  (  ( nodeReport . getUsed (  )  )     =  =    null    ?     \"  0    vcores \"     :     ( nodeReport . getUsed (  )  . getVirtualCores (  )  )     +     \"    vcores \"  )  )  ;", "nodeReportStr . print (  \"  \\ tCPU - Capacity    :     \"  )  ;", "nodeReportStr . println (  (  ( nodeReport . getCapability (  )  . getVirtualCores (  )  )     +     \"    vcores \"  )  )  ;", "}", "if    ( nodeReport    =  =    null )     {", "nodeReportStr . print (  (  \" Could   not   find   the   node   report   for   node   id    :     \"     +    nodeIdStr )  )  ;", "}", "nodeReportStr . close (  )  ;", "sysout . println ( baos . toString (  \" UTF -  8  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["printNodeStatus"], "fileName": "org.apache.hadoop.yarn.client.cli.NodeCLI"}, {"methodBody": ["METHOD_START", "{", "new   HelpFormatter (  )  . printHelp (  \" node \"  ,    opts )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.client.cli.NodeCLI"}, {"methodBody": ["METHOD_START", "{", "conf    =    new   YarnConfiguration ( conf )  ;", "conf . set ( HADOOP _ SECURITY _ SERVICE _ USER _ NAME _ KEY ,    conf . get ( RM _ PRINCIPAL ,     \"  \"  )  )  ;", "return   conf ;", "}", "METHOD_END"], "methodName": ["addSecurityConfiguration"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "for    ( String   cmdKey    :    USAGE . keySet (  )  )     {", "if    ( cmdKey . equals (  \"  - help \"  )  )     {", "continue ;", "}", "UsageInfo   usageInfo    =    USAGE . get ( cmdKey )  ;", "usageBuilderpend (  (  (  (  (  \"     [  \"     +    cmdKey )     +     \"     \"  )     +     ( usageInfo . args )  )     +     \"  ]  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["appendHAUsage"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "UsageInfo   usageInfo    =    RMAdminCLI . ADMIN _ USAGE . get ( cmd )  ;", "if    ( usageInfo    =  =    null )     {", "usageInfo    =    USAGE . get ( cmd )  ;", "if    ( usageInfo    =  =    null )     {", "return ;", "}", "}", "String   space    =     (  ( usageInfo . args )     =  =     \"  \"  )     ?     \"  \"     :     \"     \"  ;", "builder . append (  (  (  (  (  (  \"           \"     +    cmd )     +    space )     +     ( usageInfo . args )  )     +     \"  :     \"  )     +     ( usageInfo . help )  )  )  ;", "}", "METHOD_END"], "methodName": ["buildHelpMsg"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "boolean   isHACommand    =    false ;", "UsageInfo   usageInfo    =     . ADMIN _ USAGE . get ( cmd )  ;", "if    ( usageInfo    =  =    null )     {", "usageInfo    =    USAGE . get ( cmd )  ;", "if    ( usageInfo    =  =    null )     {", "return ;", "}", "isHACommand    =    true ;", "}", "String   space    =     (  ( usageInfo . args )     =  =     \"  \"  )     ?     \"  \"     :     \"     \"  ;", "builder . append (  (  (  (  (  \" Usage :    yarn   rmadmin    [  \"     +    cmd )     +    space )     +     ( usageInfo . args )  )     +     \"  ]  \\ n \"  )  )  ;", "if    ( isHACommand )     {", "builder . append (  ( cmd    +     \"    can   only   be   used   when   RM   HA   is   enabled \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["buildIndividualUsageMsg"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "builder . append (  \" Usage :    yarn   rmadmin \\ n \"  )  ;", "for    ( String   cmdKey    :     . ADMIN _ USAGE . keySet (  )  )     {", "UsageInfo   usageInfo    =     . ADMIN _ USAGE . get ( cmdKey )  ;", "builder . append (  (  (  (  (  \"           \"     +    cmdKey )     +     \"     \"  )     +     ( usageInfo . args )  )     +     \"  \\ n \"  )  )  ;", "}", "if    ( isHAEnabled )     {", "for    ( String   cmdKey    :    USAGE . keySet (  )  )     {", "if    (  !  ( cmdKey . equals (  \"  - help \"  )  )  )     {", "UsageInfo   usageInfo    =    USAGE . get ( cmdKey )  ;", "builder . append (  (  (  (  (  \"           \"     +    cmdKey )     +     \"     \"  )     +     ( usageInfo . args )  )     +     \"  \\ n \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["buildUsageMsg"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "final   YarnConfiguration   conf    =    new   YarnConfiguration ( getConf (  )  )  ;", "return   CRMProxy . createRMProxy ( conf ,    ResourceManagerAdministrationProtocol . class )  ;", "}", "METHOD_END"], "methodName": ["createAdminProtocol"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "if    (  ( usernames . length )     =  =     0  )     {", "usernames    =    new   String [  ]  {    UserGroupInformation . getCurrentUser (  )  . getUserName (  )     }  ;", "}", "for    ( String   username    :    usernames )     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  ( username    +     \"     :  \"  )  )  ;", "for    ( String   group    :    adminProtocol . getGroupsForUser ( username )  )     {", "sb . append (  \"     \"  )  ;", "sb . append ( group )  ;", "}", "System . out . println ( sb )  ;", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["getGroups"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "int   result    =    ToolRunner . run ( new   RMAdminCLI (  )  ,    args )  ;", "System . exit ( result )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   summary    =    new   StringBuilder (  )  ;", "summary . append (  (  \" rmadmin   is   the   command   to   execute   YARN   administrative    \"     +     \" commands .  \\ n \"  )  )  ;", "summary . append (  (  \" The   full   syntax   is :     \\ n \\ n \"     +     (  (  (  (  (  (  (  (  \" yarn   rmadmin \"     +     \"     [  - refreshQueues ]  \"  )     +     \"     [  - refreshNodes ]  \"  )     +     \"     [  - refreshSuperUserGroupsConfiguration ]  \"  )     +     \"     [  - refreshUserToGroupsMappings ]  \"  )     +     \"     [  - refreshAdminAcls ]  \"  )     +     \"     [  - refreshServiceAcl ]  \"  )     +     \"     [  - getGroup    [ username ]  ]  \"  )     +     \"     [  - help    [ cmd ]  ]  \"  )  )  )  ;", "if    ( isHAEnabled )     {", ". appendHAUsage ( summary )  ;", "}", "summary . append (  \"  \\ n \"  )  ;", "StringBuilder   helpBuilder    =    new   StringBuilder (  )  ;", "System . out . println ( summary )  ;", "for    ( String   cmdKey    :     . ADMIN _ USAGE . keySet (  )  )     {", ". buildHelpMsg ( cmdKey ,    helpBuilder )  ;", "helpBuilder . append (  \"  \\ n \"  )  ;", "}", "if    ( isHAEnabled )     {", "for    ( String   cmdKey    :    USAGE . keySet (  )  )     {", "if    (  !  ( cmdKey . equals (  \"  - help \"  )  )  )     {", ". buildHelpMsg ( cmdKey ,    helpBuilder )  ;", "helpBuilder . append (  \"  \\ n \"  )  ;", "}", "}", "}", "System . out . println ( helpBuilder )  ;", "System . out . println (  )  ;", "ToolRunner . printGenericCommandUsage ( System . out )  ;", "}", "METHOD_END"], "methodName": ["printHelp"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   usageBuilder    =    new   StringBuilder (  )  ;", "if    (  (  . ADMIN _ USAGE . containsKey ( cmd )  )     |  |     ( USAGE . containsKey ( cmd )  )  )     {", ". buildIndividualUsageMsg ( cmd ,    usageBuilder )  ;", "} else    {", ". buildUsageMsg ( usageBuilder ,    isHAEnabled )  ;", "}", "System . err . println ( usageBuilder )  ;", "ToolRunner . printGenericCommandUsage ( System . err )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshAdminAclsRequest   request    =    recordFactory . newRecordInstance ( RefreshAdminAclsRequest . class )  ;", "adminProtocol . refreshAdminAcls ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshAdminAcls"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshNodesRequest   request    =    recordFactory . newRecordInstance ( RefreshNodesRequest . class )  ;", "adminProtocol . refreshNodes ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshNodes"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshQueuesRequest   request    =    recordFactory . newRecordInstance ( RefreshQueuesRequest . class )  ;", "adminProtocol . refreshQueues ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshQueues"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshServiceAclsRequest   request    =    recordFactory . newRecordInstance ( RefreshServiceAclsRequest . class )  ;", "adminProtocol . refreshServiceAcls ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshServiceAcls"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshSuperUserGroupsConfigurationRequest   request    =    recordFactory . newRecordInstance ( RefreshSuperUserGroupsConfigurationRequest . class )  ;", "adminProtocol . refreshSuperUserGroupsConfiguration ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshSuperUserGroupsConfiguration"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "ResourceManagerAdministrationProtocol   adminProtocol    =    createAdminProtocol (  )  ;", "RefreshUserToGroupsMappingsRequest   request    =    recordFactory . newRecordInstance ( RefreshUserToGroupsMappingsRequest . class )  ;", "adminProtocol . refreshUserToGroupsMappings ( request )  ;", "return    0  ;", "}", "METHOD_END"], "methodName": ["refreshUserToGroupsMappings"], "fileName": "org.apache.hadoop.yarn.client.cli.RMAdminCLI"}, {"methodBody": ["METHOD_START", "{", "YarnClient   mockClient    =    mock ( YarnClient . class )  ;", "ApplicationReport   mockAppReport    =    mock ( ApplicationReport . class )  ;", "doReturn ( appState )  . when ( mockAppReport )  . getYarnApplicationState (  )  ;", "doReturn ( mockAppReport )  . when ( mockClient )  . getApplicationReport ( any ( ApplicationId . class )  )  ;", "return   mockClient ;", "}", "METHOD_END"], "methodName": ["createMockYarnClient"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "YarnClient   mockClient    =    mock ( YarnClient . class )  ;", "doThrow ( new   YarnException (  \" Unknown   AppId \"  )  )  . when ( mockClient )  . getApplicationReport ( any ( ApplicationId . class )  )  ;", "return   mockClient ;", "}", "METHOD_END"], "methodName": ["createMockYarnClientUnknownApp"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "sysOutStream    =    new   ByteArrayOutputStream (  )  ;", "sysOut    =    new   PriStream ( sysOutStream )  ;", "System . setOut ( sysOut )  ;", "sysErrStream    =    new   ByteArrayOutputStream (  )  ;", "sysErr    =    new   PriStream ( sysErrStream )  ;", "System . setErr ( sysErr )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "conf . setClass (  \" fs . file . impl \"  ,    LocalFileSystem . class ,    FileSystem . class )  ;", "LogCLIHelpers   cliHelper    =    new   LogCLIHelpers (  )  ;", "cliHelper . setConf ( conf )  ;", "YarnClient   mockYarnClient    =    createMockYarnClient ( FINISHED )  ;", "LogsCLI   dumper    =    new    . LogsCLIForTest ( mockYarnClient )  ;", "dumper . setConf ( conf )  ;", "int   exitCode    =    dumper . run ( new   String [  ]  {     \"  - applicationId \"  ,     \" application _  0  _  0  \"     }  )  ;", "assertTrue (  \" Should   return   an   error   code \"  ,     ( exitCode    !  =     0  )  )  ;", "exitCode    =    cliHelper . dumpAContainersLogs (  \" application _  0  _  0  \"  ,     \" container _  0  _  0  \"  ,     \" nonexistentnode :  1  2  3  4  \"  ,     \" nobody \"  )  ;", "assertTrue (  \" Should   return   an   error   code \"  ,     ( exitCode    !  =     0  )  )  ;", "}", "METHOD_END"], "methodName": ["testFailResultCodes"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "YarnClient   mockYarnClient    =    createMockYarnClient ( FINISHED )  ;", "LogsCLI   dumper    =    new    . LogsCLIForTest ( mockYarnClient )  ;", "dumper . setConf ( conf )  ;", "int   exitCode    =    dumper . run ( new   String [  ]  {        }  )  ;", "assertTrue (  ( exitCode    =  =     (  -  1  )  )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Retrieve   logs   for   completed   YARN   applications .  \"  )  ;", "pw . println (  \" usage :    yarn   logs    - applicationId    < application   ID >     [ OPTIONS ]  \"  )  ;", "pw . println (  )  ;", "pw . println (  \" general   options   are :  \"  )  ;", "pw . println (  \"     - appOwner    < Application   Owner >          AppOwner    ( assumed   to   be   current   user   if \"  )  ;", "pw . println (  \"                                                                                                    not   specified )  \"  )  ;", "pw . println (  \"     - containerId    < Container   ID >                ContainerId    ( must   be   specified   if   node \"  )  ;", "pw . println (  \"                                                                                                    address   is   specified )  \"  )  ;", "pw . println (  \"     - nodeAddress    < Node   Address >                NodeAddress   in   the   format   nodename : port \"  )  ;", "pw . println (  \"                                                                                                     ( must   be   specified   if   container   id   is \"  )  ;", "pw . println (  \"                                                                                                    specified )  \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "YarnClient   mockYarnClient    =    createMockYarnClient ( FINISHED )  ;", "LogsCLI   cli    =    new    . LogsCLIForTest ( mockYarnClient )  ;", "cli . setConf ( conf )  ;", "int   exitCode    =    cli . run ( new   String [  ]  {     \"  - applicationId \"  ,     \" not _ an _ app _ id \"     }  )  ;", "assertTrue (  ( exitCode    =  =     (  -  1  )  )  )  ;", "assertTrue ( sysErrStream . toString (  )  . startsWith (  \" Invalid   ApplicationId   specified \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testInvalidApplicationId"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "Configuration   conf    =    new   YarnConfiguration (  )  ;", "YarnClient   mockYarnClient    =    createMockYarnClientUnknownApp (  )  ;", "LogsCLI   cli    =    new    . LogsCLIForTest ( mockYarnClient )  ;", "cli . setConf ( conf )  ;", "int   exitCode    =    cli . run ( new   String [  ]  {     \"  - applicationId \"  ,    ApplicationId . newInstance (  1  ,     1  )  . toString (  )     }  )  ;", "assertTrue (  ( exitCode    !  =     0  )  )  ;", "assertTrue ( sysErrStream . toString (  )  . startsWith (  \" Unable   to   get   ApplicationState \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testUnknownApplicationId"], "fileName": "org.apache.hadoop.yarn.client.cli.TestLogsCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    new   ApplicationCLI (  )  ;", "cli . setClient (  )  ;", "cli . setSysOutPrintStream ( sysOut )  ;", "return   cli ;", "}", "METHOD_END"], "methodName": ["createAndGetAppCLI"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" usage :    applicationattempt \"  )  ;", "pw . println (  \"     - help                                                                                          Displays   help   for   all   commands .  \"  )  ;", "pw . println (  \"     - list    < Application   ID >                                        List   application   attempts   for \"  )  ;", "pw . println (  \"                                                                                                             aplication .  \"  )  ;", "pw . println (  \"     - status    < Application   Attempt   ID >          Prints   the   status   of   the   application \"  )  ;", "pw . println (  \"                                                                                                             attempt .  \"  )  ;", "pwose (  )  ;", "String   appsHelpStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "return   appsHelpStr ;", "}", "METHOD_END"], "methodName": ["createApplicationAttemptCLIHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" usage :    application \"  )  ;", "pw . println (  \"     - appStates    < States >                                        Works   with    - list   to   filter   applications \"  )  ;", "pw . println (  \"                                                                                                    based   on   input   comma - separated   list   of \"  )  ;", "pw . println (  \"                                                                                                    application   states .    The   valid   application \"  )  ;", "pw . println (  \"                                                                                                    state   can   be   one   of   the   following :  \"  )  ;", "pw . println (  \"                                                                                                    ALL , NEW , NEW _ SAVING , SUBMITTED , ACCEPTED , RUN \"  )  ;", "pw . println (  \"                                                                                                    NING , FINISHED , FAILED , KILLED \"  )  ;", "pw . println (  \"     - appTypes    < Types >                                              Works   with    - list   to   filter   applications \"  )  ;", "pw . println (  \"                                                                                                    based   on   input   comma - separated   list   of \"  )  ;", "pw . println (  \"                                                                                                    application   types .  \"  )  ;", "pw . println (  \"     - help                                                                                 Displays   help   for   all   commands .  \"  )  ;", "pw . println (  \"     - kill    < Application   ID >                               Kills   the   application .  \"  )  ;", "pw . println (  \"     - list                                                                                 List   applications .    Supports   optional   use \"  )  ;", "pw . println (  \"                                                                                                    of    - appTypes   to   filter   applications   based \"  )  ;", "pw . println (  \"                                                                                                    on   application   type ,    and    - appStates   to \"  )  ;", "pw . println (  \"                                                                                                    filter   applications   based   on   application \"  )  ;", "pw . println (  \"                                                                                                    state .  \"  )  ;", "pw . println (  \"     - movetoqueue    < Application   ID >          Moves   the   application   to   a   differ \"  )  ;", "pw . println (  \"                                                                                                    queue .  \"  )  ;", "pw . println (  \"     - queue    < Queue   Name >                                        Works   with   the   movetoqueue   command   to \"  )  ;", "pw . println (  \"                                                                                                    specify   which   queue   to   move   an \"  )  ;", "pw . println (  \"                                                                                                    application   to .  \"  )  ;", "pw . println (  \"     - status    < Application   ID >                         Prints   the   status   of   the   application .  \"  )  ;", "pw . close (  )  ;", "String   appsHelpStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "return   appsHelpStr ;", "}", "METHOD_END"], "methodName": ["createApplicationCLIHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" usage :    container \"  )  ;", "pw . println (  \"     - help                                                                                    Displays   help   for   all   commands .  \"  )  ;", "pw . println (  \"     - list    < Application   Attempt   ID >          List   containers   for   application   attempt .  \"  )  ;", "pw . println (  \"     - status    < Container   ID >                                  Prints   the   status   of   the   container .  \"  )  ;", "pwose (  )  ;", "String   appsHelpStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "return   appsHelpStr ;", "}", "METHOD_END"], "methodName": ["createContainerCLIHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" usage :    node \"  )  ;", "pw . println (  \"     - all                                             Works   with    - list   to   list   all   nodes .  \"  )  ;", "pw . println (  \"     - list                                          List   all   running   nodes .    Supports   optional   use   of \"  )  ;", "pw . println (  \"                                                              - states   to   filter   nodes   based   on   node   state ,    all    - all \"  )  ;", "pw . println (  \"                                                             to   list   all   nodes .  \"  )  ;", "pw . println (  \"     - states    < States >          Works   with    - list   to   filter   nodes   based   on   input \"  )  ;", "pw . println (  \"                                                             comma - separated   list   of   node   states .  \"  )  ;", "pw . println (  \"     - status    < NodeId >          Prints   the   status   report   of   the   node .  \"  )  ;", "pwose (  )  ;", "String   nodesHelpStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "return   nodesHelpStr ;", "}", "METHOD_END"], "methodName": ["createNodeCLIHelpMessage"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "List < ApplicationReport >    appReports    =    new   ArrayList < ApplicationReport >  (  )  ;", "if    ( allStates )     {", "for    ( YarnApplicationState   state    :    YarnApplicationState . values (  )  )     {", "appStates . add ( state )  ;", "}", "}", "for    ( ApplicationReport   appReport    :    applicationReports )     {", "if    (  ( appTypes    !  =    null )     &  &     (  !  ( appTypes . isEmpty (  )  )  )  )     {", "if    (  !  ( appTypes . contains ( appReport . getApplicationType (  )  )  )  )     {", "continue ;", "}", "}", "if    (  ( appStates    !  =    null )     &  &     (  !  ( appStates . isEmpty (  )  )  )  )     {", "if    (  !  ( appStates . contains ( appReport . geApplicationState (  )  )  )  )     {", "continue ;", "}", "}", "appReports . add ( appReport )  ;", "}", "return   appReports ;", "}", "METHOD_END"], "methodName": ["getApplicationReports"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "List < NodeReport >    nodeReports    =    new   ArrayList < NodeReport >  (  )  ;", "for    ( int   i    =     0  ;    i    <    noOfNodes ;    i +  +  )     {", "NodeReport   nodeReport    =    NodeReport . newInstance ( NodeId . newInstance (  (  \" host \"     +    i )  ,     0  )  ,    state ,     (  (  \" host \"     +     1  )     +     \"  :  8  8  8  8  \"  )  ,     \" rack 1  \"  ,    Records . newRecord ( Resourceass )  ,    Records . newRecord ( Resourceass )  ,     0  ,     \"  \"  ,     0  )  ;", "nodeReports . add ( nodeReport )  ;", "}", "return   nodeReports ;", "}", "METHOD_END"], "methodName": ["getNodeReports"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "List < NodeReport >    reports    =    new   ArrayList < NodeReport >  (  )  ;", "for    ( NodeReport   nodeReport    :    nodeReports )     {", "if    ( nodeStates . contains ( nodeReport . getNodeState (  )  )  )     {", "reports . add ( nodeReport )  ;", "}", "}", "return   reports ;", "}", "METHOD_END"], "methodName": ["getNodeReports"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "sysOutStream    =    new   ByteArrayOutputStream (  )  ;", "sysOut    =    spy ( new   PriStream ( sysOutStream )  )  ;", "sysErrStream    =    new   ByteArrayOutputStream (  )  ;", "sysErr    =    spy ( new   PriStream ( sysErrStream )  )  ;", "System . setOut ( sysOut )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "NodeId   nodeId    =    NodeId . newInstance (  \" Absenthost 0  \"  ,     0  )  ;", "NodeCLI   cli    =    new   NodeCLI (  )  ;", "when ( getNodeReports (  )  )  . thenReturn ( getNodeReports (  0  ,    RUNNING )  )  ;", "cli . setClient (  ;", "cli . setSysOutPrintStream ( sysOut )  ;", "cli . setSysErrPrintStream ( sysErr )  ;", "int   result    =    cli . run ( new   String [  ]  {     \"  - status \"  ,    nodeId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports (  )  ;", "verify ( sysOut ,    times (  1  )  )  . println ( isA ( String . class )  )  ;", "verify ( sysOut )  . println (  (  \" Could   not   find   the   node   report   for   node   id    :     \"     +     ( nodeId . toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testAbsentNodeStatus"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationCLI   spyCli    =    spy ( cli )  ;", "int   result    =    spyCli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - help \"     }  )  ;", "Assert . assertTrue (  ( result    =  =     0  )  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationAttemptCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "result    =    cli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - list \"  ,    applicationId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationAttemptCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     6  )  ;", "result    =    cli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - status \"  ,    appAttemptId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationAttemptCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAppAttemptsHelpCommand"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "verifyUsageInfo ( new   ApplicationCLI (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAppCLIUsageInfo"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationCLI   spyCli    =    spy ( cli )  ;", "int   result    =    spyCli . run ( new   String [  ]  {     \" application \"  ,     \"  - help \"     }  )  ;", "Assert . assertTrue (  ( result    =  =     0  )  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - kill \"  ,    applicationId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "NodeId   nodeId    =    NodeId . newInstance (  \" host 0  \"  ,     0  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - status \"  ,    nodeId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createApplicationCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAppsHelpCommand"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationCLI   spyCli    =    spy ( cli )  ;", "int   result    =    spyCli . run ( new   String [  ]  {     \" container \"  ,     \"  - help \"     }  )  ;", "Assert . assertTrue (  ( result    =  =     0  )  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createContainerCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   appAttemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     6  )  ;", "result    =    cli . run ( new   String [  ]  {     \" container \"  ,     \"  - list \"  ,    appAttemptId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createContainerCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( appAttemptId ,     7  )  ;", "result    =    cli . run ( new   String [  ]  {     \" container \"  ,     \"  - status \"  ,    containerId . toString (  )  ,     \" args \"     }  )  ;", "verify ( spyCli )  . printUsage ( any ( String . class )  ,    any ( Options . class )  )  ;", "Assert . assertEquals ( createContainerCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testContainersHelpCommand"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   attemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ApplicationAttemptReport   attemptReport    =    ApplicationAttemptReport . newInstance ( attemptId ,     \" host \"  ,     1  2  4  ,     \" url \"  ,     \" diagnostics \"  ,    FINISHED ,    ContainerId . newInstance ( attemptId ,     1  )  )  ;", "when ( getApplicationAttemptReport ( any ( ApplicationAttemptId . class )  )  )  . thenReturn ( attemptReport )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - status \"  ,    attemptId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplicationAttemptReport ( attemptId )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Application   Attempt   Report    :     \"  )  ;", "pw . println (  \"  \\ tApplicationAttempt - Id    :    appattempt _  1  2  3  4  _  0  0  0  5  _  0  0  0  0  0  1  \"  )  ;", "pw . println (  \"  \\ tState    :    FINISHED \"  )  ;", "pw . println (  \"  \\ tAMContainer    :    container _  1  2  3  4  _  0  0  0  5  _  0  1  _  0  0  0  0  0  1  \"  )  ;", "pw . println (  \"  \\ tTracking - URL    :    url \"  )  ;", "pw . println (  \"  \\ tRPC   Port    :     1  2  4  \"  )  ;", "pw . println (  \"  \\ tAM   Host    :    host \"  )  ;", "pw . println (  \"  \\ tDiagnostics    :    diagnostics \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  1  )  )  . println ( isA ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttemptReport"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   attemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ApplicationAttemptId   attemptId 1     =    ApplicationAttemptId . newInstance ( applicationId ,     2  )  ;", "ApplicationAttemptReport   attemptReport    =    ApplicationAttemptReport . newInstance ( attemptId ,     \" host \"  ,     1  2  4  ,     \" url \"  ,     \" diagnostics \"  ,    FINISHED ,    ContainerId . newInstance ( attemptId ,     1  )  )  ;", "ApplicationAttemptReport   attemptReport 1     =    ApplicationAttemptReport . newInstance ( attemptId 1  ,     \" host \"  ,     1  2  4  ,     \" url \"  ,     \" diagnostics \"  ,    FINISHED ,    ContainerId . newInstance ( attemptId 1  ,     1  )  )  ;", "List < ApplicationAttemptReport >    reports    =    new   ArrayList < ApplicationAttemptReport >  (  )  ;", "reports . add ( attemptReport )  ;", "reports . add ( attemptReport 1  )  ;", "when ( getApplicationAttempts ( any ( ApplicationId . class )  )  )  . thenReturn ( reports )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - list \"  ,    applicationId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplicationAttempts ( applicationId )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   number   of   application   attempts    :  2  \"  )  ;", "pw . print (  \"                            ApplicationAttempt - Id \"  )  ;", "pw . print (  \"  \\ t                                             State \"  )  ;", "pw . print (  \"  \\ t                                                            AM - Container - Id \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"          appattempt _  1  2  3  4  _  0  0  0  5  _  0  0  0  0  0  1  \"  )  ;", "pw . print (  \"  \\ t                                    FINISHED \"  )  ;", "pw . print (  \"  \\ t                  container _  1  2  3  4  _  0  0  0  5  _  0  1  _  0  0  0  0  0  1  \"  )  ;", "pw . println (  \"  \\ t                                                                                                url \"  )  ;", "pw . print (  \"          appattempt _  1  2  3  4  _  0  0  0  5  _  0  0  0  0  0  2  \"  )  ;", "pw . print (  \"  \\ t                                    FINISHED \"  )  ;", "pw . print (  \"  \\ t                  container _  1  2  3  4  _  0  0  0  5  _  0  2  _  0  0  0  0  0  1  \"  )  ;", "pw . println (  \"  \\ t                                                                                                url \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationAttempts"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationReport   newApplicationReport    =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    FINISHED ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenReturn ( newApplicationReport )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - status \"  ,    applicationId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplicationReport ( applicationId )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Application   Report    :     \"  )  ;", "pw . println (  \"  \\ tApplication - Id    :    application _  1  2  3  4  _  0  0  0  5  \"  )  ;", "pw . println (  \"  \\ tApplication - Name    :    appname \"  )  ;", "pw . println (  \"  \\ tApplication - Type    :    YARN \"  )  ;", "pw . println (  \"  \\ tUser    :    user \"  )  ;", "pw . println (  \"  \\ tQueue    :    queue \"  )  ;", "pw . println (  \"  \\ tStart - Time    :     0  \"  )  ;", "pw . println (  \"  \\ tFinish - Time    :     0  \"  )  ;", "pw . println (  \"  \\ tProgress    :     5  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ tState    :    FINISHED \"  )  ;", "pw . println (  \"  \\ tFinal - State    :    SUCCEEDED \"  )  ;", "pw . println (  \"  \\ tTracking - URL    :    N / A \"  )  ;", "pw . println (  \"  \\ tRPC   Port    :     1  2  4  \"  )  ;", "pw . println (  \"  \\ tAM   Host    :    host \"  )  ;", "pw . println (  \"  \\ tDiagnostics    :    diagnostics \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  1  )  )  . println ( isA ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplicationReport"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenThrow ( new   ApplicationNotFoundException (  (  (  \" History   file   for   application \"     +    applicationId )     +     \"    is   not   found \"  )  )  )  ;", "try    {", "cli . run ( new   String [  ]  {     \" application \"  ,     \"  - status \"  ,    applicationId . toString (  )     }  )  ;", "Assert . fail (  )  ;", "}    catch    ( Exception   ex )     {", "Assert . assertTrue (  ( ex   instanceof   ApplicationNotFoundException )  )  ;", "Assert . assertEquals (  (  (  \" History   file   for   application \"     +    applicationId )     +     \"    is   not   found \"  )  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetApplicationReportException"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationReport   newApplicationReport    =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    RUNNING ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "List < ApplicationReport >    applicationReports    =    new   ArrayList < ApplicationReport >  (  )  ;", "applicationReports . add ( newApplicationReport )  ;", "ApplicationId   applicationId 2     =    ApplicationId . newInstance (  1  2  3  4  ,     6  )  ;", "ApplicationReport   newApplicationReport 2     =    ApplicationReport . newInstance ( applicationId 2  ,    ApplicationAttemptId . newInstance ( applicationId 2  ,     2  )  ,     \" user 2  \"  ,     \" queue 2  \"  ,     \" appname 2  \"  ,     \" host 2  \"  ,     1  2  5  ,    null ,    FINISHED ,     \" diagnostics 2  \"  ,     \" url 2  \"  ,     2  ,     2  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  6  3  7  8  9 F ,     \" NON - YARN \"  ,    null )  ;", "applicationReports . add ( newApplicationReport 2  )  ;", "ApplicationId   applicationId 3     =    ApplicationId . newInstance (  1  2  3  4  ,     7  )  ;", "ApplicationReport   newApplicationReport 3     =    ApplicationReport . newInstance ( applicationId 3  ,    ApplicationAttemptId . newInstance ( applicationId 3  ,     3  )  ,     \" user 3  \"  ,     \" queue 3  \"  ,     \" appname 3  \"  ,     \" host 3  \"  ,     1  2  6  ,    null ,    RUNNING ,     \" diagnostics 3  \"  ,     \" url 3  \"  ,     3  ,     3  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  7  3  7  8  9 F ,     \" MAPREDUCE \"  ,    null )  ;", "applicationReports . add ( newApplicationReport 3  )  ;", "ApplicationId   applicationId 4     =    ApplicationId . newInstance (  1  2  3  4  ,     8  )  ;", "ApplicationReport   newApplicationReport 4     =    ApplicationReport . newInstance ( applicationId 4  ,    ApplicationAttemptId . newInstance ( applicationId 4  ,     4  )  ,     \" user 4  \"  ,     \" queue 4  \"  ,     \" appname 4  \"  ,     \" host 4  \"  ,     1  2  7  ,    null ,    FAILED ,     \" diagnostics 4  \"  ,     \" url 4  \"  ,     4  ,     4  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  8  3  7  8  9 F ,     \" NON - MAPREDUCE \"  ,    null )  ;", "applicationReports . add ( newApplicationReport 4  )  ;", "ApplicationId   applicationId 5     =    ApplicationId . newInstance (  1  2  3  4  ,     9  )  ;", "ApplicationReport   newApplicationReport 5     =    ApplicationReport . newInstance ( applicationId 5  ,    ApplicationAttemptId . newInstance ( applicationId 5  ,     5  )  ,     \" user 5  \"  ,     \" queue 5  \"  ,     \" appname 5  \"  ,     \" host 5  \"  ,     1  2  8  ,    null ,    ACCEPTED ,     \" diagnostics 5  \"  ,     \" url 5  \"  ,     5  ,     5  ,    KILLED ,    null ,     \" N / A \"  ,     0  .  9  3  7  8  9 F ,     \" HIVE \"  ,    null )  ;", "applicationReports . add ( newApplicationReport 5  )  ;", "ApplicationId   applicationId 6     =    ApplicationId . newInstance (  1  2  3  4  ,     1  0  )  ;", "ApplicationReport   newApplicationReport 6     =    ApplicationReport . newInstance ( applicationId 6  ,    ApplicationAttemptId . newInstance ( applicationId 6  ,     6  )  ,     \" user 6  \"  ,     \" queue 6  \"  ,     \" appname 6  \"  ,     \" host 6  \"  ,     1  2  9  ,    null ,    SUBMITTED ,     \" diagnostics 6  \"  ,     \" url 6  \"  ,     6  ,     6  ,    KILLED ,    null ,     \" N / A \"  ,     0  .  9  9  7  8  9 F ,     \" PIG \"  ,    null )  ;", "applicationReports . add ( newApplicationReport 6  )  ;", "Set < String >    appType 1     =    new   HashSet < String >  (  )  ;", "EnumSet < YarnApplicationState >    appState 1     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 1  . add ( RUNNING )  ;", "appState 1  . add ( ACCEPTED )  ;", "appState 1  . add ( SUBMITTED )  ;", "when ( getApplications ( appType 1  ,    appState 1  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 1  ,    appState 1  ,    false )  )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 1  ,    appState 1  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 1  )     +     \"    and   states :     \"  )     +    appState 1  )     +     \"  )  \"  )     +     \"  :  \"  )     +     4  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  5  \\ t                                        \"  )  ;", "pw . print (  \" appname \\ t                                                YARN \\ t                  user \\ t                \"  )  ;", "pw . print (  \" queue \\ t                                 RUNNING \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            5  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  7  \\ t                                     \"  )  ;", "pw . print (  \" appname 3  \\ t                                 MAPREDUCE \\ t               user 3  \\ t             \"  )  ;", "pw . print (  \" queue 3  \\ t                                 RUNNING \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            7  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  9  \\ t                                     \"  )  ;", "pw . print (  \" appname 5  \\ t                                                HIVE \\ t               user 5  \\ t             \"  )  ;", "pw . print (  \" queue 5  \\ t                              ACCEPTED \\ t                                     \"  )  ;", "pw . print (  \" KILLED \\ t                            9  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  1  0  \\ t                                     \"  )  ;", "pw . print (  \" appname 6  \\ t                                                   PIG \\ t               user 6  \\ t             \"  )  ;", "pw . print (  \" queue 6  \\ t                           SUBMITTED \\ t                                     \"  )  ;", "pw . print (  \" KILLED \\ t                            9  9  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "String   appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  1  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "Set < String >    appType 2     =    new   HashSet < String >  (  )  ;", "appType 2  . add (  \" YARN \"  )  ;", "appType 2  . add (  \" NON - YARN \"  )  ;", "EnumSet < YarnApplicationState >    appState 2     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 2  . add ( RUNNING )  ;", "appState 2  . add ( ACCEPTED )  ;", "appState 2  . add ( SUBMITTED )  ;", "when ( getApplications ( appType 2  ,    appState 2  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 2  ,    appState 2  ,    false )  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  - appTypes \"  ,     \" YARN ,     ,  ,       NON - YARN \"  ,     \"           ,  ,     ,  ,  \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 2  ,    appState 2  )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 2  )     +     \"    and   states :     \"  )     +    appState 2  )     +     \"  )  \"  )     +     \"  :  \"  )     +     1  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  5  \\ t                                        \"  )  ;", "pw . print (  \" appname \\ t                                                YARN \\ t                  user \\ t                \"  )  ;", "pw . print (  \" queue \\ t                                 RUNNING \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            5  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  2  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "Set < String >    appType 3     =    new   HashSet < String >  (  )  ;", "EnumSet < YarnApplicationState >    appState 3     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 3  . add ( FINISHED )  ;", "appState 3  . add ( FAILED )  ;", "when ( getApplications ( appType 3  ,    appState 3  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 3  ,    appState 3  ,    false )  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  -  - appStates \"  ,     \" FINISHED    ,  ,     ,    FAILED \"  ,     \"  ,  , FINISHED \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 3  ,    appState 3  )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 3  )     +     \"    and   states :     \"  )     +    appState 3  )     +     \"  )  \"  )     +     \"  :  \"  )     +     2  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  6  \\ t                                     \"  )  ;", "pw . print (  \" appname 2  \\ t                                    NON - YARN \\ t               user 2  \\ t             \"  )  ;", "pw . print (  \" queue 2  \\ t                              FINISHED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            6  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  8  \\ t                                     \"  )  ;", "pw . print (  \" appname 4  \\ t                     NON - MAPREDUCE \\ t               user 4  \\ t             \"  )  ;", "pw . print (  \" queue 4  \\ t                                    FAILED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            8  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  3  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "Set < String >    appType 4     =    new   HashSet < String >  (  )  ;", "appType 4  . add (  \" YARN \"  )  ;", "appType 4  . add (  \" NON - YARN \"  )  ;", "EnumSet < YarnApplicationState >    appState 4     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 4  . add ( FINISHED )  ;", "appState 4  . add ( FAILED )  ;", "when ( getApplications ( appType 4  ,    appState 4  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 4  ,    appState 4  ,    false )  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  -  - appTypes \"  ,     \" YARN , NON - YARN \"  ,     \"  -  - appStates \"  ,     \" FINISHED    ,  ,     ,    FAILED \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 2  ,    appState 2  )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 4  )     +     \"    and   states :     \"  )     +    appState 4  )     +     \"  )  \"  )     +     \"  :  \"  )     +     1  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  6  \\ t                                     \"  )  ;", "pw . print (  \" appname 2  \\ t                                    NON - YARN \\ t               user 2  \\ t             \"  )  ;", "pw . print (  \" queue 2  \\ t                              FINISHED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            6  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  4  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  -  - appStates \"  ,     \" FINISHED    ,  ,     ,    INVALID \"     }  )  ;", "assertEquals (  (  -  1  )  ,    result )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" The   application   state      INVALID   is   invalid .  \"  )  ;", "pw . print (  \" The   valid   application   state   can   be   one   of   the   following :     \"  )  ;", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "sb . append (  \" ALL ,  \"  )  ;", "for    ( YarnApplicationState   state    :    YarnApplicationState . values (  )  )     {", "sb . append (  ( state    +     \"  ,  \"  )  )  ;", "}", "String   output    =    sb . toString (  )  ;", "pw . println ( output . substring (  0  ,     (  ( output . length (  )  )     -     1  )  )  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  4  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "Set < String >    appType 5     =    new   HashSet < String >  (  )  ;", "EnumSet < YarnApplicationState >    appState 5     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 5  . add ( FINISHED )  ;", "when ( getApplications ( appType 5  ,    appState 5  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 5  ,    appState 5  ,    true )  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  -  - appStates \"  ,     \" FINISHED    ,  ,     ,    ALL \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 5  ,    appState 5  )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 5  )     +     \"    and   states :     \"  )     +    appState 5  )     +     \"  )  \"  )     +     \"  :  \"  )     +     6  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  5  \\ t                                        \"  )  ;", "pw . print (  \" appname \\ t                                                YARN \\ t                  user \\ t                \"  )  ;", "pw . print (  \" queue \\ t                                 RUNNING \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            5  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  6  \\ t                                     \"  )  ;", "pw . print (  \" appname 2  \\ t                                    NON - YARN \\ t               user 2  \\ t             \"  )  ;", "pw . print (  \" queue 2  \\ t                              FINISHED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            6  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  7  \\ t                                     \"  )  ;", "pw . print (  \" appname 3  \\ t                                 MAPREDUCE \\ t               user 3  \\ t             \"  )  ;", "pw . print (  \" queue 3  \\ t                                 RUNNING \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            7  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  8  \\ t                                     \"  )  ;", "pw . print (  \" appname 4  \\ t                     NON - MAPREDUCE \\ t               user 4  \\ t             \"  )  ;", "pw . print (  \" queue 4  \\ t                                    FAILED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            8  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  9  \\ t                                     \"  )  ;", "pw . print (  \" appname 5  \\ t                                                HIVE \\ t               user 5  \\ t             \"  )  ;", "pw . print (  \" queue 5  \\ t                              ACCEPTED \\ t                                     \"  )  ;", "pw . print (  \" KILLED \\ t                            9  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  1  0  \\ t                                     \"  )  ;", "pw . print (  \" appname 6  \\ t                                                   PIG \\ t               user 6  \\ t             \"  )  ;", "pw . print (  \" queue 6  \\ t                           SUBMITTED \\ t                                     \"  )  ;", "pw . print (  \" KILLED \\ t                            9  9  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  5  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "Set < String >    appType 6     =    new   HashSet < String >  (  )  ;", "appType 6  . add (  \" YARN \"  )  ;", "appType 6  . add (  \" NON - YARN \"  )  ;", "EnumSet < YarnApplicationState >    appState 6     =    EnumSet . noneOf ( YarnApplicationState . class )  ;", "appState 6  . add ( FINISHED )  ;", "when ( getApplications ( appType 6  ,    appState 6  )  )  . thenReturn ( getApplicationReports ( applicationReports ,    appType 6  ,    appState 6  ,    false )  )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - list \"  ,     \"  - appTypes \"  ,     \" YARN ,     ,  ,       NON - YARN \"  ,     \"  -  - appStates \"  ,     \" finished \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getApplications ( appType 6  ,    appState 6  )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  (  (  (  (  (  (  \" Total   number   of   applications    ( application - types :     \"     +    appType 6  )     +     \"    and   states :     \"  )     +    appState 6  )     +     \"  )  \"  )     +     \"  :  \"  )     +     1  )  )  ;", "pw . print (  \"                                                 Application - Id \\ t            Application - Name \"  )  ;", "pw . print (  \"  \\ t            Application - Type \"  )  ;", "pw . print (  \"  \\ t                  User \\ t               Queue \\ t                                       State \\ t                      \"  )  ;", "pw . print (  \" Final - State \\ t                     Progress \"  )  ;", "pw . println (  \"  \\ t                                                                     Tracking - URL \"  )  ;", "pw . print (  \"                            application _  1  2  3  4  _  0  0  0  6  \\ t                                     \"  )  ;", "pw . print (  \" appname 2  \\ t                                    NON - YARN \\ t               user 2  \\ t             \"  )  ;", "pw . print (  \" queue 2  \\ t                              FINISHED \\ t                            \"  )  ;", "pw . print (  \" SUCCEEDED \\ t                            6  3  .  7  9  %  \"  )  ;", "pw . println (  \"  \\ t                                                                                                N / A \"  )  ;", "pw . close (  )  ;", "appsReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appsReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  6  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetApplications"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   attemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( attemptId ,     1  )  ;", "ContainerReport   container    =    ContainerReport . newInstance ( containerId ,    null ,    NodeId . newInstance (  \" host \"  ,     1  2  3  4  )  ,    UNDEFINED ,     1  2  3  4  ,     5  6  7  8  ,     \" diagnosticInfo \"  ,     \" logURL \"  ,     0  ,    COMPLETE )  ;", "when ( getContainerReport ( any ( ContainerId . class )  )  )  . thenReturn ( container )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" container \"  ,     \"  - status \"  ,    containerId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getContainerReport ( containerId )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Container   Report    :     \"  )  ;", "pw . println (  \"  \\ tContainer - Id    :    container _  1  2  3  4  _  0  0  0  5  _  0  1  _  0  0  0  0  0  1  \"  )  ;", "pw . println (  \"  \\ tStart - Time    :     1  2  3  4  \"  )  ;", "pw . println (  \"  \\ tFinish - Time    :     5  6  7  8  \"  )  ;", "pw . println (  \"  \\ tState    :    COMPLETE \"  )  ;", "pw . println (  \"  \\ tLOG - URL    :    logURL \"  )  ;", "pw . println (  \"  \\ tHost    :    host :  1  2  3  4  \"  )  ;", "pw . println (  \"  \\ tDiagnostics    :    diagnosticInfo \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  1  )  )  . println ( isA ( String . class )  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainerReport"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationAttemptId   attemptId    =    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ;", "ContainerId   containerId    =    ContainerId . newInstance ( attemptId ,     1  )  ;", "ContainerId   containerId 1     =    ContainerId . newInstance ( attemptId ,     2  )  ;", "ContainerReport   container    =    ContainerReport . newInstance ( containerId ,    null ,    NodeId . newInstance (  \" host \"  ,     1  2  3  4  )  ,    UNDEFINED ,     1  2  3  4  ,     5  6  7  8  ,     \" diagnosticInfo \"  ,     \" logURL \"  ,     0  ,    COMPLETE )  ;", "ContainerReport   container 1     =    ContainerReport . newInstance ( containerId 1  ,    null ,    NodeId . newInstance (  \" host \"  ,     1  2  3  4  )  ,    UNDEFINED ,     1  2  3  4  ,     5  6  7  8  ,     \" diagnosticInfo \"  ,     \" logURL \"  ,     0  ,    COMPLETE )  ;", "List < ContainerReport >    reports    =    new   ArrayList < ContainerReport >  (  )  ;", "reports . add ( container )  ;", "reports . add ( container 1  )  ;", "when ( getContainers ( any ( ApplicationAttemptId . class )  )  )  . thenReturn ( reports )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" container \"  ,     \"  - list \"  ,    attemptId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getContainers ( attemptId )  ;", "Log . info ( sysOutStream . toString (  )  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   number   of   containers    :  2  \"  )  ;", "pw . print (  \"                                                       Container - Id \"  )  ;", "pw . print (  \"  \\ t                              Start   Time \"  )  ;", "pw . print (  \"  \\ t                           Finish   Time \"  )  ;", "pw . print (  \"  \\ t                                             State \"  )  ;", "pw . print (  \"  \\ t                                                Host \"  )  ;", "pw . println (  \"  \\ t                                                                                    LOG - URL \"  )  ;", "pw . print (  \"    container _  1  2  3  4  _  0  0  0  5  _  0  1  _  0  0  0  0  0  1  \"  )  ;", "pw . print (  \"  \\ t                                                 1  2  3  4  \"  )  ;", "pw . print (  \"  \\ t                                                 5  6  7  8  \"  )  ;", "pw . print (  \"  \\ t                                    COMPLETE \"  )  ;", "pw . print (  \"  \\ t                                 host :  1  2  3  4  \"  )  ;", "pw . println (  \"  \\ t                                                                                       logURL \"  )  ;", "pw . print (  \"    container _  1  2  3  4  _  0  0  0  5  _  0  1  _  0  0  0  0  0  2  \"  )  ;", "pw . print (  \"  \\ t                                                 1  2  3  4  \"  )  ;", "pw . print (  \"  \\ t                                                 5  6  7  8  \"  )  ;", "pw . print (  \"  \\ t                                    COMPLETE \"  )  ;", "pw . print (  \"  \\ t                                 host :  1  2  3  4  \"  )  ;", "pw . println (  \"  \\ t                                                                                       logURL \"  )  ;", "pw . close (  )  ;", "String   appReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( appReportStr ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetContainers"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationReport   newApplicationReport 2     =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    FINISHED ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenReturn ( newApplicationReport 2  )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - kill \"  ,    applicationId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (    times (  0  )  )  . killApplication ( any ( ApplicationId . class )  )  ;", "verify ( sysOut )  . println (  (  (  \" Application    \"     +    applicationId )     +     \"    has   already   finished    \"  )  )  ;", "ApplicationReport   newApplicationReport    =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    RUNNING ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenReturn ( newApplicationReport )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - kill \"  ,    applicationId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . killApplication ( any ( ApplicationId . class )  )  ;", "verify ( sysOut )  . println (  \" Killing   application   application _  1  2  3  4  _  0  0  0  5  \"  )  ;", "doThrow ( new   ApplicationNotFoundException (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  )  )  . when (  . getApplicationReport ( applicationId )  ;", "cli    =    createAndGetAppCLI (  )  ;", "try    {", "int   exitCode    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - kill \"  ,    applicationId . toString (  )     }  )  ;", "verify ( sysOut )  . println (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  )  ;", "Assert . assertNotSame (  \" should   return   non - zero   exit   code .  \"  ,     0  ,    exitCode )  ;", "}    catch    ( ApplicationNotFoundException   appEx )     {", "Assert . fail (  (  (  \" application    - kill   should   not   throw \"     +     \" ApplicationNotFoundException .     \"  )     +    appEx )  )  ;", "}    catch    ( Exception   e )     {", "Assert . fail (  (  \" Unexpected   exception :     \"     +    e )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testKillApplication"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "List < NodeReport >    nodeReports    =    new   ArrayList < NodeReport >  (  )  ;", "nodeReports . addAll ( getNodeReports (  1  ,    NEW )  )  ;", "nodeReports . addAll ( getNodeReports (  2  ,    RUNNING )  )  ;", "nodeReports . addAll ( getNodeReports (  1  ,    UNHEALTHY )  )  ;", "nodeReports . addAll ( getNodeReports (  1  ,    DECOMMISSIONED )  )  ;", "nodeReports . addAll ( getNodeReports (  1  ,    REBOOTED )  )  ;", "nodeReports . addAll ( getNodeReports (  1  ,    LOST )  )  ;", "NodeCLI   cli    =    new   NodeCLI (  )  ;", "cli . setClient (  ;", "cli . setSysOutPrintStream ( sysOut )  ;", "Set < NodeState >    nodeStates    =    new   HashSet < NodeState >  (  )  ;", "nodeStates . add ( NEW )  ;", "NodeState [  ]    states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "int   result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" NEW \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  1  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                    NEW \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "String   nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  1  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( RUNNING )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" RUNNING \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  2  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 1  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  2  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  3  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( UNHEALTHY )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" UNHEALTHY \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  1  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                  UNHEALTHY \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  4  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( DECOMMISSIONED )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" DECOMMISSIONED \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  1  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t   DECOMMISSIONED \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  5  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( REBOOTED )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" REBOOTED \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  1  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                     REBOOTED \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  6  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( LOST )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" LOST \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  1  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                 LOST \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  7  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "nodeStates . add ( NEW )  ;", "nodeStates . add ( RUNNING )  ;", "nodeStates . add ( LOST )  ;", "nodeStates . add ( REBOOTED )  ;", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - states \"  ,     \" NEW , RUNNING , LOST , REBOOTED \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  5  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                    NEW \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 1  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                     REBOOTED \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                 LOST \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  8  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "sysOutStream . reset (  )  ;", "nodeStates . clear (  )  ;", "for    ( NodeState   s    :    NodeState . values (  )  )     {", "nodeStates . add ( s )  ;", "}", "states    =    nodeStates . toArray ( new   NodeState [  0  ]  )  ;", "when ( getNodeReports ( states )  )  . thenReturn ( getNodeReports ( nodeReports ,    nodeStates )  )  ;", "result    =    cli . run ( new   String [  ]  {     \"  - list \"  ,     \"  -  - all \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports ( states )  ;", "baos    =    new   ByteArrayOutputStream (  )  ;", "pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Total   Nodes :  7  \"  )  ;", "pw . print (  \"                            Node - Id \\ t               Node - State \\ tNode - Http - Address \\ t \"  )  ;", "pw . println (  \" Number - of - Running - Containers \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                    NEW \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 1  :  0  \\ t                        RUNNING \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                  UNHEALTHY \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t   DECOMMISSIONED \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                     REBOOTED \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . print (  \"                            host 0  :  0  \\ t                                 LOST \\ t                     host 1  :  8  8  8  8  \\ t \"  )  ;", "pw . println (  \"                                                                                   0  \"  )  ;", "pw . close (  )  ;", "nodesReportStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "Assert . assertEquals ( nodesReportStr ,    sysOutStream . toString (  )  )  ;", "verify ( sysOut ,    times (  9  )  )  . write ( any ( byte [  ]  . class )  ,    anyInt (  )  ,    anyInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["testListClusterNodes"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - status \"     }  )  ;", "Assert . assertEquals ( result ,     (  -  1  )  )  ;", "Assert . assertEquals ( String . format (  \" Missing   argument   for   options % n %  1 s \"  ,    createApplicationCLIHelpMessage (  )  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "result    =    cli . run ( new   String [  ]  {     \" applicationattempt \"  ,     \"  - status \"     }  )  ;", "Assert . assertEquals ( result ,     (  -  1  )  )  ;", "Assert . assertEquals ( String . format (  \" Missing   argument   for   options % n %  1 s \"  ,    createApplicationAttemptCLIHelpMessage (  )  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "result    =    cli . run ( new   String [  ]  {     \" container \"  ,     \"  - status \"     }  )  ;", "Assert . assertEquals ( result ,     (  -  1  )  )  ;", "Assert . assertEquals ( String . format (  \" Missing   argument   for   options % n %  1 s \"  ,    createContainerCLIHelpMessage (  )  )  ,    sysOutStream . toString (  )  )  ;", "sysOutStream . reset (  )  ;", "NodeCLI   nodeCLI    =    new   NodeCLI (  )  ;", "nodeCLI . setClient (  )  ;", "nodeCLI . setSysOutPrintStream ( sysOut )  ;", "nodeCLI . setSysErrPrintStream ( sysErr )  ;", "result    =    nodeCLI . run ( new   String [  ]  {     \"  - status \"     }  )  ;", "Assert . assertEquals ( result ,     (  -  1  )  )  ;", "Assert . assertEquals ( String . format (  \" Missing   argument   for   options % n %  1 s \"  ,    createNodeCLIHelpMessage (  )  )  ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMissingArguments"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "ApplicationCLI   cli    =    createAndGetAppCLI (  )  ;", "ApplicationId   applicationId    =    ApplicationId . newInstance (  1  2  3  4  ,     5  )  ;", "ApplicationReport   newApplicationReport 2     =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    FINISHED ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenReturn ( newApplicationReport 2  )  ;", "int   result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - movetoqueue \"  ,    applicationId . toString (  )  ,     \"  - queue \"  ,     \" targetqueue \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (    times (  0  )  )  . moveApplicationAcrossQueues ( any ( ApplicationId . class )  ,    any ( String . class )  )  ;", "verify ( sysOut )  . println (  (  (  \" Application    \"     +    applicationId )     +     \"    has   already   finished    \"  )  )  ;", "ApplicationReport   newApplicationReport    =    ApplicationReport . newInstance ( applicationId ,    ApplicationAttemptId . newInstance ( applicationId ,     1  )  ,     \" user \"  ,     \" queue \"  ,     \" appname \"  ,     \" host \"  ,     1  2  4  ,    null ,    RUNNING ,     \" diagnostics \"  ,     \" url \"  ,     0  ,     0  ,    SUCCEEDED ,    null ,     \" N / A \"  ,     0  .  5  3  7  8  9 F ,     \" YARN \"  ,    null )  ;", "when ( getApplicationReport ( any ( ApplicationId . class )  )  )  . thenReturn ( newApplicationReport )  ;", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - movetoqueue \"  ,    applicationId . toString (  )  ,     \"  - queue \"  ,     \" targetqueue \"     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . moveApplicationAcrossQueues ( any ( ApplicationId . class )  ,    any ( String . class )  )  ;", "verify ( sysOut )  . println (  \" Moving   application   application _  1  2  3  4  _  0  0  0  5    to   queue   targetqueue \"  )  ;", "verify ( sysOut )  . println (  \" Successfully   completed   move .  \"  )  ;", "doThrow ( new   ApplicationNotFoundException (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  )  )  . when (  . moveApplicationAcrossQueues ( applicationId ,     \" targetqueue \"  )  ;", "cli    =    createAndGetAppCLI (  )  ;", "try    {", "result    =    cli . run ( new   String [  ]  {     \" application \"  ,     \"  - movetoqueue \"  ,    applicationId . toString (  )  ,     \"  - queue \"  ,     \" targetqueue \"     }  )  ;", "Assert . fail (  )  ;", "}    catch    ( Exception   ex )     {", "Assert . assertTrue (  ( ex   instanceof   ApplicationNotFoundException )  )  ;", "Assert . assertEquals (  (  (  \" Application   with   id    '  \"     +    applicationId )     +     \"  '    doesn ' t   exist   in   RM .  \"  )  ,    ex . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMoveApplicationAcrossQueues"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "verifyUsageInfo ( new   NodeCLI (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNodeCLIUsageInfo"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "NodeId   nodeId    =    NodeId . newInstance (  \" host 0  \"  ,     0  )  ;", "NodeCLI   cli    =    new   NodeCLI (  )  ;", "when ( getNodeReports (  )  )  . thenReturn ( getNodeReports (  3  ,    RUNNING )  )  ;", "cli . setClient (  ;", "cli . setSysOutPrintStream ( sysOut )  ;", "cli . setSysErrPrintStream ( sysErr )  ;", "int   result    =    cli . run ( new   String [  ]  {     \"  - status \"  ,    nodeId . toString (  )     }  )  ;", "assertEquals (  0  ,    result )  ;", "verify (  . getNodeReports (  )  ;", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "PrintWriter   pw    =    new   PrintWriter ( baos )  ;", "pw . println (  \" Node   Report    :     \"  )  ;", "pw . println (  \"  \\ tNode - Id    :    host 0  :  0  \"  )  ;", "pw . println (  \"  \\ tRack    :    rack 1  \"  )  ;", "pw . println (  \"  \\ tNode - State    :    RUNNING \"  )  ;", "pw . println (  \"  \\ tNode - Http - Address    :    host 1  :  8  8  8  8  \"  )  ;", "pw . println (  (  \"  \\ tLast - Health - Update    :     \"     +     ( DateFormatUtils . format ( new   Date (  0  )  ,     \" E   dd / MMM / yy   hh : mm : ss : SSzz \"  )  )  )  )  ;", "pw . println (  \"  \\ tHealth - Report    :     \"  )  ;", "pw . println (  \"  \\ tContainers    :     0  \"  )  ;", "pw . println (  \"  \\ tMemory - Used    :     0 MB \"  )  ;", "pw . println (  \"  \\ tMemory - Capacity    :     0 MB \"  )  ;", "pw . println (  \"  \\ tCPU - Used    :     0    vcores \"  )  ;", "pw . println (  \"  \\ tCPU - Capacity    :     0    vcores \"  )  ;", "pw . close (  )  ;", "String   nodeStatusStr    =    baos . toString (  \" UTF -  8  \"  )  ;", "verify ( sysOut ,    times (  1  )  )  . println ( isA ( String . class )  )  ;", "verify ( sysOut )  . println ( nodeStatusStr )  ;", "}", "METHOD_END"], "methodName": ["testNodeStatus"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "NodeCLI   nodeCLI    =    new   NodeCLI (  )  ;", "nodeCLI . setClient (  )  ;", "nodeCLI . setSysOutPrintStream ( sysOut )  ;", "nodeCLI . setSysErrPrintStream ( sysErr )  ;", "nodeCLI . run ( new   String [  ]  {        }  )  ;", "Assert . assertEquals ( createNodeCLIHelpMessage (  )  ,    sysOutStream . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNodesHelpCommand"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "cli . setSysErrPrintStream ( sysErr )  ;", "cli . run ( new   String [  ]  {     \" application \"     }  )  ;", "verify ( sysErr )  . println (  \" Invalid   Command   Usage    :     \"  )  ;", "}", "METHOD_END"], "methodName": ["verifyUsageInfo"], "fileName": "org.apache.hadoop.yarn.client.cli.TestYarnCLI"}, {"methodBody": ["METHOD_START", "{", "return   client ;", "}", "METHOD_END"], "methodName": ["getClient"], "fileName": "org.apache.hadoop.yarn.client.cli.YarnCLI"}, {"methodBody": ["METHOD_START", "{", "this . client    =    client ;", "}", "METHOD_END"], "methodName": ["setClient"], "fileName": "org.apache.hadoop.yarn.client.cli.YarnCLI"}, {"methodBody": ["METHOD_START", "{", "this . syserr    =    syserr ;", "}", "METHOD_END"], "methodName": ["setSysErrPrintStream"], "fileName": "org.apache.hadoop.yarn.client.cli.YarnCLI"}, {"methodBody": ["METHOD_START", "{", "this . sysout    =    sysout ;", "}", "METHOD_END"], "methodName": ["setSysOutPrintStream"], "fileName": "org.apache.hadoop.yarn.client.cli.YarnCLI"}, {"methodBody": ["METHOD_START", "{", "this . client . stop (  )  ;", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.apache.hadoop.yarn.client.cli.YarnCLI"}]