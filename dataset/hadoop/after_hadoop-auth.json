[{"methodBody": ["METHOD_START", "{", "LoginContext   loginContext    =    null ;", "try    {", "Set < Principal >    principals    =    new   HashSet < Principal >  (  )  ;", "principals . add ( new   KerberosPrincipal (  . getClientPrincipal (  )  )  )  ;", "Subject   subject    =    new   Subject ( false ,    principals ,    new   HashSet < Object >  (  )  ,    new   HashSet < Object >  (  )  )  ;", "loginContext    =    new   LoginContext (  \"  \"  ,    subject ,    null ,    new    . KerberosConfiguration ( principal )  )  ;", "loginContext . login (  )  ;", "subject    =    loginContext . getSubject (  )  ;", "return   Subject . doAs ( subject ,    new   PrivilegedExceptionAction < T >  (  )     {", "@ Override", "public   T   run (  )    throws   Exception    {", "return   callable . call (  )  ;", "}", "}  )  ;", "}    catch    ( PrivilegedActionException   ex )     {", "throw   ex . getException (  )  ;", "}    finally    {", "if    ( loginContext    !  =    null )     {", "loginContext . logout (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["doAs"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   KerberosTestUtils . doAs ( KerberosTestUtils . getClientPrincipal (  )  ,    callable )  ;", "}", "METHOD_END"], "methodName": ["doAsClient"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   KerberosTestUtils . doAs ( KerberosTestUtils . getServerPrincipal (  )  ,    callable )  ;", "}", "METHOD_END"], "methodName": ["doAsServer"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return    \" client @ EXAMPLE . COM \"  ;", "}", "METHOD_END"], "methodName": ["getClientPrincipal"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return   KerberosTestUtils . keytabFile ;", "}", "METHOD_END"], "methodName": ["getKeytabFile"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return    \" EXAMPLE . COM \"  ;", "}", "METHOD_END"], "methodName": ["getRealm"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "return    \" HTTP / localhost @ EXAMPLE . COM \"  ;", "}", "METHOD_END"], "methodName": ["getServerPrincipal"], "fileName": "org.apache.hadoop.security.authentication.KerberosTestUtils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( conn . getResponseCode (  )  )     =  =     ( HttpURLConnection . HTTP _ OK )  )     {", "Map < String ,    List < String >  >    headers    =    conn . getHeaderFields (  )  ;", "List < String >    cookies    =    headers . get (  \" Set - Cookie \"  )  ;", "if    ( cookies    !  =    null )     {", "for    ( String   cookie    :    cookies )     {", "if    ( cookie . startsWith (  . AUTH _ COOKIE _ EQ )  )     {", "String   value    =    cookie . substring (  . AUTH _ COOKIE _ EQ . length (  )  )  ;", "int   separator    =    value . indexOf (  \"  ;  \"  )  ;", "if    ( separator    >     (  -  1  )  )     {", "value    =    value . substring (  0  ,    separator )  ;", "}", "if    (  ( value . length (  )  )     >     0  )     {", "token . set ( value )  ;", "}", "}", "}", "}", "} else    {", "token . set ( null )  ;", "throw   new   AuthenticationException (  (  (  (  \" Authentication   failed ,    status :     \"     +     ( conn . getResponseCode (  )  )  )     +     \"  ,    message :     \"  )     +     ( conn . getResponseMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["extractToken"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "return   authenticator ;", "}", "METHOD_END"], "methodName": ["getAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "return   AuthenticatedURL . DEFAULT _ AUTHENTICATOR ;", "}", "METHOD_END"], "methodName": ["getDefaultAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "String   t    =    token . token ;", "if    ( t    !  =    null )     {", "if    (  !  ( t . startsWith (  \"  \\  \"  \"  )  )  )     {", "t    =     (  \"  \\  \"  \"     +    t )     +     \"  \\  \"  \"  ;", "}", "conn . addRequestProperty (  \" Cookie \"  ,     (  (  . AUTH _ COOKIE _ EQ )     +    t )  )  ;", "}", "}", "METHOD_END"], "methodName": ["injectToken"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "if    ( url    =  =    null )     {", "throw   new   IllegalArgumentException (  \" url   cannot   be   NULL \"  )  ;", "}", "if    (  (  !  ( url . getProtocol (  )  . equalsIgnoreCase (  \" http \"  )  )  )     &  &     (  !  ( url . getProtocol (  )  . equalsIgnoreCase (  \" https \"  )  )  )  )     {", "throw   new   IllegalArgumentException (  \" url   must   be   for   a   HTTP   or   HTTPS   resource \"  )  ;", "}", "if    ( token    =  =    null )     {", "throw   new   IllegalArgumentException (  \" token   cannot   be   NULL \"  )  ;", "}", "authenticator . authenticate ( url ,    token )  ;", "HttpURLConnection   conn    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "if    (  ( connConfigurator )     !  =    null )     {", "conn    =    connConfigurator . configure ( conn )  ;", "}", ". injectToken ( conn ,    token )  ;", "return   conn ;", "}", "METHOD_END"], "methodName": ["openConnection"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "AuthenticatedURL . DEFAULT _ AUTHENTICATOR    =    authenticator ;", "}", "METHOD_END"], "methodName": ["setDefaultAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "start (  )  ;", "try    {", "URL   url    =    new   URL ( getBaseURL (  )  )  ;", "AuthenticatedURL . Token   token    =    new   AuthenticatedURL . Token (  )  ;", "Assert . assertFalse ( token . isSet (  )  )  ;", ". TestConnectionConfigurator   connConf    =    new    . TestConnectionConfigurator (  )  ;", "AuthenticatedURL   aUrl    =    new   AuthenticatedURL ( authenticator ,    connConf )  ;", "HttpURLConnection   conn    =    aUrl . openConnection ( url ,    token )  ;", "Assert . assertTrue ( connConf . invoked )  ;", "String   tokenStr    =    token . toString (  )  ;", "if    ( doPost )     {", "conn . setRequestMethod (  \" POST \"  )  ;", "conn . setDoOutput ( true )  ;", "}", "conn . connect (  )  ;", "if    ( doPost )     {", "Writer   writer    =    new   OutputStreamWriter ( conn . getOutputStream (  )  )  ;", "writer . write ( POST )  ;", "writer . close (  )  ;", "}", "Assert . assertEquals ( HttpURLConnection . HTTP _ OK ,    conn . getResponseCode (  )  )  ;", "if    ( doPost )     {", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( conn . getInputStream (  )  )  )  ;", "String   echo    =    reader . readLine (  )  ;", "Assert . assertEquals ( POST ,    echo )  ;", "Assert . assertNull ( reader . readLine (  )  )  ;", "}", "aUrl    =    new   AuthenticatedURL (  )  ;", "conn    =    aUrl . openConnection ( url ,    token )  ;", "conn . connect (  )  ;", "Assert . assertEquals ( HttpURLConnection . HTTP _ OK ,    conn . getResponseCode (  )  )  ;", "Assert . assertEquals ( tokenStr ,    token . toString (  )  )  ;", "}    finally    {", "stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["_testAuthentication"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatorTestCase"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  \" http :  /  /  \"     +     ( host )  )     +     \"  :  \"  )     +     ( port )  )     +     \"  / foo / bar \"  ;", "}", "METHOD_END"], "methodName": ["getBaseURL"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatorTestCase"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase . authenticatorConfig    =    config ;", "}", "METHOD_END"], "methodName": ["setAuthenticationHandlerConfig"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatorTestCase"}, {"methodBody": ["METHOD_START", "{", "server    =    new   Server (  0  )  ;", "context    =    new   Context (  )  ;", "context . setContextPath (  \"  / foo \"  )  ;", "server . setHandler ( context )  ;", "context . addFilter ( new   FilterHolder (  . TestFilter . class )  ,     \"  /  *  \"  ,     0  )  ;", "context . addServlet ( new   ServletHolder (  . TestServlet . class )  ,     \"  / bar \"  )  ;", "host    =     \" localhost \"  ;", "ServerSocket   ss    =    new   ServerSocket (  0  )  ;", "port    =    ss . getLocalPort (  )  ;", "ss . close (  )  ;", "server . getConnectors (  )  [  0  ]  . setHost ( host )  ;", "server . getConnectors (  )  [  0  ]  . setPort ( port )  ;", "server . start (  )  ;", "System . out . println (  (  (  (  \" Running   embedded   servlet   container   at :    http :  /  /  \"     +     ( host )  )     +     \"  :  \"  )     +     ( port )  )  )  ;", "}", "METHOD_END"], "methodName": ["start"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatorTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "server . stop (  )  ;", "}    catch    ( Excep   e )     {", "}", "try    {", "server . destroy (  )  ;", "}    catch    ( Excep   e )     {", "}", "}", "METHOD_END"], "methodName": ["stop"], "fileName": "org.apache.hadoop.security.authentication.client.AuthenticatorTestCase"}, {"methodBody": ["METHOD_START", "{", "try    {", "AccessControlContext   context    =    AccessController . getContext (  )  ;", "Subject   subject    =    Subject . getSubject ( context )  ;", "if    ( subject    =  =    null )     {", ". LOG . debug (  \" No   subject   in   context ,    logging   in \"  )  ;", "subject    =    new   Subject (  )  ;", "LoginContext   login    =    new   LoginContext (  \"  \"  ,    subject ,    null ,    new    . KerberosConfiguration (  )  )  ;", "login . login (  )  ;", "}", "if    (  . LOG . isDebugEnabled (  )  )     {", ". LOG . debug (  (  \" Using   subject :     \"     +    subject )  )  ;", "}", "Subject . doAs ( subject ,    new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   Exception    {", "GSSContext   gssContext    =    null ;", "try    {", "GSSManager   gssManager    =    GSSManager . getInstance (  )  ;", "String   servicePrincipal    =    KerberosUtil . getServicePrincipal (  \" HTTP \"  ,     . this . url . getHost (  )  )  ;", "Oid   oid    =    KerberosUtil . getOidInstance (  \" NT _ GSS _ KRB 5  _ PRINCIPAL \"  )  ;", "GSSName   serviceName    =    gssManager . createName ( servicePrincipal ,    oid )  ;", "oid    =    KerberosUtil . getOidInstance (  \" GSS _ KRB 5  _ MECH _ OID \"  )  ;", "gssContext    =    gssManager . createContext ( serviceName ,    oid ,    null ,    GSSContext . DEFAULT _ LIFETIME )  ;", "gssContext . requestCredDeleg ( true )  ;", "gssContext . requestMutualAuth ( true )  ;", "byte [  ]    inToken    =    new   byte [  0  ]  ;", "byte [  ]    outToken ;", "boolean   established    =    false ;", "while    (  ! established )     {", "outToken    =    gssContext . initSecContext ( inToken ,     0  ,    inToken . length )  ;", "if    ( outToken    !  =    null )     {", "sendToken ( outToken )  ;", "}", "if    (  !  ( gssContext . isEstablished (  )  )  )     {", "inToken    =    readToken (  )  ;", "} else    {", "established    =    true ;", "}", "}", "}    finally    {", "if    ( gssContext    !  =    null )     {", "gssContext . dispose (  )  ;", "gssContext    =    null ;", "}", "}", "return   null ;", "}", "}  )  ;", "}    catch    ( PrivilegedActionException   ex )     {", "throw   new   AuthenticationException ( ex . getException (  )  )  ;", "}    catch    ( LoginException   ex )     {", "throw   new   AuthenticationException ( ex )  ;", "}", "AuthenticatedURL . extractToken ( conn ,    token )  ;", "}", "METHOD_END"], "methodName": ["doSpnegoSequence"], "fileName": "org.apache.hadoop.security.authentication.client.KerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "Authenticator   auth    =    new   PseudoAuthenticator (  )  ;", "if    (  ( connConfigurator )     !  =    null )     {", "auth . setConnectionConfigurator ( connConfigurator )  ;", "}", "return   auth ;", "}", "METHOD_END"], "methodName": ["getFallBackAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.KerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "boolean   negotiate    =    false ;", "if    (  ( conn . getResponseCode (  )  )     =  =     ( HttpURLConnection . HTTP _ UNAUTHORIZED )  )     {", "String   authHeader    =    conn . getHeaderField (  . WWW _ AUTHENTICATE )  ;", "negotiate    =     ( authHeader    !  =    null )     &  &     ( authHeader . trim (  )  . startsWith (  . NEGOTIATE )  )  ;", "}", "return   negotiate ;", "}", "METHOD_END"], "methodName": ["isNegotiate"], "fileName": "org.apache.hadoop.security.authentication.client.KerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "int   status    =    conn . getResponseCode (  )  ;", "if    (  ( status    =  =     ( HttpURLConnection . HTTP _ OK )  )     |  |     ( status    =  =     ( HttpURLConnection . HTTP _ UNAUTHORIZED )  )  )     {", "String   authHeader    =    conn . getHeaderField (  . WWW _ AUTHENTICATE )  ;", "if    (  ( authHeader    =  =    null )     |  |     (  !  ( authHeader . trim (  )  . startsWith (  . NEGOTIATE )  )  )  )     {", "throw   new   AuthenticationException (  (  (  (  \" Invalid   SPNEGO   sequence ,     '  \"     +     (  . WWW _ AUTHENTICATE )  )     +     \"  '    header   incorrect :     \"  )     +    authHeader )  )  ;", "}", "String   negotiation    =    authHeader . trim (  )  . substring (  (  (  . NEGOTIATE )     +     \"     \"  )  . length (  )  )  . trim (  )  ;", "return   base 6  4  . decode ( negotiation )  ;", "}", "throw   new   AuthenticationException (  (  \" Invalid   SPNEGO   sequence ,    status   code :     \"     +    status )  )  ;", "}", "METHOD_END"], "methodName": ["readToken"], "fileName": "org.apache.hadoop.security.authentication.client.KerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "String   token    =    base 6  4  . encodeToString ( outToken )  ;", "conn    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "if    (  ( connConfigurator )     !  =    null )     {", "conn    =    connConfigurator . configure ( conn )  ;", "}", "conn . setRequestMethod (  . AUTH _ HTTP _ METHOD )  ;", "conn . setRequestProperty (  . AUTHORIZATION ,     (  (  (  . NEGOTIATE )     +     \"     \"  )     +    token )  )  ;", "conn . connect (  )  ;", "}", "METHOD_END"], "methodName": ["sendToken"], "fileName": "org.apache.hadoop.security.authentication.client.KerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperty (  \" user . name \"  )  ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.apache.hadoop.security.authentication.client.PseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   conn    =    Mockito . mock ( HttpURLConnection . class )  ;", "Mockito . when ( conn . getResponseCode (  )  )  . thenReturn ( HttpURLConnection . HTTP _ UNAUTHORIZED )  ;", "ConnectionConfigurator   connConf    =    Mockito . mock ( ConnectionConfigurator . class )  ;", "Mockito . when ( connConf . configure ( Mockito .  < HttpURLConnection > any (  )  )  )  . thenReturn ( conn )  ;", "Authenticator   authenticator    =    Mockito . mock ( Authenticator . class )  ;", "aURL    =    new    ( authenticator ,    connConf )  ;", "aURL . openConnection ( new   URL (  \" http :  /  / foo \"  )  ,    new    . Token (  )  )  ;", "Mockito . verify ( connConf )  . configure ( Mockito .  < HttpURLConnection > any (  )  )  ;", "}", "METHOD_END"], "methodName": ["testConnectionConfigurator"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   conn    =    Mockito . mock ( HttpURLConnection . class )  ;", "Mockito . when ( conn . getResponseCode (  )  )  . thenReturn ( HttpURLConnection . HTTP _ UNAUTHORIZED )  ;", "String   tokenStr    =     \" foo \"  ;", "Map < String ,    List < String >  >    headers    =    new   HashMap < String ,    List < String >  >  (  )  ;", "List < String >    cookies    =    new   ArrayList < String >  (  )  ;", "cookies . add (  (  (  (  . AUTH _ COOKIE )     +     \"  =  \"  )     +    tokenStr )  )  ;", "headers . put (  \" Set - Cookie \"  ,    cookies )  ;", "Mockito . when ( conn . getHeaderFields (  )  )  . thenReturn ( headers )  ;", ". Token   token    =    new    . Token (  )  ;", "token . set (  \" bar \"  )  ;", "try    {", ". extractToken ( conn ,    token )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthenticationException   ex )     {", "Assert . assertFalse ( token . isSet (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExtractTokenFail"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   conn    =    Mockito . mock ( HttpURLConnection . class )  ;", "Mockito . when ( conn . getResponseCode (  )  )  . thenReturn ( HttpURLConnection . HTTP _ OK )  ;", "String   tokenStr    =     \" foo \"  ;", "Map < String ,    List < String >  >    headers    =    new   HashMap < String ,    List < String >  >  (  )  ;", "List < String >    cookies    =    new   ArrayList < String >  (  )  ;", "cookies . add (  (  (  (  . AUTH _ COOKIE )     +     \"  =  \"  )     +    tokenStr )  )  ;", "headers . put (  \" Set - Cookie \"  ,    cookies )  ;", "Mockito . when ( conn . getHeaderFields (  )  )  . thenReturn ( headers )  ;", ". Token   token    =    new    . Token (  )  ;", ". extractToken ( conn ,    token )  ;", "Assert . assertEquals ( tokenStr ,    token . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExtractTokenOK"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "Authenticator   authenticator    =    Mockito . mock ( Authenticator . class )  ;", "aURL    =    new    ( authenticator )  ;", "Assert . assertEquals ( authenticator ,    aURL . getAuthenticator (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "HttpURLConnection   conn    =    Mockito . mock ( HttpURLConnection . class )  ;", ". Token   token    =    new    . Token (  )  ;", "token . set (  \" foo \"  )  ;", ". injectToken ( conn ,    token )  ;", "Mockito . verify ( conn )  . addRequestProperty ( Mockito . eq (  \" Cookie \"  )  ,    Mockito . anyString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInjectToken"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "AuthenticatedURL . Token   token    =    new   AuthenticatedURL . Token (  )  ;", "Assert . assertFalse ( token . isSet (  )  )  ;", "token    =    new   AuthenticatedURL . Token (  \" foo \"  )  ;", "Assert . assertTrue ( token . isSet (  )  )  ;", "Assert . assertEquals (  \" foo \"  ,    token . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToken"], "fileName": "org.apache.hadoop.security.authentication.client.TestAuthenticatedURL"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( AuthenticationFilter . AUTH _ TYPE ,     \" kerberos \"  )  ;", "props . setProperty ( ionHandler . PRINCIPAL ,    KerberosTestUtils . getServerPrincipal (  )  )  ;", "props . setProperty ( ionHandler . KEYTAB ,    KerberosTestUtils . getKeytabFile (  )  )  ;", "props . setProperty ( ionHandler . NAME _ RULES ,     (  (  \" RULE :  [  1  :  $  1  @  $  0  ]  (  .  *  @  \"     +     ( KerberosTestUtils . getRealm (  )  )  )     +     \"  ) s /  @  .  *  /  /  \\ n \"  )  )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["getAuthenticationHandlerConfiguration"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "File   keytabFile    =    new   File ( KerberosTestUtils . getKeytabFile (  )  )  ;", "String   clientPrincipal    =    KerberosTestUtils . getClientPrincipal (  )  ;", "String   serverPrincipal    =    KerberosTestUtils . getServerPrincipal (  )  ;", "clientPrincipal    =    clientPrincipal . substring (  0  ,    clientPrincipal . lastIndexOf (  \"  @  \"  )  )  ;", "serverPrincipal    =    serverPrincipal . substring (  0  ,    serverPrincipal . lastIndexOf (  \"  @  \"  )  )  ;", "getKdc (  )  . createPrincipal ( keytabFile ,    clientPrincipal ,    serverPrincipal )  ;", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "final   AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration (  )  )  ;", "KerberosTestUtils . doAsClient ( new   Callable < Void >  (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "auth .  _ testAuthentication ( new    (  )  ,    false )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testAuthentication"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "final   AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration (  )  )  ;", "KerberosTestUtils . doAsClient ( new   Callable < Void >  (  )     {", "@ Override", "public   Void   call (  )    throws   Exception    {", "auth .  _ testAuthentication ( new    (  )  ,    true )  ;", "return   null ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["testAuthenticationPost"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( AuthenticationFilter . AUTH _ TYPE ,     \" simple \"  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,     \" false \"  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( props )  ;", "auth .  _ testAuthentication ( new    (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testFallbacktoPseudoAuthenticator"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( AuthenticationFilter . AUTH _ TYPE ,     \" simple \"  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,     \" true \"  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( props )  ;", "auth .  _ testAuthentication ( new    (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testFallbacktoPseudoAuthenticatorAnonymous"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration (  )  )  ;", "auth . start (  )  ;", "try    {", "URL   url    =    new   URL ( auth . getBaseURL (  )  )  ;", "HttpURLConnection   conn    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "conn . connect (  )  ;", "Assert . assertEquals ( HttpURLConnection . HTTP _ UNAUTHORIZED ,    conn . getResponseCode (  )  )  ;", "Assert . assertTrue (  (  ( conn . getHeaderField (  . WWW _ AUTHENTICATE )  )     !  =    null )  )  ;", "}    finally    {", "auth . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNotAuthenticated"], "fileName": "org.apache.hadoop.security.authentication.client.TestKerberosAuthenticator"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( AuthenticationFilter . AUTH _ TYPE ,     \" simple \"  )  ;", "props . setProperty ( ionHandler . ANONYMOUS _ ALLOWED ,    Boolean . toString ( anonymousAllowed )  )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["getAuthenticationHandlerConfiguration"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( true )  )  ;", "auth . start (  )  ;", "try    {", "URL   url    =    new   URL ( auth . getBaseURL (  )  )  ;", "HttpURLConnection   conn    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "conn . connect (  )  ;", "Assert . assertEquals ( HttpURLConnection . HTTP _ OK ,    conn . getResponseCode (  )  )  ;", "}    finally    {", "auth . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAnonymousAllowed"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( false )  )  ;", "auth . start (  )  ;", "try    {", "URL   url    =    new   URL ( auth . getBaseURL (  )  )  ;", "HttpURLConnection   conn    =     (  ( HttpURLConnection )     ( url . openConnection (  )  )  )  ;", "conn . connect (  )  ;", "Assert . assertEquals ( HttpURLConnection . HTTP _ FORBIDDEN ,    conn . getResponseCode (  )  )  ;", "Assert . assertEquals (  \" Anonymous   requests   are   disallowed \"  ,    conn . getResponseMessage (  )  )  ;", "}    finally    {", "auth . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAnonymousDisallowed"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( true )  )  ;", "auth .  _ testAuthentication ( new    (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAuthenticationAnonymousAllowed"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( true )  )  ;", "auth .  _ testAuthentication ( new    (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAuthenticationAnonymousAllowedWithPost"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( false )  )  ;", "auth .  _ testAuthentication ( new    (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testAuthenticationAnonymousDisallowed"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "AuthenticatorTestCase   auth    =    new   AuthenticatorTestCase (  )  ;", "AuthenticatorTestCase . setAuthenticationHandlerConfig ( getAuthenticationHandlerConfiguration ( false )  )  ;", "auth .  _ testAuthentication ( new    (  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["testAuthenticationAnonymousDisallowedWithPost"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticator   authenticator    =    new   PseudoAuthenticator (  )  ;", "Assert . assertEquals ( System . getProperty (  \" user . name \"  )  ,    authenticator . getUserName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetUserName"], "fileName": "org.apache.hadoop.security.authentication.client.TestPseudoAuthenticator"}, {"methodBody": ["METHOD_START", "{", "if    ( userAgent    =  =    null )     {", "return   false ;", "}", "userAgent    =    userAgent . toLowerCase (  )  ;", "boolean   isBrowser    =    true ;", "for    ( String   nonBrowserUserAgent    :    nonBrowserUserAgents )     {", "if    ( userAgent . contains ( nonBrowserUserAgent )  )     {", "isBrowser    =    false ;", "break ;", "}", "}", "return   isBrowser ;", "}", "METHOD_END"], "methodName": ["isBrowser"], "fileName": "org.apache.hadoop.security.authentication.server.AltKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder ( AuthenticatedURL . AUTH _ COOKIE )  . append (  \"  =  \"  )  ;", "if    (  ( token    !  =    null )     &  &     (  ( token . length (  )  )     >     0  )  )     {", "sb . append (  \"  \\  \"  \"  )  . append ( token )  . append (  \"  \\  \"  \"  )  ;", "}", "sb . append (  \"  ;    Version =  1  \"  )  ;", "if    ( path    !  =    null )     {", "sb . append (  \"  ;    Path =  \"  )  . append ( path )  ;", "}", "if    ( domain    !  =    null )     {", "sb . append (  \"  ;    Domain =  \"  )  . append ( domain )  ;", "}", "if    ( expires    >  =     0  )     {", "Date   date    =    new   Date ( expires )  ;", "SimpleDateFormat   df    =    new   SimpleDateFormat (  (  \" EEE ,     \"     +     \" dd - MMM - yyyy   HH : mm : ss   zzz \"  )  )  ;", "df . setTimeZone ( TimeZone . getTimeZone (  \" GMT \"  )  )  ;", "sb . append (  \"  ;    Expires =  \"  )  . append ( df . format ( date )  )  ;", "}", "if    ( isSecure )     {", "sb . append (  \"  ;    Secure \"  )  ;", "}", "sb . append (  \"  ;    HttpOnly \"  )  ;", "resp . addHeader (  \" Set - Cookie \"  ,    sb . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["createAuthCookie"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "filterChain . doFilter ( request ,    response )  ;", "}", "METHOD_END"], "methodName": ["doFilter"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   authHandler ;", "}", "METHOD_END"], "methodName": ["getAuthenticationHandler"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   config ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "Enumer <  ?  >    names    =    filterConfig . getInitParameterNames (  )  ;", "while    ( names . hasMoreElements (  )  )     {", "String   name    =     (  ( String )     ( names . nextElement (  )  )  )  ;", "if    ( name . startsWith ( configPrefix )  )     {", "String   value    =    filterConfig . getInitParameter ( name )  ;", "props . put ( name . substring ( configPrefix . length (  )  )  ,    value )  ;", "}", "}", "return   props ;", "}", "METHOD_END"], "methodName": ["getConfiguration"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   cookieDomain ;", "}", "METHOD_END"], "methodName": ["getCookieDomain"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   cookiePath ;", "}", "METHOD_END"], "methodName": ["getCookiePath"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   sb    =    request . getRequestURL (  )  ;", "if    (  ( request . getQueryString (  )  )     !  =    null )     {", "sbpend (  \"  ?  \"  ) pend ( request . getQueryString (  )  )  ;", "}", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["getRequestURL"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationToken   token    =    null ;", "String   tokenStr    =    null ;", "Cookie [  ]    cookies    =    request . getCookies (  )  ;", "if    ( cookies    !  =    null )     {", "for    ( Cookie   cookie    :    cookies )     {", "if    ( cookie . getName (  )  . equals ( AuthenticatedURL . AUTH _ COOKIE )  )     {", "tokenStr    =    cookie . getValue (  )  ;", "try    {", "tokenStr    =    signer . verifyAndExtract ( tokenStr )  ;", "}    catch    ( SignerException   ex )     {", "throw   new   AuthenticationException ( ex )  ;", "}", "break ;", "}", "}", "}", "if    ( tokenStr    !  =    null )     {", "token    =    AuthenticationToken . parse ( tokenStr )  ;", "if    (  !  ( token . getType (  )  . equals ( authHandler . getType (  )  )  )  )     {", "throw   new   AuthenticationException (  \" Invalid   AuthenticationToken   type \"  )  ;", "}", "if    ( token . isExpired (  )  )     {", "throw   new   AuthenticationException (  \" AuthenticationToken   expired \"  )  ;", "}", "}", "return   token ;", "}", "METHOD_END"], "methodName": ["getToken"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return    ( validity )     /     1  0  0  0  ;", "}", "METHOD_END"], "methodName": ["getValidity"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   customSecretProvider ;", "}", "METHOD_END"], "methodName": ["isCustomSignerSecretProvider"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "return   randomSecret ;", "}", "METHOD_END"], "methodName": ["isRandomSecret"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( value    =  =    null )     |  |     (  ( value . length (  )  )     =  =     0  )  )     |  |     ( value . contains ( AuthenticationToken . ATTR _ SEPARATOR )  )  )     {", "throw   new   IllegalArgumentException (  ( name    +     ( AuthenticationToken . ILLEGAL _ ARG _ MSG )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkForIllegalArgument"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "StringBuffer   sb    =    new   StringBuffer (  )  ;", "sb . append (  . USER _ NAME )  . append (  \"  =  \"  )  . append ( getUserName (  )  )  . append (  . ATTR _ SEPARATOR )  ;", "sb . append (  . PRINCIPAL )  . append (  \"  =  \"  )  . append ( getName (  )  )  . append (  . ATTR _ SEPARATOR )  ;", "sb . append (  . TYPE )  . append (  \"  =  \"  )  . append ( getType (  )  )  . append (  . ATTR _ SEPARATOR )  ;", "sb . append (  . EXPIRES )  . append (  \"  =  \"  )  . append ( getExpires (  )  )  ;", "token    =    sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["generateToken"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "return   expires ;", "}", "METHOD_END"], "methodName": ["getExpires"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "return   type ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "return   userName ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "return    (  ( getExpires (  )  )     !  =     (  -  1  )  )     &  &     (  ( System . currentTimeMillis (  )  )     >     ( getExpires (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isExpired"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    AuthenticationToken . split ( tokenStr )  ;", "if    (  !  ( map . keySet (  )  . equals ( AuthenticationToken . ATTRIBUTES )  )  )     {", "throw   new   AuthenticationException (  \" Invalid   token   string ,    missing   attributes \"  )  ;", "}", "long   expires    =    Long . parseLong ( map . get ( AuthenticationToken . EXPIRES )  )  ;", "AuthenticationToken   token    =    new   AuthenticationToken ( map . get ( AuthenticationToken . USER _ NAME )  ,    map . get ( AuthenticationToken . PRINCIPAL )  ,    map . get ( AuthenticationToken . TYPE )  )  ;", "token . setExpires ( expires )  ;", "return   token ;", "}", "METHOD_END"], "methodName": ["parse"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     !  =     ( AuthenticationToken . ANONYMOUS )  )     {", "this . expires    =    expires ;", "generateToken (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setExpires"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    map    =    new   HashMap < String ,    String >  (  )  ;", "StringTokenizer   st    =    new   StringTokenizer ( tokenStr ,     . ATTR _ SEPARATOR )  ;", "while    ( st . hasMoreTokens (  )  )     {", "String   part    =    st . nextToken (  )  ;", "int   separator    =    part . indexOf (  '  =  '  )  ;", "if    ( separator    =  =     (  -  1  )  )     {", "throw   new   AuthenticationException (  \" Invalid   authentication   token \"  )  ;", "}", "String   key    =    part . substring (  0  ,    separator )  ;", "String   value    =    part . substring (  ( separator    +     1  )  )  ;", "map . put ( key ,    value )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.apache.hadoop.security.authentication.server.AuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "return   keytab ;", "}", "METHOD_END"], "methodName": ["getKeytab"], "fileName": "org.apache.hadoop.security.authentication.server.KerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "return   serverSubject . getPrincipals ( KerberosPrincipal . class )  ;", "}", "METHOD_END"], "methodName": ["getPrincipals"], "fileName": "org.apache.hadoop.security.authentication.server.KerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "return   acceptAnonymous ;", "}", "METHOD_END"], "methodName": ["getAcceptAnonymous"], "fileName": "org.apache.hadoop.security.authentication.server.PseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "List < NameValuePair >    list    =    URLEncodedUtils . parse ( request . getQueryString (  )  ,    PseudoAuthenticationHandler . UTF 8  _ CHARSET )  ;", "if    ( list    !  =    null )     {", "for    ( NameValuePair   nv    :    list )     {", "if    ( PseudoAuthenticator . USER _ NAME . equals ( nv . getName (  )  )  )     {", "return   nv . getValue (  )  ;", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getUserName"], "fileName": "org.apache.hadoop.security.authentication.server.PseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getHeader (  \" User - Agent \"  )  )  . thenReturn (  \" Some   Browser \"  )  ;", "Token   token    =    handler . authenticate ( request ,    response )  ;", "Assert . assertEquals (  \" A \"  ,    token . getUserName (  )  )  ;", "Assert . assertEquals (  \" B \"  ,    token . getName (  )  )  ;", "Assert . assertEquals ( getExpectedType (  )  ,    token . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAlternateAuthenticationAsBrowser"], "fileName": "org.apache.hadoop.security.authentication.server.TestAltKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "if    (  ( handler )     !  =    null )     {", "handler . destroy (  )  ;", "handler    =    null ;", "}", "handler    =    getNew (  )  ;", "Properties   props    =    getDefaultProperties (  )  ;", "props . setProperty (  \" alt - kerberos . non - browser . user - agents \"  ,     \" foo ,    bar \"  )  ;", "try    {", "handler . init ( props )  ;", "}    catch    ( Exception   ex )     {", "handler    =    null ;", "throw   ex ;", "}", "Mockito . when ( request . getHeader (  \" User - Agent \"  )  )  . thenReturn (  \" blah \"  )  ;", "AuthenticationToken   token    =    handler . authenticate ( request ,    response )  ;", "Assert . assertEquals (  \" A \"  ,    token . getUserName (  )  )  ;", "Assert . assertEquals (  \" B \"  ,    token . getName (  )  )  ;", "Assert . assertEquals ( getExpectedType (  )  ,    token . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonDefaultNonBrowserUserAgentAsBrowser"], "fileName": "org.apache.hadoop.security.authentication.server.TestAltKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( handler )     !  =    null )     {", "handler . destroy (  )  ;", "handler    =    null ;", "}", "handler    =    getNew (  )  ;", "Properties   props    =    getDefaultProperties (  )  ;", "props . setProperty (  \" alt - kerberos . non - browser . user - agents \"  ,     \" foo ,    bar \"  )  ;", "try    {", "handler . init ( props )  ;", "}    catch    ( Exception   ex )     {", "handler    =    null ;", "throw   ex ;", "}", "testRequestWithoutAuthorization (  )  ;", "testRequestWithInvalidAuthorization (  )  ;", "testRequestWithAuthorization (  )  ;", "testRequestWithInvalidKerberosAuthorization (  )  ;", "}", "METHOD_END"], "methodName": ["testNonDefaultNonBrowserUserAgentAsNonBrowser"], "fileName": "org.apache.hadoop.security.authentication.server.TestAltKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter (  \" expired . token \"  )  )  . thenReturn ( Boolean . toString ( expired )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TOKEN _ VALIDITY )  )  . thenReturn ( new   Long (  . TOKEN _ VALIDITY _ SEC )  . toString (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . AUTH _ TOKEN _ VALIDITY ,    AuthenticationFilter . SIGNATURE _ SECRET ,     (  \" management . operation \"     +     \"  . return \"  )  ,     \" expired . token \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "if    ( withDomainPath )     {", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . COOKIE _ DOMAIN )  )  . thenReturn (  \"  . foo . com \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . COOKIE _ PATH )  )  . thenReturn (  \"  / bar \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . AUTH _ TOKEN _ VALIDITY ,    AuthenticationFilter . SIGNATURE _ SECRET ,    AuthenticationFilter . COOKIE _ DOMAIN ,    AuthenticationFilter . COOKIE _ PATH ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "}", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getParameter (  \" authenticated \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "Mockito . when ( request . getQueryString (  )  )  . thenReturn (  \" authenticated = true \"  )  ;", "if    ( invalidToken )     {", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,     \" foo \"  )     }  )  ;", "}", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", "final   HashMap < String ,    String >    cookieMap    =    new   HashMap < String ,    String >  (  )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "String   cookieHeader    =     (  ( String )     ( invocation . getArguments (  )  [  1  ]  )  )  ;", ". parseCookieMap ( cookieHeader ,    cookieMap )  ;", "return   null ;", "}", "}  )  . when ( response )  . addHeader ( Mockito . eq (  \" Set - Cookie \"  )  ,    Mockito . anyString (  )  )  ;", "try    {", "filter . init ( config )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "if    ( expired )     {", "Mockito . verify ( response ,    Mockito . never (  )  )  . addHeader ( Mockito . eq (  \" Set - Cookie \"  )  ,    Mockito . anyString (  )  )  ;", "} else    {", "String   v    =    cookieMap . get ( AuthenticatedURL . AUTH _ COOKIE )  ;", "Assert . assertNotNull (  \" cookie   missing \"  ,    v )  ;", "Assert . assertTrue (  (  (  (  (  ( v . contains (  \" u =  \"  )  )     &  &     ( v . contains (  \" p =  \"  )  )  )     &  &     ( v . contains (  \" t =  \"  )  )  )     &  &     ( v . contains (  \" e =  \"  )  )  )     &  &     ( v . contains (  \" s =  \"  )  )  )  )  ;", "Mockito . verify ( chain )  . doFilter ( Mockito . any ( ServletRequest . class )  ,    Mockito . any ( ServletResponse . class )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   value    =    signer . verifyAndExtract ( v )  ;", "AuthenticationToken   token    =    AuthenticationToken . parse ( value )  ;", "assertThat ( token . getExpires (  )  ,    not (  0 L )  )  ;", "if    ( withDomainPath )     {", "Assert . assertEquals (  \"  . foo . com \"  ,    cookieMap . get (  \" Domain \"  )  )  ;", "Assert . assertEquals (  \"  / bar \"  ,    cookieMap . get (  \" Path \"  )  )  ;", "} else    {", "Assert . assertFalse ( cookieMap . containsKey (  \" Domain \"  )  )  ;", "Assert . assertFalse ( cookieMap . containsKey (  \" Path \"  )  )  ;", "}", "}", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["_testDoFilterAuthentication"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "List < HttpCookie >    cookies    =    HttpCookie . parse ( cookieHeader )  ;", "for    ( HttpCookie   cookie    :    cookies )     {", "if    ( edURL . AUTH _ COOKIE . equals ( cookie . getName (  )  )  )     {", "cookieMap . put ( cookie . getName (  )  ,    cookie . getValue (  )  )  ;", "if    (  ( cookie . getPath (  )  )     !  =    null )     {", "cookieMap . put (  \" Path \"  ,    cookie . getPath (  )  )  ;", "}", "if    (  ( cookie . getDomain (  )  )     !  =    null )     {", "cookieMap . put (  \" Domain \"  ,    cookie . getDomain (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["parseCookieMap"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     +     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "Object [  ]    args    =    invocation . getArguments (  )  ;", "HttpServletRequest   request    =     (  ( HttpServletRequest )     ( args [  0  ]  )  )  ;", "Assert . assertEquals (  \" u \"  ,    request . getRemoteUser (  )  )  ;", "Assert . assertEquals (  \" p \"  ,    request . getUserPrincipal (  )  . getName (  )  )  ;", "return   null ;", "}", "}  )  . when ( chain )  . doFilter ( Mockito .  < ServletRequest > anyObject (  )  ,    Mockito .  < ServletResponse > anyObject (  )  )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticated"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "String   secret    =     \" secret \"  ;", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn ( secret )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     . DummyAuthenticationHandler . TYPE )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     -     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider ( secret )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", ". verifyUnauthorized ( filter ,    request ,    response ,    chain )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticatedExpired"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "String   secret    =     \" secret \"  ;", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn ( secret )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     \" invalidtype \"  )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     +     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider ( secret )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", ". verifyUnauthorized ( filter ,    request ,    response ,    chain )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticatedInvalidType"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "_ testDoFilterAuthentication ( false ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDoFilterAuthentication"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {        }  )  ;", "Mockito . when ( request . getHeader (  \" WWW - Authenticate \"  )  )  . thenReturn (  \" dummyauth \"  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", "final   HashMap < String ,    String >    cookieMap    =    new   HashMap < String ,    String >  (  )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "Object [  ]    args    =    invocation . getArguments (  )  ;", ". parseCookieMap (  (  ( String )     ( args [  1  ]  )  )  ,    cookieMap )  ;", "return   null ;", "}", "}  )  . when ( response )  . addHeader ( Mockito . eq (  \" Set - Cookie \"  )  ,    Mockito . anyString (  )  )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "Assert . fail (  \" shouldn ' t   get   here \"  )  ;", "return   null ;", "}", "}  )  . when ( chain )  . doFilter ( Mockito .  < ServletRequest > anyObject (  )  ,    Mockito .  < ServletResponse > anyObject (  )  )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "Mockito . verify ( response )  . sendError ( SC _ FORBIDDEN ,     \" AUTH   FAILED \"  )  ;", "Mockito . verify ( response ,    Mockito . never (  )  )  . setHeader ( Mockito . eq (  \" WWW - Authenticate \"  )  ,    Mockito . anyString (  )  )  ;", "String   value    =    cookieMap . get ( AuthenticatedURL . AUTH _ COOKIE )  ;", "Assert . assertNotNull (  \" cookie   missing \"  ,    value )  ;", "Assert . assertEquals (  \"  \"  ,    value )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticationFailure"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "_ testDoFilterAuthentication ( false ,    false ,    true )  ;", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticationImmediateExpiration"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "_ testDoFilterAuthentication ( true ,    false ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticationWithDomainPath"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "_ testDoFilterAuthentication ( false ,    true ,    false )  ;", "}", "METHOD_END"], "methodName": ["testDoFilterAuthenticationWithInvalidToken"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "Assert . fail (  )  ;", "return   null ;", "}", "}  )  . when ( chain )  . doFilter ( Mockito .  < ServletRequest > anyObject (  )  ,    Mockito .  < ServletResponse > anyObject (  )  )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "Mockito . verify ( response )  . sendError ( SC _ UNAUTHORIZED ,     \" Authentication   required \"  )  ;", "Mockito . verify ( response )  . setHeader (  \" WWW - Authenticate \"  ,     \" dummyauth \"  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDoFilterNotAuthenticated"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . CONFIG _ PREFIX )  )  . thenReturn (  \"  \"  )  ;", "Mockito . when ( config . getInitParameter (  \" a \"  )  )  . thenReturn (  \" A \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList (  \" a \"  )  )  . elements (  )  )  ;", "Properties   props    =    filter . getConfiguration (  \"  \"  ,    config )  ;", "Assert . assertEquals (  \" A \"  ,    props . getProperty (  \" a \"  )  )  ;", "config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . CONFIG _ PREFIX )  )  . thenReturn (  \" foo \"  )  ;", "Mockito . when ( config . getInitParameter (  \" foo . a \"  )  )  . thenReturn (  \" A \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList (  \" foo . a \"  )  )  . elements (  )  )  ;", "props    =    filter . getConfiguration (  \" foo .  \"  ,    config )  ;", "Assert . assertEquals (  \" A \"  ,    props . getProperty (  \" a \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetConfiguration"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "Mockito . when ( request . getQueryString (  )  )  . thenReturn (  \" a = A & b = B \"  )  ;", "Assert . assertEquals (  \" http :  /  / foo :  8  0  8  0  / bar ? a = A & b = B \"  ,    filter . getRequestURL ( request )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetRequestURL"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     . DummyAuthenticationHandler . TYPE )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     +     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "AuthenticationToken   newToken    =    filter . getToken ( request )  ;", "Assert . assertEquals ( token . toString (  )  ,    newToken . toString (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetToken"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     . DummyAuthenticationHandler . TYPE )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     -     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "boolean   failed    =    false ;", "try    {", "filter . getToken ( request )  ;", "}    catch    ( AuthenticationException   ex )     {", "Assert . assertEquals (  \" AuthenticationToken   expired \"  ,    ex . getMessage (  )  )  ;", "failed    =    true ;", "}    finally    {", "Assert . assertTrue (  \" token   not   expired \"  ,    failed )  ;", "}", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetTokenExpired"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     \" invalidtype \"  )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     +     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "boolean   failed    =    false ;", "try    {", "filter . getToken ( request )  ;", "}    catch    ( AuthenticationException   ex )     {", "Assert . assertEquals (  \" Invalid   AuthenticationToken   type \"  ,    ex . getMessage (  )  )  ;", "failed    =    true ;", "}    finally    {", "Assert . assertTrue (  \" token   not   invalid   type \"  ,    failed )  ;", "}", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetTokenInvalidType"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" simple \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TOKEN _ VALIDITY )  )  . thenReturn ( new   Long (  . TOKEN _ VALIDITY _ SEC )  . toString (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . AUTH _ TOKEN _ VALIDITY )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertEquals ( PseudoAuthenticationHandler . class ,    filter . getAuthenticationHandler (  )  . getClass (  )  )  ;", "Assert . assertTrue ( filter . isRandomSecret (  )  )  ;", "Assert . assertFalse ( filter . isCustomSignerSecretProvider (  )  )  ;", "Assert . assertNull ( filter . getCookieDomain (  )  )  ;", "Assert . assertNull ( filter . getCookiePath (  )  )  ;", "Assert . assertEquals (  . TOKEN _ VALIDITY _ SEC ,    filter . getValidity (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" simple \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertFalse ( filter . isRandomSecret (  )  )  ;", "Assert . assertFalse ( filter . isCustomSignerSecretProvider (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" simple \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . SIGNATURE _ SECRET )  )  . thenReturn (  \" secret \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . SIGNATURE _ SECRET )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( new   SignerSecretProvider (  )     {", "@ Override", "public   void   init ( Properties   config ,    long   tokenValidity )     {", "}", "@ Override", "public   byte [  ]    getCurrentSecret (  )     {", "return   null ;", "}", "@ Override", "public   byte [  ]  [  ]    getAllSecrets (  )     {", "return   null ;", "}", "}  )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertFalse ( filter . isRandomSecret (  )  )  ;", "Assert . assertTrue ( filter . isCustomSignerSecretProvider (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" simple \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . COOKIE _ DOMAIN )  )  . thenReturn (  \"  . foo . com \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . COOKIE _ PATH )  )  . thenReturn (  \"  / bar \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . COOKIE _ DOMAIN ,    AuthenticationFilter . COOKIE _ PATH )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertEquals (  \"  . foo . com \"  ,    filter . getCookieDomain (  )  )  ;", "Assert . assertEquals (  \"  / bar \"  ,    filter . getCookiePath (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", ". DummyAuthenticationHandler . reset (  )  ;", "filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" true \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertTrue (  . DummyAuthenticationHandler . init )  ;", "}    finally    {", "filter . destroy (  )  ;", "Assert . assertTrue (  . DummyAuthenticationHandler . destroy )  ;", "}", "filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" kerberos \"  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE )  )  . elements (  )  )  ;", "filter . init ( config )  ;", "}    catch    ( ServletException   ex )     {", "}    finally    {", "Assert . assertEquals ( KerberosAuthenticationHandler . class ,    filter . getAuthenticationHandler (  )  . getClass (  )  )  ;", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInit"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  \" SimPle \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TOKEN _ VALIDITY )  )  . thenReturn ( new   Long (  . TOKEN _ VALIDITY _ SEC )  . toString (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,    AuthenticationFilter . AUTH _ TOKEN _ VALIDITY )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "Assert . assertEquals ( PseudoAuthenticationHandler . class ,    filter . getAuthenticationHandler (  )  . getClass (  )  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInitCaseSensitivity"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  (  )  . elements (  )  )  ;", "filter . init ( config )  ;", "Assert . fail (  )  ;", "}    catch    ( ServletException   ex )     {", "Assert . assertEquals (  \" Authentication   type   must   be   specified :    simple | kerberos |  < class >  \"  ,    ex . getMessage (  )  )  ;", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInitEmpty"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "AuthenticationFilter   filter    =    new   AuthenticationFilter (  )  ;", "try    {", "FilterConfig   config    =    Mockito . mock ( FilterConfig . class )  ;", "Mockito . when ( config . getInitParameter (  \" management . operation . return \"  )  )  . thenReturn (  \" false \"  )  ;", "Mockito . when ( config . getInitParameter ( AuthenticationFilter . AUTH _ TYPE )  )  . thenReturn (  . DummyAuthenticationHandler . class . getName (  )  )  ;", "Mockito . when ( config . getInitParameterNames (  )  )  . thenReturn ( new   Vector < String >  ( Arrays . asList ( AuthenticationFilter . AUTH _ TYPE ,     \" management . operation . return \"  )  )  . elements (  )  )  ;", "ServletContext   context    =    Mockito . mock ( ServletContext . class )  ;", "Mockito . when ( context . getAttribute ( AuthenticationFilter . SIGNATURE _ PROVIDER _ ATTRIBUTE )  )  . thenReturn ( null )  ;", "Mockito . when ( config . getServletContext (  )  )  . thenReturn ( context )  ;", "filter . init ( config )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "Mockito . when ( request . getRequestURL (  )  )  . thenReturn ( new   StringBuffer (  \" http :  /  / foo :  8  0  8  0  / bar \"  )  )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "FilterChain   chain    =    Mockito . mock ( FilterChain . class )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "Mockito . verify ( response )  . setStatus ( SC _ ACCEPTED )  ;", "Mockito . verifyNoMoreInteractions ( response )  ;", "Mockito . reset ( request )  ;", "Mockito . reset ( response )  ;", "AuthenticationToken   token    =    new   AuthenticationToken (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "token . setExpires (  (  ( System . currentTimeMillis (  )  )     +     (  . TOKEN _ VALIDITY _ SEC )  )  )  ;", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   tokenSigned    =    signer . sign ( token . toString (  )  )  ;", "Cookie   cookie    =    new   Cookie ( AuthenticatedURL . AUTH _ COOKIE ,    tokenSigned )  ;", "Mockito . when ( request . getCookies (  )  )  . thenReturn ( new   Cookie [  ]  {    cookie    }  )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "Mockito . verify ( response )  . setStatus ( SC _ ACCEPTED )  ;", "Mockito . verifyNoMoreInteractions ( response )  ;", "}    finally    {", "filter . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testManagementOperation"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "final   HashMap < String ,    String >    cookieMap    =    new   HashMap < String ,    String >  (  )  ;", "Mockito . doAnswer ( new   Answer < Object >  (  )     {", "@ Override", "public   Object   answer ( InvocationOnMock   invocation )    throws   Throwable    {", "String   cookieHeader    =     (  ( String )     ( invocation . getArguments (  )  [  1  ]  )  )  ;", ". parseCookieMap ( cookieHeader ,    cookieMap )  ;", "return   null ;", "}", "}  )  . when ( response )  . addHeader ( Mockito . eq (  \" Set - Cookie \"  )  ,    Mockito . anyString (  )  )  ;", "filter . doFilter ( request ,    response ,    chain )  ;", "Mockito . verify ( response )  . sendError ( Mockito . eq ( SC _ UNAUTHORIZED )  ,    Mockito . anyString (  )  )  ;", "Mockito . verify ( chain ,    Mockito . never (  )  )  . doFilter ( Mockito . any ( ServletRequest . class )  ,    Mockito . any ( ServletResponse . class )  )  ;", "Assert . assertTrue (  \" cookie   is   missing \"  ,    cookieMap . containsKey ( AuthenticatedURL . AUTH _ COOKIE )  )  ;", "Assert . assertEquals (  \"  \"  ,    cookieMap . get ( AuthenticatedURL . AUTH _ COOKIE )  )  ;", "}", "METHOD_END"], "methodName": ["verifyUnauthorized"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationFilter"}, {"methodBody": ["METHOD_START", "{", "Assert . assertNotNull ( AuthenticationToken . ANONYMOUS )  ;", "Assert . assertEquals ( null ,    AuthenticationToken . ANONYMOUS . getUserName (  )  )  ;", "Assert . assertEquals ( null ,    AuthenticationToken . ANONYMOUS . getName (  )  )  ;", "Assert . assertEquals ( null ,    AuthenticationToken . ANONYMOUS . getType (  )  )  ;", "Assert . assertEquals (  (  -  1  )  ,    AuthenticationToken . ANONYMOUS . getExpires (  )  )  ;", "Assert . assertFalse ( AuthenticationToken . ANONYMOUS . isExpired (  )  )  ;", "}", "METHOD_END"], "methodName": ["testAnonymous"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    ( null ,     \" p \"  ,     \" t \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "new    (  \"  \"  ,     \" p \"  ,     \" t \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "new    (  \" u \"  ,    null ,     \" t \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "new    (  \" u \"  ,     \"  \"  ,     \" t \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "new    (  \" u \"  ,     \" p \"  ,    null )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "new    (  \" u \"  ,     \" p \"  ,     \"  \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "new    (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "}", "METHOD_END"], "methodName": ["testConstructor"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "long   expires    =     ( System . currentTimeMillis (  )  )     +     5  0  ;", "token    =    new    (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "token . setExpires ( expires )  ;", "Assert . assertEquals (  \" u \"  ,    token . getUserName (  )  )  ;", "Assert . assertEquals (  \" p \"  ,    token . getName (  )  )  ;", "Assert . assertEquals (  \" t \"  ,    token . getType (  )  )  ;", "Assert . assertEquals ( expires ,    token . getExpires (  )  )  ;", "Assert . assertFalse ( token . isExpired (  )  )  ;", "Thread . sleep (  7  0  )  ;", "Assert . assertTrue ( token . isExpired (  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetters"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "long   expires    =     ( System . currentTimeMillis (  )  )     +     5  0  ;", "token    =    new    (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "token . setExpires ( expires )  ;", "String   str    =    token . toString (  )  ;", "str    =    str . substring (  0  ,    str . indexOf (  \" e =  \"  )  )  ;", "try    {", ". parse ( str )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthenticationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseInvalid"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "long   expires    =     ( System . currentTimeMillis (  )  )     +     5  0  ;", "token    =    new    (  \" u \"  ,     \" p \"  ,     \" t \"  )  ;", "token . setExpires ( expires )  ;", "String   str    =    token . toString (  )  ;", "token    =     . parse ( str )  ;", "Assert . assertEquals (  \" p \"  ,    token . getName (  )  )  ;", "Assert . assertEquals (  \" t \"  ,    token . getType (  )  )  ;", "Assert . assertEquals ( expires ,    token . getExpires (  )  )  ;", "Assert . assertFalse ( token . isExpired (  )  )  ;", "Thread . sleep (  7  0  )  ;", "Assert . assertTrue ( token . isExpired (  )  )  ;", "}", "METHOD_END"], "methodName": ["testToStringAndParse"], "fileName": "org.apache.hadoop.security.authentication.server.TestAuthenticationToken"}, {"methodBody": ["METHOD_START", "{", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  . PRINCIPAL ,    KerberosTestUtils . getServerPrincipal (  )  )  ;", "props . setProperty (  . KEYTAB ,    KerberosTestUtils . getKeytabFile (  )  )  ;", "props . setProperty (  . NAME _ RULES ,     (  (  \" RULE :  [  1  :  $  1  @  $  0  ]  (  .  *  @  \"     +     ( KerberosTestUtils . getRealm (  )  )  )     +     \"  ) s /  @  .  *  /  /  \\ n \"  )  )  ;", "return   props ;", "}", "METHOD_END"], "methodName": ["getDefaultProperties"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "return   KerberosAuthenticationHandler . TYPE ;", "}", "METHOD_END"], "methodName": ["getExpectedType"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "return   new   KerberosAuthenticationHandler (  )  ;", "}", "METHOD_END"], "methodName": ["getNewAuthenticationHandler"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "File   keytabFile    =    new   File ( KerberosTestUtils . getKeytabFile (  )  )  ;", "String   clientPrincipal    =    KerberosTestUtils . getClientPrincipal (  )  ;", "String   serverPrincipal    =    KerberosTestUtils . getServerPrincipal (  )  ;", "clientPrincipal    =    clientPrincipal . substring (  0  ,    clientPrincipal . lastIndexOf (  \"  @  \"  )  )  ;", "serverPrincipal    =    serverPrincipal . substring (  0  ,    serverPrincipal . lastIndexOf (  \"  @  \"  )  )  ;", "getKdc (  )  . createPrincipal ( keytabFile ,    clientPrincipal ,    serverPrincipal )  ;", "handler    =    getNew (  )  ;", "Properties   props    =    getDefaultProperties (  )  ;", "try    {", "handler . init ( props )  ;", "}    catch    ( Exception   ex )     {", "handler    =    null ;", "throw   ex ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "if    (  ( handler )     !  =    null )     {", "handler . destroy (  )  ;", "handler    =    null ;", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    keytabUsers    =    new   String [  ]  {     \" HTTP / host 1  \"  ,     \" HTTP / host 2  \"  ,     \" HTTP 2  / host 1  \"  ,     \" XHTTP / host \"     }  ;", "String   keytab    =    KerberosTestUtils . getKeytabFile (  )  ;", "getKdc (  )  . createPrincipal ( new   File ( keytab )  ,    keytabUsers )  ;", "handler . destroy (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  . KEYTAB ,    keytab )  ;", "props . setProperty (  . PRINCIPAL ,     \"  *  \"  )  ;", "handler    =    getNewAuthenticationHandler (  )  ;", "handler . init ( props )  ;", "Assert . assertEquals ( KerberosTestUtils . getKeytabFile (  )  ,    handler . getKeytab (  )  )  ;", "Set < KerberosPrincipal >    loginPrincipals    =    handler . getPrincipals (  )  ;", "for    ( String   user    :    keytabUsers )     {", "Principal   principal    =    new   KerberosPrincipal (  (  ( user    +     \"  @  \"  )     +     ( KerberosTestUtils . getRealm (  )  )  )  )  ;", "boolean   expected    =    user . startsWith (  \" HTTP /  \"  )  ;", "Assert . assertEquals (  (  \" checking   for    \"     +    user )  ,    expected ,    loginPrincipals . contains ( principal )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDynamicPrincipalDiscovery"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "String [  ]    keytabUsers    =    new   String [  ]  {     \" hdfs / localhost \"     }  ;", "String   keytab    =    KerberosTestUtils . getKeytabFile (  )  ;", "getKdc (  )  . createPrincipal ( new   File ( keytab )  ,    keytabUsers )  ;", "handler . destroy (  )  ;", "Properties   props    =    new   Properties (  )  ;", "props . setProperty (  . KEYTAB ,    keytab )  ;", "props . setProperty (  . PRINCIPAL ,     \"  *  \"  )  ;", "handler    =    getNewAuthenticationHandler (  )  ;", "try    {", "handler . init ( props )  ;", "Assert . fail (  \" init   should   have   failed \"  )  ;", "}    catch    ( ServletException   ex )     {", "Assert . assertEquals (  \" Principals   do   not   exist   in   the   keytab \"  ,    ex . getCause (  )  . getMessage (  )  )  ;", "}    catch    ( Throwable   t )     {", "Assert . fail (  (  \" wrong   exception :     \"     +    t )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDynamicPrincipalDiscoveryMissingPrincipals"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( KerberosTestUtils . getKeytabFile (  )  ,    handler . getKeytab (  )  )  ;", "Set < KerberosPrincipal >    principals    =    handler . getPrincipals (  )  ;", "Principal   expectedPrincipal    =    new   KerberosPrincipal ( KerberosTestUtils . getServerPrincipal (  )  )  ;", "Assert . assertTrue ( principals . contains ( expectedPrincipal )  )  ;", "Assert . assertEquals (  1  ,    principals . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInit"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "KerberosName   kn    =    new   KerberosName ( KerberosTestUtils . getServerPrincipal (  )  )  ;", "Assert . assertEquals ( KerberosTestUtils . getRealm (  )  ,    kn . getRealm (  )  )  ;", "handler . destroy (  )  ;", "KerberosName . setRules (  \" RULE :  [  1  :  $  1  @  $  0  ]  (  .  *  @ FOO ) s /  @  .  *  /  /  \\ nDEFAULT \"  )  ;", "handler    =    getNewAuthenticationHandler (  )  ;", "Properties   props    =    getDefaultProperties (  )  ;", "props . setProperty (  . NAME _ RULES ,     \" RULE :  [  1  :  $  1  @  $  0  ]  (  .  *  @ BAR ) s /  @  .  *  /  /  \\ nDEFAULT \"  )  ;", "try    {", "handler . init ( props )  ;", "}    catch    ( Exception   ex )     {", "}", "kn    =    new   KerberosName (  \" bar @ BAR \"  )  ;", "Assert . assertEquals (  \" bar \"  ,    kn . getShortName (  )  )  ;", "kn    =    new   KerberosName (  \" bar @ FOO \"  )  ;", "try    {", "kn . getShortName (  )  ;", "Assert . fail (  )  ;", "}    catch    ( Exception   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testNameRules"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "String   token    =    KerberosTestUtils . doAsClient ( new   Callable < String >  (  )     {", "@ Override", "public   String   call (  )    throws   Exception    {", "GSSManager   gssManager    =    GSSManager . getInstance (  )  ;", "GSSContext   gssContext    =    null ;", "try    {", "String   servicePrincipal    =    KerberosTestUtils . getServerPrincipal (  )  ;", "Oid   oid    =    KerberosUtil . getOidInstance (  \" NT _ GSS _ KRB 5  _ PRINCIPAL \"  )  ;", "GSSName   serviceName    =    gssManager . createName ( servicePrincipal ,    oid )  ;", "oid    =    KerberosUtil . getOidInstance (  \" GSS _ KRB 5  _ MECH _ OID \"  )  ;", "gssContext    =    gssManager . createContext ( serviceName ,    oid ,    null ,    GSSContext . DEFAULT _ LIFETIME )  ;", "gssContext . requestCredDeleg ( true )  ;", "gssContext . requestMutualAuth ( true )  ;", "byte [  ]    inToken    =    new   byte [  0  ]  ;", "byte [  ]    outToken    =    gssContext . initSecContext ( inToken ,     0  ,    inToken . length )  ;", "Base 6  4    base 6  4     =    new   Base 6  4  (  0  )  ;", "return   base 6  4  . encodeToString ( outToken )  ;", "}    finally    {", "if    ( gssContext    !  =    null )     {", "gssContext . dispose (  )  ;", "}", "}", "}", "}  )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getHeader ( or . AUTHORIZATION )  )  . thenReturn (  (  (  ( or . NEGOTIATE )     +     \"     \"  )     +    token )  )  ;", "Mockito . when ( request . getServerName (  )  )  . thenReturn (  \" localhost \"  )  ;", "AuthenticationToken   authToken    =    handler . authenticate ( request ,    response )  ;", "if    ( authToken    !  =    null )     {", "Mockito . verify ( response )  . setHeader ( Mockito . eq ( or . WWW _ AUTHENTICATE )  ,    Mockito . matches (  (  ( or . NEGOTIATE )     +     \"     .  *  \"  )  )  )  ;", "Mockito . verify ( response )  . setStatus ( SC _ OK )  ;", "Assert . assertEquals ( KerberosTestUtils . getClientPrincipal (  )  ,    authToken . getName (  )  )  ;", "Assert . assertTrue ( KerberosTestUtils . getClientPrincipal (  )  . startsWith ( authToken . getUserName (  )  )  )  ;", "Assert . assertEquals ( getExpectedType (  )  ,    authToken . getType (  )  )  ;", "} else    {", "Mockito . verify ( response )  . setHeader ( Mockito . eq ( or . WWW _ AUTHENTICATE )  ,    Mockito . matches (  (  ( or . NEGOTIATE )     +     \"     .  *  \"  )  )  )  ;", "Mockito . verify ( response )  . setStatus ( SC _ UNAUTHORIZED )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequestWithAuthorization"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getHeader ( or . AUTHORIZATION )  )  . thenReturn ( or . NEGOTIATE )  ;", "try    {", "handler . authenticate ( request ,    response )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthenticationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequestWithIncompleteAuthorization"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getHeader ( or . AUTHORIZATION )  )  . thenReturn (  \" invalid \"  )  ;", "Assert . assertNull ( handler . authenticate ( request ,    response )  )  ;", "Mockito . verify ( response )  . setHeader ( or . WWW _ AUTHENTICATE ,    or . NEGOTIATE )  ;", "Mockito . verify ( response )  . setStatus ( SC _ UNAUTHORIZED )  ;", "}", "METHOD_END"], "methodName": ["testRequestWithInvalidAuthorization"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "String   token    =    new   Base 6  4  (  0  )  . encodeToString ( new   byte [  ]  {     0  ,     1  ,     2     }  )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getHeader ( or . AUTHORIZATION )  )  . thenReturn (  (  ( or . NEGOTIATE )     +    token )  )  ;", "try    {", "handler . authenticate ( request ,    response )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthenticationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequestWithInvalidKerberosAuthorization"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Assert . assertNull ( handler . authenticate ( request ,    response )  )  ;", "Mockito . verify ( response )  . setHeader ( or . WWW _ AUTHENTICATE ,    or . NEGOTIATE )  ;", "Mockito . verify ( response )  . setStatus ( SC _ UNAUTHORIZED )  ;", "}", "METHOD_END"], "methodName": ["testRequestWithoutAuthorization"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "Assert . assertEquals ( getExpectedType (  )  ,    handler . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testType"], "fileName": "org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticationHandler   handler    =    new   PseudoAuthenticationHandler (  )  ;", "try    {", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,    Boolean . toString ( anonymous )  )  ;", "handler . init ( props )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "Mockito . when ( request . getQueryString (  )  )  . thenReturn (  (  (  ( PseudoAuthenticator . USER _ NAME )     +     \"  =  \"  )     +     \" user \"  )  )  ;", "AuthenticationToken   token    =    handler . authenticate ( request ,    response )  ;", "Assert . assertNotNull ( token )  ;", "Assert . assertEquals (  \" user \"  ,    token . getUserName (  )  )  ;", "Assert . assertEquals (  \" user \"  ,    token . getName (  )  )  ;", "Assert . assertEquals ( PseudoAuthenticationHandler . TYPE ,    token . getType (  )  )  ;", "}    finally    {", "handler . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["_testUserName"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticationHandler   handler    =    new   PseudoAuthenticationHandler (  )  ;", "try    {", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,     \" false \"  )  ;", "handler . init ( props )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "handler . authenticate ( request ,    response )  ;", "Assert . fail (  )  ;", "}    catch    ( AuthenticationException   ex )     {", "}    catch    ( Exception   ex )     {", "Assert . fail (  )  ;", "}    finally    {", "handler . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAnonymousOff"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticationHandler   handler    =    new   PseudoAuthenticationHandler (  )  ;", "try    {", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,     \" true \"  )  ;", "handler . init ( props )  ;", "HttpServletRequest   request    =    Mockito . mock ( HttpServletRequest . class )  ;", "HttpServletResponse   response    =    Mockito . mock ( HttpServletResponse . class )  ;", "AuthenticationToken   token    =    handler . authenticate ( request ,    response )  ;", "Assert . assertEquals ( AuthenticationToken . ANONYMOUS ,    token )  ;", "}    finally    {", "handler . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAnonymousOn"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticationHandler   handler    =    new   PseudoAuthenticationHandler (  )  ;", "try    {", "Properties   props    =    new   Properties (  )  ;", "props . setProperty ( PseudoAuthenticationHandler . ANONYMOUS _ ALLOWED ,     \" false \"  )  ;", "handler . init ( props )  ;", "Assert . assertEquals ( false ,    handler . getAcceptAnonymous (  )  )  ;", "}    finally    {", "handler . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInit"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "PseudoAuthenticationHandler   handler    =    new   PseudoAuthenticationHandler (  )  ;", "Assert . assertEquals ( PseudoAuthenticationHandler . TYPE ,    handler . getType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testType"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "_ testUserName ( false )  ;", "}", "METHOD_END"], "methodName": ["testUserNameAnonymousOff"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "_ testUserName ( true )  ;", "}", "METHOD_END"], "methodName": ["testUserNameAnonymousOn"], "fileName": "org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler"}, {"methodBody": ["METHOD_START", "{", "return   KerberosName . defaultRealm ;", "}", "METHOD_END"], "methodName": ["getDefaultRealm"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "return   hostName ;", "}", "METHOD_END"], "methodName": ["getHostName"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "return   realm ;", "}", "METHOD_END"], "methodName": ["getRealm"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "String   ruleString    =    null ;", "if    (  (  . rules )     !  =    null )     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "for    (  . Rule   rule    :     . rules )     {", "sb . append ( rule . toString (  )  )  . append (  \"  \\ n \"  )  ;", "}", "ruleString    =    sb . toString (  )  . trim (  )  ;", "}", "return   ruleString ;", "}", "METHOD_END"], "methodName": ["getRules"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "return   serviceName ;", "}", "METHOD_END"], "methodName": ["getServiceName"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "String [  ]    params ;", "if    (  ( hostName )     =  =    null )     {", "if    (  ( realm )     =  =    null )     {", "return   serviceName ;", "}", "params    =    new   String [  ]  {    realm ,    serviceName    }  ;", "} else    {", "params    =    new   String [  ]  {    realm ,    serviceName ,    hostName    }  ;", "}", "for    (  . Rule   r    :     . rules )     {", "String   result    =    r . apply ( params )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "throw   new    . NoMatchingRule (  (  \" No   rules   applied   to    \"     +     ( toString (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getShortName"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "return    ( KerberosName . rules )     !  =    null ;", "}", "METHOD_END"], "methodName": ["hasRulesBeenSet"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "List < KerberosName . Rule >    result    =    new   ArrayList < KerberosName . Rule >  (  )  ;", "String   remaining    =    rules . trim (  )  ;", "while    (  ( remaining . length (  )  )     >     0  )     {", "Matcher   matcher    =    KerberosName . ruleParser . matcher ( remaining )  ;", "if    (  !  ( matcher . lookingAt (  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Invalid   rule :     \"     +    remaining )  )  ;", "}", "if    (  ( matcher . group (  2  )  )     !  =    null )     {", "result . add ( new   KerberosName . Rule (  )  )  ;", "} else    {", "result . add ( new   KerberosName . Rule ( Integer . parseInt ( matcher . group (  4  )  )  ,    matcher . group (  5  )  ,    matcher . group (  7  )  ,    matcher . group (  9  )  ,    matcher . group (  1  0  )  ,     \" g \"  . equals ( matcher . group (  1  1  )  )  ,     \" L \"  . equals ( matcher . group (  1  2  )  )  )  )  ;", "}", "remaining    =    remaining . substring ( matcher . end (  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["parseRules"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "for    (  . Rule   r    :     . rules )     {", "System . out . println (  (  (  (  +  + i )     +     \"     \"  )     +    r )  )  ;", "}", "}", "METHOD_END"], "methodName": ["printRules"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "KerberosName . rules    =     ( ruleString    !  =    null )     ?    KerberosName . parseRules ( ruleString )     :    null ;", "}", "METHOD_END"], "methodName": ["setRules"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosName"}, {"methodBody": ["METHOD_START", "{", "Object   kerbConf ;", "Class <  ?  >    classRef ;", "Method   getInstanceMethod ;", "Method   getDefaultRealmMethod ;", "if    ( System . getProperty (  \" vendor \"  )  . contains (  \" IBM \"  )  )     {", "classRef    =    Class . forName (  \" com . ibmkrb 5  . internal . Config \"  )  ;", "} else    {", "classRef    =    Class . forName (  \" sunkrb 5  . Config \"  )  ;", "}", "getInstanceMethod    =    classRef . getMethod (  \" getInstance \"  ,    new   Class [  0  ]  )  ;", "kerbConf    =    getInstanceMethod . invoke ( classRef ,    new   Object [  0  ]  )  ;", "getDefaultRealmMethod    =    classRef . getDeclaredMethod (  \" getDefaultRealm \"  ,    new   Class [  0  ]  )  ;", "return    (  ( String )     ( getDefaultRealmMethod . invoke ( kerbConf ,    new   Object [  0  ]  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getDefaultRealm"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperty (  \" vendor \"  )  . contains (  \" IBM \"  )     ?     \" com . ibm . security . auth . module . Krb 5 LoginModule \"     :     \" com . sun . security . auth . module . Krb 5 LoginModule \"  ;", "}", "METHOD_END"], "methodName": ["getKrb5LoginModuleName"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "return   InetAddress . getLocalHost (  )  . getCanonicalHostName (  )  ;", "}", "METHOD_END"], "methodName": ["getLocalHostName"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "Class <  ?  >    oidClass ;", "if    ( PlatformName . IBM _ JAVA )     {", "if    (  \" NT _ GSS _ KRB 5  _ PRINCIPAL \"  . equals ( oidName )  )     {", "return   new   Oid (  \"  1  .  2  .  8  4  0  .  1  1  3  5  5  4  .  1  .  2  .  2  .  1  \"  )  ;", "}", "oidClass    =    Class . forName (  \" com . ibmjgss . GSSUtil \"  )  ;", "} else    {", "oidClass    =    Class . forName (  \" sunjgss . GSSUtil \"  )  ;", "}", "Field   oidField    =    oidClass . getDeclaredField ( oidName )  ;", "return    (  ( Oid )     ( oidField . get ( oidClass )  )  )  ;", "}", "METHOD_END"], "methodName": ["getOidInstance"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "Keytab   keytab    =    Keytab . read ( new   File ( keytabFileName )  )  ;", "Set < String >    principals    =    new   HashSet < String >  (  )  ;", "List < KeytabEntry >    ries    =    keytab . getEntries (  )  ;", "for    ( KeytabEntry   ry    :    ries )     {", "principals . add ( ry . getPrincipalName (  )  . replace (  \"  \\  \\  \"  ,     \"  /  \"  )  )  ;", "}", "return   principals . toArray ( new   String [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getPrincipalNames"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "String [  ]    principals    =    KerberosUtil . getPrincipalNames ( keytab )  ;", "if    (  ( principals . length )     !  =     0  )     {", "List < String >    matchingPrincipals    =    new   ArrayList < String >  (  )  ;", "for    ( String   principal    :    principals )     {", "if    ( pattern . matcher ( principal )  . matches (  )  )     {", "matchingPrincipals . add ( principal )  ;", "}", "}", "principals    =    matchingPrincipals . toArray ( new   String [  0  ]  )  ;", "}", "return   principals ;", "}", "METHOD_END"], "methodName": ["getPrincipalNames"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "String   fqdn    =    hostname ;", "if    (  (  ( null    =  =    fqdn )     |  |     ( fqdn . equals (  \"  \"  )  )  )     |  |     ( fqdn . equals (  \"  0  .  0  .  0  .  0  \"  )  )  )     {", "fqdn    =     . getLocalHostName (  )  ;", "}", "return    ( service    +     \"  /  \"  )     +     ( fqdn . toLowerCase ( Locale . US )  )  ;", "}", "METHOD_END"], "methodName": ["getServicePrincipal"], "fileName": "org.apache.hadoop.security.authentication.util.KerberosUtil"}, {"methodBody": ["METHOD_START", "{", "secrets    =    new   byte [  ]  [  ]  {    currentSecret ,    previousSecret    }  ;", "}", "METHOD_END"], "methodName": ["initSecrets"], "fileName": "org.apache.hadoop.security.authentication.util.RolloverSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( isDestroyed )  )     {", ". LOG . debug (  \" rolling   secret \"  )  ;", "byte [  ]    newSecret    =    generateNewSecret (  )  ;", "secrets    =    new   byte [  ]  [  ]  {    newSecret ,    secrets [  0  ]     }  ;", "}", "}", "METHOD_END"], "methodName": ["rollSecret"], "fileName": "org.apache.hadoop.security.authentication.util.RolloverSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( schedulerRunning )  )     {", "schedulerRunning    =    true ;", "scheduler    =    Executors . newSingleThreadScheduledExecutor (  )  ;", "scheduler . scheduleAtFixedRate ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "roll (  )  ;", "}", "}  ,    initialDelay ,    period ,    TimeUnit . MILLISECONDS )  ;", "}", "}", "METHOD_END"], "methodName": ["startScheduler"], "fileName": "org.apache.hadoop.security.authentication.util.RolloverSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "boolean   isValid    =    false ;", "byte [  ]  [  ]    secrets    =    secretProvider . getAllSecrets (  )  ;", "for    ( int   i    =     0  ;    i    <     ( secrets . length )  ;    i +  +  )     {", "byte [  ]    secret    =    secrets [ i ]  ;", "if    ( secret    !  =    null )     {", "String   currentSignature    =    computeSignature ( secret ,    rawValue )  ;", "if    ( originalSignature . equals ( currentSignature )  )     {", "isValid    =    true ;", "break ;", "}", "}", "}", "if    (  ! isValid )     {", "throw   new   Exception (  \" Invalid   signature \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkSignatures"], "fileName": "org.apache.hadoop.security.authentication.util.Signer"}, {"methodBody": ["METHOD_START", "{", "try    {", "MessageDigest   md    =    MessageDigest . getInstance (  \" SHA \"  )  ;", "md . update ( str . getBytes (  )  )  ;", "md . update ( secret )  ;", "byte [  ]    digest    =    md . digest (  )  ;", "return   new   Base 6  4  (  0  )  . encodeToString ( digest )  ;", "}    catch    ( NoSuchAlgorithmExcep   ex )     {", "throw   new   RuntimeExcep (  (  \" It   should   not   happen ,     \"     +     ( ex . getMessage (  )  )  )  ,    ex )  ;", "}", "}", "METHOD_END"], "methodName": ["computeSignature"], "fileName": "org.apache.hadoop.security.authentication.util.Signer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( str    =  =    null )     |  |     (  ( str . length (  )  )     =  =     0  )  )     {", "throw   new   IllegalArgumentException (  \" NULL   or   empty   string   to   sign \"  )  ;", "}", "byte [  ]    secret    =    secretProvider . getCurrentSecret (  )  ;", "String   signature    =    computeSignature ( secret ,    str )  ;", "return    ( str    +     (  . SIGNATURE )  )     +    signature ;", "}", "METHOD_END"], "methodName": ["sign"], "fileName": "org.apache.hadoop.security.authentication.util.Signer"}, {"methodBody": ["METHOD_START", "{", "int   index    =    signedStr . lastIndexOf ( Signer . SIGNATURE )  ;", "if    ( index    =  =     (  -  1  )  )     {", "throw   new   SignerException (  (  \" Invalid   signed   text :     \"     +    signedStr )  )  ;", "}", "String   originalSignature    =    signedStr . substring (  ( index    +     ( Signer . SIGNATURE . length (  )  )  )  )  ;", "String   rawValue    =    signedStr . substring (  0  ,    index )  ;", "checkSignatures ( rawValue ,    originalSignature )  ;", "return   rawValue ;", "}", "METHOD_END"], "methodName": ["verifyAndExtract"], "fileName": "org.apache.hadoop.security.authentication.util.Signer"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  (  \" Checking    \"     +    name )     +     \"    to   ensure   it   is   bad .  \"  )  )  ;", "try    {", "new    ( name )  ;", "Assert . fail (  (  \" didn ' t   get   exception   for    \"     +    name )  )  ;", "}    catch    ( IllegalArgumentException   iae )     {", "}", "}", "METHOD_END"], "methodName": ["checkBadName"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Checking   bad   translation   for    \"     +    from )  )  ;", "nm    =    new    ( from )  ;", "try    {", "nm . getShortName (  )  ;", "Assert . fail (  (  \" didn ' t   get   exception   for    \"     +    from )  )  ;", "}    catch    ( IOException   ie )     {", "}", "}", "METHOD_END"], "methodName": ["checkBadTranslation"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "System . out . println (  (  \" Translate    \"     +    from )  )  ;", "nm    =    new    ( from )  ;", "String   simple    =    nm . getShortName (  )  ;", "System . out . println (  (  \" to    \"     +    simple )  )  ;", "Assert . assertEquals (  \" short   name   incorrect \"  ,    to ,    simple )  ;", "}", "METHOD_END"], "methodName": ["checkTranslation"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "System . clearProperty (  \" realm \"  )  ;", "System . clearProperty (  \" kdc \"  )  ;", "}", "METHOD_END"], "methodName": ["clear"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "System . setProperty (  \" realm \"  ,    KerberosTestUtils . getRealm (  )  )  ;", "System . setProperty (  \" kdc \"  ,     \" localhost :  8  8  \"  )  ;", "String   rules    =     \" RULE :  [  1  :  $  1  @  $  0  ]  (  .  *  @ YAHOO \\  \\  . COM ) s /  @  .  *  /  /  \\ n \"     +     (  (  (  \" RULE :  [  2  :  $  1  ]  ( johndoe ) s /  ^  .  *  $  / guest /  \\ n \"     +     \" RULE :  [  2  :  $  1  ;  $  2  ]  (  ^  .  *  ; admin $  ) s /  ; admin $  /  /  \\ n \"  )     +     \" RULE :  [  2  :  $  2  ]  ( root )  \\ n \"  )     +     \" DEFAULT \"  )  ;", ". setRules ( rules )  ;", ". printRules (  )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "checkBadName (  \" owen / owen / owen @ FOO . COM \"  )  ;", "checkBadName (  \" owen @ foo / bar . com \"  )  ;", "checkBadTransl (  \" foo @ ACME . COM \"  )  ;", "checkBadTransl (  \" root / joe @ FOO . COM \"  )  ;", "}", "METHOD_END"], "methodName": ["testAntiPatterns"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "checkTranslation (  (  \" omalley @  \"     +     ( KerberosTestUtils . getRealm (  )  )  )  ,     \" omalley \"  )  ;", "checkTranslation (  (  \" hdfs /  1  0  .  0  .  0  .  1  @  \"     +     ( KerberosTestUtils . getRealm (  )  )  )  ,     \" hdfs \"  )  ;", "checkTranslation (  \" oom @ YAHOO . COM \"  ,     \" oom \"  )  ;", "checkTranslation (  \" johndoe / zoo @ FOO . COM \"  ,     \" guest \"  )  ;", "checkTranslation (  \" joe / admin @ FOO . COM \"  ,     \" joe \"  )  ;", "checkTranslation (  \" joe / root @ FOO . COM \"  ,     \" root \"  )  ;", "}", "METHOD_END"], "methodName": ["testRules"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "String   rules    =     \" RULE :  [  1  :  $  1  ]  / L \\ n \"     +     (  (  (  \" RULE :  [  2  :  $  1  ]  / L \\ n \"     +     \" RULE :  [  2  :  $  1  ;  $  2  ]  (  ^  .  *  ; admin $  ) s /  ; admin $  /  /  / L \\ n \"  )     +     \" RULE :  [  2  :  $  1  ;  $  2  ]  (  ^  .  *  ; guest $  ) s /  ; guest $  /  / g / L \\ n \"  )     +     \" DEFAULT \"  )  ;", ". setRules ( rules )  ;", ". printRules (  )  ;", "checkTranslation (  \" Joe @ FOO . COM \"  ,     \" joe \"  )  ;", "checkTranslation (  \" Joe / root @ FOO . COM \"  ,     \" joe \"  )  ;", "checkTranslation (  \" Joe / admin @ FOO . COM \"  ,     \" joe \"  )  ;", "checkTranslation (  \" Joe / guestguest @ FOO . COM \"  ,     \" joe \"  )  ;", "}", "METHOD_END"], "methodName": ["testToLowerCase"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosName"}, {"methodBody": ["METHOD_START", "{", "List < KeytabEntry >    lstEntries    =    new   ArrayList < KeytabEntry >  (  )  ;", "for    ( String   principal    :    principalNames )     {", "for    ( int   kvno    =     1  ;    kvno    <  =     3  ;    kvno +  +  )     {", "EncryptionKey   key    =    new   EncryptionKey ( EncryptionType . UNKNOWN ,     \" samplekey 1  \"  . getBytes (  )  ,    kvno )  ;", "KeytabEntry   keytabEntry    =    new   KeytabEntry ( principal ,     1  ,    new   KerberosTime (  )  ,     (  ( byte )     (  1  )  )  ,    key )  ;", "lstEntries . add ( keytabEntry )  ;", "}", "}", "Keytab   keytab    =    Keytab . getInstance (  )  ;", "keytab . setEntries ( lstEntries )  ;", "keytab . write ( new   File (  . testKeytab )  )  ;", "}", "METHOD_END"], "methodName": ["createKeyTab"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "File   keytabFile    =    new   File ( TestKerberosUtil . testKeytab )  ;", "if    ( keytabFile . exists (  )  )     {", "keytabFile . delete (  )  ;", "}", "}", "METHOD_END"], "methodName": ["deleteKeytab"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "createKeyTab ( TestKerberosUtil . testKeytab ,    TestKerberosUtil . testPrincipals )  ;", "String [  ]    principals    =    KerberosUtil . getPrincipalNames ( TestKerberosUtil . testKeytab )  ;", "Assert . assertNotNull (  \" principals   cannot   be   null \"  ,    principals )  ;", "int   expectedSize    =     0  ;", "List < String >    principalList    =    Arrays . asList ( principals )  ;", "for    ( String   principal    :    TestKerberosUtil . testPrincipals )     {", "Assert . assertTrue (  (  \" missing   principal    \"     +    principal )  ,    principalList . contains ( principal )  )  ;", "expectedSize +  +  ;", "}", "Assert . assertEquals ( expectedSize ,    principals . length )  ;", "}", "METHOD_END"], "methodName": ["testGetPrincipalNamesFromKeytab"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "createKeyTab ( TestKerberosUtil . testKeytab ,    TestKerberosUtil . testPrincipals )  ;", "Pattern   httpPattern    =    Pattern . compile (  \" HTTP /  .  *  \"  )  ;", "String [  ]    httpPrincipals    =    KerberosUtil . getPrincipalNames ( TestKerberosUtil . testKeytab ,    httpPattern )  ;", "Assert . assertNotNull (  \" principals   cannot   be   null \"  ,    httpPrincipals )  ;", "int   expectedSize    =     0  ;", "List < String >    httpPrincipalList    =    Arrays . asList ( httpPrincipals )  ;", "for    ( String   principal    :    TestKerberosUtil . testPrincipals )     {", "if    ( httpPattern . matcher ( principal )  . matches (  )  )     {", "Assert . assertTrue (  (  \" missing   principal    \"     +    principal )  ,    httpPrincipalList . contains ( principal )  )  ;", "expectedSize +  +  ;", "}", "}", "Assert . assertEquals ( expectedSize ,    httpPrincipals . length )  ;", "}", "METHOD_END"], "methodName": ["testGetPrincipalNamesFromKeytabWithPattern"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "try    {", "KerberosUtil . getPrincipalNames (  . testKeytab )  ;", "Assert . fail (  \" Exception   should   have   been   thrown \"  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "METHOD_END"], "methodName": ["testGetPrincipalNamesMissingKeytab"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "createKeyTab ( TestKerberosUtil . testKeytab ,    new   String [  ]  {     \" test / testhost @ testRealm \"     }  )  ;", "try    {", "KerberosUtil . getPrincipalNames ( TestKerberosUtil . testKeytab ,    null )  ;", "Assert . fail (  \" Exception   should   have   been   thrown \"  )  ;", "}    catch    ( Exception   e )     {", "}", "}", "METHOD_END"], "methodName": ["testGetPrincipalNamesMissingPattern"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "String   service    =     \" TestKerberosUtil \"  ;", "String   localHostname    =    KerberosUtil . getLocalHostName (  )  ;", "String   testHost    =     \" FooBar \"  ;", "Assert . assertEquals (  \" When   no   hostname   is   sent \"  ,     (  ( service    +     \"  /  \"  )     +     ( localHostname . toLowerCase (  )  )  )  ,    KerberosUtil . getServicePrincipal ( service ,    null )  )  ;", "Assert . assertEquals (  \" When   empty   hostname   is   sent \"  ,     (  ( service    +     \"  /  \"  )     +     ( localHostname . toLowerCase (  )  )  )  ,    KerberosUtil . getServicePrincipal ( service ,     \"  \"  )  )  ;", "Assert . assertEquals (  \" When    0  .  0  .  0  .  0    hostname   is   sent \"  ,     (  ( service    +     \"  /  \"  )     +     ( localHostname . toLowerCase (  )  )  )  ,    KerberosUtil . getServicePrincipal ( service ,     \"  0  .  0  .  0  .  0  \"  )  )  ;", "Assert . assertEquals (  \" When   uppercase   hostname   is   sent \"  ,     (  ( service    +     \"  /  \"  )     +     ( testHost . toLowerCase (  )  )  )  ,    KerberosUtil . getServicePrincipal ( service ,    testHost )  )  ;", "Assert . assertEquals (  \" When   lowercase   hostname   is   sent \"  ,     (  ( service    +     \"  /  \"  )     +     ( testHost . toLowerCase (  )  )  )  ,    KerberosUtil . getServicePrincipal ( service ,    testHost . toLowerCase (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testGetServerPrincipal"], "fileName": "org.apache.hadoop.security.authentication.util.TestKerberosUtil"}, {"methodBody": ["METHOD_START", "{", "long   rolloverFrequency    =     1  5     *     1  0  0  0  ;", "long   seed    =    System . currentTimeMillis (  )  ;", "Random   rand    =    new   Random ( seed )  ;", "byte [  ]    secret 1     =    Long . toString ( rand . nextLong (  )  )  . getBytes (  )  ;", "byte [  ]    secret 2     =    Long . toString ( rand . nextLong (  )  )  . getBytes (  )  ;", "byte [  ]    secret 3     =    Long . toString ( rand . nextLong (  )  )  . getBytes (  )  ;", "secretProvider    =    new    ( seed )  ;", "try    {", "secretProvider . init ( null ,    rolloverFrequency )  ;", "byte [  ]    currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "byte [  ]  [  ]    allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 1  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 1  ,    allSecrets [  0  ]  )  ;", "Assert . assertNull ( allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 2  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 2  ,    allSecrets [  0  ]  )  ;", "Assert . assertArrayEquals ( secret 1  ,    allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 3  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 3  ,    allSecrets [  0  ]  )  ;", "Assert . assertArrayEquals ( secret 2  ,    allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "}    finally    {", "secretProvider . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetAndRollSecrets"], "fileName": "org.apache.hadoop.security.authentication.util.TestRandomSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "long   rolloverFrequency    =     1  5     *     1  0  0  0  ;", "byte [  ]    secret 1     =     \" doctor \"  . getBytes (  )  ;", "byte [  ]    secret 2     =     \" who \"  . getBytes (  )  ;", "byte [  ]    secret 3     =     \" tardis \"  . getBytes (  )  ;", ". TRolloverSignerSecretProvider   secretProvider    =    new    . TRolloverSignerSecretProvider ( new   byte [  ]  [  ]  {    secret 1  ,    secret 2  ,    secret 3     }  )  ;", "try    {", "secretProvider . init ( null ,    rolloverFrequency )  ;", "byte [  ]    currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "byte [  ]  [  ]    allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 1  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 1  ,    allSecrets [  0  ]  )  ;", "Assert . assertNull ( allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 2  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 2  ,    allSecrets [  0  ]  )  ;", "Assert . assertArrayEquals ( secret 1  ,    allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "currentSecret    =    secretProvider . getCurrentSecret (  )  ;", "allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertArrayEquals ( secret 3  ,    currentSecret )  ;", "Assert . assertEquals (  2  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secret 3  ,    allSecrets [  0  ]  )  ;", "Assert . assertArrayEquals ( secret 2  ,    allSecrets [  1  ]  )  ;", "Thread . sleep (  ( rolloverFrequency    +     2  0  0  0  )  )  ;", "}    finally    {", "secretProvider . destroy (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGetAndRollSecrets"], "fileName": "org.apache.hadoop.security.authentication.util.TestRolloverSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "try    {", "signer . verifyAndExtract (  \" test \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( SignerException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testInvalidSignedText"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "TestSigner . TestSignerSecretProvider   secretProvider    =    new   TestSigner . TestSignerSecretProvider (  )  ;", "Signer   signer    =    new   Signer ( secretProvider )  ;", "secretProvider . setCurrentSecret (  \" secretB \"  )  ;", "String   t 1     =     \" test \"  ;", "String   s 1     =    signer . sign ( t 1  )  ;", "String   e 1     =    signer . verifyAndExtract ( s 1  )  ;", "Assert . assertEquals ( t 1  ,    e 1  )  ;", "secretProvider . setPreviousSecret (  \" secretA \"  )  ;", "String   t 2     =     \" test \"  ;", "String   s 2     =    signer . sign ( t 2  )  ;", "String   e 2     =    signer . verifyAndExtract ( s 2  )  ;", "Assert . assertEquals ( t 2  ,    e 2  )  ;", "Assert . assertEquals ( s 1  ,    s 2  )  ;", "secretProvider . setCurrentSecret (  \" secretC \"  )  ;", "secretProvider . setPreviousSecret (  \" secretB \"  )  ;", "String   t 3     =     \" test \"  ;", "String   s 3     =    signer . sign ( t 3  )  ;", "String   e 3     =    signer . verifyAndExtract ( s 3  )  ;", "Assert . assertEquals ( t 3  ,    e 3  )  ;", "Assert . assertNotEquals ( s 1  ,    s 3  )  ;", "String   e 1 b    =    signer . verifyAndExtract ( s 1  )  ;", "Assert . assertEquals ( t 1  ,    e 1 b )  ;", "secretProvider . setCurrentSecret (  \" secretD \"  )  ;", "secretProvider . setPreviousSecret (  \" secretC \"  )  ;", "try    {", "signer . verifyAndExtract ( s 1  )  ;", "Assert . fail (  )  ;", "}    catch    ( SignerException   ex )     {", "}", "}", "METHOD_END"], "methodName": ["testMultipleSecrets"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "try    {", "signer . sign ( null )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "try    {", "signer . sign (  \"  \"  )  ;", "Assert . fail (  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNullAndEmptyString"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   s 1     =    signer . sign (  \" ok \"  )  ;", "String   s 2     =    signer . sign (  \" ok \"  )  ;", "String   s 3     =    signer . sign (  \" wrong \"  )  ;", "Assert . assertEquals ( s 1  ,    s 2  )  ;", "Assert . assertNotEquals ( s 1  ,    s 3  )  ;", "}", "METHOD_END"], "methodName": ["testSignature"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   t    =     \" test \"  ;", "String   s    =    signer . sign ( t )  ;", "s    +  =     \" x \"  ;", "try    {", "signer . verifyAndExtract ( s )  ;", "Assert . fail (  )  ;", "}    catch    ( SignerException   ex )     {", "}    catch    ( Throwable   ex )     {", "Assert . fail (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTampering"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "Signer   signer    =    new   Signer ( new   StringSignerSecretProvider (  \" secret \"  )  )  ;", "String   t    =     \" test \"  ;", "String   s    =    signer . sign ( t )  ;", "String   e    =    signer . verifyAndExtract ( s )  ;", "Assert . assertEquals ( t ,    e )  ;", "}", "METHOD_END"], "methodName": ["testVerify"], "fileName": "org.apache.hadoop.security.authentication.util.TestSigner"}, {"methodBody": ["METHOD_START", "{", "String   secretStr    =     \" secret \"  ;", "secretProvider    =    new    ( secretStr )  ;", "secretProvider . init ( null ,     (  -  1  )  )  ;", "byte [  ]    secretBytes    =    secretStr . getBytes (  )  ;", "Assert . assertArrayEquals ( secretBytes ,    secretProvider . getCurrentSecret (  )  )  ;", "byte [  ]  [  ]    allSecrets    =    secretProvider . getAllSecrets (  )  ;", "Assert . assertEquals (  1  ,    allSecrets . length )  ;", "Assert . assertArrayEquals ( secretBytes ,    allSecrets [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testGetSecrets"], "fileName": "org.apache.hadoop.security.authentication.util.TestStringSignerSecretProvider"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( PlatformName . PLATFORM _ NAME )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.util.PlatformName"}]