[{"methodBody": ["METHOD_START", "{", "return   new   ApplicationMaster . NMCallbackHandler ( this )  ;", "}", "METHOD_END"], "methodName": ["createNMCallbackHandler"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "ApplicationMaster . LOG . info (  \" Dump   debug   output \"  )  ;", "Map < String ,    String >    envs    =    System . getenv (  )  ;", "for    ( Map . Entry < String ,    String >    env    :    envs . entrySet (  )  )     {", "ApplicationMaster . LOG . info (  (  (  (  \" System   env :    key =  \"     +     ( env . getKey (  )  )  )     +     \"  ,    val =  \"  )     +     ( env . getValue (  )  )  )  )  ;", "System . out . println (  (  (  (  \" System   env :    key =  \"     +     ( env . getKey (  )  )  )     +     \"  ,    val =  \"  )     +     ( env . getValue (  )  )  )  )  ;", "}", "BufferedReader   buf    =    null ;", "try    {", "String   lines    =     ( Shell . WINDOWS )     ?    Shell . execCommand (  \" cmd \"  ,     \"  / c \"  ,     \" dir \"  )     :    Shell . execCommand (  \" ls \"  ,     \"  - al \"  )  ;", "buf    =    new   BufferedReader ( new   StringReader ( lines )  )  ;", "String   line    =     \"  \"  ;", "while    (  ( line    =    buf . readLine (  )  )     !  =    null )     {", "ApplicationMaster . LOG . info (  (  \" System   CWD   content :     \"     +    line )  )  ;", "System . out . println (  (  \" System   CWD   content :     \"     +    line )  )  ;", "}", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "IOUtils . cleanup ( ApplicationMaster . LOG ,    buf )  ;", "}", "}", "METHOD_END"], "methodName": ["dumpOutDebugInfo"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( filePath )  . exists (  )  ;", "}", "METHOD_END"], "methodName": ["fileExist"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "while    (  (  !  ( done )  )     &  &     (  ( numCompletedContainers . get (  )  )     !  =     ( numTotalContainers )  )  )     {", "try    {", "Thread . sleep (  2  0  0  )  ;", "}    catch    ( InterruptedException   ex )     {", "}", "}", "for    ( Thread   launchThread    :    launchThreads )     {", "try    {", "launchThread . join (  1  0  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", ". LOG . info (  (  \" Exception   thrown   in   thread   join :     \"     +     ( e . getMessage (  )  )  )  )  ;", "e . printStackTrace (  )  ;", "}", "}", ". LOG . info (  \" Application   completed .    Stopping   running   containers \"  )  ;", "nmClientAsync . stop (  )  ;", ". LOG . info (  \" Application   completed .    Signalling   finish   to   RM \"  )  ;", "FinalApplicationStatus   appStatus ;", "String   appMessage    =    null ;", "boolean   success    =    true ;", "if    (  (  ( numFailedContainers . get (  )  )     =  =     0  )     &  &     (  ( numCompletedContainers . get (  )  )     =  =     ( numTotalContainers )  )  )     {", "appStatus    =    FinalApplicationStatus . SUCCEEDED ;", "} else    {", "appStatus    =    FinalApplicationStatus . FAILED ;", "appMessage    =     (  (  (  (  (  (  (  \" Diagnostics .  \"     +     \"  ,    total =  \"  )     +     ( numTotalContainers )  )     +     \"  ,    completed =  \"  )     +     ( numCompletedContainers . get (  )  )  )     +     \"  ,    allocated =  \"  )     +     ( numAllocatedContainers . get (  )  )  )     +     \"  ,    failed =  \"  )     +     ( numFailedContainers . get (  )  )  ;", "success    =    false ;", "}", "try    {", "amRMClient . unregister ( appStatus ,    appMessage ,    null )  ;", "}    catch    ( YarnException   ex )     {", ". LOG . error (  \" Failed   to   unregister   application \"  ,    ex )  ;", "}    catch    ( IOException   e )     {", ". LOG . error (  \" Failed   to   unregister   application \"  ,    e )  ;", "}", "amRMClient . stop (  )  ;", "return   success ;", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "Options   opts    =    new   Options (  )  ;", "opts . addOption (  \" app _ attempt _ id \"  ,    true ,     \" App   Attempt   ID .    Not   to   be   used   unless   for   testing   purposes \"  )  ;", "opts . addOption (  \" shell _ env \"  ,    true ,     \" Environment   for   shell   script .    Specified   as   env _ key = env _ val   pairs \"  )  ;", "opts . addOption (  \" container _ memory \"  ,    true ,     \" Amount   of   memory   in   MB   to   be   requested   to   run   the   shell   command \"  )  ;", "opts . addOption (  \" container _ vcores \"  ,    true ,     \" Amount   of   virtual   cores   to   be   requested   to   run   the   shell   command \"  )  ;", "opts . addOption (  \" num _ containers \"  ,    true ,     \" No .    of   containers   on   which   the   shell   command   needs   to   be   executed \"  )  ;", "opts . addOption (  \" priority \"  ,    true ,     \" Application   Priority .    Default    0  \"  )  ;", "opts . addOption (  \" debug \"  ,    false ,     \" Dump   out   debug   information \"  )  ;", "opts . addOption (  \" help \"  ,    false ,     \" Print   usage \"  )  ;", "CommandLine   cliParser    =    new   GnuParser (  )  . parse ( opts ,    args )  ;", "if    (  ( args . length )     =  =     0  )     {", "printUsage ( opts )  ;", "throw   new   IllegalArgumentException (  \" No   args   specified   for   application   master   to   initialize \"  )  ;", "}", "if    ( fileExist (  . log 4 jPath )  )     {", "try    {", "Log 4 jPropertyHelper . updateLog 4 jConfiguration (  . class ,     . log 4 jPath )  ;", "}    catch    ( Exception   e )     {", ". LOG . warn (  (  \" Can   not   set   up   custom   log 4 j   properties .     \"     +    e )  )  ;", "}", "}", "if    ( cliParser . hasOption (  \" help \"  )  )     {", "printUsage ( opts )  ;", "return   false ;", "}", "if    ( cliParser . hasOption (  \" debug \"  )  )     {", "dumpOutDebugInfo (  )  ;", "}", "Map < String ,    String >    envs    =    System . getenv (  )  ;", "if    (  !  ( envs . containsKey ( CONTAINER _ ID . name (  )  )  )  )     {", "if    ( cliParser . hasOption (  \" app _ attempt _ id \"  )  )     {", "String   appIdStr    =    cliParser . getOptionValue (  \" app _ attempt _ id \"  ,     \"  \"  )  ;", "appAttemptID    =    ConverterUtils . toApplicationAttemptId ( appIdStr )  ;", "} else    {", "throw   new   IllegalArgumentException (  \" Application   Attempt   Id   not   set   in   the   environment \"  )  ;", "}", "} else    {", "ContainerId   containerId    =    ConverterUtils . toContainerId ( envs . get ( CONTAINER _ ID . name (  )  )  )  ;", "appAttemptID    =    containerId . getApplicationAttemptId (  )  ;", "}", "if    (  !  ( envs . containsKey ( APP _ SUBMIT _ TIME _ ENV )  )  )     {", "throw   new   RuntimeException (  (  ( ApplicationConstants . APP _ SUBMIT _ TIME _ ENV )     +     \"    not   set   in   the   environment \"  )  )  ;", "}", "if    (  !  ( envs . containsKey ( NM _ HOST . name (  )  )  )  )     {", "throw   new   RuntimeException (  (  ( NM _ HOST . name (  )  )     +     \"    not   set   in   the   environment \"  )  )  ;", "}", "if    (  !  ( envs . containsKey ( NM _ HTTP _ PORT . name (  )  )  )  )     {", "throw   new   RuntimeException (  (  ( Environment . NM _ HTTP _ PORT )     +     \"    not   set   in   the   environment \"  )  )  ;", "}", "if    (  !  ( envs . containsKey ( NM _ PORT . name (  )  )  )  )     {", "throw   new   RuntimeException (  (  ( NM _ PORT . name (  )  )     +     \"    not   set   in   the   environment \"  )  )  ;", "}", ". LOG . info (  (  (  (  (  (  (  \" Application   master   for   app \"     +     \"  ,    appId =  \"  )     +     ( appAttemptID . getApplicationId (  )  . getId (  )  )  )     +     \"  ,    clustertimestamp =  \"  )     +     ( appAttemptID . getApplicationId (  )  . getClusterTimestamp (  )  )  )     +     \"  ,    attemptId =  \"  )     +     ( appAttemptID . getAttemptId (  )  )  )  )  ;", "if    (  (  !  ( fileExist (  . shellCommandPath )  )  )     &  &     ( envs . get ( DSConstants . DISTRIBUTEDSHELLSCRIPTLOCATION )  . isEmpty (  )  )  )     {", "throw   new   IllegalArgumentException (  \" No   shell   command   or   shell   script   specified   to   be   executed   by   application   master \"  )  ;", "}", "if    ( fileExist (  . shellCommandPath )  )     {", "shellCommand    =    readContent (  . shellCommandPath )  ;", "}", "if    ( fileExist (  . shellArgsPath )  )     {", "shellArgs    =    readContent (  . shellArgsPath )  ;", "}", "if    ( cliParser . hasOption (  \" shell _ env \"  )  )     {", "String [  ]    shellEnvs    =    cliParser . getOptionValues (  \" shell _ env \"  )  ;", "for    ( String   env    :    shellEnvs )     {", "env    =    env . trim (  )  ;", "int   index    =    env . indexOf (  '  =  '  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "shellEnv . put ( env ,     \"  \"  )  ;", "continue ;", "}", "String   key    =    env . substring (  0  ,    index )  ;", "String   val    =     \"  \"  ;", "if    ( index    <     (  ( env . length (  )  )     -     1  )  )     {", "val    =    env . substring (  ( index    +     1  )  )  ;", "}", "shellEnv . put ( key ,    val )  ;", "}", "}", "if    ( envs . containsKey ( DSConstants . DISTRIBUTEDSHELLSCRIPTLOCATION )  )     {", "scriptPath    =    envs . get ( DSConstants . DISTRIBUTEDSHELLSCRIPTLOCATION )  ;", "if    ( envs . containsKey ( DSConstants . DISTRIBUTEDSHELLSCRIPTTIMESTAMP )  )     {", "shellScriptPathTimestamp    =    Long . valueOf ( envs . get ( DSConstants . DISTRIBUTEDSHELLSCRIPTTIMESTAMP )  )  ;", "}", "if    ( envs . containsKey ( DSConstants . DISTRIBUTEDSHELLSCRIPTLEN )  )     {", "shellScriptPathLen    =    Long . valueOf ( envs . get ( DSConstants . DISTRIBUTEDSHELLSCRIPTLEN )  )  ;", "}", "if    (  (  !  ( scriptPath . isEmpty (  )  )  )     &  &     (  (  ( shellScriptPathTimestamp )     <  =     0  )     |  |     (  ( shellScriptPathLen )     <  =     0  )  )  )     {", ". LOG . error (  (  (  (  (  (  (  \" Illegal   values   in   env   for   shell   script   path \"     +     \"  ,    path =  \"  )     +     ( scriptPath )  )     +     \"  ,    len =  \"  )     +     ( shellScriptPathLen )  )     +     \"  ,    timestamp =  \"  )     +     ( shellScriptPathTimestamp )  )  )  ;", "throw   new   IllegalArgumentException (  \" Illegal   values   in   env   for   shell   script   path \"  )  ;", "}", "}", "containerMemory    =    Integer . parseInt ( cliParser . getOptionValue (  \" container _ memory \"  ,     \"  1  0  \"  )  )  ;", "containerVirtualCores    =    Integer . parseInt ( cliParser . getOptionValue (  \" container _ vcores \"  ,     \"  1  \"  )  )  ;", "numTotalContainers    =    Integer . parseInt ( cliParser . getOptionValue (  \" num _ containers \"  ,     \"  1  \"  )  )  ;", "if    (  ( numTotalContainers )     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" Cannot   run   distributed   shell   with   no   containers \"  )  ;", "}", "requestPriority    =    Integer . parseInt ( cliParser . getOptionValue (  \" priority \"  ,     \"  0  \"  )  )  ;", "timelineClient    =    TimelineClient . createTimelineClient (  )  ;", "timelineClient . init ( conf )  ;", "timelineClient . start (  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    false ;", "try    {", "appMaster    =    new    (  )  ;", ". LOG . info (  \" Initializing    \"  )  ;", "boolean   doRun    =    appMaster . init ( args )  ;", "if    (  ! doRun )     {", "System . exit (  0  )  ;", "}", "appMaster . run (  )  ;", "result    =    appMaster . finish (  )  ;", "}    catch    ( Throwable   t )     {", ". LOG . fatal (  \" Error   running    \"  ,    t )  ;", "LogManager . shutdown (  )  ;", "ExitUtil . terminate (  1  ,    t )  ;", "}", "if    ( result )     {", ". LOG . info (  \" Application   Master   completed   successfully .    exiting \"  )  ;", "System . exit (  0  )  ;", "} else    {", ". LOG . info (  \" Application   Master   failed .    exiting \"  )  ;", "System . exit (  2  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "new   HelpFormatter (  )  . printHelp (  \" ApplicationMaster \"  ,    opts )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "TimelineEntity   entity    =    new   TimelineEntity (  )  ;", "entity . setEntityId ( appAttemptId )  ;", "entity . setEntityType (  . DSEntity . DS _ APP _ ATTEMPT . toString (  )  )  ;", "entity . addPrimaryFilter (  \" user \"  ,    UserGroupInformation . getCurrentUser (  )  . getShortUserName (  )  )  ;", "TimelineEvent   event    =    new   TimelineEvent (  )  ;", "event . setEventType ( appEvent . toString (  )  )  ;", "event . setTimestamp ( System . currentTimeMillis (  )  )  ;", "entity . addEvent ( event )  ;", "timelineClient . putEntities ( entity )  ;", "}", "METHOD_END"], "methodName": ["publishApplicationAttemptEvent"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "TimelineEntity   entity    =    new   TimelineEntity (  )  ;", "entity . setEntityId ( container . getContainerId (  )  . toString (  )  )  ;", "entity . setEntityType (  . DSEntity . DS _ CONTAINER . toString (  )  )  ;", "entity . addPrimaryFilter (  \" user \"  ,    UserGroupInformation . getCurrentUser (  )  . getShortUserName (  )  )  ;", "TimelineEvent   event    =    new   TimelineEvent (  )  ;", "event . setTimestamp ( System . currentTimeMillis (  )  )  ;", "event . setEventType (  . DSEvent . DS _ CONTAINER _ END . toString (  )  )  ;", "event . addEventInfo (  \" State \"  ,    container . getState (  )  . name (  )  )  ;", "event . addEventInfo (  \" Exit   Status \"  ,    container . getExitStatus (  )  )  ;", "entity . addEvent ( event )  ;", "timelineClient . putEntities ( entity )  ;", "}", "METHOD_END"], "methodName": ["publishContainerEndEvent"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "TimelineEntity   entity    =    new   TimelineEntity (  )  ;", "entity . setEntityId ( container . getId (  )  . toString (  )  )  ;", "entity . setEntityType (  . DSEntity . DS _ CONTAINER . toString (  )  )  ;", "entity . addPrimaryFilter (  \" user \"  ,    UserGroupInformation . getCurrentUser (  )  . getShortUserName (  )  )  ;", "TimelineEvent   event    =    new   TimelineEvent (  )  ;", "event . setTimestamp ( System . currentTimeMillis (  )  )  ;", "event . setEventType (  . DSEvent . DS _ CONTAINER _ START . toString (  )  )  ;", "event . addEventInfo (  \" Node \"  ,    container . getNodeId (  )  . toString (  )  )  ;", "event . addEventInfo (  \" Resources \"  ,    container . getResource (  )  . toString (  )  )  ;", "entity . addEvent ( event )  ;", "timelineClient . putEntities ( entity )  ;", "}", "METHOD_END"], "methodName": ["publishContainerStartEvent"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "DataInputStream   ds    =    null ;", "try    {", "ds    =    new   DataInputStream ( new   FileInputStream ( filePath )  )  ;", "return   ds . readUTF (  )  ;", "}    finally    {", "IOUtils . closeQuietly ( ds )  ;", "}", "}", "METHOD_END"], "methodName": ["readContent"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "appSubmitterUgi . doAs ( new   PrivilegedExceptionAction < Void >  (  )     {", "@ Override", "public   Void   run (  )    throws   IOException    {", "FileSystem   fs    =    renamedScriptPath . getFileSystem ( conf )  ;", "fs . rename ( new   Path ( scriptPath )  ,    renamedScriptPath )  ;", "return   null ;", "}", "}  )  ;", ". LOG . info (  (  (  (  \" User    \"     +     ( appSubmitterUgi . getUserName (  )  )  )     +     \"    added   suffix (  . sh /  . bat )    to   script   file   as    \"  )     +    renamedScriptPath )  )  ;", "}", "METHOD_END"], "methodName": ["renameScriptFile"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "ApplicationMaster . LOG . info (  \" Starting   ApplicationMaster \"  )  ;", "try    {", "ApplicationMaster . publishApplicationAttemptEvent ( timelineClient ,    appAttemptID . toString (  )  ,    ApplicationMaster . DSEvent . DS _ APP _ ATTEMPT _ START )  ;", "}    catch    ( Exception   e )     {", "ApplicationMaster . LOG . error (  (  \" App   Attempt   start   event   coud   not   be   pulished   for    \"     +     ( appAttemptID . toString (  )  )  )  ,    e )  ;", "}", "Credentials   credentials    =    UserGroupInformation . getCurrentUser (  )  . getCredentials (  )  ;", "DataOutputBuffer   dob    =    new   DataOutputBuffer (  )  ;", "credentials . writeTokenStorageToStream ( dob )  ;", "Iterator < Token <  ?  >  >    iter    =    credentials . getAllTokens (  )  . iterator (  )  ;", "ApplicationMaster . LOG . info (  \" Executing   with   tokens :  \"  )  ;", "while    ( iter . hasNext (  )  )     {", "Token <  ?  >    token    =    iter . next (  )  ;", "ApplicationMaster . LOG . info ( token )  ;", "if    ( token . getKind (  )  . equals ( KIND _ NAME )  )     {", "iter . remove (  )  ;", "}", "}", "allTokens    =    ByteBuffer . wrap ( dob . getData (  )  ,     0  ,    dob . getLength (  )  )  ;", "String   appSubmitterUserName    =    System . getenv ( USER . name (  )  )  ;", "appSubmitterUgi    =    UserGroupInformation . createRemoteUser ( appSubmitterUserName )  ;", "appSubmitterUgi . addCredentials ( credentials )  ;", "AMRMClientAsync . CallbackHandler   allocListener    =    new   ApplicationMaster . RMCallbackHandler (  )  ;", "amRMClient    =    AMRMClientAsync . createAMRMClientAsync (  1  0  0  0  ,    allocListener )  ;", "amRMClient . init ( conf )  ;", "amRMClient . start (  )  ;", "containerListener    =    createNMCallbackHandler (  )  ;", "nmClientAsync    =    new   NMClientAsyncImpl ( containerListener )  ;", "nmClientAsync . init ( conf )  ;", "nmClientAsync . start (  )  ;", "appMasterHostname    =    NetUtils . getHostname (  )  ;", "RegisterApplicationMasterResponse   response    =    amRMClient . registerApplicationMaster ( appMasterHostname ,    appMasterRpcPort ,    appMasterTrackingUrl )  ;", "int   maxMem    =    response . getMaximumResourceCapability (  )  . getMemory (  )  ;", "ApplicationMaster . LOG . info (  (  \" Max   mem   capabililty   of   resources   in   this   cluster    \"     +    maxMem )  )  ;", "int   maxVCores    =    response . getMaximumResourceCapability (  )  . getVirtualCores (  )  ;", "ApplicationMaster . LOG . info (  (  \" Max   vcores   capabililty   of   resources   in   this   cluster    \"     +    maxVCores )  )  ;", "if    (  ( containerMemory )     >    maxMem )     {", "ApplicationMaster . LOG . info (  (  (  (  (  \" Container   memory   specified   above   max   threshold   of   cluster .  \"     +     (  \"    Using   max   value .  \"     +     \"  ,    specified =  \"  )  )     +     ( containerMemory )  )     +     \"  ,    max =  \"  )     +    maxMem )  )  ;", "containerMemory    =    maxMem ;", "}", "if    (  ( containerVirtualCores )     >    maxVCores )     {", "ApplicationMaster . LOG . info (  (  (  (  (  \" Container   virtual   cores   specified   above   max   threshold   of   cluster .  \"     +     (  \"    Using   max   value .  \"     +     \"  ,    specified =  \"  )  )     +     ( containerVirtualCores )  )     +     \"  ,    max =  \"  )     +    maxVCores )  )  ;", "containerVirtualCores    =    maxVCores ;", "}", "List < Container >    previousAMRunningContainers    =    response . getContainersFromPreviousAttempts (  )  ;", "ApplicationMaster . LOG . info (  (  (  (  ( appAttemptID )     +     \"    received    \"  )     +     ( previousAMRunningContainers . size (  )  )  )     +     \"    previous   attempts '    running   containers   on   AM   registration .  \"  )  )  ;", "numAllocatedContainers . addAndGet ( previousAMRunningContainers . size (  )  )  ;", "int   numTotalContainersToRequest    =     ( numTotalContainers )     -     ( previousAMRunningContainers . size (  )  )  ;", "for    ( int   i    =     0  ;    i    <    numTotalContainersToRequest ;     +  + i )     {", "ContainerRequest   containerAsk    =    setupContainerAskForRM (  )  ;", "amRMClient . addContainerRequest ( containerAsk )  ;", "}", "numRequestedContainers . set ( numTotalContainers )  ;", "try    {", "ApplicationMaster . publishApplicationAttemptEvent ( timelineClient ,    appAttemptID . toString (  )  ,    ApplicationMaster . DSEvent . DS _ APP _ ATTEMPT _ END )  ;", "}    catch    ( Exception   e )     {", "ApplicationMaster . LOG . error (  (  \" App   Attempt   start   event   coud   not   be   pulished   for    \"     +     ( appAttemptID . toString (  )  )  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "Priority   pri    =    Priority . newInstance ( requestPriority )  ;", "Resource   capability    =    Resource . newInstance ( containerMemory ,    containerVirtualCores )  ;", "ContainerRequest   request    =    new   ContainerRequest ( capability ,    null ,    null ,    pri )  ;", ". LOG . info (  (  \" Requested   container   ask :     \"     +     ( request . toString (  )  )  )  )  ;", "return   request ;", "}", "METHOD_END"], "methodName": ["setupContainerAskForRM"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"}, {"methodBody": ["METHOD_START", "{", "String   suffix    =     (  (  (  ( appName )     +     \"  /  \"  )     +    appId )     +     \"  /  \"  )     +    fileDstPath ;", "Path   dst    =    new   Path ( fs . getHomeDirectory (  )  ,    suffix )  ;", "if    ( fileSrcPath    =  =    null )     {", "FSDataOutputStream   ostream    =    null ;", "try    {", "ostream    =    FileSystem . create ( fs ,    dst ,    new   FsPermission (  (  ( short )     (  4  5  6  )  )  )  )  ;", "ostream . writeUTF ( resources )  ;", "}    finally    {", "IOUtils . closeQuietly ( ostream )  ;", "}", "} else    {", "fs . copyFromLocalFile ( new   Path ( fileSrcPath )  ,    dst )  ;", "}", "FileStatus   scFileStatus    =    fs . getFileStatus ( dst )  ;", "LocalResource   scRsrc    =    LocalResource . newInstance ( ConverterUtils . getYarnUrlFromURI ( dst . toUri (  )  )  ,    FILE ,    APPLICATION ,    scFileStatus . getLen (  )  ,    scFileStatus . getModifTime (  )  )  ;", "localResources . put ( fileDstPath ,    scRsrc )  ;", "}", "METHOD_END"], "methodName": ["addToLocalResources"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "yarnClient . killApplication ( appId )  ;", "}", "METHOD_END"], "methodName": ["forceKillApplication"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "CommandLine   cliParser    =    new   GnuParser (  )  . parse ( opts ,    args )  ;", "if    (  ( args . length )     =  =     0  )     {", "throw   new   IllegalArgumentException (  \" No   args   specified   for   client   to   initialize \"  )  ;", "}", "if    ( cliParser . hasOption (  \" log _ properties \"  )  )     {", "String   log 4 jPath    =    cliParser . getOptionValue (  \" log _ properties \"  )  ;", "try    {", "Log 4 jPropertyHelper . updateLog 4 jConfiguration ( Client . class ,    log 4 jPath )  ;", "}    catch    ( Exception   e )     {", "Client . LOG . warn (  (  \" Can   not   set   up   custom   log 4 j   properties .     \"     +    e )  )  ;", "}", "}", "if    ( cliParser . hasOption (  \" help \"  )  )     {", "printUsage (  )  ;", "return   false ;", "}", "if    ( cliParser . hasOption (  \" debug \"  )  )     {", "debugFlag    =    true ;", "}", "if    ( cliParser . hasOption (  \" keep _ containers _ across _  _ attempts \"  )  )     {", "Client . LOG . info (  \" keep _ containers _ across _  _ attempts \"  )  ;", "keepContainers    =    true ;", "}", "appName    =    cliParser . getOptionValue (  \" appname \"  ,     \" DistributedShell \"  )  ;", "amPriority    =    Integer . parseInt ( cliParser . getOptionValue (  \" priority \"  ,     \"  0  \"  )  )  ;", "amQueue    =    cliParser . getOptionValue (  \" queue \"  ,     \" default \"  )  ;", "amMemory    =    Integer . parseInt ( cliParser . getOptionValue (  \" master _ memory \"  ,     \"  1  0  \"  )  )  ;", "amVCores    =    Integer . parseInt ( cliParser . getOptionValue (  \" master _ vcores \"  ,     \"  1  \"  )  )  ;", "if    (  ( amMemory )     <     0  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   memory   specified   for      master ,    exiting .  \"     +     \"    Specified   memory =  \"  )     +     ( amMemory )  )  )  ;", "}", "if    (  ( amVCores )     <     0  )     {", "throw   new   IllegalArgumentException (  (  (  \" Invalid   virtual   cores   specified   for      master ,    exiting .  \"     +     \"    Specified   virtual   cores =  \"  )     +     ( amVCores )  )  )  ;", "}", "if    (  !  ( cliParser . hasOption (  \" jar \"  )  )  )     {", "throw   new   IllegalArgumentException (  \" No   jar   file   specified   for      master \"  )  ;", "}", "appMasterJar    =    cliParser . getOptionValue (  \" jar \"  )  ;", "if    (  (  !  ( cliParser . hasOption (  \" shell _ command \"  )  )  )     &  &     (  !  ( cliParser . hasOption (  \" shell _ script \"  )  )  )  )     {", "throw   new   IllegalArgumentException (  \" No   shell   command   or   shell   script   specified   to   be   executed   by      master \"  )  ;", "} else", "if    (  ( cliParser . hasOption (  \" shell _ command \"  )  )     &  &     ( cliParser . hasOption (  \" shell _ script \"  )  )  )     {", "throw   new   IllegalArgumentException (  (  \" Can   not   specify   shell _ command   option    \"     +     \" and   shell _ script   option   at   the   same   time \"  )  )  ;", "} else", "if    ( cliParser . hasOption (  \" shell _ command \"  )  )     {", "shellCommand    =    cliParser . getOptionValue (  \" shell _ command \"  )  ;", "} else    {", "shellScriptPath    =    cliParser . getOptionValue (  \" shell _ script \"  )  ;", "}", "if    ( cliParser . hasOption (  \" shell _ args \"  )  )     {", "shellArgs    =    cliParser . getOptionValues (  \" shell _ args \"  )  ;", "}", "if    ( cliParser . hasOption (  \" shell _ env \"  )  )     {", "String [  ]    envs    =    cliParser . getOptionValues (  \" shell _ env \"  )  ;", "for    ( String   env    :    envs )     {", "env    =    env . trim (  )  ;", "int   index    =    env . indexOf (  '  =  '  )  ;", "if    ( index    =  =     (  -  1  )  )     {", "shellEnv . put ( env ,     \"  \"  )  ;", "continue ;", "}", "String   key    =    env . substring (  0  ,    index )  ;", "String   val    =     \"  \"  ;", "if    ( index    <     (  ( env . length (  )  )     -     1  )  )     {", "val    =    env . substring (  ( index    +     1  )  )  ;", "}", "shellEnv . put ( key ,    val )  ;", "}", "}", "shellCmdPriority    =    Integer . parseInt ( cliParser . getOptionValue (  \" shell _ cmd _ priority \"  ,     \"  0  \"  )  )  ;", "containerMemory    =    Integer . parseInt ( cliParser . getOptionValue (  \" container _ memory \"  ,     \"  1  0  \"  )  )  ;", "containerVirtualCores    =    Integer . parseInt ( cliParser . getOptionValue (  \" container _ vcores \"  ,     \"  1  \"  )  )  ;", "numContainers    =    Integer . parseInt ( cliParser . getOptionValue (  \" num _ containers \"  ,     \"  1  \"  )  )  ;", "if    (  (  (  ( containerMemory )     <     0  )     |  |     (  ( containerVirtualCores )     <     0  )  )     |  |     (  ( numContainers )     <     1  )  )     {", "throw   new   IllegalArgumentException (  (  (  (  (  (  (  \" Invalid   no .    of   containers   or   container   memory / vcores   specified ,  \"     +     (  \"    exiting .  \"     +     \"    Specified   containerMemory =  \"  )  )     +     ( containerMemory )  )     +     \"  ,    containerVirtualCores =  \"  )     +     ( containerVirtualCores )  )     +     \"  ,    numContainer =  \"  )     +     ( numContainers )  )  )  ;", "}", "clientTimeout    =    Integer . parseInt ( cliParser . getOptionValue (  \" timeout \"  ,     \"  6  0  0  0  0  0  \"  )  )  ;", "log 4 jPropFile    =    cliParser . getOptionValue (  \" log _ properties \"  ,     \"  \"  )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    false ;", "try    {", "Client   client    =    new   Client (  )  ;", "Client . LOG . info (  \" Initializing   Client \"  )  ;", "try    {", "boolean   doRun    =    client . init ( args )  ;", "if    (  ! doRun )     {", "System . exit (  0  )  ;", "}", "}    catch    ( IllegalArgumentException   e )     {", "System . err . println ( e . getLocalizedMessage (  )  )  ;", "client . printUsage (  )  ;", "System . exit (  (  -  1  )  )  ;", "}", "result    =    client . run (  )  ;", "}    catch    ( Throwable   t )     {", "Client . LOG . fatal (  \" Error   running   CLient \"  ,    t )  ;", "System . exit (  1  )  ;", "}", "if    ( result )     {", "Client . LOG . info (  \" A   completed   successfully \"  )  ;", "System . exit (  0  )  ;", "}", "Client . LOG . error (  \" A   failed   to   complete   successfully \"  )  ;", "System . exit (  2  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "Client . LOG . debug (  \" Thread   sleep   in   monitoring   loop   interrupted \"  )  ;", "}", "ApplicationReport   report    =    yarnClient . getApplicationReport ( appId )  ;", "Client . LOG . info (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" Got      report   from   ASM   for \"     +     \"  ,    appId =  \"  )     +     ( appId . getId (  )  )  )     +     \"  ,    clientToAMToken =  \"  )     +     ( report . getClientToAMToken (  )  )  )     +     \"  ,    appDiagnostics =  \"  )     +     ( report . getDiagnostics (  )  )  )     +     \"  ,    appMasterHost =  \"  )     +     ( report . getHost (  )  )  )     +     \"  ,    appQueue =  \"  )     +     ( report . getQueue (  )  )  )     +     \"  ,    appMasterRpcPort =  \"  )     +     ( report . getRpcPort (  )  )  )     +     \"  ,    appStartTime =  \"  )     +     ( report . getStartTime (  )  )  )     +     \"  ,    yarnAppState =  \"  )     +     ( report . getYarnApplicationState (  )  . toString (  )  )  )     +     \"  ,    distributedFinalState =  \"  )     +     ( report . getFinalApplicationStatus (  )  . toString (  )  )  )     +     \"  ,    appTrackingUrl =  \"  )     +     ( report . getTrackingUrl (  )  )  )     +     \"  ,    appUser =  \"  )     +     ( report . getUser (  )  )  )  )  ;", "YarnApplicationState   state    =    report . getYarnApplicationState (  )  ;", "FinalApplicationStatus   dsStatus    =    report . getFinalApplicationStatus (  )  ;", "if    (  ( YarnApplicationState . FINISHED )     =  =    state )     {", "if    (  ( FinalApplicationStatus . SUCCEEDED )     =  =    dsStatus )     {", "Client . LOG . info (  \" Application   has   completed   successfully .    Breaking   monitoring   loop \"  )  ;", "return   true ;", "} else    {", "Client . LOG . info (  (  (  (  (  (  \" Application   did   finished   unsuccessfully .  \"     +     \"    YarnState =  \"  )     +     ( state . toString (  )  )  )     +     \"  ,    DSFinalStatus =  \"  )     +     ( dsStatus . toString (  )  )  )     +     \"  .    Breaking   monitoring   loop \"  )  )  ;", "return   false ;", "}", "} else", "if    (  (  ( YarnApplicationState . KILLED )     =  =    state )     |  |     (  ( YarnApplicationState . FAILED )     =  =    state )  )     {", "Client . LOG . info (  (  (  (  (  (  \" Application   did   not   finish .  \"     +     \"    YarnState =  \"  )     +     ( state . toString (  )  )  )     +     \"  ,    DSFinalStatus =  \"  )     +     ( dsStatus . toString (  )  )  )     +     \"  .    Breaking   monitoring   loop \"  )  )  ;", "return   false ;", "}", "if    (  ( System . currentTimeMillis (  )  )     >     (  ( clientStartTime )     +     ( clientTimeout )  )  )     {", "Client . LOG . info (  \" Reached   client   specified   timeout   for    .    Killing    \"  )  ;", "forceKillApplication ( appId )  ;", "return   false ;", "}", "}", "}", "METHOD_END"], "methodName": ["monitorApplication"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "new   HelpFormatter (  )  . printHelp (  \" Client \"  ,    opts )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "Client . LOG . info (  \" Running   Client \"  )  ;", "yarnClient . start (  )  ;", "YarnClusterMetrics   clusterMetrics    =    yarnClient . getYarnClusterMetrics (  )  ;", "Client . LOG . info (  (  (  \" Got   Cluster   metric   info   from   ASM \"     +     \"  ,    numNodeManagers =  \"  )     +     ( clusterMetrics . getNumNodeManagers (  )  )  )  )  ;", "List < NodeReport >    clusterNodeReports    =    yarnClient . getNodeReports ( RUNNING )  ;", "Client . LOG . info (  \" Got   Cluster   node   info   from   ASM \"  )  ;", "for    ( NodeReport   node    :    clusterNodeReports )     {", "Client . LOG . info (  (  (  (  (  (  (  (  (  \" Got   node   report   from   ASM   for \"     +     \"  ,    nodeId =  \"  )     +     ( node . getNodeId (  )  )  )     +     \"  ,    nodeAddress \"  )     +     ( node . getHttpAddress (  )  )  )     +     \"  ,    nodeRackName \"  )     +     ( node . getRackName (  )  )  )     +     \"  ,    nodeNumContainers \"  )     +     ( node . getNumContainers (  )  )  )  )  ;", "}", "QueueInfo   queueInfo    =    yarnClient . getQueueInfo ( this . amQueue )  ;", "Client . LOG . info (  (  (  (  (  (  (  (  (  (  (  \" Queue   info \"     +     \"  ,    queueName =  \"  )     +     ( queueInfo . getQueueName (  )  )  )     +     \"  ,    queueCurrentCapacity =  \"  )     +     ( queueInfo . getCurrentCapacity (  )  )  )     +     \"  ,    queueMaxCapacity =  \"  )     +     ( queueInfo . getMaximumCapacity (  )  )  )     +     \"  ,    queueApplicationCount =  \"  )     +     ( queueInfo . getA (  )  . size (  )  )  )     +     \"  ,    queueChildQueueCount =  \"  )     +     ( queueInfo . getChildQueues (  )  . size (  )  )  )  )  ;", "List < QueueUserACLInfo >    listAclInfo    =    yarnClient . getQueueAclsInfo (  )  ;", "for    ( QueueUserACLInfo   aclInfo    :    listAclInfo )     {", "for    ( QueueACL   userAcl    :    aclInfo . getUserAcls (  )  )     {", "Client . LOG . info (  (  (  (  (  \" User   ACL   Info   for   Queue \"     +     \"  ,    queueName =  \"  )     +     ( aclInfo . getQueueName (  )  )  )     +     \"  ,    userAcl =  \"  )     +     ( userAcl . name (  )  )  )  )  ;", "}", "}", "YarnClientApplication   app    =    yarnClient . createApplication (  )  ;", "GetNewApplicationResponse   appResponse    =    app . getNewApplicationResponse (  )  ;", "int   maxMem    =    appResponse . getMaximumResourceCapability (  )  . getMemory (  )  ;", "Client . LOG . info (  (  \" Max   mem   capabililty   of   resources   in   this   cluster    \"     +    maxMem )  )  ;", "if    (  ( amMemory )     >    maxMem )     {", "Client . LOG . info (  (  (  (  (  \" AM   memory   specified   above   max   threshold   of   cluster .    Using   max   value .  \"     +     \"  ,    specified =  \"  )     +     ( amMemory )  )     +     \"  ,    max =  \"  )     +    maxMem )  )  ;", "amMemory    =    maxMem ;", "}", "int   maxVCores    =    appResponse . getMaximumResourceCapability (  )  . getVirtualCores (  )  ;", "Client . LOG . info (  (  \" Max   virtual   cores   capabililty   of   resources   in   this   cluster    \"     +    maxVCores )  )  ;", "if    (  ( amVCores )     >    maxVCores )     {", "Client . LOG . info (  (  (  (  (  \" AM   virtual   cores   specified   above   max   threshold   of   cluster .     \"     +     (  \" Using   max   value .  \"     +     \"  ,    specified =  \"  )  )     +     ( amVCores )  )     +     \"  ,    max =  \"  )     +    maxVCores )  )  ;", "amVCores    =    maxVCores ;", "}", "ApplicationSubmissionContext   appContext    =    app . getApplicationSubmissionContext (  )  ;", "ApplicationId   appId    =    appContext . getApplicationId (  )  ;", "appContext . setKeepContainersAcrossApplicationAttempts ( keepContainers )  ;", "appContext . setApplicationName ( appName )  ;", "Map < String ,    LocalResource >    localResources    =    new   HashMap < String ,    LocalResource >  (  )  ;", "Client . LOG . info (  \" Copy   App   Master   jar   from   local   filesystem   and   add   to   local   environment \"  )  ;", "FileSystem   fs    =    FileSystem . get ( conf )  ;", "addToLocalResources ( fs ,    appMasterJar ,    Client . appMasterJarPath ,    appId . toString (  )  ,    localResources ,    null )  ;", "if    (  !  ( log 4 jPropFile . isEmpty (  )  )  )     {", "addToLocalResources ( fs ,    log 4 jPropFile ,    Client . log 4 jPath ,    appId . toString (  )  ,    localResources ,    null )  ;", "}", "String   hdfsShellScriptLocation    =     \"  \"  ;", "long   hdfsShellScriptLen    =     0  ;", "long   hdfsShellScriptTimestamp    =     0  ;", "if    (  !  ( shellScriptPath . isEmpty (  )  )  )     {", "Path   shellSrc    =    new   Path ( shellScriptPath )  ;", "String   shellPathSuffix    =     (  (  (  ( appName )     +     \"  /  \"  )     +     ( appId . toString (  )  )  )     +     \"  /  \"  )     +     ( Client . SCRIPT _ PATH )  ;", "Path   shellDst    =    new   Path ( fs . getHomeDirectory (  )  ,    shellPathSuffix )  ;", "fs . copyFromLocalFile ( false ,    true ,    shellSrc ,    shellDst )  ;", "hdfsShellScriptLocation    =    shellDst . toUri (  )  . toString (  )  ;", "FileStatus   shellFileStatus    =    fs . getFileStatus ( shellDst )  ;", "hdfsShellScriptLen    =    shellFileStatus . getLen (  )  ;", "hdfsShellScriptTimestamp    =    shellFileStatus . getModificationTime (  )  ;", "}", "if    (  !  ( shellCommand . isEmpty (  )  )  )     {", "addToLocalResources ( fs ,    null ,    Client . shellCommandPath ,    appId . toString (  )  ,    localResources ,    shellCommand )  ;", "}", "if    (  ( shellArgs . length )     >     0  )     {", "addToLocalResources ( fs ,    null ,    Client . shellArgsPath ,    appId . toString (  )  ,    localResources ,    StringUtils . join ( shellArgs ,     \"     \"  )  )  ;", "}", "Client . LOG . info (  \" Set   the   environment   for   the   application   master \"  )  ;", "Map < String ,    String >    env    =    new   HashMap < String ,    String >  (  )  ;", "env . put ( DSConstants . DISTRIBUTEDSHELLSCRIPTLOCATION ,    hdfsShellScriptLocation )  ;", "env . put ( DSConstants . DISTRIBUTEDSHELLSCRIPTTIMESTAMP ,    Long . toString ( hdfsShellScriptTimestamp )  )  ;", "env . put ( DSConstants . DISTRIBUTEDSHELLSCRIPTLEN ,    Long . toString ( hdfsShellScriptLen )  )  ;", "StringBuilder   classPathEnv    =    new   StringBuilder ( CLASSPATH .  $  $  (  )  )  . append ( CLASS _ PATH _ SEPARATOR )  . append (  \"  .  /  *  \"  )  ;", "for    ( String   c    :    conf . getStrings ( YARN _ APPLICATION _ CLASSPATH ,    DEFAULT _ YARN _ CROSS _ PLATFORM _ APPLICATION _ CLASSPATH )  )     {", "classPathEnv . append ( CLASS _ PATH _ SEPARATOR )  ;", "classPathEnv . append ( c . trim (  )  )  ;", "}", "classPathEnv . append ( CLASS _ PATH _ SEPARATOR )  . append (  \"  .  / log 4 j . properties \"  )  ;", "if    ( conf . getBoolean ( IS _ MINI _ YARN _ CLUSTER ,    false )  )     {", "classPathEnv . append (  '  :  '  )  ;", "classPathEnv . append ( System . getProperty (  \" path \"  )  )  ;", "}", "env . put (  \" CLASSPATH \"  ,    classPathEnv . toString (  )  )  ;", "Vector < CharSequence >    vargs    =    new   Vector < CharSequence >  (  3  0  )  ;", "Client . LOG . info (  \" Setting   up   app   master   command \"  )  ;", "vargs . add (  (  ( JAVA _ HOME .  $  $  (  )  )     +     \"  / bin / java \"  )  )  ;", "vargs . add (  (  (  \"  - Xmx \"     +     ( amMemory )  )     +     \" m \"  )  )  ;", "vargs . add ( appMasterMainClass )  ;", "vargs . add (  (  \"  -  - container _ memory    \"     +     ( String . valueOf ( containerMemory )  )  )  )  ;", "vargs . add (  (  \"  -  - container _ vcores    \"     +     ( String . valueOf ( containerVirtualCores )  )  )  )  ;", "vargs . add (  (  \"  -  - num _ containers    \"     +     ( String . valueOf ( numContainers )  )  )  )  ;", "vargs . add (  (  \"  -  - priority    \"     +     ( String . valueOf ( shellCmdPriority )  )  )  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    shellEnv . entrySet (  )  )     {", "vargs . add (  (  (  (  \"  -  - shell _ env    \"     +     ( entry . getKey (  )  )  )     +     \"  =  \"  )     +     ( entry . getValue (  )  )  )  )  ;", "}", "if    ( debugFlag )     {", "vargs . add (  \"  -  - debug \"  )  ;", "}", "vargs . add (  (  (  \"  1  >  \"     +     ( ApplicationConstants . LOG _ DIR _ EXPANSION _ VAR )  )     +     \"  / AppMaster . stdout \"  )  )  ;", "vargs . add (  (  (  \"  2  >  \"     +     ( ApplicationConstants . LOG _ DIR _ EXPANSION _ VAR )  )     +     \"  / AppMaster . stderr \"  )  )  ;", "StringBuilder   command    =    new   StringBuilder (  )  ;", "for    ( CharSequence   str    :    vargs )     {", "command . append ( str )  . append (  \"     \"  )  ;", "}", "Client . LOG . info (  (  \" Completed   setting   up   app   master   command    \"     +     ( command . toString (  )  )  )  )  ;", "List < String >    commands    =    new   ArrayList < String >  (  )  ;", "commands . add ( command . toString (  )  )  ;", "ContainerLaunchContext   amContainer    =    ContainerLaunchContext . newInstance ( localResources ,    env ,    commands ,    null ,    null ,    null )  ;", "Resource   capability    =    Resource . newInstance ( amMemory ,    amVCores )  ;", "appContext . setResource ( capability )  ;", "if    ( UserGroupInformation . isSecurityEnabled (  )  )     {", "Credentials   credentials    =    new   Credentials (  )  ;", "String   tokenRenewer    =    conf . get ( RM _ PRINCIPAL )  ;", "if    (  ( tokenRenewer    =  =    null )     |  |     (  ( tokenRenewer . length (  )  )     =  =     0  )  )     {", "throw   new   IOException (  \" Can ' t   get   Master   Kerberos   principal   for   the   RM   to   use   as   renewer \"  )  ;", "}", "final   Token <  ?  >  [  ]    tokens    =    fs . addDelegationTokens ( tokenRenewer ,    credentials )  ;", "if    ( tokens    !  =    null )     {", "for    ( Token <  ?  >    token    :    tokens )     {", "Client . LOG . info (  (  (  (  \" Got   dt   for    \"     +     ( fs . getUri (  )  )  )     +     \"  ;     \"  )     +    token )  )  ;", "}", "}", "DataOutputBuffer   dob    =    new   DataOutputBuffer (  )  ;", "credentials . writeTokenStorageToStream ( dob )  ;", "ByteBuffer   fsTokens    =    ByteBuffer . wrap ( dob . getData (  )  ,     0  ,    dob . getLength (  )  )  ;", "amContainer . setTokens ( fsTokens )  ;", "}", "appContext . setAMContainerSpec ( amContainer )  ;", "Priority   pri    =    Priority . newInstance ( amPriority )  ;", "appContext . setPriority ( pri )  ;", "appContext . setQueue ( amQueue )  ;", "Client . LOG . info (  \" Submitting   application   to   ASM \"  )  ;", "yarnClient . submitApplication ( appContext )  ;", "return   monitorApplication ( appId )  ;", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Client"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    false ;", "try    {", "appMaster    =    new    (  )  ;", ". LOG . info (  \" Initializing   ApplicationMaster \"  )  ;", "boolean   doRun    =    appMaster . init ( args )  ;", "if    (  ! doRun )     {", "System . exit (  0  )  ;", "}", "appMaster . run (  )  ;", "result    =    appMaster . finish (  )  ;", "}    catch    ( Throwable   t )     {", ". LOG . fatal (  \" Error   running   ApplicationMaster \"  ,    t )  ;", "System . exit (  1  )  ;", "}", "if    ( result )     {", ". LOG . info (  \" Application   Master   completed   successfully .    exiting \"  )  ;", "System . exit (  0  )  ;", "} else    {", ". LOG . info (  \" Application   Master   failed .    exiting \"  )  ;", "System . exit (  2  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.ContainerLaunchFailAppMaster"}, {"methodBody": ["METHOD_START", "{", "Properties   customProperties    =    new   Properties (  )  ;", "FileInputStream   fs    =    null ;", "InputStream   is    =    null ;", "try    {", "fs    =    new   FileInputStream ( log 4 jPath )  ;", "is    =    targetClass . getResourceAsStream (  \"  / log 4 j . properties \"  )  ;", "customProperties . load ( fs )  ;", "Properties   originalProperties    =    new   Properties (  )  ;", "originalProperties . load ( is )  ;", "for    ( Map . Entry < Object ,    Object >    entry    :    customProperties . entrySet (  )  )     {", "originalProperties . set ( entry . getKey (  )  . toString (  )  ,    entry . getValue (  )  . toString (  )  )  ;", "}", "LogManager . resetConfiguration (  )  ;", "Configurator . configure ( originalProperties )  ;", "}    finally    {", "IOUtils . closeQuietly ( is )  ;", "IOUtils . closeQuietly ( fs )  ;", "}", "}", "METHOD_END"], "methodName": ["updateLog4jConfiguration"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.Log4jPropertyHelper"}, {"methodBody": ["METHOD_START", "{", "boolean   result    =    false ;", "try    {", "appMaster    =    new    (  )  ;", "boolean   doRun    =    appMaster . init ( args )  ;", "if    (  ! doRun )     {", "System . exit (  0  )  ;", "}", "appMaster . run (  )  ;", "if    (  ( appMaster . appAttemptID . getAttemptId (  )  )     =  =     1  )     {", "try    {", "Thread . sleep (  3  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "}", "System . exit (  1  0  0  )  ;", "}", "result    =    appMaster . finish (  )  ;", "}    catch    ( Throwable   t )     {", "System . exit (  1  )  ;", "}", "if    ( result )     {", ". LOG . info (  \" Application   Master   completed   successfully .    exiting \"  )  ;", "System . exit (  0  )  ;", "} else    {", ". LOG . info (  \" Application   Master   failed .    exiting \"  )  ;", "System . exit (  2  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDSFailedAppMaster"}, {"methodBody": ["METHOD_START", "{", "String   hostname    =    NetUtils . getHostname (  )  ;", "if    ( hostname . equals ( appHostname )  )     {", "return   true ;", "}", "Assert . assertTrue (  (  \" Unknown   format   for   hostname    \"     +    appHostname )  ,    appHostname . contains (  \"  /  \"  )  )  ;", "Assert . assertTrue (  (  \" Unknown   format   for   hostname    \"     +    hostname )  ,    hostname . contains (  \"  /  \"  )  )  ;", "String [  ]    appHostnameParts    =    appHostname . split (  \"  /  \"  )  ;", "String [  ]    hostnameParts    =    hostname . split (  \"  /  \"  )  ;", "return    ( compareFQDNs ( appHostnameParts [  0  ]  ,    hostnameParts [  0  ]  )  )     &  &     ( checkIPs ( hostnameParts [  0  ]  ,    hostnameParts [  1  ]  ,    appHostnameParts [  1  ]  )  )  ;", "}", "METHOD_END"], "methodName": ["checkHostname"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "if    ( localIP . equals ( appIP )  )     {", "return   true ;", "}", "boolean   appIPCheck    =    false ;", "boolean   localIPCheck    =    false ;", "InetAddress [  ]    addresses    =    InetAddress . getAllByName ( hostname )  ;", "for    ( InetAddress   ia    :    addresses )     {", "if    ( ia . getHostAddress (  )  . equals ( appIP )  )     {", "appIPCheck    =    true ;", "continue ;", "}", "if    ( ia . getHostAddress (  )  . equals ( localIP )  )     {", "localIPCheck    =    true ;", "}", "}", "return   appIPCheck    &  &    localIPCheck ;", "}", "METHOD_END"], "methodName": ["checkIPs"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "if    ( appHostname . equals ( hostname )  )     {", "return   true ;", "}", "String   appFQDN    =    InetAddress . getByName ( appHostname )  . getCanonicalHostName (  )  ;", "String   localFQDN    =    InetAddress . getByName ( hostname )  . getCanonicalHostName (  )  ;", "return   appFQDN . equals ( localFQDN )  ;", "}", "METHOD_END"], "methodName": ["compareFQDNs"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "TestDistributedShell . LOG . info (  \" Starting   up   YARN   cluster \"  )  ;", "conf . setInt ( RM _ SCHEDULER _ MINIMUM _ ALLOCATION _ MB ,     1  2  8  )  ;", "conf . setClass ( RM _ SCHEDULER ,    FifoScheduler . class ,    ResourceScheduler . class )  ;", "conf . set (  \" yarn . log . dir \"  ,     \" target \"  )  ;", "conf . setBoolean ( TIMELINE _ SERVICE _ ENABLED ,    true )  ;", "if    (  ( yarnCluster )     =  =    null )     {", "yarnCluster    =    new   MiniYARNCluster ( TestDistributedShell . class . getSimpleName (  )  ,     1  ,     1  ,     1  ,     1  ,    true )  ;", "yarnCluster . init ( conf )  ;", "yarnCluster . start (  )  ;", "NodeManager   nm    =    yarnCluster . getNodeManager (  0  )  ;", "TestDistributedShell . waitForNMToRegister ( nm )  ;", "URL   url    =    Thread . currentThread (  )  . getContextClassLoader (  )  . getResource (  \" yarn - site . xml \"  )  ;", "if    ( url    =  =    null )     {", "throw   new   RuntimeException (  \" Could   not   find    ' yarn - site . xml '    dummy   file   in   classpath \"  )  ;", "}", "Configuration   yarnClusterConfig    =    yarnCluster . getConfig (  )  ;", "yarnClusterConfig . set (  \" yarn . application . classpath \"  ,    new   File ( url . getPath (  )  )  . getParent (  )  )  ;", "ByteArrayOutputStream   bytesOut    =    new   ByteArrayOutputStream (  )  ;", "yarnClusterConfig . writeXml ( bytesOut )  ;", "bytesOut . close (  )  ;", "OutputStream   os    =    new   FileOutputStream ( new   File ( url . getPath (  )  )  )  ;", "os . write ( bytesOut . toByteArray (  )  )  ;", "os . close (  )  ;", "}", "FileContext   fsContext    =    FileContext . getLocalFSFileContext (  )  ;", "fsContext . delete ( new   Path ( conf . get (  \" yarn . timeline - service . leveldb - timeline - store . path \"  )  )  ,    true )  ;", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "TestDistributedShell . LOG . info (  (  \" setup   thread   sleep   interrupted .    message =  \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "if    (  ( yarnCluster )     !  =    null )     {", "try    {", "yarnCluster . stop (  )  ;", "}    finally    {", "yarnCluster    =    null ;", "}", "}", "FileContext   fsContext    =    FileContext . getLocalFSFileContext (  )  ;", "fsContext . delete ( new   fs . Path ( conf . get (  \" yarn . timeline - service . leveldb - timeline - store . path \"  )  )  ,    true )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "Client   client    =    new   Client ( ContainerLaunchFailAppMaster . class . getName (  )  ,    new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "Assert . assertFalse ( result )  ;", "}", "METHOD_END"], "methodName": ["testContainerLaunchFailureHandling"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  1  \"  ,     \"  -  - shell _ command \"  ,     \" sleep    8  \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - keep _ containers _ across _ application _ attempts \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "Client   client    =    new   Client ( TestDSFailedAppMaster . class . getName (  )  ,    new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "client . init ( args )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "Assert . assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["testDSRestartWithPreviousRunningContainers"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "final   Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "final   AtomicBoolean   result    =    new   AtomicBoolean ( false )  ;", "Thread   t    =    new   Thread (  )     {", "public   void   run (  )     {", "try    {", "result . set ( client . run (  )  )  ;", "}    catch    ( Exception   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "}  ;", "t . start (  )  ;", "YarnClient   yarnClient    =    YarnClient . createYarnClient (  )  ;", "yarnClient . init ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "yarnClient . start (  )  ;", "String   hostName    =    NetUtils . getHostname (  )  ;", "boolean   verified    =    false ;", "String   errorMessage    =     \"  \"  ;", "while    (  ! verified )     {", "List < ApplicationReport >    apps    =    yarnClient . getApplications (  )  ;", "if    (  ( apps . size (  )  )     =  =     0  )     {", "Thread . sleep (  1  0  )  ;", "continue ;", "}", "ApplicationReport   appReport    =    apps . get (  0  )  ;", "if    ( appReport . getHost (  )  . equals (  \" N / A \"  )  )     {", "Thread . sleep (  1  0  )  ;", "continue ;", "}", "errorMessage    =     (  (  (  (  (  \" Expected   host   name   to   start   with    '  \"     +    hostName )     +     \"  '  ,    was    '  \"  )     +     ( appReport . getHost (  )  )  )     +     \"  '  .    Expected   rpc   port   to   be    '  -  1  '  ,    was    '  \"  )     +     ( appReport . getRpcPort (  )  )  )     +     \"  '  .  \"  ;", "if    (  ( checkHostname ( appReport . getHost (  )  )  )     &  &     (  ( appReport . getRpcPort (  )  )     =  =     (  -  1  )  )  )     {", "verified    =    true ;", "}", "if    (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . FINISHED )  )     {", "break ;", "}", "}", "Assert . assertTrue ( errorMessage ,    verified )  ;", "t . join (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "Assert . assertTrue ( result . get (  )  )  ;", "TimelineEntities   entitiesAttempts    =    yarnCluster . getApplicationHistoryServer (  )  . getTimelineStore (  )  . getEntities ( ApplicationMaster . DSEntity . DS _ APP _ ATTEMPT . toString (  )  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "Assert . assertNotNull ( entitiesAttempts )  ;", "Assert . assertEquals (  1  ,    entitiesAttempts . getEntities (  )  . size (  )  )  ;", "Assert . assertEquals (  2  ,    entitiesAttempts . getEntities (  )  . get (  0  )  . getEvents (  )  . size (  )  )  ;", "Assert . assertEquals ( entitiesAttempts . getEntities (  )  . get (  0  )  . getEntityType (  )  . toString (  )  ,    ApplicationMaster . DSEntity . DS _ APP _ ATTEMPT . toString (  )  )  ;", "TimelineEntities   entities    =    yarnCluster . getApplicationHistoryServer (  )  . getTimelineStore (  )  . getEntities ( ApplicationMaster . DSEntity . DS _ CONTAINER . toString (  )  ,    null ,    null ,    null ,    null ,    null ,    null ,    null ,    null )  ;", "Assert . assertNotNull ( entities )  ;", "Assert . assertEquals (  2  ,    entities . getEntities (  )  . size (  )  )  ;", "Assert . assertEquals ( entities . getEntities (  )  . get (  0  )  . getEntityType (  )  . toString (  )  ,    ApplicationMaster . DSEntity . DS _ CONTAINER . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDSShell"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,     \"  \\  \" echo   output _ ignored ; echo   output _ expected \\  \"  \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "final   Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "List < String >    expectedContent    =    new   ArrayList < String >  (  )  ;", "expectedContent . add (  \" output _ expected \"  )  ;", "verifyContainerLog (  2  ,    expectedContent ,    false ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDSShellWithCommands"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "final   File   basedir    =    new   File (  \" target \"  ,    TestDistributedShell . class . getName (  )  )  ;", "final   File   tmpDir    =    new   File ( basedir ,     \" tmpDir \"  )  ;", "tmpDir . mkdirs (  )  ;", "final   File   customLogProperty    =    new   File ( tmpDir ,     \" custom _ log 4 j . properties \"  )  ;", "if    ( customLogProperty . exists (  )  )     {", "customLogProperty . delete (  )  ;", "}", "if    (  !  ( customLogProperty . createNewFile (  )  )  )     {", "Assert . fail (  \" Can   not   create   custom   log 4 j   property   file .  \"  )  ;", "}", "PrintWriter   fileWriter    =    new   PrintWriter ( customLogProperty )  ;", "fileWriter . write (  \" log 4 j . rootLogger = debug , stdout \"  )  ;", "fileWriter . close (  )  ;", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  3  \"  ,     \"  -  - shell _ command \"  ,     \" echo \"  ,     \"  -  - shell _ args \"  ,     \" HADOOP \"  ,     \"  -  - log _ properties \"  ,    customLogProperty . getAbsolutePath (  )  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "final   Log   LOG _ Client    =    LogFactory . getLog ( Client . class )  ;", "Assert . assertTrue ( LOG _ Client . isInfoEnabled (  )  )  ;", "Assert . assertFalse ( LOG _ Client . isDebugEnabled (  )  )  ;", "final   Log   LOG _ AM    =    LogFactory . getLog ( ApplicationMaster . class )  ;", "Assert . assertTrue ( LOG _ AM . isInfoEnabled (  )  )  ;", "Assert . assertFalse ( LOG _ AM . isDebugEnabled (  )  )  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "final   Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "Assert . assertTrue (  (  ( verifyContainerLog (  3  ,    null ,    true ,     \" DEBUG \"  )  )     >     1  0  )  )  ;", "Assert . assertTrue ( LOG _ Client . isInfoEnabled (  )  )  ;", "Assert . assertTrue ( LOG _ Client . isDebugEnabled (  )  )  ;", "Assert . assertTrue ( LOG _ AM . isInfoEnabled (  )  )  ;", "Assert . assertTrue ( LOG _ AM . isDebugEnabled (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDSShellWithCustomLogPropertyFile"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", ". LOG . info (  \" Initializing   DS   Client   with   no   args \"  )  ;", "try    {", "client . init ( new   String [  ]  {        }  )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" No   args \"  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   with   no   jar   file \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" No   jar \"  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   with   no   shell   command \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,     . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" No   shell   command \"  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   with   invalid   no .    of   containers \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,     . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  -  1  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" Invalid   no .    of   containers \"  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   with   invalid   no .    of   vcores \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,     . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  -  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  \" Invalid   virtual   cores   specified \"  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   with    -  - shell _ command   and    -  - shell _ script \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,     . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"  ,     \"  -  - shell _ script \"  ,     \" test . sh \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  (  \" Can   not   specify   shell _ command   option    \"     +     \" and   shell _ script   option   at   the   same   time \"  )  )  )  ;", "}", ". LOG . info (  \" Initializing   DS   Client   without    -  - shell _ command   and    -  - shell _ script \"  )  ;", "try    {", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,     . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "client . init ( args )  ;", "Assert . fail (  \" Exception   is   expected \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "Assert . assertTrue (  \" The   throw   exception   is   not   expected \"  ,    e . getMessage (  )  . contains (  (  \" No   shell   command   or   shell   script   specified    \"     +     \" to   be   executed   by   application   master \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDSShellWithInvalidArgs"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  4  \"  ,     \"  -  - shell _ command \"  ,     \" echo \"  ,     \"  -  - shell _ args \"  ,     \" HADOOP   YARN   MAPREDUCE   HDFS \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "final   Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "List < String >    expectedContent    =    new   ArrayList < String >  (  )  ;", "expectedContent . add (  \" HADOOP   YARN   MAPREDUCE   HDFS \"  )  ;", "verifyContainerLog (  4  ,    expectedContent ,    false ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDSShellWithMultipleArgs"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "final   File   basedir    =    new   File (  \" target \"  ,    TestDistributedShell . class . getName (  )  )  ;", "final   File   tmpDir    =    new   File ( basedir ,     \" tmpDir \"  )  ;", "tmpDir . mkdirs (  )  ;", "final   File   customShellScript    =    new   File ( tmpDir ,     \" custom _ script . sh \"  )  ;", "if    ( customShellScript . exists (  )  )     {", "customShellScript . delete (  )  ;", "}", "if    (  !  ( customShellScript . createNewFile (  )  )  )     {", "Assert . fail (  \" Can   not   create   custom   shell   script   file .  \"  )  ;", "}", "PrintWriter   fileWriter    =    new   PrintWriter ( customShellScript )  ;", "fileWriter . write (  \" echo   testDSShellWithShellScript \"  )  ;", "fileWriter . close (  )  ;", "System . out . println ( customShellScript . getAbsolutePath (  )  )  ;", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  1  \"  ,     \"  -  - shell _ script \"  ,    customShellScript . getAbsolutePath (  )  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "final   Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    client . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "boolean   result    =    client . run (  )  ;", "TestDistributedShell . LOG . info (  (  \" Client   run   completed .    Result =  \"     +    result )  )  ;", "List < String >    expectedContent    =    new   ArrayList < String >  (  )  ;", "expectedContent . add (  \" testDSShellWithShellScript \"  )  ;", "verifyContainerLog (  1  ,    expectedContent ,    false ,     \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testDSShellWithShellScript"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \"  -  - jar \"  ,    TestDistributedShell . APPMASTER _ JAR ,     \"  -  - num _ containers \"  ,     \"  2  \"  ,     \"  -  - shell _ command \"  ,    Shell . WINDOWS    ?     \" dir \"     :     \" ls \"  ,     \"  -  - master _ memory \"  ,     \"  5  1  2  \"  ,     \"  -  - master _ vcores \"  ,     \"  2  \"  ,     \"  -  - container _ memory \"  ,     \"  1  2  8  \"  ,     \"  -  - container _ vcores \"  ,     \"  1  \"  ,     \"  -  - debug \"     }  ;", "TestDistributedShell . LOG . info (  \" Initializing   DS   Client \"  )  ;", "Client   client    =    new   Client ( new   Configuration ( yarnCluster . getConfig (  )  )  )  ;", "Assert . assertTrue ( client . init ( args )  )  ;", "TestDistributedShell . LOG . info (  \" Running   DS   Client \"  )  ;", "Assert . assertTrue ( client . run (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDebugFlag"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "File   logFolder    =    new   File ( yarnCluster . getNodeManager (  0  )  . getConfig (  )  . get ( NM _ LOG _ DIRS ,    DEFAULT _ NM _ LOG _ DIRS )  )  ;", "File [  ]    listOfFiles    =    logFolder . listFiles (  )  ;", "int   currentContainerLogFileIndex    =     -  1  ;", "for    ( int   i    =     ( listOfFiles . length )     -     1  ;    i    >  =     0  ;    i -  -  )     {", "if    (  ( listOfFiles [ i ]  . listFiles (  )  . length )     =  =     ( containerNum    +     1  )  )     {", "currentContainerLogFileIndex    =    i ;", "break ;", "}", "}", "Assert . assertTrue (  ( currentContainerLogFileIndex    !  =     (  -  1  )  )  )  ;", "File [  ]    containerFiles    =    listOfFiles [ currentContainerLogFileIndex ]  . listFiles (  )  ;", "int   numOfWords    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( containerFiles . length )  ;    i +  +  )     {", "for    ( File   output    :    containerFiles [ i ]  . listFiles (  )  )     {", "if    ( output . getName (  )  . trim (  )  . contains (  \" stdout \"  )  )     {", "BufferedReader   br    =    null ;", "List < String >    stdOutContent    =    new   ArrayList < String >  (  )  ;", "try    {", "String   sCurrentLine ;", "br    =    new   BufferedReader ( new   FileReader ( output )  )  ;", "int   numOfline    =     0  ;", "while    (  ( sCurrentLine    =    br . readLine (  )  )     !  =    null )     {", "if    ( count )     {", "if    ( sCurrentLine . contains ( expectedWord )  )     {", "numOfWords +  +  ;", "}", "} else", "if    ( output . getName (  )  . trim (  )  . equals (  \" stdout \"  )  )     {", "if    (  !  (  . WINDOWS )  )     {", "Assert . assertEquals (  (  \" The   current   is \"     +    sCurrentLine )  ,    expectedContent . get ( numOfline )  ,    sCurrentLine . trim (  )  )  ;", "numOfline +  +  ;", "} else    {", "stdOutContent . add ( sCurrentLine . trim (  )  )  ;", "}", "}", "}", "if    (  (  (  . WINDOWS )     &  &     (  ! count )  )     &  &     ( output . getName (  )  . trim (  )  . equals (  \" stdout \"  )  )  )     {", "Assert . assertTrue ( stdOutContent . containsAll ( expectedContent )  )  ;", "}", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "try    {", "if    ( br    !  =    null )", "br . close (  )  ;", "}    catch    ( IOException   ex )     {", "ex . printStackTrace (  )  ;", "}", "}", "}", "}", "}", "return   numOfWords ;", "}", "METHOD_END"], "methodName": ["verifyContainerLog"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "int   attempt    =     6  0  ;", "ContainerManagerImpl   cm    =     (  ( ContainerManagerImpl )     ( nm . getNMContext (  )  . getContainerManager (  )  )  )  ;", "while    (  ( cm . getBlockNewContainerRequsStatus (  )  )     &  &     (  ( attempt -  -  )     >     0  )  )     {", "Thread . sleep (  2  0  0  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["waitForNMToRegister"], "fileName": "org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell"}, {"methodBody": ["METHOD_START", "{", "TestUnmanagedAMLauncher . LOG . info (  \" Trying   to   generate   classpath   for   app   master   from   current   thread ' s   classpath \"  )  ;", "String   envClassPath    =     \"  \"  ;", "String   cp    =    System . getProperty (  \" path \"  )  ;", "if    ( cp    !  =    null )     {", "envClassPath    +  =     ( cp . trim (  )  )     +     ( File . pathSeparator )  ;", "}", "ClassLoader   thisClassLoader    =    Thread . currentThread (  )  . getContextClassLoader (  )  ;", "URL   url    =    thisClassLoader . getResource (  \" yarn - site . xml \"  )  ;", "envClassPath    +  =    new   File ( url . getFile (  )  )  . getParent (  )  ;", "return   envClassPath ;", "}", "METHOD_END"], "methodName": ["getTestRuntimeClasspath"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "if    ( args [  0  ]  . equals (  \" success \"  )  )     {", "ApplicationMasterProtocol   client    =    ClientRMProxy . createRMProxy (  . conf ,    ApplicationMasterProtocol . class )  ;", "client . registerApplicationMaster ( RegisterApplicationMasterRequest . newInstance ( NetUtils . getHostname (  )  ,     (  -  1  )  ,     \"  \"  )  )  ;", "Thread . sleep (  1  0  0  0  )  ;", "FinishApplicationMasterResponse   resp    =    client . finishApplicationMaster ( FinishApplicationMasterRequest . newInstance ( SUCCEEDED ,     \" success \"  ,    null )  )  ;", "assertTrue ( resp . getIsUnregistered (  )  )  ;", "System . exit (  0  )  ;", "} else    {", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "TestUnmanagedAMLauncher . LOG . info (  \" Starting   up   YARN   cluster \"  )  ;", "TestUnmanagedAMLauncher . conf . setInt ( RM _ SCHEDULER _ MINIMUM _ ALLOCATION _ MB ,     1  2  8  )  ;", "if    (  ( TestUnmanagedAMLauncher . yarnCluster )     =  =    null )     {", "TestUnmanagedAMLauncher . yarnCluster    =    new   MiniYARNCluster ( TestUnmanagedAMLauncher . class . getSimpleName (  )  ,     1  ,     1  ,     1  )  ;", "TestUnmanagedAMLauncher . yarnCluster . init ( TestUnmanagedAMLauncher . conf )  ;", "TestUnmanagedAMLauncher . yarnCluster . start (  )  ;", "Configuration   yarnClusterConfig    =    TestUnmanagedAMLauncher . yarnCluster . getConfig (  )  ;", "TestUnmanagedAMLauncher . LOG . info (  (  \" MiniYARN   ResourceManager   published   address :     \"     +     ( yarnClusterConfig . get ( RM _ ADDRESS )  )  )  )  ;", "TestUnmanagedAMLauncher . LOG . info (  (  \" MiniYARN   ResourceManager   published   web   address :     \"     +     ( yarnClusterConfig . get ( RM _ WEBAPP _ ADDRESS )  )  )  )  ;", "String   webapp    =    yarnClusterConfig . get ( RM _ WEBAPP _ ADDRESS )  ;", "assertTrue (  (  \" Web   app   address   still   unbound   to   a   host   at    \"     +    webapp )  ,     (  !  ( webapp . startsWith (  \"  0  .  0  .  0  .  0  \"  )  )  )  )  ;", "TestUnmanagedAMLauncher . LOG . info (  (  \" Yarn   webapp   is   at    \"     +    webapp )  )  ;", "URL   url    =    Thread . currentThread (  )  . getContextClassLoader (  )  . getResource (  \" yarn - site . xml \"  )  ;", "if    ( url    =  =    null )     {", "throw   new   RuntimeException (  \" Could   not   find    ' yarn - site . xml '    dummy   file   in   classpath \"  )  ;", "}", "ByteArrayOutputStream   bytesOut    =    new   ByteArrayOutputStream (  )  ;", "yarnClusterConfig . writeXml ( bytesOut )  ;", "bytesOut . close (  )  ;", "OutputStream   os    =    new   FileOutputStream ( new   File ( url . getPath (  )  )  )  ;", "os . write ( bytesOut . toByteArray (  )  )  ;", "os . close (  )  ;", "}", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "TestUnmanagedAMLauncher . LOG . info (  (  \" setup   thread   sleep   interrupted .    message =  \"     +     ( e . getMessage (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setup"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "if    (  ( TestUnmanagedAMLauncher . yarnCluster )     !  =    null )     {", "try    {", "TestUnmanagedAMLauncher . yarnCluster . stop (  )  ;", "}    finally    {", "TestUnmanagedAMLauncher . yarnCluster    =    null ;", "}", "}", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "String   classpath    =    TestUnmanagedAMLauncher . getTestRuntimeClasspath (  )  ;", "String   javaHome    =    System . getenv (  \" JAVA _ HOME \"  )  ;", "if    ( javaHome    =  =    null )     {", "TestUnmanagedAMLauncher . LOG . fatal (  \" JAVA _ HOME   not   defined .    Test   not   running .  \"  )  ;", "return ;", "}", "String [  ]    args    =    new   String [  ]  {     \"  -  - classpath \"  ,    classpath ,     \"  -  - queue \"  ,     \" default \"  ,     \"  -  - cmd \"  ,     (  ( javaHome    +     \"  / bin / java    - Xmx 5  1  2 m    \"  )     +     ( TestUnmanagedAMLauncher . class . getCanonicalName (  )  )  )     +     \"    success \"     }  ;", "TestUnmanagedAMLauncher . LOG . info (  \" Initializing   Launcher \"  )  ;", "UnmanagedAMLauncher   launcher    =    new   UnmanagedAMLauncher ( new   Configuration ( TestUnmanagedAMLauncher . yarnCluster . getConfig (  )  )  )     {", "public   void   launchAM ( ApplicationAttemptId   attemptId )    throws   IOException ,    YarnException    {", "YarnApplicationAttemptState   attemptState    =    rmClient . getApplicationAttemptReport ( attemptId )  . getYarnApplicationAttemptState (  )  ;", "Assert . assertTrue ( attemptState . equals ( LAUNCHED )  )  ;", "super . launchAM ( attemptId )  ;", "}", "}  ;", "boolean   initSuccess    =    launcher . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestUnmanagedAMLauncher . LOG . info (  \" Running   Launcher \"  )  ;", "boolean   result    =    launcher . run (  )  ;", "TestUnmanagedAMLauncher . LOG . info (  (  \" Launcher   run   completed .    Result =  \"     +    result )  )  ;", "Assert . assertTrue ( result )  ;", "}", "METHOD_END"], "methodName": ["testUMALauncher"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "String   classpath    =    TestUnmanagedAMLauncher . getTestRuntimeClasspath (  )  ;", "String   javaHome    =    System . getenv (  \" JAVA _ HOME \"  )  ;", "if    ( javaHome    =  =    null )     {", "TestUnmanagedAMLauncher . LOG . fatal (  \" JAVA _ HOME   not   defined .    Test   not   running .  \"  )  ;", "return ;", "}", "String [  ]    args    =    new   String [  ]  {     \"  -  - classpath \"  ,    classpath ,     \"  -  - queue \"  ,     \" default \"  ,     \"  -  - cmd \"  ,     (  ( javaHome    +     \"  / bin / java    - Xmx 5  1  2 m    \"  )     +     ( TestUnmanagedAMLauncher . class . getCanonicalName (  )  )  )     +     \"    failure \"     }  ;", "TestUnmanagedAMLauncher . LOG . info (  \" Initializing   Launcher \"  )  ;", "UnmanagedAMLauncher   launcher    =    new   UnmanagedAMLauncher ( new   Configuration ( TestUnmanagedAMLauncher . yarnCluster . getConfig (  )  )  )  ;", "boolean   initSuccess    =    launcher . init ( args )  ;", "Assert . assertTrue ( initSuccess )  ;", "TestUnmanagedAMLauncher . LOG . info (  \" Running   Launcher \"  )  ;", "try    {", "launcher . run (  )  ;", "fail (  \" Expected   an   exception   to   occur   as   launch   should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "}", "}", "METHOD_END"], "methodName": ["testUMALauncherError"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "Options   opts    =    new   Options (  )  ;", "opts . addOption (  \" appname \"  ,    true ,     \" Application   Name .    Default   value    -     \"  )  ;", "opts . addOption (  \" priority \"  ,    true ,     \" Application   Priority .    Default    0  \"  )  ;", "opts . addOption (  \" queue \"  ,    true ,     \" RM   Queue   in   which   this   application   is   to   be   submitted \"  )  ;", "opts . addOption (  \" master _ memory \"  ,    true ,     \" Amount   of   memory   in   MB   to   be   requested   to   run   the   application   master \"  )  ;", "opts . addOption (  \" cmd \"  ,    true ,     \" command   to   start   unmanaged   AM    ( required )  \"  )  ;", "opts . addOption (  \" classpath \"  ,    true ,     \" additional   classpath \"  )  ;", "opts . addOption (  \" help \"  ,    false ,     \" Print   usage \"  )  ;", "CommandLine   cliParser    =    new   GnuParser (  )  . parse ( opts ,    args )  ;", "if    (  ( args . length )     =  =     0  )     {", "printUsage ( opts )  ;", "throw   new   IllegalArgumentException (  \" No   args   specified   for   client   to   initialize \"  )  ;", "}", "if    ( cliParser . hasOption (  \" help \"  )  )     {", "printUsage ( opts )  ;", "return   false ;", "}", "appName    =    cliParser . getOptionValue (  \" appname \"  ,     \"  \"  )  ;", "amPriority    =    Integer . parseInt ( cliParser . getOptionValue (  \" priority \"  ,     \"  0  \"  )  )  ;", "amQueue    =    cliParser . getOptionValue (  \" queue \"  ,     \" default \"  )  ;", "classpath    =    cliParser . getOptionValue (  \" classpath \"  ,    null )  ;", "amCmd    =    cliParser . getOptionValue (  \" cmd \"  )  ;", "if    (  ( amCmd )     =  =    null )     {", "printUsage ( opts )  ;", "throw   new   IllegalArgumentException (  \" No   cmd   specified   for   application   master \"  )  ;", "}", "YarnConfiguration   yarnConf    =    new   YarnConfiguration ( conf )  ;", "rmClient    =    YarnClient . createYarnClient (  )  ;", "rmClient . init ( yarnConf )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["init"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "Credentials   credentials    =    new   Credentials (  )  ;", "Token < AMRMTokenIdentifier >    token    =    rmClient . getAMRMToken ( attemptId . getApplicationId (  )  )  ;", "credentials . addToken ( token . getService (  )  ,    token )  ;", "File   tokenFile    =    File . createTempFile (  \" unmanagedAMRMToken \"  ,     \"  \"  ,    new   File ( System . getProperty (  \" user . dir \"  )  )  )  ;", "try    {", "FileUtil . chmod ( tokenFile . getAbsolutePath (  )  ,     \"  6  0  0  \"  )  ;", "}    catch    ( InterruptedException   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "tokenFile . deleteOnExit (  )  ;", "DataOutputStream   os    =    new   DataOutputStream ( new   FileOutputStream ( tokenFile ,    true )  )  ;", "credentials . writeTokenStorageToStream ( os )  ;", "os . close (  )  ;", "Map < String ,    String >    env    =    System . getenv (  )  ;", "ArrayList < String >    envAMList    =    new   ArrayList < String >  (  )  ;", "boolean   setClasspath    =    false ;", "for    ( Map . Entry < String ,    String >    entry    :    env . entrySet (  )  )     {", "String   key    =    entry . getKey (  )  ;", "String   value    =    entry . getValue (  )  ;", "if    ( key . equals (  \" CLASSPATH \"  )  )     {", "setClasspath    =    true ;", "if    (  ( classpath )     !  =    null )     {", "value    =     ( value    +     ( File . pathSeparator )  )     +     ( classpath )  ;", "}", "}", "envAMList . add (  (  ( key    +     \"  =  \"  )     +    value )  )  ;", "}", "if    (  (  ! setClasspath )     &  &     (  ( classpath )     !  =    null )  )     {", "envAMList . add (  (  \" CLASSPATH =  \"     +     ( classpath )  )  )  ;", "}", "ContainerId   containerId    =    ContainerId . newInstance ( attemptId ,     0  )  ;", "String   hostname    =    InetAddress . getLocalHost (  )  . getHostName (  )  ;", "envAMList . add (  (  (  ( CONTAINER _ ID . name (  )  )     +     \"  =  \"  )     +    containerId )  )  ;", "envAMList . add (  (  (  ( NM _ HOST . name (  )  )     +     \"  =  \"  )     +    hostname )  )  ;", "envAMList . add (  (  ( NM _ HTTP _ PORT . name (  )  )     +     \"  =  0  \"  )  )  ;", "envAMList . add (  (  ( NM _ PORT . name (  )  )     +     \"  =  0  \"  )  )  ;", "envAMList . add (  (  ( LOCAL _ DIRS . name (  )  )     +     \"  =     / tmp \"  )  )  ;", "envAMList . add (  (  (  ( ApplicationConstants . APP _ SUBMIT _ TIME _ ENV )     +     \"  =  \"  )     +     ( System . currentTimeMillis (  )  )  )  )  ;", "envAMList . add (  (  (  ( ApplicationConstants . CONTAINER _ TOKEN _ FILE _ ENV _ NAME )     +     \"  =  \"  )     +     ( tokenFile . getAbsolutePath (  )  )  )  )  ;", "String [  ]    envAM    =    new   String [ envAMList . size (  )  ]  ;", "Process   amProc    =    Runtime . getRuntime (  )  . exec ( amCmd ,    envAMList . toArray ( envAM )  )  ;", "final   BufferedReader   errReader    =    new   BufferedReader ( new   InputStreamReader ( amProc . getErrorStream (  )  )  )  ;", "final   BufferedReader   inReader    =    new   BufferedReader ( new   InputStreamReader ( amProc . getInputStream (  )  )  )  ;", "Thread   errThread    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "String   line    =    errReader . readLine (  )  ;", "while    (  ( line    !  =    null )     &  &     (  !  ( isInterrupted (  )  )  )  )     {", "System . err . println ( line )  ;", "line    =    errReader . readLine (  )  ;", "}", "}    catch    ( IOException   ioe )     {", ". LOG . warn (  \" Error   reading   the   error   stream \"  ,    ioe )  ;", "}", "}", "}  ;", "Thread   outThread    =    new   Thread (  )     {", "@ Override", "public   void   run (  )     {", "try    {", "String   line    =    inReader . readLine (  )  ;", "while    (  ( line    !  =    null )     &  &     (  !  ( isInterrupted (  )  )  )  )     {", "System . out . println ( line )  ;", "line    =    inReader . readLine (  )  ;", "}", "}    catch    ( IOException   ioe )     {", ". LOG . warn (  \" Error   reading   the   out   stream \"  ,    ioe )  ;", "}", "}", "}  ;", "try    {", "errThread . start (  )  ;", "outThread . start (  )  ;", "}    catch    ( IllegalStateException   ise )     {", "}", "try    {", "int   exitCode    =    amProc . waitFor (  )  ;", ". LOG . info (  (  \" AM   process   exited   with   value :     \"     +    exitCode )  )  ;", "}    catch    ( InterruptedException   e )     {", "e . printStackTrace (  )  ;", "}    finally    {", "amCompleted    =    true ;", "}", "try    {", "errThread . join (  )  ;", "outThread . join (  )  ;", "errReader . close (  )  ;", "inReader . close (  )  ;", "}    catch    ( InterruptedException   ie )     {", ". LOG . info (  \" ShellExecutor :    Interrupted   while   reading   the   error / out   stream \"  ,    ie )  ;", "}    catch    ( IOException   ioe )     {", ". LOG . warn (  \" Error   while   closing   the   error / out   stream \"  ,    ioe )  ;", "}", "amProc . destroy (  )  ;", "}", "METHOD_END"], "methodName": ["launchAM"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "try    {", "client    =    new    (  )  ;", ". LOG . info (  \" Initializing   Client \"  )  ;", "boolean   doRun    =    client . init ( args )  ;", "if    (  ! doRun )     {", "System . exit (  0  )  ;", "}", "client . run (  )  ;", "}    catch    ( Throwable   t )     {", ". LOG . fatal (  \" Error   running   Client \"  ,    t )  ;", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "long   foundAMCompletedTime    =     0  ;", "StringBuilder   expectedFinalState    =    new   StringBuilder (  )  ;", "boolean   first    =    true ;", "for    ( YarnApplicationState   state    :    finalState )     {", "if    ( first )     {", "first    =    false ;", "expectedFinalState . append ( state . name (  )  )  ;", "} else    {", "expectedFinalState . append (  (  \"  ,  \"     +     ( state . name (  )  )  )  )  ;", "}", "}", "while    ( true )     {", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", ". LOG . debug (  \" Thread   sleep   in   monitoring   loop   interrupted \"  )  ;", "}", "ApplicationReport   report    =    rmClient . getApplicationReport ( appId )  ;", ". LOG . info (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" Got   application   report   from   ASM   for \"     +     \"  ,    appId =  \"  )     +     ( appId . getId (  )  )  )     +     \"  ,    appAttemptId =  \"  )     +     ( report . getCurrentApplicationAttemptId (  )  )  )     +     \"  ,    clientToAMToken =  \"  )     +     ( report . getClientToAMToken (  )  )  )     +     \"  ,    appDiagnostics =  \"  )     +     ( report . getDiagnostics (  )  )  )     +     \"  ,    appMasterHost =  \"  )     +     ( report . getHost (  )  )  )     +     \"  ,    appQueue =  \"  )     +     ( report . getQueue (  )  )  )     +     \"  ,    appMasterRpcPort =  \"  )     +     ( report . getRpcPort (  )  )  )     +     \"  ,    appStartTime =  \"  )     +     ( report . getStartTime (  )  )  )     +     \"  ,    yarnAppState =  \"  )     +     ( report . getYarnApplicationState (  )  . toString (  )  )  )     +     \"  ,    distributedFinalState =  \"  )     +     ( report . getFinalApplicationStatus (  )  . toString (  )  )  )     +     \"  ,    appTrackingUrl =  \"  )     +     ( report . getTrackingUrl (  )  )  )     +     \"  ,    appUser =  \"  )     +     ( report . getUser (  )  )  )  )  ;", "YarnApplicationState   state    =    report . getYarnApplicationState (  )  ;", "if    ( finalState . contains ( state )  )     {", "return   report ;", "}", "if    ( amCompleted )     {", "if    ( foundAMCompletedTime    =  =     0  )     {", "foundAMCompletedTime    =    System . currentTimeMillis (  )  ;", "} else", "if    (  (  ( System . currentTimeMillis (  )  )     -    foundAMCompletedTime )     >     (  . AM _ STATE _ WAIT _ TIMEOUT _ MS )  )     {", ". LOG . warn (  (  (  (  (  (  (  (  \" Waited    \"     +     (  (  . AM _ STATE _ WAIT _ TIMEOUT _ MS )     /     1  0  0  0  )  )     +     \"    seconds   after   process   completed   for   AppReport \"  )     +     \"    to   reach   desired   final   state .    Not   waiting   anymore .  \"  )     +     \" CurrentState    =     \"  )     +    state )     +     \"  ,    ExpectedStates    =     \"  )     +     ( expectedFinalState . toString (  )  )  )  )  ;", "throw   new   RuntimeException (  (  (  (  (  \" Failed   to   receive   final   expected   state \"     +     (  \"    in   ApplicationReport \"     +     \"  ,    CurrentState =  \"  )  )     +    state )     +     \"  ,    ExpectedStates =  \"  )     +     ( expectedFinalState . toString (  )  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["monitorApplication"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "long   startTime    =    System . currentTimeMillis (  )  ;", "ApplicationAttemptId   attemptId    =    null ;", "while    ( true )     {", "if    ( attemptId    =  =    null )     {", "attemptId    =    rmClient . getApplicationReport ( appId )  . getCurrentApplicationAttemptId (  )  ;", "}", "ApplicationAttemptReport   attemptReport    =    null ;", "if    ( attemptId    !  =    null )     {", "attemptReport    =    rmClient . getApplicationAttemptReport ( attemptId )  ;", "if    ( attemptState . equals ( attemptReport . getYarnApplicationAttemptState (  )  )  )     {", "return   attemptReport ;", "}", "}", ". LOG . info (  (  (  (  (  (  \" Current   attempt   state   of    \"     +    appId )     +     \"    is    \"  )     +     ( attemptReport    =  =    null    ?     \"    N / A    \"     :    attemptReport . getYarnApplicationAttemptState (  )  )  )     +     \"  ,    waiting   for   current   attempt   to   reach    \"  )     +    attemptState )  )  ;", "try    {", "Thread . sleep (  1  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", ". LOG . warn (  (  (  (  \" Interrupted   while   waiting   for   current   attempt   of    \"     +    appId )     +     \"    to   reach    \"  )     +    attemptState )  )  ;", "}", "if    (  (  ( System . currentTimeMillis (  )  )     -    startTime )     >     (  . AM _ STATE _ WAIT _ TIMEOUT _ MS )  )     {", "String   errmsg    =     (  (  \" Timeout   for   waiting   current   attempt   of    \"     +    appId )     +     \"    to   reach    \"  )     +    attemptState ;", ". LOG . error ( errmsg )  ;", "throw   new   RuntimeException ( errmsg )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["monitorCurrentAppAttempt"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "new   HelpFormatter (  )  . printHelp (  \" Client \"  ,    opts )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}, {"methodBody": ["METHOD_START", "{", "UnmanagedAMLauncher . LOG . info (  \" Starting   Client \"  )  ;", "rmClient . start (  )  ;", "try    {", "UnmanagedAMLauncher . LOG . info (  \" Setting   up   application   submission   context   for   ASM \"  )  ;", "ApplicationSubmissionContext   appContext    =    rmClient . createApplication (  )  . getApplicationSubmissionContext (  )  ;", "ApplicationId   appId    =    appContext . getApplicationId (  )  ;", "appContext . setApplicationName ( appName )  ;", "Priority   pri    =    Records . newRecord ( Priority . class )  ;", "pri . setPriority ( amPriority )  ;", "appContext . setPriority ( pri )  ;", "appContext . setQueue ( amQueue )  ;", "ContainerLaunchContext   amContainer    =    Records . newRecord ( ContainerLaunchContext . class )  ;", "appContext . setAMContainerSpec ( amContainer )  ;", "appContext . setUnmanagedAM ( true )  ;", "UnmanagedAMLauncher . LOG . info (  \" Setting   unmanaged   AM \"  )  ;", "UnmanagedAMLauncher . LOG . info (  \" Submitting   application   to   ASM \"  )  ;", "rmClient . submitApplication ( appContext )  ;", "ApplicationReport   appReport    =    monitorApplication ( appId ,    EnumSet . of ( ACCEPTED ,    KILLED ,    FAILED ,    FINISHED )  )  ;", "if    (  ( appReport . getYarnApplicationState (  )  )     =  =     ( YarnApplicationState . ACCEPTED )  )     {", "ApplicationAttemptReport   attemptReport    =    monitorCurrentAppAttempt ( appId ,    LAUNCHED )  ;", "ApplicationAttemptId   attemptId    =    attemptReport . getApplicationAttemptId (  )  ;", "UnmanagedAMLauncher . LOG . info (  (  \" Launching   AM   with   application   attempt   id    \"     +    attemptId )  )  ;", "launchAM ( attemptId )  ;", "appReport    =    monitorApplication ( appId ,    EnumSet . of ( KILLED ,    FAILED ,    FINISHED )  )  ;", "}", "YarnApplicationState   appState    =    appReport . getYarnApplicationState (  )  ;", "FinalApplicationStatus   appStatus    =    appReport . getFinalApplicationStatus (  )  ;", "UnmanagedAMLauncher . LOG . info (  (  (  (  \" App   ended   with   state :     \"     +     ( appReport . getYarnApplicationState (  )  )  )     +     \"    and   status :     \"  )     +    appStatus )  )  ;", "boolean   success ;", "if    (  (  ( YarnApplicationState . FINISHED )     =  =    appState )     &  &     (  ( FinalApplicationStatus . SUCCEEDED )     =  =    appStatus )  )     {", "UnmanagedAMLauncher . LOG . info (  \" Application   has   completed   successfully .  \"  )  ;", "success    =    true ;", "} else    {", "UnmanagedAMLauncher . LOG . info (  (  (  (  (  \" Application   did   finished   unsuccessfully .  \"     +     \"    YarnState =  \"  )     +     ( appState . toString (  )  )  )     +     \"  ,    FinalStatus =  \"  )     +     ( appStatus . toString (  )  )  )  )  ;", "success    =    false ;", "}", "return   success ;", "}    finally    {", "rmClient . stop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.apache.hadoop.yarn.applications.unmanagedamlauncher.UnmanagedAMLauncher"}]