[{"methodBody": ["METHOD_START", "{", "assertThat ( multiGetResponse . getResponses (  )  . length ,    equalTo ( numDocs )  )  ;", "int   i    =     1  ;", "for    ( MultiGetItemResponse   multiGetItemResponse    :    multiGetResponse )     {", "assertThat ( multiGetItemResponse . getIndex (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( multiGetItemResponse . getType (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( multiGetItemResponse . getId (  )  ,    equalTo ( Integer . toString (  ( i +  +  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertMultiGetResponse"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "assertThat ( bulkItemResponses . size (  )  ,    is ( numDocs )  )  ;", "int   i    =     1  ;", "for    ( ItemResponse   bulkItemResponse    :    bulkItemResponses )     {", "assertThat ( bulkItemResponse . getIndex (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( bulkItemResponse . getType (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( bulkItemResponse . getId (  )  ,    equalTo ( Integer . toString (  ( i +  +  )  )  )  )  ;", "assertThat (  (  (  (  \" item    \"     +    i )     +     \"    failed   with   cause :     \"  )     +     ( bulkItemResponse . getFailureMessage (  )  )  )  ,    bulkItemResponse . isFailed (  )  ,    equalTo ( false )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertResponseItems"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "MultiGetRequest   multiGetRequest    =    new   MultiGetRequest (  )  ;", "for    ( int   i    =     1  ;    i    <  =    numDocs ;    i +  +  )     {", "if    ( randomBoolean (  )  )     {", "p . add ( new   IndexRequest (  \" test \"  ,     \" test \"  ,    Integer . toString ( i )  )  . source ( JSON ,     \" field \"  ,    randomRealisticUnicodeOfLengthBetween (  1  ,     3  0  )  )  )  ;", "} else    {", "final   String   source    =     (  (  (  \"  {     \\  \" index \\  \"  :  {  \\  \"  _ index \\  \"  :  \\  \" test \\  \"  ,  \\  \"  _ type \\  \"  :  \\  \" test \\  \"  ,  \\  \"  _ id \\  \"  :  \\  \"  \"     +     ( Integer . toString ( i )  )  )     +     \"  \\  \"  }     }  \\ n \"  )     +     ( Strings . toString ( JsonXContent . contentBuilder (  )  . startObject (  )  . field (  \" field \"  ,    randomRealisticUnicodeOfLengthBetween (  1  ,     3  0  )  )  . endObject (  )  )  )  )     +     \"  \\ n \"  ;", "p . add ( new   BytesArray ( source )  ,    null ,    null ,    JSON )  ;", "}", "multiGetRequest . add (  \" test \"  ,     \" test \"  ,    Integer . toString ( i )  )  ;", "}", "return   multiGetRequest ;", "}", "METHOD_END"], "methodName": ["indexDocs"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "return   BulkProcessor . builder ( ESRestHighLevelClientTestCase . highLevelClient (  )  :  : bulkAsync ,    listener )  ;", "}", "METHOD_END"], "methodName": ["initBulkProcessorBuilder"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "int   bulkActions    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "int   numDocs    =    randomIntBetween ( bulkActions ,     ( bulkActions    +     1  0  0  )  )  ;", "int   concurrentRequests    =    randomIntBetween (  0  ,     7  )  ;", "int   expectedBulkActions    =    numDocs    /    bulkActions ;", "final   CountDownLatch   latch    =    new   CountDownLatch ( expectedBulkActions )  ;", "int   totalExpectedBulkActions    =     (  ( numDocs    %    bulkActions )     =  =     0  )     ?    expectedBulkActions    :    expectedBulkActions    +     1  ;", "final   CountDownLatch   closeLatch    =    new   CountDownLatch ( totalExpectedBulkActions )  ;", "BulkProcessorIT . BulkProcessorTestListener   listener    =    new   BulkProcessorIT . BulkProcessorTestListener ( latch ,    closeLatch )  ;", "MultiGetRequest   multiGetRequest ;", "try    ( BulkProcessor   processor    =    BulkProcessorIT . initBulkProcessorBuilder ( listener )  . setConcurrentRequests ( concurrentRequests )  . setBulkActions ( bulkActions )  . setFlushInterval ( TimeValue . timeValueHours (  2  4  )  )  . setBulkSize ( new   ommon . unit . ByteSizeValue (  1  ,    ByteSizeUnit . GB )  )  . build (  )  )     {", "multiGetRequest    =    BulkProcessorIT . indexDocs ( processor ,    numDocs )  ;", "latch . await (  )  ;", "assertThat ( listener . beforeCounts . get (  )  ,    equalTo ( expectedBulkActions )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    equalTo ( expectedBulkActions )  )  ;", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "assertThat ( listener . bulkItems . size (  )  ,    equalTo (  ( numDocs    -     ( numDocs    %    bulkActions )  )  )  )  ;", "}", "closeLatch . await (  )  ;", "assertThat ( listener . beforeCounts . get (  )  ,    equalTo ( totalExpectedBulkActions )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    equalTo ( totalExpectedBulkActions )  )  ;", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "assertThat ( listener . bulkItems . size (  )  ,    equalTo ( numDocs )  )  ;", "Set < String >    ids    =    new   HashSet <  >  (  )  ;", "for    ( BulkItemResponse   bulkItemResponse    :    listener . bulkItems )     {", "assertThat ( bulkItemResponse . getFailureMessage (  )  ,    bulkItemResponse . isFailed (  )  ,    equalTo ( false )  )  ;", "assertThat ( bulkItemResponse . getIndex (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( bulkItemResponse . getType (  )  ,    equalTo (  \" test \"  )  )  ;", "assertThat ( Integer . valueOf ( bulkItemResponse . getId (  )  )  ,    both ( greaterThan (  0  )  )  . and ( lessThanOrEqualTo ( numDocs )  )  )  ;", "assertThat ( ids . add ( bulkItemResponse . getId (  )  )  ,    equalTo ( true )  )  ;", "}", "BulkProcessorIT . assertMultiGetResponse ( ESRestHighLevelClientTestCase . highLevelClient (  )  . multiGet ( multiGetRequest )  ,    numDocs )  ;", "}", "METHOD_END"], "methodName": ["testBulkProcessorConcurrentRequests"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "String   createIndexBody    =     \"  {  \\ n \"     +     (  (  (  (  (  (  \"              \\  \" settings \\  \"     :     {  \\ n \"     +     \"                          \\  \" index \\  \"     :     {  \\ n \"  )     +     \"                                      \\  \" blocks . write \\  \"     :    true \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"              \\ n \"  )     +     \"  }  \"  )  ;", "NStringEntity   entity    =    new   NStringEntity ( createIndexBody ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    client (  )  . performRequest (  \" PUT \"  ,     \"  / test - ro \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo (  2  0  0  )  )  ;", "int   bulkActions    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "int   numDocs    =    randomIntBetween ( bulkActions ,     ( bulkActions    +     1  0  0  )  )  ;", "int   concurrentRequests    =    randomIntBetween (  0  ,     1  0  )  ;", "int   expectedBulkActions    =    numDocs    /    bulkActions ;", "final   CountDownLatch   latch    =    new   CountDownLatch ( expectedBulkActions )  ;", "int   totalExpectedBulkActions    =     (  ( numDocs    %    bulkActions )     =  =     0  )     ?    expectedBulkActions    :    expectedBulkActions    +     1  ;", "final   CountDownLatch   closeLatch    =    new   CountDownLatch ( totalExpectedBulkActions )  ;", "int   testDocs    =     0  ;", "int   testReadOnlyDocs    =     0  ;", "MultiGetRequest   multiGetRequest    =    new   MultiGetRequest (  )  ;", "BulkProcessorIT . BulkProcessorTestListener   listener    =    new   BulkProcessorIT . BulkProcessorTestListener ( latch ,    closeLatch )  ;", "try    ( BulkProcessor   processor    =    BulkProcessorIT . initBulkProcessorBuilder ( listener )  . setConcurrentRequests ( concurrentRequests )  . setBulkActions ( bulkActions )  . setFlushInterval ( TimeValue . timeValueHours (  2  4  )  )  . setBulkSize ( new   ommon . unit . ByteSizeValue (  1  ,    ByteSizeUnit . GB )  )  . build (  )  )     {", "for    ( int   i    =     1  ;    i    <  =    numDocs ;    i +  +  )     {", "if    ( randomBoolean (  )  )     {", "testDocs +  +  ;", "processor . add ( new   IndexRequest (  \" test \"  ,     \" test \"  ,    Integer . toString ( testDocs )  )  . source ( JSON ,     \" field \"  ,     \" value \"  )  )  ;", "multiGetRequest . add (  \" test \"  ,     \" test \"  ,    Integer . toString ( testDocs )  )  ;", "} else    {", "testReadOnlyDocs +  +  ;", "processor . add ( new   IndexRequest (  \" test - ro \"  ,     \" test \"  ,    Integer . toString ( testReadOnlyDocs )  )  . source ( JSON ,     \" field \"  ,     \" value \"  )  )  ;", "}", "}", "}", "closeLatch . await (  )  ;", "assertThat ( listener . beforeCounts . get (  )  ,    equalTo ( totalExpectedBulkActions )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    equalTo ( totalExpectedBulkActions )  )  ;", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "assertThat ( listener . bulkItems . size (  )  ,    equalTo (  ( testDocs    +    testReadOnlyDocs )  )  )  ;", "Set < String >    ids    =    new   HashSet <  >  (  )  ;", "Set < String >    readOnlyIds    =    new   HashSet <  >  (  )  ;", "for    ( BulkItemResponse   bulkItemResponse    :    listener . bulkItems )     {", "assertThat ( bulkItemResponse . getIndex (  )  ,    either ( equalTo (  \" test \"  )  )  . or ( equalTo (  \" test - ro \"  )  )  )  ;", "assertThat ( bulkItemResponse . getType (  )  ,    equalTo (  \" test \"  )  )  ;", "if    ( bulkItemResponse . getIndex (  )  . equals (  \" test \"  )  )     {", "assertThat ( bulkItemResponse . isFailed (  )  ,    equalTo ( false )  )  ;", "assertThat ( Integer . valueOf ( bulkItemResponse . getId (  )  )  ,    both ( greaterThan (  0  )  )  . and ( lessThanOrEqualTo ( testDocs )  )  )  ;", "assertThat ( ids . add ( bulkItemResponse . getId (  )  )  ,    equalTo ( true )  )  ;", "} else    {", "assertThat ( bulkItemResponse . isFailed (  )  ,    equalTo ( true )  )  ;", "assertThat ( Integer . valueOf ( bulkItemResponse . getId (  )  )  ,    both ( greaterThan (  0  )  )  . and ( lessThanOrEqualTo ( testReadOnlyDocs )  )  )  ;", "assertThat ( readOnlyIds . add ( bulkItemResponse . getId (  )  )  ,    equalTo ( true )  )  ;", "}", "}", "BulkProcessorIT . assertMultiGetResponse ( ESRestHighLevelClientTestCase . highLevelClient (  )  . multiGet ( multiGetRequest )  ,    testDocs )  ;", "}", "METHOD_END"], "methodName": ["testBulkProcessorConcurrentRequestsReadOnlyIndex"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "BulkProcessorIT . BulkProcessorTestListener   listener    =    new   BulkProcessorIT . BulkProcessorTestListener ( latch )  ;", "int   numDocs    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "try    ( BulkProcessor   processor    =    BulkProcessorIT . initBulkProcessorBuilder ( listener )  . setConcurrentRequests ( randomIntBetween (  0  ,     1  0  )  )  . setBulkActions (  ( numDocs    +     ( randomIntBetween (  1  ,     1  0  0  )  )  )  )  . setFlushInterval ( TimeValue . timeValueHours (  2  4  )  )  . setBulkSize ( new   ommon . unit . ByteSizeValue (  1  ,    ByteSizeUnit . GB )  )  . build (  )  )     {", "MultiGetRequest   multiGetRequest    =    BulkProcessorIT . indexDocs ( processor ,    numDocs )  ;", "assertThat ( latch . await ( randomInt (  5  0  0  )  ,    TimeUnit . MILLISECONDS )  ,    equalTo ( false )  )  ;", "processor . flush (  )  ;", "latch . await (  )  ;", "assertThat ( listener . beforeCounts . get (  )  ,    equalTo (  1  )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    equalTo (  1  )  )  ;", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "BulkProcessorIT . assertResponseItems ( listener . bulkItems ,    numDocs )  ;", "BulkProcessorIT . assertMultiGetResponse ( ESRestHighLevelClientTestCase . highLevelClient (  )  . multiGet ( multiGetRequest )  ,    numDocs )  ;", "}", "}", "METHOD_END"], "methodName": ["testBulkProcessorFlush"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "BulkProcessorIT . BulkProcessorTestListener   listener    =    new   BulkProcessorIT . BulkProcessorTestListener (  )  ;", "int   numDocs    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "BulkProcessor   processor    =    BulkProcessorIT . initBulkProcessorBuilder ( listener )  . setConcurrentRequests ( randomIntBetween (  0  ,     1  )  )  . setBulkActions ( numDocs )  . setFlushInterval ( TimeValue . timeValueHours (  2  4  )  )  . setBulkSize ( new   ommon . unit . ByteSizeValue ( randomIntBetween (  1  ,     1  0  )  ,    RandomPicks . randomFrom ( random (  )  ,    ByteSizeUnit . values (  )  )  )  )  . build (  )  ;", "MultiGetRequest   multiGetRequest    =    BulkProcessorIT . indexDocs ( processor ,    numDocs )  ;", "assertThat ( processor . awaitClose (  1  ,    TimeUnit . MINUTES )  ,    is ( true )  )  ;", "if    ( randomBoolean (  )  )     {", "if    ( randomBoolean (  )  )     {", "assertThat ( processor . awaitClose (  1  ,    TimeUnit . MINUTES )  ,    is ( true )  )  ;", "} else    {", "processor . close (  )  ;", "}", "}", "assertThat ( listener . beforeCounts . get (  )  ,    greaterThanOrEqualTo (  1  )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    greaterThanOrEqualTo (  1  )  )  ;", "for    ( Throwable   bulkFailure    :    listener . bulkFailures )     {", "logger . error (  \" bulk   failure \"  ,    bulkFailure )  ;", "}", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "BulkProcessorIT . assertResponseItems ( listener . bulkItems ,    numDocs )  ;", "BulkProcessorIT . assertMultiGetResponse ( ESRestHighLevelClientTestCase . highLevelClient (  )  . multiGet ( multiGetRequest )  ,    numDocs )  ;", "}", "METHOD_END"], "methodName": ["testBulkProcessorWaitOnClose"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "BulkProcessorIT . BulkProcessorTestListener   listener    =    new   BulkProcessorIT . BulkProcessorTestListener ( latch )  ;", "int   numDocs    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "try    ( BulkProcessor   processor    =    BulkProcessorIT . initBulkProcessorBuilder ( listener )  . setConcurrentRequests ( randomIntBetween (  0  ,     1  )  )  . setBulkActions ( numDocs )  . setFlushInterval ( TimeValue . timeValueHours (  2  4  )  )  . setBulkSize ( new   ommon . unit . ByteSizeValue (  1  ,    ByteSizeUnit . GB )  )  . build (  )  )     {", "MultiGetRequest   multiGetRequest    =    BulkProcessorIT . indexDocs ( processor ,    numDocs )  ;", "latch . await (  )  ;", "assertThat ( listener . beforeCounts . get (  )  ,    equalTo (  1  )  )  ;", "assertThat ( listener . afterCounts . get (  )  ,    equalTo (  1  )  )  ;", "assertThat ( listener . bulkFailures . size (  )  ,    equalTo (  0  )  )  ;", "BulkProcessorIT . assertResponseItems ( listener . bulkItems ,    numDocs )  ;", "BulkProcessorIT . assertMultiGetResponse ( ESRestHighLevelClientTestCase . highLevelClient (  )  . multiGet ( multiGetRequest )  ,    numDocs )  ;", "}", "}", "METHOD_END"], "methodName": ["testThatBulkProcessorCountIsCorrect"], "fileName": "org.elasticsearch.client.BulkProcessorIT"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( clusterUpdateSettingsRequest ,    Request :  : clusterPutSettings ,    ClusterUpdateSettingsResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putSettings"], "fileName": "org.elasticsearch.client.ClusterClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( clusterUpdateSettingsRequest ,    Request :  : clusterPutSettings ,    ClusterUpdateSettingsResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putSettingsAsync"], "fileName": "org.elasticsearch.client.ClusterClient"}, {"methodBody": ["METHOD_START", "{", "final   String   transientSettingKey    =    INDICES _ RECOVERY _ MAX _ BYTES _ PER _ SEC _ SETTING . getKey (  )  ;", "final   int   transientSettingValue    =     1  0  ;", "final   String   persistentSettingKey    =    CLUSTER _ ROUTING _ ALLOCATION _ ENABLE _ SETTING . getKey (  )  ;", "final   String   persistentSettingValue    =    NONE . name (  )  ;", "Settings   transientSettings    =    Settings . builder (  )  . put ( transientSettingKey ,    transientSettingValue ,    BYTES )  . build (  )  ;", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( persistentSettingKey ,    persistentSettingValue )  ;", "UpdateSettingsRequest   setRequest    =    new   UpdateSettingsRequest (  )  ;", "setRequest . transientSettings ( transientSettings )  ;", "setRequest . persistentSettings ( map )  ;", "UpdateSettingsResponse   setResponse    =    ESRestHighLevelClientTestCase . execute ( setRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . cluster (  )  :  : putSettings ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . cluster (  )  :  : putSettingsAsync )  ;", "assertAcked ( setResponse )  ;", "assertThat ( setResponse . getTransientSettings (  )  . get ( transientSettingKey )  ,    notNullValue (  )  )  ;", "assertThat ( setResponse . getTransientSettings (  )  . get ( persistentSettingKey )  ,    nullValue (  )  )  ;", "assertThat ( setResponse . getTransientSettings (  )  . get ( transientSettingKey )  ,    equalTo (  ( transientSettingValue    +     ( BYTES . getSuffix (  )  )  )  )  )  ;", "assertThat ( setResponse . getPersistentSettings (  )  . get ( transientSettingKey )  ,    nullValue (  )  )  ;", "assertThat ( setResponse . getPersistentSettings (  )  . get ( persistentSettingKey )  ,    notNullValue (  )  )  ;", "assertThat ( setResponse . getPersistentSettings (  )  . get ( persistentSettingKey )  ,    equalTo ( persistentSettingValue )  )  ;", "Map < String ,    Object >    setMap    =    getAsMap (  \"  /  _ cluster / settings \"  )  ;", "String   transientSetValue    =     (  ( String )     ( XContentMapValues . extractValue (  (  \" transient .  \"     +    transientSettingKey )  ,    setMap )  )  )  ;", "assertThat ( transientSetValue ,    equalTo (  ( transientSettingValue    +     ( BYTES . getSuffix (  )  )  )  )  )  ;", "String   persistentSetValue    =     (  ( String )     ( XContentMapValues . extractValue (  (  \" persistent .  \"     +    persistentSettingKey )  ,    setMap )  )  )  ;", "assertThat ( persistentSetValue ,    equalTo ( persistentSettingValue )  )  ;", "UpdateSettingsRequest   resetRequest    =    new   UpdateSettingsRequest (  )  ;", "resetRequest . transientSettings ( Settings . builder (  )  . putNull ( transientSettingKey )  )  ;", "resetRequest . persistentSettings (  (  (  \"  {  \\  \"  \"     +    persistentSettingKey )     +     \"  \\  \"  :    null    }  \"  )  ,    JSON )  ;", "UpdateSettingsResponse   resetResponse    =    ESRestHighLevelClientTestCase . execute ( resetRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . cluster (  )  :  : putSettings ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . cluster (  )  :  : putSettingsAsync )  ;", "assertThat ( resetResponse . getTransientSettings (  )  . get ( transientSettingKey )  ,    equalTo ( null )  )  ;", "assertThat ( resetResponse . getPersistentSettings (  )  . get ( persistentSettingKey )  ,    equalTo ( null )  )  ;", "assertThat ( resetResponse . getTransientSettings (  )  ,    equalTo ( EMPTY )  )  ;", "assertThat ( resetResponse . getPersistentSettings (  )  ,    equalTo ( EMPTY )  )  ;", "Map < String ,    Object >    resetMap    =    getAsMap (  \"  /  _ cluster / settings \"  )  ;", "String   transientResetValue    =     (  ( String )     ( XContentMapValues . extractValue (  (  \" transient .  \"     +    transientSettingKey )  ,    resetMap )  )  )  ;", "assertThat ( transientResetValue ,    equalTo ( null )  )  ;", "String   persistentResetValue    =     (  ( String )     ( XContentMapValues . extractValue (  (  \" persistent .  \"     +    persistentSettingKey )  ,    resetMap )  )  )  ;", "assertThat ( persistentResetValue ,    equalTo ( null )  )  ;", "}", "METHOD_END"], "methodName": ["testClusterPutSettings"], "fileName": "org.elasticsearch.client.ClusterClientIT"}, {"methodBody": ["METHOD_START", "{", "String   setting    =     \" no _ idea _ what _ you _ are _ talking _ about \"  ;", "int   value    =     1  0  ;", "ClusterUpdateSettingsRequest   clusterUpdateSettingsRequest    =    new   ClusterUpdateSettingsRequest (  )  ;", "clusterUpdateSettingsRequest . transientSettings ( Settings . builder (  )  . put ( setting ,    value )  . build (  )  )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( clusterUpdateSettingsRequest ,    highLevelClient (  )  . cluster (  )  :  : putSettings ,    highLevelClient (  )  . cluster (  )  :  : putSettingsAsync )  )  ;", "assertThat ( exception . status (  )  ,    equalTo ( BAD _ REQUEST )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  (  (  \" E   exception    [ type = illegal _ argument _ exception ,    reason = transient   setting    [  \"     +    setting )     +     \"  ]  ,    not   recognized ]  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClusterUpdateSettingNonExistent"], "fileName": "org.elasticsearch.client.ClusterClientIT"}, {"methodBody": ["METHOD_START", "{", "int   nbItems    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "boolean [  ]    errors    =    new   boolean [ nbItems ]  ;", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "for    ( int   i    =     0  ;    i    <    nbItems ;    i +  +  )     {", "String   id    =    String . valueOf ( i )  ;", "boolean   erroneous    =    randomBoolean (  )  ;", "errors [ i ]     =    erroneous ;", "DocWriteRequest . OpType   opType    =    randomFrom ( OpType . values (  )  )  ;", "if    ( opType    =  =     ( OpType . DELETE )  )     {", "if    ( erroneous    =  =    false )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source (  \" field \"  ,     (  -  1  )  )  )  . status (  )  )  ;", "}", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" test \"  ,    id )  ;", "bulkRequest . add ( deleteRequest )  ;", "} else    {", "BytesReference   source    =    BytesReference . bytes ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" id \"  ,    i )  . endObject (  )  )  ;", "if    ( opType    =  =     ( OpType . INDEX )  )     {", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source ( source ,    xContentType )  ;", "if    ( erroneous )     {", "indexRequest . version (  1  2 L )  ;", "}", "bulkRequest . add ( indexRequest )  ;", "} else", "if    ( opType    =  =     ( OpType . CREATE )  )     {", "IndexRequest   createRequest    =    new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source ( source ,    xContentType )  . create ( true )  ;", "if    ( erroneous )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( createRequest )  . status (  )  )  ;", "}", "bulkRequest . add ( createRequest )  ;", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "action . update . UpdateRequest   updateRequest    =    new   action . update . UpdateRequest (  \" index \"  ,     \" test \"  ,    id )  . doc ( new   IndexRequest (  )  . source ( source ,    xContentType )  )  ;", "if    ( erroneous    =  =    false )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source (  \" field \"  ,     (  -  1  )  )  )  . status (  )  )  ;", "}", "bulkRequest . add ( updateRequest )  ;", "}", "}", "}", "BulkResponse   bulkResponse    =    ESRestHighLevelClientTestCase . execute ( bulkRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : bulk ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : bulkAsync )  ;", "assertEquals ( OK ,    bulkResponse . status (  )  )  ;", "assertTrue (  (  ( bulkResponse . getTook (  )  . getMillis (  )  )     >     0  )  )  ;", "assertEquals ( nbItems ,    bulkResponse . getItems (  )  . length )  ;", "validateBulkResponses ( nbItems ,    errors ,    bulkResponse ,    bulkRequest )  ;", "}", "METHOD_END"], "methodName": ["testBulk"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "int   nbItems    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "boolean [  ]    errors    =    new   boolean [ nbItems ]  ;", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "AtomicReference < BulkResponse >    responseRef    =    new   AtomicReference <  >  (  )  ;", "AtomicReference < BulkRequest >    requestRef    =    new   AtomicReference <  >  (  )  ;", "AtomicReference < Throwable >    error    =    new   AtomicReference <  >  (  )  ;", "BulkProcessor . Listener   listener    =    new   BulkProcessor . Listener (  )     {", "@ Override", "public   void   beforeBulk ( long   executionId ,    BulkRequest   request )     {", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    BulkResponse   response )     {", "responseRef . set ( response )  ;", "requestRef . set ( request )  ;", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    Throwable   failure )     {", "error . set ( failure )  ;", "}", "}  ;", "RestHighLevelClient   hlClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "try    ( BulkProcessor   processor    =    BulkProcessor . builder ( hlClient :  : bulkAsync ,    listener )  . setConcurrentRequests (  0  )  . setBulkSize ( new   ommon . unit . ByteSizeValue (  5  ,    ByteSizeUnit . GB )  )  . setBulkActions (  ( nbItems    +     1  )  )  . build (  )  )     {", "for    ( int   i    =     0  ;    i    <    nbItems ;    i +  +  )     {", "String   id    =    String . valueOf ( i )  ;", "boolean   erroneous    =    randomBoolean (  )  ;", "errors [ i ]     =    erroneous ;", "DocWriteRequest . OpType   opType    =    randomFrom ( OpType . values (  )  )  ;", "if    ( opType    =  =     ( OpType . DELETE )  )     {", "if    ( erroneous    =  =    false )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source (  \" field \"  ,     (  -  1  )  )  )  . status (  )  )  ;", "}", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" test \"  ,    id )  ;", "processor . add ( deleteRequest )  ;", "} else    {", "if    ( opType    =  =     ( OpType . INDEX )  )     {", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source ( xContentType ,     \" id \"  ,    i )  ;", "if    ( erroneous )     {", "indexRequest . version (  1  2 L )  ;", "}", "processor . add ( indexRequest )  ;", "} else", "if    ( opType    =  =     ( OpType . CREATE )  )     {", "IndexRequest   createRequest    =    new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source ( xContentType ,     \" id \"  ,    i )  . create ( true )  ;", "if    ( erroneous )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( createRequest )  . status (  )  )  ;", "}", "processor . add ( createRequest )  ;", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" test \"  ,    id )  . doc ( new   IndexRequest (  )  . source ( xContentType ,     \" id \"  ,    i )  )  ;", "if    ( erroneous    =  =    false )     {", "assertEquals ( CREATED ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" test \"  ,    id )  . source (  \" field \"  ,     (  -  1  )  )  )  . status (  )  )  ;", "}", "processor . add ( updateRequest )  ;", "}", "}", "}", "assertNull ( responseRef . get (  )  )  ;", "assertNull ( requestRef . get (  )  )  ;", "}", "BulkResponse   bulkResponse    =    responseRef . get (  )  ;", "BulkRequest   bulkRequest    =    requestRef . get (  )  ;", "assertEquals ( OK ,    bulkResponse . status (  )  )  ;", "assertTrue (  (  ( bulkResponse . getTook (  )  . getMillis (  )  )     >     0  )  )  ;", "assertEquals ( nbItems ,    bulkResponse . getItems (  )  . length )  ;", "assertNull ( error . get (  )  )  ;", "validateBulkResponses ( nbItems ,    errors ,    bulkResponse ,    bulkRequest )  ;", "}", "METHOD_END"], "methodName": ["testBulkProcessorIntegration"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   docId    =     \" id \"  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  . source ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  )  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  ;", "if    ( randomBoolean (  )  )     {", "deleteRequest . version (  1 L )  ;", "}", "DeleteResponse   deleteResponse    =    ESRestHighLevelClientTestCase . execute ( deleteRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : delete ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : deleteAsync )  ;", "assertEquals (  \" index \"  ,    deleteResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    deleteResponse . getType (  )  )  ;", "assertEquals ( docId ,    deleteResponse . getId (  )  )  ;", "assertEquals ( DELETED ,    deleteResponse . getResult (  )  )  ;", "}", "{", "String   docId    =     \" does _ not _ exist \"  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  ;", "DeleteResponse   deleteResponse    =    ESRestHighLevelClientTestCase . execute ( deleteRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : delete ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : deleteAsync )  ;", "assertEquals (  \" index \"  ,    deleteResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    deleteResponse . getType (  )  )  ;", "assertEquals ( docId ,    deleteResponse . getId (  )  )  ;", "assertEquals ( NOT _ FOUND ,    deleteResponse . getResult (  )  )  ;", "}", "{", "String   docId    =     \" version _ conflict \"  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  . source ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  )  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  . version (  2  )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( deleteRequest ,    highLevelClient (  )  :  : delete ,    highLevelClient (  )  :  : deleteAsync )  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  (  (  \" E   exception    [ type = version _ conflict _ engine _ exception ,    reason =  [ type ]  [  \"     +    docId )     +     \"  ]  :     \"  )     +     \" version   conflict ,    current   version    [  1  ]    is   different   than   the   one   provided    [  2  ]  ]  \"  )  ,    exception . getMessage (  )  )  ;", "assertEquals (  \" index \"  ,    exception . getMetadata (  \" es . index \"  )  . get (  0  )  )  ;", "}", "{", "String   docId    =     \" version _ type \"  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  . source ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  . versionType ( EXTERNAL )  . version (  1  2  )  )  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  . versionType ( EXTERNAL )  . version (  1  3  )  ;", "DeleteResponse   deleteResponse    =    ESRestHighLevelClientTestCase . execute ( deleteRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : delete ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : deleteAsync )  ;", "assertEquals (  \" index \"  ,    deleteResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    deleteResponse . getType (  )  )  ;", "assertEquals ( docId ,    deleteResponse . getId (  )  )  ;", "assertEquals ( DELETED ,    deleteResponse . getResult (  )  )  ;", "}", "{", "String   docId    =     \" wrong _ version \"  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  . source ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  . versionType ( EXTERNAL )  . version (  1  2  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >     {", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  . versionType ( VersionType . EXTERNAL )  . version (  1  0  )  ;", "execute ( deleteRequest ,    highLevelClient (  )  :  : delete ,    highLevelClient (  )  :  : deleteAsync )  ;", "}  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  (  \" E   exception    [ type = version _ conflict _ engine _ exception ,    reason =  [ type ]  [  \"     +    docId )     +     \"  ]  :    version   conflict ,    current   version    [  1  2  ]    is   higher   or   equal   to   the   one   provided    [  1  0  ]  ]  \"  )  ,    exception . getMessage (  )  )  ;", "assertEquals (  \" index \"  ,    exception . getMetadata (  \" es . index \"  )  . get (  0  )  )  ;", "}", "{", "String   docId    =     \" routing \"  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  . source ( Collections . singletonMap (  \" foo \"  ,     \" bar \"  )  )  . routing (  \" foo \"  )  )  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest (  \" index \"  ,     \" type \"  ,    docId )  . routing (  \" foo \"  )  ;", "DeleteResponse   deleteResponse    =    ESRestHighLevelClientTestCase . execute ( deleteRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : delete ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : deleteAsync )  ;", "assertEquals (  \" index \"  ,    deleteResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    deleteResponse . getType (  )  )  ;", "assertEquals ( docId ,    deleteResponse . getId (  )  )  ;", "assertEquals ( DELETED ,    deleteResponse . getResult (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDelete"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "assertFalse ( ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : existsAsync )  )  ;", "}", "String   document    =     \"  {  \\  \" field 1  \\  \"  :  \\  \" value 1  \\  \"  ,  \\  \" field 2  \\  \"  :  \\  \" value 2  \\  \"  }  \"  ;", "StringEntity   stringEntity    =    new   StringEntity ( document ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =     (  )  . performRequest ( METHOD _ NAME ,     \"  / index / type / id \"  ,    Collections . singletonMap (  \" refresh \"  ,     \" wait _ for \"  )  ,    stringEntity )  ;", "assertEquals (  2  0  1  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "assertTrue ( ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : existsAsync )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" does _ not _ exist \"  )  ;", "assertFalse ( ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : existsAsync )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" does _ not _ exist \"  )  . version (  1  )  ;", "assertFalse ( ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : existsAsync )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "ElasticsearchException   exception    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    execute ( getRequest ,    highLevelClient (  )  :  : get ,    highLevelClient (  )  :  : getAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  ,    exception . getMessage (  )  )  ;", "assertEquals (  \" index \"  ,    exception . getMetadata (  \" es . index \"  )  . get (  0  )  )  ;", "}", "String   document    =     \"  {  \\  \" field 1  \\  \"  :  \\  \" value 1  \\  \"  ,  \\  \" field 2  \\  \"  :  \\  \" value 2  \\  \"  }  \"  ;", "StringEntity   stringEntity    =    new   StringEntity ( document ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    client (  )  . performRequest ( METHOD _ NAME ,     \"  / index / type / id \"  ,    Collections . singletonMap (  \" refresh \"  ,     \" wait _ for \"  )  ,    stringEntity )  ;", "assertEquals (  2  0  1  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  . version (  2  )  ;", "ElasticsearchException   exception    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    execute ( getRequest ,    highLevelClient (  )  :  : get ,    highLevelClient (  )  :  : getAsync )  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  \" Elasticsearch   exception    [ type = version _ conflict _ engine _ exception ,     \"     +     (  \" reason =  [ type ]  [ id ]  :     \"     +     \" version   conflict ,    current   version    [  1  ]    is   different   than   the   one   provided    [  2  ]  ]  \"  )  )  ,    exception . getMessage (  )  )  ;", "assertEquals (  \" index \"  ,    exception . getMetadata (  \" es . index \"  )  . get (  0  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "if    ( randomBoolean (  )  )     {", "getRequest . version (  1 L )  ;", "}", "GetResponse   getResponse    =    ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : get ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : getAsync )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    getResponse . getId (  )  )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertFalse ( getResponse . isSourceEmpty (  )  )  ;", "assertEquals (  1 L ,    getResponse . getVersion (  )  )  ;", "assertEquals ( document ,    getResponse . getSourceAsString (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" does _ not _ exist \"  )  ;", "GetResponse   getResponse    =    ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : get ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : getAsync )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" does _ not _ exist \"  ,    getResponse . getId (  )  )  ;", "assertFalse ( getResponse . isExists (  )  )  ;", "assertEquals (  (  -  1  )  ,    getResponse . getVersion (  )  )  ;", "assertTrue ( getResponse . isSourceEmpty (  )  )  ;", "assertNull ( getResponse . getSourceAsString (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "getRequest . fetchSourceContext ( new   search . fetch . subphase . FetchSourceContext ( false ,    Strings . EMPTY _ ARRAY ,    Strings . EMPTY _ ARRAY )  )  ;", "GetResponse   getResponse    =    ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : get ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : getAsync )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    getResponse . getId (  )  )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertTrue ( getResponse . isSourceEmpty (  )  )  ;", "assertEquals (  1 L ,    getResponse . getVersion (  )  )  ;", "assertNull ( getResponse . getSourceAsString (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "if    ( randomBoolean (  )  )     {", "getRequest . fetchSourceContext ( new   search . fetch . subphase . FetchSourceContext ( true ,    new   String [  ]  {     \" field 1  \"     }  ,    Strings . EMPTY _ ARRAY )  )  ;", "} else    {", "getRequest . fetchSourceContext ( new   search . fetch . subphase . FetchSourceContext ( true ,    Strings . EMPTY _ ARRAY ,    new   String [  ]  {     \" field 2  \"     }  )  )  ;", "}", "GetResponse   getResponse    =    ESRestHighLevelClientTestCase . execute ( getRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : get ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : getAsync )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    getResponse . getId (  )  )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertFalse ( getResponse . isSourceEmpty (  )  )  ;", "assertEquals (  1 L ,    getResponse . getVersion (  )  )  ;", "Map < String ,    Object >    sourceAsMap    =    getResponse . getSourceAsMap (  )  ;", "assertEquals (  1  ,    sourceAsMap . size (  )  )  ;", "assertEquals (  \" value 1  \"  ,    sourceAsMap . get (  \" field 1  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGet"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "final   XContentType   xContentType    =    randomFrom ( XContentType . values (  )  )  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" test \"  ,     \" test \"  )  . endObject (  )  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . execute ( indexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : index ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : indexAsync )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals ( DocWriteResponse . Result . CREATED ,    indexResponse . getResult (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertTrue ( Strings . hasLength ( indexResponse . getId (  )  )  )  ;", "assertEquals (  1 L ,    indexResponse . getVersion (  )  )  ;", "assertNotNull ( indexResponse . getShardId (  )  )  ;", "assertEquals (  (  -  1  )  ,    indexResponse . getShardId (  )  . getId (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getShardId (  )  . getIndexName (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getShardId (  )  . getIndex (  )  . getName (  )  )  ;", "assertEquals (  \"  _ na _  \"  ,    indexResponse . getShardId (  )  . getIndex (  )  . getUUID (  )  )  ;", "assertNotNull ( indexResponse . getShardInfo (  )  )  ;", "assertEquals (  0  ,    indexResponse . getShardInfo (  )  . getFailed (  )  )  ;", "assertTrue (  (  ( indexResponse . getShardInfo (  )  . getSuccessful (  )  )     >     0  )  )  ;", "assertTrue (  (  ( indexResponse . getShardInfo (  )  . getTotal (  )  )     >     0  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" version \"  ,     1  )  . endObject (  )  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . execute ( indexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : index ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : indexAsync )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    indexResponse . getId (  )  )  ;", "assertEquals (  1 L ,    indexResponse . getVersion (  )  )  ;", "indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" version \"  ,     2  )  . endObject (  )  )  ;", "indexResponse    =    ESRestHighLevelClientTestCase . execute ( indexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : index ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : indexAsync )  ;", "assertEquals ( OK ,    indexResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    indexResponse . getId (  )  )  ;", "assertEquals (  2 L ,    indexResponse . getVersion (  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >     {", "IndexRequest   wrongRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "wrongRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" field \"  ,     \" test \"  )  . endObject (  )  )  ;", "wrongRequest . version (  5 L )  ;", "execute ( wrongRequest ,    highLevelClient (  )  :  : index ,    highLevelClient (  )  :  : indexAsync )  ;", "}  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  \" E   exception    [ type = version _ conflict _ engine _ exception ,    reason =  [ type ]  [ id ]  :     \"     +     \" version   conflict ,    current   version    [  2  ]    is   different   than   the   one   provided    [  5  ]  ]  \"  )  ,    exception . getMessage (  )  )  ;", "assertEquals (  \" index \"  ,    exception . getMetadata (  \" es . index \"  )  . get (  0  )  )  ;", "}", "{", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >     {", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" missing _ pipeline \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" field \"  ,     \" test \"  )  . endObject (  )  )  ;", "indexRequest . setPipeline (  \" missing \"  )  ;", "execute ( indexRequest ,    highLevelClient (  )  :  : index ,    highLevelClient (  )  :  : indexAsync )  ;", "}  )  ;", "assertEquals ( BAD _ REQUEST ,    exception . status (  )  )  ;", "assertEquals (  (  \" E   exception    [ type = illegal _ argument _ exception ,     \"     +     \" reason = pipeline   with   id    [ missing ]    does   not   exist ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" external _ version _ type \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" field \"  ,     \" test \"  )  . endObject (  )  )  ;", "indexRequest . version (  1  2 L )  ;", "indexRequest . versionType ( EXTERNAL )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . execute ( indexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : index ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : indexAsync )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" external _ version _ type \"  ,    indexResponse . getId (  )  )  ;", "assertEquals (  1  2 L ,    indexResponse . getVersion (  )  )  ;", "}", "{", "final   IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" with _ create _ op _ type \"  )  ;", "indexRequest . source ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . field (  \" field \"  ,     \" test \"  )  . endObject (  )  )  ;", "indexRequest . opType ( CREATE )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . execute ( indexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : index ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : indexAsync )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" with _ create _ op _ type \"  ,    indexResponse . getId (  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >     {", "execute ( indexRequest ,    highLevelClient (  )  :  : index ,    highLevelClient (  )  :  : indexAsync )  ;", "}  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  \" E   exception    [ type = version _ conflict _ engine _ exception ,    reason =  [ type ]  [ with _ create _ op _ type ]  :     \"     +     \" version   conflict ,    document   already   exists    ( current   version    [  1  ]  )  ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndex"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "{", "MultiGetRequest   multiGetRequest    =    new   MultiGetRequest (  )  ;", "multiGetRequest . add (  \" index \"  ,     \" type \"  ,     \" id 1  \"  )  ;", "multiGetRequest . add (  \" index \"  ,     \" type \"  ,     \" id 2  \"  )  ;", "MultiGetResponse   response    =    ESRestHighLevelClientTestCase . execute ( multiGetRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiGet ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiGetAsync )  ;", "assertEquals (  2  ,    response . getResponses (  )  . length )  ;", "assertTrue ( response . getResponses (  )  [  0  ]  . isFailed (  )  )  ;", "assertNull ( response . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertEquals (  \" id 1  \"  ,    response . getResponses (  )  [  0  ]  . getFailure (  )  . getId (  )  )  ;", "assertEquals (  \" type \"  ,    response . getResponses (  )  [  0  ]  . getFailure (  )  . getType (  )  )  ;", "assertEquals (  \" index \"  ,    response . getResponses (  )  [  0  ]  . getFailure (  )  . getIndex (  )  )  ;", "assertEquals (  \" E   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  ,    response . getResponses (  )  [  0  ]  . getFailure (  )  . getFailure (  )  . getMessage (  )  )  ;", "assertTrue ( response . getResponses (  )  [  1  ]  . isFailed (  )  )  ;", "assertNull ( response . getResponses (  )  [  1  ]  . getResponse (  )  )  ;", "assertEquals (  \" id 2  \"  ,    response . getResponses (  )  [  1  ]  . getId (  )  )  ;", "assertEquals (  \" type \"  ,    response . getResponses (  )  [  1  ]  . getType (  )  )  ;", "assertEquals (  \" index \"  ,    response . getResponses (  )  [  1  ]  . getIndex (  )  )  ;", "assertEquals (  \" E   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  ,    response . getResponses (  )  [  1  ]  . getFailure (  )  . getFailure (  )  . getMessage (  )  )  ;", "}", "String   document    =     \"  {  \\  \" field \\  \"  :  \\  \" value 1  \\  \"  }  \"  ;", "StringEntity   stringEntity    =    new   StringEntity ( document ,    ContentType . APPLICATION _ JSON )  ;", "Response   r    =    client (  )  . performRequest ( METHOD _ NAME ,     \"  / index / type / id 1  \"  ,    Collections . singletonMap (  \" refresh \"  ,     \" true \"  )  ,    stringEntity )  ;", "assertEquals (  2  0  1  ,    r . getStatusLine (  )  . getStatusCode (  )  )  ;", "document    =     \"  {  \\  \" field \\  \"  :  \\  \" value 2  \\  \"  }  \"  ;", "stringEntity    =    new   StringEntity ( document ,    ContentType . APPLICATION _ JSON )  ;", "r    =    client (  )  . performRequest ( METHOD _ NAME ,     \"  / index / type / id 2  \"  ,    Collections . singletonMap (  \" refresh \"  ,     \" true \"  )  ,    stringEntity )  ;", "assertEquals (  2  0  1  ,    r . getStatusLine (  )  . getStatusCode (  )  )  ;", "{", "MultiGetRequest   multiGetRequest    =    new   MultiGetRequest (  )  ;", "multiGetRequest . add (  \" index \"  ,     \" type \"  ,     \" id 1  \"  )  ;", "multiGetRequest . add (  \" index \"  ,     \" type \"  ,     \" id 2  \"  )  ;", "MultiGetResponse   response    =    ESRestHighLevelClientTestCase . execute ( multiGetRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiGet ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiGetAsync )  ;", "assertEquals (  2  ,    response . getResponses (  )  . length )  ;", "assertFalse ( response . getResponses (  )  [  0  ]  . isFailed (  )  )  ;", "assertNull ( response . getResponses (  )  [  0  ]  . getFailure (  )  )  ;", "assertEquals (  \" id 1  \"  ,    response . getResponses (  )  [  0  ]  . getId (  )  )  ;", "assertEquals (  \" type \"  ,    response . getResponses (  )  [  0  ]  . getType (  )  )  ;", "assertEquals (  \" index \"  ,    response . getResponses (  )  [  0  ]  . getIndex (  )  )  ;", "assertEquals ( Collections . singletonMap (  \" field \"  ,     \" value 1  \"  )  ,    response . getResponses (  )  [  0  ]  . getResponse (  )  . getSource (  )  )  ;", "assertFalse ( response . getResponses (  )  [  1  ]  . isFailed (  )  )  ;", "assertNull ( response . getResponses (  )  [  1  ]  . getFailure (  )  )  ;", "assertEquals (  \" id 2  \"  ,    response . getResponses (  )  [  1  ]  . getId (  )  )  ;", "assertEquals (  \" type \"  ,    response . getResponses (  )  [  1  ]  . getType (  )  )  ;", "assertEquals (  \" index \"  ,    response . getResponses (  )  [  1  ]  . getIndex (  )  )  ;", "assertEquals ( Collections . singletonMap (  \" field \"  ,     \" value 2  \"  )  ,    response . getResponses (  )  [  1  ]  . getResponse (  )  . getSource (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMultiGet"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "String   routing    =     \" routing /  \u00d6\u00d0  \u00ce\u00c4 value #  1  ?  \"  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "indexRequest . source (  \" field \"  ,     \" value \"  )  ;", "indexRequest . routing ( routing )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . index ( indexRequest )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    indexResponse . getId (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  . routing ( routing )  ;", "GetResponse   getResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . get ( getRequest )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" id \"  ,    getResponse . getId (  )  )  ;", "assertEquals ( routing ,    getResponse . getField (  \"  _ routing \"  )  . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParamsEncode"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "{", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" does _ not _ exist \"  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    randomFrom ( XContentType . values (  )  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >    execute ( updateRequest ,    highLevelClient (  )  :  : update ,    highLevelClient (  )  :  : updateAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "assertEquals (  \" E   exception    [ type = document _ missing _ exception ,    reason =  [ type ]  [ does _ not _ exist ]  :    document   missing ]  \"  ,    exception . getMessage (  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "indexRequest . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( indexRequest )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" field \"  ,     \" updated \"  )  ,    randomFrom ( XContentType . values (  )  )  )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( OK ,    updateResponse . status (  )  )  ;", "assertEquals (  (  ( indexResponse . getVersion (  )  )     +     1  )  ,    updateResponse . getVersion (  )  )  ;", "UpdateRequest   updateRequestConflict    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "updateRequestConflict . doc ( Collections . singletonMap (  \" field \"  ,     \" with _ version _ conflict \"  )  ,    randomFrom ( XContentType . values (  )  )  )  ;", "updateRequestConflict . version ( indexResponse . getVersion (  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >    execute ( updateRequestConflict ,    highLevelClient (  )  :  : update ,    highLevelClient (  )  :  : updateAsync )  )  ;", "assertEquals ( CONFLICT ,    exception . status (  )  )  ;", "assertEquals (  (  \" E   exception    [ type = version _ conflict _ engine _ exception ,    reason =  [ type ]  [ id ]  :    version   conflict ,     \"     +     \" current   version    [  2  ]    is   different   than   the   one   provided    [  1  ]  ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" with _ script \"  )  ;", "indexRequest . source ( Collections . singletonMap (  \" counter \"  ,     1  2  )  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( indexRequest )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" with _ script \"  )  ;", "Script   script    =    new   Script ( ScriptType . INLINE ,     \" painless \"  ,     \" ctx .  _ source . counter    +  =    params . count \"  ,    Collections . singletonMap (  \" count \"  ,     8  )  )  ;", "updateRequest . script ( script )  ;", "updateRequest . fetchSource ( true )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( OK ,    updateResponse . status (  )  )  ;", "assertEquals ( UPDATED ,    updateResponse . getResult (  )  )  ;", "assertEquals (  2 L ,    updateResponse . getVersion (  )  )  ;", "assertEquals (  2  0  ,    updateResponse . getGetResult (  )  . sourceAsMap (  )  . get (  \" counter \"  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" with _ doc \"  )  ;", "indexRequest . source (  \" field _  1  \"  ,     \" one \"  ,     \" field _  3  \"  ,     \" three \"  )  ;", "indexRequest . version (  1  2 L )  ;", "indexRequest . versionType ( EXTERNAL )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( indexRequest )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals (  1  2 L ,    indexResponse . getVersion (  )  )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" with _ doc \"  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" field _  2  \"  ,     \" two \"  )  ,    randomFrom ( XContentType . values (  )  )  )  ;", "updateRequest . fetchSource (  \" field _  *  \"  ,     \" field _  3  \"  )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( OK ,    updateResponse . status (  )  )  ;", "assertEquals ( UPDATED ,    updateResponse . getResult (  )  )  ;", "assertEquals (  1  3 L ,    updateResponse . getVersion (  )  )  ;", "GetResult   getResult    =    updateResponse . getGetResult (  )  ;", "assertEquals (  1  3 L ,    updateResponse . getVersion (  )  )  ;", "Map < String ,    Object >    sourceAsMap    =    getResult . sourceAsMap (  )  ;", "assertEquals (  \" one \"  ,    sourceAsMap . get (  \" field _  1  \"  )  )  ;", "assertEquals (  \" two \"  ,    sourceAsMap . get (  \" field _  2  \"  )  )  ;", "assertFalse ( sourceAsMap . containsKey (  \" field _  3  \"  )  )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" noop \"  )  ;", "indexRequest . source (  \" field \"  ,     \" value \"  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( indexRequest )  ;", "assertEquals ( CREATED ,    indexResponse . status (  )  )  ;", "assertEquals (  1 L ,    indexResponse . getVersion (  )  )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" noop \"  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    randomFrom ( XContentType . values (  )  )  )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( OK ,    updateResponse . status (  )  )  ;", "assertEquals ( NOOP ,    updateResponse . getResult (  )  )  ;", "assertEquals (  1 L ,    updateResponse . getVersion (  )  )  ;", "updateRequest . detectNoop ( false )  ;", "updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( OK ,    updateResponse . status (  )  )  ;", "assertEquals ( UPDATED ,    updateResponse . getResult (  )  )  ;", "assertEquals (  2 L ,    updateResponse . getVersion (  )  )  ;", "}", "{", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" with _ upsert \"  )  ;", "updateRequest . upsert ( Collections . singletonMap (  \" doc _ status \"  ,     \" created \"  )  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" doc _ status \"  ,     \" updated \"  )  )  ;", "updateRequest . fetchSource ( true )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( CREATED ,    updateResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    updateResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    updateResponse . getType (  )  )  ;", "assertEquals (  \" with _ upsert \"  ,    updateResponse . getId (  )  )  ;", "GetResult   getResult    =    updateResponse . getGetResult (  )  ;", "assertEquals (  1 L ,    updateResponse . getVersion (  )  )  ;", "assertEquals (  \" created \"  ,    getResult . sourceAsMap (  )  . get (  \" doc _ status \"  )  )  ;", "}", "{", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" with _ doc _ as _ upsert \"  )  ;", "updateRequest . doc ( Collections . singletonMap (  \" field \"  ,     \" initialized \"  )  )  ;", "updateRequest . fetchSource ( true )  ;", "updateRequest . docAsUpsert ( true )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( CREATED ,    updateResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    updateResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    updateResponse . getType (  )  )  ;", "assertEquals (  \" with _ doc _ as _ upsert \"  ,    updateResponse . getId (  )  )  ;", "GetResult   getResult    =    updateResponse . getGetResult (  )  ;", "assertEquals (  1 L ,    updateResponse . getVersion (  )  )  ;", "assertEquals (  \" initialized \"  ,    getResult . sourceAsMap (  )  . get (  \" field \"  )  )  ;", "}", "{", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" with _ scripted _ upsert \"  )  ;", "updateRequest . fetchSource ( true )  ;", "updateRequest . script ( new   Script ( ScriptType . INLINE ,     \" painless \"  ,     \" ctx .  _ source . level    =    params . test \"  ,    Collections . singletonMap (  \" test \"  ,     \" C \"  )  )  )  ;", "updateRequest . scriptedUpsert ( true )  ;", "updateRequest . upsert ( Collections . singletonMap (  \" level \"  ,     \" A \"  )  )  ;", "UpdateResponse   updateResponse    =    ESRestHighLevelClientTestCase . execute ( updateRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : update ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : updateAsync )  ;", "assertEquals ( CREATED ,    updateResponse . status (  )  )  ;", "assertEquals (  \" index \"  ,    updateResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    updateResponse . getType (  )  )  ;", "assertEquals (  \" with _ scripted _ upsert \"  ,    updateResponse . getId (  )  )  ;", "GetResult   getResult    =    updateResponse . getGetResult (  )  ;", "assertEquals (  1 L ,    updateResponse . getVersion (  )  )  ;", "assertEquals (  \" C \"  ,    getResult . sourceAsMap (  )  . get (  \" level \"  )  )  ;", "}", "{", "IllegalStateException   exception    =    expectThrows ( IllegalStateException . class ,     (  )     -  >     {", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \" id \"  )  ;", "updateRequest . doc ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" doc \"  )  ,    XContentType . JSON )  )  ;", "updateRequest . upsert ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" upsert \"  )  ,    XContentType . YAML )  )  ;", "execute ( updateRequest ,    highLevelClient (  )  :  : update ,    highLevelClient (  )  :  : updateAsync )  ;", "}  )  ;", "assertEquals (  \" Update   request   cannot   have   different   content   types   for   doc    [ JSON ]    and   upsert    [ YAML ]    documents \"  ,    exception . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "String   indexPattern    =     \"  < logstash -  { now / M }  >  \"  ;", "String   expectedIndex    =     \" logstash -  \"     +     ( DateTimeFormat . forPattern (  \" YYYY . MM . dd \"  )  . print ( new   DateTime ( DateTimeZone . UTC )  . monthOfYear (  )  . roundFloorCopy (  )  )  )  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest ( indexPattern ,     \" type \"  ,     \" id #  1  \"  )  ;", "indexRequest . source (  \" field \"  ,     \" value \"  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . index ( indexRequest )  ;", "assertEquals ( expectedIndex ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals (  \" id #  1  \"  ,    indexResponse . getId (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest ( indexPattern ,     \" type \"  ,     \" id #  1  \"  )  ;", "GetResponse   getResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . get ( getRequest )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertEquals ( expectedIndex ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals (  \" id #  1  \"  ,    getResponse . getId (  )  )  ;", "}", "String   docId    =     \" this / is / the / id /  \u00d6\u00d0  \u00ce\u00c4  \"  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" index \"  ,     \" type \"  ,    docId )  ;", "indexRequest . source (  \" field \"  ,     \" value \"  )  ;", "IndexResponse   indexResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . index ( indexRequest )  ;", "assertEquals (  \" index \"  ,    indexResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    indexResponse . getType (  )  )  ;", "assertEquals ( docId ,    indexResponse . getId (  )  )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" index \"  ,     \" type \"  ,    docId )  ;", "GetResponse   getResponse    =    ESRestHighLevelCTestCase . highLevelC (  )  . get ( getRequest )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertEquals (  \" index \"  ,    getResponse . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    getResponse . getType (  )  )  ;", "assertEquals ( docId ,    getResponse . getId (  )  )  ;", "}", "assertTrue ( ESRestHighLevelCTestCase . highLevelC (  )  . indices (  )  . exists ( new   GetIndexRequest (  )  . indices ( indexPattern ,     \" index \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testUrlEncode"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <    nbItems ;    i +  +  )     {", "BulkItemResponse   bulkItemResponse    =    bulkResponse . getItems (  )  [ i ]  ;", "assertEquals ( i ,    bulkItemResponse . getItemId (  )  )  ;", "assertEquals (  \" index \"  ,    bulkItemResponse . getIndex (  )  )  ;", "assertEquals (  \" test \"  ,    bulkItemResponse . getType (  )  )  ;", "assertEquals ( String . valueOf ( i )  ,    bulkItemResponse . getId (  )  )  ;", "DocWriteRequest . OpType   requestOpType    =    bulkRequest . requests (  )  . get ( i )  . opType (  )  ;", "if    (  ( requestOpType    =  =     ( OpType . INDEX )  )     |  |     ( requestOpType    =  =     ( OpType . CREATE )  )  )     {", "assertEquals ( errors [ i ]  ,    bulkItemResponse . isFailed (  )  )  ;", "assertEquals (  ( errors [ i ]     ?    RestStatus . CONFLICT    :    RestStatus . CREATED )  ,    bulkItemResponse . status (  )  )  ;", "} else", "if    ( requestOpType    =  =     ( OpType . UPDATE )  )     {", "assertEquals ( errors [ i ]  ,    bulkItemResponse . isFailed (  )  )  ;", "assertEquals (  ( errors [ i ]     ?    RestStatus . NOT _ FOUND    :    RestStatus . OK )  ,    bulkItemResponse . status (  )  )  ;", "} else", "if    ( requestOpType    =  =     ( OpType . DELETE )  )     {", "assertFalse ( bulkItemResponse . isFailed (  )  )  ;", "assertEquals (  ( errors [ i ]     ?    RestStatus . NOT _ FOUND    :    RestStatus . OK )  ,    bulkItemResponse . status (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["validateBulkResponses"], "fileName": "org.elasticsearch.client.CrudIT"}, {"methodBody": ["METHOD_START", "{", "if    (  ( restHighLevelClient )     =  =    null )     {", "final   RestClient   restClient    =    mock ( RestClient . class )  ;", "restHighLevelClient    =    new    . CustomRestClient ( restClient )  ;", "doAnswer (  (    mock )     -  >    mockPerformRequest (  (  ( Header )     ( mock . getArguments (  )  [  4  ]  )  )  )  )  . when ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  . ENDPOINT )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  ;", "doAnswer (  (    mock )     -  >    mockPerformRequestAsync (  (  ( Header )     ( mock . getArguments (  )  [  5  ]  )  )  ,     (  ( ResponseListener )     ( mock . getArguments (  )  [  4  ]  )  )  )  )  . when ( restClient )  . performRequestAsync ( eq ( METHOD _ NAME )  ,    eq (  . ENDPOINT )  ,    anyMapOf ( String . class ,    String . class )  ,    any ( HttpEntity . class )  ,    any ( ResponseListener . class )  ,    anyVararg (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initClients"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "final   Response   mockResponse    =    mock ( Response . class )  ;", "when ( mockResponse . getHost (  )  )  . thenReturn ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  ;", "ProtocolVersion   protocol    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "when ( mockResponse . getStatusLine (  )  )  . thenReturn ( new   BasicStatusLine ( protocol ,     2  0  0  ,     \" OK \"  )  )  ;", "MainResponse   response    =    new   MainResponse ( httpHeader . getValue (  )  ,    Version . CURRENT ,    ClusterName . DEFAULT ,     \"  _ na \"  ,    Build . CURRENT )  ;", "BytesRef   bytesRef    =    XContentHelper . toXContent ( response ,    JSON ,    false )  . toBytesRef (  )  ;", "when ( mockResponse . getEntity (  )  )  . thenReturn ( new   ByteArrayEntity ( bytesRef . bytes ,    ContentType . APPLICATION _ JSON )  )  ;", "RequestLine   requestLine    =    new   BasicRequestLine ( HttpGet . METHOD _ NAME ,     . ENDPOINT ,    protocol )  ;", "when ( mockResponse . getRequestLine (  )  )  . thenReturn ( requestLine )  ;", "return   mockResponse ;", "}", "METHOD_END"], "methodName": ["mockPerformRequest"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "responseListener . onSuccess ( mockPerforquest ( httpHeader )  )  ;", "}    catch    ( IOException   e )     {", "responseListener . onFailure ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["mockPerformRequestAsync"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "final   MainRequest   request    =    new   MainRequest (  )  ;", "final   Header   header    =    new   BasicHeader (  \" node _ name \"  ,    randomAlphaOfLengthBetween (  1  ,     1  0  )  )  ;", "MainResponse   response    =    r . custom ( request ,    header )  ;", "assertEquals ( header . getValue (  )  ,    response . getNodeName (  )  )  ;", "response    =    r . customAndParse ( request ,    header )  ;", "assertEquals ( header . getValue (  )  ,    response . getNodeName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEndpoint"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "final   MainRequest   request    =    new   MainRequest (  )  ;", "final   Header   header    =    new   BasicHeader (  \" node _ name \"  ,    randomAlphaOfLengthBetween (  1  ,     1  0  )  )  ;", "PlainActionFuture < MainResponse >    future    =    PlainActionFuture . newFuture (  )  ;", "r . customAsync ( request ,    future ,    header )  ;", "assertEquals ( header . getValue (  )  ,    future . get (  )  . getNodeName (  )  )  ;", "future    =    PlainActionFuture . newFuture (  )  ;", "r . customAndParseAsync ( request ,    future ,    header )  ;", "assertEquals ( header . getValue (  )  ,    future . get (  )  . getNodeName (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCustomEndpointAsync"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    methodNames    =    new   String [  ]  {     \" performRequest \"  ,     \" performRequestAsync \"  ,     \" performRequestAndParseEntity \"  ,     \" performRequestAsyncAndParseEntity \"  ,     \" parseEntity \"  ,     \" parseResponseException \"     }  ;", "final   List < String >    protectedMethods    =    Arrays . stream (  . class . getDeclaredMethods (  )  )  . filter (  (    method )     -  >    Modifier . isProtected ( method . getModifiers (  )  )  )  . map ( Method :  : getName )  . collect ( Collectors . toList (  )  )  ;", "assertThat ( protectedMethods ,    containsInAnyOrder ( methodNames )  )  ;", "}", "METHOD_END"], "methodName": ["testMethodsVisibility"], "fileName": "org.elasticsearch.client.CustomRestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "return   deadUntilNanos ;", "}", "METHOD_END"], "methodName": ["getDeadUntilNanos"], "fileName": "org.elasticsearch.client.DeadHostState"}, {"methodBody": ["METHOD_START", "{", "return   failedAttempts ;", "}", "METHOD_END"], "methodName": ["getFailedAttempts"], "fileName": "org.elasticsearch.client.DeadHostState"}, {"methodBody": ["METHOD_START", "{", "return    (  ( timeSupplier . nanoTime (  )  )     -     ( deadUntilNanos )  )     >     0  ;", "}", "METHOD_END"], "methodName": ["shallBeRetried"], "fileName": "org.elasticsearch.client.DeadHostState"}, {"methodBody": ["METHOD_START", "{", "int   numObjects    =    randomIntBetween ( DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS . length ,     3  0  )  ;", "DeadHostState [  ]    deadHostStates    =    new   DeadHostState [ numObjects ]  ;", "for    ( int   i    =     0  ;    i    <    numObjects ;    i +  +  )     {", "if    ( i    =  =     0  )     {", "deadHostStates [ i ]     =    new   DeadHostState ( DeadHostState . TimeSupplier . DEFAULT )  ;", "} else    {", "deadHostStates [ i ]     =    new   DeadHostState ( deadHostStates [  ( i    -     1  )  ]  ,    DeadHostState . TimeSupplier . DEFAULT )  ;", "}", "}", "for    ( int   k    =     1  ;    k    <     ( deadHostStates . length )  ;    k +  +  )     {", "assertThat ( deadHostStates [  ( k    -     1  )  ]  . getDeadUntilNanos (  )  ,    lessThan ( deadHostStates [ k ]  . getDeadUntilNanos (  )  )  )  ;", "assertThat ( deadHostStates [  ( k    -     1  )  ]  ,    lessThan ( deadHostStates [ k ]  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCompareToDefaultTimeSupplier"], "fileName": "org.elasticsearch.client.DeadHostStateTests"}, {"methodBody": ["METHOD_START", "{", "DeadHostState   previous    =    new   DeadHostState ( DeadHostState . TimeSupplier . DEFAULT )  ;", "int   iters    =    randomIntBetween (  5  ,     3  0  )  ;", "for    ( int   i    =     0  ;    i    <    iters ;    i +  +  )     {", "DeadHostState   deadHostState    =    new   DeadHostState ( previous ,    DeadHostState . TimeSupplier . DEFAULT )  ;", "assertThat ( deadHostState . getDeadUntilNanos (  )  ,    greaterThan ( previous . getDeadUntilNanos (  )  )  )  ;", "assertThat ( deadHostState . getFailedAttempts (  )  ,    equalTo (  (  ( previous . getFailedAttempts (  )  )     +     1  )  )  )  ;", "previous    =    deadHostState ;", "}", "}", "METHOD_END"], "methodName": ["testDeadHostStateFromPreviousDefaultTimeSupplier"], "fileName": "org.elasticsearch.client.DeadHostStateTests"}, {"methodBody": ["METHOD_START", "{", "DeadHostStateTests . ConfigurableTimeSupplier   zeroTimeSupplier    =    new   DeadHostStateTests . ConfigurableTimeSupplier (  )  ;", "zeroTimeSupplier . nanoTime    =     0 L ;", "DeadHostState   previous    =    new   DeadHostState ( zeroTimeSupplier )  ;", "for    ( long   expectedTimeoutsSecond    :    DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS )     {", "assertThat ( TimeUnit . NANOSECONDS . toSeconds ( previous . getDeadUntilNanos (  )  )  ,    equalTo ( expectedTimeoutsSecond )  )  ;", "previous    =    new   DeadHostState ( previous ,    zeroTimeSupplier )  ;", "}", "int   iters    =    randomIntBetween (  5  ,     3  0  )  ;", "for    ( int   i    =     0  ;    i    <    iters ;    i +  +  )     {", "DeadHostState   deadHostState    =    new   DeadHostState ( previous ,    zeroTimeSupplier )  ;", "assertThat ( TimeUnit . NANOSECONDS . toSeconds ( deadHostState . getDeadUntilNanos (  )  )  ,    equalTo ( DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS [  (  ( DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS . length )     -     1  )  ]  )  )  ;", "previous    =    deadHostState ;", "}", "}", "METHOD_END"], "methodName": ["testDeadHostStateTimeouts"], "fileName": "org.elasticsearch.client.DeadHostStateTests"}, {"methodBody": ["METHOD_START", "{", "DeadHostState   deadHostState    =    new   DeadHostState ( DeadHostState . TimeSupplier . DEFAULT )  ;", "long   currentTime    =    System . nanoTime (  )  ;", "assertThat ( deadHostState . getDeadUntilNanos (  )  ,    greaterThan ( currentTime )  )  ;", "assertThat ( deadHostState . getFailedAttempts (  )  ,    equalTo (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["testInitialDeadHostStateDefaultTimeSupplier"], "fileName": "org.elasticsearch.client.DeadHostStateTests"}, {"methodBody": ["METHOD_START", "{", "DeadHostStateTests . ConfigurableTimeSupplier   timeSupplier    =    new   DeadHostStateTests . ConfigurableTimeSupplier (  )  ;", "DeadHostState   deadHostState    =    null ;", "for    ( int   i    =     0  ;    i    <     ( DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS . length )  ;    i +  +  )     {", "long   expectedTimeoutSecond    =    DeadHostStateTests . EXPECTED _ TIMEOUTS _ SECONDS [ i ]  ;", "timeSupplier . nanoTime    =     0  ;", "if    ( i    =  =     0  )     {", "deadHostState    =    new   DeadHostState ( timeSupplier )  ;", "} else    {", "deadHostState    =    new   DeadHostState ( deadHostState ,    timeSupplier )  ;", "}", "for    ( int   j    =     0  ;    j    <    expectedTimeoutSecond ;    j +  +  )     {", "timeSupplier . nanoTime    +  =    TimeUnit . SECONDS . toNanos (  1  )  ;", "assertThat ( deadHostState . shallBeRetried (  )  ,    is ( false )  )  ;", "}", "int   iters    =    randomIntBetween (  5  ,     3  0  )  ;", "for    ( int   j    =     0  ;    j    <    iters ;    j +  +  )     {", "timeSupplier . nanoTime    +  =    TimeUnit . SECONDS . toNanos (  1  )  ;", "assertThat ( deadHostState . shallBeRetried (  )  ,    is ( true )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testShallBeRetried"], "fileName": "org.elasticsearch.client.DeadHostStateTests"}, {"methodBody": ["METHOD_START", "{", "ESRestHighLevelClientTestCase . restHighLevelClient . close (  )  ;", "ESRestHighLevelClientTestCase . restHighLevelClient    =    null ;", "}", "METHOD_END"], "methodName": ["cleanupClient"], "fileName": "org.elasticsearch.client.ESRestHighLevelClientTestCase"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "return   syncMethod . execute ( requ ,    headers )  ;", "} else    {", "PlainActionFuture < Resp >    future    =    PlainActionFuture . newFuture (  )  ;", "asyncMethod . execute ( requ ,    future ,    headers )  ;", "return   future . actionGet (  )  ;", "}", "}", "METHOD_END"], "methodName": ["execute"], "fileName": "org.elasticsearch.client.ESRestHighLevelClientTestCase"}, {"methodBody": ["METHOD_START", "{", "return   ESRestHighLevelClientTestCase . restHighLevelClient ;", "}", "METHOD_END"], "methodName": ["highLevelClient"], "fileName": "org.elasticsearch.client.ESRestHighLevelClientTestCase"}, {"methodBody": ["METHOD_START", "{", "super . initClient (  )  ;", "if    (  (  . restHighLevelClient )     =  =    null )     {", ". restHighLevelClient    =    new    . HighLevelClient ( client (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["initHighLevelClient"], "fileName": "org.elasticsearch.client.ESRestHighLevelClientTestCase"}, {"methodBody": ["METHOD_START", "{", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "RequestLine   requestLine    =    new   BasicRequestLine (  \" GET \"  ,     \"  /  \"  ,    protocolVersion )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,     2  0  0  ,     \" OK \"  )  ;", "Http   http    =    new   BasicHttp ( statusLine )  ;", "return   new    ( requestLine ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    http )  ;", "}", "METHOD_END"], "methodName": ["mockResponse"], "fileName": "org.elasticsearch.client.FailureTrackingResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "FailureTrackingResponseListenerTests . MockResponseListener   responseListener    =    new   FailureTrackingResponseListenerTests . MockResponseListener (  )  ;", "RestC   listener    =    new   RestC ( responseListener )  ;", "int   numIters    =    randomIntBetween (  1  ,     1  0  )  ;", "Exception [  ]    expectedExceptions    =    new   Exception [ numIters ]  ;", "for    ( int   i    =     0  ;    i    <    numIters ;    i +  +  )     {", "RuntimeException   runtimeException    =    new   RuntimeException (  (  \" test \"     +    i )  )  ;", "expectedExceptions [ i ]     =    runtimeException ;", "listener . trackFailure ( runtimeException )  ;", "assertNull ( responseListener . response . get (  )  )  ;", "assertNull ( responseListener . exception . get (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "Response   response    =    FailureTrackingResponseListenerTests . mockResponse (  )  ;", "listener . onSuccess ( response )  ;", "assertSame ( response ,    responseListener . response . get (  )  )  ;", "assertNull ( responseListener . exception . get (  )  )  ;", "} else    {", "RuntimeException   runtimeException    =    new   RuntimeException (  \" definitive \"  )  ;", "listener . onDefinitiveFailure ( runtimeException )  ;", "assertNull ( responseListener . response . get (  )  )  ;", "Throwable   exception    =    responseListener . exception . get (  )  ;", "assertSame ( runtimeException ,    exception )  ;", "int   i    =    numIters    -     1  ;", "do    {", "assertNotNull ( exception . getSuppressed (  )  )  ;", "assertEquals (  1  ,    exception . getSuppressed (  )  . length )  ;", "assertSame ( expectedExceptions [  ( i -  -  )  ]  ,    exception . getSuppressed (  )  [  0  ]  )  ;", "exception    =    exception . getSuppressed (  )  [  0  ]  ;", "}    while    ( i    >  =     0     )  ;", "}", "}", "METHOD_END"], "methodName": ["testOnFailure"], "fileName": "org.elasticsearch.client.FailureTrackingResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "FailureTrackingResponseListenerTests . MockResponseListener   responseListener    =    new   FailureTrackingResponseListenerTests . MockResponseListener (  )  ;", "RestC   listener    =    new   RestC ( responseListener )  ;", "final   Response   response    =    FailureTrackingResponseListenerTests . mockResponse (  )  ;", "listener . onSuccess ( response )  ;", "assertSame ( response ,    responseListener . response . get (  )  )  ;", "assertNull ( responseListener . exception . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOnSuccess"], "fileName": "org.elasticsearch.client.FailureTrackingResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   bufferLimitBytes ;", "}", "METHOD_END"], "methodName": ["getBufferLimit"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumer"}, {"methodBody": ["METHOD_START", "{", "return   HeapByteBufferAllocator . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getByteBufferAllocator"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumer"}, {"methodBody": ["METHOD_START", "{", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,     2  0  0  ,     \" OK \"  )  ;", "consumer . onResponseReceived ( new   BasicHttpResponse ( statusLine )  )  ;", "final   AtomicReference < Long >    contentLength    =    new   AtomicReference <  >  (  )  ;", "HttpEntity   entity    =    new   StringEntity (  \"  \"  ,    ContentType . APPLICATION _ JSON )     {", "@ Override", "public   long   getContentLength (  )     {", "return   contentLength . get (  )  ;", "}", "}  ;", "contentLength . set ( randomLong ( bufferLimit )  )  ;", "consumer . onEntityEnclosed ( entity ,    APPLICATION _ JSON )  ;", "contentLength . set ( randomLongBetween (  ( bufferLimit    +     1  )  ,     . MAX _ TEST _ BUFFER _ SIZE )  )  ;", "try    {", "consumer . onEntityEnclosed ( entity ,    APPLICATION _ JSON )  ;", "}    catch    ( ContentTooLongException   e )     {", "assertEquals (  (  (  (  (  \" entity   content   is   too   long    [  \"     +     ( entity . getContentLength (  )  )  )     +     \"  ]    for   the   configured   buffer   limit    [  \"  )     +    bufferLimit )     +     \"  ]  \"  )  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["bufferLimitTest"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "int   bufferLimit    =    randomIntBetween (  1  ,    Integer . MAX _ VALUE )  ;", "Constructor <  ?  >    constructor    =    HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory . class . getConstructor ( Integer . TYPE )  ;", "assertEquals ( Modifier . PUBLIC ,     (  ( constructor . getModifiers (  )  )     &     ( Modifier . PUBLIC )  )  )  ;", "Object   object    =    constructor . newInstance ( bufferLimit )  ;", "assertThat ( object ,    instanceOf ( HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory . class )  )  ;", "HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory   consumerFactory    =     (  ( HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory )     ( object )  )  ;", "HttpAsyncResponseConsumer < HttpResponse >    consumer    =    consumerFactory . createHttpAsyncResponseConsumer (  )  ;", "assertThat ( consumer ,    instanceOf (  . class )  )  ;", "bufferedAsyncResponseConsumer    =     (  (  )     ( consumer )  )  ;", "assertEquals ( bufferLimit ,    bufferedAsyncResponseConsumer . getBufferLimit (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCanConfigureHeapBufferLimitFromOutsidePackage"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new   HeapBufferedAsyncResponseConsumer ( randomIntBetween ( Integer . MIN _ VALUE ,     0  )  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" bufferLimit   must   be   greater   than    0  \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "new   HeapBufferedAsyncResponseConsumer (  0  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" bufferLimit   must   be   greater   than    0  \"  ,    e . getMessage (  )  )  ;", "}", "int   bufferLimit    =    randomIntBetween (  1  ,     (  (  . MAX _ TEST _ BUFFER _ SIZE )     -     1  0  0  )  )  ;", "HeapBufferedAsyncResponseConsumer   consumer    =    new   HeapBufferedAsyncResponseConsumer ( bufferLimit )  ;", ". bufferLimitTest ( consumer ,    bufferLimit )  ;", "}", "METHOD_END"], "methodName": ["testConfiguredBufferLimit"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "HeapBufferedAsyncResponseConsumer   consumer    =    new   HeapBufferedAsyncResponseConsumer ( HeapBufferedAsyncResponseConsumerTests . TEST _ BUFFER _ LIMIT )  ;", "HeapBufferedAsyncResponseConsumerTests . bufferLimitTest ( consumer ,    HeapBufferedAsyncResponseConsumerTests . TEST _ BUFFER _ LIMIT )  ;", "}", "METHOD_END"], "methodName": ["testDefaultBufferLimit"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( Modifier . PUBLIC ,     (  ( HttpAsyncResponseConsumerFactory . class . getModifiers (  )  )     &     ( Modifier . PUBLIC )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHttpAsyncResponseConsumerFactoryVisibility"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "ContentDecoder   contentDecoder    =    mock ( ContentDecoder . class )  ;", "IOControl   ioControl    =    mock ( IOControl . class )  ;", "HttpContext   httpContext    =    mock ( HttpContext . class )  ;", "HeapBufferedAsyncResponseConsumer   consumer    =    spy ( new   HeapBufferedAsyncResponseConsumer (  . TEST _ BUFFER _ LIMIT )  )  ;", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,     2  0  0  ,     \" OK \"  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( statusLine )  ;", "httpResponse . setEntity ( new   StringEntity (  \" test \"  ,    ContentType . TEXT _ PLAIN )  )  ;", "consumer . responseReceived ( httpResponse )  ;", "consumer . consumeContent ( contentDecoder ,    ioControl )  ;", "consumer . responseCompleted ( httpContext )  ;", "verify ( consumer )  . releaseResources (  )  ;", "verify ( consumer )  . buildResult ( httpContext )  ;", "assertTrue ( consumer . isDone (  )  )  ;", "assertSame ( httpResponse ,    consumer . getResult (  )  )  ;", "consumer . responseCompleted ( httpContext )  ;", "verify ( consumer ,    times (  1  )  )  . releaseResources (  )  ;", "verify ( consumer ,    times (  1  )  )  . buildResult ( httpContext )  ;", "}", "METHOD_END"], "methodName": ["testResponseProcessing"], "fileName": "org.elasticsearch.client.HeapBufferedAsyncResponseConsumerTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals ( hosts . length ,    this . hosts . size (  )  )  ;", "assertThat ( this . hosts ,    containsInAnyOrder ( hosts )  )  ;", "this . hosts . clear (  )  ;", "}", "METHOD_END"], "methodName": ["assertCalled"], "fileName": "org.elasticsearch.client.HostsTrackingFailureListener"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  0  ,    hosts . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotCalled"], "fileName": "org.elasticsearch.client.HostsTrackingFailureListener"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( clearIndicesCacheRequest ,    Request :  : clearCache ,    ClearIndicesCacheResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( clearIndicesCacheRequest ,    Request :  : clearCache ,    ClearIndicesCacheResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["clearCacheAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( closeIndexRequest ,    Request :  : closeIndex ,    CloseIndexResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["close"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( closeIndexRequest ,    Request :  : closeIndex ,    CloseIndexResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["closeAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( createIndexRequest ,    Request :  : createIndex ,    CreateIndexResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( createIndexRequest ,    Request :  : createIndex ,    CreateIndexResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["createAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( deleteIndexRequest ,    Request :  : deleteIndex ,    DeleteIndexResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( deleteIndexRequest ,    Request :  : deleteIndex ,    DeleteIndexResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["deleteAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequest ( request ,    Request :  : indicesExist ,    RestHighLevelClient :  : convertExistsResponse ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequest ( getAliasesRequest ,    Request :  : existsAlias ,    RestHighLevelClient :  : convertExistsResponse ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["existsAlias"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsync ( getAliasesRequest ,    Request :  : existsAlias ,    RestHighLevelClient :  : convertExistsResponse ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["existsAliasAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsync ( request ,    Request :  : indicesExist ,    RestHighLevelClient :  : convertExistsResponse ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["existsAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( flushRequest ,    Request :  : flush ,    FlushResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( flushRequest ,    Request :  : flush ,    FlushResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["flushAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( forceMergeRequest ,    Request :  : forceMerge ,    ForceMergeResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["forceMerge"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( forceMergeRequest ,    Request :  : forceMerge ,    ForceMergeResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["forceMergeAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( openIndexRequest ,    Request :  : openIndex ,    OpenIndexResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["open"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( openIndexRequest ,    Request :  : openIndex ,    OpenIndexResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["openAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( putMappingRequest ,    Request :  : putMapping ,    PutMappingResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putMapping"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( putMappingRequest ,    Request :  : putMapping ,    PutMappingResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putMappingAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( updateSettingsRequest ,    Request :  : indexPutSettings ,    UpdateSettingsResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putSettings"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( updateSettingsRequest ,    Request :  : indexPutSettings ,    UpdateSettingsResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["putSettingsAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( refreshRequest ,    Request :  : refresh ,    RefreshResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["refresh"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( refreshRequest ,    Request :  : refresh ,    RefreshResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["refreshAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( rolloverRequest ,    Request :  : rollover ,    RolloverResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["rollover"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( rolloverRequest ,    Request :  : rollover ,    RolloverResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["rolloverAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( resizeRequest ,    Request :  : shrink ,    ResizeResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( resizeRequest ,    Request :  : shrink ,    ResizeResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["shrinkAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( resizeRequest ,    Request :  : split ,    ResizeResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( resizeRequest ,    Request :  : split ,    ResizeResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["splitAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "return   restHighLevelClient . performRequestAndParseEntity ( indicesAliasesRequest ,    Request :  : updateAliases ,    IndicesAliasesResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["updateAliases"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . performRequestAsyncAndParseEntity ( indicesAliasesRequest ,    Request :  : updateAliases ,    IndicesAliasesResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["updateAliasesAsync"], "fileName": "org.elasticsearch.client.IndicesClient"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    indexSettings    =    getIndexSettings ( index )  ;", "return    (  ( Map < String ,    Object >  )     (  (  ( Map < String ,    Object >  )     ( indexSettings . get ( index )  )  )  . get (  \" settings \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getIndexSettingsAsMap"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   index    =     \" index \"  ;", "String   alias    =     \" alias \"  ;", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "IndicesAliasesRequest   nonExistentIndexRequest    =    new   IndicesAliasesRequest (  )  ;", "nonExistentIndexRequest . addAliasAction ( new   action . admin . indices . alias . IndicesAliasesRequest . AliasActions ( Type . ADD )  . index ( nonExistentIndex )  . alias ( alias )  )  ;", "ElasticsearchException   exception    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    execute ( nonExistentIndexRequest ,    highLevelClient (  )  . indices (  )  :  : updateAliases ,    highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  )  ;", "assertThat ( exception . status (  )  ,    equalTo ( NOT _ FOUND )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  \" Elasticsearch   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  )  )  ;", "assertThat ( exception . getMetadata (  \" es . index \"  )  ,    hasItem ( nonExistentIndex )  )  ;", "createIndex ( index ,    EMPTY )  ;", "IndicesAliasesRequest   mixedRequest    =    new   IndicesAliasesRequest (  )  ;", "mixedRequest . addAliasAction ( new   action . admin . indices . alias . IndicesAliasesRequest . AliasActions ( Type . ADD )  . indices ( index )  . aliases ( alias )  )  ;", "mixedRequest . addAliasAction ( new   action . admin . indices . alias . IndicesAliasesRequest . AliasActions ( Type . REMOVE )  . indices ( nonExistentIndex )  . alias ( alias )  )  ;", "exception    =    expectThrows ( ElasticsearchStatusException . class ,     (  )     -  >    execute ( mixedRequest ,    highLevelClient (  )  . indices (  )  :  : updateAliases ,    highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  )  ;", "assertThat ( exception . status (  )  ,    equalTo ( NOT _ FOUND )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  \" Elasticsearch   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  )  )  ;", "assertThat ( exception . getMetadata (  \" es . index \"  )  ,    hasItem ( nonExistentIndex )  )  ;", "assertThat ( exception . getMetadata (  \" es . index \"  )  ,    not ( hasItem ( index )  )  )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( false )  )  ;", "IndicesAliasesRequest   removeIndexRequest    =    new   IndicesAliasesRequest (  )  ;", "removeIndexRequest . addAliasAction ( new   action . admin . indices . alias . IndicesAliasesRequest . AliasActions ( Type . ADD )  . index ( nonExistentIndex )  . alias ( alias )  )  ;", "removeIndexRequest . addAliasAction ( new   action . admin . indices . alias . IndicesAliasesRequest . AliasActions ( Type . REMOVE _ INDEX )  . indices ( nonExistentIndex )  )  ;", "exception    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    execute ( removeIndexRequest ,    highLevelClient (  )  . indices (  )  :  : updateAliases ,    highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  )  ;", "assertThat ( exception . status (  )  ,    equalTo ( NOT _ FOUND )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  \" Elasticsearch   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  )  )  ;", "assertThat ( exception . getMetadata (  \" es . index \"  )  ,    hasItem ( nonExistentIndex )  )  ;", "assertThat ( exception . getMetadata (  \" es . index \"  )  ,    not ( hasItem ( index )  )  )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testAliasesNonExistentIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   index    =     \" index \"  ;", "Settings   settings    =    Settings . builder (  )  . put (  \" number _ of _ shards \"  ,     1  )  . put (  \" number _ of _ replicas \"  ,     0  )  . build (  )  ;", "createIndex ( index ,    settings )  ;", "ClearIndicesCacheRequest   clearCacheRequest    =    new   ClearIndicesCacheRequest ( index )  ;", "ClearIndicesCacheResponse   clearCacheResponse    =    ESRestHighLevelClientTestCase . execute ( clearCacheRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : clearCache ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : clearCacheAsync )  ;", "assertThat ( clearCacheResponse . getTotalShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( clearCacheResponse . getSuccessfulShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( clearCacheResponse . getFailedShards (  )  ,    equalTo (  0  )  )  ;", "assertThat ( clearCacheResponse . getShardFailures (  )  ,    equalTo ( EMPTY )  )  ;", "}", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "ClearIndicesCacheRequest   clearCacheRequest    =    new   ClearIndicesCacheRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( clearCacheRequest ,    highLevelClient (  )  . indices (  )  :  : clearCache ,    highLevelClient (  )  . indices (  )  :  : clearCacheAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testClearCache"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   index    =     \" index \"  ;", "createIndex ( index ,    EMPTY )  ;", "Response   response    =    client (  )  . performRequest ( METHOD _ NAME ,     ( index    +     \"  /  _  \"  )  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( OK . getStatus (  )  )  )  ;", "CloseIndexRequest   closeIndexRequest    =    new   CloseIndexRequest ( index )  ;", "CloseIndexResponse   closeIndexResponse    =    ESRestHighLevelClientTestCase . execute ( closeIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : close ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : closeAsync )  ;", "assertTrue ( closeIndexResponse . isAcknowledged (  )  )  ;", "ResponseException   exception    =    expectThrows ( ResponseException . class ,     (  )     -  >    client (  )  . performRequest ( HttpGet . METHOD _ NAME ,     ( index    +     \"  /  _  \"  )  )  )  ;", "assertThat ( exception . getResponse (  )  . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( BAD _ REQUEST . getStatus (  )  )  )  ;", "assertThat ( exception . getMessage (  )  . contains ( index )  ,    equalTo ( true )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseExistingIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "CloseIndexRequest   closeIndexRequest    =    new   CloseIndexRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( closeIndexRequest ,    highLevelClient (  )  . indices (  )  :  : close ,    highLevelClient (  )  . indices (  )  :  : closeAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseNonExistentIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   indexName    =     \" plain _ index \"  ;", "assertFalse ( indexExists ( indexName )  )  ;", "CreateIndexRequest   createIndexRequest    =    new   CreateIndexRequest ( indexName )  ;", "CreateIndexResponse   createIndexResponse    =    ESRestHighLevelClientTestCase . execute ( createIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : create ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : createAsync )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "assertTrue ( indexExists ( indexName )  )  ;", "}", "{", "String   indexName    =     \" rich _ index \"  ;", "assertFalse ( indexExists ( indexName )  )  ;", "CreateIndexRequest   createIndexRequest    =    new   CreateIndexRequest ( indexName )  ;", "Alias   alias    =    new   Alias (  \" alias _ name \"  )  ;", "alias . filter (  \"  {  \\  \" term \\  \"  :  {  \\  \" year \\  \"  :  2  0  1  6  }  }  \"  )  ;", "alias . routing (  \"  1  \"  )  ;", "createIndexRequest . alias ( alias )  ;", "Settings . Builder   settings    =    Settings . builder (  )  ;", "settings . put ( SETTING _ NUMBER _ OF _ REPLICAS ,     2  )  ;", "createIndexRequest . settings ( settings )  ;", "XContentBuilder   mappingBuilder    =    JsonXContent . contentBuilder (  )  ;", "mappingBuilder . startObject (  )  . startObject (  \" properties \"  )  . startObject (  \" field \"  )  ;", "mappingBuilder . field (  \" type \"  ,     \" text \"  )  ;", "mappingBuilder . endObject (  )  . endObject (  )  . endObject (  )  ;", "createIndexRequest . mapping (  \" type _ name \"  ,    mappingBuilder )  ;", "CreateIndexResponse   createIndexResponse    =    ESRestHighLevelClientTestCase . execute ( createIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : create ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : createAsync )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "Map < String ,    Object >    getIndexResponse    =    getAsMap ( indexName )  ;", "assertEquals (  \"  2  \"  ,    XContentMapValues . extractValue (  ( indexName    +     \"  . settings . index . number _ of _ replicas \"  )  ,    getIndexResponse )  )  ;", "Map < String ,    Object >    aliasData    =     (  ( Map < String ,    Object >  )     ( XContentMapValues . extractValue (  ( indexName    +     \"  . aliases . alias _ name \"  )  ,    getIndexResponse )  )  )  ;", "assertNotNull ( aliasData )  ;", "assertEquals (  \"  1  \"  ,    aliasData . get (  \" index _ routing \"  )  )  ;", "Map < String ,    Object >    filter    =     (  ( Map )     ( aliasData . get (  \" filter \"  )  )  )  ;", "Map < String ,    Object >    term    =     (  ( Map )     ( filter . get (  \" term \"  )  )  )  ;", "assertEquals (  2  0  1  6  ,    term . get (  \" year \"  )  )  ;", "assertEquals (  \" text \"  ,    XContentMapValues . extractValue (  ( indexName    +     \"  . mappings . type _ name . properties . field . type \"  )  ,    getIndexResponse )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   indexName    =     \" test _ index \"  ;", "createIndex ( indexName ,    EMPTY )  ;", "DeleteIndexRequest   deleteIndexRequest    =    new   DeleteIndexRequest ( indexName )  ;", "DeleteIndexResponse   deleteIndexResponse    =    ESRestHighLevelClientTestCase . execute ( deleteIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : delete ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : deleteAsync )  ;", "assertTrue ( deleteIndexResponse . isAcknowledged (  )  )  ;", "assertFalse ( indexExists ( indexName )  )  ;", "}", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "DeleteIndexRequest   deleteIndexRequest    =    new   DeleteIndexRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( deleteIndexRequest ,    highLevelClient (  )  . indices (  )  :  : delete ,    highLevelClient (  )  . indices (  )  :  : deleteAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDeleteIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "GetAliasesRequest   getAliasesRequest    =    new   GetAliasesRequest (  \" alias \"  )  ;", "assertFalse ( ESRestHighLevelClientTestCase . execute ( getAliasesRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAlias ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAliasAsync )  )  ;", "createIndex (  \" index \"  ,    EMPTY )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     \"  / index /  _ alias / alias \"  )  ;", "assertTrue ( ESRestHighLevelClientTestCase . execute ( getAliasesRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAlias ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAliasAsync )  )  ;", "GetAliasesRequest   getAliasesRequest 2     =    new   GetAliasesRequest (  )  ;", "getAliasesRequest 2  . aliases (  \" alias \"  )  ;", "getAliasesRequest 2  . i (  \" index \"  )  ;", "assertTrue ( ESRestHighLevelClientTestCase . execute ( getAliasesRequest 2  ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAlias ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAliasAsync )  )  ;", "getAliasesRequest 2  . i (  \" does _ not _ exist \"  )  ;", "assertFalse ( ESRestHighLevelClientTestCase . execute ( getAliasesRequest 2  ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAlias ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAliasAsync )  )  ;", "}", "METHOD_END"], "methodName": ["testExistsAlias"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   index    =     \" index \"  ;", "Settings   settings    =    Settings . builder (  )  . put (  \" number _ of _ shards \"  ,     1  )  . put (  \" number _ of _ replicas \"  ,     0  )  . build (  )  ;", "createIndex ( index ,    settings )  ;", "FlushRequest   flushRequest    =    new   FlushRequest ( index )  ;", "FlushResponse   flushResponse    =    ESRestHighLevelClientTestCase . execute ( flushRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : flush ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : flushAsync )  ;", "assertThat ( flushResponse . getTotalShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( flushResponse . getSuccessfulShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( flushResponse . getFailedShards (  )  ,    equalTo (  0  )  )  ;", "assertThat ( flushResponse . getShardFailures (  )  ,    equalTo ( EMPTY )  )  ;", "}", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "FlushRequest   flushRequest    =    new   FlushRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( flushRequest ,    highLevelClient (  )  . indices (  )  :  : flush ,    highLevelClient (  )  . indices (  )  :  : flushAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testFlush"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   index    =     \" index \"  ;", "Settings   settings    =    Settings . builder (  )  . put (  \" number _ of _ shards \"  ,     1  )  . put (  \" number _ of _ replicas \"  ,     0  )  . build (  )  ;", "createIndex ( index ,    settings )  ;", "ForceMergeRequest   forceMergeRequest    =    new   ForceMergeRequest ( index )  ;", "ForceMergeResponse   forceMergeResponse    =    ESRestHighLevelClientTestCase . execute ( forceMergeRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : forceMerge ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : forceMergeAsync )  ;", "assertThat ( forceMergeResponse . getTotalShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( forceMergeResponse . getSuccessfulShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( forceMergeResponse . getFailedShards (  )  ,    equalTo (  0  )  )  ;", "assertThat ( forceMergeResponse . getShardFailures (  )  ,    equalTo ( EMPTY )  )  ;", "}", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "ForceMergeRequest   forceMergeRequest    =    new   ForceMergeRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( forceMergeRequest ,    highLevelClient (  )  . indices (  )  :  : forceMerge ,    highLevelClient (  )  . indices (  )  :  : forceMergeAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testForceMerge"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   index    =     \" index \"  ;", "UpdateSettingsRequest   indexUpdateSettingsRequest    =    new   UpdateSettingsRequest ( index )  ;", "String   setting    =     \" no _ idea _ what _ you _ are _ talking _ about \"  ;", "int   value    =     1  0  ;", "indexUpdateSettingsRequest . settings ( Settings . builder (  )  . put ( setting ,    value )  . build (  )  )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( indexUpdateSettingsRequest ,    highLevelClient (  )  . indices (  )  :  : putSettings ,    highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  \" E   exception    [ type = index _ not _ found _ exception ,    reason = no   such   index ]  \"  )  )  ;", "createIndex ( index ,    EMPTY )  ;", "exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( indexUpdateSettingsRequest ,    highLevelClient (  )  . indices (  )  :  : putSettings ,    highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  )  ;", "assertThat ( exception . status (  )  ,    equalTo ( BAD _ REQUEST )  )  ;", "assertThat ( exception . getMessage (  )  ,    equalTo (  (  \" E   exception    [ type = illegal _ argument _ exception ,     \"     +     (  \" reason = unknown   setting    [ index . no _ idea _ what _ you _ are _ talking _ about ]    please   check   that   any   required   plugins   are   installed ,     \"     +     \" or   check   the   breaking   changes   documentation   for   removed   settings ]  \"  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexPutSettingNonExistent"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "final   Setting < Integer >    dynamicSetting    =    IndexMetaData . INDEX _ NUMBER _ OF _ REPLICAS _ SETTING ;", "final   String   dynamicSettingKey    =    IndexMetaData . SETTING _ NUMBER _ OF _ REPLICAS ;", "final   int   dynamicSettingValue    =     0  ;", "final   Setting < String >    staticSetting    =    IndexSettings . INDEX _ CHECK _ ON _ STARTUP ;", "final   String   staticSettingKey    =    INDEX _ CHECK _ ON _ STARTUP . getKey (  )  ;", "final   String   staticSettingValue    =     \" true \"  ;", "final   Setting < Integer >    unmodifiableSetting    =    IndexMetaData . INDEX _ NUMBER _ OF _ SHARDS _ SETTING ;", "final   String   unmodifiableSettingKey    =    IndexMetaData . SETTING _ NUMBER _ OF _ SHARDS ;", "final   int   unmodifiableSettingValue    =     3  ;", "String   index    =     \" index \"  ;", "createIndex ( index ,    EMPTY )  ;", "assertThat ( dynamicSetting . getDefault ( EMPTY )  ,    not ( dynamicSettingValue )  )  ;", "UpdateSettingsRequest   dynamicSettingRequest    =    new   UpdateSettingsRequest (  )  ;", "dynamicSettingRequest . settings ( Settings . builder (  )  . put ( dynamicSettingKey ,    dynamicSettingValue )  . build (  )  )  ;", "UpdateSettingsResponse   response    =    ESRestHighLevelClientTestCase . execute ( dynamicSettingRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : putSettings ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  ;", "assertTrue ( response . isAcknowledged (  )  )  ;", "Map < String ,    Object >    indexSettingsAsMap    =    getIndexSettingsAsMap ( index )  ;", "assertThat ( indexSettingsAsMap . get ( dynamicSettingKey )  ,    equalTo ( String . valueOf ( dynamicSettingValue )  )  )  ;", "assertThat ( staticSetting . getDefault ( EMPTY )  ,    not ( staticSettingValue )  )  ;", "UpdateSettingsRequest   staticSettingRequest    =    new   UpdateSettingsRequest (  )  ;", "staticSettingRequest . settings ( Settings . builder (  )  . put ( staticSettingKey ,    staticSettingValue )  . build (  )  )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( staticSettingRequest ,    highLevelClient (  )  . indices (  )  :  : putSettings ,    highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  )  ;", "assertThat ( exception . getMessage (  )  ,    startsWith (  (  \" E   exception    [ type = illegal _ argument _ exception ,     \"     +     \" reason = Can ' t   update   non   dynamic   settings    [  [ index . shard . check _ on _ startup ]  ]    for   open   indices    [  [ index /  \"  )  )  )  ;", "indexSettingsAsMap    =    getIndexSettingsAsMap ( index )  ;", "assertNull ( indexSettingsAsMap . get ( staticSettingKey )  )  ;", "closeIndex ( index )  ;", "response    =    ESRestHighLevelClientTestCase . execute ( staticSettingRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : putSettings ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  ;", "assertTrue ( response . isAcknowledged (  )  )  ;", "openIndex ( index )  ;", "indexSettingsAsMap    =    getIndexSettingsAsMap ( index )  ;", "assertThat ( indexSettingsAsMap . get ( staticSettingKey )  ,    equalTo ( staticSettingValue )  )  ;", "assertThat ( unmodifiableSetting . getDefault ( EMPTY )  ,    not ( unmodifiableSettingValue )  )  ;", "UpdateSettingsRequest   unmodifiableSettingRequest    =    new   UpdateSettingsRequest (  )  ;", "unmodifiableSettingRequest . settings ( Settings . builder (  )  . put ( unmodifiableSettingKey ,    unmodifiableSettingValue )  . build (  )  )  ;", "exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( unmodifiableSettingRequest ,    highLevelClient (  )  . indices (  )  :  : putSettings ,    highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  )  ;", "assertThat ( exception . getMessage (  )  ,    startsWith (  (  \" E   exception    [ type = illegal _ argument _ exception ,     \"     +     \" reason = Can ' t   update   non   dynamic   settings    [  [ index . number _ of _ shards ]  ]    for   open   indices    [  [ index /  \"  )  )  )  ;", "closeIndex ( index )  ;", "exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( unmodifiableSettingRequest ,    highLevelClient (  )  . indices (  )  :  : putSettings ,    highLevelClient (  )  . indices (  )  :  : putSettingsAsync )  )  ;", "assertThat ( exception . getMessage (  )  ,    startsWith (  (  \" E   exception    [ type = illegal _ argument _ exception ,     \"     +     \" reason = final   index   setting    [ index . number _ of _ shards ]  ,    not   updateable \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexPutSettings"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   indexName    =     \" test _ index _ exists _ index _ present \"  ;", "createIndex ( indexName ,    EMPTY )  ;", "GetIndexRequest   request    =    new   GetIndexRequest (  )  ;", "request . i ( indexName )  ;", "boolean   response    =    ESRestHighLevelClientTestCase . execute ( request ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAsync )  ;", "assertTrue ( response )  ;", "}", "{", "String   indexName    =     \" non _ existent _ index \"  ;", "GetIndexRequest   request    =    new   GetIndexRequest (  )  ;", "request . i ( indexName )  ;", "boolean   response    =    ESRestHighLevelClientTestCase . execute ( request ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAsync )  ;", "assertFalse ( response )  ;", "}", "{", "String   existingIndex    =     \" apples \"  ;", "createIndex ( existingIndex ,    EMPTY )  ;", "String   nonExistentIndex    =     \" oranges \"  ;", "GetIndexRequest   request    =    new   GetIndexRequest (  )  ;", "request . i ( existingIndex ,    nonExistentIndex )  ;", "boolean   response    =    ESRestHighLevelClientTestCase . execute ( request ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : exists ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : existsAsync )  ;", "assertFalse ( response )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndicesExists"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   index    =     \" index \"  ;", "createIndex ( index ,    EMPTY )  ;", "closeIndex ( index )  ;", "ResponseException   exception    =    expectThrows ( ResponseException . class ,     (  )     -  >    client (  )  . performRequest ( HttpGet . METHOD _ NAME ,     ( index    +     \"  /  _  \"  )  )  )  ;", "assertThat ( exception . getResponse (  )  . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( BAD _ REQUEST . getStatus (  )  )  )  ;", "assertThat ( exception . getMessage (  )  . contains ( index )  ,    equalTo ( true )  )  ;", "OpenIndexRequest   openIndexRequest    =    new   OpenIndexRequest ( index )  ;", "OpenIndexResponse   openIndexResponse    =    ESRestHighLevelClientTestCase . execute ( openIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : open ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : openAsync )  ;", "assertTrue ( openIndexResponse . isAcknowledged (  )  )  ;", "Response   response    =    client (  )  . performRequest ( METHOD _ NAME ,     ( index    +     \"  /  _  \"  )  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( OK . getStatus (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testOpenExistingIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "OpenIndexRequest   openIndexRequest    =    new   OpenIndexRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( openIndexRequest ,    highLevelClient (  )  . indices (  )  :  : open ,    highLevelClient (  )  . indices (  )  :  : openAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "OpenIndexRequest   lenientOpenIndexRequest    =    new   OpenIndexRequest ( nonExistentIndex )  ;", "lenientOpenIndexRequest . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "OpenIndexResponse   lenientOpenIndexResponse    =    ESRestHighLevelClientTestCase . execute ( lenientOpenIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : open ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : openAsync )  ;", "assertThat ( lenientOpenIndexResponse . isAcknowledged (  )  ,    equalTo ( true )  )  ;", "OpenIndexRequest   strictOpenIndexRequest    =    new   OpenIndexRequest ( nonExistentIndex )  ;", "strictOpenIndexRequest . indicesOptions ( IndicesOptions . strictExpandOpen (  )  )  ;", "EException   strictException    =    expectThrows ( EException . class ,     (  )     -  >    execute ( openIndexRequest ,    highLevelClient (  )  . indices (  )  :  : open ,    highLevelClient (  )  . indices (  )  :  : openAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    strictException . status (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOpenNonExistentIndex"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   indexName    =     \" mapping _ index \"  ;", "createIndex ( indexName ,    EMPTY )  ;", "PutMappingRequest   putMappingRequest    =    new   PutMappingRequest ( indexName )  ;", "putMappingRequest . type (  \" type _ name \"  )  ;", "XContentBuilder   mappingBuilder    =    JsonXContent . contentBuilder (  )  ;", "mappingBuilder . startObject (  )  . startObject (  \" properties \"  )  . startObject (  \" field \"  )  ;", "mappingBuilder . field (  \" type \"  ,     \" text \"  )  ;", "mappingBuilder . endObject (  )  . endObject (  )  . endObject (  )  ;", "putMappingRequest . source ( mappingBuilder )  ;", "PutMappingResponse   putMappingResponse    =    ESRestHighLevelClientTestCase . execute ( putMappingRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : putMapping ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  :  : putMappingAsync )  ;", "assertTrue ( putMappingResponse . isAcknowledged (  )  )  ;", "Map < String ,    Object >    getIndexResponse    =    getAsMap ( indexName )  ;", "assertEquals (  \" text \"  ,    XContentMapValues . extractValue (  ( indexName    +     \"  . mappings . type _ name . properties . field . type \"  )  ,    getIndexResponse )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPutMapping"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "{", "String   index    =     \" index \"  ;", "Settings   settings    =    Settings . builder (  )  . put (  \" number _ of _ shards \"  ,     1  )  . put (  \" number _ of _ replicas \"  ,     0  )  . build (  )  ;", "createIndex ( index ,    settings )  ;", "RefreshRequest   refreshRequest    =    new   RefreshRequest ( index )  ;", "RefreshResponse   refreshResponse    =    ESRestHighLevelClientTestCase . execute ( refreshRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : refresh ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : refreshAsync )  ;", "assertThat ( refreshResponse . getTotalShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( refreshResponse . getSuccessfulShards (  )  ,    equalTo (  1  )  )  ;", "assertThat ( refreshResponse . getFailedShards (  )  ,    equalTo (  0  )  )  ;", "assertThat ( refreshResponse . getShardFailures (  )  ,    equalTo ( EMPTY )  )  ;", "}", "{", "String   nonExistentIndex    =     \" non _ existent _ index \"  ;", "assertFalse ( indexExists ( nonExistentIndex )  )  ;", "RefreshRequest   refreshRequest    =    new   RefreshRequest ( nonExistentIndex )  ;", "EException   exception    =    expectThrows ( EException . class ,     (  )     -  >    execute ( refreshRequest ,    highLevelClient (  )  . indices (  )  :  : refresh ,    highLevelClient (  )  . indices (  )  :  : refreshAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRefresh"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  . create ( new   CreateIndexRequest (  \" test \"  )  . alias ( new   Alias (  \" alias \"  )  )  )  ;", "RolloverRequest   rolloverRequest    =    new   RolloverRequest (  \" alias \"  ,     \" test _ new \"  )  ;", "rolloverRequest . addMaxIndexDocsCondition (  1  )  ;", "{", "RolloverResponse   rolloverResponse    =    ESRestHighLevelClientTestCase . execute ( rolloverRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rollover ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rolloverAsync )  ;", "assertFalse ( rolloverResponse . isRolledOver (  )  )  ;", "assertFalse ( rolloverResponse . isDryRun (  )  )  ;", "Map < String ,    Boolean >    conditionStatus    =    rolloverResponse . getConditionStatus (  )  ;", "assertEquals (  1  ,    conditionStatus . size (  )  )  ;", "assertFalse ( conditionStatus . get (  \"  [ max _ docs :     1  ]  \"  )  )  ;", "assertEquals (  \" test \"  ,    rolloverResponse . getOldIndex (  )  )  ;", "assertEquals (  \" test _ new \"  ,    rolloverResponse . getNewIndex (  )  )  ;", "}", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" test \"  ,     \" type \"  ,     \"  1  \"  )  . source (  \" field \"  ,     \" value \"  )  )  ;", "ESRestHighLevelClientTestCase . highLevelClient (  )  . index ( new   IndexRequest (  \" test \"  ,     \" type \"  ,     \"  2  \"  )  . source (  \" field \"  ,     \" value \"  )  . setRefreshPolicy ( WAIT _ UNTIL )  )  ;", "{", "rolloverRequest . addMaxIndexAgeCondition ( new   TimeValue (  1  )  )  ;", "rolloverRequest . dryRun ( true )  ;", "RolloverResponse   rolloverResponse    =    ESRestHighLevelClientTestCase . execute ( rolloverRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rollover ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rolloverAsync )  ;", "assertFalse ( rolloverResponse . isRolledOver (  )  )  ;", "assertTrue ( rolloverResponse . isDryRun (  )  )  ;", "Map < String ,    Boolean >    conditionStatus    =    rolloverResponse . getConditionStatus (  )  ;", "assertEquals (  2  ,    conditionStatus . size (  )  )  ;", "assertTrue ( conditionStatus . get (  \"  [ max _ docs :     1  ]  \"  )  )  ;", "assertTrue ( conditionStatus . get (  \"  [ max _ age :     1 ms ]  \"  )  )  ;", "assertEquals (  \" test \"  ,    rolloverResponse . getOldIndex (  )  )  ;", "assertEquals (  \" test _ new \"  ,    rolloverResponse . getNewIndex (  )  )  ;", "}", "{", "rolloverRequest . dryRun ( false )  ;", "rolloverRequest . addMaxIndexSizeCondition ( new   ommon . unit . ByteSizeValue (  1  ,    ByteSizeUnit . MB )  )  ;", "RolloverResponse   rolloverResponse    =    ESRestHighLevelClientTestCase . execute ( rolloverRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rollover ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : rolloverAsync )  ;", "assertTrue ( rolloverResponse . isRolledOver (  )  )  ;", "assertFalse ( rolloverResponse . isDryRun (  )  )  ;", "Map < String ,    Boolean >    conditionStatus    =    rolloverResponse . getConditionStatus (  )  ;", "assertEquals (  3  ,    conditionStatus . size (  )  )  ;", "assertTrue ( conditionStatus . get (  \"  [ max _ docs :     1  ]  \"  )  )  ;", "assertTrue ( conditionStatus . get (  \"  [ max _ age :     1 ms ]  \"  )  )  ;", "assertFalse ( conditionStatus . get (  \"  [ max _ size :     1 mb ]  \"  )  )  ;", "assertEquals (  \" test \"  ,    rolloverResponse . getOldIndex (  )  )  ;", "assertEquals (  \" test _ new \"  ,    rolloverResponse . getNewIndex (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRollover"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Object >    nodes    =    getAsMap (  \"  _ nodes \"  )  ;", "String   firstNode    =     (  ( Map < String ,    Object >  )     ( nodes . get (  \" nodes \"  )  )  )  . keySet (  )  . iterator (  )  . next (  )  ;", "createIndex (  \" source \"  ,    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     4  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . build (  )  )  ;", "updateIndexSettings (  \" source \"  ,    Settings . builder (  )  . put (  \" index . routing . allocation . require .  _ name \"  ,    firstNode )  . put (  \" index . blocks . write \"  ,    true )  )  ;", "ResizeRequest   resizeRequest    =    new   ResizeRequest (  \" target \"  ,     \" source \"  )  ;", "resizeRequest . setResizeType ( SHRINK )  ;", "Settings   targetSettings    =    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     2  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . build (  )  ;", "resizeRequest . setTargetIndex ( new   CreateIndexRequest (  \" target \"  )  . settings ( targetSettings )  . alias ( new   Alias (  \" alias \"  )  )  )  ;", "ResizeResponse   resizeResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  . shrink ( resizeRequest )  ;", "assertTrue ( resizeResponse . isAcknowledged (  )  )  ;", "assertTrue ( resizeResponse . isShardsAcknowledged (  )  )  ;", "Map < String ,    Object >    getIndexResponse    =    getAsMap (  \" target \"  )  ;", "Map < String ,    Object >    indexSettings    =     (  ( Map < String ,    Object >  )     ( XContentMapValues . extractValue (  \" target . settings . index \"  ,    getIndexResponse )  )  )  ;", "assertNotNull ( indexSettings )  ;", "assertEquals (  \"  2  \"  ,    indexSettings . get (  \" number _ of _ shards \"  )  )  ;", "assertEquals (  \"  0  \"  ,    indexSettings . get (  \" number _ of _ replicas \"  )  )  ;", "Map < String ,    Object >    aliasData    =     (  ( Map < String ,    Object >  )     ( XContentMapValues . extractValue (  \" target . aliases . alias \"  ,    getIndexResponse )  )  )  ;", "assertNotNull ( aliasData )  ;", "}", "METHOD_END"], "methodName": ["testShrink"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "createIndex (  \" source \"  ,    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     2  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . put (  \" index . number _ of _ routing _ shards \"  ,     4  )  . build (  )  )  ;", "updateIndexSettings (  \" source \"  ,    Settings . builder (  )  . put (  \" index . blocks . write \"  ,    true )  )  ;", "ResizeRequest   resizeRequest    =    new   ResizeRequest (  \" target \"  ,     \" source \"  )  ;", "resizeRequest . setResizeType ( SPLIT )  ;", "Settings   targetSettings    =    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     4  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . build (  )  ;", "resizeRequest . setTargetIndex ( new   CreateIndexRequest (  \" target \"  )  . settings ( targetSettings )  . alias ( new   Alias (  \" alias \"  )  )  )  ;", "ResizeResponse   resizeResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . i (  )  . split ( resizeRequest )  ;", "assertTrue ( resizeResponse . isAcknowledged (  )  )  ;", "assertTrue ( resizeResponse . isShardsAcknowledged (  )  )  ;", "Map < String ,    Object >    getIndexResponse    =    getAsMap (  \" target \"  )  ;", "Map < String ,    Object >    indexSettings    =     (  ( Map < String ,    Object >  )     ( XContentMapValues . extractValue (  \" target . settings . index \"  ,    getIndexResponse )  )  )  ;", "assertNotNull ( indexSettings )  ;", "assertEquals (  \"  4  \"  ,    indexSettings . get (  \" number _ of _ shards \"  )  )  ;", "assertEquals (  \"  0  \"  ,    indexSettings . get (  \" number _ of _ replicas \"  )  )  ;", "Map < String ,    Object >    aliasData    =     (  ( Map < String ,    Object >  )     ( XContentMapValues . extractValue (  \" target . aliases . alias \"  ,    getIndexResponse )  )  )  ;", "assertNotNull ( aliasData )  ;", "}", "METHOD_END"], "methodName": ["testSplit"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "String   index    =     \" index \"  ;", "String   alias    =     \" alias \"  ;", "createIndex ( index ,    EMPTY )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( false )  )  ;", "AliasesRequest   aliasesAddRequest    =    new   AliasesRequest (  )  ;", "AliasActions   addAction    =    new   AliasActions ( AliasActions . Type . ADD )  . index ( index )  . aliases ( alias )  ;", "addAction . routing (  \" routing \"  )  . searchRouting (  \" search _ routing \"  )  . filter (  \"  {  \\  \" term \\  \"  :  {  \\  \" year \\  \"  :  2  0  1  6  }  }  \"  )  ;", "aliasesAddRequest . addAliasAction ( addAction )  ;", "AliasesResponse   aliasesAddResponse    =    ESRestHighLevelClientTestCase . execute ( aliasesAddRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliases ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  ;", "assertTrue ( aliasesAddResponse . isAcknowledged (  )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( true )  )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( true )  )  ;", "Map < String ,    Object >    getAlias    =    getAlias ( index ,    alias )  ;", "assertThat ( getAlias . get (  \" index _ routing \"  )  ,    equalTo (  \" routing \"  )  )  ;", "assertThat ( getAlias . get (  \" search _ routing \"  )  ,    equalTo (  \" search _ routing \"  )  )  ;", "Map < String ,    Object >    filter    =     (  ( Map < String ,    Object >  )     ( getAlias . get (  \" filter \"  )  )  )  ;", "Map < String ,    Object >    term    =     (  ( Map < String ,    Object >  )     ( filter . get (  \" term \"  )  )  )  ;", "assertEquals (  2  0  1  6  ,    term . get (  \" year \"  )  )  ;", "String   alias 2     =     \" alias 2  \"  ;", "AliasesRequest   aliasesAddRemoveRequest    =    new   AliasesRequest (  )  ;", "addAction    =    new   AliasActions ( AliasActions . Type . ADD )  . indices ( index )  . alias ( alias 2  )  ;", "aliasesAddRemoveRequest . addAliasAction ( addAction )  ;", "AliasActions   removeAction    =    new   AliasActions ( AliasActions . Type . REMOVE )  . index ( index )  . alias ( alias )  ;", "aliasesAddRemoveRequest . addAliasAction ( removeAction )  ;", "AliasesResponse   aliasesAddRemoveResponse    =    ESRestHighLevelClientTestCase . execute ( aliasesAddRemoveRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliases ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  ;", "assertTrue ( aliasesAddRemoveResponse . isAcknowledged (  )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( alias 2  )  ,    equalTo ( true )  )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( index ,    alias 2  )  ,    equalTo ( true )  )  ;", "AliasesRequest   aliasesRemoveIndexRequest    =    new   AliasesRequest (  )  ;", "AliasActions   removeIndexAction    =    new   AliasActions ( AliasActions . Type . REMOVE _ INDEX )  . index ( index )  ;", "aliasesRemoveIndexRequest . addAliasAction ( removeIndexAction )  ;", "AliasesResponse   aliasesRemoveIndexResponse    =    ESRestHighLevelClientTestCase . execute ( aliasesRemoveIndexRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliases ,    ESRestHighLevelClientTestCase . highLevelClient (  )  . indices (  )  :  : updateAliasesAsync )  ;", "assertTrue ( aliasesRemoveIndexResponse . isAcknowledged (  )  )  ;", "assertThat ( aliasExists ( alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( alias 2  )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( index ,    alias )  ,    equalTo ( false )  )  ;", "assertThat ( aliasExists ( index ,    alias 2  )  ,    equalTo ( false )  )  ;", "assertThat ( indexExists ( index )  ,    equalTo ( false )  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateAliases"], "fileName": "org.elasticsearch.client.IndicesClientIT"}, {"methodBody": ["METHOD_START", "{", "MainResponse   info    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . info (  )  ;", "Map < String ,    Object >    infoAsMap    =    entityAsMap ( adminClient (  )  . performRequest ( METHOD _ NAME ,     \"  /  \"  )  )  ;", "assertEquals ( infoAsMap . get (  \" cluster _ name \"  )  ,    info . getClusterName (  )  . value (  )  )  ;", "assertEquals ( infoAsMap . get (  \" cluster _ uuid \"  )  ,    info . getClusterUuid (  )  )  ;", "assertNotNull ( info . getNodeName (  )  )  ;", "Map < String ,    Object >    versionMap    =     (  ( Map < String ,    Object >  )     ( infoAsMap . get (  \" version \"  )  )  )  ;", "assertEquals ( versionMap . get (  \" build _ hash \"  )  ,    info . getBuild (  )  . shortHash (  )  )  ;", "assertEquals ( versionMap . get (  \" build _ date \"  )  ,    info . getBuild (  )  . date (  )  )  ;", "assertEquals ( versionMap . get (  \" build _ snapshot \"  )  ,    info . getBuild (  )  . isSnapshot (  )  )  ;", "assertEquals ( versionMap . get (  \" number \"  )  ,    info . getVersion (  )  . toString (  )  )  ;", "assertEquals ( versionMap . get (  \" lucene _ version \"  )  ,    info . getVersion (  )  . luceneVersion . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInfo"], "fileName": "org.elasticsearch.client.PingAndInfoIT"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( ESRestHighLevelClientTestCase . highLevelClient (  )  . ping (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPing"], "fileName": "org.elasticsearch.client.PingAndInfoIT"}, {"methodBody": ["METHOD_START", "{", "return   Stream . of ( docs )  . map (  (    s )     -  >    new   RatedDocument ( indexName ,    s ,     1  )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["createRelevant"], "fileName": "org.elasticsearch.client.RankEvalIT"}, {"methodBody": ["METHOD_START", "{", "StringEntity   doc    =    new   StringEntity (  \"  {  \\  \" text \\  \"  :  \\  \" berlin \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  1  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" text \\  \"  :  \\  \" amsterdam \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  2  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  3  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  4  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  5  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index / doc /  6  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" POST \"  ,     \"  / index /  _ refresh \"  )  ;", "(  )  . performRequest (  \" PUT \"  ,     \"  / index 2  / doc /  7  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest (  \" POST \"  ,     \"  / index 2  /  _ refresh \"  )  ;", "}", "METHOD_END"], "methodName": ["indexDocuments"], "fileName": "org.elasticsearch.client.RankEvalIT"}, {"methodBody": ["METHOD_START", "{", "SearchSourceBuilder   testQuery    =    new   SearchSourceBuilder (  )  ;", "testQuery . query ( new   MatchAllQueryBuilder (  )  )  ;", "List < RatedDocument >    amsterdamRatedDocs    =     . createRelevant (  \" index \"  ,     \"  2  \"  ,     \"  3  \"  ,     \"  4  \"  ,     \"  5  \"  )  ;", "amsterdamRatedDocs . addAll (  . createRelevant (  \" index 2  \"  ,     \"  7  \"  )  )  ;", "RatedRequest   amsterdamRequest    =    new   RatedRequest (  \" amsterdam _ query \"  ,    amsterdamRatedDocs ,    testQuery )  ;", "RatedRequest   berlinRequest    =    new   RatedRequest (  \" berlin _ query \"  ,     . createRelevant (  \" index \"  ,     \"  1  \"  )  ,    testQuery )  ;", "List < RatedRequest >    specifications    =    new   ArrayList <  >  (  )  ;", "specifications . add ( amsterdamRequest )  ;", "specifications . add ( berlinRequest )  ;", "PrecisionAtK   metric    =    new   PrecisionAtK (  1  ,    false ,     1  0  )  ;", "RankEvalSpec   spec    =    new   RankEvalSpec ( specifications ,    metric )  ;", "RankEvalRequest   rankEvalRequest    =    new   RankEvalRequest ( spec ,    new   String [  ]  {     \" index \"  ,     \" index 2  \"     }  )  ;", "RankEvalResponse   response    =    ESRestHighLevelClientTestCase . execute ( rankEvalRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : rankEval ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : rankEvalAsync )  ;", "double   expectedPrecision    =     (  (  1  .  0     /     7  .  0  )     +     (  5  .  0     /     7  .  0  )  )     /     2  .  0  ;", "assertEquals ( expectedPrecision ,    response . getEvaluationResult (  )  ,    Double . MIN _ VALUE )  ;", "Map < String ,    EvalQueryQuality >    partialResults    =    response . getPartialResults (  )  ;", "assertEquals (  2  ,    partialResults . size (  )  )  ;", "EvalQueryQuality   amsterdamQueryQuality    =    partialResults . get (  \" amsterdam _ query \"  )  ;", "assertEquals (  2  ,    EvaluationMetric . filterUnknownDocuments ( amsterdamQueryQuality . getHitsAndRatings (  )  )  . size (  )  )  ;", "List < RatedSearchHit >    hitsAndRatings    =    amsterdamQueryQuality . getHitsAndRatings (  )  ;", "assertEquals (  7  ,    hitsAndRatings . size (  )  )  ;", "for    ( RatedSearchHit   hit    :    hitsAndRatings )     {", "String   id    =    hit . getSearchHit (  )  . getId (  )  ;", "if    (  ( id . equals (  \"  1  \"  )  )     |  |     ( id . equals (  \"  6  \"  )  )  )     {", "assertFalse ( hit . getRating (  )  . isPresent (  )  )  ;", "} else    {", "assertEquals (  1  ,    hit . getRating (  )  . get (  )  . intValue (  )  )  ;", "}", "}", "EvalQueryQuality   berlinQueryQuality    =    partialResults . get (  \" berlin _ query \"  )  ;", "assertEquals (  6  ,    EvaluationMetric . filterUnknownDocuments ( berlinQueryQuality . getHitsAndRatings (  )  )  . size (  )  )  ;", "hitsAndRatings    =    berlinQueryQuality . getHitsAndRatings (  )  ;", "assertEquals (  7  ,    hitsAndRatings . size (  )  )  ;", "for    ( RatedSearchHit   hit    :    hitsAndRatings )     {", "String   id    =    hit . getSearchHit (  )  . getId (  )  ;", "if    ( id . equals (  \"  1  \"  )  )     {", "assertEquals (  1  ,    hit . getRating (  )  . get (  )  . intValue (  )  )  ;", "} else    {", "assertFalse ( hit . getRating (  )  . isPresent (  )  )  ;", "}", "}", "client (  )  . performRequest (  \" POST \"  ,     \" index 2  /  _ close \"  ,    Collections . emptyMap (  )  )  ;", "rankEvalRequest . indicesOptions ( IndicesOptions . fromParameters ( null ,     \" true \"  ,    null ,    DEFAULT _ INDICES _ OPTIONS )  )  ;", "response    =    ESRestHighLevelClientTestCase . execute ( rankEvalRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : rankEval ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : rankEvalAsync )  ;", "}", "METHOD_END"], "methodName": ["testRankEvalRequest"], "fileName": "org.elasticsearch.client.RankEvalIT"}, {"methodBody": ["METHOD_START", "{", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( bulkRequest . timeout (  )  )  ;", "parameters . withRefreshPolicy ( bulkRequest . getRefreshPolicy (  )  )  ;", "XContentType   bulkContentType    =    null ;", "for    ( int   i    =     0  ;    i    <     ( bulkRequest . numberOfActions (  )  )  ;    i +  +  )     {", "DocWriteRequest <  ?  >    request    =    bulkRequest . requests (  )  . get ( i )  ;", "DocWriteRequest . OpType   opType    =    request . opType (  )  ;", "if    (  ( opType    =  =     ( OpType . INDEX )  )     |  |     ( opType    =  =     ( OpType . CREATE )  )  )     {", "bulkContentType    =    Request . enforceSameContentType (  (  ( IndexRequest )     ( request )  )  ,    bulkContentType )  ;", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "action . update . UpdateRequest   updateRequest    =     (  ( action . update . UpdateRequest )     ( request )  )  ;", "if    (  ( updateRequest . doc (  )  )     !  =    null )     {", "bulkContentType    =    Request . enforceSameContentType ( updateRequest . doc (  )  ,    bulkContentType )  ;", "}", "if    (  ( updateRequest . upsertRequest (  )  )     !  =    null )     {", "bulkContentType    =    Request . enforceSameContentType ( updateRequest . upsertRequest (  )  ,    bulkContentType )  ;", "}", "}", "}", "if    ( bulkContentType    =  =    null )     {", "bulkContentType    =    XContentType . JSON ;", "}", "final   byte   separator    =    bulkContentType . xContent (  )  . streamSeparator (  )  ;", "final   ContentType   requestContentType    =    Request . createContentType ( bulkContentType )  ;", "ByteArrayOutputStream   content    =    new   ByteArrayOutputStream (  )  ;", "for    ( DocWriteRequest <  ?  >    request    :    bulkRequest . requests (  )  )     {", "DocWriteRequest . OpType   opType    =    request . opType (  )  ;", "try    ( XContentBuilder   metadata    =    XContentBuilder . builder ( bulkContentType . xContent (  )  )  )     {", "metadata . startObject (  )  ;", "{", "metadata . startObject ( opType . getLowercase (  )  )  ;", "if    ( Strings . hasLength ( request . index (  )  )  )     {", "metadata . field (  \"  _ index \"  ,    request . index (  )  )  ;", "}", "if    ( Strings . hasLength ( request . type (  )  )  )     {", "metadata . field (  \"  _ type \"  ,    request . type (  )  )  ;", "}", "if    ( Strings . hasLength ( request . id (  )  )  )     {", "metadata . field (  \"  _ id \"  ,    request . id (  )  )  ;", "}", "if    ( Strings . hasLength ( request . routing (  )  )  )     {", "metadata . field (  \" routing \"  ,    request . routing (  )  )  ;", "}", "if    (  ( request . version (  )  )     !  =     ( Versions . MATCH _ ANY )  )     {", "metadata . field (  \" version \"  ,    request . version (  )  )  ;", "}", "VersionType   versionType    =    request . versionType (  )  ;", "if    ( versionType    !  =     ( VersionType . INTERNAL )  )     {", "if    ( versionType    =  =     ( VersionType . EXTERNAL )  )     {", "metadata . field (  \" version _ type \"  ,     \" external \"  )  ;", "} else", "if    ( versionType    =  =     ( VersionType . EXTERNAL _ GTE )  )     {", "metadata . field (  \" version _ type \"  ,     \" external _ gte \"  )  ;", "} else", "if    ( versionType    =  =     ( VersionType . FORCE )  )     {", "metadata . field (  \" version _ type \"  ,     \" force \"  )  ;", "}", "}", "if    (  ( opType    =  =     ( OpType . INDEX )  )     |  |     ( opType    =  =     ( OpType . CREATE )  )  )     {", "IndexRequest   indexRequest    =     (  ( IndexRequest )     ( request )  )  ;", "if    ( Strings . hasLength ( indexRequest . getPipeline (  )  )  )     {", "metadata . field (  \" pipeline \"  ,    indexRequest . getPipeline (  )  )  ;", "}", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "action . update . UpdateRequest   updateRequest    =     (  ( action . update . UpdateRequest )     ( request )  )  ;", "if    (  ( updateRequest . retryOnConflict (  )  )     >     0  )     {", "metadata . field (  \" retry _ on _ conflict \"  ,    updateRequest . retryOnConflict (  )  )  ;", "}", "if    (  ( updateRequest . fetchSource (  )  )     !  =    null )     {", "metadata . field (  \"  _ source \"  ,    updateRequest . fetchSource (  )  )  ;", "}", "}", "metadata . endObject (  )  ;", "}", "metadata . endObject (  )  ;", "BytesRef   metadataSource    =    BytesReference . bytes ( metadata )  . toBytesRef (  )  ;", "content . write ( metadataSource . bytes ,    metadataSource . offset ,    metadataSource . length )  ;", "content . write ( separator )  ;", "}", "BytesRef   source    =    null ;", "if    (  ( opType    =  =     ( OpType . INDEX )  )     |  |     ( opType    =  =     ( OpType . CREATE )  )  )     {", "IndexRequest   indexRequest    =     (  ( IndexRequest )     ( request )  )  ;", "BytesReference   indexSource    =    indexRequest . source (  )  ;", "XContentType   indexXContentType    =    indexRequest . getContentType (  )  ;", "try    ( XContentParser   parser    =    XContentHelper . createParser ( EMPTY ,    INSTANCE ,    indexSource ,    indexXContentType )  )     {", "try    ( XContentBuilder   builder    =    XContentBuilder . builder ( bulkContentType . xContent (  )  )  )     {", "builder . copyCurrentStructure ( parser )  ;", "source    =    BytesReference . bytes ( builder )  . toBytesRef (  )  ;", "}", "}", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "source    =    XContentHelper . toXContent (  (  ( action . update . UpdateRequest )     ( request )  )  ,    bulkContentType ,    false )  . toBytesRef (  )  ;", "}", "if    ( source    !  =    null )     {", "content . write ( source . bytes ,    source . offset ,    source . length )  ;", "content . write ( separator )  ;", "}", "}", "HttpEntity   entity    =    new   ByteArrayEntity ( content . toByteArray (  )  ,     0  ,    content . size (  )  ,    requestContentType )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,     \"  /  _ bulk \"  ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["bulk"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     (  ( clearIndicesCacheRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    clearIndicesCacheRequest . indices (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ cache / clear \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withIndicesOptions ( clearIndicesCacheRequest . indicesOptions (  )  )  ;", "parameters . putParam (  \" query \"  ,    Boolean . toString ( clearIndicesCacheRequest . queryCache (  )  )  )  ;", "parameters . putParam (  \" fielddata \"  ,    Boolean . toString ( clearIndicesCacheRequest . fieldDataCache (  )  )  )  ;", "parameters . putParam (  \" request \"  ,    Boolean . toString ( clearIndicesCacheRequest . requestCache (  )  )  )  ;", "parameters . putParam (  \" fields \"  ,    String . join (  \"  ,  \"  ,    clearIndicesCacheRequest . fields (  )  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["clearCache"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "HttpEntity   entity    =    Request . createEntity ( clearScrollRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpDelete . METHOD _ NAME ,     \"  /  _ search / scroll \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["clearScroll"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( closeIndexRequest . indices (  )  ,     \"  _ close \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( closeIndexRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( closeIndexRequest . masterNodeTimeout (  )  )  ;", "parameters . withIndicesOptions ( closeIndexRequest . indicesOptions (  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["closeIndex"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withFlatSettings ( clusterUpdateSettingsRequest . flatSettings (  )  )  ;", "parameters . withTimeout ( clusterUpdateSettingsRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( clusterUpdateSettingsRequest . masterNodeTimeout (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( clusterUpdateSettingsRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPut . METHOD _ NAME ,     \"  /  _ cluster / settings \"  ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["clusterPutSettings"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   ContentType . create ( xContentType . mediaTypeWithoutParameters (  )  ,     (  ( Charset )     ( null )  )  )  ;", "}", "METHOD_END"], "methodName": ["createContentType"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "BytesRef   source    =    XContentHelper . toXContent ( toXContent ,    xContentType ,    false )  . toBytesRef (  )  ;", "return   new   ByteArrayEntity ( source . bytes ,    source . offset ,    source . length ,     . createContentType ( xContentType )  )  ;", "}", "METHOD_END"], "methodName": ["createEntity"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( createIndexRequest . indices (  )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( createIndexRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( createIndexRequest . masterNodeTimeout (  )  )  ;", "parameters . withWaitForActiveShards ( createIndexRequest . waitForActiveShards (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( createIndexRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPut . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["createIndex"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( deleteRequest . index (  )  ,    deleteRequest . type (  )  ,    deleteRequest . id (  )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withRouting ( deleteRequest . routing (  )  )  ;", "parameters . withTimeout ( deleteRequest . timeout (  )  )  ;", "parameters . withVersion ( deleteRequest . version (  )  )  ;", "parameters . withVersionType ( deleteRequest . versionType (  )  )  ;", "parameters . withRefreshPolicy ( deleteRequest . getRefreshPolicy (  )  )  ;", "parameters . withWaitForActiveShards ( deleteRequest . waitForActiveShards (  )  )  ;", "return   new   Request ( HttpDelete . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( deleteIndexRequest . indices (  )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( deleteIndexRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( deleteIndexRequest . masterNodeTimeout (  )  )  ;", "parameters . withIndicesOptions ( deleteIndexRequest . indicesOptions (  )  )  ;", "return   new   Request ( HttpDelete . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["deleteIndex"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addPathPart ( index ,    type ,    id )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addPathPart ( index ,    type ,    id )  . addPathPartAsIs ( endpoint )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( indices )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( indices )  . addPathPartAsIs ( endpoint )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( indices )  . addPathPartAsIs ( endpoint )  . addPathPart ( type )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( indices )  . addPathPartAsIs ( endpoint )  . addCommaSeparatedPathParts ( suffixes )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( indices )  . addCommaSeparatedPathParts ( types )  . addPathPartAsIs ( endpoint )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["endpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "XContentType   requestContentType    =    indexRequest . getContentType (  )  ;", "if    (  ( requestContentType    !  =     ( XContentType . JSON )  )     &  &     ( requestContentType    !  =     ( XContentType . SMILE )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Unsupported   content - type   found   for   request   with   content - type    [  \"     +    requestContentType )     +     \"  ]  ,    only   JSON   and   SMILE   are   supported \"  )  )  ;", "}", "if    ( xContentType    =  =    null )     {", "return   requestContentType ;", "}", "if    ( requestContentType    !  =    xContentType )     {", "throw   new   IllegalArgumentException (  (  (  (  (  \" Mismatching   content - type   found   for   request   with   content - type    [  \"     +    requestContentType )     +     \"  ]  ,    previous   requests   have   content - type    [  \"  )     +    xContentType )     +     \"  ]  \"  )  )  ;", "}", "return   xContentType ;", "}", "METHOD_END"], "methodName": ["enforceSameContentType"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request   request    =    Request . get ( getRequest )  ;", "return   new   Request ( HttpHead . METHOD _ NAME ,    request . endpoint ,    request . parameters ,    null )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . withIndicesOptions ( getAliasesRequest . indicesOptions (  )  )  ;", "params . withLocal ( getAliasesRequest . local (  )  )  ;", "if    (  (  (  ( getAliasesRequest . indices (  )  )     =  =    null )     |  |     (  ( getAliasesRequest . indices (  )  . length )     =  =     0  )  )     &  &     (  (  ( getAliasesRequest . aliases (  )  )     =  =    null )     |  |     (  ( getAliasesRequest . aliases (  )  . length )     =  =     0  )  )  )     {", "throw   new   IllegalArgumentException (  \" existsAlias   requires   at   least   an   alias   or   an   index \"  )  ;", "}", "String [  ]    indices    =     (  ( getAliasesRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    getAliasesRequest . indices (  )  ;", "String [  ]    aliases    =     (  ( getAliasesRequest . aliases (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    getAliasesRequest . aliases (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ alias \"  ,    aliases )  ;", "return   new   Request ( HttpHead . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["existsAlias"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     (  ( flushRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    flushRequest . indices (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ flush \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withIndicesOptions ( flushRequest . indicesOptions (  )  )  ;", "parameters . putParam (  \" wait _ if _ ongoing \"  ,    Boolean . toString ( flushRequest . waitIfOngoing (  )  )  )  ;", "parameters . putParam (  \" force \"  ,    Boolean . toString ( flushRequest . force (  )  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["flush"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     (  ( forceMergeRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    forceMergeRequest . indices (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ forcemerge \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withIndicesOptions ( forceMergeRequest . indicesOptions (  )  )  ;", "parameters . putParam (  \" max _ num _ segments \"  ,    Integer . toString ( forceMergeRequest . maxNumSegments (  )  )  )  ;", "parameters . putParam (  \" only _ expunge _ deletes \"  ,    Boolean . toString ( forceMergeRequest . onlyExpungeDeletes (  )  )  )  ;", "parameters . putParam (  \" flush \"  ,    Boolean . toString ( forceMergeRequest . flush (  )  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["forceMerge"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( getRequest . index (  )  ,    getRequest . type (  )  ,    getRequest . id (  )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withPreference ( getRequest . preference (  )  )  ;", "parameters . withRouting ( getRequest . routing (  )  )  ;", "parameters . withRefresh ( getRequest . refresh (  )  )  ;", "parameters . withRealtime ( getRequest . realtime (  )  )  ;", "parameters . withStoredFields ( getRequest . storedFields (  )  )  ;", "parameters . withVersion ( getRequest . version (  )  )  ;", "parameters . withVersionType ( getRequest . versionType (  )  )  ;", "parameters . withFetchSourceContext ( getRequest . fetchSourceContext (  )  )  ;", "return   new   Request ( HttpGet . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   endpoint ;", "}", "METHOD_END"], "methodName": ["getEndpoint"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   entity ;", "}", "METHOD_END"], "methodName": ["getEntity"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   method ;", "}", "METHOD_END"], "methodName": ["getMethod"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   parameters ;", "}", "METHOD_END"], "methodName": ["getParameters"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   method    =     ( Strings . hasLength ( indexRequest . id (  )  )  )     ?    HttpPut . METHOD _ NAME    :    HttpPost . METHOD _ NAME ;", "boolean   isCreate    =     ( indexRequest . opType (  )  )     =  =     ( OpType . CREATE )  ;", "String   endpoint    =    Request . endpoint ( indexRequest . index (  )  ,    indexRequest . type (  )  ,    indexRequest . id (  )  ,     ( isCreate    ?     \"  _ create \"     :    null )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withRouting ( indexRequest . routing (  )  )  ;", "parameters . withTimeout ( indexRequest . timeout (  )  )  ;", "parameters . withVersion ( indexRequest . version (  )  )  ;", "parameters . withVersionType ( indexRequest . versionType (  )  )  ;", "parameters . withPipeline ( indexRequest . getPipeline (  )  )  ;", "parameters . withRefreshPolicy ( indexRequest . getRefreshPolicy (  )  )  ;", "parameters . withWaitForActiveShards ( indexRequest . waitForActiveShards (  )  )  ;", "BytesRef   source    =    indexRequest . source (  )  . toBytesRef (  )  ;", "ContentType   contentType    =    Request . createContentType ( indexRequest . getContentType (  )  )  ;", "HttpEntity   entity    =    new   ByteArrayEntity ( source . bytes ,    source . offset ,    source . length ,    contentType )  ;", "return   new   Request ( method ,    endpoint ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["index"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( updateSettingsRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( updateSettingsRequest . masterNodeTimeout (  )  )  ;", "parameters . withIndicesOptions ( updateSettingsRequest . indicesOptions (  )  )  ;", "parameters . withFlatSettings ( updateSettingsRequest . flatSettings (  )  )  ;", "parameters . withPreserveExisting ( updateSettingsRequest . isPreserveExisting (  )  )  ;", "String [  ]    indices    =     (  ( updateSettingsRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    updateSettingsRequest . indices (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ settings \"  )  ;", "HttpEntity   entity    =    Request . createEntity ( updateSettingsRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPut . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["indexPutSettings"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( request . indices (  )  )     =  =    null )     |  |     (  ( request . indices (  )  . length )     =  =     0  )  )     {", "throw   new   IllegalArgumentException (  \" indices   are   mandatory \"  )  ;", "}", "String   endpoint    =     . endpoint ( request . indices (  )  ,     \"  \"  )  ;", ". Params   params    =     . Params . builder (  )  ;", "params . withLocal ( request . local (  )  )  ;", "params . withHuman ( request . humanReadable (  )  )  ;", "params . withIndicesOptions ( request . indicesOptions (  )  )  ;", "params . withFlatSettings ( request . flatSettings (  )  )  ;", "params . withIncludeDefaults ( request . includeDefaults (  )  )  ;", "return   new    ( HttpHead . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["indicesExist"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["info"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withPreference ( multiGetRequest . preference (  )  )  ;", "parameters . withRealtime ( multiGetRequest . realtime (  )  )  ;", "parameters . withRefresh ( multiGetRequest . refresh (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( multiGetRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,     \"  /  _ mget \"  ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["multiGet"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . putParam ( TYPED _ KEYS _ PARAM ,     \" true \"  )  ;", "if    (  ( multiSearchRequest . maxConcurrentSearchRequests (  )  )     !  =     ( MultiSearchRequest . MAX _ CONCURRENT _ SEARCH _ REQUESTS _ DEFAULT )  )     {", "params . putParam (  \" max _ concurrent _ searches \"  ,    Integer . toString ( multiSearchRequest . maxConcurrentSearchRequests (  )  )  )  ;", "}", "XContent   xContent    =    Request . REQUEST _ BODY _ CONTENT _ TYPE . xContent (  )  ;", "byte [  ]    source    =    MultiSearchRequest . writeMultiLineFormat ( multiSearchRequest ,    xContent )  ;", "HttpEntity   entity    =    new   ByteArrayEntity ( source ,    Request . createContentType ( xContent . type (  )  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,     \"  /  _ msearch \"  ,    params . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["multiSearch"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( openIndexRequest . indices (  )  ,     \"  _ open \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( openIndexRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( openIndexRequest . masterNodeTimeout (  )  )  ;", "parameters . withWaitForActiveShards ( openIndexRequest . waitForActiveShards (  )  )  ;", "parameters . withIndicesOptions ( openIndexRequest . indicesOptions (  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["openIndex"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "return   new   Request ( HttpHead . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["ping"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "if    (  ( putMappingRequest . getConcreteIndex (  )  )     !  =    null )     {", "throw   new   IllegalArgumentException (  \" concreteIndex   cannot   be   set   on   PutMapping   requests   made   over   the   REST   API \"  )  ;", "}", "String   endpoint    =    Request . endpoint ( putMappingRequest . indices (  )  ,     \"  _ mapping \"  ,    putMappingRequest . type (  )  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( putMappingRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( putMappingRequest . masterNodeTimeout (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( putMappingRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPut . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["putMapping"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( rankEvalRequest . indices (  )  ,    EMPTY _ ARRAY ,     \"  _ rank _ eval \"  )  ;", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . withIndicesOptions ( rankEvalRequest . indicesOptions (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( rankEvalRequest . getRankEvalSpec (  )  ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpGet . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["rankEval"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     (  ( refreshRequest . indices (  )  )     =  =    null )     ?    Strings . EMPTY _ ARRAY    :    refreshRequest . indices (  )  ;", "String   endpoint    =    Request . endpoint ( indices ,     \"  _ refresh \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withIndicesOptions ( refreshRequest . indicesOptions (  )  )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["refresh"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . withTimeout ( resizeRequest . timeout (  )  )  ;", "params . withMasterTimeout ( resizeRequest . masterNodeTimeout (  )  )  ;", "params . withWaitForActiveShards ( resizeRequest . getTargetIndexRequest (  )  . waitForActiveShards (  )  )  ;", "String   endpoint    =    new   Request . EndpointBuilder (  )  . addPathPart ( resizeRequest . getSourceIndex (  )  )  . addPathPartAsIs (  (  \"  _  \"     +     ( resizeRequest . getResizeType (  )  . name (  )  . toLowerCase ( Locale . ROOT )  )  )  )  . addPathPart ( resizeRequest . getTargetIndexRequest (  )  . index (  )  )  . build (  )  ;", "HttpEntity   entity    =    Request . createEntity ( resizeRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPut . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["resize"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . withTimeout ( rolloverRequest . timeout (  )  )  ;", "params . withMasterTimeout ( rolloverRequest . masterNodeTimeout (  )  )  ;", "params . withWaitForActiveShards ( rolloverRequest . getCreateIndexRequest (  )  . waitForActiveShards (  )  )  ;", "if    ( rolloverRequest . isDryRun (  )  )     {", "params . putParam (  \" dry _ run \"  ,    Boolean . TRUE . toString (  )  )  ;", "}", "String   endpoint    =    new   Request . EndpointBuilder (  )  . addPathPart ( rolloverRequest . getAlias (  )  )  . addPathPartAsIs (  \"  _ rollover \"  )  . addPathPart ( rolloverRequest . getNewIndexName (  )  )  . build (  )  ;", "HttpEntity   entity    =    Request . createEntity ( rolloverRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["rollover"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( searchRequest . indices (  )  ,    searchRequest . types (  )  ,     \"  _ search \"  )  ;", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . putParam ( TYPED _ KEYS _ PARAM ,     \" true \"  )  ;", "params . withRouting ( searchRequest . routing (  )  )  ;", "params . withPreference ( searchRequest . preference (  )  )  ;", "params . withIndicesOptions ( searchRequest . indicesOptions (  )  )  ;", "params . putParam (  \" search _ type \"  ,    searchRequest . searchType (  )  . name (  )  . toLowerCase ( Locale . ROOT )  )  ;", "if    (  ( searchRequest . requestCache (  )  )     !  =    null )     {", "params . putParam (  \" request _ cache \"  ,    Boolean . toString ( searchRequest . requestCache (  )  )  )  ;", "}", "if    (  ( searchRequest . allowPartialSearchResults (  )  )     !  =    null )     {", "params . putParam (  \" allow _ partial _ search _ results \"  ,    Boolean . toString ( searchRequest . allowPartialSearchResults (  )  )  )  ;", "}", "params . putParam (  \" batched _ reduce _ size \"  ,    Integer . toString ( searchRequest . getBatchedReduceSize (  )  )  )  ;", "if    (  ( searchRequest . scroll (  )  )     !  =    null )     {", "params . putParam (  \" scroll \"  ,    searchRequest . scroll (  )  . keepAlive (  )  )  ;", "}", "HttpEntity   entity    =    null ;", "if    (  ( searchRequest . source (  )  )     !  =    null )     {", "entity    =    Request . createEntity ( searchRequest . source (  )  ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "}", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    params . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["search"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "HttpEntity   entity    =    Request . createEntity ( searchScrollRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,     \"  /  _ search / scroll \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["searchScroll"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resizeRequest . getResizeType (  )  )     !  =     ( ResizeType . SHRINK )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Wrong   resize   type    [  \"     +     ( resizeRequest . getResizeType (  )  )  )     +     \"  ]    for   indices   shrink   request \"  )  )  ;", "}", "return   Request . resize ( resizeRequest )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "if    (  ( resizeRequest . getResizeType (  )  )     !  =     ( ResizeType . SPLIT )  )     {", "throw   new   IllegalArgumentException (  (  (  \" Wrong   resize   type    [  \"     +     ( resizeRequest . getResizeType (  )  )  )     +     \"  ]    for   indices   split   request \"  )  )  ;", "}", "return   Request . resize ( resizeRequest )  ;", "}", "METHOD_END"], "methodName": ["split"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   endpoint    =    Request . endpoint ( updateRequest . index (  )  ,    updateRequest . type (  )  ,    updateRequest . id (  )  ,     \"  _ update \"  )  ;", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withRouting ( updateRequest . routing (  )  )  ;", "parameters . withTimeout ( updateRequest . timeout (  )  )  ;", "parameters . withRefreshPolicy ( updateRequest . getRefreshPolicy (  )  )  ;", "parameters . withWaitForActiveShards ( updateRequest . waitForActiveShards (  )  )  ;", "parameters . withDocAsUpsert ( updateRequest . docAsUpsert (  )  )  ;", "parameters . withFetchSourceContext ( updateRequest . fetchSource (  )  )  ;", "parameters . withRetryOnConflict ( updateRequest . retryOnConflict (  )  )  ;", "parameters . withVersion ( updateRequest . version (  )  )  ;", "parameters . withVersionType ( updateRequest . versionType (  )  )  ;", "XContentType   xContentType    =    null ;", "if    (  ( updateRequest . doc (  )  )     !  =    null )     {", "xContentType    =    updateRequest . doc (  )  . getContentType (  )  ;", "}", "if    (  ( updateRequest . upsertRequest (  )  )     !  =    null )     {", "XContentType   upsertContentType    =    updateRequest . upsertRequest (  )  . getContentType (  )  ;", "if    (  ( xContentType    !  =    null )     &  &     ( xContentType    !  =    upsertContentType )  )     {", "throw   new   IllegalStateException (  (  (  (  (  (  \" Update   request   cannot   have   different   content   types   for   doc    [  \"     +    xContentType )     +     \"  ]  \"  )     +     \"    and   upsert    [  \"  )     +    upsertContentType )     +     \"  ]    documents \"  )  )  ;", "} else    {", "xContentType    =    upsertContentType ;", "}", "}", "if    ( xContentType    =  =    null )     {", "xContentType    =    Requests . INDEX _ CONTENT _ TYPE ;", "}", "HttpEntity   entity    =    Request . createEntity ( updateRequest ,    xContentType )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,    endpoint ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "Request . Params   parameters    =    Request . Params . builder (  )  ;", "parameters . withTimeout ( indicesAliasesRequest . timeout (  )  )  ;", "parameters . withMasterTimeout ( indicesAliasesRequest . masterNodeTimeout (  )  )  ;", "HttpEntity   entity    =    Request . createEntity ( indicesAliasesRequest ,    Request . REQUEST _ BODY _ CONTENT _ TYPE )  ;", "return   new   Request ( HttpPost . METHOD _ NAME ,     \"  /  _ aliases \"  ,    parameters . getParams (  )  ,    entity )  ;", "}", "METHOD_END"], "methodName": ["updateAliases"], "fileName": "org.elasticsearch.client.Request"}, {"methodBody": ["METHOD_START", "{", "String   requestLine    =     (  (  (  (  \" curl    - iX    \"     +     ( request . getMethod (  )  )  )     +     \"     '  \"  )     +    host )     +     ( RequestLogger . getUri ( request . getRequestLine (  )  )  )  )     +     \"  '  \"  ;", "if    ( request   instanceof   HttpEntityEnclosingRequest )     {", "HttpEntityEnclosingRequest   enclosingRequest    =     (  ( HttpEntityEnclosingRequest )     ( request )  )  ;", "if    (  ( enclosingRequest . getEntity (  )  )     !  =    null )     {", "requestLine    +  =     \"     - d    '  \"  ;", "HttpEntity   entity    =    enclosingRequest . getEntity (  )  ;", "if    (  ( entity . isRepeatable (  )  )     =  =    false )     {", "entity    =    new   BufferedHttpEntity ( enclosingRequest . getEntity (  )  )  ;", "enclosingRequest . setEntity ( entity )  ;", "}", "requestLine    +  =     ( EntityUtils . toString ( entity ,    StandardCharsets . UTF _  8  )  )     +     \"  '  \"  ;", "}", "}", "return   requestLine ;", "}", "METHOD_END"], "methodName": ["buildTraceRequest"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   responseLine    =    new   StringBuilder (  )  ;", "responseLine . append (  \"  #     \"  )  . append ( httpResponse . getStatusLine (  )  )  ;", "for    ( Header   header    :    httpResponse . getAllHeaders (  )  )     {", "responseLine . append (  \"  \\ n #     \"  )  . append ( header . getName (  )  )  . append (  \"  :     \"  )  . append ( header . getValue (  )  )  ;", "}", "responseLine . append (  \"  \\ n #  \"  )  ;", "HttpEntity   entity    =    httpResponse . getEntity (  )  ;", "if    ( entity    !  =    null )     {", "if    (  ( entity . isRepeatable (  )  )     =  =    false )     {", "entity    =    new   apache . http . entity . BufferedHttpEntity ( entity )  ;", "}", "httpResponse . setEntity ( entity )  ;", "ContentType   contentType    =    ContentType . get ( entity )  ;", "Charset   charset    =    StandardCharsets . UTF _  8  ;", "if    (  ( contentType    !  =    null )     &  &     (  ( contentType . getCharset (  )  )     !  =    null )  )     {", "charset    =    contentType . getCharset (  )  ;", "}", "try    ( BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( entity . getContent (  )  ,    charset )  )  )     {", "String   line ;", "while    (  ( line    =    reader . readLine (  )  )     !  =    null )     {", "responseLine . append (  \"  \\ n #     \"  )  . append ( line )  ;", "}", "}", "}", "return   responseLine . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildTraceResponse"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   message    =    new   StringBuilder (  \" request    [  \"  )  . append ( request . getMethod (  )  )  . append (  \"     \"  )  . append ( host )  . append ( RequestLogger . getUri ( request . getRequestLine (  )  )  )  . append (  \"  ]    returned    \"  )  . append ( warnings . length )  . append (  \"    warnings :     \"  )  ;", "for    ( int   i    =     0  ;    i    <     ( warnings . length )  ;    i +  +  )     {", "if    ( i    >     0  )     {", "message . append (  \"  ,  \"  )  ;", "}", "message . append (  \"  [  \"  )  . append ( warnings [ i ]  . getValue (  )  )  . append (  \"  ]  \"  )  ;", "}", "return   message . toString (  )  ;", "}", "METHOD_END"], "methodName": ["buildWarningMessage"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "if    (  ( requestLine . getUri (  )  . charAt (  0  )  )     !  =     '  /  '  )     {", "return    \"  /  \"     +     ( requestLine . getUri (  )  )  ;", "}", "return   requestLine . getUri (  )  ;", "}", "METHOD_END"], "methodName": ["getUri"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  \" request    [  \"     +     ( request . getMethod (  )  )  )     +     \"     \"  )     +    host )     +     (  . getUri ( request . getRequestLine (  )  )  )  )     +     \"  ]    failed \"  )  ,    e )  ;", "}", "if    (  . tracer . isTraceEnabled (  )  )     {", "String   traceRequest ;", "try    {", "traceRequest    =     . buildTraceRequest ( request ,    host )  ;", "}    catch    ( IOException   e 1  )     {", ". tracer . trace (  \" error   while   reading   request   for   trace   purposes \"  ,    e )  ;", "traceRequest    =     \"  \"  ;", "}", ". tracer . trace ( traceRequest )  ;", "}", "}", "METHOD_END"], "methodName": ["logFailedRequest"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "if    ( logger . isDebugEnabled (  )  )     {", "logger . debug (  (  (  (  (  (  (  (  \" request    [  \"     +     ( request . getMethod (  )  )  )     +     \"     \"  )     +    host )     +     (  . getUri ( request . getRequestLine (  )  )  )  )     +     \"  ]    returned    [  \"  )     +     ( httpResponse . getStatusLine (  )  )  )     +     \"  ]  \"  )  )  ;", "}", "if    ( logger . isWarnEnabled (  )  )     {", "Header [  ]    warnings    =    httpResponse . getHeaders (  \" Warning \"  )  ;", "if    (  ( warnings    !  =    null )     &  &     (  ( warnings . length )     >     0  )  )     {", "logger . warn (  . buildWarningMessage ( request ,    host ,    warnings )  )  ;", "}", "}", "if    (  . tracer . isTraceEnabled (  )  )     {", "String   requestLine ;", "try    {", "requestLine    =     . buildTraceRequest ( request ,    host )  ;", "}    catch    ( IOException   e )     {", "requestLine    =     \"  \"  ;", ". tracer . trace (  \" error   while   reading   request   for   trace   purposes \"  ,    e )  ;", "}", "String   responseLine ;", "try    {", "responseLine    =     . buildTraceResponse ( httpResponse )  ;", "}    catch    ( IOException   e )     {", "responseLine    =     \"  \"  ;", ". tracer . trace (  \" error   while   reading   response   for   trace   purposes \"  ,    e )  ;", "}", ". tracer . trace (  (  ( requestLine    +     '  \\ n '  )     +    responseLine )  )  ;", "}", "}", "METHOD_END"], "methodName": ["logResponse"], "fileName": "org.elasticsearch.client.RequestLogger"}, {"methodBody": ["METHOD_START", "{", "int   requestType    =    randomIntBetween (  0  ,     7  )  ;", "switch    ( requestType )     {", "case    0     :", "return   new   HttpGetWithEntity ( uri )  ;", "case    1     :", "return   new   HttpPost ( uri )  ;", "case    2     :", "return   new   HttpPut ( uri )  ;", "case    3     :", "return   new   HttpDeleteWithEntity ( uri )  ;", "case    4     :", "return   new   HttpHead ( uri )  ;", "case    5     :", "return   new   HttpTrace ( uri )  ;", "case    6     :", "return   new   HttpOptions ( uri )  ;", "case    7     :", "return   new   HttpPatch ( uri )  ;", "default    :", "throw   new   UnsupportedOperationException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["randomHttpRequest"], "fileName": "org.elasticsearch.client.RequestLoggerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHost   host    =    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ;", "HttpUriRequest   request    =     . randomHttpRequest ( new   URI (  \"  / index / type /  _ api \"  )  )  ;", "int   numWarnings    =    randomIntBetween (  1  ,     5  )  ;", "StringBuilder   expected    =    new   StringBuilder (  \" request    [  \"  )  . append ( request . getMethod (  )  )  . append (  \"     \"  )  . append ( host )  . append (  \"  / index / type /  _ api ]    returned    \"  )  . append ( numWarnings )  . append (  \"    warnings :     \"  )  ;", "Header [  ]    warnings    =    new   Header [ numWarnings ]  ;", "for    ( int   i    =     0  ;    i    <    numWarnings ;    i +  +  )     {", "String   warning    =     \" this   is   warning   number    \"     +    i ;", "warnings [ i ]     =    new   BasicHeader (  \" Warning \"  ,    warning )  ;", "if    ( i    >     0  )     {", "expected . append (  \"  ,  \"  )  ;", "}", "expected . append (  \"  [  \"  )  . append ( warning )  . append (  \"  ]  \"  )  ;", "}", "assertEquals ( expected . toString (  )  ,    RequestLogger . buildWarningMessage ( request ,    host ,    warnings )  )  ;", "}", "METHOD_END"], "methodName": ["testResponseWarnings"], "fileName": "org.elasticsearch.client.RequestLoggerTests"}, {"methodBody": ["METHOD_START", "{", "HttpHost   host    =    new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     ( randomBoolean (  )     ?     \" http \"     :     \" https \"  )  )  ;", "String   expectedEndpoint    =     \"  / index / type /  _ api \"  ;", "URI   uri ;", "if    ( randomBoolean (  )  )     {", "uri    =    new   URI ( expectedEndpoint )  ;", "} else    {", "uri    =    new   URI (  \" index / type /  _ api \"  )  ;", "}", "HttpUriRequest   request    =     . randomHttpRequest ( uri )  ;", "String   expected    =     (  (  (  (  \" curl    - iX    \"     +     ( request . getMethod (  )  )  )     +     \"     '  \"  )     +    host )     +    expectedEndpoint )     +     \"  '  \"  ;", "boolean   hasBody    =     ( request   instanceof   HttpEntityEnclosingRequest )     &  &     ( randomBoolean (  )  )  ;", "String   requestBody    =     \"  {     \\  \" field \\  \"  :     \\  \" value \\  \"     }  \"  ;", "if    ( hasBody )     {", "expected    +  =     (  \"     - d    '  \"     +    requestBody )     +     \"  '  \"  ;", "HttpEntityEnclosingRequest   enclosingRequest    =     (  ( HttpEntityEnclosingRequest )     ( request )  )  ;", "HttpEntity   entity ;", "switch    ( randomIntBetween (  0  ,     4  )  )     {", "case    0     :", "entity    =    new   StringEntity ( requestBody ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    1     :", "entity    =    new   InputStreamEntity ( new   ByteArrayInputStream ( requestBody . getBytes ( StandardCharsets . UTF _  8  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    2     :", "entity    =    new   NStringEntity ( requestBody ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    3     :", "entity    =    new   NByteArrayEntity ( requestBody . getBytes ( StandardCharsets . UTF _  8  )  ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    4     :", "entity    =    new   StringEntity ( requestBody ,    ContentType . create (  \" application / json \"  ,     (  ( Charset )     ( null )  )  )  )  ;", "break ;", "default    :", "throw   new   UnsupportedOperationException (  )  ;", "}", "enclosingRequest . setEntity ( entity )  ;", "}", "String   traceRequest    =    RequestLogger . buildTraceRequest ( request ,    host )  ;", "assertThat ( traceRequest ,    equalTo ( expected )  )  ;", "if    ( hasBody )     {", "String   body    =    EntityUtils . toString (  (  ( HttpEntityEnclosingRequest )     ( request )  )  . getEntity (  )  ,    StandardCharsets . UTF _  8  )  ;", "assertThat ( body ,    equalTo ( requestBody )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTraceRequest"], "fileName": "org.elasticsearch.client.RequestLoggerTests"}, {"methodBody": ["METHOD_START", "{", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "int   statusCode    =    randomIntBetween (  2  0  0  ,     5  9  9  )  ;", "String   reasonPhrase    =     \" REASON \"  ;", "BasicStatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,    statusCode ,    reasonPhrase )  ;", "String   expected    =     \"  #     \"     +     ( statusLine . toString (  )  )  ;", "BasicHttpResponse   httpResponse    =    new   BasicHttpResponse ( statusLine )  ;", "int   numHeaders    =    randomIntBetween (  0  ,     3  )  ;", "for    ( int   i    =     0  ;    i    <    numHeaders ;    i +  +  )     {", "httpResponse . setHeader (  (  \" header \"     +    i )  ,     \" value \"  )  ;", "expected    +  =     (  \"  \\ n #    header \"     +    i )     +     \"  :    value \"  ;", "}", "expected    +  =     \"  \\ n #  \"  ;", "boolean   hasBody    =    getRandom (  )  . nextBoolean (  )  ;", "String   responseBody    =     \"  {  \\ n       \\  \" field \\  \"  :     \\  \" value \\  \"  \\ n }  \"  ;", "if    ( hasBody )     {", "expected    +  =     \"  \\ n #     {  \"  ;", "expected    +  =     \"  \\ n #           \\  \" field \\  \"  :     \\  \" value \\  \"  \"  ;", "expected    +  =     \"  \\ n #     }  \"  ;", "HttpEntity   entity ;", "switch    ( randomIntBetween (  0  ,     2  )  )     {", "case    0     :", "entity    =    new   StringEntity ( responseBody ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    1     :", "entity    =    new   InputStreamEntity ( new   ByteArrayInputStream ( responseBody . getBytes ( StandardCharsets . UTF _  8  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "break ;", "case    2     :", "entity    =    new   StringEntity ( responseBody ,    ContentType . create (  \" application / json \"  ,     (  ( Charset )     ( null )  )  )  )  ;", "break ;", "default    :", "throw   new   UnsupportedOperationException (  )  ;", "}", "httpResponse . setEntity ( entity )  ;", "}", "String   traceResponse    =     . buildTraceResponse ( httpResponse )  ;", "assertThat ( traceResponse ,    equalTo ( expected )  )  ;", "if    ( hasBody )     {", "String   body    =    EntityUtils . toString ( httpResponse . getEntity (  )  ,    StandardCharsets . UTF _  8  )  ;", "assertThat ( body ,    equalTo ( responseBody )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testTraceResponse"], "fileName": "org.elasticsearch.client.RequestLoggerTests"}, {"methodBody": ["METHOD_START", "{", "BytesReference   expectedBytes    =    XContentHelper . toXContent ( expectedBody ,    Request . REQUEST _ BODY _ CONTENT _ TYPE ,    false )  ;", "assertEquals ( JSON . mediaTypeWithoutParameters (  )  ,    actualEntity . getContentType (  )  . getValue (  )  )  ;", "assertEquals ( expectedBytes ,    new   ommon . bytes . BytesArray ( EntityUtils . toByteArray ( actualEntity )  )  )  ;", "}", "METHOD_END"], "methodName": ["assertToXContentBody"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String   index    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   id    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "GetRequest   getRequest    =    new   GetRequest ( index ,    type ,    id )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "if    ( randomBoolean (  )  )     {", "if    ( randomBoolean (  )  )     {", "String   preference    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "getRequest . preference ( preference )  ;", "expectedParams . put (  \" preference \"  ,    preference )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   routing    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "getRequest . routing ( routing )  ;", "expectedParams . put (  \" routing \"  ,    routing )  ;", "}", "if    ( randomBoolean (  )  )     {", "boolean   realtime    =    randomBoolean (  )  ;", "getRequest . realtime ( realtime )  ;", "if    ( realtime    =  =    false )     {", "expectedParams . put (  \" realtime \"  ,     \" false \"  )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", "boolean   refresh    =    randomBoolean (  )  ;", "getRequest . refresh ( refresh )  ;", "if    ( refresh )     {", "expectedParams . put (  \" refresh \"  ,     \" true \"  )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", "long   version    =    randomLong (  )  ;", "getRequest . version ( version )  ;", "if    ( version    !  =     ( Versions . MATCH _ ANY )  )     {", "expectedParams . put (  \" version \"  ,    Long . toString ( version )  )  ;", "}", "}", ". setRandomVersionType ( getRequest :  : versionType ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "int   numStoredFields    =    randomIntBetween (  1  ,     1  0  )  ;", "String [  ]    storedFields    =    new   String [ numStoredFields ]  ;", "String   storedFieldsParam    =     . randomFields ( storedFields )  ;", "getRequest . storedFields ( storedFields )  ;", "expectedParams . put (  \" stored _ fields \"  ,    storedFieldsParam )  ;", "}", "if    ( randomBoolean (  )  )     {", ". randomizeFetchSourceContextParams ( getRequest :  : fetchSourceContext ,    expectedParams )  ;", "}", "}", "Request   request    =    requestConverter . apply ( getRequest )  ;", "assertEquals (  (  (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )     +     \"  /  \"  )     +    id )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "assertEquals ( method ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAndExistsTest"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   excludesParam    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( fields . length )  ;    i +  +  )     {", "String   exclude    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "fields [ i ]     =    exclude ;", "excludesParam . append ( exclude )  ;", "if    ( i    <     (  ( fields . length )     -     1  )  )     {", "excludesParam . append (  \"  ,  \"  )  ;", "}", "}", "return   excludesParam . toString (  )  ;", "}", "METHOD_END"], "methodName": ["randomFields"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "int   numIndices    =    randomIntBetween ( minIndicesNum ,    maxIndicesNum )  ;", "String [  ]    indices    =    new   String [ numIndices ]  ;", "for    ( int   i    =     0  ;    i    <    numIndices ;    i +  +  )     {", "indices [ i ]     =     \" index -  \"     +     ( randomAlphaOfLengthBetween (  2  ,     5  )  . toLowerCase ( Locale . ROOT )  )  ;", "}", "return   indices ;", "}", "METHOD_END"], "methodName": ["randomIndicesNames"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "if    ( randomBoolean (  )  )     {", "boolean   fetchSource    =    randomBoolean (  )  ;", "consumer . accept ( new   FetchSourceContext ( fetchSource )  )  ;", "if    ( fetchSource    =  =    false )     {", "expectedParams . put (  \"  _ source \"  ,     \" false \"  )  ;", "}", "} else    {", "int   numIncludes    =    randomIntBetween (  0  ,     5  )  ;", "String [  ]    includes    =    new   String [ numIncludes ]  ;", "String   includesParam    =     . randomFields ( includes )  ;", "if    ( numIncludes    >     0  )     {", "expectedParams . put (  \"  _ source _ include \"  ,    includesParam )  ;", "}", "int   numExcludes    =    randomIntBetween (  0  ,     5  )  ;", "String [  ]    excludes    =    new   String [ numExcludes ]  ;", "String   excludesParam    =     . randomFields ( excludes )  ;", "if    ( numExcludes    >     0  )     {", "expectedParams . put (  \"  _ source _ exclude \"  ,    excludesParam )  ;", "}", "consumer . accept ( new   FetchSourceContext ( true ,    includes ,    excludes )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["randomizeFetchSourceContextParams"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  2  ,     2  )  ;", "ResizeRequest   resizeRequest    =    new   ResizeRequest ( indices [  0  ]  ,    indices [  1  ]  )  ;", "resizeRequest . setResizeType ( resizeType )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomMasterTimeout ( resizeRequest ,    expectedParams )  ;", "RequestTests . setRandomTimeout ( resizeRequest :  : timeout ,    resizeRequest . timeout (  )  ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "CreateIndexRequest   createIndexRequest    =    new   CreateIndexRequest ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  ;", "if    ( randomBoolean (  )  )     {", "createIndexRequest . settings ( RandomCreateIndexGenerator . randomIndexSettings (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "RandomCreateIndexGenerator . randomAliases ( createIndexRequest )  ;", "}", "resizeRequest . setTargetIndex ( createIndexRequest )  ;", "}", "RequestTests . setRandomWaitForActiveShards ( resizeRequest :  : setWaitForActiveShards ,    expectedParams )  ;", "Request   request    =    function . apply ( resizeRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "String   expectedEndpoint    =     (  (  (  (  \"  /  \"     +     ( resizeRequest . getSourceIndex (  )  )  )     +     \"  /  _  \"  )     +     ( resizeType . name (  )  . toLowerCase ( Locale . ROOT )  )  )     +     \"  /  \"  )     +     ( resizeRequest . getTargetIndexRequest (  )  . index (  )  )  ;", "assertEquals ( expectedEndpoint ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "RequestTests . assertToXContentBody ( resizeRequest ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["resizeTest"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "boolean   flatSettings    =    randomBoolean (  )  ;", "setter . accept ( flatSettings )  ;", "if    ( flatSettings )     {", "expectedParams . put (  \" flat _ settings \"  ,    String . valueOf ( flatSettings )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomFlatSettings"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "boolean   humanReadable    =    randomBoolean (  )  ;", "r . humanReadable ( humanReadable )  ;", "if    ( humanReadable )     {", "expectedParams . put (  \" human \"  ,    String . valueOf ( humanReadable )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomHumanReadable"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "boolean   includeDefaults    =    randomBoolean (  )  ;", "r . includeDefaults ( includeDefaults )  ;", "if    ( includeDefaults )     {", "expectedParams . put (  \" include _ defaults \"  ,    String . valueOf ( includeDefaults )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomIncludeDefaults"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "setter . accept ( IndicesOptions . fromOptions ( randomBoolean (  )  ,    randomBoolean (  )  ,    randomBoolean (  )  ,    randomBoolean (  )  )  )  ;", "}", "expectedParams . put (  \" ignore _ unavailable \"  ,    Boolean . toString ( getter . get (  )  . ignoreUnavailable (  )  )  )  ;", "expectedParams . put (  \" allow _ no _ indices \"  ,    Boolean . toString ( getter . get (  )  . allowNoIndices (  )  )  )  ;", "if    (  ( getter . get (  )  . expandWildcardsOpen (  )  )     &  &     ( getter . get (  )  . expandWildcardsClosed (  )  )  )     {", "expectedParams . put (  \" expand _ wildcards \"  ,     \" open , closed \"  )  ;", "} else", "if    ( getter . get (  )  . expandWildcardsOpen (  )  )     {", "expectedParams . put (  \" expand _ wildcards \"  ,     \" open \"  )  ;", "} else", "if    ( getter . get (  )  . expandWildcardsClosed (  )  )     {", "expectedParams . put (  \" expand _ wildcards \"  ,     \" closed \"  )  ;", "} else    {", "expectedParams . put (  \" expand _ wildcards \"  ,     \" none \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRandomIndicesOptions"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "boolean   local    =    randomBoolean (  )  ;", "r . local ( local )  ;", "if    ( local )     {", "expectedParams . put (  \" local \"  ,    String . valueOf ( local )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomLocal"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "String   masterTimeout    =    randomTimeValue (  )  ;", "r . masterNodeTimeout ( masterTimeout )  ;", "expectedParams . put (  \" master _ timeout \"  ,    masterTimeout )  ;", "} else    {", "expectedParams . put (  \" master _ timeout \"  ,    DEFAULT _ MASTER _ NODE _ TIMEOUT . getStringRep (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRandomMasterTimeout"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "Write . RefreshPolicy   refreshPolicy    =    randomFrom ( RefreshPolicy . values (  )  )  ;", "setter . accept ( refreshPolicy )  ;", "if    ( refreshPolicy    !  =     ( RefreshPolicy . NONE )  )     {", "expectedParams . put (  \" refresh \"  ,    refreshPolicy . getValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomRefreshPolicy"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "String   timeout    =    randomTimeValue (  )  ;", "setter . accept ( timeout )  ;", "expectedParams . put (  \" timeout \"  ,    timeout )  ;", "} else    {", "expectedParams . put (  \" timeout \"  ,    defaultTimeout . getStringRep (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setRandomTimeout"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "long   version    =    randomFrom ( MATCH _ ANY ,    MATCH _ DELETED ,    NOT _ FOUND ,    randomNonNegativeLong (  )  )  ;", "r . version ( version )  ;", "if    ( version    !  =     ( Versions . MATCH _ ANY )  )     {", "expectedParams . put (  \" version \"  ,    Long . toString ( version )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomVersion"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "VersionType   versionType    =    randomFrom ( VersionType . val (  )  )  ;", "setter . accept ( versionType )  ;", "if    ( versionType    !  =     ( VersionType . INTERNAL )  )     {", "expectedParams . put (  \" version _ type \"  ,    versionType . name (  )  . toLowerCase ( Locale . ROOT )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setRandomVersionType"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "if    ( randomBoolean (  )  )     {", "String   waitForActiveShardsString ;", "iwaitForActiveShards    =    randomIetween (  (  -  1  )  ,     5  )  ;", "if    ( waitForActiveShards    =  =     (  -  1  )  )     {", "waitForActiveShardsString    =     \" all \"  ;", "} else    {", "waitForActiveShardsString    =    String . valueOf ( waitForActiveShards )  ;", "}", "setter . accept ( ActiveShardCouparseString ( waitForActiveShardsString )  )  ;", "expectedParams . put (  \" wait _ for _ active _ shards \"  ,    waitForActiveShardsString )  ;", "}", "}", "METHOD_END"], "methodName": ["setRandomWaitForActiveShards"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "if    ( randomBoolean (  )  )     {", "String   timeout    =    randomTimeValue (  )  ;", "bulkRequest . timeout ( timeout )  ;", "expectedParams . put (  \" timeout \"  ,    timeout )  ;", "} else    {", "expectedParams . put (  \" timeout \"  ,    DEFAULT _ TIMEOUT . getStringRep (  )  )  ;", "}", "RequestTests . setRandomRefreshPolicy ( bulkRequest :  : setRefreshPolicy ,    expectedParams )  ;", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "int   nbItems    =    randomIntBetween (  1  0  ,     1  0  0  )  ;", "for    ( int   i    =     0  ;    i    <    nbItems ;    i +  +  )     {", "String   index    =    randomAlphaOfLength (  5  )  ;", "String   type    =    randomAlphaOfLength (  5  )  ;", "String   id    =    randomAlphaOfLength (  5  )  ;", "BytesReference   source    =    RandomObjects . randomSource ( random (  )  ,    xContentType )  ;", "DocWriteRequest . OpType   opType    =    randomFrom ( OpType . values (  )  )  ;", "DocWriteRequest <  ?  >    docWriteRequest ;", "if    ( opType    =  =     ( OpType . INDEX )  )     {", "IndexRequest   indexRequest    =    new   IndexRequest ( index ,    type ,    id )  . source ( source ,    xContentType )  ;", "docWriteRequest    =    indexRequest ;", "if    ( randomBoolean (  )  )     {", "indexRequest . setPipeline ( randomAlphaOfLength (  5  )  )  ;", "}", "} else", "if    ( opType    =  =     ( OpType . CREATE )  )     {", "IndexRequest   createRequest    =    new   IndexRequest ( index ,    type ,    id )  . source ( source ,    xContentType )  . create ( true )  ;", "docWriteRequest    =    createRequest ;", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "final   action . update . UpdateRequest   updateRequest    =    new   action . update . UpdateRequest ( index ,    type ,    id )  . doc ( new   IndexRequest (  )  . source ( source ,    xContentType )  )  ;", "docWriteRequest    =    updateRequest ;", "if    ( randomBoolean (  )  )     {", "updateRequest . retryOnConflict ( randomIntBetween (  1  ,     5  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "RequestTests . randomizeFetchSourceContextParams ( updateRequest :  : fetchSource ,    new   HashMap (  )  )  ;", "}", "} else", "if    ( opType    =  =     ( OpType . DELETE )  )     {", "docWriteRequest    =    new   action . delete . DeleteRequest ( index ,    type ,    id )  ;", "} else    {", "throw   new   UnsupportedOperationException (  (  (  \" optype    [  \"     +    opType )     +     \"  ]    not   supported \"  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "docWriteRequest . routing ( randomAlphaOfLength (  1  0  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "docWriteRequest . version ( randomNonNegativeLong (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "docWriteRequest . versionType ( randomFrom ( VersionType . values (  )  )  )  ;", "}", "bulkRequest . add ( docWriteRequest )  ;", "}", "Request   request    =    Request . bulk ( bulkRequest )  ;", "assertEquals (  \"  /  _ bulk \"  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals ( xContentType . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "byte [  ]    content    =    new   byte [  (  ( int )     ( request . getEntity (  )  . getContentLength (  )  )  )  ]  ;", "try    ( InputStream   inputStream    =    request . getEntity (  )  . getContent (  )  )     {", "Streams . readFully ( inputStream ,    content )  ;", "}", "BulkRequest   parsedBulkRequest    =    new   BulkRequest (  )  ;", "parsedBulkRequest . add ( content ,     0  ,    content . length ,    xContentType )  ;", "assertEquals ( bulkRequest . numberOfActions (  )  ,    parsedBulkRequest . numberOfActions (  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( bulkRequest . numberOfActions (  )  )  ;    i +  +  )     {", "DocWriteRequest <  ?  >    originalRequest    =    bulkRequest . requests (  )  . get ( i )  ;", "DocWriteRequest <  ?  >    parsedRequest    =    parsedBulkRequest . requests (  )  . get ( i )  ;", "assertEquals ( originalRequest . opType (  )  ,    parsedRequest . opType (  )  )  ;", "assertEquals ( originalRequest . index (  )  ,    parsedRequest . index (  )  )  ;", "assertEquals ( originalRequest . type (  )  ,    parsedRequest . type (  )  )  ;", "assertEquals ( originalRequest . id (  )  ,    parsedRequest . id (  )  )  ;", "assertEquals ( originalRequest . routing (  )  ,    parsedRequest . routing (  )  )  ;", "assertEquals ( originalRequest . version (  )  ,    parsedRequest . version (  )  )  ;", "assertEquals ( originalRequest . versionType (  )  ,    parsedRequest . versionType (  )  )  ;", "DocWriteRequest . OpType   opType    =    originalRequest . opType (  )  ;", "if    ( opType    =  =     ( OpType . INDEX )  )     {", "IndexRequest   indexRequest    =     (  ( IndexRequest )     ( originalRequest )  )  ;", "IndexRequest   parsedIndexRequest    =     (  ( IndexRequest )     ( parsedRequest )  )  ;", "assertEquals ( indexRequest . getPipeline (  )  ,    parsedIndexRequest . getPipeline (  )  )  ;", "assertToXContentEquivalent ( indexRequest . source (  )  ,    parsedIndexRequest . source (  )  ,    xContentType )  ;", "} else", "if    ( opType    =  =     ( OpType . UPDATE )  )     {", "action . update . UpdateRequest   updateRequest    =     (  ( action . update . UpdateRequest )     ( originalRequest )  )  ;", "action . update . UpdateRequest   parsedUpdateRequest    =     (  ( action . update . UpdateRequest )     ( parsedRequest )  )  ;", "assertEquals ( updateRequest . retryOnConflict (  )  ,    parsedUpdateRequest . retryOnConflict (  )  )  ;", "assertEquals ( updateRequest . fetchSource (  )  ,    parsedUpdateRequest . fetchSource (  )  )  ;", "if    (  ( updateRequest . doc (  )  )     !  =    null )     {", "assertToXContentEquivalent ( updateRequest . doc (  )  . source (  )  ,    parsedUpdateRequest . doc (  )  . source (  )  ,    xContentType )  ;", "} else    {", "assertNull ( parsedUpdateRequest . doc (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testBulk"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "{", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  )  ;", "bulkRequest . add ( new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \"  1  \"  )  . script ( mockScript (  \" test \"  )  )  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  2  \"  )  )  ;", "Request   request    =    Request . bulk ( bulkRequest )  ;", "assertEquals ( JSON . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "}", "{", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    xContentType )  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  2  \"  )  )  ;", "Request   request    =    Request . bulk ( bulkRequest )  ;", "assertEquals ( xContentType . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "}", "{", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  ;", "if    ( randomBoolean (  )  )     {", "updateRequest . doc ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    xContentType )  )  ;", "} else    {", "updateRequest . upsert ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    xContentType )  )  ;", "}", "Request   request    =    Request . bulk ( new   BulkRequest (  )  . add ( updateRequest )  )  ;", "assertEquals ( xContentType . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "}", "{", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    SMILE )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  1  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  ;", "IllegalArgumentException   exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . bulk ( bulkRequest )  )  ;", "assertEquals (  (  \" Mismatching   content - type   found   for   request   with   content - type    [ JSON ]  ,     \"     +     \" previous   requests   have   content - type    [ SMILE ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "{", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  1  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  ;", "bulkRequest . add ( new   UpdateRequest (  \" index \"  ,     \" type \"  ,     \"  2  \"  )  . doc ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  . upsert ( new   IndexRequest (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    SMILE )  )  )  ;", "IllegalArgumentException   exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . bulk ( bulkRequest )  )  ;", "assertEquals (  (  \" Mismatching   content - type   found   for   request   with   content - type    [ SMILE ]  ,     \"     +     \" previous   requests   have   content - type    [ JSON ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "{", "XContentType   xContentType    =    randomFrom ( CBOR ,    YAML )  ;", "BulkRequest   bulkRequest    =    new   BulkRequest (  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  0  \"  )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  1  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  2  \"  )  )  ;", "bulkRequest . add ( new   DeleteRequest (  \" index \"  ,     \" type \"  ,     \"  3  \"  )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  4  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    JSON )  )  ;", "bulkRequest . add ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \"  1  \"  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    xContentType )  )  ;", "IllegalArgumentException   exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . bulk ( bulkRequest )  )  ;", "assertEquals (  (  (  \" Unsupported   content - type   found   for   request   with   content - type    [  \"     +    xContentType )     +     \"  ]  ,    only   JSON   and   SMILE   are   supported \"  )  ,    exception . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBulkWithDifferentContentTypes"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "assertTrue (  \" Request   class   is   not   public \"  ,    Modifier . isPublic ( Request . class . getModifiers (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClassVisibility"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "ClearIndicesCacheRequest   clearIndicesCacheRequest ;", "if    ( randomBoolean (  )  )     {", "clearIndicesCacheRequest    =    new   ClearIndicesCacheRequest ( indices )  ;", "} else    {", "clearIndicesCacheRequest    =    new   ClearIndicesCacheRequest (  )  ;", "clearIndicesCacheRequest . indices ( indices )  ;", "}", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( clearIndicesCacheRequest :  : indicesOptions ,    clearIndicesCacheRequest :  : indicesOptions ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "clearIndicesCacheRequest . queryCache ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" query \"  ,    Boolean . toString ( clearIndicesCacheRequest . queryCache (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "clearIndicesCacheRequest . fieldDataCache ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" fielddata \"  ,    Boolean . toString ( clearIndicesCacheRequest . fieldDataCache (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "clearIndicesCacheRequest . requestCache ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" request \"  ,    Boolean . toString ( clearIndicesCacheRequest . requestCache (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "clearIndicesCacheRequest . fields ( RequestTests . randomIndicesNames (  1  ,     5  )  )  ;", "expectedParams . put (  \" fields \"  ,    String . join (  \"  ,  \"  ,    clearIndicesCacheRequest . fields (  )  )  )  ;", "}", "Request   request    =    Request . clearCache ( clearIndicesCacheRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "endpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "endpoint . add (  \"  _ cache / clear \"  )  ;", "assertThat ( request . getEndpoint (  )  ,    equalTo ( endpoint . toString (  )  )  )  ;", "assertThat ( request . getParameters (  )  ,    equalTo ( expectedParams )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testClearCache"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "ClearScrollRequest   clearScrollRequest    =    new   ClearScrollRequest (  )  ;", "int   numScrolls    =    randomIntBetween (  1  ,     1  0  )  ;", "for    ( int   i    =     0  ;    i    <    numScrolls ;    i +  +  )     {", "clearScrollRequest . addScrollId ( randomAlphaOfLengthBetween (  5  ,     1  0  )  )  ;", "}", "Request   request    =    Request . clearScroll ( clearScrollRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals (  \"  /  _ search / scroll \"  ,    request . getEndpoint (  )  )  ;", "assertEquals (  0  ,    request . getParameters (  )  . size (  )  )  ;", ". assertToXContentBody ( clearScrollRequest ,    request . getEntity (  )  )  ;", "assertEquals ( Request . REQUEST _ BODY _ CONTENT _ TYPE . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClearScroll"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  1  ,     5  )  ;", "CloseIndexRequest   closeIndexRequest    =    new   CloseIndexRequest ( indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomTimeout ( closeIndexRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", "RequestTests . setRandomMasterTimeout ( closeIndexRequest ,    expectedParams )  ;", "RequestTests . setRandomIndicesOptions ( closeIndexRequest :  : indicesOptions ,    closeIndexRequest :  : indicesOptions ,    expectedParams )  ;", "Request   request    =    Request . closeIndex ( closeIndexRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  . add ( String . join (  \"  ,  \"  ,    indices )  )  . add (  \"  _ close \"  )  ;", "assertThat ( endpoint . toString (  )  ,    equalTo ( request . getEndpoint (  )  )  )  ;", "assertThat ( expectedParams ,    equalTo ( request . getParameters (  )  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCloseIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    Strings . EMPTY _ ARRAY ;", "ActionValidationException   validationException    =    new   CloseIndex ( indices )  . validate (  )  ;", "assertNotNull ( validationException )  ;", "}", "METHOD_END"], "methodName": ["testCloseIndexEmptyIndices"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "ClusterUpdateSettingsRequest   request    =    new   ClusterUpdateSettingsRequest (  )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomFlatSettings ( request :  : flatSettings ,    expectedParams )  ;", ". setRandomMasterTimeout ( request ,    expectedParams )  ;", ". setRandomTimeout ( request :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", "Request   expectedRequest    =    Request . clusterPutSettings ( request )  ;", "assertEquals (  \"  /  _ cluster / settings \"  ,    expectedRequest . getEndpoint (  )  )  ;", "assertEquals ( METHOD _ NAME ,    expectedRequest . getMethod (  )  )  ;", "assertEquals ( expectedParams ,    expectedRequest . getParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClusterPutSettings"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "final   String   method    =    randomFrom (  \" GET \"  ,     \" PUT \"  ,     \" POST \"  ,     \" HEAD \"  ,     \" DELETE \"  )  ;", "final   String   endpoint    =    randomAlphaOfLengthBetween (  1  ,     1  0  )  ;", "final   Map < String ,    String >    parameters    =    Collections . singletonMap ( randomAlphaOfLength (  5  )  ,    randomAlphaOfLength (  5  )  )  ;", "final   HttpEntity   entity    =     ( randomBoolean (  )  )     ?    new   StringEntity ( randomAlphaOfLengthBetween (  1  ,     1  0  0  )  ,    ContentType . TEXT _ PLAIN )     :    null ;", "NullPointerException   e    =    expectThrows ( NullPointerException . class ,     (  )     -  >    new    ( null ,    endpoint ,    parameters ,    entity )  )  ;", "assertEquals (  \" method   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "e    =    expectThrows ( NullPointerException . class ,     (  )     -  >    new    ( method ,    null ,    parameters ,    entity )  )  ;", "assertEquals (  \" endpoint   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "e    =    expectThrows ( NullPointerException . class ,     (  )     -  >    new    ( method ,    endpoint ,    null ,    entity )  )  ;", "assertEquals (  \" parameters   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "final      request    =    new    ( method ,    endpoint ,    parameters ,    entity )  ;", "assertEquals ( method ,    request . getMethod (  )  )  ;", "assertEquals ( endpoint ,    request . getEndpoint (  )  )  ;", "assertEquals ( parameters ,    request . getParameters (  )  )  ;", "assertEquals ( entity ,    request . getEntity (  )  )  ;", "final   Constructor <  ?  >  [  ]    constructors    =     . class . getConstructors (  )  ;", "assertEquals (  \" Expected   only    1    constructor \"  ,     1  ,    constructors . length )  ;", "assertTrue (  \"    constructor   is   not   public \"  ,    Modifier . isPublic ( constructors [  0  ]  . getModifiers (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testConstructor"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "final   XContentType   xContentType    =    randomFrom ( XContentType . values (  )  )  ;", "assertEquals ( xContentType . mediaTypeWithoutParameters (  )  ,     . createContentType ( xContentType )  . getMimeType (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateContentType"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "CreateIndexRequest   createIndexRequest    =    RandomCreateIndexGenerator . randomCreateIndexRequest (  )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomTimeout ( createIndexRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", ". setRandomMasterTimeout ( createIndexRequest ,    expectedParams )  ;", ". setRandomWaitForActiveShards ( createIndexRequest :  : waitForActiveShards ,    expectedParams )  ;", "Request   request    =    Request . createIndex ( createIndexRequest )  ;", "assertEquals (  (  \"  /  \"     +     ( createIndexRequest . index (  )  )  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", ". assertToXContentBody ( createIndexRequest ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testCreateIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "ActionRequestValidationException   validationException    =    new   CreateIndexRequest ( null )  . validate (  )  ;", "assertNotNull ( validationException )  ;", "}", "METHOD_END"], "methodName": ["testCreateIndexNullIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String   index    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   id    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "DeleteRequest   deleteRequest    =    new   DeleteRequest ( index ,    type ,    id )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomTimeout ( deleteRequest :  : timeout ,    DEFAULT _ TIMEOUT ,    expectedParams )  ;", ". setRandomRefreshPolicy ( deleteRequest :  : setRefreshPolicy ,    expectedParams )  ;", ". setRandomVersion ( deleteRequest ,    expectedParams )  ;", ". setRandomVersionType ( deleteRequest :  : versionType ,    expectedParams )  ;", "if    ( frequently (  )  )     {", "if    ( randomBoolean (  )  )     {", "String   routing    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "deleteRequest . routing ( routing )  ;", "expectedParams . put (  \" routing \"  ,    routing )  ;", "}", "}", "Request   request    =    Request . delete ( deleteRequest )  ;", "assertEquals (  (  (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )     +     \"  /  \"  )     +    id )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDelete"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "DeleteIndexRequest   deleteIndexRequest    =    new   DeleteIndexRequest ( indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomTimeout ( deleteIndexRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", "RequestTests . setRandomMasterTimeout ( deleteIndexRequest ,    expectedParams )  ;", "RequestTests . setRandomIndicesOptions ( deleteIndexRequest :  : indicesOptions ,    deleteIndexRequest :  : indicesOptions ,    expectedParams )  ;", "Request   request    =    Request . deleteIndex ( deleteIndexRequest )  ;", "assertEquals (  (  \"  /  \"     +     ( String . join (  \"  ,  \"  ,    indices )  )  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    Strings . EMPTY _ ARRAY ;", "ActionValidationException   validationException    =    new   DeleteIndex ( indices )  . validate (  )  ;", "assertNotNull ( validationException )  ;", "}", "METHOD_END"], "methodName": ["testDeleteIndexEmptyIndices"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \"  / index / type / id \"  ,    Request . endpoint (  \" index \"  ,     \" type \"  ,     \" id \"  )  )  ;", "assertEquals (  \"  / index / type / id /  _ endpoint \"  ,    Request . endpoint (  \" index \"  ,     \" type \"  ,     \" id \"  ,     \"  _ endpoint \"  )  )  ;", "assertEquals (  \"  / index 1  , index 2  \"  ,    Request . endpoint ( new   String [  ]  {     \" index 1  \"  ,     \" index 2  \"     }  )  )  ;", "assertEquals (  \"  / index 1  , index 2  /  _ endpoint \"  ,    Request . endpoint ( new   String [  ]  {     \" index 1  \"  ,     \" index 2  \"     }  ,     \"  _ endpoint \"  )  )  ;", "assertEquals (  \"  / index 1  , index 2  / type 1  , type 2  /  _ endpoint \"  ,    Request . endpoint ( new   String [  ]  {     \" index 1  \"  ,     \" index 2  \"     }  ,    new   String [  ]  {     \" type 1  \"  ,     \" type 2  \"     }  ,     \"  _ endpoint \"  )  )  ;", "assertEquals (  \"  / index 1  , index 2  /  _ endpoint / suffix 1  , suffix 2  \"  ,    Request . endpoint ( new   String [  ]  {     \" index 1  \"  ,     \" index 2  \"     }  ,     \"  _ endpoint \"  ,    new   String [  ]  {     \" suffix 1  \"  ,     \" suffix 2  \"     }  )  )  ;", "}", "METHOD_END"], "methodName": ["testEndpoint"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  ;", "assertEquals (  \"  /  \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart ( EMPTY _ ARRAY )  ;", "assertEquals (  \"  /  \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \"  \"  )  ;", "assertEquals (  \"  /  \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" a \"  ,     \" b \"  )  ;", "assertEquals (  \"  / a / b \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" a \"  )  . addPathPart (  \" b \"  )  . addPathPartAsIs (  \"  _ create \"  )  ;", "assertEquals (  \"  / a / b /  _ create \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" a \"  ,     \" b \"  ,     \" c \"  )  . addPathPartAsIs (  \"  _ create \"  )  ;", "assertEquals (  \"  / a / b / c /  _ create \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" a \"  )  . addPathPartAsIs (  \"  _ create \"  )  ;", "assertEquals (  \"  / a /  _ create \"  ,    endpointBuilder . build (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEndpointBuilder"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \"  -  # index 1  , index #  2  \"  ,     \" type \"  ,     \" id \"  )  ;", "assertEquals (  \"  /  -  %  2  3 index 1  , index %  2  3  2  / type / id \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" index \"  ,     \" type #  2  \"  ,     \" id \"  )  ;", "assertEquals (  \"  / index / type %  2  3  2  / id \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" index \"  ,     \" type \"  ,     \" this / is / the / id \"  )  ;", "assertEquals (  \"  / index / type / this %  2 Fis %  2 Fthe %  2 Fid \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" index \"  ,     \" type \"  ,     \" this | is | the | id \"  )  ;", "assertEquals (  \"  / index / type / this %  7 Cis %  7 Cthe %  7 Cid \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" index \"  ,     \" type \"  ,     \" id #  1  \"  )  ;", "assertEquals (  \"  / index / type / id %  2  3  1  \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \"  < logstash -  { now / M }  >  \"  ,     \"  _ search \"  )  ;", "assertEquals (  \"  /  %  3 Clogstash -  %  7 Bnow %  2 FM %  7 D %  3 E /  _ search \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \"  \u00d6\u00d0  \u00ce\u00c4  \"  )  ;", "assertEquals (  \"  /  \u00d6\u00d0  \u00ce\u00c4  \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" foo   bar \"  )  ;", "assertEquals (  \"  / foo %  2  0 bar \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" foo + bar \"  )  ;", "assertEquals (  \"  / foo + bar \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" foo + bar \"  )  ;", "assertEquals (  \"  / foo + bar \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" foo / bar \"  )  ;", "assertEquals (  \"  / foo %  2 Fbar \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" foo ^ bar \"  )  ;", "assertEquals (  \"  / foo %  5 Ebar \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addPathPart (  \" cluster 1  : index 1  , index 2  \"  )  . addPathPartAsIs (  \"  _ search \"  )  ;", "assertEquals (  \"  / cluster 1  : index 1  , index 2  /  _ search \"  ,    endpointBuilder . build (  )  )  ;", "}", "{", "Request . EndpointBuilder   endpointBuilder    =    new   Request . EndpointBuilder (  )  . addCommaSeparatedPathParts ( new   String [  ]  {     \" index 1  \"  ,     \" index 2  \"     }  )  . addPathPartAsIs (  \" cache / clear \"  )  ;", "assertEquals (  \"  / index 1  , index 2  / cache / clear \"  ,    endpointBuilder . build (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEndpointBuilderEncodeParts"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "XContentType   xContentType    =    randomFrom ( JSON ,    SMILE )  ;", "Index   index    =    new   Index (  )  . source ( Collections . singletonMap (  \" field \"  ,     \" value \"  )  ,    xContentType )  ;", "assertEquals ( xContentType ,     . enforceSameContentType ( index ,    null )  )  ;", "assertEquals ( xContentType ,     . enforceSameContentType ( index ,    xContentType )  )  ;", "XContentType   bulkContentType    =     ( randomBoolean (  )  )     ?    xContentType    :    null ;", "IllegalArgumentException   exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    enforceSameContentType ( new   Index (  )  . source ( singletonMap (  \" field \"  ,     \" value \"  )  ,    XContentType . CBOR )  ,    bulkContentType )  )  ;", "assertEquals (  \" Unsupported   content - type   found   for   request   with   content - type    [ CBOR ]  ,    only   JSON   and   SMILE   are   supported \"  ,    exception . getMessage (  )  )  ;", "exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    enforceSameContentType ( new   Index (  )  . source ( singletonMap (  \" field \"  ,     \" value \"  )  ,    XContentType . YAML )  ,    bulkContentType )  )  ;", "assertEquals (  \" Unsupported   content - type   found   for   request   with   content - type    [ YAML ]  ,    only   JSON   and   SMILE   are   supported \"  ,    exception . getMessage (  )  )  ;", "XContentType   requestContentType    =     ( xContentType    =  =     ( XContentType . JSON )  )     ?    XContentType . SMILE    :    XContentType . JSON ;", "exception    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    enforceSameContentType ( new   Index (  )  . source ( singletonMap (  \" field \"  ,     \" value \"  )  ,    requestContentType )  ,    xContentType )  )  ;", "assertEquals (  (  (  (  (  (  \" Mismatching   content - type   found   for   request   with   content - type    [  \"     +    requestContentType )     +     \"  ]  ,     \"  )     +     \" previous   requests   have   content - type    [  \"  )     +    xContentType )     +     \"  ]  \"  )  ,    exception . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testEnforceSameContentType"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RequestTests . getAndExistsTest ( Request :  : exists ,    METHOD _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "GetAliasesRequest   getAliasesRequest    =    new   GetAliasesRequest (  )  ;", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :     . randomIndicesNames (  0  ,     5  )  ;", "getAliasesRequest . indices ( indices )  ;", "boolean   hasIndices    =     ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  ;", "String [  ]    aliases ;", "if    ( hasIndices )     {", "aliases    =     ( randomBoolean (  )  )     ?    null    :     . randomIndicesNames (  0  ,     5  )  ;", "} else    {", "aliases    =     . randomIndicesNames (  1  ,     5  )  ;", "}", "getAliasesRequest . aliases ( aliases )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomLocal ( getAliasesRequest ,    expectedParams )  ;", ". setRandomIndicesOptions ( getAliasesRequest :  : indicesOptions ,    getAliasesRequest :  : indicesOptions ,    expectedParams )  ;", "Request   request    =    Request . existsAlias ( getAliasesRequest )  ;", "StringJoiner   expectedEndpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "expectedEndpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "expectedEndpoint . add (  \"  _ alias \"  )  ;", "if    (  ( aliases    !  =    null )     &  &     (  ( aliases . length )     >     0  )  )     {", "expectedEndpoint . add ( String . join (  \"  ,  \"  ,    aliases )  )  ;", "}", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals ( expectedEndpoint . toString (  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testExistsAlias"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "{", "GetAliasesRequest   getAliasesRequest    =    new   GetAliasesRequest (  )  ;", "IllegalArgumentException   iae    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . existsAlias ( getAliasesRequest )  )  ;", "assertEquals (  \" existsAlias   requires   at   least   an   alias   or   an   index \"  ,    iae . getMessage (  )  )  ;", "}", "{", "GetAliasesRequest   getAliasesRequest    =    new   GetAliasesRequest (  (  ( String [  ]  )     ( null )  )  )  ;", "getAliasesRequest . indices (  (  ( String [  ]  )     ( null )  )  )  ;", "IllegalArgumentException   iae    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . existsAlias ( getAliasesRequest )  )  ;", "assertEquals (  \" existsAlias   requires   at   least   an   alias   or   an   index \"  ,    iae . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExistsAliasNoAliasNoIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "FlushRequest   flushRequest ;", "if    ( randomBoolean (  )  )     {", "flushRequest    =    new   FlushRequest ( indices )  ;", "} else    {", "flushRequest    =    new   FlushRequest (  )  ;", "flushRequest . indices ( indices )  ;", "}", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( flushRequest :  : indicesOptions ,    flushRequest :  : indicesOptions ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "flushRequest . force ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" force \"  ,    Boolean . toString ( flushRequest . force (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "flushRequest . waitIfOngoing ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" wait _ if _ ongoing \"  ,    Boolean . toString ( flushRequest . waitIfOngoing (  )  )  )  ;", "Request   request    =    Request . flush ( flushRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "endpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "endpoint . add (  \"  _ flush \"  )  ;", "assertThat ( request . getEndpoint (  )  ,    equalTo ( endpoint . toString (  )  )  )  ;", "assertThat ( request . getParameters (  )  ,    equalTo ( expectedParams )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testFlush"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "ForceMergeRequest   forceMergeRequest ;", "if    ( randomBoolean (  )  )     {", "forceMergeRequest    =    new   ForceMergeRequest ( indices )  ;", "} else    {", "forceMergeRequest    =    new   ForceMergeRequest (  )  ;", "forceMergeRequest . indices ( indices )  ;", "}", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( forceMergeRequest :  : indicesOptions ,    forceMergeRequest :  : indicesOptions ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "forceMergeRequest . maxNumSegments ( randomInt (  )  )  ;", "}", "expectedParams . put (  \" max _ num _ segments \"  ,    Integer . toString ( forceMergeRequest . maxNumSegments (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "forceMergeRequest . onlyExpungeDeletes ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" only _ expunge _ deletes \"  ,    Boolean . toString ( forceMergeRequest . onlyExpungeDeletes (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "forceMergeRequest . flush ( randomBoolean (  )  )  ;", "}", "expectedParams . put (  \" flush \"  ,    Boolean . toString ( forceMergeRequest . flush (  )  )  )  ;", "Request   request    =    Request . forceMerge ( forceMergeRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "endpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "endpoint . add (  \"  _ forcemerge \"  )  ;", "assertThat ( request . getEndpoint (  )  ,    equalTo ( endpoint . toString (  )  )  )  ;", "assertThat ( request . getParameters (  )  ,    equalTo ( expectedParams )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testForceMerge"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RequestTests . getAndExistsTest ( Request :  : get ,    METHOD _ NAME )  ;", "}", "METHOD_END"], "methodName": ["testGet"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String   index    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "IndexRequest   indexRequest    =    new   IndexRequest ( index ,    type )  ;", "String   id    =     ( randomBoolean (  )  )     ?    randomAlphaOfLengthBetween (  3  ,     1  0  )     :    null ;", "indexRequest . id ( id )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "String   method    =    HttpPost . METHOD _ NAME ;", "if    ( id    !  =    null )     {", "method    =    HttpPut . METHOD _ NAME ;", "if    ( randomBoolean (  )  )     {", "indexRequest . opType ( CREATE )  ;", "}", "}", ". setRandomTimeout ( indexRequest :  : timeout ,    DEFAULT _ TIMEOUT ,    expectedParams )  ;", ". setRandomRefreshPolicy ( indexRequest :  : setRefreshPolicy ,    expectedParams )  ;", "if    (  ( indexRequest . opType (  )  )     =  =     ( OpType . CREATE )  )     {", "indexRequest . version ( randomFrom ( MATCH _ ANY ,    MATCH _ DELETED )  )  ;", "expectedParams . put (  \" version \"  ,    Long . toString ( MATCH _ DELETED )  )  ;", "} else    {", ". setRandomVersion ( indexRequest ,    expectedParams )  ;", ". setRandomVersionType ( indexRequest :  : versionType ,    expectedParams )  ;", "}", "if    ( frequently (  )  )     {", "if    ( randomBoolean (  )  )     {", "String   routing    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "indexRequest . routing ( routing )  ;", "expectedParams . put (  \" routing \"  ,    routing )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   pipeline    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "indexRequest . setPipeline ( pipeline )  ;", "expectedParams . put (  \" pipeline \"  ,    pipeline )  ;", "}", "}", "XContentType   xContentType    =    randomFrom ( XContentType . values (  )  )  ;", "int   nbFields    =    randomIntBetween (  0  ,     1  0  )  ;", "try    ( XContentBuilder   builder    =    XContentBuilder . builder ( xContentType . xContent (  )  )  )     {", "builder . startObject (  )  ;", "for    ( int   i    =     0  ;    i    <    nbFields ;    i +  +  )     {", "builder . field (  (  \" field _  \"     +    i )  ,    i )  ;", "}", "builder . endObject (  )  ;", "indexRequest . source ( builder )  ;", "}", "Request   request    =    Request . index ( indexRequest )  ;", "if    (  ( indexRequest . opType (  )  )     =  =     ( OpType . CREATE )  )     {", "assertEquals (  (  (  (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )     +     \"  /  \"  )     +    id )     +     \"  /  _ create \"  )  ,    request . getEndpoint (  )  )  ;", "} else", "if    ( id    !  =    null )     {", "assertEquals (  (  (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )     +     \"  /  \"  )     +    id )  ,    request . getEndpoint (  )  )  ;", "} else    {", "assertEquals (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )  ,    request . getEndpoint (  )  )  ;", "}", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( method ,    request . getMethod (  )  )  ;", "HttpEntity   entity    =    request . getEntity (  )  ;", "assertTrue (  ( entity   instanceof   ByteArrayEntity )  )  ;", "assertEquals ( indexRequest . getContentType (  )  . mediaTypeWithoutParameters (  )  ,    entity . getContentType (  )  . getValue (  )  )  ;", "try    ( XContentParser   parser    =    createParser ( xContentType . xContent (  )  ,    entity . getContent (  )  )  )     {", "assertEquals ( nbFields ,    parser . map (  )  . size (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    RequestTests . randomIndicesNames (  0  ,     2  )  ;", "UpdateSettingsRequest   updateSettingsRequest    =    new   UpdateSettingsRequest ( indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomFlatSettings ( updateSettingsRequest :  : flatSettings ,    expectedParams )  ;", "RequestTests . setRandomMasterTimeout ( updateSettingsRequest ,    expectedParams )  ;", "RequestTests . setRandomTimeout ( updateSettingsRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", "RequestTests . setRandomIndicesOptions ( updateSettingsRequest :  : indicesOptions ,    updateSettingsRequest :  : indicesOptions ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "updateSettingsRequest . setPreserveExisting ( randomBoolean (  )  )  ;", "if    ( updateSettingsRequest . isPreserveExisting (  )  )     {", "expectedParams . put (  \" preserve _ existing \"  ,     \" true \"  )  ;", "}", "}", "Request   request    =    Request . indexPutSettings ( updateSettingsRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "endpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "endpoint . add (  \"  _ settings \"  )  ;", "assertThat ( endpoint . toString (  )  ,    equalTo ( request . getEndpoint (  )  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "RequestTests . assertToXContentBody ( updateSettingsRequest ,    request . getEntity (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexPutSettings"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  1  ,     1  0  )  ;", "GetIndexRequest   getIndexRequest    =    new   GetIndexRequest (  )  . indices ( indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( getIndexRequest :  : indicesOptions ,    getIndexRequest :  : indicesOptions ,    expectedParams )  ;", "RequestTests . setRandomLocal ( getIndexRequest ,    expectedParams )  ;", "RequestTests . setRandomFlatSettings ( getIndexRequest :  : flatSettings ,    expectedParams )  ;", "RequestTests . setRandomHumanReadable ( getIndexRequest ,    expectedParams )  ;", "RequestTests . setRandomIncludeDefaults ( getIndexRequest ,    expectedParams )  ;", "final   Request   request    =    Request . indicesExist ( getIndexRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals (  (  \"  /  \"     +     ( String . join (  \"  ,  \"  ,    indices )  )  )  ,    request . getEndpoint (  )  )  ;", "assertThat ( expectedParams ,    equalTo ( request . getParameters (  )  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndicesExist"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . indicesExist ( new   GetIndexRequest (  )  )  )  ;", "expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . indicesExist ( new   GetIndexRequest (  )  . indices (  (  ( String [  ]  )     ( null )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testIndicesExistEmptyIndices"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "Request   request    =    Request . info (  )  ;", "assertEquals (  \"  /  \"  ,    request . getEndpoint (  )  )  ;", "assertEquals (  0  ,    request . getParameters (  )  . size (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["testInfo"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "MultiGetRequest   multiGetRequest    =    new   MultiGetRequest (  )  ;", "if    ( randomBoolean (  )  )     {", "String   preference    =    randomAlphaOfLength (  4  )  ;", "multiGetRequest . preference ( preference )  ;", "expectedParams . put (  \" preference \"  ,    preference )  ;", "}", "if    ( randomBoolean (  )  )     {", "multiGetRequest . realtime ( randomBoolean (  )  )  ;", "if    (  ( multiGetRequest . realtime (  )  )     =  =    false )     {", "expectedParams . put (  \" realtime \"  ,     \" false \"  )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", "multiGetRequest . refresh ( randomBoolean (  )  )  ;", "if    ( multiGetRequest . refresh (  )  )     {", "expectedParams . put (  \" refresh \"  ,     \" true \"  )  ;", "}", "}", "int   numberOfRequests    =    randomIntBetween (  0  ,     3  2  )  ;", "for    ( int   i    =     0  ;    i    <    numberOfRequests ;    i +  +  )     {", "MultiGetRequest . Item   item    =    new   MultiGetRequest . Item ( randomAlphaOfLength (  4  )  ,    randomAlphaOfLength (  4  )  ,    randomAlphaOfLength (  4  )  )  ;", "if    ( randomBoolean (  )  )     {", "item . routing ( randomAlphaOfLength (  4  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "item . storedFields ( generateRandomStringArray (  1  6  ,     8  ,    false )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "item . version ( randomNonNegativeLong (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "item . versionType ( randomFrom ( VersionType . values (  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", ". randomizeFetchSourceContextParams ( item :  : fetchSourceContext ,    new   HashMap (  )  )  ;", "}", "multiGetRequest . add ( item )  ;", "}", "Request   request    =    Request . multiGet ( multiGetRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals (  \"  /  _ mget \"  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", ". assertToXContentBody ( multiGetRequest ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiGet"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "int   numberOfSearchRequests    =    randomIntBetween (  0  ,     3  2  )  ;", "MultiSearchRequest   multiSearchRequest    =    new   MultiSearchRequest (  )  ;", "for    ( int   i    =     0  ;    i    <    numberOfSearchRequests ;    i +  +  )     {", "SearchRequest   searchRequest    =    RandomSearchRequestGenerator . randomSearchRequest (  (  )     -  >     {", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . from ( randomInt (  1  0  )  )  ;", "searchSourceBuilder . size ( randomIntBetween (  2  0  ,     1  0  0  )  )  ;", "return   searchSourceBuilder ;", "}  )  ;", "searchRequest . scroll (  (  ( Scroll )     ( null )  )  )  ;", "IndicesOptions   randomlyGenerated    =    searchRequest . indicesOptions (  )  ;", "IndicesOptions   msearchDefault    =    new   MultiSearchRequest (  )  . indicesOptions (  )  ;", "searchRequest . indicesOptions ( IndicesOptions . fromOptions ( randomlyGenerated . ignoreUnavailable (  )  ,    randomlyGenerated . allowNoIndices (  )  ,    randomlyGenerated . expandWildcardsOpen (  )  ,    randomlyGenerated . expandWildcardsClosed (  )  ,    msearchDefault . allowAliasesToMultipleIndices (  )  ,    msearchDefault . forbidClosedIndices (  )  ,    msearchDefault . ignoreAliases (  )  )  )  ;", "multiSearchRequest . add ( searchRequest )  ;", "}", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "expectedParams . put ( TYPED _ KEYS _ PARAM ,     \" true \"  )  ;", "if    ( randomBoolean (  )  )     {", "multiSearchRequest . maxConcurrentSearchRequests ( randomIntBetween (  1  ,     8  )  )  ;", "expectedParams . put (  \" max _ concurrent _ searches \"  ,    Integer . toString ( multiSearchRequest . maxConcurrentSearchRequests (  )  )  )  ;", "}", "Request   request    =    Request . multiSearch ( multiSearchRequest )  ;", "assertEquals (  \"  /  _ msearch \"  ,    request . getEndpoint (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "List < SearchRequest >    requests    =    new   ArrayList <  >  (  )  ;", "CheckedBiConsumer < SearchRequest ,    XContentParser ,    IOException >    consumer    =     (    searchRequest ,    p )     -  >     {", "SearchSourceBuilder   searchSourceBuilder    =    SearchSourceBuilder . fromXContent ( p ,    false )  ;", "if    (  ( searchSourceBuilder . equals ( new   SearchSourceBuilder (  )  )  )     =  =    false )     {", "searchRequest . source ( searchSourceBuilder )  ;", "}", "requests . add ( searchRequest )  ;", "}  ;", "MultiSearchRequest . readMultiLineFormat ( new   ommon . bytes . BytesArray ( EntityUtils . toByteArray ( request . getEntity (  )  )  )  ,    Request . REQUEST _ BODY _ CONTENT _ TYPE . xContent (  )  ,    consumer ,    null ,    multiSearchRequest . indicesOptions (  )  ,    null ,    null ,    null ,    xContentRegistry (  )  ,    true )  ;", "assertEquals ( requests ,    multiSearchRequest . requests (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiSearch"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  1  ,     5  )  ;", "OpenIndexRequest   openIndexRequest    =    new   OpenIndexRequest ( indices )  ;", "openIndexRequest . indices ( indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomTimeout ( openIndexRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", "RequestTests . setRandomMasterTimeout ( openIndexRequest ,    expectedParams )  ;", "RequestTests . setRandomIndicesOptions ( openIndexRequest :  : indicesOptions ,    openIndexRequest :  : indicesOptions ,    expectedParams )  ;", "RequestTests . setRandomWaitForActiveShards ( openIndexRequest :  : waitForActiveShards ,    expectedParams )  ;", "Request   request    =    Request . openIndex ( openIndexRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  . add ( String . join (  \"  ,  \"  ,    indices )  )  . add (  \"  _ open \"  )  ;", "assertThat ( endpoint . toString (  )  ,    equalTo ( request . getEndpoint (  )  )  )  ;", "assertThat ( expectedParams ,    equalTo ( request . getParameters (  )  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testOpenIndex"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    Strings . EMPTY _ ARRAY ;", "ActionValidationException   validationException    =    new   OpenIndex ( indices )  . validate (  )  ;", "assertNotNull ( validationException )  ;", "}", "METHOD_END"], "methodName": ["testOpenIndexEmptyIndices"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "final   int   nbParams    =    randomIntBetween (  0  ,     1  0  )  ;", ". Params   params    =     . Params . builder (  )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <    nbParams ;    i +  +  )     {", "String   paramName    =     \" p _  \"     +    i ;", "String   paramValue    =    randomAlphaOfLength (  5  )  ;", "params . putParam ( paramName ,    paramValue )  ;", "expectedParams . put ( paramName ,    paramValue )  ;", "}", "Map < String ,    String >    requestParams    =    params . getParams (  )  ;", "assertEquals ( nbParams ,    requestParams . size (  )  )  ;", "assertEquals ( expectedParams ,    requestParams )  ;", "}", "METHOD_END"], "methodName": ["testParams"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "Request . Params   params    =    Request . Params . builder (  )  ;", "params . putParam (  \" test \"  ,     \"  1  \"  )  ;", "IllegalArgumentException   e    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    params . putParam (  \" test \"  ,     \"  2  \"  )  )  ;", "assertEquals (  \" Request   parameter    [ test ]    is   already   registered \"  ,    e . getMessage (  )  )  ;", "Map < String ,    String >    requestParams    =    params . getParams (  )  ;", "assertEquals (  1 L ,    requestParams . size (  )  )  ;", "assertEquals (  \"  1  \"  ,    requestParams . values (  )  . iterator (  )  . next (  )  )  ;", "}", "METHOD_END"], "methodName": ["testParamsNoDuplicates"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "Request   request    =    Request . ping (  )  ;", "assertEquals (  \"  /  \"  ,    request . getEndpoint (  )  )  ;", "assertEquals (  0  ,    request . getParameters (  )  . size (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPing"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "PutMappingRequest   putMappingRequest    =    new   PutMappingRequest (  )  ;", "String [  ]    indices    =     . randomIndicesNames (  0  ,     5  )  ;", "putMappingRequest . indices ( indices )  ;", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "putMappingRequest . type ( type )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomTimeout ( putMappingRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", ". setRandomMasterTimeout ( putMappingRequest ,    expectedParams )  ;", "Request   request    =    Request . putMapping ( putMappingRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "String   index    =    String . join (  \"  ,  \"  ,    indices )  ;", "if    ( Strings . hasLength ( index )  )     {", "endpoint . add ( index )  ;", "}", "endpoint . add (  \"  _ mapping \"  )  ;", "endpoint . add ( type )  ;", "assertEquals ( endpoint . toString (  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", ". assertToXContentBody ( putMappingRequest ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPutMapping"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RankEvalSpec   spec    =    new   RankEvalSpec ( Collections . singletonList ( new   RatedRequest (  \" queryId \"  ,    Collections . emptyList (  )  ,    new   SearchSourceBuilder (  )  )  )  ,    new   PrecisionAtK (  )  )  ;", "String [  ]    indices    =    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "RankEvalRequest   rankEvalRequest    =    new   RankEvalRequest ( spec ,    indices )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( rankEvalRequest :  : indicesOptions ,    rankEvalRequest :  : indicesOptions ,    expectedParams )  ;", "Request   request    =    Request . rankEval ( rankEvalRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "String   index    =    String . join (  \"  ,  \"  ,    indices )  ;", "if    ( Strings . hasLength ( index )  )     {", "endpoint . add ( index )  ;", "}", "endpoint . add ( ENDPOINT )  ;", "assertEquals ( endpoint . toString (  )  ,    request . getEndpoint (  )  )  ;", "assertEquals (  3  ,    request . getParameters (  )  . size (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "RequestTests . assertToXContentBody ( spec ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRankEval"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =     ( randomBoolean (  )  )     ?    null    :    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "RefreshRequest   refreshRequest ;", "if    ( randomBoolean (  )  )     {", "refreshRequest    =    new   RefreshRequest ( indices )  ;", "} else    {", "refreshRequest    =    new   RefreshRequest (  )  ;", "refreshRequest . indices ( indices )  ;", "}", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomIndicesOptions ( refreshRequest :  : indicesOptions ,    refreshRequest :  : indicesOptions ,    expectedParams )  ;", "Request   request    =    Request . refresh ( refreshRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "if    (  ( indices    !  =    null )     &  &     (  ( indices . length )     >     0  )  )     {", "endpoint . add ( String . join (  \"  ,  \"  ,    indices )  )  ;", "}", "endpoint . add (  \"  _ refresh \"  )  ;", "assertThat ( request . getEndpoint (  )  ,    equalTo ( endpoint . toString (  )  )  )  ;", "assertThat ( request . getParameters (  )  ,    equalTo ( expectedParams )  )  ;", "assertThat ( request . getEntity (  )  ,    nullValue (  )  )  ;", "assertThat ( request . getMethod (  )  ,    equalTo ( METHOD _ NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testRefresh"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RolloverRequest   rolloverRequest    =    new   RolloverRequest ( randomAlphaOfLengthBetween (  3  ,     1  0  )  ,     ( randomBoolean (  )     ?    null    :    randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "RequestTests . setRandomTimeout ( rolloverRequest :  : timeout ,    rolloverRequest . timeout (  )  ,    expectedParams )  ;", "RequestTests . setRandomMasterTimeout ( rolloverRequest ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "rolloverRequest . dryRun ( randomBoolean (  )  )  ;", "if    ( rolloverRequest . isDryRun (  )  )     {", "expectedParams . put (  \" dry _ run \"  ,     \" true \"  )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", "rolloverRequest . addMaxIndexAgeCondition ( new   ommon . unit . TimeValue ( randomNonNegativeLong (  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "rolloverRequest . getCreateIndexRequest (  )  . mapping ( type ,    RandomCreateIndexGenerator . randomMapping ( type )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "RandomCreateIndexGenerator . randomAliases ( rolloverRequest . getCreateIndexRequest (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "rolloverRequest . getCreateIndexRequest (  )  . settings ( RandomCreateIndexGenerator . randomIndexSettings (  )  )  ;", "}", "RequestTests . setRandomWaitForActiveShards ( rolloverRequest . getCreateIndexRequest (  )  :  : waitForActiveShards ,    expectedParams )  ;", "Request   request    =    Request . rollover ( rolloverRequest )  ;", "if    (  ( rolloverRequest . getNewIndexName (  )  )     =  =    null )     {", "assertEquals (  (  (  \"  /  \"     +     ( rolloverRequest . getAlias (  )  )  )     +     \"  /  _ rollover \"  )  ,    request . getEndpoint (  )  )  ;", "} else    {", "assertEquals (  (  (  (  \"  /  \"     +     ( rolloverRequest . getAlias (  )  )  )     +     \"  /  _ rollover /  \"  )     +     ( rolloverRequest . getNewIndexName (  )  )  )  ,    request . getEndpoint (  )  )  ;", "}", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "RequestTests . assertToXContentBody ( rolloverRequest ,    request . getEntity (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRollover"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    indices    =    RequestTests . randomIndicesNames (  0  ,     5  )  ;", "SearchRequest   searchRequest    =    new   SearchRequest ( indices )  ;", "int   numTypes    =    randomIntBetween (  0  ,     5  )  ;", "String [  ]    types    =    new   String [ numTypes ]  ;", "for    ( int   i    =     0  ;    i    <    numTypes ;    i +  +  )     {", "types [ i ]     =     \" type -  \"     +     ( randomAlphaOfLengthBetween (  2  ,     5  )  )  ;", "}", "searchRequest . types ( types )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "expectedParams . put ( TYPED _ KEYS _ PARAM ,     \" true \"  )  ;", "if    ( randomBoolean (  )  )     {", "searchRequest . routing ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  ;", "expectedParams . put (  \" routing \"  ,    searchRequest . routing (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchRequest . preference ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  ;", "expectedParams . put (  \" preference \"  ,    searchRequest . preference (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchRequest . searchType ( randomFrom ( SearchType . values (  )  )  )  ;", "}", "expectedParams . put (  \" search _ type \"  ,    searchRequest . searchType (  )  . name (  )  . toLowerCase ( Locale . ROOT )  )  ;", "if    ( randomBoolean (  )  )     {", "searchRequest . requestCache ( randomBoolean (  )  )  ;", "expectedParams . put (  \" request _ cache \"  ,    Boolean . toString ( searchRequest . requestCache (  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchRequest . allowPartialSearchResults ( randomBoolean (  )  )  ;", "expectedParams . put (  \" allow _ partial _ search _ results \"  ,    Boolean . toString ( searchRequest . allowPartialSearchResults (  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchRequest . setBatchedReduceSize ( randomIntBetween (  2  ,    Integer . MAX _ VALUE )  )  ;", "}", "expectedParams . put (  \" batched _ reduce _ size \"  ,    Integer . toString ( searchRequest . getBatchedReduceSize (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "searchRequest . scroll ( randomTimeValue (  )  )  ;", "expectedParams . put (  \" scroll \"  ,    searchRequest . scroll (  )  . keepAlive (  )  . getStringRep (  )  )  ;", "}", "RequestTests . setRandomIndicesOptions ( searchRequest :  : indicesOptions ,    searchRequest :  : indicesOptions ,    expectedParams )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "if    ( frequently (  )  )     {", "if    ( frequently (  )  )     {", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . size ( randomIntBetween (  0  ,    Integer . MAX _ VALUE )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . from ( randomIntBetween (  0  ,    Integer . MAX _ VALUE )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . minScore ( randomFloat (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . explain ( randomBoolean (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . profile ( randomBoolean (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . highlighter ( new   HighlightBuilder (  )  . field ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . query ( new   index . query . TermQueryBuilder ( randomAlphaOfLengthBetween (  3  ,     1  0  )  ,    randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . aggregation ( new   search . aggregations . bucket . terms . TermsAggregationBuilder ( randomAlphaOfLengthBetween (  3  ,     1  0  )  ,    ValueType . STRING )  . field ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . suggest ( new   SuggestBuilder (  )  . addSuggestion ( randomAlphaOfLengthBetween (  3  ,     1  0  )  ,    new   search . suggest . completion . CompletionSuggestionBuilder ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . addRescorer ( new   QueryRescorerBuilder ( new   index . query . TermQueryBuilder ( randomAlphaOfLengthBetween (  3  ,     1  0  )  ,    randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "searchSourceBuilder . collapse ( new   search . collapse . CollapseBuilder ( randomAlphaOfLengthBetween (  3  ,     1  0  )  )  )  ;", "}", "}", "searchRequest . source ( searchSourceBuilder )  ;", "}", "Request   request    =    Request . search ( searchRequest )  ;", "StringJoiner   endpoint    =    new   StringJoiner (  \"  /  \"  ,     \"  /  \"  ,     \"  \"  )  ;", "String   index    =    String . join (  \"  ,  \"  ,    indices )  ;", "if    ( Strings . hasLength ( index )  )     {", "endpoint . add ( index )  ;", "}", "String   type    =    String . join (  \"  ,  \"  ,    types )  ;", "if    ( Strings . hasLength ( type )  )     {", "endpoint . add ( type )  ;", "}", "endpoint . add (  \"  _ search \"  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals ( endpoint . toString (  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "RequestTests . assertToXContentBody ( searchSourceBuilder ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearch"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "expectThrows ( NullPointerException . class ,     (  )     -  >    new   SearchRequest (  (  ( String [  ]  )     ( null )  )  )  )  ;", "expectThrows ( NullPointerException . class ,     (  )     -  >    new   SearchRequest (  )  . indices (  (  ( String [  ]  )     ( null )  )  )  )  ;", "expectThrows ( NullPointerException . class ,     (  )     -  >    new   SearchRequest (  )  . types (  (  ( String [  ]  )     ( null )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchNullIndicesAndTypes"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "Request   request    =    Request . search ( searchRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals (  \"  /  _ search \"  ,    request . getEndpoint (  )  )  ;", "assertNull ( request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchNullSource"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "SearchScrollRequest   searchScrollRequest    =    new   SearchScrollRequest (  )  ;", "searchScrollRequest . scrollId ( randomAlphaOfLengthBetween (  5  ,     1  0  )  )  ;", "if    ( randomBoolean (  )  )     {", "searchScrollRequest . scroll ( randomPositiveTimeValue (  )  )  ;", "}", "Request   request    =    Request . searchScroll ( searchScrollRequest )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "assertEquals (  \"  /  _ search / scroll \"  ,    request . getEndpoint (  )  )  ;", "assertEquals (  0  ,    request . getParameters (  )  . size (  )  )  ;", ". assertToXContentBody ( searchScrollRequest ,    request . getEntity (  )  )  ;", "assertEquals ( Request . REQUEST _ BODY _ CONTENT _ TYPE . mediaTypeWithoutParameters (  )  ,    request . getEntity (  )  . getContentType (  )  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchScroll"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RequestTests . resizeTest ( SHRINK ,    Request :  : shrink )  ;", "}", "METHOD_END"], "methodName": ["testShrink"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "ResizeRequest   resizeRequest    =    new   ResizeRequest (  \" target \"  ,     \" source \"  )  ;", "resizeRequest . setResizeType ( SPLIT )  ;", "IllegalArgumentException   iae    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . shrink ( resizeRequest )  )  ;", "assertEquals (  \" Wrong   resize   type    [ SPLIT ]    for   indices   shrink   request \"  ,    iae . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkWrongResizeType"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "RequestTests . resizeTest ( SPLIT ,    Request :  : split )  ;", "}", "METHOD_END"], "methodName": ["testSplit"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "ResizeRequest   resizeRequest    =    new   ResizeRequest (  \" target \"  ,     \" source \"  )  ;", "resizeRequest . setResizeType ( SHRINK )  ;", "IllegalArgumentException   iae    =    expectThrows ( IllegalArgumentException . class ,     (  )     -  >    Request . split ( resizeRequest )  )  ;", "assertEquals (  \" Wrong   resize   type    [ SHRINK ]    for   indices   split   request \"  ,    iae . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSplitWrongResizeType"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "XContentType   xContentType    =    randomFrom ( XContentType . values (  )  )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", "String   index    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   type    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "String   id    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "UpdateRequest   updateRequest    =    new   UpdateRequest ( index ,    type ,    id )  ;", "updateRequest . detectNoop ( randomBoolean (  )  )  ;", "if    ( randomBoolean (  )  )     {", "BytesReference   source    =    RandomObjects . randomSource ( random (  )  ,    xContentType )  ;", "updateRequest . doc ( new   IndexRequest (  )  . source ( source ,    xContentType )  )  ;", "boolean   docAsUpsert    =    randomBoolean (  )  ;", "updateRequest . docAsUpsert ( docAsUpsert )  ;", "if    ( docAsUpsert )     {", "expectedParams . put (  \" doc _ as _ upsert \"  ,     \" true \"  )  ;", "}", "} else    {", "updateRequest . script ( mockScript (  \"  _ value    +     1  \"  )  )  ;", "updateRequest . scriptedUpsert ( randomBoolean (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "BytesReference   source    =    RandomObjects . randomSource ( random (  )  ,    xContentType )  ;", "updateRequest . upsert ( new   IndexRequest (  )  . source ( source ,    xContentType )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   routing    =    randomAlphaOfLengthBetween (  3  ,     1  0  )  ;", "updateRequest . routing ( routing )  ;", "expectedParams . put (  \" routing \"  ,    routing )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   timeout    =    randomTimeValue (  )  ;", "updateRequest . timeout ( timeout )  ;", "expectedParams . put (  \" timeout \"  ,    timeout )  ;", "} else    {", "expectedParams . put (  \" timeout \"  ,    DEFAULT _ TIMEOUT . getStringRep (  )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "WriteRequest . RefreshPolicy   refreshPolicy    =    randomFrom ( RefreshPolicy . values (  )  )  ;", "updateRequest . setRefreshPolicy ( refreshPolicy )  ;", "if    ( refreshPolicy    !  =     ( RefreshPolicy . NONE )  )     {", "expectedParams . put (  \" refresh \"  ,    refreshPolicy . getValue (  )  )  ;", "}", "}", ". setRandomWaitForActiveShards ( updateRequest :  : waitForActiveShards ,    expectedParams )  ;", ". setRandomVersion ( updateRequest ,    expectedParams )  ;", ". setRandomVersionType ( updateRequest :  : versionType ,    expectedParams )  ;", "if    ( randomBoolean (  )  )     {", "int   retryOnConflict    =    randomIntBetween (  0  ,     5  )  ;", "updateRequest . retryOnConflict ( retryOnConflict )  ;", "if    ( retryOnConflict    >     0  )     {", "expectedParams . put (  \" retry _ on _ conflict \"  ,    String . valueOf ( retryOnConflict )  )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", ". randomizeFetchSourceContextParams ( updateRequest :  : fetchSource ,    expectedParams )  ;", "}", "Request   request    =    Request . update ( updateRequest )  ;", "assertEquals (  (  (  (  (  (  (  \"  /  \"     +    index )     +     \"  /  \"  )     +    type )     +     \"  /  \"  )     +    id )     +     \"  /  _ update \"  )  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", "assertEquals ( METHOD _ NAME ,    request . getMethod (  )  )  ;", "HttpEntity   entity    =    request . getEntity (  )  ;", "assertTrue (  ( entity   instanceof   ByteArrayEntity )  )  ;", "UpdateRequest   parsedUpdateRequest    =    new   UpdateRequest (  )  ;", "XContentType   entityContentType    =    XContentType . fromMediaTypeOrFormat ( entity . getContentType (  )  . getValue (  )  )  ;", "try    ( XContentParser   parser    =    createParser ( entityContentType . xContent (  )  ,    entity . getContent (  )  )  )     {", "parsedUpdateRequest . fromXContent ( parser )  ;", "}", "assertEquals ( updateRequest . scriptedUpsert (  )  ,    parsedUpdateRequest . scriptedUpsert (  )  )  ;", "assertEquals ( updateRequest . docAsUpsert (  )  ,    parsedUpdateRequest . docAsUpsert (  )  )  ;", "assertEquals ( updateRequest . detectNoop (  )  ,    parsedUpdateRequest . detectNoop (  )  )  ;", "assertEquals ( updateRequest . fetchSource (  )  ,    parsedUpdateRequest . fetchSource (  )  )  ;", "assertEquals ( updateRequest . script (  )  ,    parsedUpdateRequest . script (  )  )  ;", "if    (  ( updateRequest . doc (  )  )     !  =    null )     {", "assertToXContentEquivalent ( updateRequest . doc (  )  . source (  )  ,    parsedUpdateRequest . doc (  )  . source (  )  ,    xContentType )  ;", "} else    {", "assertNull ( parsedUpdateRequest . doc (  )  )  ;", "}", "if    (  ( updateRequest . upsertRequest (  )  )     !  =    null )     {", "assertToXContentEquivalent ( updateRequest . upsertRequest (  )  . source (  )  ,    parsedUpdateRequest . upsertRequest (  )  . source (  )  ,    xContentType )  ;", "} else    {", "assertNull ( parsedUpdateRequest . upsertRequest (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "IndicesAliasesRequest   indicesAliasesRequest    =    new   IndicesAliasesRequest (  )  ;", "AliasActions   aliasAction    =    RandomAliasActionsGenerator . randomAliasAction (  )  ;", "indicesAliasesRequest . addAliasAction ( aliasAction )  ;", "Map < String ,    String >    expectedParams    =    new   HashMap <  >  (  )  ;", ". setRandomTimeout ( indicesAliasesRequest :  : timeout ,    DEFAULT _ ACK _ TIMEOUT ,    expectedParams )  ;", ". setRandomMasterTimeout ( indicesAliasesRequest ,    expectedParams )  ;", "Request   request    =    Request . updateAliases ( indicesAliasesRequest )  ;", "assertEquals (  \"  /  _ aliases \"  ,    request . getEndpoint (  )  )  ;", "assertEquals ( expectedParams ,    request . getParameters (  )  )  ;", ". assertToXContentBody ( indicesAliasesRequest ,    request . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateAliases"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "IllegalStateException   exception    =    expectThrows ( IllegalStateException . class ,     (  )     -  >     {", "Update   update    =    new   Update (  )  ;", "update . doc ( new   Index (  )  . source ( singletonMap (  \" field \"  ,     \" doc \"  )  ,    XContentType . JSON )  )  ;", "update . upsert ( new   Index (  )  . source ( singletonMap (  \" field \"  ,     \" upsert \"  )  ,    XContentType . YAML )  )  ;", ". update ( update )  ;", "}  )  ;", "assertEquals (  \" Update   request   cannot   have   different   content   types   for   doc    [ JSON ]    and   upsert    [ YAML ]    documents \"  ,    exception . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testUpdateWithDifferentContentTypes"], "fileName": "org.elasticsearch.client.RequestTests"}, {"methodBody": ["METHOD_START", "{", "return   response . getEntity (  )  ;", "}", "METHOD_END"], "methodName": ["getEntity"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "Header   header    =    response . getFirstHeader ( name )  ;", "if    ( header    =  =    null )     {", "return   null ;", "}", "return   header . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getHeader"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "return   response . getAllHeaders (  )  ;", "}", "METHOD_END"], "methodName": ["getHeaders"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "return   host ;", "}", "METHOD_END"], "methodName": ["getHost"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "return   response ;", "}", "METHOD_END"], "methodName": ["getHttpResponse"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "return   requestLine ;", "}", "METHOD_END"], "methodName": ["getRequestLine"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "return   response . getStatusLine (  )  ;", "}", "METHOD_END"], "methodName": ["getStatusLine"], "fileName": "org.elasticsearch.client.Response"}, {"methodBody": ["METHOD_START", "{", "String   message    =    String . format ( Locale . ROOT ,     \" method    [  % s ]  ,    host    [  % s ]  ,    URI    [  % s ]  ,    status   line    [  % s ]  \"  ,    response . getRequestLine (  )  . getMethod (  )  ,    response . getHost (  )  ,    response . getRequestLine (  )  . getUri (  )  ,    response . getStatusLine (  )  . toString (  )  )  ;", "HttpEntity   entity    =    response . getEntity (  )  ;", "if    ( entity    !  =    null )     {", "if    (  ( entity . isRepeatable (  )  )     =  =    false )     {", "entity    =    new   BufferedHttpEntity ( entity )  ;", "response . getHttp (  )  . setEntity ( entity )  ;", "}", "message    +  =     \"  \\ n \"     +     ( EntityUtils . toString ( entity )  )  ;", "}", "return   message ;", "}", "METHOD_END"], "methodName": ["buildMessage"], "fileName": "org.elasticsearch.client.ResponseException"}, {"methodBody": ["METHOD_START", "{", "return   response ;", "}", "METHOD_END"], "methodName": ["getResponse"], "fileName": "org.elasticsearch.client.ResponseException"}, {"methodBody": ["METHOD_START", "{", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" http \"  ,     1  ,     1  )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,     5  0  0  ,     \" Internal   Server   Error \"  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( statusLine )  ;", "String   responseBody    =     \"  {  \\  \" error \\  \"  :  {  \\  \" root _ cause \\  \"  :     {  }  }  }  \"  ;", "boolean   hasBody    =    getRandom (  )  . nextBoolean (  )  ;", "if    ( hasBody )     {", "HttpEntity   entity ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "entity    =    new   StringEntity ( responseBody ,    ContentType . APPLICATION _ JSON )  ;", "} else    {", "entity    =    new   InputStreamEntity ( new   ByteArrayInputStream ( responseBody . getBytes ( StandardCharsets . UTF _  8  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "}", "httpResponse . setEntity ( entity )  ;", "}", "RequestLine   requestLine    =    new   BasicRequestLine (  \" GET \"  ,     \"  /  \"  ,    protocolVersion )  ;", "HttpHost   httpHost    =    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ;", "Response   response    =    new   Response ( requestLine ,    httpHost ,    httpResponse )  ;", "responseException    =    new    ( response )  ;", "assertSame ( response ,    responseException . getResponse (  )  )  ;", "if    ( hasBody )     {", "assertEquals ( responseBody ,    EntityUtils . toString ( responseException . getResponse (  )  . getEntity (  )  )  )  ;", "} else    {", "assertNull ( responseException . getResponse (  )  . getEntity (  )  )  ;", "}", "String   message    =    String . format ( Locale . ROOT ,     \" method    [  % s ]  ,    host    [  % s ]  ,    URI    [  % s ]  ,    status   line    [  % s ]  \"  ,    response . getRequestLine (  )  . getMethod (  )  ,    response . getHost (  )  ,    response . getRequestLine (  )  . getUri (  )  ,    response . getStatusLine (  )  . toString (  )  )  ;", "if    ( hasBody )     {", "message    +  =     \"  \\ n \"     +    responseBody ;", "}", "assertEquals ( message ,    responseException . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testResponseException"], "fileName": "org.elasticsearch.client.ResponseExceptionTests"}, {"methodBody": ["METHOD_START", "{", "if    ( entity    !  =    null )     {", "if    ( httpRequest   instanceof   HttpEntityEnclosingRequestBase )     {", "(  ( HttpEntityEnclosingRequestBase )     ( httpRequest )  )  . setEntity ( entity )  ;", "} else    {", "throw   new   UnsupportedOperationException (  (  ( httpRequest . getMethod (  )  )     +     \"    with   body   is   not   supported \"  )  )  ;", "}", "}", "return   httpRequest ;", "}", "METHOD_END"], "methodName": ["addRequestBody"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "if    ( suppressedException    !  =    null )     {", "currException . addSuppressed ( suppressedException )  ;", "}", "return   currException ;", "}", "METHOD_END"], "methodName": ["addSuppressedException"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( path ,     \" path   must   not   be   null \"  )  ;", "try    {", "String   fullPath ;", "if    ( pathPrefix    !  =    null )     {", "if    ( path . startsWith (  \"  /  \"  )  )     {", "fullPath    =    pathPrefix    +    path ;", "} else    {", "fullPath    =     ( pathPrefix    +     \"  /  \"  )     +    path ;", "}", "} else    {", "fullPath    =    path ;", "}", "URIBuilder   uriBuilder    =    new   URIBuilder ( fullPath )  ;", "for    ( Map . Entry < String ,    String >    param    :    params . rySet (  )  )     {", "uriBuilder . addParameter ( param . getKey (  )  ,    param . getValue (  )  )  ;", "}", "return   uriBuilder . build (  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   IllegalArgumException ( e . getMessage (  )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["buildUri"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "return   new   RestClientBuilder ( hosts )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "switch    ( method . toUpperCase ( Locale . ROOT )  )     {", "case   HttpDeleteWithEntity . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpDeleteWithEntity ( uri )  ,    entity )  ;", "case   HttpGetWithEntity . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpGetWithEntity ( uri )  ,    entity )  ;", "case   HttpHead . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpHead ( uri )  ,    entity )  ;", "case   HttpOptions . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpOptions ( uri )  ,    entity )  ;", "case   HttpPatch . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpPatch ( uri )  ,    entity )  ;", "case   HttpPost . METHOD _ NAME    :", "HttpPost   httpPost    =    new   HttpPost ( uri )  ;", ". addRequestBody ( httpPost ,    entity )  ;", "return   httpPost ;", "case   HttpPut . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpPut ( uri )  ,    entity )  ;", "case   HttpTrace . METHOD _ NAME    :", "return    . addRequestBody ( new   HttpTrace ( uri )  ,    entity )  ;", "default    :", "throw   new   UnsupportedOperationException (  (  \" http   method   not   supported :     \"     +    method )  )  ;", "}", "}", "METHOD_END"], "methodName": ["createHttpRequest"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "switch    ( statusCode )     {", "case    5  0  2     :", "case    5  0  3     :", "case    5  0  4     :", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isRetryStatus"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "return   statusCode    <     3  0  0  ;", "}", "METHOD_END"], "methodName": ["isSuccessfulResponse"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "final   RestClient . HostTuple < Set < HttpHost >  >    hostTuple    =    this . hostTuple ;", "Collection < HttpHost >    nextHosts    =    Collections . emptySet (  )  ;", "do    {", "Set < HttpHost >    filteredHosts    =    new   HashSet ( hostTuple . hosts )  ;", "for    ( Map . Entry < HttpHost ,    DeadHostState >    entry    :    blacklist . entrySet (  )  )     {", "if    (  ( entry . getValue (  )  . shallBeRetried (  )  )     =  =    false )     {", "filteredHosts . remove ( entry . getKey (  )  )  ;", "}", "}", "if    ( filteredHosts . isEmpty (  )  )     {", "List < Map . Entry < HttpHost ,    DeadHostState >  >    sortedHosts    =    new   ArrayList ( blacklist . entrySet (  )  )  ;", "if    (  ( sortedHosts . size (  )  )     >     0  )     {", "Collections . sort ( sortedHosts ,    new   Comparator < Map . Entry < HttpHost ,    DeadHostState >  >  (  )     {", "@ Override", "public   int   compare ( Map . Entry < HttpHost ,    DeadHostState >    o 1  ,    Map . Entry < HttpHost ,    DeadHostState >    o 2  )     {", "return   o 1  . getValue (  )  . compareTo ( o 2  . getValue (  )  )  ;", "}", "}  )  ;", "HttpHost   deadHost    =    sortedHosts . get (  0  )  . getKey (  )  ;", "RestClient . logger . trace (  (  (  \" resurrecting   host    [  \"     +    deadHost )     +     \"  ]  \"  )  )  ;", "nextHosts    =    Collections . singleton ( deadHost )  ;", "}", "} else    {", "List < HttpHost >    rotatedHosts    =    new   ArrayList ( filteredHosts )  ;", "Collections . rotate ( rotatedHosts ,     (  ( rotatedHosts . size (  )  )     -     ( lastHostIndex . getAndIncrement (  )  )  )  )  ;", "nextHosts    =    rotatedHosts ;", "}", "}    while    ( nextHosts . isEmpty (  )     )  ;", "return   new   RestClient . HostTuple ( nextHosts . iterator (  )  ,    hostTuple . authCache )  ;", "}", "METHOD_END"], "methodName": ["nextHost"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "DeadHostState   previousDeadHostState    =    blacklist . putIfAbsent ( host ,    new   DeadHostState ( DeadHostState . TimeSupplier . DEFAULT )  )  ;", "if    ( previousDeadHostState    =  =    null )     {", ". logger . debug (  (  (  \" added   host    [  \"     +    host )     +     \"  ]    to   blacklist \"  )  )  ;", "break ;", "}", "if    ( blacklist . replace ( host ,    previousDeadHostState ,    new   DeadHostState ( previousDeadHostState ,    DeadHostState . TimeSupplier . DEFAULT )  )  )     {", ". logger . debug (  (  (  \" updated   host    [  \"     +    host )     +     \"  ]    already   in   blacklist \"  )  )  ;", "break ;", "}", "}", "failureListener . onFailure ( host )  ;", "}", "METHOD_END"], "methodName": ["onFailure"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "DeadHostState   removedHost    =    this . blacklist . remove ( host )  ;", "if    (  (  . logger . isDebugEnabled (  )  )     &  &     ( removedHost    !  =    null )  )     {", ". logger . debug (  (  (  \" removed   host    [  \"     +    host )     +     \"  ]    from   blacklist \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["onResponse"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( method ,    endpoint ,    params ,     (  ( HttpEntity )     ( null )  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( method ,    endpoint ,    params ,    entity ,    HttpAsyncResponseConsumerFactory . DEFAULT ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   listener    =    new   RestClient . SyncResponseListener ( maxRetryTimeoutMillis )  ;", "performRequestAsyncNoCatch ( method ,    endpoint ,    params ,    entity ,    httpAsyncResponseConsumerFactory ,    listener ,    headers )  ;", "return   listener . get (  )  ;", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( method ,    endpoint ,    Collections .  < String ,    String > emptyMap (  )  ,    null ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "try    {", "performRequestAsyncNoCatch ( method ,    endpoint ,    params ,    ity ,    httpAsyncResponseConsumerFactory ,    responseListener ,    headers )  ;", "}    catch    ( Exception   e )     {", "responseListener . onFailure ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsync ( method ,    endpoint ,    params ,    entity ,    HttpAsyncResponseConsumerFactory . DEFAULT ,    responseListener ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsync ( method ,    endpoint ,    params ,    null ,    responseListener ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsync ( method ,    endpoint ,    Collections .  < String ,    String > emptyMap (  )  ,    null ,    responseListener ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "final   HttpHost   host    =    hostTuple . hosts . next (  )  ;", "final   HttpAsyncRequestProducer   requestProducer    =    HttpAsyncMethods . create ( host ,    request )  ;", "final   HttpAsyncResponseConsumer < HttpResponse >    asyncResponseConsumer    =    httpAsyncResponseConsumerFactory . createHttpAsyncResponseConsumer (  )  ;", "final   HttpClientContext   context    =    HttpClientContext . create (  )  ;", "context . setAuthCache ( hostTuple . authCache )  ;", "client . execute ( requestProducer ,    asyncResponseConsumer ,    context ,    new   FutureCallback < HttpResponse >  (  )     {", "@ Override", "public   void   completed ( HttpResponse   httpResponse )     {", "try    {", "RequestLogger . logResponse (  . logger ,    request ,    host ,    httpResponse )  ;", "int   statusCode    =    httpResponse . getStatusLine (  )  . getStatusCode (  )  ;", "Response   response    =    new   Response ( request . getRequestLine (  )  ,    host ,    httpResponse )  ;", "if    (  (  . isSuccessfulResponse ( statusCode )  )     |  |     ( ignoreErrorCodes . contains ( response . getStatusLine (  )  . getStatusCode (  )  )  )  )     {", "onResponse ( host )  ;", "listener . onSuccess ( response )  ;", "} else    {", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "if    (  . isRetryStatus ( statusCode )  )     {", "onFailure ( host )  ;", "retryIfPossible ( responseException )  ;", "} else    {", "onResponse ( host )  ;", "listener . onDefinitiveFailure ( responseException )  ;", "}", "}", "}    catch    ( Exception   e )     {", "listener . onDefinitiveFailure ( e )  ;", "}", "}", "@ Override", "public   void   failed ( Exception   failure )     {", "try    {", "RequestLogger . logFailedRequest (  . logger ,    request ,    host ,    failure )  ;", "onFailure ( host )  ;", "retryIfPossible ( failure )  ;", "}    catch    ( Exception   e )     {", "listener . onDefinitiveFailure ( e )  ;", "}", "}", "private   void   retryIfPossible ( Exception   exception )     {", "if    ( hostTuple . hosts . hasNext (  )  )     {", "long   timeElapsedMillis    =    TimeUnit . NANOSECONDS . toMillis (  (  ( System . nanoTime (  )  )     -    startTime )  )  ;", "long   timeout    =     ( maxRetryTimeoutMillis )     -    timeElapsedMillis ;", "if    ( timeout    <  =     0  )     {", "IOException   retryTimeoutException    =    new   IOException (  (  (  \" request   retries   exceeded   max   retry   timeout    [  \"     +     ( maxRetryTimeoutMillis )  )     +     \"  ]  \"  )  )  ;", "listener . onDefinitiveFailure ( retryTimeoutException )  ;", "} else    {", "listener . trackFailure ( exception )  ;", "request . reset (  )  ;", "performRequestAsync ( startTime ,    hostTuple ,    request ,    ignoreErrorCodes ,    httpAsyncResponseConsumerFactory ,    listener )  ;", "}", "} else    {", "listener . onDefinitiveFailure ( exception )  ;", "}", "}", "@ Override", "public   void   cancelled (  )     {", "listener . onDefinitiveFailure ( new   ExecutionException (  \" request   was   cancelled \"  ,    null )  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( params ,     \" params   must   not   be   null \"  )  ;", "Map < String ,    String >    requestParams    =    new   HashMap <  >  ( params )  ;", "String   ignoreString    =    requestParams . remove (  \" ignore \"  )  ;", "Set < Integer >    ignoreErrorCodes ;", "if    ( ignoreString    =  =    null )     {", "if    ( METHOD _ NAME . equals ( method )  )     {", "ignoreErrorCodes    =    Collections . singleton (  4  0  4  )  ;", "} else    {", "ignoreErrorCodes    =    Collections . emptySet (  )  ;", "}", "} else    {", "String [  ]    ignoresArray    =    ignoreString . split (  \"  ,  \"  )  ;", "ignoreErrorCodes    =    new   HashSet <  >  (  )  ;", "if    ( METHOD _ NAME . equals ( method )  )     {", "ignoreErrorCodes . add (  4  0  4  )  ;", "}", "for    ( String   ignoreCode    :    ignoresArray )     {", "try    {", "ignoreErrorCodes . add ( Integer . valueOf ( ignoreCode )  )  ;", "}    catch    ( NumberFormatException   e )     {", "throw   new   IllegalArgumentException (  (  (  \" ignore   value   should   be   a   number ,    found    [  \"     +    ignoreString )     +     \"  ]    instead \"  )  ,    e )  ;", "}", "}", "}", "URI   uri    =     . buildUri ( pathPrefix ,    endpoint ,    requestParams )  ;", "HttpRequestBase   request    =     . createHttpRequest ( method ,    uri ,    entity )  ;", "setHeaders ( request ,    headers )  ;", ". FailureTrackingResponseListener   failureTrackingResponseListener    =    new    . FailureTrackingResponseListener ( responseListener )  ;", "long   startTime    =    System . nanoTime (  )  ;", "performRequestAsync ( startTime ,    nextHost (  )  ,    request ,    ignoreErrorCodes ,    httpAsyncResponseConsumerFactory ,    failureTrackingResponseListener )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsyncNoCatch"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( requestHeaders ,     \" request   headers   must   not   be   null \"  )  ;", "final   Set < String >    requestNames    =    new   HashSet ( requestHeaders . length )  ;", "for    ( Header   requestHeader    :    requestHeaders )     {", "Objects . requireNonNull ( requestHeader ,     \" request   header   must   not   be   null \"  )  ;", "httpRequest . addHeader ( requestHeader )  ;", "requestNames . add ( requestHeader . getName (  )  )  ;", "}", "for    ( Header   defaultHeader    :    defaultHeaders )     {", "if    (  ( requestNames . contains ( defaultHeader . getName (  )  )  )     =  =    false )     {", "httpRequest . addHeader ( defaultHeader )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setHeaders"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hosts    =  =    null )     |  |     (  ( hosts . length )     =  =     0  )  )     {", "throw   new   IllegalArgumentException (  \" hosts   must   not   be   null   nor   empty \"  )  ;", "}", "Set < HttpHost >    httpHosts    =    new   HashSet <  >  (  )  ;", "AuthCache   authCache    =    new   BasicAuthCache (  )  ;", "for    ( HttpHost   host    :    hosts )     {", "Objects . requireNonNull ( host ,     \" host   cannot   be   null \"  )  ;", "httpHosts . add ( host )  ;", "authCache . put ( host ,    new   BasicScheme (  )  )  ;", "}", "this . hostTuple    =    new    . HostTuple ( Collections . unmodifiableSet ( httpHosts )  ,    authCache )  ;", "this . blacklist . clear (  )  ;", "}", "METHOD_END"], "methodName": ["setHosts"], "fileName": "org.elasticsearch.client.RestClient"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failureListener )     =  =    null )     {", "failureListener    =    new    . FailureListener (  )  ;", "}", "CloseableHttpAsyncClient   httpClient    =    AccessController . doPrivileged ( new   PrivilegedAction < CloseableHttpAsyncClient >  (  )     {", "@ Override", "public   CloseableHttpAsyncClient   run (  )     {", "return   createHttpClient (  )  ;", "}", "}  )  ;", "restClient    =    new    ( httpClient ,    maxRetryTimeout ,    defaultHeaders ,    hosts ,    pathPrefix ,    failureListener )  ;", "httpClient . start (  )  ;", "return   restClient ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "RequestConfig . Builder   requestConfigBuilder    =    RequestConfig . custom (  )  . setConnectTimeout ( RestClientBuilder . DEFAULT _ CONNECT _ TIMEOUT _ MILLIS )  . setSocketTimeout ( RestClientBuilder . DEFAULT _ SOCKET _ TIMEOUT _ MILLIS )  . setConnectionRequestTimeout ( RestClientBuilder . DEFAULT _ CONNECTION _ REQUEST _ TIMEOUT _ MILLIS )  ;", "if    (  ( requestConfigCallback )     !  =    null )     {", "requestConfigBuilder    =    requestConfigCallback . customizeRequestConfig ( requestConfigBuilder )  ;", "}", "try    {", "HttpAsyncClientBuilder   httpClientBuilder    =    HttpAsyncClientBuilder . create (  )  . setDefaultRequestConfig ( requestConfigBuilder . build (  )  )  . setMaxConnPerRoute ( RestClientBuilder . DEFAULT _ MAX _ CONN _ PER _ ROUTE )  . setMaxConnTotal ( RestClientBuilder . DEFAULT _ MAX _ CONN _ TOTAL )  . setSSLContext ( SSLContext . getDefault (  )  )  ;", "if    (  ( httpClientConfigCallback )     !  =    null )     {", "httpClientBuilder    =    httpClientConfigCallback . customizeHttpClient ( httpClientBuilder )  ;", "}", "final   HttpAsyncClientBuilder   finalBuilder    =    httpClientBuilder ;", "return   AccessController . doPrivileged ( new   PrivilegedAction < CloseableHttpAsyncClient >  (  )     {", "@ Override", "public   CloseableHttpAsyncClient   run (  )     {", "return   finalBuilder . build (  )  ;", "}", "}  )  ;", "}    catch    ( NoSuchAlgorithmException   e )     {", "throw   new   IllegalStateException (  \" could   not   create   the   default   ssl   context \"  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["createHttpClient"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( defaultHeaders ,     \" defaultHeaders   must   not   be   null \"  )  ;", "for    ( Header   defaultHeader    :    defaultHeaders )     {", "Objects . requireNonNull ( defaultHeader ,     \" default   header   must   not   be   null \"  )  ;", "}", "this . defaultHeaders    =    defaultHeaders ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDefaultHeaders"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( failureListener ,     \" failureListener   must   not   be   null \"  )  ;", "this . failureListener    =    failureListener ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFailureListener"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( httpClientConfigCallback ,     \" httpClientConfigCallback   must   not   be   null \"  )  ;", "this . httpClientConfigCallback    =    httpClientConfigCallback ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHttpClientConfigCallback"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "if    ( maxRetryTimeoutMillis    <  =     0  )     {", "throw   new   IllegalArgumException (  \" maxRetryTimeoutMillis   must   be   greater   than    0  \"  )  ;", "}", "this . maxRetryTimeout    =    maxRetryTimeoutMillis ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMaxRetryTimeoutMillis"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( pathPrefix ,     \" pathPrefix   must   not   be   null \"  )  ;", "String   cleanPathPrefix    =    pathPrefix ;", "if    (  ( cleanPathPrefix . startsWith (  \"  /  \"  )  )     =  =    false )     {", "cleanPathPrefix    =     \"  /  \"     +    cleanPathPrefix ;", "}", "if    ( cleanPathPrefix . endsWith (  \"  /  \"  )  )     {", "cleanPathPrefix    =    cleanPathPrefix . substring (  0  ,     (  ( cleanPathPrefix . length (  )  )     -     1  )  )  ;", "if    ( cleanPathPrefix . endsWith (  \"  /  \"  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" pathPrefix   is   malformed .    too   many   trailing   shes :     [  \"     +    pathPrefix )     +     \"  ]  \"  )  )  ;", "}", "}", "if    (  ( cleanPathPrefix . isEmpty (  )  )     |  |     (  \"  /  \"  . equals ( cleanPathPrefix )  )  )     {", "throw   new   IllegalArgumentException (  (  (  \" pathPrefix   must   not   be   empty   or    '  /  '  :     [  \"     +    pathPrefix )     +     \"  ]  \"  )  )  ;", "}", "this . pathPrefix    =    cleanPathPrefix ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPathPrefix"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( requestConfigCallback ,     \" requestConfigCallback   must   not   be   null \"  )  ;", "this . requestConfigCallback    =    requestConfigCallback ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRequestConfigCallback"], "fileName": "org.elasticsearch.client.RestClientBuilder"}, {"methodBody": ["METHOD_START", "{", "InetSocketAddress   address    =    RestClientBuilderIntegTests . httpsServer . getAddress (  )  ;", "return   RestClient . builder ( new   HttpHost ( address . getHostString (  )  ,    address . getPort (  )  ,     \" https \"  )  )  . build (  )  ;", "}", "METHOD_END"], "methodName": ["buildRestClient"], "fileName": "org.elasticsearch.client.RestClientBuilderIntegTests"}, {"methodBody": ["METHOD_START", "{", "SSLContext   sslContext    =    SSLContext . getInstance (  \" TLS \"  )  ;", "try    ( InputStream   in    =     . class . getResourceAsStream (  \"  / testks . jks \"  )  )     {", "KeyStore   keyStore    =    KeyStore . getInstance (  \" JKS \"  )  ;", "keyStore . load ( in ,     \" password \"  . toCharArray (  )  )  ;", "KeyManagerFactory   kmf    =    KeyManagerFactory . getInstance (  \" SunX 5  0  9  \"  )  ;", "kmf . init ( keyStore ,     \" password \"  . toCharArray (  )  )  ;", "TrustManagerFactory   tmf    =    TrustManagerFactory . getInstance (  \" SunX 5  0  9  \"  )  ;", "tmf . init ( keyStore )  ;", "sslContext . init ( kmf . getKeyManagers (  )  ,    tmf . getTrustManagers (  )  ,    null )  ;", "}", "return   sslContext ;", "}", "METHOD_END"], "methodName": ["getSslContext"], "fileName": "org.elasticsearch.client.RestClientBuilderIntegTests"}, {"methodBody": ["METHOD_START", "{", "RestClientBuilderIntegTests . httpsServer    =    MockHttpServer . createHttps ( new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,     0  )  ,     0  )  ;", "RestClientBuilderIntegTests . httpsServer . setHttpsConfigurator ( new   HttpsConfigurator ( RestClientBuilderIntegTests . getSslContext (  )  )  )  ;", "RestClientBuilderIntegTests . httpsServer . createContext (  \"  /  \"  ,    new   RestClientBuilderIntegTests . ResponseHandler (  )  )  ;", "RestClientBuilderIntegTests . httpsServer . start (  )  ;", "}", "METHOD_END"], "methodName": ["startHttpServer"], "fileName": "org.elasticsearch.client.RestClientBuilderIntegTests"}, {"methodBody": ["METHOD_START", "{", "RestClientBuilderIntegTests . httpsServer . stop (  0  )  ;", "RestClientBuilderIntegTests . httpsServer    =    null ;", "}", "METHOD_END"], "methodName": ["stopHttpServers"], "fileName": "org.elasticsearch.client.RestClientBuilderIntegTests"}, {"methodBody": ["METHOD_START", "{", "final   SSLContext   defaultSSLContext    =    SSLContext . getDefault (  )  ;", "try    {", "try    ( RestClient   client    =    buildRestClient (  )  )     {", "try    {", "client . performRequest (  \" GET \"  ,     \"  /  \"  )  ;", "fail (  \" connection   should   have   been   rejected   due   to   SSL   handshake \"  )  ;", "}    catch    ( Exception   e )     {", "assertThat ( e . getMessage (  )  ,    containsString (  \" General   SSLEngine   problem \"  )  )  ;", "}", "}", "SSLContext . setDefault (  . getSslContext (  )  )  ;", "try    ( RestClient   client    =    buildRestClient (  )  )     {", "Response   response    =    client . performRequest (  \" GET \"  ,     \"  /  \"  )  ;", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "}    finally    {", "SSLContext . setDefault ( defaultSSLContext )  ;", "}", "}", "METHOD_END"], "methodName": ["testBuilderUsesDefaultSSLContext"], "fileName": "org.elasticsearch.client.RestClientBuilderIntegTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setPathPrefix ( pathPrefix )  ;", "fail (  (  (  \" path   prefix    [  \"     +    pathPrefix )     +     \"  ]    should   have   failed \"  )  )  ;", "}    catch    ( final   IllegalArgumentException   e )     {", "assertThat ( e . getMessage (  )  ,    containsString ( pathPrefix )  )  ;", "}", "}", "METHOD_END"], "methodName": ["assertSetPathPrefixThrows"], "fileName": "org.elasticsearch.client.RestClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "RestClient . builder (  (  ( HttpHost [  ]  )     ( null )  )  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" hosts   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder (  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" no   hosts   provided \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" host   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    ( RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . build (  )  )     {", "assertNotNull ( restClient )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setMaxRetryTimeoutMillis ( randomIntBetween ( Integer . MIN _ VALUE ,     0  )  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" maxRetryTimeoutMillis   must   be   greater   than    0  \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setDefaultHeaders ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" defaultHeaders   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setDefaultHeaders ( new   Header [  ]  {    null    }  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" default   header   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setFailureListener ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" failureListener   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setHttpClientConfigCallback ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" httpClientConfigCallback   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setRequestConfigCallback ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" requestConfigCallback   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "int   numNodes    =    randomIntBetween (  1  ,     5  )  ;", "HttpHost [  ]    hosts    =    new   HttpHost [ numNodes ]  ;", "for    ( int   i    =     0  ;    i    <    numNodes ;    i +  +  )     {", "hosts [ i ]     =    new   HttpHost (  \" localhost \"  ,     (  9  2  0  0     +    i )  )  ;", "}", "builder    =    RestClient . builder ( hosts )  ;", "if    ( randomBoolean (  )  )     {", "builder . setHttpClientConfigCallback ( new    . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "return   httpClientBuilder ;", "}", "}  )  ;", "}", "if    ( randomBoolean (  )  )     {", "builder . setRequestConfigCallback ( new    . RequestConfigCallback (  )     {", "@ Override", "public   Builder   customizeRequestConfig ( RequestConfig . Builder   requestConfigBuilder )     {", "return   requestConfigBuilder ;", "}", "}  )  ;", "}", "if    ( randomBoolean (  )  )     {", "int   numHeaders    =    randomIntBetween (  1  ,     5  )  ;", "Header [  ]    headers    =    new   Header [ numHeaders ]  ;", "for    ( int   i    =     0  ;    i    <    numHeaders ;    i +  +  )     {", "headers [ i ]     =    new   BasicHeader (  (  \" header \"     +    i )  ,     \" value \"  )  ;", "}", "builder . setDefaultHeaders ( headers )  ;", "}", "if    ( randomBoolean (  )  )     {", "builder . setMaxRetryTimeoutMillis ( randomIntBetween (  1  ,    Integer . MAX _ VALUE )  )  ;", "}", "if    ( randomBoolean (  )  )     {", "String   pathPrefix    =     ( randomBoolean (  )     ?     \"  /  \"     :     \"  \"  )     +     ( randomAsciiOfLengthBetween (  2  ,     5  )  )  ;", "while    (  (  ( pathPrefix . length (  )  )     <     2  0  )     &  &     ( randomBoolean (  )  )  )     {", "pathPrefix    +  =     \"  /  \"     +     ( randomAsciiOfLengthBetween (  3  ,     6  )  )  ;", "}", "builder . setPathPrefix (  ( pathPrefix    +     ( randomBoolean (  )     ?     \"  /  \"     :     \"  \"  )  )  )  ;", "}", "try    ( RestClient   restClient    =    builder . build (  )  )     {", "assertNotNull ( restClient )  ;", "}", "}", "METHOD_END"], "methodName": ["testBuild"], "fileName": "org.elasticsearch.client.RestClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RestClientBuilderTests . assertSetPathPrefixThrows (  \"  /  \"  )  ;", "RestClientBuilderTests . assertSetPathPrefixThrows (  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetPathPrefixEmpty"], "fileName": "org.elasticsearch.client.RestClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "RestClientBuilderTests . assertSetPathPrefixThrows (  \"  /  /  \"  )  ;", "RestClientBuilderTests . assertSetPathPrefixThrows (  \" base / path /  /  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSetPathPrefixMalformed"], "fileName": "org.elasticsearch.client.RestClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "try    {", ". builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setPathPrefix ( null )  ;", "fail (  \" pathPrefix   set   to   null   should   fail !  \"  )  ;", "}    catch    ( final   NullPointerException   e )     {", "assertEquals (  \" pathPrefix   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSetPathPrefixNull"], "fileName": "org.elasticsearch.client.RestClientBuilderTests"}, {"methodBody": ["METHOD_START", "{", "HttpServer   httpServer    =    MockHttpServer . createHttp ( new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,     0  )  ,     0  )  ;", "httpServer . start (  )  ;", "for    ( int   statusCode    :    RestClientTestUtil . getAllStatusCodes (  )  )     {", "httpServer . createContext (  (  (  (  . pathPrefix )     +     \"  /  \"  )     +    statusCode )  ,    new    . ResponseHandler ( statusCode )  )  ;", "}", "return   httpServer ;", "}", "METHOD_END"], "methodName": ["createHttpServer"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "String   pathPrefixWithoutLeadingSlash ;", "if    ( randomBoolean (  )  )     {", "pathPrefixWithoutLeadingSlash    =     \" testPathPrefix /  \"     +     ( randomAsciiOfLengthBetween (  1  ,     5  )  )  ;", ". pathPrefix    =     \"  /  \"     +    pathPrefixWithoutLeadingSlash ;", "} else    {", ". pathPrefix    =    pathPrefixWithoutLeadingSlash    =     \"  \"  ;", "}", "int   numHttpServers    =    randomIntBetween (  2  ,     4  )  ;", ". httpServers    =    new   HttpServer [ numHttpServers ]  ;", "HttpHost [  ]    httpHosts    =    new   HttpHost [ numHttpServers ]  ;", "for    ( int   i    =     0  ;    i    <    numHttpServers ;    i +  +  )     {", "HttpServer   httpServer    =     . createHttpServer (  )  ;", ". httpServers [ i ]     =    httpServer ;", "httpHosts [ i ]     =    new   HttpHost ( httpServer . getAddress (  )  . getHostString (  )  ,    httpServer . getAddress (  )  . getPort (  )  )  ;", "}", "RestClientBuilder   restClientBuilder    =    RestClient . builder ( httpHosts )  ;", "if    (  (  . pathPrefix . length (  )  )     >     0  )     {", "restClientBuilder . setPathPrefix (  (  ( randomBoolean (  )     ?     \"  /  \"     :     \"  \"  )     +    pathPrefixWithoutLeadingSlash )  )  ;", "}", ". restClient    =    restClientBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["startHttpServer"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "RestClientMultipleHostsIntegTests . restClient . close (  )  ;", "RestClientMultipleHostsIntegTests . restClient    =    null ;", "for    ( HttpServer   httpServer    :    RestClientMultipleHostsIntegTests . httpServers )     {", "httpServer . stop (  0  )  ;", "}", "RestClientMultipleHostsIntegTests . httpServers    =    null ;", "}", "METHOD_END"], "methodName": ["stopHttpServers"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( RestClientMultipleHostsIntegTests . httpServers . length )     >     1  )     &  &     ( randomBoolean (  )  )  )     {", "List < HttpServer >    updatedHttpServers    =    new   ArrayList <  >  (  (  ( RestClientMultipleHostsIntegTests . httpServers . length )     -     1  )  )  ;", "int   nodeIndex    =    randomInt (  (  ( RestClientMultipleHostsIntegTests . httpServers . length )     -     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( RestClientMultipleHostsIntegTests . httpServers . length )  ;    i +  +  )     {", "HttpServer   httpServer    =    RestClientMultipleHostsIntegTests . httpServers [ i ]  ;", "if    ( i    =  =    nodeIndex )     {", "httpServer . stop (  0  )  ;", "} else    {", "updatedHttpServers . add ( httpServer )  ;", "}", "}", "RestClientMultipleHostsIntegTests . httpServers    =    updatedHttpServers . toArray ( new   HttpServer [ updatedHttpServers . size (  )  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["stopRandomHost"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "int   numRequests    =    randomIntBetween (  5  ,     2  0  )  ;", "final   CountDownLatch   latch    =    new   CountDownLatch ( numRequests )  ;", "final   List <  . TestResponse >    responses    =    new   CopyOnWriteArrayList <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <    numRequests ;    i +  +  )     {", "final   String   method    =    RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ;", "final   int   statusCode    =     ( randomBoolean (  )  )     ?    RestClientTestUtil . randomOkStatusCode ( getRandom (  )  )     :    RestClientTestUtil . randomErrorNoRetryStatusCode ( getRandom (  )  )  ;", ". restClient . performRequestAsync ( method ,     (  \"  /  \"     +    statusCode )  ,    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "responses . add ( new    . TestResponse ( method ,    statusCode ,    response )  )  ;", "latch . countDown (  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "responses . add ( new    . TestResponse ( method ,    statusCode ,    exception )  )  ;", "latch . countDown (  )  ;", "}", "}  )  ;", "}", "assertTrue ( latch . await (  5  ,    TimeUnit . SECONDS )  )  ;", "assertEquals ( numRequests ,    responses . size (  )  )  ;", "for    (  . TestResponse   testResponse    :    responses )     {", "Response   response    =    testResponse . getResponse (  )  ;", "assertEquals ( testResponse . method ,    response . getRequestLine (  )  . getMethod (  )  )  ;", "assertEquals ( testResponse . statusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertEquals (  (  (  (  (  . pathPrefix . length (  )  )     >     0     ?     . pathPrefix    :     \"  \"  )     +     \"  /  \"  )     +     ( testResponse . statusCode )  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testAsyncRequests"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "int   numRequests    =    randomIntBetween (  5  ,     2  0  )  ;", "for    ( int   i    =     0  ;    i    <    numRequests ;    i +  +  )     {", "final   String   method    =    RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ;", "final   int   statusCode    =     ( randomBoolean (  )  )     ?    RestClientTestUtil . randomOkStatusCode ( getRandom (  )  )     :    RestClientTestUtil . randomErrorNoRetryStatusCode ( getRandom (  )  )  ;", "Response   response ;", "try    {", "response    =     . restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  )  ;", "}    catch    ( ResponseException   responseException )     {", "response    =    responseException . getResponse (  )  ;", "}", "assertEquals ( method ,    response . getRequestLine (  )  . getMethod (  )  )  ;", "assertEquals ( statusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertEquals (  (  (  (  (  . pathPrefix . length (  )  )     >     0     ?     . pathPrefix    :     \"  \"  )     +     \"  /  \"  )     +    statusCode )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSyncRequests"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsIntegTests"}, {"methodBody": ["METHOD_START", "{", "CloseableHttpAsyncClient   httpClient    =    mock ( CloseableHttpAsyncClient . class )  ;", "when ( httpClient .  < HttpResponse > execute ( any ( HttpAsyncRequestProducer . class )  ,    any ( HttpAsyncResponseConsumer . class )  ,    any ( HttpClientContext . class )  ,    any ( FutureCallback . class )  )  )  . thenAnswer ( new   Answer < Future < HttpResponse >  >  (  )     {", "@ Override", "public   Future < HttpResponse >    answer ( InvocationOnMock   invocationOnMock )    throws   Throwable    {", "HttpAsyncRequestProducer   requestProducer    =     (  ( HttpAsyncRequestProducer )     ( invocationOnMock . getArguments (  )  [  0  ]  )  )  ;", "final   HttpUriRequest   request    =     (  ( HttpUriRequest )     ( requestProducer . generateRequest (  )  )  )  ;", "final   HttpHost   httpHost    =    requestProducer . getTarget (  )  ;", "HttpClientContext   context    =     (  ( HttpClientContext )     ( invocationOnMock . getArguments (  )  [  2  ]  )  )  ;", "assertThat ( context . getAuthCache (  )  . get ( httpHost )  ,    instanceOf ( BasicScheme . class )  )  ;", "final   FutureCallback < HttpResponse >    futureCallback    =     (  ( FutureCallback < HttpResponse >  )     ( invocationOnMock . getArguments (  )  [  3  ]  )  )  ;", "exec . execute ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "if    ( request . getURI (  )  . getPath (  )  . equals (  \"  / soe \"  )  )     {", "futureCallback . failed ( new   SocketTimeoutException ( httpHost . toString (  )  )  )  ;", "} else", "if    ( request . getURI (  )  . getPath (  )  . equals (  \"  / coe \"  )  )     {", "futureCallback . failed ( new   ConnectTimeoutException ( httpHost . toString (  )  )  )  ;", "} else", "if    ( request . getURI (  )  . getPath (  )  . equals (  \"  / ioe \"  )  )     {", "futureCallback . failed ( new   IOException ( httpHost . toString (  )  )  )  ;", "} else    {", "int   statusCode    =    Integer . parseInt ( request . getURI (  )  . getPath (  )  . substring (  1  )  )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( new   ProtocolVersion (  \" http \"  ,     1  ,     1  )  ,    statusCode ,     \"  \"  )  ;", "futureCallback . completed ( new   BasicHttpResponse ( statusLine )  )  ;", "}", "}", "}  )  ;", "return   null ;", "}", "}  )  ;", "int   numHosts    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     2  ,     5  )  ;", "httpHosts    =    new   HttpHost [ numHosts ]  ;", "for    ( int   i    =     0  ;    i    <    numHosts ;    i +  +  )     {", "httpHosts [ i ]     =    new   HttpHost (  \" localhost \"  ,     (  9  2  0  0     +    i )  )  ;", "}", "failureListener    =    new   HostsTrackingFailureListener (  )  ;", "restClient    =    new    ( httpClient ,     1  0  0  0  0  ,    new   Header [  0  ]  ,    httpHosts ,    null ,    failureListener )  ;", "}", "METHOD_END"], "methodName": ["createRestClient"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "switch    ( RandomNumbers . randomIntBetween ( getRandom (  )  ,     0  ,     3  )  )     {", "case    0     :", "return    \"  /  \"     +     ( TestUtil . randomErrorRetryStatusCode ( getRandom (  )  )  )  ;", "case    1     :", "return    \"  / coe \"  ;", "case    2     :", "return    \"  / soe \"  ;", "case    3     :", "return    \"  / ioe \"  ;", "}", "throw   new   UnsupportedOperationException (  )  ;", "}", "METHOD_END"], "methodName": ["randomErrorRetryEndpoint"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "exec . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdownExec"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "int   numIters    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,     5  )  ;", "for    ( int   i    =     0  ;    i    <    numIters ;    i +  +  )     {", "Set < HttpHost >    hostsSet    =    new   HashSet <  >  (  )  ;", "Collections . addAll ( hostsSet ,    httpHosts )  ;", "for    ( int   j    =     0  ;    j    <     ( httpHosts . length )  ;    j +  +  )     {", "String   method    =    TestUtil . randomHttpMethod ( getRandom (  )  )  ;", "int   statusCode    =    TestUtil . randomErrorNoRetryStatusCode ( getRandom (  )  )  ;", "try    {", "Response   response    =    restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  )  ;", "if    (  ( method . equals (  \" HEAD \"  )  )     &  &     ( statusCode    =  =     4  0  4  )  )     {", "assertEquals (  4  0  4  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertEquals ( statusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertTrue (  (  \" host   not   found :     \"     +     ( response . getHost (  )  )  )  ,    hostsSet . remove ( response . getHost (  )  )  )  ;", "} else    {", "fail (  \" request   should   have   failed \"  )  ;", "}", "}    catch    ( ResponseException   e )     {", "if    (  ( method . equals (  \" HEAD \"  )  )     &  &     ( statusCode    =  =     4  0  4  )  )     {", "throw   e ;", "}", "Response   response    =    e . getResponse (  )  ;", "assertEquals ( statusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertTrue (  (  \" host   not   found :     \"     +     ( response . getHost (  )  )  )  ,    hostsSet . remove ( response . getHost (  )  )  )  ;", "assertEquals (  0  ,    e . getSuppressed (  )  . length )  ;", "}", "}", "assertEquals (  (  \" every   host   should   have   been   used   but   some   weren ' t :     \"     +    hostsSet )  ,     0  ,    hostsSet . size (  )  )  ;", "}", "failureListener . assertNotCalled (  )  ;", "}", "METHOD_END"], "methodName": ["testRoundRobinNoRetryErrors"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "int   numIters    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,     5  )  ;", "for    ( int   i    =     0  ;    i    <    numIters ;    i +  +  )     {", "Set < HttpHost >    hostsSet    =    new   HashSet <  >  (  )  ;", "Collections . addAll ( hostsSet ,    httpHosts )  ;", "for    ( int   j    =     0  ;    j    <     ( httpHosts . length )  ;    j +  +  )     {", "int   statusCode    =    TestUtil . randomOkStatusCode ( getRandom (  )  )  ;", "Response   response    =    restClient . performRequest ( TestUtil . randomHttpMethod ( getRandom (  )  )  ,     (  \"  /  \"     +    statusCode )  )  ;", "assertEquals ( statusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertTrue (  (  \" host   not   found :     \"     +     ( response . getHost (  )  )  )  ,    hostsSet . remove ( response . getHost (  )  )  )  ;", "}", "assertEquals (  (  \" every   host   should   have   been   used   but   some   weren ' t :     \"     +    hostsSet )  ,     0  ,    hostsSet . size (  )  )  ;", "}", "failureListener . assertNotCalled (  )  ;", "}", "METHOD_END"], "methodName": ["testRoundRobinOkStatusCodes"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "String   retryEndpoint    =    RestClientMultipleHostsTests . randomErrorRetryEndpoint (  )  ;", "try    {", "restClient . performRequest ( RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ,    retryEndpoint )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( ResponseException   e )     {", "e    =     (  ( ResponseException )     ( e . getCause (  )  )  )  ;", "Set < HttpHost >    hostsSet    =    new   HashSet <  >  (  )  ;", "Collections . addAll ( hostsSet ,    httpHosts )  ;", "failureListener . assertCalled ( httpHosts )  ;", "do    {", "Response   response    =    e . getResponse (  )  ;", "assertEquals ( Integer . parseInt ( retryEndpoint . substring (  1  )  )  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertTrue (  (  (  \" host    [  \"     +     ( response . getHost (  )  )  )     +     \"  ]    not   found ,    most   likely   used   multiple   times \"  )  ,    hostsSet . remove ( response . getHost (  )  )  )  ;", "if    (  ( e . getSuppressed (  )  . length )     >     0  )     {", "assertEquals (  1  ,    e . getSuppressed (  )  . length )  ;", "Throwable   suppressed    =    e . getSuppressed (  )  [  0  ]  ;", "assertThat ( suppressed ,    instanceOf ( ResponseException . class )  )  ;", "e    =     (  ( ResponseException )     ( suppressed )  )  ;", "} else    {", "e    =    null ;", "}", "}    while    ( e    !  =    null    )  ;", "assertEquals (  (  \" every   host   should   have   been   used   but   some   weren ' t :     \"     +    hostsSet )  ,     0  ,    hostsSet . size (  )  )  ;", "}    catch    ( IOException   e )     {", "e    =     (  ( IOException )     ( e . getCause (  )  )  )  ;", "Set < HttpHost >    hostsSet    =    new   HashSet <  >  (  )  ;", "Collections . addAll ( hostsSet ,    httpHosts )  ;", "failureListener . assertCalled ( httpHosts )  ;", "do    {", "HttpHost   httpHost    =    HttpHost . create ( e . getMessage (  )  )  ;", "assertTrue (  (  (  \" host    [  \"     +    httpHost )     +     \"  ]    not   found ,    most   likely   used   multiple   times \"  )  ,    hostsSet . remove ( httpHost )  )  ;", "if    (  ( e . getSuppressed (  )  . length )     >     0  )     {", "assertEquals (  1  ,    e . getSuppressed (  )  . length )  ;", "Throwable   suppressed    =    e . getSuppressed (  )  [  0  ]  ;", "assertThat ( suppressed ,    instanceOf ( IOException . class )  )  ;", "e    =     (  ( IOException )     ( suppressed )  )  ;", "} else    {", "e    =    null ;", "}", "}    while    ( e    !  =    null    )  ;", "assertEquals (  (  \" every   host   should   have   been   used   but   some   weren ' t :     \"     +    hostsSet )  ,     0  ,    hostsSet . size (  )  )  ;", "}", "int   numIters    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     2  ,     5  )  ;", "for    ( int   i    =     1  ;    i    <  =    numIters ;    i +  +  )     {", "Set < HttpHost >    hostsSet    =    new   HashSet <  >  (  )  ;", "Collections . addAll ( hostsSet ,    httpHosts )  ;", "for    ( int   j    =     0  ;    j    <     ( httpHosts . length )  ;    j +  +  )     {", "retryEndpoint    =    RestClientMultipleHostsTests . randomErrorRetryEndpoint (  )  ;", "try    {", "restClient . performRequest ( RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ,    retryEndpoint )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( ResponseException   e )     {", "Response   response    =    e . getResponse (  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( Integer . parseInt ( retryEndpoint . substring (  1  )  )  )  )  ;", "assertTrue (  (  (  \" host    [  \"     +     ( response . getHost (  )  )  )     +     \"  ]    not   found ,    most   likely   used   multiple   times \"  )  ,    hostsSet . remove ( response . getHost (  )  )  )  ;", "failureListener . assertCalled ( response . getHost (  )  )  ;", "assertEquals (  0  ,    e . getSuppressed (  )  . length )  ;", "}    catch    ( IOException   e )     {", "e    =     (  ( IOException )     ( e . getCause (  )  )  )  ;", "HttpHost   httpHost    =    HttpHost . create ( e . getMessage (  )  )  ;", "assertTrue (  (  (  \" host    [  \"     +    httpHost )     +     \"  ]    not   found ,    most   likely   used   multiple   times \"  )  ,    hostsSet . remove ( httpHost )  )  ;", "failureListener . assertCalled ( httpHost )  ;", "assertEquals (  0  ,    e . getSuppressed (  )  . length )  ;", "}", "}", "assertEquals (  (  \" every   host   should   have   been   used   but   some   weren ' t :     \"     +    hostsSet )  ,     0  ,    hostsSet . size (  )  )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "HttpHost   selectedHost    =    null ;", "int   iters    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     2  ,     1  0  )  ;", "for    ( int   y    =     0  ;    y    <    iters ;    y +  +  )     {", "int   statusCode    =    RestClientTestUtil . randomErrorNoRetryStatusCode ( getRandom (  )  )  ;", "Response   response ;", "try    {", "response    =    restClient . performRequest ( RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ,     (  \"  /  \"     +    statusCode )  )  ;", "}    catch    ( ResponseException   e )     {", "response    =    e . getResponse (  )  ;", "}", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( statusCode )  )  ;", "if    ( selectedHost    =  =    null )     {", "selectedHost    =    response . getHost (  )  ;", "} else    {", "assertThat ( response . getHost (  )  ,    equalTo ( selectedHost )  )  ;", "}", "}", "failureListener . assertNotCalled (  )  ;", "for    ( int   y    =     0  ;    y    <     ( i    +     1  )  ;    y +  +  )     {", "retryEndpoint    =    RestClientMultipleHostsTests . randomErrorRetryEndpoint (  )  ;", "try    {", "restClient . performRequest ( RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ,    retryEndpoint )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( ResponseException   e )     {", "Response   response    =    e . getResponse (  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( Integer . parseInt ( retryEndpoint . substring (  1  )  )  )  )  ;", "assertThat ( response . getHost (  )  ,    equalTo ( selectedHost )  )  ;", "failureListener . assertCalled ( selectedHost )  ;", "}    catch    ( IOException   e )     {", "e    =     (  ( IOException )     ( e . getCause (  )  )  )  ;", "HttpHost   httpHost    =    HttpHost . create ( e . getMessage (  )  )  ;", "assertThat ( httpHost ,    equalTo ( selectedHost )  )  ;", "failureListener . assertCalled ( selectedHost )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testRoundRobinRetryErrors"], "fileName": "org.elasticsearch.client.RestClientMultipleHostsTests"}, {"methodBody": ["METHOD_START", "{", "return   bodyTest ( RestClientSingleHostIntegTests . restClient ,    method )  ;", "}", "METHOD_END"], "methodName": ["bodyTest"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "String   requestBody    =     \"  {     \\  \" field \\  \"  :     \\  \" value \\  \"     }  \"  ;", "StringEntity   entity    =    new   StringEntity ( requestBody ,    ContentType . APPLICATION _ JSON )  ;", "int   statusCode    =    RestClientTestUtil . randomStatusCode ( getRandom (  )  )  ;", "Response   esResponse ;", "try    {", "esResponse    =    restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,    Collections .  < String ,    String > emptyMap (  )  ,    entity )  ;", "}    catch    ( ResponseException   e )     {", "esResponse    =    e . getResponse (  )  ;", "}", "assertEquals ( method ,    esResponse . getRequestLine (  )  . getMethod (  )  )  ;", "assertEquals ( statusCode ,    esResponse . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertEquals (  (  (  (  . pathPrefix )     +     \"  /  \"  )     +    statusCode )  ,    esResponse . getRequestLine (  )  . getUri (  )  )  ;", "assertEquals ( requestBody ,    EntityUtils . toString ( esResponse . getEntity (  )  )  )  ;", "return   esResponse ;", "}", "METHOD_END"], "methodName": ["bodyTest"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "HttpServer   httpServer    =    MockHttpServer . createHttp ( new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,     0  )  ,     0  )  ;", "httpServer . start (  )  ;", "for    ( int   statusCode    :    RestClientTestUtil . getAllStatusCodes (  )  )     {", "httpServer . createContext (  (  (  (  . pathPrefix )     +     \"  /  \"  )     +    statusCode )  ,    new    . ResponseHandler ( statusCode )  )  ;", "}", "return   httpServer ;", "}", "METHOD_END"], "methodName": ["createHttpServer"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "final   BasicCredentialsProvider   credentialsProvider    =    new   BasicCredentialsProvider (  )  ;", "credentialsProvider . setCredentials ( ANY ,    new   UsernamePasswordCredentials (  \" user \"  ,     \" pass \"  )  )  ;", "final   RestClientBuilder   restClientBuilder    =    RestClient . builder ( new   HttpHost (  . httpServer . getAddress (  )  . getHostString (  )  ,     . httpServer . getAddress (  )  . getPort (  )  )  )  . setDefaultHeaders (  . defaultHeaders )  ;", "if    (  (  . pathPrefix . length (  )  )     >     0  )     {", "restClientBuilder . setPathPrefix (  . pathPrefix )  ;", "}", "if    ( useAuth )     {", "restClientBuilder . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( final   HttpAsyncClientBuilder   httpClientBuilder )     {", "if    ( usePreemptiveAuth    =  =    false )     {", "httpClientBuilder . disableAuthCaching (  )  ;", "}", "return   httpClientBuilder . setDefaultCredentialsProvider ( credentialsProvider )  ;", "}", "}  )  ;", "}", "return   restClientBuilder . build (  )  ;", "}", "METHOD_END"], "methodName": ["createRestClient"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "RestClientSingleHostIntegTests . pathPrefix    =     ( randomBoolean (  )  )     ?     \"  / testPathPrefix /  \"     +     ( randomAsciiLettersOfLengthBetween (  1  ,     5  )  )     :     \"  \"  ;", "RestClientSingleHostIntegTests . httpServer    =    RestClientSingleHostIntegTests . createHttpServer (  )  ;", "RestClientSingleHostIntegTests . defaultHeaders    =    RestClientTestUtil . randomHeaders ( getRandom (  )  ,     \" Header - default \"  )  ;", "RestClientSingleHostIntegTests . restClient    =    RestClientSingleHostIntegTests . createRestClient ( false ,    true )  ;", "}", "METHOD_END"], "methodName": ["startHttpServer"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "RestClientSingleHostIntegTests . restClient . close (  )  ;", "RestClientSingleHostIntegTests . restClient    =    null ;", "RestClientSingleHostIntegTests . httpServer . stop (  0  )  ;", "RestClientSingleHostIntegTests . httpServer    =    null ;", "}", "METHOD_END"], "methodName": ["stopHttpServers"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "bodyTest (  \" DELETE \"  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteWithBody"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" this / is / the / routing \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = this %  2 Fis %  2 Fthe %  2 Frouting \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" this | is | the | routing \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = this %  7 Cis %  7 Cthe %  7 Crouting \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" routing #  1  \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = routing %  2  3  1  \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \"  \u00d6\u00d0  \u00ce\u00c4  \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing =  % E 4  % B 8  % AD % E 6  %  9  6  %  8  7  \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" foo   bar \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = foo + bar \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" foo + bar \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = foo %  2 Bbar \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" foo / bar \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = foo %  2 Fbar \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" PUT \"  ,     \"  /  2  0  0  \"  ,    Collections . singletonMap (  \" routing \"  ,     \" foo ^ bar \"  )  )  ;", "assertEquals (  (  ( RestClientSingleHostIntegTests . pathPrefix )     +     \"  /  2  0  0  ? routing = foo %  5 Ebar \"  )  ,    response . getRequestLine (  )  . getUri (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testEncodeParams"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "bodyTest (  \" GET \"  )  ;", "}", "METHOD_END"], "methodName": ["testGetWithBody"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "final   Set < String >    standardHeaders    =    new   HashSet <  >  ( Arrays . asList (  \" Connection \"  ,     \" Host \"  ,     \" User - agent \"  ,     \" Date \"  )  )  ;", "if    (  ( method . equals (  \" HEAD \"  )  )     =  =    false )     {", "standardHeaders . add (  \" Content - length \"  )  ;", "}", "final   Header [  ]    requestHeaders    =    RestClientTestUtil . randomHeaders ( getRandom (  )  ,     \" Header \"  )  ;", "final   int   statusCode    =    RestClientTestUtil . randomStatusCode ( getRandom (  )  )  ;", "Response   esResponse ;", "try    {", "esResponse    =     . restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,    Collections .  < String ,    String > emptyMap (  )  ,    requestHeaders )  ;", "}    catch    ( ResponseException   e )     {", "esResponse    =    e . getResponse (  )  ;", "}", "assertEquals ( method ,    esResponse . getRequestLine (  )  . getMethod (  )  )  ;", "assertEquals ( statusCode ,    esResponse . getStatusLine (  )  . getStatusCode (  )  )  ;", "assertEquals (  (  (  (  . pathPrefix )     +     \"  /  \"  )     +    statusCode )  ,    esResponse . getRequestLine (  )  . getUri (  )  )  ;", "RestClientTestCase . assertHeaders (  . defaultHeaders ,    requestHeaders ,    esResponse . getHeaders (  )  ,    standardHeaders )  ;", "for    ( final   Header   responseHeader    :    esResponse . getHeaders (  )  )     {", "String   name    =    responseHeader . getName (  )  ;", "if    (  ( name . startsWith (  \" Header \"  )  )     =  =    false )     {", "assertTrue (  (  \" unknown   header   was   returned    \"     +    name )  ,    standardHeaders . remove ( name )  )  ;", "}", "}", "assertTrue (  (  \" some   expected   standard   headers   weren ' t   returned :     \"     +    standardHeaders )  ,    standardHeaders . isEmpty (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHeaders"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    methods    =    new   String [  ]  {     \" POST \"  ,     \" PUT \"  ,     \" GET \"  ,     \" DELETE \"     }  ;", "try    ( RestClient   restClient    =     . createRestClient ( true ,    false )  )     {", "for    ( final   String   method    :    methods )     {", "final   Response   response    =    bodyTest ( restClient ,    method )  ;", "assertThat ( response . getHeader (  \" Authorization \"  )  ,    nullValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testPreemptiveAuthDisabled"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    methods    =    new   String [  ]  {     \" POST \"  ,     \" PUT \"  ,     \" GET \"  ,     \" DELETE \"     }  ;", "try    ( RestClient   restClient    =     . createRestClient ( true ,    true )  )     {", "for    ( final   String   method    :    methods )     {", "final   Response   response    =    bodyTest ( restClient ,    method )  ;", "assertThat ( response . getHeader (  \" Authorization \"  )  ,    startsWith (  \" Basic \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testPreemptiveAuthEnabled"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "if    (  ( RestClientSingleHostIntegTests . pathPrefix . length (  )  )     =  =     0  )     {", "try    {", "RestClientSingleHostIntegTests . restClient . performRequest (  \" GET \"  ,     \"  2  0  0  \"  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( ResponseException   e )     {", "assertEquals (  4  0  4  ,    e . getResponse (  )  . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "} else    {", "{", "Response   response    =    RestClientSingleHostIntegTests . restClient . performRequest (  \" GET \"  ,     \"  2  0  0  \"  )  ;", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "{", "try    ( RestClient   restClient    =    RestClient . builder ( new   HttpHost ( RestClientSingleHostIntegTests . httpServer . getAddress (  )  . getHostString (  )  ,    RestClientSingleHostIntegTests . httpServer . getAddress (  )  . getPort (  )  )  )  . setPathPrefix ( RestClientSingleHostIntegTests . pathPrefix . substring (  1  )  )  . build (  )  )     {", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  2  0  0  \"  )  ;", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testUrlWithoutLeadingSlash"], "fileName": "org.elasticsearch.client.RestClientSingleHostIntegTests"}, {"methodBody": ["METHOD_START", "{", "httpClient    =    mock ( CloseableHttpAsyncClient . class )  ;", "when ( httpClient .  < HttpResponse > execute ( any ( HttpAsyncRequestProducer . class )  ,    any ( HttpAsyncResponseConsumer . class )  ,    any ( HttpClientContext . class )  ,    any ( FutureCallback . class )  )  )  . thenAnswer ( new   Answer < Future < HttpResponse >  >  (  )     {", "@ Override", "public   Future < HttpResponse >    answer ( InvocationOnMock   invocationOnMock )    throws   Throwable    {", "HttpAsyncRequestProducer   requestProducer    =     (  ( HttpAsyncRequestProducer )     ( invocationOnMock . getArguments (  )  [  0  ]  )  )  ;", "HttpClientContext   context    =     (  ( HttpClientContext )     ( invocationOnMock . getArguments (  )  [  2  ]  )  )  ;", "assertThat ( context . getAuthCache (  )  . get ( httpHost )  ,    instanceOf ( BasicScheme . class )  )  ;", "final   FutureCallback < HttpResponse >    futureCallback    =     (  ( FutureCallback < HttpResponse >  )     ( invocationOnMock . getArguments (  )  [  3  ]  )  )  ;", "HttpUriRequest   request    =     (  ( HttpUriRequest )     ( requestProducer . generateRequest (  )  )  )  ;", "if    ( request . getURI (  )  . getPath (  )  . equals (  \"  / soe \"  )  )     {", "futureCallback . failed ( new   SocketTimeoutException (  )  )  ;", "} else", "if    ( request . getURI (  )  . getPath (  )  . equals (  \"  / coe \"  )  )     {", "futureCallback . failed ( new   ConnectTimeoutException (  )  )  ;", "} else    {", "int   statusCode    =    Integer . parseInt ( request . getURI (  )  . getPath (  )  . substring (  1  )  )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( new   ProtocolVersion (  \" http \"  ,     1  ,     1  )  ,    statusCode ,     \"  \"  )  ;", "final   HttpResponse   httpResponse    =    new   BasicHttpResponse ( statusLine )  ;", "if    ( request   instanceof   HttpEntityEnclosingRequest )     {", "HttpEntity   entity    =     (  ( HttpEntityEnclosingRequest )     ( request )  )  . getEntity (  )  ;", "if    ( entity    !  =    null )     {", "assertTrue (  \" the   entity   is   not   repeatable ,    cannot   set   it   to   the   response   directly \"  ,    entity . isRepeatable (  )  )  ;", "httpResponse . setEntity ( entity )  ;", "}", "}", "httpResponse . setHeaders ( request . getAllHeaders (  )  )  ;", "exec . execute ( new   Runnable (  )     {", "@ Override", "public   void   run (  )     {", "futureCallback . completed ( httpResponse )  ;", "}", "}  )  ;", "}", "return   null ;", "}", "}  )  ;", "defaultHeaders    =    TestUtil . randomHeaders ( getRandom (  )  ,     \" Header - default \"  )  ;", "httpHost    =    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ;", "failureListener    =    new   HostsTrackingFailureListener (  )  ;", "restClient    =    new    ( httpClient ,     1  0  0  0  0  ,    defaultHeaders ,    new   HttpHost [  ]  {    httpHost    }  ,    null ,    failureListener )  ;", "}", "METHOD_END"], "methodName": ["createRestClient"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "String   uriAsString    =     \"  /  \"     +     ( RestClientTestUtil . randomStatusCode ( getRandom (  )  )  )  ;", "URIBuilder   uriBuilder    =    new   URIBuilder ( uriAsString )  ;", "final   Map < String ,    String >    params    =    new   HashMap <  >  (  )  ;", "boolean   hasParams    =    randomBoolean (  )  ;", "if    ( hasParams )     {", "int   numParams    =    randomIntBetween (  1  ,     3  )  ;", "for    ( int   i    =     0  ;    i    <    numParams ;    i +  +  )     {", "String   paramKey    =     \" param -  \"     +    i ;", "String   paramValue    =    randomAsciiOfLengthBetween (  3  ,     1  0  )  ;", "params . put ( paramKey ,    paramValue )  ;", "uriBuilder . addParameter ( paramKey ,    paramValue )  ;", "}", "}", "if    ( randomBoolean (  )  )     {", "String   ignore    =    Integer . toString ( randomFrom ( RestClientTestUtil . getAllErrorStatusCodes (  )  )  )  ;", "if    ( randomBoolean (  )  )     {", "ignore    +  =     \"  ,  \"     +     ( Integer . toString ( randomFrom ( RestClientTestUtil . getAllErrorStatusCodes (  )  )  )  )  ;", "}", "params . put (  \" ignore \"  ,    ignore )  ;", "}", "URI   uri    =    uriBuilder . build (  )  ;", "HttpUriRequest   request ;", "switch    ( method )     {", "case    \" DELETE \"     :", "request    =    new   HttpDeleteWithEntity ( uri )  ;", "break ;", "case    \" GET \"     :", "request    =    new   HttpGetWithEntity ( uri )  ;", "break ;", "case    \" HEAD \"     :", "request    =    new   HttpHead ( uri )  ;", "break ;", "case    \" OPTIONS \"     :", "request    =    new   HttpOptions ( uri )  ;", "break ;", "case    \" PATCH \"     :", "request    =    new   HttpPatch ( uri )  ;", "break ;", "case    \" POST \"     :", "request    =    new   HttpPost ( uri )  ;", "break ;", "case    \" PUT \"     :", "request    =    new   HttpPut ( uri )  ;", "break ;", "case    \" TRACE \"     :", "request    =    new   HttpTrace ( uri )  ;", "break ;", "default    :", "throw   new   UnsupportedOperationException (  (  \" method   not   supported :     \"     +    method )  )  ;", "}", "HttpEntity   entity    =    null ;", "boolean   hasBody    =     ( request   instanceof   HttpEntityEnclosingRequest )     &  &     ( getRandom (  )  . nextBoolean (  )  )  ;", "if    ( hasBody )     {", "entity    =    new   StringEntity ( randomAsciiOfLengthBetween (  1  0  ,     1  0  0  )  ,    ContentType . APPLICATION _ JSON )  ;", "(  ( HttpEntityEnclosingRequest )     ( request )  )  . setEntity ( entity )  ;", "}", "Header [  ]    headers    =    new   Header [  0  ]  ;", "final   Set < String >    uniqueNames    =    new   HashSet <  >  (  )  ;", "if    ( randomBoolean (  )  )     {", "headers    =    RestClientTestUtil . randomHeaders ( getRandom (  )  ,     \" Header \"  )  ;", "for    ( Header   header    :    headers )     {", "request . addHeader ( header )  ;", "uniqueNames . add ( header . getName (  )  )  ;", "}", "}", "for    ( Header   defaultHeader    :    defaultHeaders )     {", "if    (  ( uniqueNames . contains ( defaultHeader . getName (  )  )  )     =  =    false )     {", "request . addHeader ( defaultHeader )  ;", "}", "}", "try    {", "if    (  (  ( hasParams    =  =    false )     &  &     ( hasBody    =  =    false )  )     &  &     ( randomBoolean (  )  )  )     {", "restClient . performRequest ( method ,    uriAsString ,    headers )  ;", "} else", "if    (  ( hasBody    =  =    false )     &  &     ( randomBoolean (  )  )  )     {", "restClient . performRequest ( method ,    uriAsString ,    params ,    headers )  ;", "} else    {", "restClient . performRequest ( method ,    uriAsString ,    params ,    entity ,    headers )  ;", "}", "}    catch    ( ResponseException   e )     {", "}", "return   request ;", "}", "METHOD_END"], "methodName": ["performRandomRequest"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "int   methodSelector ;", "if    ( params . isEmpty (  )  )     {", "methodSelector    =    randomIntBetween (  0  ,     2  )  ;", "} else    {", "methodSelector    =    randomIntBetween (  1  ,     2  )  ;", "}", "switch    ( methodSelector )     {", "case    0     :", "return   r . performRequest ( method ,    endpoint ,    headers )  ;", "case    1     :", "return   r . performRequest ( method ,    endpoint ,    params ,    headers )  ;", "case    2     :", "return   r . performRequest ( method ,    endpoint ,    params ,     (  ( HttpEntity )     ( null )  )  ,    headers )  ;", "default    :", "throw   new   UnsupportedOperationException (  )  ;", "}", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( method ,    endpoint ,    Collections .  < String ,    String > emptyMap (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "exec . shutdown (  )  ;", "}", "METHOD_END"], "methodName": ["shutdownExec"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "String   body    =     \"  {     \\  \" field \\  \"  :     \\  \" value \\  \"     }  \"  ;", "StringEntity   entity    =    new   StringEntity ( body ,    ContentType . APPLICATION _ JSON )  ;", "for    ( String   method    :    Arrays . asList (  \" DELETE \"  ,     \" GET \"  ,     \" PATCH \"  ,     \" POST \"  ,     \" PUT \"  )  )     {", "for    ( int   okStatusCode    :    TestUtil . getOkStatusCodes (  )  )     {", "Response   response    =    restClient . performRequest ( method ,     (  \"  /  \"     +    okStatusCode )  ,    Collections .  < String ,    String > emptyMap (  )  ,    entity )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( okStatusCode )  )  ;", "assertThat ( EntityUtils . toString ( response . getEntity (  )  )  ,    equalTo ( body )  )  ;", "}", "for    ( int   errorStatusCode    :    TestUtil . getAllErrorStatusCodes (  )  )     {", "try    {", "restClient . performRequest ( method ,     (  \"  /  \"     +    errorStatusCode )  ,    Collections .  < String ,    String > emptyMap (  )  ,    entity )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( ResponseException   e )     {", "Response   response    =    e . getResponse (  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( errorStatusCode )  )  ;", "assertThat ( EntityUtils . toString ( response . getEntity (  )  )  ,    equalTo ( body )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "}", "for    ( String   method    :    Arrays . asList (  \" HEAD \"  ,     \" OPTIONS \"  ,     \" TRACE \"  )  )     {", "try    {", "restClient . performRequest ( method ,     (  \"  /  \"     +     ( TestUtil . randomStatusCode ( getRandom (  )  )  )  )  ,    Collections .  < String ,    String > emptyMap (  )  ,    entity )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( UnsupportedOperationException   e )     {", "assertThat ( e . getMessage (  )  ,    equalTo (  ( method    +     \"    with   body   is   not   supported \"  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testBody"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "Set < Integer >    expectedIgnores    =    new   HashSet <  >  (  )  ;", "String   ignoreParam    =     \"  \"  ;", "if    ( METHOD _ NAME . equals ( method )  )     {", "expectedIgnores . add (  4  0  4  )  ;", "}", "if    ( randomBoolean (  )  )     {", "int   numIgnores    =    randomIntBetween (  1  ,     3  )  ;", "for    ( int   i    =     0  ;    i    <    numIgnores ;    i +  +  )     {", "Integer   code    =    randomFrom ( RestClientTestUtil . getAllErrorStatusCodes (  )  )  ;", "expectedIgnores . add ( code )  ;", "ignoreParam    +  =    code ;", "if    ( i    <     ( numIgnores    -     1  )  )     {", "ignoreParam    +  =     \"  ,  \"  ;", "}", "}", "}", "for    ( int   errorStatusCode    :    RestClientTestUtil . getAllErrorStatusCodes (  )  )     {", "try    {", "Map < String ,    String >    params ;", "if    ( ignoreParam . isEmpty (  )  )     {", "params    =    Collections . emptyMap (  )  ;", "} else    {", "params    =    Collections . singletonMap (  \" ignore \"  ,    ignoreParam )  ;", "}", "Response   response    =    performRequest ( method ,     (  \"  /  \"     +    errorStatusCode )  ,    params )  ;", "if    ( expectedIgnores . contains ( errorStatusCode )  )     {", "assertEquals ( errorStatusCode ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "} else    {", "fail (  \" request   should   have   failed \"  )  ;", "}", "}    catch    ( ResponseException   e )     {", "if    ( expectedIgnores . contains ( errorStatusCode )  )     {", "throw   e ;", "}", "assertEquals ( errorStatusCode ,    e . getResponse (  )  . getStatusLine (  )  . getStatusCode (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "if    (  ( errorStatusCode    <  =     5  0  0  )     |  |     ( expectedIgnores . contains ( errorStatusCode )  )  )     {", "failureListener . assertNotCalled (  )  ;", "} else    {", "failureListener . assertCalled ( httpHost )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testErrorStatusCodes"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "final   Header [  ]    requestHeaders    =    RestClientTestUtil . randomHeaders ( getRandom (  )  ,     \" Header \"  )  ;", "final   int   statusCode    =    RestClientTestUtil . randomStatusCode ( getRandom (  )  )  ;", "Response   esResponse ;", "try    {", "esResponse    =    restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,    requestHeaders )  ;", "}    catch    ( ResponseException   e )     {", "esResponse    =    e . getResponse (  )  ;", "}", "assertThat ( esResponse . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( statusCode )  )  ;", "RestClientTestCase . assertHeaders ( defaultHeaders ,    requestHeaders ,    esResponse . getHeaders (  )  ,    Collections .  < String > emptySet (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testHeaders"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "try    {", "performRequest ( method ,     \"  / coe \"  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( IOException   e )     {", "assertThat ( e ,    instanceOf ( ConnectTimeoutException . class )  )  ;", "}", "failureListener . assertCalled ( httpHost )  ;", "try    {", "performRequest ( method ,     \"  / soe \"  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( IOException   e )     {", "assertThat ( e ,    instanceOf ( SocketTimeoutException . class )  )  ;", "}", "failureListener . assertCalled ( httpHost )  ;", "}", "}", "METHOD_END"], "methodName": ["testIOExceptions"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "ArgumentCaptor < HttpAsyncRequestProducer >    requestArgumentCaptor    =    ArgumentCaptor . forClass ( HttpAsyncRequestProducer . class )  ;", "int   times    =     0  ;", "for    ( String   httpMethod    :    TestUtil . getHttpMethods (  )  )     {", "HttpUriRequest   expectedRequest    =    performRandomRequest ( httpMethod )  ;", "verify ( httpClient ,    times (  (  +  + times )  )  )  .  < HttpResponse > execute ( requestArgumentCaptor . capture (  )  ,    any ( HttpAsyncResponseConsumer . class )  ,    any ( HttpClientContext . class )  ,    any ( FutureCallback . class )  )  ;", "HttpUriRequest   actualRequest    =     (  ( HttpUriRequest )     ( requestArgumentCaptor . getValue (  )  . generateRequest (  )  )  )  ;", "assertEquals ( expectedRequest . getURI (  )  ,    actualRequest . getURI (  )  )  ;", "assertEquals ( expectedRequest . getClass (  )  ,    actualRequest . getClass (  )  )  ;", "assertArrayEquals ( expectedRequest . getAllHeaders (  )  ,    actualRequest . getAllHeaders (  )  )  ;", "if    ( expectedRequest   instanceof   HttpEntityEnclosingRequest )     {", "HttpEntity   expectedEntity    =     (  ( HttpEntityEnclosingRequest )     ( expectedRequest )  )  . getEntity (  )  ;", "if    ( expectedEntity    !  =    null )     {", "HttpEntity   actualEntity    =     (  ( HttpEntityEnclosingRequest )     ( actualRequest )  )  . getEntity (  )  ;", "assertEquals ( EntityUtils . toString ( expectedEntity )  ,    EntityUtils . toString ( actualEntity )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testInternalHttpRequest"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "String   method    =    RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ;", "int   statusCode    =    RestClientTestUtil . randomStatusCode ( getRandom (  )  )  ;", "try    {", "performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,     (  ( Header [  ]  )     ( null )  )  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" request   headers   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,     (  ( Header )     ( null )  )  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" request   header   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNullHeaders"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "String   method    =    RestClientTestUtil . randomHttpMethod ( getRandom (  )  )  ;", "int   statusCode    =    RestClientTestUtil . randomStatusCode ( getRandom (  )  )  ;", "try    {", "restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,     (  ( Map < String ,    String >  )     ( null )  )  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" params   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "restClient . performRequest ( method ,     (  \"  /  \"     +    statusCode )  ,    null ,     (  ( HttpEntity )     ( null )  )  )  ;", "fail (  \" request   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" params   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testNullParams"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "for    ( int   okStatusCode    :    RestClientTestUtil . getOkStatusCodes (  )  )     {", "Response   response    =    performRequest ( method ,     (  \"  /  \"     +    okStatusCode )  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( okStatusCode )  )  ;", "}", "}", "failureListener . assertNotCalled (  )  ;", "}", "METHOD_END"], "methodName": ["testOkStatusCodes"], "fileName": "org.elasticsearch.client.RestClientSingleHostTests"}, {"methodBody": ["METHOD_START", "{", "List < String >    values    =    map . get ( name )  ;", "if    ( values    =  =    null )     {", "values    =    new   ArrayList <  >  (  )  ;", "map . put ( name ,    values )  ;", "}", "values . add ( value )  ;", "}", "METHOD_END"], "methodName": ["addValueToListEntry"], "fileName": "org.elasticsearch.client.RestClientTestCase"}, {"methodBody": ["METHOD_START", "{", "final   Map < String ,    List < String >  >    expectedHeaders    =    new   HashMap <  >  (  )  ;", "final   Set < String >    requestHeaderKeys    =    new   HashSet <  >  (  )  ;", "for    ( final   Header   header    :    requestHeaders )     {", "final   String   name    =    header . getName (  )  ;", ". addValueToListEntry ( expectedHeaders ,    name ,    header . getValue (  )  )  ;", "requestHeaderKeys . add ( name )  ;", "}", "for    ( final   Header   defaultHeader    :    defaultHeaders )     {", "final   String   name    =    defaultHeader . getName (  )  ;", "if    (  ( requestHeaderKeys . contains ( name )  )     =  =    false )     {", ". addValueToListEntry ( expectedHeaders ,    name ,    defaultHeader . getValue (  )  )  ;", "}", "}", "Set < String >    actualIgnoredHeaders    =    new   HashSet <  >  (  )  ;", "for    ( Header   responseHeader    :    actualHeaders )     {", "final   String   name    =    responseHeader . getName (  )  ;", "if    ( ignoreHeaders . contains ( name )  )     {", "expectedHeaders . remove ( name )  ;", "actualIgnoredHeaders . add ( name )  ;", "continue ;", "}", "final   String   value    =    responseHeader . getValue (  )  ;", "final   List < String >    values    =    expectedHeaders . get ( name )  ;", "assertNotNull (  (  (  (  \" found   response   header    [  \"     +    name )     +     \"  ]    that   wasn ' t   originally   sent :     \"  )     +    value )  ,    values )  ;", "assertTrue (  (  (  (  \" found   incorrect   response   header    [  \"     +    name )     +     \"  ]  :     \"  )     +    value )  ,    values . remove ( value )  )  ;", "if    ( values . isEmpty (  )  )     {", "expectedHeaders . remove ( name )  ;", "}", "}", "assertEquals (  \" some   headers   meant   to   be   ignored   were   not   part   of   the   actual   headers \"  ,    ignoreHeaders ,    actualIgnoredHeaders )  ;", "assertTrue (  (  \" some   headers   that   were   sent   weren ' t   returned    \"     +    expectedHeaders )  ,    expectedHeaders . isEmpty (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertHeaders"], "fileName": "org.elasticsearch.client.RestClientTestCase"}, {"methodBody": ["METHOD_START", "{", "return   RestClientTestUtil . ALL _ ERROR _ STATUS _ CODES ;", "}", "METHOD_END"], "methodName": ["getAllErrorStatusCodes"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RestClientTestUtil . ALL _ STATUS _ CODES ;", "}", "METHOD_END"], "methodName": ["getAllStatusCodes"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RestClientTestUtil . HTTP _ METHODS ;", "}", "METHOD_END"], "methodName": ["getHttpMethods"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RestClientTestUtil . OK _ STATUS _ CODES ;", "}", "METHOD_END"], "methodName": ["getOkStatusCodes"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RandomPicks . randomFrom ( random ,    RestClientTestUtil . ERROR _ NO _ RETRY _ STATUS _ CODES )  ;", "}", "METHOD_END"], "methodName": ["randomErrorNoRetryStatusCode"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RandomPicks . randomFrom ( random ,    RestClientTestUtil . ERROR _ RETRY _ STATUS _ CODES )  ;", "}", "METHOD_END"], "methodName": ["randomErrorRetryStatusCode"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "int   numHeaders    =    RandomNumbers . randomIntBetween ( random ,     0  ,     5  )  ;", "final   Header [  ]    headers    =    new   Header [ numHeaders ]  ;", "for    ( int   i    =     0  ;    i    <    numHeaders ;    i +  +  )     {", "String   headerName    =    baseName ;", "if    ( random . nextBoolean (  )  )     {", "headerName    =    headerName    +    i ;", "}", "headers [ i ]     =    new   apache . http . message . BasicHeader ( headerName ,    RandomStrings . randomAsciiOfLengthBetween ( random ,     3  ,     1  0  )  )  ;", "}", "return   headers ;", "}", "METHOD_END"], "methodName": ["randomHeaders"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RandomPicks . randomFrom ( random ,    RestClientTestUtil . HTTP _ METHODS )  ;", "}", "METHOD_END"], "methodName": ["randomHttpMethod"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RandomPicks . randomFrom ( random ,    RestClientTestUtil . OK _ STATUS _ CODES )  ;", "}", "METHOD_END"], "methodName": ["randomOkStatusCode"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "return   RandomPicks . randomFrom ( random ,    RestClientTestUtil . ALL _ STATUS _ CODES )  ;", "}", "METHOD_END"], "methodName": ["randomStatusCode"], "fileName": "org.elasticsearch.client.RestClientTestUtil"}, {"methodBody": ["METHOD_START", "{", "HttpHost [  ]    hosts    =    new   HttpHost [  ]  {    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )     }  ;", "return   new    ( mock ( CloseableHttpAsyncClient . class )  ,    randomIntBetween (  1  0  0  0  ,     3  0  0  0  0  )  ,    new   Header [  ]  {        }  ,    hosts ,    null ,    null )  ;", "}", "METHOD_END"], "methodName": ["createRestClient"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "{", "URI   uri    =    RestClient . buildUri (  \"  / foo $ bar \"  ,     \"  / index / type / id \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \"  / foo $ bar / index / type / id \"  ,    uri . getPath (  )  )  ;", "}", "{", "URI   uri    =    RestClient . buildUri ( null ,     \"  / foo $ bar / ty / pe / i / d \"  ,    Collections .  < String ,    String > emptyMap (  )  )  ;", "assertEquals (  \"  / foo $ bar / ty / pe / i / d \"  ,    uri . getPath (  )  )  ;", "}", "{", "URI   uri    =    RestClient . buildUri ( null ,     \"  / index / type / id \"  ,    Collections . singletonMap (  \" foo $ bar \"  ,     \" x / y / z \"  )  )  ;", "assertEquals (  \"  / index / type / id \"  ,    uri . getPath (  )  )  ;", "assertEquals (  \" foo $ bar = x / y / z \"  ,    uri . getQuery (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBuildUriLeavesPathUntouched"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "HttpHost [  ]    hosts    =    new   HttpHost [  ]  {    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )     }  ;", "CloseableHttpAsyncClient   closeableHttpAsyncClient    =    mock ( CloseableHttpAsyncClient . class )  ;", "restClient    =    new    ( closeableHttpAsyncClient ,     1  0  0  0  ,    new   Header [  0  ]  ,    hosts ,    null ,    null )  ;", "restClient . close (  )  ;", "verify ( closeableHttpAsyncClient ,    times (  1  )  )  . close (  )  ;", "restClient . close (  )  ;", "verify ( closeableHttpAsyncClient ,    times (  2  )  )  . close (  )  ;", "restClient . close (  )  ;", "verify ( closeableHttpAsyncClient ,    times (  3  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCloseIsIdempotent"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "try    ( RestClient   restClient    =    RestClientTests . createRestClient (  )  )     {", "for    ( String   method    :    RestClientTestUtil . getHttpMethods (  )  )     {", "try    {", "restClient . performRequest ( method ,    null )  ;", "fail (  \" path   set   to   null   should   fail !  \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" path   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testNullPath"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "try    ( RestClient   restClient    =     . createRestClient (  )  )     {", "ResponseListener   listener    =    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "fail (  \" should   have   failed   because   of   null   headers \"  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "assertThat ( exception ,    instanceOf ( NullPointerException . class )  )  ;", "assertEquals (  \" request   header   must   not   be   null \"  ,    exception . getMessage (  )  )  ;", "latch . countDown (  )  ;", "}", "}  ;", "restClient . performRequestAsync (  \" GET \"  ,    randomAsciiLettersOfLength (  5  )  ,    listener ,     (  ( Header )     ( null )  )  )  ;", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformAsyncWithNullHeaders"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "try    ( RestClient   restClient    =     . createRestClient (  )  )     {", "restClient . performRequestAsync ( randomAsciiLettersOfLength (  5  )  ,    randomAsciiLettersOfLength (  5  )  ,    null ,    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "fail (  \" should   have   failed   because   of   null   parameters \"  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "assertThat ( exception ,    instanceOf ( NullPointerException . class )  )  ;", "assertEquals (  \" params   must   not   be   null \"  ,    exception . getMessage (  )  )  ;", "latch . countDown (  )  ;", "}", "}  )  ;", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformAsyncWithNullParams"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "try    ( RestClient   restClient    =     . createRestClient (  )  )     {", "restClient . performRequestAsync (  \" unsupported \"  ,    randomAsciiLettersOfLength (  5  )  ,    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "fail (  \" should   have   failed   because   of   unsupported   method \"  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "assertThat ( exception ,    instanceOf ( UnsupportedOperationException . class )  )  ;", "assertEquals (  \" http   method   not   supported :    unsupported \"  ,    exception . getMessage (  )  )  ;", "latch . countDown (  )  ;", "}", "}  )  ;", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformAsyncWithUnsupportedMethod"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "try    ( RestClient   restClient    =     . createRestClient (  )  )     {", "restClient . performRequestAsync (  \" GET \"  ,     \"  :  : http :  /  /  /  \"  ,    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "fail (  \" should   have   failed   because   of   wrong   endpoint \"  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "assertThat ( exception ,    instanceOf ( IllegalArgumentException . class )  )  ;", "assertEquals (  \" Expected   scheme   name   at   index    0  :     :  : http :  /  /  /  \"  ,    exception . getMessage (  )  )  ;", "latch . countDown (  )  ;", "}", "}  )  ;", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformAsyncWithWrongEndpoint"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "try    ( RestClient   restClient    =    RestClientTests . createRestClient (  )  )     {", "restClient . setHosts (  (  ( HttpHost [  ]  )     ( null )  )  )  ;", "fail (  \" setHosts   should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" hosts   must   not   be   null   nor   empty \"  ,    e . getMessage (  )  )  ;", "}", "try    ( RestClient   restClient    =    RestClientTests . createRestClient (  )  )     {", "restClient . setHosts (  )  ;", "fail (  \" setHosts   should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" hosts   must   not   be   null   nor   empty \"  ,    e . getMessage (  )  )  ;", "}", "try    ( RestClient   restClient    =    RestClientTests . createRestClient (  )  )     {", "restClient . setHosts (  (  ( HttpHost )     ( null )  )  )  ;", "fail (  \" setHosts   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" host   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    ( RestClient   restClient    =    RestClientTests . createRestClient (  )  )     {", "restClient . setHosts ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    null ,    new   HttpHost (  \" localhost \"  ,     9  2  0  1  )  )  ;", "fail (  \" setHosts   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" host   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSetHostsWrongArguments"], "fileName": "org.elasticsearch.client.RestClientTests"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( bulkRequest ,    Request :  : bulk ,    BulkResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["bulk"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( bulkRequest ,    Request :  : bulk ,    BulkResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["bulkAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( clearScrollRequest ,    Request :  : clearScroll ,    ClearScrollResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["clearScroll"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( clearScrollRequest ,    Request :  : clearScroll ,    ClearScrollResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["clearScrollAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   clusterClient ;", "}", "METHOD_END"], "methodName": ["cluster"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return    ( response . getStatusLine (  )  . getStatusCode (  )  )     =  =     2  0  0  ;", "}", "METHOD_END"], "methodName": ["convertExistsResponse"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( deleteRequest ,    Request :  : delete ,    DeleteResponse :  : fromXContent ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( deleteRequest ,    Request :  : delete ,    DeleteResponse :  : fromXContent ,    listener ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["deleteAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( getRequest ,    Request :  : exists ,    RestHighLevelClient :  : convertExistsResponse ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["exists"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsync ( getRequest ,    Request :  : exists ,    RestHighLevelClient :  : convertExistsResponse ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["existsAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( getRequest ,    Request :  : get ,    GetResponse :  : fromXContent ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["get"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( getRequest ,    Request :  : get ,    GetResponse :  : fromXContent ,    listener ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["getAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    ContextParser < Object ,     ?    extends   Aggregation >  >    map    =    new   HashMap <  >  (  )  ;", "map . put ( NAME ,     (    p ,    c )     -  >    ParsedCardinality . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalHDRPercentiles . NAME ,     (    p ,    c )     -  >    ParsedHDRPercentiles . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalHDRPercentileRanks . NAME ,     (    p ,    c )     -  >    ParsedHDRPercentileRanks . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalTDigestPercentiles . NAME ,     (    p ,    c )     -  >    ParsedTDigestPercentiles . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalTDigestPercentileRanks . NAME ,     (    p ,    c )     -  >    ParsedTDigestPercentileRanks . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( PercentilesBucketPipelineAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedPercentilesBucket . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( MinAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedMin . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( MaxAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedMax . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( SumAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedSum . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( AvgAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedAvg . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( ValueCountAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedValueCount . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalSimpleValue . NAME ,     (    p ,    c )     -  >    ParsedSimpleValue . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( DerivativePipelineAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedDerivative . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( InternalBucketMetricValue . NAME ,     (    p ,    c )     -  >    ParsedBucketMetricValue . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( StatsAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedStats . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( StatsBucketPipelineAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedStatsBucket . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( ExtendedStatsAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedExtendedStats . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( ExtendedStatsBucketPipelineAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedExtendedStatsBucket . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( GeoBoundsAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedGeoBounds . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( GeoCentroidAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedGeoCentroid . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( HistogramAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedHistogram . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( DateHistogramAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedDateHistogram . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( StringTerms . NAME ,     (    p ,    c )     -  >    ParsedStringTerms . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( LongTerms . NAME ,     (    p ,    c )     -  >    ParsedLongTerms . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( DoubleTerms . NAME ,     (    p ,    c )     -  >    ParsedDoubleTerms . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( MissingAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedMissing . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( NestedAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedNested . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( ReverseNestedAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedReverseNested . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( GlobalAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedGlobal . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( FilterAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedFilter . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( PARSER _ NAME ,     (    p ,    c )     -  >    ParsedSampler . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( GeoGridAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedGeoHashGrid . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( RangeAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedRange . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( DateRangeAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedDateRange . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( GeoDistanceAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedGeoDistance . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( FiltersAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedFilters . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( AdjacencyMatrixAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedAdjacencyMatrix . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( SignificantLongTerms . NAME ,     (    p ,    c )     -  >    ParsedSignificantLongTerms . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( SignificantStringTerms . NAME ,     (    p ,    c )     -  >    ParsedSignificantStringTerms . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( ScriptedMetricAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedScriptedMetric . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( IpRangeAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedBinaryRange . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( TopHitsAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedTopHits . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "map . put ( CompositeAggregationBuilder . NAME ,     (    p ,    c )     -  >    ParsedComposite . fromXContent ( p ,     (  ( String )     ( c )  )  )  )  ;", "List < NamedXContentRegistry . Entry >    entries    =    map . entrySet (  )  . stream (  )  . map (  (    entry )     -  >    new   NamedXContentRegistry . Entry (  . class ,    new   ommon . ParseField ( entry . getKey (  )  )  ,    entry . getValue (  )  )  )  . collect ( Collectors . toList (  )  )  ;", "entries . add ( new   NamedXContentRegistry . Entry ( Suggestion . class ,    new   ommon . ParseField ( TermSuggestion . NAME )  ,     (    parser ,    context )     -  >    TermSuggestion . fromXContent ( parser ,     (  ( String )     ( context )  )  )  )  )  ;", "entries . add ( new   NamedXContentRegistry . Entry ( Suggestion . class ,    new   ommon . ParseField ( PhraseSuggestion . NAME )  ,     (    parser ,    context )     -  >    PhraseSuggestion . fromXContent ( parser ,     (  ( String )     ( context )  )  )  )  )  ;", "entries . add ( new   NamedXContentRegistry . Entry ( Suggestion . class ,    new   ommon . ParseField ( CompletionSuggestion . NAME )  ,     (    parser ,    context )     -  >    CompletionSuggestion . fromXContent ( parser ,     (  ( String )     ( context )  )  )  )  )  ;", "return   entries ;", "}", "METHOD_END"], "methodName": ["getDefaultNamedXContents"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   client ;", "}", "METHOD_END"], "methodName": ["getLowLevelClient"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "List < NamedXContentRegistry . Entry >    entries    =    new   ArrayList <  >  (  )  ;", "for    ( NamedXContentProvider   service    :    ServiceLoader . load ( NamedXContentProvider . class )  )     {", "entries . addAll ( service . getNamedXContentParsers (  )  )  ;", "}", "return   entries ;", "}", "METHOD_END"], "methodName": ["getProvidedNamedXContents"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( indexRequest ,    Request :  : index ,    IndexResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["index"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( indexRequest ,    Request :  : index ,    IndexResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["indexAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   indicesClient ;", "}", "METHOD_END"], "methodName": ["indices"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( new   MainRequest (  )  ,     (    request )     -  >    Request . info (  )  ,    MainResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["info"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( multiGetRequest ,    Request :  : multiGet ,    MultiGetResponse :  : fromXContent ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["multiGet"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( multiGetRequest ,    Request :  : multiGet ,    MultiGetResponse :  : fromXContent ,    listener ,    Collections . singleton (  4  0  4  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["multiGetAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( multiSearchRequest ,    Request :  : multiSearch ,    MultiSearchResponse :  : fromXContext ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["multiSearch"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( searchRequest ,    Request :  : multiSearch ,    MultiSearchResponse :  : fromXContext ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["multiSearchAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "if    ( entity    =  =    null )     {", "throw   new   IllegalStateException (  \" Response   body   expected   but   not   returned \"  )  ;", "}", "if    (  ( entity . getContentType (  )  )     =  =    null )     {", "throw   new   IllegalStateException (  \" E   didn ' t   return   the    [ Content - Type ]    header ,    unable   to   parse   response   body \"  )  ;", "}", "XContentType   xContentType    =    XContentType . fromMediaTypeOrFormat ( entity . getContentType (  )  . getValue (  )  )  ;", "if    ( xContentType    =  =    null )     {", "throw   new   IllegalStateException (  (  \" Unsupported   Content - Type :     \"     +     ( entity . getContentType (  )  . getValue (  )  )  )  )  ;", "}", "try    ( XContentParser   parser    =    xContentType . xContent (  )  . createParser ( registry ,    INSTANCE ,    entity . getContent (  )  )  )     {", "return   entityParser . apply ( parser )  ;", "}", "}", "METHOD_END"], "methodName": ["parseEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "Response   response    =    responseException . getResponse (  )  ;", "HttpEntity   entity    =    response . getEntity (  )  ;", "ElasticsearchStatusException   Exception ;", "if    ( entity    =  =    null )     {", "Exception    =    new   ElasticsearchStatusException ( responseException . getMessage (  )  ,    RestStatus . fromCode ( response . getStatusLine (  )  . getStatusCode (  )  )  ,    responseException )  ;", "} else    {", "try    {", "Exception    =    parseEntity ( entity ,    BytesRestResponse :  : errorFromXContent )  ;", "Exception . addSuppressed ( responseException )  ;", "}    catch    ( Exception   e )     {", "RestStatus   restStatus    =    RestStatus . fromCode ( response . getStatusLine (  )  . getStatusCode (  )  )  ;", "Exception    =    new   ElasticsearchStatusException (  \" Unable   to   parse   response   body \"  ,    restStatus ,    responseException )  ;", "Exception . addSuppressed ( e )  ;", "}", "}", "return   Exception ;", "}", "METHOD_END"], "methodName": ["parseResponseException"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "ActionRequestValidationException   validationException    =    request . validate (  )  ;", "if    ( validationException    !  =    null )     {", "throw   validationException ;", "}", "Request   req    =    requestConverter . apply ( request )  ;", "Response   response ;", "try    {", "response    =    performRequest ( req . getMethod (  )  ,    req . getEndpoint (  )  ,    req . getParameters (  )  ,    req . getEntity (  )  ,    headers )  ;", "}    catch    ( ResponseException   e )     {", "if    ( ignores . contains ( e . getResponse (  )  . getStatusLine (  )  . getStatusCode (  )  )  )     {", "try    {", "return   responseConverter . apply ( e . getResponse (  )  )  ;", "}    catch    ( Exception   innerException )     {", "throw   parseResponseException ( e )  ;", "}", "}", "throw   parseResponseException ( e )  ;", "}", "try    {", "return   responseConverter . apply ( response )  ;", "}    catch    ( Exception   e )     {", "throw   new   IOException (  (  \" Unable   to   parse   response   body   for    \"     +    response )  ,    e )  ;", "}", "}", "METHOD_END"], "methodName": ["performRequest"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( request ,    requestConverter ,     (    response )     -  >    parseEntity ( response . getEntity (  )  ,    entityParser )  ,    ignores ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAndParseEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "ActionRequestValidationException   validationException    =    request . validate (  )  ;", "if    ( validationException    !  =    null )     {", "listener . onFailure ( validationException )  ;", "return ;", "}", "Request   req ;", "try    {", "req    =    requestConverter . apply ( request )  ;", "}    catch    ( Exception   e )     {", "listener . onFailure ( e )  ;", "return ;", "}", "ResponseListener   responseListener    =    wrapResponseListener ( responseConverter ,    listener ,    ignores )  ;", "performRequestAsync ( req . getMethod (  )  ,    req . getEndpoint (  )  ,    req . getParameters (  )  ,    req . getEntity (  )  ,    responseListener ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsync ( request ,    requestConverter ,     (    response )     -  >    parseEntity ( response . getEntity (  )  ,    entityParser )  ,    listener ,    ignores ,    headers )  ;", "}", "METHOD_END"], "methodName": ["performRequestAsyncAndParseEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequest ( new   MainRequest (  )  ,     (    request )     -  >    Request . ping (  )  ,    RestHighLevelClient :  : convertExistsResponse ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["ping"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( rankEvalRequest ,    Request :  : rankEval ,    RankEvalResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["rankEval"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( rankEvalRequest ,    Request :  : rankEval ,    RankEvalResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["rankEvalAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( searchRequest ,    Request :  : search ,    SearchResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["search"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( searchRequest ,    Request :  : search ,    SearchResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["searchAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( searchScrollRequest ,    Request :  : searchScroll ,    SearchResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["searchScroll"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( searchScrollRequest ,    Request :  : searchScroll ,    SearchResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["searchScrollAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   performRequestAndParseEntity ( updateRequest ,    Request :  : update ,    UpdateResponse :  : fromXContent ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "performRequestAsyncAndParseEntity ( updateRequest ,    Request :  : update ,    UpdateResponse :  : fromXContent ,    listener ,    Collections . emptySet (  )  ,    headers )  ;", "}", "METHOD_END"], "methodName": ["updateAsync"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "return   new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "try    {", "actionListener . onResponse ( responseConverter . apply ( response )  )  ;", "}    catch    ( Exception   e )     {", "IOException   ioe    =    new   IOException (  (  \" Unable   to   parse   response   body   for    \"     +    response )  ,    e )  ;", "onFailure ( ioe )  ;", "}", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "if    ( exception   instanceof   ResponseException )     {", "ResponseException   responseException    =     (  ( ResponseException )     ( exception )  )  ;", "Response   response    =    responseException . getResponse (  )  ;", "if    ( ignores . contains ( response . getStatusLine (  )  . getStatusCode (  )  )  )     {", "try    {", "actionListener . onResponse ( responseConverter . apply ( response )  )  ;", "}    catch    ( Exception   innerException )     {", "actionListener . onFailure ( parseResponseException ( responseException )  )  ;", "}", "} else    {", "actionListener . onFailure ( parseResponseException ( responseException )  )  ;", "}", "} else    {", "actionListener . onFailure ( exception )  ;", "}", "}", "}  ;", "}", "METHOD_END"], "methodName": ["wrapResponseListener"], "fileName": "org.elasticsearch.client.RestHighLevelClient"}, {"methodBody": ["METHOD_START", "{", "RestClient   restClient    =    mock ( RestClient . class )  ;", "restHighLevelClient    =    new    . RestHighLevelClientExt ( restClient )  ;", "}", "METHOD_END"], "methodName": ["initClient"], "fileName": "org.elasticsearch.client.RestHighLevelClientExtTests"}, {"methodBody": ["METHOD_START", "{", "{", "HttpEntity   jsonEntity    =    new   StringEntity (  \"  {  \\  \" custom 1  \\  \"  :  {     \\  \" field \\  \"  :  \\  \" value \\  \"  }  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", ". BaseCustomResponseSection   customSection    =    restHighLevelClient . parseEntity ( jsonEntity ,     . BaseCustomResponseSection :  : fromXContent )  ;", "assertThat ( customSection ,    instanceOf (  . CustomResponseSection 1  . class )  )  ;", ". CustomResponseSection 1    customResponseSection 1     =     (  (  . CustomResponseSection 1  )     ( customSection )  )  ;", "assertEquals (  \" value \"  ,    customResponseSection 1  . value )  ;", "}", "{", "HttpEntity   jsonEntity    =    new   StringEntity (  \"  {  \\  \" custom 2  \\  \"  :  {     \\  \" array \\  \"  :     [  \\  \" item 1  \\  \"  ,     \\  \" item 2  \\  \"  ]  }  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", ". BaseCustomResponseSection   customSection    =    restHighLevelClient . parseEntity ( jsonEntity ,     . BaseCustomResponseSection :  : fromXContent )  ;", "assertThat ( customSection ,    instanceOf (  . CustomResponseSection 2  . class )  )  ;", ". CustomResponseSection 2    customResponseSection 2     =     (  (  . CustomResponseSection 2  )     ( customSection )  )  ;", "assertArrayEquals ( new   String [  ]  {     \" item 1  \"  ,     \" item 2  \"     }  ,    customResponseSection 2  . values )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseEntityCustomResponseSection"], "fileName": "org.elasticsearch.client.RestHighLevelClientExtTests"}, {"methodBody": ["METHOD_START", "{", "try    ( XContentBuilder   builder    =    xContentBuilder )     {", "builder . startObject (  )  ;", "builder . field (  \" field \"  ,     \" value \"  )  ;", "builder . endObject (  )  ;", "return   new   apache . http . entity . ByteArrayEntity ( BytesReference . bytes ( builder )  . toBytesRef (  )  . bytes ,    contentType )  ;", "}", "}", "METHOD_END"], "methodName": ["createBinaryEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "restClient    =    mock ( RestClient . class )  ;", "restHighLevelClient    =    new    ( restClient ,    RestClient :  : close ,    Collections . emptyList (  )  )  ;", "}", "METHOD_END"], "methodName": ["initClient"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Response   response    =    mock ( Response . class )  ;", "ContentType   contentType    =    ContentType . parse ( Request . REQUEST _ BODY _ CONTENT _ TYPE . mediaType (  )  )  ;", "String   requestBody    =    toXContent ( toXContent ,    Request . REQUEST _ BODY _ CONTENT _ TYPE ,    false )  . utf 8 ToString (  )  ;", "when ( response . getEntity (  )  )  . thenReturn ( new   NStringEntity ( requestBody ,    contentType )  )  ;", "when ( restCperformRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenReturn ( response )  ;", "}", "METHOD_END"], "methodName": ["mockResponse"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "return   new   BasicStatusLine ( RestHighLevelClientTests . HTTP _ PROTOCOL ,    restStatus . getStatus (  )  ,    restStatus . name (  )  )  ;", "}", "METHOD_END"], "methodName": ["newStatusLine"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "ClearScrollResponse   mockClearScrollResponse    =    new   ClearScrollResponse ( randomBoolean (  )  ,    randomIntBetween (  0  ,    Integer . MAX _ VALUE )  )  ;", "mockResponse ( mockClearScrollResponse )  ;", "ClearScrollRequest   clearScrollRequest    =    new   ClearScrollRequest (  )  ;", "clearScrollRequest . addScrollId ( randomAlphaOfLengthBetween (  5  ,     1  0  )  )  ;", "ClearScrollResponse   clearScrollResponse    =    restHighLevelClient . clearScroll ( clearScrollRequest ,    headers )  ;", "assertEquals ( mockClearScrollResponse . isSucceeded (  )  ,    clearScrollResponse . isSucceeded (  )  )  ;", "assertEquals ( mockClearScrollResponse . getNumFreed (  )  ,    clearScrollResponse . getNumFreed (  )  )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  _ search / scroll \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNotNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testClearScroll"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "restHighLevelClient . close (  )  ;", "verify ( restClient ,    times (  1  )  )  . close (  )  ;", "restHighLevelClient . close (  )  ;", "verify ( restClient ,    times (  2  )  )  . close (  )  ;", "restHighLevelClient . close (  )  ;", "verify ( restClient ,    times (  3  )  )  . close (  )  ;", "}", "METHOD_END"], "methodName": ["testCloseIsIdempotent"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestStatus   restStatus    =     ( randomBoolean (  )  )     ?    RestStatus . OK    :    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "Response   response    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "boolean   result    =    RestHighLevelClient . convertExistsResponse ( response )  ;", "assertEquals (  ( restStatus    =  =     ( RestStatus . OK )  )  ,    result )  ;", "}", "METHOD_END"], "methodName": ["testConvertExistsResponse"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "List < NamedXContentRegistry . Entry >    namedXContents    =    RestHighLevelClient . getDefaultNamedXContents (  )  ;", "int   expectedInternalAggregations    =    InternalAggregationTestCase . getDefaultNamedXContents (  )  . size (  )  ;", "int   expectedSuggestions    =     3  ;", "assertEquals (  ( expectedInternalAggregations    +    expectedSuggestions )  ,    namedXContents . size (  )  )  ;", "Map < Class <  ?  >  ,    Integer >    categories    =    new   HashMap <  >  (  )  ;", "for    ( NamedXContentRegistry . Entry   namedXContent    :    namedXContents )     {", "Integer   counter    =    categories . putIfAbsent ( namedXContent . categoryClass ,     1  )  ;", "if    ( counter    !  =    null )     {", "categories . put ( namedXContent . categoryClass ,     ( counter    +     1  )  )  ;", "}", "}", "assertEquals (  2  ,    categories . size (  )  )  ;", "assertEquals ( expectedInternalAggregations ,    categories . get ( Aggregation . class )  . intValue (  )  )  ;", "assertEquals ( expectedSuggestions ,    categories . get ( Suggestion . class )  . intValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDefaultNamedXContents"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "MainResponse   testInfo    =    new   MainResponse (  \" nodeName \"  ,    Version . CURRENT ,    new   ClusterName (  \" clusterName \"  )  ,     \" clusterUuid \"  ,    Build . CURRENT )  ;", "mockResponse ( testInfo )  ;", "MainResponse   receivedInfo    =    restHighLevelClient . info ( headers )  ;", "assertEquals ( testInfo ,    receivedInfo )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testInfo"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "{", "IllegalStateException   ise    =    expectThrows ( IllegalStateException . class ,     (  )     -  >    restHighLevelClient . parseEntity ( null ,    null )  )  ;", "assertEquals (  \" Response   body   expected   but   not   returned \"  ,    ise . getMessage (  )  )  ;", "}", "{", "IllegalStateException   ise    =    expectThrows ( IllegalStateException . class ,     (  )     -  >    restHighLevelClient . parseEntity ( new   StringEntity (  \"  \"  ,     (  ( ContentType )     ( null )  )  )  ,    null )  )  ;", "assertEquals (  \" Elasticsearch   didn ' t   return   the    [ Content - Type ]    header ,    unable   to   parse   response   body \"  ,    ise . getMessage (  )  )  ;", "}", "{", "StringEntity   entity    =    new   StringEntity (  \"  \"  ,    ContentType . APPLICATION _ SVG _ XML )  ;", "IllegalStateException   ise    =    expectThrows ( IllegalStateException . class ,     (  )     -  >    restHighLevelClient . parseEntity ( entity ,    null )  )  ;", "assertEquals (  (  \" Unsupported   Content - Type :     \"     +     ( entity . getContentType (  )  . getValue (  )  )  )  ,    ise . getMessage (  )  )  ;", "}", "{", "CheckedFunction < XContentParser ,    String ,    IOException >    entityParser    =     (    parser )     -  >     {", "assertEquals ( XContentParser . Token . START _ OBJECT ,    parser . nextToken (  )  )  ;", "assertEquals ( XContentParser . Token . FIELD _ NAME ,    parser . nextToken (  )  )  ;", "assertTrue ( parser . nextToken (  )  . isValue (  )  )  ;", "String   value    =    parser . text (  )  ;", "assertEquals ( XContentParser . Token . END _ OBJECT ,    parser . nextToken (  )  )  ;", "return   value ;", "}  ;", "HttpEntity   jsonEntity    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "assertEquals (  \" value \"  ,    restHighLevelClient . parseEntity ( jsonEntity ,    entityParser )  )  ;", "HttpEntity   yamlEntity    =    new   StringEntity (  \"  -  -  -  \\ nfield :    value \\ n \"  ,    ContentType . create (  \" application / yaml \"  )  )  ;", "assertEquals (  \" value \"  ,    restHighLevelClient . parseEntity ( yamlEntity ,    entityParser )  )  ;", "HttpEntity   smileEntity    =     . createBinaryEntity ( SmileXContent . contentBuilder (  )  ,    ContentType . create (  \" application / smile \"  )  )  ;", "assertEquals (  \" value \"  ,    restHighLevelClient . parseEntity ( smileEntity ,    entityParser )  )  ;", "HttpEntity   cborEntity    =     . createBinaryEntity ( CborXContent . contentBuilder (  )  ,    ContentType . create (  \" application / cbor \"  )  )  ;", "assertEquals (  \" value \"  ,    restHighLevelClient . parseEntity ( cborEntity ,    entityParser )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "{", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "Response   response    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "ElasticsearchException   elasticsearchException    =    restHighLevelClient . parseResponseException ( responseException )  ;", "assertEquals ( responseException . getMessage (  )  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "}", "{", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" error \\  \"  :  \\  \" test   error   message \\  \"  ,  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "ElasticsearchException   elasticsearchException    =    restHighLevelClient . parseResponseException ( responseException )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = exception ,    reason = test   error   message ]  \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getSuppressed (  )  [  0  ]  )  ;", "}", "{", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  \"  {  \\  \" error \\  \"  :  \"  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "ElasticsearchException   elasticsearchException    =    restHighLevelClient . parseResponseException ( responseException )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( IOException . class )  )  ;", "}", "{", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "ElasticsearchException   elasticsearchException    =    restHighLevelClient . parseResponseException ( responseException )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( IllegalStateException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testParseResponseException"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  \"  {  \\  \" error \\  \"  :  \"  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . emptySet (  )  )  )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( JsonParseException . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithBrokenEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . emptySet (  )  )  )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( IllegalStateException . class )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithBrokenEntity2"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" error \\  \"  :  \\  \" test   error   message \\  \"  ,  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . emptySet (  )  )  )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = exception ,    reason = test   error   message ]  \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getSuppressed (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( NOT _ FOUND )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "assertEquals ( Integer . valueOf (  4  0  4  )  ,    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . singleton (  4  0  4  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithIgnores"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( NOT _ FOUND )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    Collections . singleton (  4  0  4  )  )  )  ;", "assertEquals ( NOT _ FOUND ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertEquals ( responseException . getMessage (  )  ,    elasticsearchException . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithIgnoresErrorNoBody"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( NOT _ FOUND )  )  ;", "httpResponse . setEntity ( new   StringEntity (  \"  {  \\  \" error \\  \"  :  \\  \" test   error   message \\  \"  ,  \\  \" status \\  \"  :  4  0  4  }  \"  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    Collections . singleton (  4  0  4  )  )  )  ;", "assertEquals ( NOT _ FOUND ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getSuppressed (  )  [  0  ]  )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = exception ,    reason = test   error   message ]  \"  ,    elasticsearchException . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithIgnoresErrorValidBody"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( mockResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( responseException )  ;", "ElasticsearchException   elasticsearchException    =    expectThrows ( ElasticsearchException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . emptySet (  )  )  )  ;", "assertEquals ( responseException . getMessage (  )  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["testPerformRequestOnResponseExceptionWithoutEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "MainRequest   mainRequest    =    new   MainRequest (  )  ;", "CheckedFunction < MainRequest ,    Request ,    IOException >    requestConverter    =     (    request )     -  >    new   Request ( HttpGet . METHOD _ NAME ,     \"  /  \"  ,    Collections . emptyMap (  )  ,    null )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse (  . newStatusLine ( restStatus )  )  ;", "Response   mockResponse    =    new   Response (  . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenReturn ( mockResponse )  ;", "{", "Integer   result    =    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    Collections . emptySet (  )  )  ;", "assertEquals ( restStatus . getStatus (  )  ,    result . intValue (  )  )  ;", "}", "{", "IOException   ioe    =    expectThrows ( IOException . class ,     (  )     -  >    restHighLevelClient . performRequest ( mainRequest ,    requestConverter ,     (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    Collections . emptySet (  )  )  )  ;", "assertEquals (  (  (  (  (  (  \" Unable   to   parse   response   body   for   Response { requestLine = GET    /    http /  1  .  1  ,    host = http :  /  / localhost :  9  2  0  0  ,     \"     +     \" response = http /  1  .  1     \"  )     +     ( restStatus . getStatus (  )  )  )     +     \"     \"  )     +     ( restStatus . name (  )  )  )     +     \"  }  \"  )  ,    ioe . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPerformRequestOnSuccess"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "Response   response    =    mock ( Response . class )  ;", "when ( response . getStatusLine (  )  )  . thenReturn (  . newStatusLine ( NOT _ FOUND )  )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenReturn ( response )  ;", "assertFalse ( restHighLevelClient . ping ( headers )  )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPing404NotFound"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenThrow ( new   SocketTimeoutException (  )  )  ;", "expectThrows ( SocketTimeoutException . class ,     (  )     -  >    restHighLevelClient . ping ( headers )  )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPingSocketTimeout"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "Response   response    =    mock ( Response . class )  ;", "when ( response . getStatusLine (  )  )  . thenReturn (  . newStatusLine ( OK )  )  ;", "when ( restClient . performRequest ( anyString (  )  ,    anyString (  )  ,    anyMapOf ( String . class ,    String . class )  ,    anyObject (  )  ,    anyVararg (  )  )  )  . thenReturn ( response )  ;", "assertTrue ( restHighLevelClient . ping ( headers )  )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testPingSuccessful"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "List < NamedXContentRegistry . Entry >    namedXContents    =    RestHighLevelClient . getProvidedNamedXContents (  )  ;", "assertEquals (  7  ,    namedXContents . size (  )  )  ;", "Map < Class <  ?  >  ,    Integer >    categories    =    new   HashMap <  >  (  )  ;", "List < String >    names    =    new   ArrayList <  >  (  )  ;", "for    ( NamedXContentRegistry . Entry   namedXContent    :    namedXContents )     {", "names . add ( namedXContent . name . getPreferredName (  )  )  ;", "Integer   counter    =    categories . putIfAbsent ( namedXContent . categoryClass ,     1  )  ;", "if    ( counter    !  =    null )     {", "categories . put ( namedXContent . categoryClass ,     ( counter    +     1  )  )  ;", "}", "}", "assertEquals (  3  ,    categories . size (  )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    categories . get ( Aggregation . class )  )  ;", "assertTrue ( names . contains ( NAME )  )  ;", "assertTrue ( names . contains ( MatrixStatsAggregationBuilder . NAME )  )  ;", "assertEquals ( Integer . valueOf (  3  )  ,    categories . get ( EvaluationMetric . class )  )  ;", "assertTrue ( names . contains ( PrecisionAtK . NAME )  )  ;", "assertTrue ( names . contains ( DiscountedCumulativeGain . NAME )  )  ;", "assertTrue ( names . contains ( MeanReciprocalRank . NAME )  )  ;", "assertEquals ( Integer . valueOf (  2  )  ,    categories . get ( MetricDetail . class )  )  ;", "assertTrue ( names . contains ( PrecisionAtK . NAME )  )  ;", "assertTrue ( names . contains ( MeanReciprocalRank . NAME )  )  ;", "}", "METHOD_END"], "methodName": ["testProvidedNamedXContents"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "ActionRequestValidationException   validationException    =    new   ActionRequestValidationException (  )  ;", "validationException . addValidationError (  \" validation   error \"  )  ;", "ActionRequest   request    =    new   ActionRequest (  )     {", "@ Override", "public   ActionRequestValidationException   validate (  )     {", "return   validationException ;", "}", "}  ;", "{", "ActionRequestValidationException   actualException    =    expectThrows ( ActionRequestValidationException . class ,     (  )     -  >    restHighLevelClient . performRequest ( request ,    null ,    null ,    null )  )  ;", "assertSame ( validationException ,    actualException )  ;", "}", "{", ". TrackingActionListener   trackingActionListener    =    new    . TrackingActionListener (  )  ;", "restHighLevelClient . performRequestAsync ( request ,    null ,    null ,    trackingActionListener ,    null )  ;", "assertSame ( validationException ,    trackingActionListener . exception . get (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequestValidation"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "Header [  ]    headers    =    RestClientTestUtil . randomHeaders ( random (  )  ,     \" Header \"  )  ;", "SearchResponse   mockSearchResponse    =    new   SearchResponse ( new   SearchResponseSections ( SearchHits . empty (  )  ,    InternalAggregations . EMPTY ,    null ,    false ,    false ,    null ,     1  )  ,    randomAlphaOfLengthBetween (  5  ,     1  0  )  ,     5  ,     5  ,     0  ,     1  0  0  ,    ShardSearchFailure . EMPTY _ ARRAY ,    Clusters . EMPTY )  ;", "mockResponse ( mockSearchResponse )  ;", "SearchResponse   searchResponse    =    restHighLevelClient . searchScroll ( new   SearchScrollRequest ( randomAlphaOfLengthBetween (  5  ,     1  0  )  )  ,    headers )  ;", "assertEquals ( mockSearchResponse . getScrollId (  )  ,    searchResponse . getScrollId (  )  )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  5  ,    searchResponse . getTotalShards (  )  )  ;", "assertEquals (  5  ,    searchResponse . getSuccessfulShards (  )  )  ;", "assertEquals (  1  0  0  ,    searchResponse . getTook (  )  . getMillis (  )  )  ;", "verify ( restClient )  . performRequest ( eq ( METHOD _ NAME )  ,    eq (  \"  /  _ search / scroll \"  )  ,    eq ( Collections . emptyMap (  )  )  ,    isNotNull ( HttpEntity . class )  ,    argThat ( new    . HeadersVarargMatcher ( headers )  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchScroll"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "IllegalStateException   exception    =    new   IllegalStateException (  )  ;", "responseListener . onFailure ( exception )  ;", "assertSame ( exception ,    trackingActionListener . exception . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnException"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  \"  {  \\  \" error \\  \"  :  \"  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( JsonParseException . class )  )  ;", "}", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals (  \" Unable   to   parse   response   body \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertThat ( elasticsearchException . getSuppressed (  )  [  0  ]  ,    instanceOf ( IllegalStateException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithBrokenEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "httpResponse . setEntity ( new   StringEntity (  (  (  \"  {  \\  \" error \\  \"  :  \\  \" test   error   message \\  \"  ,  \\  \" status \\  \"  :  \"     +     ( restStatus . getStatus (  )  )  )     +     \"  }  \"  )  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = exception ,    reason = test   error   message ]  \"  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getSuppressed (  )  [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . singleton (  4  0  4  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( NOT _ FOUND )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertNull ( trackingActionListener . exception . get (  )  )  ;", "assertEquals (  4  0  4  ,    trackingActionListener . statusCode . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithIgnores"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    trackingActionListener ,    Collections . singleton (  4  0  4  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( NOT _ FOUND )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals ( NOT _ FOUND ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "assertEquals ( responseException . getMessage (  )  ,    elasticsearchException . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithIgnoresErrorNoBody"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    trackingActionListener ,    Collections . singleton (  4  0  4  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( NOT _ FOUND )  )  ;", "httpResponse . setEntity ( new   StringEntity (  \"  {  \\  \" error \\  \"  :  \\  \" test   error   message \\  \"  ,  \\  \" status \\  \"  :  4  0  4  }  \"  ,    ContentType . APPLICATION _ JSON )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals ( NOT _ FOUND ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getSuppressed (  )  [  0  ]  )  ;", "assertEquals (  \" Elasticsearch   exception    [ type = exception ,    reason = test   error   message ]  \"  ,    elasticsearchException . getMessage (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithIgnoresErrorValidBody"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "Response   response    =    new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  ;", "ResponseException   responseException    =    new   ResponseException ( response )  ;", "responseListener . onFailure ( responseException )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( ElasticsearchException . class )  )  ;", "ElasticsearchException   elasticsearchException    =     (  ( ElasticsearchException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals ( responseException . getMessage (  )  ,    elasticsearchException . getMessage (  )  )  ;", "assertEquals ( restStatus ,    elasticsearchException . status (  )  )  ;", "assertSame ( responseException ,    elasticsearchException . getCause (  )  )  ;", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnResponseExceptionWithoutEntity"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >    response . getStatusLine (  )  . getStatusCode (  )  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "responseListener . onSuccess ( new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  )  ;", "assertNull ( trackingActionListener . exception . get (  )  )  ;", "assertEquals ( restStatus . getStatus (  )  ,    trackingActionListener . statusCode . get (  )  )  ;", "}", "{", "RestHighLevelClientTests . TrackingActionListener   trackingActionListener    =    new   RestHighLevelClientTests . TrackingActionListener (  )  ;", "ResponseListener   responseListener    =    restHighLevelClient . wrapResponseListener (  (    response )     -  >     {", "throw   new   IllegalStateException (  )  ;", "}  ,    trackingActionListener ,    Collections . emptySet (  )  )  ;", "RestStatus   restStatus    =    randomFrom ( RestStatus . values (  )  )  ;", "HttpResponse   httpResponse    =    new   BasicHttpResponse ( RestHighLevelClientTests . newStatusLine ( restStatus )  )  ;", "responseListener . onSuccess ( new   Response ( RestHighLevelClientTests . REQUEST _ LINE ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    httpResponse )  )  ;", "assertThat ( trackingActionListener . exception . get (  )  ,    instanceOf ( IOException . class )  )  ;", "IOException   ioe    =     (  ( IOException )     ( trackingActionListener . exception . get (  )  )  )  ;", "assertEquals (  (  (  (  (  (  \" Unable   to   parse   response   body   for   Response { requestLine = GET    /    http /  1  .  1  ,    host = http :  /  / localhost :  9  2  0  0  ,     \"     +     \" response = http /  1  .  1     \"  )     +     ( restStatus . getStatus (  )  )  )     +     \"     \"  )     +     ( restStatus . name (  )  )  )     +     \"  }  \"  )  ,    ioe . getMessage (  )  )  ;", "assertThat ( ioe . getCause (  )  ,    instanceOf ( IllegalStateException . class )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testWrapResponseListenerOnSuccess"], "fileName": "org.elasticsearch.client.RestHighLevelClientTests"}, {"methodBody": ["METHOD_START", "{", "assertThat ( searchResponse . getTook (  )  . nanos (  )  ,    greaterThanOrEqualTo (  0 L )  )  ;", "assertEquals (  0  ,    searchResponse . getFailedShards (  )  )  ;", "assertThat ( searchResponse . getTotalShards (  )  ,    greaterThan (  0  )  )  ;", "assertEquals ( searchResponse . getTotalShards (  )  ,    searchResponse . getSuccessfulShards (  )  )  ;", "assertEquals (  0  ,    searchResponse . getShardFailures (  )  . length )  ;", "assertEquals ( EMPTY ,    searchResponse . getClusters (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertSearchHeader"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "StringEntity   doc 1     =    new   StringEntity (  \"  {  \\  \" type \\  \"  :  \\  \" type 1  \\  \"  ,     \\  \" num \\  \"  :  1  0  ,     \\  \" num 2  \\  \"  :  5  0  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index / type /  1  \"  ,    Collections . emptyMap (  )  ,    doc 1  )  ;", "StringEntity   doc 2     =    new   StringEntity (  \"  {  \\  \" type \\  \"  :  \\  \" type 1  \\  \"  ,     \\  \" num \\  \"  :  2  0  ,     \\  \" num 2  \\  \"  :  4  0  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index / type /  2  \"  ,    Collections . emptyMap (  )  ,    doc 2  )  ;", "StringEntity   doc 3     =    new   StringEntity (  \"  {  \\  \" type \\  \"  :  \\  \" type 1  \\  \"  ,     \\  \" num \\  \"  :  5  0  ,     \\  \" num 2  \\  \"  :  3  5  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index / type /  3  \"  ,    Collections . emptyMap (  )  ,    doc 3  )  ;", "StringEntity   doc 4     =    new   StringEntity (  \"  {  \\  \" type \\  \"  :  \\  \" type 2  \\  \"  ,     \\  \" num \\  \"  :  1  0  0  ,     \\  \" num 2  \\  \"  :  1  0  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index / type /  4  \"  ,    Collections . emptyMap (  )  ,    doc 4  )  ;", "StringEntity   doc 5     =    new   StringEntity (  \"  {  \\  \" type \\  \"  :  \\  \" type 2  \\  \"  ,     \\  \" num \\  \"  :  1  0  0  ,     \\  \" num 2  \\  \"  :  1  0  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index / type /  5  \"  ,    Collections . emptyMap (  )  ,    doc 5  )  ;", "(  )  . performRequest ( HttpPost . METHOD _ NAME ,     \"  / index /  _ refresh \"  )  ;", "StringEntity   doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 1  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 1  / doc /  1  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 2  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 1  / doc /  2  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 1  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 2  / doc /  3  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 2  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 2  / doc /  4  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 1  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 3  / doc /  5  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "doc    =    new   StringEntity (  \"  {  \\  \" field \\  \"  :  \\  \" value 2  \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest ( METHOD _ NAME ,     \"  / index 3  / doc /  6  \"  ,    Collections . emptyMap (  )  ,    doc )  ;", "(  )  . performRequest ( HttpPost . METHOD _ NAME ,     \"  / index 1  , index 2  , index 3  /  _ refresh \"  )  ;", "}", "METHOD_END"], "methodName": ["indexDocuments"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "MultiSearchRequest   multiSearchRequest    =    new   MultiSearchRequest (  )  ;", "SearchRequest   searchRequest 1     =    new   SearchRequest (  \" index 1  \"  )  ;", "searchRequest 1  . source (  )  . sort (  \"  _ id \"  ,    ASC )  ;", "multiSearchRequest . add ( searchRequest 1  )  ;", "SearchRequest   searchRequest 2     =    new   SearchRequest (  \" index 2  \"  )  ;", "searchRequest 2  . source (  )  . sort (  \"  _ id \"  ,    ASC )  ;", "multiSearchRequest . add ( searchRequest 2  )  ;", "SearchRequest   searchRequest 3     =    new   SearchRequest (  \" index 3  \"  )  ;", "searchRequest 3  . source (  )  . sort (  \"  _ id \"  ,    ASC )  ;", "multiSearchRequest . add ( searchRequest 3  )  ;", "MultiSearchResponse   multiSearchResponse    =    ESRestHighLevelClientTestCase . execute ( multiSearchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearch ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearchAsync )  ;", "assertThat ( multiSearchResponse . getTook (  )  . millis (  )  ,    Matchers . greaterThanOrEqualTo (  0 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  . length ,    Matchers . equalTo (  3  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  1  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getAt (  1  )  . getId (  )  ,    Matchers . equalTo (  \"  2  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  3  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getAt (  1  )  . getId (  )  ,    Matchers . equalTo (  \"  4  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  5  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getAt (  1  )  . getId (  )  ,    Matchers . equalTo (  \"  6  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiSearch"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "MultiSearchRequest   multiSearchRequest    =    new   MultiSearchRequest (  )  ;", "SearchRequest   searchRequest 1     =    new   SearchRequest (  \" index 1  \"  )  ;", "searchRequest 1  . source (  )  . query ( new   ScriptQueryBuilder ( new   script . Script ( ScriptType . INLINE ,     \" invalid \"  ,     \" code \"  ,    Collections . emptyMap (  )  )  )  )  ;", "multiSearchRequest . add ( searchRequest 1  )  ;", "SearchRequest   searchRequest 2     =    new   SearchRequest (  \" index 2  \"  )  ;", "searchRequest 2  . source (  )  . query ( new   ScriptQueryBuilder ( new   script . Script ( ScriptType . INLINE ,     \" invalid \"  ,     \" code \"  ,    Collections . emptyMap (  )  )  )  )  ;", "multiSearchRequest . add ( searchRequest 2  )  ;", "MultiSearchResponse   multiSearchResponse    =    ESRestHighLevelClientTestCase . execute ( multiSearchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearch ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearchAsync )  ;", "assertThat ( multiSearchResponse . getTook (  )  . millis (  )  ,    Matchers . greaterThanOrEqualTo (  0 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  . length ,    Matchers . equalTo (  2  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . isFailure (  )  ,    Matchers . is ( true )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getFailure (  )  . getMessage (  )  ,    containsString (  \" search _ phase _ execution _ exception \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  ,    nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . isFailure (  )  ,    Matchers . is ( true )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getFailure (  )  . getMessage (  )  ,    containsString (  \" search _ phase _ execution _ exception \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  ,    nullValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiSearch_failure"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "MultiSearchRequest   multiSearchRequest    =    new   MultiSearchRequest (  )  ;", "SearchRequest   searchRequest 1     =    new   SearchRequest (  \" index 1  \"  )  ;", "searchRequest 1  . source (  )  . size (  0  )  . aggregation ( new   search . aggregations . bucket . terms . TermsAggregationBuilder (  \" name \"  ,    ValueType . STRING )  . field (  \" field . keyword \"  )  . order ( BucketOrder . key ( true )  )  )  ;", "multiSearchRequest . add ( searchRequest 1  )  ;", "SearchRequest   searchRequest 2     =    new   SearchRequest (  \" index 2  \"  )  ;", "searchRequest 2  . source (  )  . size (  0  )  . aggregation ( new   search . aggregations . bucket . terms . TermsAggregationBuilder (  \" name \"  ,    ValueType . STRING )  . field (  \" field . keyword \"  )  . order ( BucketOrder . key ( true )  )  )  ;", "multiSearchRequest . add ( searchRequest 2  )  ;", "SearchRequest   searchRequest 3     =    new   SearchRequest (  \" index 3  \"  )  ;", "searchRequest 3  . source (  )  . size (  0  )  . aggregation ( new   search . aggregations . bucket . terms . TermsAggregationBuilder (  \" name \"  ,    ValueType . STRING )  . field (  \" field . keyword \"  )  . order ( BucketOrder . key ( true )  )  )  ;", "multiSearchRequest . add ( searchRequest 3  )  ;", "MultiSearchResponse   multiSearchResponse    =    ESRestHighLevelClientTestCase . execute ( multiSearchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearch ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearchAsync )  ;", "assertThat ( multiSearchResponse . getTook (  )  . millis (  )  ,    Matchers . greaterThanOrEqualTo (  0 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  . length ,    Matchers . equalTo (  3  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", "SearchIT . assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getHits (  )  . length ,    Matchers . equalTo (  0  )  )  ;", "Terms   terms    =    multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getAggregations (  )  . get (  \" name \"  )  ;", "assertThat ( terms . getBuckets (  )  . size (  )  ,    Matchers . equalTo (  2  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  0  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 1  \"  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  1  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 2  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", "SearchIT . assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getHits (  )  . length ,    Matchers . equalTo (  0  )  )  ;", "terms    =    multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getAggregations (  )  . get (  \" name \"  )  ;", "assertThat ( terms . getBuckets (  )  . size (  )  ,    Matchers . equalTo (  2  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  0  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 1  \"  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  1  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 2  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", "SearchIT . assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  2 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getHits (  )  . length ,    Matchers . equalTo (  0  )  )  ;", "terms    =    multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getAggregations (  )  . get (  \" name \"  )  ;", "assertThat ( terms . getBuckets (  )  . size (  )  ,    Matchers . equalTo (  2  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  0  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 1  \"  )  )  ;", "assertThat ( terms . getBuckets (  )  . get (  1  )  . getKeyAsString (  )  ,    Matchers . equalTo (  \" value 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiSearch_withAgg"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "MultiSearchRequest   multiSearchRequest    =    new   MultiSearchRequest (  )  ;", "SearchRequest   searchRequest 1     =    new   SearchRequest (  \" index 1  \"  )  ;", "searchRequest 1  . source (  )  . query ( new   TermsQueryBuilder (  \" field \"  ,     \" value 2  \"  )  )  ;", "multiSearchRequest . add ( searchRequest 1  )  ;", "SearchRequest   searchRequest 2     =    new   SearchRequest (  \" index 2  \"  )  ;", "searchRequest 2  . source (  )  . query ( new   TermsQueryBuilder (  \" field \"  ,     \" value 2  \"  )  )  ;", "multiSearchRequest . add ( searchRequest 2  )  ;", "SearchRequest   searchRequest 3     =    new   SearchRequest (  \" index 3  \"  )  ;", "searchRequest 3  . source (  )  . query ( new   TermsQueryBuilder (  \" field \"  ,     \" value 2  \"  )  )  ;", "multiSearchRequest . add ( searchRequest 3  )  ;", "MultiSearchResponse   multiSearchResponse    =    ESRestHighLevelClientTestCase . execute ( multiSearchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearch ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearchAsync )  ;", "assertThat ( multiSearchResponse . getTook (  )  . millis (  )  ,    Matchers . greaterThanOrEqualTo (  0 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  . length ,    Matchers . equalTo (  3  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  2  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  4  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  6  \"  )  )  ;", "searchRequest 1  . source (  )  . highlighter ( new   HighlightBuilder (  )  . field (  \" field \"  )  )  ;", "searchRequest 2  . source (  )  . highlighter ( new   HighlightBuilder (  )  . field (  \" field \"  )  )  ;", "searchRequest 3  . source (  )  . highlighter ( new   HighlightBuilder (  )  . field (  \" field \"  )  )  ;", "multiSearchResponse    =    ESRestHighLevelClientTestCase . execute ( multiSearchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearch ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : multiSearchAsync )  ;", "assertThat ( multiSearchResponse . getTook (  )  . millis (  )  ,    Matchers . greaterThanOrEqualTo (  0 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  . length ,    Matchers . equalTo (  3  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  0  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getHighlightFields (  )  . get (  \" field \"  )  . fragments (  )  [  0  ]  . string (  )  ,    Matchers . equalTo (  \"  < em > value 2  <  / em >  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  4  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  1  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getHighlightFields (  )  . get (  \" field \"  )  . fragments (  )  [  0  ]  . string (  )  ,    Matchers . equalTo (  \"  < em > value 2  <  / em >  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getFailure (  )  ,    Matchers . nullValue (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . isFailure (  )  ,    Matchers . is ( false )  )  ;", ". assertSearchHeader ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getTotalHits (  )  ,    Matchers . equalTo (  1 L )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getId (  )  ,    Matchers . equalTo (  \"  6  \"  )  )  ;", "assertThat ( multiSearchResponse . getResponses (  )  [  2  ]  . getResponse (  )  . getHits (  )  . getAt (  0  )  . getHighlightFields (  )  . get (  \" field \"  )  . fragments (  )  [  0  ]  . string (  )  ,    Matchers . equalTo (  \"  < em > value 2  <  / em >  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testMultiSearch_withQuery"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "searchRequest . source ( new   SearchSourceBuilder (  )  . query ( new   MatchQueryBuilder (  \" num \"  ,     1  0  )  )  )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getAggregations (  )  )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  1  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  1  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertThat ( searchResponse . getHits (  )  . getMaxScore (  )  ,    greaterThan (  0  .  0 F )  )  ;", "SearchHit   searchHit    =    searchResponse . getHits (  )  . getHits (  )  [  0  ]  ;", "assertEquals (  \" index \"  ,    searchHit . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    searchHit . getType (  )  )  ;", "assertEquals (  \"  1  \"  ,    searchHit . getId (  )  )  ;", "assertThat ( searchHit . getScore (  )  ,    greaterThan (  0  .  0 F )  )  ;", "assertEquals (  (  -  1 L )  ,    searchHit . getVersion (  )  )  ;", "assertNotNull ( searchHit . getSourceAsMap (  )  )  ;", "assertEquals (  3  ,    searchHit . getSourceAsMap (  )  . size (  )  )  ;", "assertEquals (  \" type 1  \"  ,    searchHit . getSourceAsMap (  )  . get (  \" type \"  )  )  ;", "assertEquals (  5  0  ,    searchHit . getSourceAsMap (  )  . get (  \" num 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchMatchQuery"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getAggregations (  )  )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  5  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  5  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "for    ( SearchHit   searchHit    :    searchResponse . getHits (  )  . getHits (  )  )     {", "assertEquals (  \" index \"  ,    searchHit . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    searchHit . getType (  )  )  ;", "assertThat ( Integer . valueOf ( searchHit . getId (  )  )  ,    both ( greaterThan (  0  )  )  . and ( lessThan (  6  )  )  )  ;", "assertEquals (  1  .  0 F ,    searchHit . getScore (  )  ,     0  )  ;", "assertEquals (  (  -  1 L )  ,    searchHit . getVersion (  )  )  ;", "assertNotNull ( searchHit . getSourceAsMap (  )  )  ;", "assertEquals (  3  ,    searchHit . getSourceAsMap (  )  . size (  )  )  ;", "assertTrue ( searchHit . getSourceAsMap (  )  . containsKey (  \" type \"  )  )  ;", "assertTrue ( searchHit . getSourceAsMap (  )  . containsKey (  \" num \"  )  )  ;", "assertTrue ( searchHit . getSourceAsMap (  )  . containsKey (  \" num 2  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchNoQuery"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "XContentBuilder   builder    =    jsonBuilder (  )  . startObject (  )  . field (  \" field \"  ,    i )  . endObject (  )  ;", "HttpEntity   entity    =    new   NStringEntity ( Strings . toString ( builder )  ,    ContentType . APPLICATION _ JSON )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     (  \" test / type 1  /  \"     +     ( Integer . toString ( i )  )  )  ,    Collections . emptyMap (  )  ,    entity )  ;", "}", "client (  )  . performRequest ( HttpPost . METHOD _ NAME ,     \"  / test /  _ refresh \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  . size (  3  5  )  . sort (  \" field \"  ,    ASC )  ;", "SearchRequest   searchRequest    =    new   SearchRequest (  \" test \"  )  . scroll ( TimeValue . timeValueMinutes (  2  )  )  . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "try    {", "long   counter    =     0  ;", "SearchIT . assertSearchHeader ( searchResponse )  ;", "assertThat ( searchResponse . getHits (  )  . getTotalHits (  )  ,    equalTo (  1  0  0 L )  )  ;", "assertThat ( searchResponse . getHits (  )  . getHits (  )  . length ,    equalTo (  3  5  )  )  ;", "for    ( SearchHit   hit    :    searchResponse . getHits (  )  )     {", "assertThat (  (  ( Number )     ( hit . getSortValues (  )  [  0  ]  )  )  . longValue (  )  ,    equalTo (  ( counter +  +  )  )  )  ;", "}", "searchResponse    =    ESRestHighLevelClientTestCase . execute ( new   SearchScrollRequest ( searchResponse . getScrollId (  )  )  . scroll ( TimeValue . timeValueMinutes (  2  )  )  ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchScroll ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchScrollAsync )  ;", "assertThat ( searchResponse . getHits (  )  . getTotalHits (  )  ,    equalTo (  1  0  0 L )  )  ;", "assertThat ( searchResponse . getHits (  )  . getHits (  )  . length ,    equalTo (  3  5  )  )  ;", "for    ( SearchHit   hit    :    searchResponse . getHits (  )  )     {", "assertEquals (  ( counter +  +  )  ,     (  ( Number )     ( hit . getSortValues (  )  [  0  ]  )  )  . longValue (  )  )  ;", "}", "searchResponse    =    ESRestHighLevelClientTestCase . execute ( new   SearchScrollRequest ( searchResponse . getScrollId (  )  )  . scroll ( TimeValue . timeValueMinutes (  2  )  )  ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchScroll ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchScrollAsync )  ;", "assertThat ( searchResponse . getHits (  )  . getTotalHits (  )  ,    equalTo (  1  0  0 L )  )  ;", "assertThat ( searchResponse . getHits (  )  . getHits (  )  . length ,    equalTo (  3  0  )  )  ;", "for    ( SearchHit   hit    :    searchResponse . getHits (  )  )     {", "assertEquals (  ( counter +  +  )  ,     (  ( Number )     ( hit . getSortValues (  )  [  0  ]  )  )  . longValue (  )  )  ;", "}", "}    finally    {", "ClearScrollRequest   clearScrollRequest    =    new   ClearScrollRequest (  )  ;", "clearScrollRequest . addScrollId ( searchResponse . getScrollId (  )  )  ;", "ClearScrollResponse   clearScrollResponse    =    ESRestHighLevelClientTestCase . execute ( clearScrollRequest ,     (    request ,    headers )     -  >    highLevelClient (  )  . clearScroll ( request ,    headers )  ,     (    request ,    listener ,    headers )     -  >    highLevelClient (  )  . clearScrollAsync ( request ,    listener ,    headers )  )  ;", "assertThat ( clearScrollResponse . getNumFreed (  )  ,    greaterThan (  0  )  )  ;", "assertTrue ( clearScrollResponse . isSucceeded (  )  )  ;", "SearchScrollRequest   scrollRequest    =    new   SearchScrollRequest ( searchResponse . getScrollId (  )  )  . scroll ( TimeValue . timeValueMinutes (  2  )  )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >    execute ( scrollRequest ,    highLevelClient (  )  :  : searchScroll ,    highLevelClient (  )  :  : searchScrollAsync )  )  ;", "assertEquals ( NOT _ FOUND ,    exception . status (  )  )  ;", "assertThat ( exception . getRootCause (  )  ,    instanceOf ( EException . class )  )  ;", "EException   rootCause    =     (  ( EException )     ( exception . getRootCause (  )  )  )  ;", "assertThat ( rootCause . getMessage (  )  ,    containsString (  \" No   search   context   found   for \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchScroll"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . aggregation ( new   MatrixStatsAggregationBuilder (  \" agg 1  \"  )  . fields ( Arrays . asList (  \" num \"  ,     \" num 2  \"  )  )  )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  5  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "assertEquals (  1  ,    searchResponse . getAggregations (  )  . asList (  )  . size (  )  )  ;", "MatrixStats   matrixStats    =    searchResponse . getAggregations (  )  . get (  \" agg 1  \"  )  ;", "assertEquals (  5  ,    matrixStats . getFieldCount (  \" num \"  )  )  ;", "assertEquals (  5  6  .  0  ,    matrixStats . getMean (  \" num \"  )  ,     0  .  0  )  ;", "assertEquals (  1  8  3  0  .  0  ,    matrixStats . getVariance (  \" num \"  )  ,     0  .  0  )  ;", "assertEquals (  0  .  0  9  3  4  0  1  9  8  8  0  4  9  7  3  0  4  6  ,    matrixStats . getSkewness (  \" num \"  )  ,     0  .  0  )  ;", "assertEquals (  1  .  2  7  4  1  6  4  6  5  1  0  7  9  4  5  8  9  ,    matrixStats . getKurtosis (  \" num \"  )  ,     0  .  0  )  ;", "assertEquals (  5  ,    matrixStats . getFieldCount (  \" num 2  \"  )  )  ;", "assertEquals (  2  9  .  0  ,    matrixStats . getMean (  \" num 2  \"  )  ,     0  .  0  )  ;", "assertEquals (  3  3  0  .  0  ,    matrixStats . getVariance (  \" num 2  \"  )  ,     0  .  0  )  ;", "assertEquals (  (  -  0  .  1  3  5  6  8  0  3  9  3  4  6  5  8  5  5  4  2  )  ,    matrixStats . getSkewness (  \" num 2  \"  )  ,     1  .  0 E -  1  6  )  ;", "assertEquals (  1  .  3  5  1  7  5  6  1  9  8  3  4  7  1  0  7  4  ,    matrixStats . getKurtosis (  \" num 2  \"  )  ,     0  .  0  )  ;", "assertEquals (  (  -  7  6  7  .  5  )  ,    matrixStats . getCovariance (  \" num \"  ,     \" num 2  \"  )  ,     0  .  0  )  ;", "assertEquals (  (  -  0  .  9  8  7  6  3  3  6  2  9  1  6  6  7  9  2  3  )  ,    matrixStats . getCorrelation (  \" num \"  ,     \" num 2  \"  )  ,     0  .  0  )  ;", "}", "METHOD_END"], "methodName": ["testSearchWithMatrixStats"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "final   String   indexName    =     \" child _ example \"  ;", "StringEntity   parentMapping    =    new   StringEntity (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"              \\  \" mappings \\  \"  :     {  \\ n \"     +     \"                          \\  \" qa \\  \"     :     {  \\ n \"  )     +     \"                                      \\  \" properties \\  \"     :     {  \\ n \"  )     +     \"                                                  \\  \" qa _ join _ field \\  \"     :     {  \\ n \"  )     +     \"                                                              \\  \" type \\  \"     :     \\  \" join \\  \"  ,  \\ n \"  )     +     \"                                                              \\  \" relations \\  \"     :     {     \\  \" question \\  \"     :     \\  \" answer \\  \"     }  \\ n \"  )     +     \"                                                  }  \\ n \"  )     +     \"                                      }  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"              }  \"  )     +     \"  }  \"  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     (  \"  /  \"     +    indexName )  ,    Collections . emptyMap (  )  ,    parentMapping )  ;", "StringEntity   questionDoc    =    new   StringEntity (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  \"              \\  \" body \\  \"  :     \\  \"  < p > I   have   Windows    2  0  0  3    server   and   i   bought   a   new   Windows    2  0  0  8    server .  .  .  \\  \"  ,  \\ n \"     +     \"              \\  \" title \\  \"  :     \\  \" Whats   the   best   way   to   file   transfer   my   site   from   server   to   a   newer   one ?  \\  \"  ,  \\ n \"  )     +     \"              \\  \" tags \\  \"  :     [  \\ n \"  )     +     \"                          \\  \" windows - server -  2  0  0  3  \\  \"  ,  \\ n \"  )     +     \"                          \\  \" windows - server -  2  0  0  8  \\  \"  ,  \\ n \"  )     +     \"                          \\  \" file - transfer \\  \"  \\ n \"  )     +     \"              ]  ,  \\ n \"  )     +     \"              \\  \" qa _ join _ field \\  \"     :     \\  \" question \\  \"  \\ n \"  )     +     \"  }  \"  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     (  (  \"  /  \"     +    indexName )     +     \"  / qa /  1  \"  )  ,    Collections . emptyMap (  )  ,    questionDoc )  ;", "StringEntity   answerDoc 1     =    new   StringEntity (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  \"              \\  \" owner \\  \"  :     {  \\ n \"     +     \"                          \\  \" location \\  \"  :     \\  \" Norfolk ,    United   Kingdom \\  \"  ,  \\ n \"  )     +     \"                          \\  \" display _ name \\  \"  :     \\  \" Sam \\  \"  ,  \\ n \"  )     +     \"                          \\  \" id \\  \"  :     4  8  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" body \\  \"  :     \\  \"  < p > Unfortunately   you \\  ' re   pretty   much   limited   to   FTP .  .  .  \\  \"  ,  \\ n \"  )     +     \"              \\  \" qa _ join _ field \\  \"     :     {  \\ n \"  )     +     \"                          \\  \" name \\  \"     :     \\  \" answer \\  \"  ,  \\ n \"  )     +     \"                          \\  \" parent \\  \"     :     \\  \"  1  \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" creation _ date \\  \"  :     \\  \"  2  0  0  9  -  0  5  -  0  4 T 1  3  :  4  5  :  3  7  .  0  3  0  \\  \"  \\ n \"  )     +     \"  }  \"  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     (  (  \"  /  \"     +    indexName )     +     \"  / qa /  2  \"  )  ,    Collections . singletonMap (  \" routing \"  ,     \"  1  \"  )  ,    answerDoc 1  )  ;", "StringEntity   answerDoc 2     =    new   StringEntity (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  \"              \\  \" owner \\  \"  :     {  \\ n \"     +     \"                          \\  \" location \\  \"  :     \\  \" Norfolk ,    United   Kingdom \\  \"  ,  \\ n \"  )     +     \"                          \\  \" display _ name \\  \"  :     \\  \" Troll \\  \"  ,  \\ n \"  )     +     \"                          \\  \" id \\  \"  :     4  9  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" body \\  \"  :     \\  \"  < p > Use   Linux .  .  .  \\  \"  ,  \\ n \"  )     +     \"              \\  \" qa _ join _ field \\  \"     :     {  \\ n \"  )     +     \"                          \\  \" name \\  \"     :     \\  \" answer \\  \"  ,  \\ n \"  )     +     \"                          \\  \" parent \\  \"     :     \\  \"  1  \\  \"  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" creation _ date \\  \"  :     \\  \"  2  0  0  9  -  0  5  -  0  5 T 1  3  :  4  5  :  3  7  .  0  3  0  \\  \"  \\ n \"  )     +     \"  }  \"  )  )  ,    ContentType . APPLICATION _ JSON )  ;", "client (  )  . performRequest ( METHOD _ NAME ,     (  (  \"  /  \"     +    indexName )     +     \"  / qa /  3  \"  )  ,    Collections . singletonMap (  \" routing \"  ,     \"  1  \"  )  ,    answerDoc 2  )  ;", "client (  )  . performRequest ( HttpPost . METHOD _ NAME ,     \"  /  _ refresh \"  )  ;", "TermsAggregationBuilder   leafTermAgg    =    new   TermsAggregationBuilder (  \" top - names \"  ,    ValueType . STRING )  . field (  \" owner . display _ name . keyword \"  )  . size (  1  0  )  ;", "ChildrenAggregationBuilder   childrenAgg    =    new   ChildrenAggregationBuilder (  \" to - answers \"  ,     \" answer \"  )  . subAggregation ( leafTermAgg )  ;", "TermsAggregationBuilder   termsAgg    =    new   TermsAggregationBuilder (  \" top - tags \"  ,    ValueType . STRING )  . field (  \" tags . keyword \"  )  . size (  1  0  )  . subAggregation ( childrenAgg )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . size (  0  )  . aggregation ( termsAgg )  ;", "SearchRequest   searchRequest    =    new   SearchRequest ( indexName )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  3  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "assertEquals (  1  ,    searchResponse . getAggregations (  )  . asList (  )  . size (  )  )  ;", "Terms   terms    =    searchResponse . getAggregations (  )  . get (  \" top - tags \"  )  ;", "assertEquals (  0  ,    terms . getDocCountError (  )  )  ;", "assertEquals (  0  ,    terms . getSumOfOtherDocCounts (  )  )  ;", "assertEquals (  3  ,    terms . getBuckets (  )  . size (  )  )  ;", "for    ( Terms . Bucket   bucket    :    terms . getBuckets (  )  )     {", "assertThat ( bucket . getKeyAsString (  )  ,    either ( equalTo (  \" file - transfer \"  )  )  . or ( equalTo (  \" windows - server -  2  0  0  3  \"  )  )  . or ( equalTo (  \" windows - server -  2  0  0  8  \"  )  )  )  ;", "assertEquals (  1  ,    bucket . getDocCount (  )  )  ;", "assertEquals (  1  ,    bucket . getAggregations (  )  . asList (  )  . size (  )  )  ;", "Children   children    =    bucket . getAggregations (  )  . get (  \" to - answers \"  )  ;", "assertEquals (  2  ,    children . getDocCount (  )  )  ;", "assertEquals (  1  ,    children . getAggregations (  )  . asList (  )  . size (  )  )  ;", "Terms   leafTerms    =    children . getAggregations (  )  . get (  \" top - names \"  )  ;", "assertEquals (  0  ,    leafTerms . getDocCountError (  )  )  ;", "assertEquals (  0  ,    leafTerms . getSumOfOtherDocCounts (  )  )  ;", "assertEquals (  2  ,    leafTerms . getBuckets (  )  . size (  )  )  ;", "assertEquals (  2  ,    leafTerms . getBuckets (  )  . size (  )  )  ;", "Terms . Bucket   sam    =    leafTerms . getBucketByKey (  \" Sam \"  )  ;", "assertEquals (  1  ,    sam . getDocCount (  )  )  ;", "Terms . Bucket   troll    =    leafTerms . getBucketByKey (  \" Troll \"  )  ;", "assertEquals (  1  ,    troll . getDocCount (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchWithParentJoin"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . aggregation ( new   RangeAggregationBuilder (  \" agg 1  \"  )  . field (  \" num \"  )  )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "EStatusException   exception    =    expectThrows ( EStatusException . class ,     (  )     -  >    execute ( searchRequest ,    highLevelClient (  )  :  : search ,    highLevelClient (  )  :  : searchAsync )  )  ;", "assertEquals ( BAD _ REQUEST ,    exception . status (  )  )  ;", "}", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . aggregation ( new   RangeAggregationBuilder (  \" agg 1  \"  )  . field (  \" num \"  )  . addRange (  \" first \"  ,     0  ,     3  0  )  . addRange (  \" second \"  ,     3  1  ,     2  0  0  )  )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "SearchIT . assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  5  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "Range   rangeAgg    =    searchResponse . getAggregations (  )  . get (  \" agg 1  \"  )  ;", "assertEquals (  \" agg 1  \"  ,    rangeAgg . getName (  )  )  ;", "assertEquals (  2  ,    rangeAgg . getBuckets (  )  . size (  )  )  ;", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  0  )  ;", "assertEquals (  \" first \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  2  ,    bucket . getDocCount (  )  )  ;", "}", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  1  )  ;", "assertEquals (  \" second \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  3  ,    bucket . getDocCount (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchWithRangeAgg"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . suggest ( new   SuggestBuilder (  )  . addSuggestion (  \" sugg 1  \"  ,    new   PhraseSuggestionBuilder (  \" type \"  )  )  . setGlobalText (  \" type \"  )  )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getAggregations (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . totalHits )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  1  ,    searchResponse . getSuggest (  )  . size (  )  )  ;", "Suggestion <  ?    extends   Entry <  ?    extends   Suggest . Suggestion . Entry . Option >  >    sugg    =    searchResponse . getSuggest (  )  . iterator (  )  . next (  )  ;", "assertEquals (  \" sugg 1  \"  ,    sugg . getName (  )  )  ;", "for    ( Entry <  ?    extends   Suggest . Suggestion . Entry . Option >    options    :    sugg )     {", "assertEquals (  \" type \"  ,    options . getText (  )  . string (  )  )  ;", "assertEquals (  0  ,    options . getOffset (  )  )  ;", "assertEquals (  4  ,    options . getLength (  )  )  ;", "assertEquals (  2  ,    options . getOptions (  )  . size (  )  )  ;", "for    ( Suggest . Suggestion . Entry . Option   option    :    options )     {", "assertThat ( option . getScore (  )  ,    greaterThan (  0  .  0 F )  )  ;", "assertThat ( option . getText (  )  . string (  )  ,    either ( equalTo (  \" type 1  \"  )  )  . or ( equalTo (  \" type 2  \"  )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSearchWithSuggest"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . aggregation ( new   search . aggregations . bucket . terms . TermsAggregationBuilder (  \" agg 1  \"  ,    ValueType . STRING )  . field (  \" type . keyword \"  )  )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "SearchIT . assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "Terms   termsAgg    =    searchResponse . getAggregations (  )  . get (  \" agg 1  \"  )  ;", "assertEquals (  \" agg 1  \"  ,    termsAgg . getName (  )  )  ;", "assertEquals (  2  ,    termsAgg . getBuckets (  )  . size (  )  )  ;", "Terms . Bucket   type 1     =    termsAgg . getBucketByKey (  \" type 1  \"  )  ;", "assertEquals (  3  ,    type 1  . getDocCount (  )  )  ;", "assertEquals (  0  ,    type 1  . getAggregations (  )  . asList (  )  . size (  )  )  ;", "Terms . Bucket   type 2     =    termsAgg . getBucketByKey (  \" type 2  \"  )  ;", "assertEquals (  2  ,    type 2  . getDocCount (  )  )  ;", "assertEquals (  0  ,    type 2  . getAggregations (  )  . asList (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSearchWithTermsAgg"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" index \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "TermsAggregationBuilder   agg    =    new   TermsAggregationBuilder (  \" agg 1  \"  ,    ValueType . STRING )  . field (  \" type . keyword \"  )  ;", "agg . subAggregation ( new   RangeAggregationBuilder (  \" subagg \"  )  . field (  \" num \"  )  . addRange (  \" first \"  ,     0  ,     3  0  )  . addRange (  \" second \"  ,     3  1  ,     2  0  0  )  )  ;", "searchSourceBuilder . aggregation ( agg )  ;", "searchSourceBuilder . size (  0  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", ". assertSearchHeader ( searchResponse )  ;", "assertNull ( searchResponse . getSuggest (  )  )  ;", "assertEquals ( Collections . emptyMap (  )  ,    searchResponse . getProfileResults (  )  )  ;", "assertEquals (  0  ,    searchResponse . getHits (  )  . getHits (  )  . length )  ;", "assertEquals (  0  .  0 F ,    searchResponse . getHits (  )  . getMaxScore (  )  ,     0  .  0 F )  ;", "Terms   termsAgg    =    searchResponse . getAggregations (  )  . get (  \" agg 1  \"  )  ;", "assertEquals (  \" agg 1  \"  ,    termsAgg . getName (  )  )  ;", "assertEquals (  2  ,    termsAgg . getBuckets (  )  . size (  )  )  ;", "Terms . Bucket   type 1     =    termsAgg . getBucketByKey (  \" type 1  \"  )  ;", "assertEquals (  3  ,    type 1  . getDocCount (  )  )  ;", "assertEquals (  1  ,    type 1  . getAggregations (  )  . asList (  )  . size (  )  )  ;", "{", "Range   rangeAgg    =    type 1  . getAggregations (  )  . get (  \" subagg \"  )  ;", "assertEquals (  2  ,    rangeAgg . getBuckets (  )  . size (  )  )  ;", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  0  )  ;", "assertEquals (  \" first \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  2  ,    bucket . getDocCount (  )  )  ;", "}", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  1  )  ;", "assertEquals (  \" second \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  1  ,    bucket . getDocCount (  )  )  ;", "}", "}", "Terms . Bucket   type 2     =    termsAgg . getBucketByKey (  \" type 2  \"  )  ;", "assertEquals (  2  ,    type 2  . getDocCount (  )  )  ;", "assertEquals (  1  ,    type 2  . getAggregations (  )  . asList (  )  . size (  )  )  ;", "{", "Range   rangeAgg    =    type 2  . getAggregations (  )  . get (  \" subagg \"  )  ;", "assertEquals (  2  ,    rangeAgg . getBuckets (  )  . size (  )  )  ;", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  0  )  ;", "assertEquals (  \" first \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  0  ,    bucket . getDocCount (  )  )  ;", "}", "{", "Range . Bucket   bucket    =    rangeAgg . getBuckets (  )  . get (  1  )  ;", "assertEquals (  \" second \"  ,    bucket . getKeyAsString (  )  )  ;", "assertEquals (  2  ,    bucket . getDocCount (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSearchWithTermsAndRangeAgg"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "HttpEntity   entity    =    new   NStringEntity (  \"  {     \\  \" field \\  \"  :  \\  \" value \\  \"  }  \"  ,    ContentType . APPLICATION _ JSON )  ;", "(  )  . performRequest (  \" PUT \"  ,     \" test / type /  1  \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "(  )  . performRequest (  \" POST \"  ,     \"  / test /  _ refresh \"  )  ;", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" test \"  )  . source ( SearchSourceBuilder . searchSource (  )  . scriptField (  \" result \"  ,    new   Script (  \" null \"  )  )  )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "SearchHit   searchHit    =    searchResponse . getHits (  )  . getAt (  0  )  ;", "List < Object >    values    =    searchHit . getFields (  )  . get (  \" result \"  )  . getValues (  )  ;", "assertNotNull ( values )  ;", "assertEquals (  1  ,    values . size (  )  )  ;", "assertNull ( values . get (  0  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" test \"  )  . source ( SearchSourceBuilder . searchSource (  )  . scriptField (  \" result \"  ,    new   Script (  \" new   HashMap (  )  \"  )  )  )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "SearchHit   searchHit    =    searchResponse . getHits (  )  . getAt (  0  )  ;", "List < Object >    values    =    searchHit . getFields (  )  . get (  \" result \"  )  . getValues (  )  ;", "assertNotNull ( values )  ;", "assertEquals (  1  ,    values . size (  )  )  ;", "assertThat ( values . get (  0  )  ,    instanceOf ( Map . class )  )  ;", "Map <  ?  ,     ?  >    map    =     (  ( Map <  ?  ,     ?  >  )     ( values . get (  0  )  )  )  ;", "assertEquals (  0  ,    map . size (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" test \"  )  . source ( SearchSourceBuilder . searchSource (  )  . scriptField (  \" result \"  ,    new   Script (  \" new   String [  ]  {  }  \"  )  )  )  ;", "SearchResponse   searchResponse    =    ESRestHighLevelClientTestCase . execute ( searchRequest ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : search ,    ESRestHighLevelClientTestCase . highLevelClient (  )  :  : searchAsync )  ;", "SearchHit   searchHit    =    searchResponse . getHits (  )  . getAt (  0  )  ;", "List < Object >    values    =    searchHit . getFields (  )  . get (  \" result \"  )  . getValues (  )  ;", "assertNotNull ( values )  ;", "assertEquals (  1  ,    values . size (  )  )  ;", "assertThat ( values . get (  0  )  ,    instanceOf ( List . class )  )  ;", "List <  ?  >    list    =     (  ( List <  ?  >  )     ( values . get (  0  )  )  )  ;", "assertEquals (  0  ,    list . size (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchWithWeirdScriptFields"], "fileName": "org.elasticsearch.client.SearchIT"}, {"methodBody": ["METHOD_START", "{", "StackTraceElement   myMethod    =    Thread . currentThread (  )  . getStackTrace (  )  [  2  ]  ;", "for    ( StackTraceElement   se    :    e . getStackTrace (  )  )     {", "if    (  ( se . getClassName (  )  . equals ( myMethod . getClassName (  )  )  )     &  &     ( se . getMethodName (  )  . equals ( myMethod . getMethodName (  )  )  )  )     {", "return ;", "}", "}", "StringWriter   stack    =    new   StringWriter (  )  ;", "e . printStackTrace ( new   PrintWriter ( stack )  )  ;", "fail (  (  (  (  \" didn ' t   find   the   calling   method    ( looks   like    \"     +    myMethod )     +     \"  )    in :  \\ n \"  )     +    stack )  )  ;", "}", "METHOD_END"], "methodName": ["assertExceptionStackContainsCallingMethod"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "ProtocolVersion   protocolVersion    =    new   ProtocolVersion (  \" HTTP \"  ,     1  ,     1  )  ;", "RequestLine   requestLine    =    new   BasicRequestLine (  \" GET \"  ,     \"  /  \"  ,    protocolVersion )  ;", "StatusLine   statusLine    =    new   BasicStatusLine ( protocolVersion ,     2  0  0  ,     \" OK \"  )  ;", "Http   http    =    new   BasicHttp ( statusLine )  ;", "return   new    ( requestLine ,    new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  ,    http )  ;", "}", "METHOD_END"], "methodName": ["mockResponse"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "ConnectTimeoutException   timeoutException    =    new   ConnectTimeoutException (  )  ;", "syncResponseListener . onFailure ( timeoutException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( IOException   e )     {", "assertSame ( timeoutException ,    e . getCause (  )  )  ;", "assertEquals ( timeoutException . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testConnectTimeoutExceptionIsBuiltCorrectly"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "ConnectionClosedException   closedException    =    new   ConnectionClosedException ( randomAsciiAlphanumOfLength (  5  )  )  ;", "syncResponseListener . onFailure ( closedException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( ConnectionClosedException   e )     {", "assertSame ( closedException ,    e . getCause (  )  )  ;", "assertEquals ( closedException . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testConnectionClosedExceptionIsWrapped"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "URISyntaxException   exception    =    new   URISyntaxException (  \" test \"  ,     \" test \"  )  ;", "syncResponseListener . onFailure ( exception )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "assertEquals (  \" error   while   performing   request \"  ,    e . getMessage (  )  )  ;", "assertSame ( exception ,    e . getCause (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testExceptionIsWrapped"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "IOException   ioException    =    new   IOException (  )  ;", "syncResponseListener . onFailure ( ioException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( IOException   e )     {", "assertSame ( ioException ,    e . getCause (  )  )  ;", "assertEquals ( ioException . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testIOExceptionIsBuiltCorrectly"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "RuntimeException   firstException    =    new   RuntimeException (  \" first - test \"  )  ;", "syncResponseListener . onFailure ( firstException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "assertEquals ( firstException . getMessage (  )  ,    e . getMessage (  )  )  ;", "assertSame ( firstException ,    e . getCause (  )  )  ;", "}", "RuntimeException   secondException    =    new   RuntimeException (  \" second - test \"  )  ;", "try    {", "syncResponseListener . onFailure ( secondException )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals ( e . getMessage (  )  ,     \" exception   is   already   set \"  )  ;", "}", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "assertEquals ( firstException . getMessage (  )  ,    e . getMessage (  )  )  ;", "assertSame ( firstException ,    e . getCause (  )  )  ;", "}", "Response   response    =    SyncResponseListenerTests . mockResponse (  )  ;", "syncResponseListener . onSuccess ( response )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals (  \" response   and   exception   are   unexpectedly   set   at   the   same   time \"  ,    e . getMessage (  )  )  ;", "assertNotNull ( e . getSuppressed (  )  )  ;", "assertEquals (  1  ,    e . getSuppressed (  )  . length )  ;", "assertSame ( firstException ,    e . getSuppressed (  )  [  0  ]  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOnFailure"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "try    {", "syncResponseListener . onFailure ( null )  ;", "fail (  \" onFailure   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" exception   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOnFailureNullException"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "Response   mockResponse    =    SyncResponseListenerTests . mockResponse (  )  ;", "syncResponseListener . onSuccess ( mockResponse )  ;", "Response   response    =    syncResponseListener . get (  )  ;", "assertSame ( response ,    mockResponse )  ;", "try    {", "syncResponseListener . onSuccess ( mockResponse )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals ( e . getMessage (  )  ,     \" response   is   already   set \"  )  ;", "}", "response    =    syncResponseListener . get (  )  ;", "assertSame ( response ,    mockResponse )  ;", "}", "METHOD_END"], "methodName": ["testOnSuccess"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "try    {", "syncResponseListener . onSuccess ( null )  ;", "fail (  \" onSuccess   should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" response   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testOnSuccessNullResponse"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "RuntimeException   runtimeException    =    new   RuntimeException (  )  ;", "syncResponseListener . onFailure ( runtimeException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( RuntimeException   e )     {", "assertSame ( runtimeException ,    e . getCause (  )  )  ;", "assertEquals ( runtimeException . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testRuntimeIsBuiltCorrectly"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "SSLHandshakeException   exception    =    new   SSLHandshakeException ( randomAsciiAlphanumOfLength (  5  )  )  ;", "syncResponseListener . onFailure ( exception )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( SSLHandshakeException   e )     {", "assertSame ( exception ,    e . getCause (  )  )  ;", "assertEquals ( exception . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testSSLHandshakeExceptionIsWrapped"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "RestClient . SyncResponseListener   syncResponseListener    =    new   RestClient . SyncResponseListener (  1  0  0  0  0  )  ;", "SocketTimeoutException   timeoutException    =    new   SocketTimeoutException (  )  ;", "syncResponseListener . onFailure ( timeoutException )  ;", "try    {", "syncResponseListener . get (  )  ;", "fail (  \" get   should   have   failed \"  )  ;", "}    catch    ( IOException   e )     {", "assertSame ( timeoutException ,    e . getCause (  )  )  ;", "assertEquals ( timeoutException . getMessage (  )  ,    e . getMessage (  )  )  ;", "SyncResponseListenerTests . assertExceptionStackContainsCallingMethod ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["testSocketTimeoutExceptionIsBuiltCorrectly"], "fileName": "org.elasticsearch.client.SyncResponseListenerTests"}, {"methodBody": ["METHOD_START", "{", "List < GarbageCollectorMXBean >    gcMxBeans    =    ManagementFactory . getGarbageCollectorMXBeans (  )  ;", "return   gcMxBeans . stream (  )  . mapToLong ( GarbageCollectorMXBean :  : getCollectionCount )  . sum (  )  ;", "}", "METHOD_END"], "methodName": ["getTotalGcCount"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     <     1  )     {", "System . err . println (  \" usage :     [ search | bulk ]  \"  )  ;", "System . exit (  1  )  ;", "}", "switch    ( args [  0  ]  )     {", "case    \" search \"     :", "runSearch ( args )  ;", "break ;", "case    \" bulk \"     :", "runBulkIndex ( args )  ;", "break ;", "default    :", "System . err . println (  (  (  \" Unknown   benchmark   type    [  \"     +     ( args [  0  ]  )  )     +     \"  ]  \"  )  )  ;", "System . exit (  1  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     7  )     {", "System . err . println (  \" usage :     ' bulk '    argetHostIp   indexFilePath   indexName   typeName   numberOfDocuments   bulkSize \"  )  ;", "System . exit (  1  )  ;", "}", "String   argetHost    =    args [  1  ]  ;", "String   indexFilePath    =    args [  2  ]  ;", "String   indexName    =    args [  3  ]  ;", "String   typeName    =    args [  4  ]  ;", "int   totalDocs    =    Integer . valueOf ( args [  5  ]  )  ;", "int   bulkSize    =    Integer . valueOf ( args [  6  ]  )  ;", "int   totalIterationCount    =     (  ( int )     ( Math . floor (  ( totalDocs    /    bulkSize )  )  )  )  ;", "int   warmupIterations    =     (  ( int )     (  0  .  4     *    totalIterationCount )  )  ;", "int   iterations    =    totalIterationCount    -    warmupIterations ;", "T   client    =    client ( argetHost )  ;", "BenchmarkRunner    =    new   BenchmarkRunner ( warmupIterations ,    iterations ,    new   BulkBenchmarkTask ( bulkRequestExecutor ( client ,    indexName ,    typeName )  ,    indexFilePath ,    warmupIterations ,    iterations ,    bulkSize )  )  ;", "try    {", "runTrials (  (  )     -  >     {", "runGc (  )  ;", "run (  )  ;", "}  )  ;", "}    finally    {", "client . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["runBulkIndexBenchmark"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "long   previousCollections    =    getTotalGcCount (  )  ;", "int   attempts    =     0  ;", "do    {", "System . gc (  )  ;", "try    {", "Thread . sleep (  2  0  0  0  )  ;", "}    catch    ( InterruptedException   e )     {", "Thread . currThread (  )  . interrupt (  )  ;", "return ;", "}", "attempts +  +  ;", "}    while    (  ( previousCollections    =  =     ( getTotalGcCount (  )  )  )     |  |     ( attempts    <     5  )     )  ;", "}", "METHOD_END"], "methodName": ["runGc"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     5  )     {", "System . err . println (  \" usage :     ' search '    benchmarkTargetHostIp   indexName   searchRequestBody   throughputRates \"  )  ;", "System . exit (  1  )  ;", "}", "String   benchmarkTargetHost    =    args [  1  ]  ;", "String   indexName    =    args [  2  ]  ;", "String   searchBody    =    args [  3  ]  ;", "List < Integer >    throughputRates    =    Arrays . asList ( args [  4  ]  . split (  \"  ,  \"  )  )  . stream (  )  . map ( Integer :  : valueOf )  . collect ( Collectors . toList (  )  )  ;", "T   client    =    client ( benchmarkTargetHost )  ;", "try    {", "runTrials (  (  )     -  >     {", "for    ( int   throughput    :    throughputRates )     {", "runGc (  )  ;", "BenchmarkRunner   benchmark    =    new   BenchmarkRunner (  . SEARCH _ BENCHMARK _ ITERATIONS ,     . SEARCH _ BENCHMARK _ ITERATIONS ,    new   SearchBenchmarkTask ( searchRequestExecutor ( client ,    indexName )  ,    searchBody ,     . SEARCH _ BENCHMARK _ ITERATIONS ,     . SEARCH _ BENCHMARK _ ITERATIONS ,    throughput )  )  ;", "System . out . printf (  \" Target   throughput    =     % d   ops    /    s % n \"  ,    throughput )  ;", "benchmark . run (  )  ;", "}", "}  )  ;", "}    finally    {", "client . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["runSearchBenchmark"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "int   totalWarmupTrialRuns    =     1  ;", "for    ( int   run    =     1  ;    run    <  =    totalWarmupTrialRuns ;    run +  +  )     {", "System . out . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "System . out . println (  (  (  (  \"    Warmup   trial   run    \"     +    run )     +     \"  /  \"  )     +    totalWarmupTrialRuns )  )  ;", "System . out . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "runner . run (  )  ;", "}", "int   totalTrialRuns    =     5  ;", "for    ( int   run    =     1  ;    run    <  =    totalTrialRuns ;    run +  +  )     {", "System . out . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "System . out . println (  (  (  (  \"    Trial   run    \"     +    run )     +     \"  /  \"  )     +    totalTrialRuns )  )  ;", "System . out . println (  \"  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  \"  )  ;", "runner . run (  )  ;", "}", "}", "METHOD_END"], "methodName": ["runTrials"], "fileName": "org.elasticsearch.client.benchmark.AbstractBenchmark"}, {"methodBody": ["METHOD_START", "{", "String   type    =    args [  0  ]  ;", "AbstractBenchmark <  ?  >     =    null ;", "switch    ( type )     {", "case    \" transport \"     :", "=    new   TransportClientBenchmark (  )  ;", "break ;", "case    \" rest \"     :", "=    new   RestClientBenchmark (  )  ;", "break ;", "default    :", "System . err . println (  (  (  \" Unknown   client   type    [  \"     +    type )     +     \"  ]  \"  )  )  ;", "System . exit (  1  )  ;", "}", "run ( Arrays . copyOfRange ( args ,     1  ,    args . length )  )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.elasticsearch.client.benchmark.BenchmarkMain"}, {"methodBody": ["METHOD_START", "{", "char [  ]    characters    =    new   char [ times ]  ;", "Arrays . fill ( characters ,    character )  ;", "return   new   String ( characters )  ;", "}", "METHOD_END"], "methodName": ["repeat"], "fileName": "org.elasticsearch.client.benchmark.BenchmarkRunner"}, {"methodBody": ["METHOD_START", "{", "SampleRecorder   recorder    =    new   SampleRecorder ( iterations )  ;", "System . out . printf (  \" ing    % s   with    % d   warmup   iterations   and    % d   iterations .  % n \"  ,    task . getClass (  )  . getSimpleName (  )  ,    warmupIterations ,    iterations )  ;", "try    {", "task . setUp ( recorder )  ;", "task . run (  )  ;", "task . tearDown (  )  ;", "}    catch    ( InterruptedException   ex )     {", "Thread . currentThread (  )  . interrupt (  )  ;", "return ;", "}    catch    ( Exception   ex )     {", "throw   new   RuntimeException ( ex )  ;", "}", "List < Sample >    samples    =    recorder . getSamples (  )  ;", "final   List < Metrics >    summaryMetrics    =    MetricsCalculator . calculate ( samples )  ;", "if    ( summaryMetrics . isEmpty (  )  )     {", "System . out . println (  \" No   results .  \"  )  ;", "}", "for    ( Metrics   metrics    :    summaryMetrics )     {", "String   throughput    =    String . format ( Locale . ROOT ,     \" Throughput    [ ops / s ]  :     % f \"  ,    metrics . throughput )  ;", "String   serviceTimes    =    String . format ( Locale . ROOT ,     \" Service   time    [ ms ]  :    p 5  0     =     % f ,    p 9  0     =     % f ,    p 9  5     =     % f ,    p 9  9     =     % f ,    p 9  9  .  9     =     % f ,    p 9  9  .  9  9     =     % f \"  ,    metrics . serviceTimeP 5  0  ,    metrics . serviceTimeP 9  0  ,    metrics . serviceTimeP 9  5  ,    metrics . serviceTimeP 9  9  ,    metrics . serviceTimeP 9  9  9  ,    metrics . serviceTimeP 9  9  9  9  )  ;", "String   latencies    =    String . format ( Locale . ROOT ,     \" Latency    [ ms ]  :                   p 5  0     =     % f ,    p 9  0     =     % f ,    p 9  5     =     % f ,    p 9  9     =     % f ,    p 9  9  .  9     =     % f ,    p 9  9  .  9  9     =     % f \"  ,    metrics . latencyP 5  0  ,    metrics . latencyP 9  0  ,    metrics . latencyP 9  5  ,    metrics . latencyP 9  9  ,    metrics . latencyP 9  9  9  ,    metrics . latencyP 9  9  9  9  )  ;", "int   lineLength    =    Math . max ( serviceTimes . length (  )  ,    latencies . length (  )  )  ;", "System . out . println ( repeat ( lineLength ,     '  -  '  )  )  ;", "System . out . println ( throughput )  ;", "System . out . println ( serviceTimes )  ;", "System . out . println ( latencies )  ;", "System . out . printf (  \" success   count    =     % d ,    error   count    =     % d % n \"  ,    metrics . successCount ,    metrics . errorCount )  ;", "System . out . println ( repeat ( lineLength ,     '  -  '  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["run"], "fileName": "org.elasticsearch.client.benchmark.BenchmarkRunner"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < Sample >  >    samplesPerOperation    =    MetricsCalculator . groupByOperation ( samples )  ;", "return   MetricsCalculator . calculateMetricsPerOperation ( samplesPerOperation )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "org.elasticsearch.client.benchmark.metrics.MetricsCalculator"}, {"methodBody": ["METHOD_START", "{", "List < Metrics >    metrics    =    new   ArrayList <  >  (  )  ;", "for    ( Map . Entry < String ,    List < Sample >  >    operationAndMetrics    :    samplesPerOperation . entrySet (  )  )     {", "List < Sample >    samples    =    operationAndMetrics . getValue (  )  ;", "double [  ]    serviceTimes    =    new   double [ samples . size (  )  ]  ;", "double [  ]    latencies    =    new   double [ samples . size (  )  ]  ;", "int   it    =     0  ;", "long   firstStart    =    Long . MAX _ VALUE ;", "long   latestEnd    =    Long . MIN _ VALUE ;", "for    ( Sample   sample    :    samples )     {", "firstStart    =    Math . min ( sample . getStartTimestamp (  )  ,    firstStart )  ;", "latestEnd    =    Math . max ( sample . getStopTimestamp (  )  ,    latestEnd )  ;", "serviceTimes [ it ]     =    sample . getServiceTime (  )  ;", "latencies [ it ]     =    sample . getLatency (  )  ;", "it +  +  ;", "}", "metrics . add ( new   Metrics ( operationAndMetrics . getKey (  )  ,    samples . stream (  )  . filter (  (    r )     -  >    r . isSuccess (  )  )  . count (  )  ,    samples . stream (  )  . filter (  (    r )     -  >     !  ( r . isSuccess (  )  )  )  . count (  )  ,     . calculateThroughput ( samples . size (  )  ,     ( latestEnd    -    firstStart )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     5  0  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     9  0  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     9  5  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     9  9  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     9  9  .  9  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( serviceTimes ,     9  9  .  9  9  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     5  0  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     9  0  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     9  5  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     9  9  .  0  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     9  9  .  9  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  ,     (  ( StatUtils . percentile ( latencies ,     9  9  .  9  9  )  )     /     ( TimeUnit . MILLISECONDS . toNanos (  1 L )  )  )  )  )  ;", "}", "return   metrics ;", "}", "METHOD_END"], "methodName": ["calculateMetricsPerOperation"], "fileName": "org.elasticsearch.client.benchmark.metrics.MetricsCalculator"}, {"methodBody": ["METHOD_START", "{", "return   sampleSize    *     (  ( TimeUnit . SECONDS . toNanos (  1 L )  )     /    duration )  ;", "}", "METHOD_END"], "methodName": ["calculateThroughput"], "fileName": "org.elasticsearch.client.benchmark.metrics.MetricsCalculator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < Sample >  >    samplesPerOperation    =    new   HashMap <  >  (  )  ;", "for    ( Sample   sample    :    samples )     {", "if    (  !  ( samplesPerOperation . containsKey ( sample . getOperation (  )  )  )  )     {", "samplesPerOperation . put ( sample . getOperation (  )  ,    new   ArrayList <  >  (  )  )  ;", "}", "samplesPerOperation . get ( sample . getOperation (  )  )  . add ( sample )  ;", "}", "return   samplesPerOperation ;", "}", "METHOD_END"], "methodName": ["groupByOperation"], "fileName": "org.elasticsearch.client.benchmark.metrics.MetricsCalculator"}, {"methodBody": ["METHOD_START", "{", "return    ( stopTimestamp )     -     ( expectedStartTimestamp )  ;", "}", "METHOD_END"], "methodName": ["getLatency"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "return   operation ;", "}", "METHOD_END"], "methodName": ["getOperation"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "return    ( stopTimestamp )     -     ( startTimestamp )  ;", "}", "METHOD_END"], "methodName": ["getServiceTime"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "return   startTimestamp ;", "}", "METHOD_END"], "methodName": ["getStartTimestamp"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "return   stopTimestamp ;", "}", "METHOD_END"], "methodName": ["getStopTimestamp"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "return   success ;", "}", "METHOD_END"], "methodName": ["isSuccess"], "fileName": "org.elasticsearch.client.benchmark.metrics.Sample"}, {"methodBody": ["METHOD_START", "{", "samples . add ( sample )  ;", "}", "METHOD_END"], "methodName": ["addSample"], "fileName": "org.elasticsearch.client.benchmark.metrics.SampleRecorder"}, {"methodBody": ["METHOD_START", "{", "return   Collections . unmodifiableList ( samples )  ;", "}", "METHOD_END"], "methodName": ["getSamples"], "fileName": "org.elasticsearch.client.benchmark.metrics.SampleRecorder"}, {"methodBody": ["METHOD_START", "{", "long   interval    =     ( TimeUnit . SECONDS . toNanos (  1 L )  )     /     ( targetThroughput )  ;", "long   totalStart    =    System . nanoTime (  )  ;", "for    ( int   iteration    =     0  ;    iteration    <    iterations ;    iteration +  +  )     {", "long   expectedStart    =    totalStart    +     ( iteration    *    interval )  ;", "while    (  ( System . nanoTime (  )  )     <    expectedStart )     {", "}", "long   start    =    System . nanoTime (  )  ;", "boolean   success    = RequestExecutorRequestBody )  ;", "long   stop    =    System . nanoTime (  )  ;", "if    ( addSample )     {", "sampleRecorder . addSample ( new   Sample (  \"  ,    expectedStart ,    start ,    stop ,    success )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["runIterations"], "fileName": "org.elasticsearch.client.benchmark.ops.search.SearchBenchmarkTask"}, {"methodBody": ["METHOD_START", "{", "RestClientBenchmark   b    =    new   RestClientBenchmark (  )  ;", "b . run ( args )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.elasticsearch.client.benchmark.rest.RestClientBenchmark"}, {"methodBody": ["METHOD_START", "{", "TransportClientBenchmark   benchmark    =    new   TransportClientBenchmark (  )  ;", "benchmark . run ( args )  ;", "}", "METHOD_END"], "methodName": ["main"], "fileName": "org.elasticsearch.client.benchmark.transport.TransportClientBenchmark"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" field \"  ,     \" foo \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" field \"  ,     \" bar \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" field \"  ,     \" baz \"  )  )  ;", "BulkResponse   bulkResponse    =    client . bulk ( request )  ;", "assertSame ( bulkResponse . status (  )  ,    OK )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  )  ;", "request . add ( new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . doc ( JSON ,     \" other \"  ,     \" test \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  4  \"  )  . source ( JSON ,     \" field \"  ,     \" baz \"  )  )  ;", "BulkResponse   bulkResponse    =    client . bulk ( request )  ;", "assertSame ( bulkResponse . status (  )  ,    OK )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "for    ( BulkItemResponse   bulkItemResponse    :    bulkResponse )     {", "DocWriteResponse   itemResponse    =    bulkItemResponse . getResponse (  )  ;", "if    (  (  ( bulkItemResponse . getOpType (  )  )     =  =     ( OpType . INDEX )  )     |  |     (  ( bulkItemResponse . getOpType (  )  )     =  =     ( OpType . CREATE )  )  )     {", "IndexResponse   indexResponse    =     (  ( IndexResponse )     ( itemResponse )  )  ;", "} else", "if    (  ( bulkItemResponse . getOpType (  )  )     =  =     ( OpType . UPDATE )  )     {", "action . update . UpdateResponse   updateResponse    =     (  ( action . update . UpdateResponse )     ( itemResponse )  )  ;", "} else", "if    (  ( bulkItemResponse . getOpType (  )  )     =  =     ( OpType . DELETE )  )     {", "action . delete . DeleteResponse   deleteResponse    =     (  ( action . delete . DeleteResponse )     ( itemResponse )  )  ;", "}", "}", "if    ( bulkResponse . hasFailures (  )  )     {", "}", "for    ( BulkItemResponse   bulkItemResponse    :    bulkResponse )     {", "if    ( bulkItemResponse . isFailed (  )  )     {", "BulkItemResponse . Failure   failure    =    bulkItemResponse . getFailure (  )  ;", "}", "}", "}", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . setRefreshPolicy ( WAIT _ UNTIL )  ;", "request . setRefreshPolicy (  \" wait _ for \"  )  ;", "request . waitForActiveShards (  2  )  ;", "request . waitForActiveShards ( ALL )  ;", "ActionListener < BulkResponse >    listener    =    new   ActionListener < BulkResponse >  (  )     {", "@ Override", "public   void   onResponse ( BulkResponse   bulkResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . bulkAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBulk"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkProcessor . Listener   listener    =    new   BulkProcessor . Listener (  )     {", "@ Override", "public   void   beforeBulk ( long   executionId ,    BulkRequest   request )     {", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    BulkResponse   response )     {", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    Throwable   failure )     {", "}", "}  ;", "BulkProcessor   bulkProcessor    =    BulkProcessor . builder ( client :  : bulkAsync ,    listener )  . build (  )  ;", "assertNotNull ( bulkProcessor )  ;", "IndexRequest   one    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" title \"  ,     \" In   which   order   are   my   Elasticsearch   queries   executed ?  \"  )  ;", "IndexRequest   two    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" title \"  ,     \" Current   status   and   upcoming   changes   in   Elasticsearch \"  )  ;", "IndexRequest   three    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" title \"  ,     \" The   Future   of   Federated   Search   in   Elasticsearch \"  )  ;", "bulkProcessor . add ( one )  ;", "bulkProcessor . add ( two )  ;", "bulkProcessor . add ( three )  ;", "boolean   terminated    =    bulkProcessor . awaitClose (  3  0 L ,    TimeUnit . SECONDS )  ;", "assertTrue ( terminated )  ;", "bulkProcessor . close (  )  ;", "}", "{", "BulkProcessor . Listener   listener    =    new   BulkProcessor . Listener (  )     {", "@ Override", "public   void   beforeBulk ( long   executionId ,    BulkRequest   request )     {", "int   numberOfActions    =    request . numberOfActions (  )  ;", "logger . debug (  \" Executing   bulk    [  {  }  ]    with    {  }    requests \"  ,    executionId ,    numberOfActions )  ;", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    BulkResponse   response )     {", "if    ( response . hasFailures (  )  )     {", "logger . warn (  \" Bulk    [  {  }  ]    executed   with   failures \"  ,    executionId )  ;", "} else    {", "logger . debug (  \" Bulk    [  {  }  ]    completed   in    {  }    milliseconds \"  ,    executionId ,    response . getTook (  )  . getMillis (  )  )  ;", "}", "}", "@ Override", "public   void   afterBulk ( long   executionId ,    BulkRequest   request ,    Throwable   failure )     {", "logger . error (  \" Failed   to   execute   bulk \"  ,    failure )  ;", "}", "}  ;", "BulkProcessor . Builder   builder    =    BulkProcessor . builder ( client :  : bulkAsync ,    listener )  ;", "builder . setBulkActions (  5  0  0  )  ;", "builder . setBulkSize ( new   ommon . unit . ByteSizeValue (  1 L ,    ByteSizeUnit . MB )  )  ;", "builder . setConcurrentRequests (  0  )  ;", "builder . setFlushInterval ( TimeValue . timeValueSeconds (  1  0 L )  )  ;", "builder . setBackoffPolicy ( BackoffPolicy . constantBackoff ( TimeValue . timeValueSeconds (  1 L )  ,     3  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testBulkProcessor"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" field \"  ,     \" value \"  )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertSame ( indexResponse . status (  )  ,    CREATED )  ;", "}", "{", "DeleteRequest   request    =    new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "DeleteResponse   deleteResponse    =    client . delete ( request )  ;", "assertSame ( deleteResponse . getResult (  )  ,    DELETED )  ;", "String   index    =    deleteResponse . getIndex (  )  ;", "String   type    =    deleteResponse . getType (  )  ;", "String   id    =    deleteResponse . getId (  )  ;", "long   version    =    deleteResponse . getVersion (  )  ;", "ReplicationResponse . ShardInfo   shardInfo    =    deleteResponse . getShardInfo (  )  ;", "if    (  ( shardInfo . getTotal (  )  )     !  =     ( shardInfo . getSuccessful (  )  )  )     {", "}", "if    (  ( shardInfo . getFailed (  )  )     >     0  )     {", "for    ( ReplicationResponse . ShardInfo . Failure   failure    :    shardInfo . getFailures (  )  )     {", "String   reason    =    failure . reason (  )  ;", "}", "}", "}", "{", "DeleteRequest   request    =    new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . routing (  \" routing \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . setRefreshPolicy ( WAIT _ UNTIL )  ;", "request . setRefreshPolicy (  \" wait _ for \"  )  ;", "request . version (  2  )  ;", "request . versionType ( EXTERNAL )  ;", "}", "{", "DeleteRequest   request    =    new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \" does _ not _ exist \"  )  ;", "DeleteResponse   deleteResponse    =    client . delete ( request )  ;", "if    (  ( deleteResponse . getResult (  )  )     =  =     ( Result . NOT _ FOUND )  )     {", "}", "}", "{", "IndexResponse   indexResponse    =    client . index ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" field \"  ,     \" value \"  )  )  ;", "assertSame ( indexResponse . status (  )  ,    CREATED )  ;", "try    {", "DeleteRequest   request    =    new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . version (  2  )  ;", "DeleteResponse   deleteResponse    =    client . delete ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . CONFLICT )  )     {", "}", "}", "}", "{", "IndexResponse   indexResponse    =    client . index ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \" async \"  )  . source (  \" field \"  ,     \" value \"  )  )  ;", "assertSame ( indexResponse . status (  )  ,    CREATED )  ;", "DeleteRequest   request    =    new   DeleteRequest (  \" posts \"  ,     \" doc \"  ,     \" async \"  )  ;", "ActionListener < DeleteResponse >    listener    =    new   ActionListener < DeleteResponse >  (  )     {", "@ Override", "public   void   onResponse ( DeleteResponse   deleteResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . deleteAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDelete"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "GetRequest   getRequest    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "getRequest . fetchSourceContext ( new   FetchSourceContext ( false )  )  ;", "getRequest . storedFields (  \"  _ none _  \"  )  ;", "{", "boolean   exists    =    client . exists ( getRequest )  ;", "assertFalse ( exists )  ;", "}", "{", "ActionListener < Boolean >    listener    =    new   ActionListener < Boolean >  (  )     {", "@ Override", "public   void   onResponse ( Boolean   exists )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . existsAsync ( getRequest ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "String   mappings    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"              \\  \" mappings \\  \"     :     {  \\ n \"     +     \"                          \\  \" doc \\  \"     :     {  \\ n \"  )     +     \"                                      \\  \" properties \\  \"     :     {  \\ n \"  )     +     \"                                                  \\  \" message \\  \"     :     {  \\ n \"  )     +     \"                                                              \\  \" type \\  \"  :     \\  \" text \\  \"  ,  \\ n \"  )     +     \"                                                              \\  \" store \\  \"  :    true \\ n \"  )     +     \"                                                  }  \\ n \"  )     +     \"                                      }  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"  }  \"  )  ;", "NStringEntity   entity    =    new   NStringEntity ( mappings ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    client (  )  . performRequest (  \" PUT \"  ,     \"  / posts \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" user \"  ,     \" kimchy \"  ,     \" postDate \"  ,    new   Date (  )  ,     \" message \"  ,     \" trying   out   Elasticsearch \"  )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertEquals ( indexResponse . getResult (  )  ,    CREATED )  ;", "}", "{", "GetRequest   getRequest    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "GetResponse   getResponse    =    client . get ( getRequest )  ;", "assertTrue ( getResponse . isExists (  )  )  ;", "assertEquals (  3  ,    getResponse . getSourceAsMap (  )  . size (  )  )  ;", "String   index    =    getResponse . getIndex (  )  ;", "String   type    =    getResponse . getType (  )  ;", "String   id    =    getResponse . getId (  )  ;", "if    ( getResponse . isExists (  )  )     {", "long   version    =    getResponse . getVersion (  )  ;", "String   sourceAsString    =    getResponse . getSourceAsString (  )  ;", "Map < String ,    Object >    sourceAsMap    =    getResponse . getSourceAsMap (  )  ;", "byte [  ]    sourceAsBytes    =    getResponse . getSourceAsBytes (  )  ;", "} else    {", "}", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . fetchSourceContext ( DO _ NOT _ FETCH _ SOURCE )  ;", "GetResponse   getResponse    =    client . get ( request )  ;", "assertNull ( getResponse . getSourceInternal (  )  )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "String [  ]    includes    =    new   String [  ]  {     \" message \"  ,     \"  * Date \"     }  ;", "String [  ]    excludes    =    Strings . EMPTY _ ARRAY ;", "FetchSourceContext   fetchSourceContext    =    new   FetchSourceContext ( true ,    includes ,    excludes )  ;", "request . fetchSourceContext ( fetchSourceContext )  ;", "GetResponse   getResponse    =    client . get ( request )  ;", "Map < String ,    Object >    sourceAsMap    =    getResponse . getSourceAsMap (  )  ;", "assertEquals (  2  ,    sourceAsMap . size (  )  )  ;", "assertEquals (  \" trying   out   Elasticsearch \"  ,    sourceAsMap . get (  \" message \"  )  )  ;", "assertTrue ( sourceAsMap . containsKey (  \" postDate \"  )  )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "String [  ]    includes    =    Strings . EMPTY _ ARRAY ;", "String [  ]    excludes    =    new   String [  ]  {     \" message \"     }  ;", "FetchSourceContext   fetchSourceContext    =    new   FetchSourceContext ( true ,    includes ,    excludes )  ;", "request . fetchSourceContext ( fetchSourceContext )  ;", "GetResponse   getResponse    =    client . get ( request )  ;", "Map < String ,    Object >    sourceAsMap    =    getResponse . getSourceAsMap (  )  ;", "assertEquals (  2  ,    sourceAsMap . size (  )  )  ;", "assertEquals (  \" kimchy \"  ,    sourceAsMap . get (  \" user \"  )  )  ;", "assertTrue ( sourceAsMap . containsKey (  \" postDate \"  )  )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . storedFields (  \" message \"  )  ;", "GetResponse   getResponse    =    client . get ( request )  ;", "String   message    =    getResponse . getField (  \" message \"  )  . getValue (  )  ;", "assertEquals (  \" trying   out   Elasticsearch \"  ,    message )  ;", "assertEquals (  1  ,    getResponse . getFields (  )  . size (  )  )  ;", "assertNull ( getResponse . getSourceInternal (  )  )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . routing (  \" routing \"  )  ;", "request . preference (  \" preference \"  )  ;", "request . realtime ( false )  ;", "request . refresh ( true )  ;", "request . version (  2  )  ;", "request . versionType ( EXTERNAL )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "ActionListener < GetResponse >    listener    =    new   ActionListener < GetResponse >  (  )     {", "@ Override", "public   void   onResponse ( GetResponse   getResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . getAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "GetRequest   request    =    new   GetRequest (  \" does _ not _ exist \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "try    {", "GetResponse   getResponse    =    client . get ( request )  ;", "}    catch    ( ElasticsearchException   e )     {", "if    (  ( e . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "{", "try    {", "GetRequest   request    =    new   GetRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . version (  2  )  ;", "GetResponse   getResponse    =    client . get ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . CONFLICT )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testGet"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "Map < String ,    Object >    jsonMap    =    new   HashMap <  >  (  )  ;", "jsonMap . put (  \" user \"  ,     \" kimchy \"  )  ;", "jsonMap . put (  \" postDate \"  ,    new   Date (  )  )  ;", "jsonMap . put (  \" message \"  ,     \" trying   out   Elasticsearch \"  )  ;", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( jsonMap )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertEquals ( indexResponse . getResult (  )  ,    CREATED )  ;", "}", "{", "XContentBuilder   builder    =    XContentFactory . jsonBuilder (  )  ;", "builder . startObject (  )  ;", "{", "builder . field (  \" user \"  ,     \" kimchy \"  )  ;", "builder . timeField (  \" postDate \"  ,    new   Date (  )  )  ;", "builder . field (  \" message \"  ,     \" trying   out   Elasticsearch \"  )  ;", "}", "builder . endObject (  )  ;", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( builder )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertEquals ( indexResponse . getResult (  )  ,    UPDATED )  ;", "}", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" user \"  ,     \" kimchy \"  ,     \" postDate \"  ,    new   Date (  )  ,     \" message \"  ,     \" trying   out   Elasticsearch \"  )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertEquals ( indexResponse . getResult (  )  ,    UPDATED )  ;", "}", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "String   jsonString    =     \"  {  \"     +     (  (  (  \"  \\  \" user \\  \"  :  \\  \" kimchy \\  \"  ,  \"     +     \"  \\  \" postDate \\  \"  :  \\  \"  2  0  1  3  -  0  1  -  3  0  \\  \"  ,  \"  )     +     \"  \\  \" message \\  \"  :  \\  \" trying   out   Elasticsearch \\  \"  \"  )     +     \"  }  \"  )  ;", "request . source ( jsonString ,    JSON )  ;", "IndexResponse   indexResponse    =    client . index ( request )  ;", "assertEquals ( indexResponse . getResult (  )  ,    UPDATED )  ;", "String   index    =    indexResponse . getIndex (  )  ;", "String   type    =    indexResponse . getType (  )  ;", "String   id    =    indexResponse . getId (  )  ;", "long   version    =    indexResponse . getVersion (  )  ;", "if    (  ( indexResponse . getResult (  )  )     =  =     ( Result . CREATED )  )     {", "} else", "if    (  ( indexResponse . getResult (  )  )     =  =     ( Result . UPDATED )  )     {", "}", "ReplicationResponse . ShardInfo   shardInfo    =    indexResponse . getShardInfo (  )  ;", "if    (  ( shardInfo . getTotal (  )  )     !  =     ( shardInfo . getSuccessful (  )  )  )     {", "}", "if    (  ( shardInfo . getFailed (  )  )     >     0  )     {", "for    ( ReplicationResponse . ShardInfo . Failure   failure    :    shardInfo . getFailures (  )  )     {", "String   reason    =    failure . reason (  )  ;", "}", "}", "}", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . routing (  \" routing \"  )  ;", "request . timeout ( TimeValue . timeValueSeconds (  1  )  )  ;", "request . timeout (  \"  1 s \"  )  ;", "request . setRefreshPolicy ( WAIT _ UNTIL )  ;", "request . setRefreshPolicy (  \" wait _ for \"  )  ;", "request . version (  2  )  ;", "request . versionType ( EXTERNAL )  ;", "request . opType ( CREATE )  ;", "request . opType (  \" create \"  )  ;", "request . setPipeline (  \" pipeline \"  )  ;", "}", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" field \"  ,     \" value \"  )  . version (  1  )  ;", "try    {", "IndexResponse   response    =    client . index ( request )  ;", "}    catch    ( ElasticsearchException   e )     {", "if    (  ( e . status (  )  )     =  =     ( RestStatus . CONFLICT )  )     {", "}", "}", "}", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" field \"  ,     \" value \"  )  . opType ( CREATE )  ;", "try    {", "IndexResponse   response    =    client . index ( request )  ;", "}    catch    ( ElasticsearchException   e )     {", "if    (  ( e . status (  )  )     =  =     ( RestStatus . CONFLICT )  )     {", "}", "}", "}", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \" async \"  )  . source (  \" field \"  ,     \" value \"  )  ;", "ActionListener < IndexResponse >    listener    =    new   ActionListener < IndexResponse >  (  )     {", "@ Override", "public   void   onResponse ( IndexResponse   indexResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indexAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndex"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "String   mappings    =     \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \"              \\  \" mappings \\  \"     :     {  \\ n \"     +     \"                          \\  \" type \\  \"     :     {  \\ n \"  )     +     \"                                      \\  \" properties \\  \"     :     {  \\ n \"  )     +     \"                                                  \\  \" foo \\  \"     :     {  \\ n \"  )     +     \"                                                              \\  \" type \\  \"  :     \\  \" text \\  \"  ,  \\ n \"  )     +     \"                                                              \\  \" store \\  \"  :    true \\ n \"  )     +     \"                                                  }  \\ n \"  )     +     \"                                      }  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"  }  \"  )  ;", "NStringEntity   entity    =    new   NStringEntity ( mappings ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    client (  )  . performRequest (  \" PUT \"  ,     \"  / index \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "Map < String ,    Object >    source    =    new   HashMap <  >  (  )  ;", "source . put (  \" foo \"  ,     \" val 1  \"  )  ;", "source . put (  \" bar \"  ,     \" val 2  \"  )  ;", "source . put (  \" baz \"  ,     \" val 3  \"  )  ;", "client . index ( new   IndexRequest (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . source ( source )  . setRefreshPolicy ( IMMEDIATE )  )  ;", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" another _ id \"  )  )  ;", "request . add ( new   MultiGetRequest . Item (  \" missing _ index \"  ,     \" type \"  ,     \" id \"  )  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" with _ routing \"  )  . routing (  \" some _ routing \"  )  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" with _ version \"  )  . versionType ( EXTERNAL )  . version (  1  0  1  2  3 L )  )  ;", "request . preference (  \" some _ preference \"  )  ;", "request . realtime ( false )  ;", "request . refresh ( true )  ;", "MultiGetResponse   response    =    client . multiGet ( request )  ;", "MultiGetItemResponse   firstItem    =    response . getResponses (  )  [  0  ]  ;", "assertNull ( firstItem . getFailure (  )  )  ;", "GetResponse   firstGet    =    firstItem . getResponse (  )  ;", "String   index    =    firstItem . getIndex (  )  ;", "String   type    =    firstItem . getType (  )  ;", "String   id    =    firstItem . getId (  )  ;", "if    ( firstGet . isExists (  )  )     {", "long   version    =    firstGet . getVersion (  )  ;", "String   sourceAsString    =    firstGet . getSourceAsString (  )  ;", "Map < String ,    Object >    sourceAsMap    =    firstGet . getSourceAsMap (  )  ;", "byte [  ]    sourceAsBytes    =    firstGet . getSourceAsBytes (  )  ;", "} else    {", "}", "assertTrue ( firstGet . isExists (  )  )  ;", "assertEquals ( source ,    firstGet . getSource (  )  )  ;", "MultiGetItemResponse   missingIndexItem    =    response . getResponses (  )  [  2  ]  ;", "assertNull ( missingIndexItem . getResponse (  )  )  ;", "Exception   e    =    missingIndexItem . getFailure (  )  . getFailure (  )  ;", "ElasticsearchException   ee    =     (  ( ElasticsearchException )     ( e )  )  ;", "assertThat ( e . getMessage (  )  ,    containsString (  \" reason = no   such   index \"  )  )  ;", "ActionListener < MultiGetResponse >    listener    =    new   ActionListener < MultiGetResponse >  (  )     {", "@ Override", "public   void   onResponse ( MultiGetResponse   response )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . multiGetAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . fetchSourceContext ( DO _ NOT _ FETCH _ SOURCE )  )  ;", "MultiGetItemResponse   item    =    unwrapAndAssertExample ( client . multiGet ( request )  )  ;", "assertNull ( item . getResponse (  )  . getSource (  )  )  ;", "}", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "String [  ]    includes    =    new   String [  ]  {     \" foo \"  ,     \"  * r \"     }  ;", "String [  ]    excludes    =    Strings . EMPTY _ ARRAY ;", "FetchSourceContext   fetchSourceContext    =    new   FetchSourceContext ( true ,    includes ,    excludes )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . fetchSourceContext ( fetchSourceContext )  )  ;", "MultiGetItemResponse   item    =    unwrapAndAssertExample ( client . multiGet ( request )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    hasEntry (  \" foo \"  ,     \" val 1  \"  )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    hasEntry (  \" bar \"  ,     \" val 2  \"  )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    not ( hasKey (  \" baz \"  )  )  )  ;", "}", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "String [  ]    includes    =    Strings . EMPTY _ ARRAY ;", "String [  ]    excludes    =    new   String [  ]  {     \" foo \"  ,     \"  * r \"     }  ;", "FetchSourceContext   fetchSourceContext    =    new   FetchSourceContext ( true ,    includes ,    excludes )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . fetchSourceContext ( fetchSourceContext )  )  ;", "MultiGetItemResponse   item    =    unwrapAndAssertExample ( client . multiGet ( request )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    not ( hasKey (  \" foo \"  )  )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    not ( hasKey (  \" bar \"  )  )  )  ;", "assertThat ( item . getResponse (  )  . getSource (  )  ,    hasEntry (  \" baz \"  ,     \" val 3  \"  )  )  ;", "}", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . storedFields (  \" foo \"  )  )  ;", "MultiGetResponse   response    =    client . multiGet ( request )  ;", "MultiGetItemResponse   item    =    response . getResponses (  )  [  0  ]  ;", "String   value    =    item . getResponse (  )  . getField (  \" foo \"  )  . getValue (  )  ;", "assertNull ( item . getResponse (  )  . getSource (  )  )  ;", "assertEquals (  \" val 1  \"  ,    value )  ;", "}", "{", "MultiGetRequest   request    =    new   MultiGetRequest (  )  ;", "request . add ( new   MultiGetRequest . Item (  \" index \"  ,     \" type \"  ,     \" example _ id \"  )  . version (  1  0  0  0 L )  )  ;", "MultiGetResponse   response    =    client . multiGet ( request )  ;", "MultiGetItemResponse   item    =    response . getResponses (  )  [  0  ]  ;", "assertNull ( item . getResponse (  )  )  ;", "Exception   e    =    item . getFailure (  )  . getFailure (  )  ;", "ElasticsearchException   ee    =     (  ( ElasticsearchException )     ( e )  )  ;", "assertThat ( e . getMessage (  )  ,    containsString (  (  \" version   conflict ,    current   version    [  1  ]    is    \"     +     \" different   than   the   one   provided    [  1  0  0  0  ]  \"  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMultiGet"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "IndexRequest   indexRequest    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source (  \" field \"  ,     0  )  ;", "IndexResponse   indexResponse    =    client . index ( indexRequest )  ;", "assertSame ( indexResponse . status (  )  ,    CREATED )  ;", "XContentType   xContentType    =    XContentType . JSON ;", "String   script    =    Strings . toString ( XContentBuilder . builder ( xContentType . xContent (  )  )  . startObject (  )  . startObject (  \" script \"  )  . field (  \" lang \"  ,     \" painless \"  )  . field (  \" code \"  ,     \" ctx .  _ source . field    +  =    params . count \"  )  . endObject (  )  . endObject (  )  )  ;", "HttpEntity   body    =    new   NStringEntity ( script ,    ContentType . create ( xContentType . mediaType (  )  )  )  ;", "Response   response    =    client (  )  . performRequest ( METHOD _ NAME ,     \"  /  _ scripts / increment - field \"  ,    Collections . emptyMap (  )  ,    body )  ;", "assertEquals ( response . getStatusLine (  )  . getStatusCode (  )  ,    OK . getStatus (  )  )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "request . fetchSource ( true )  ;", "Map < String ,    Object >    parameters    =    Collections . singletonMap (  \" count \"  ,     4  )  ;", "Script   inline    =    new   Script ( ScriptType . INLINE ,     \" painless \"  ,     \" ctx .  _ source . field    +  =    params . count \"  ,    parameters )  ;", "request . script ( inline )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "assertEquals (  4  ,    updateResponse . getGetResult (  )  . getSource (  )  . get (  \" field \"  )  )  ;", "request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . fetchSource ( true )  ;", "Script   stored    =    new   Script ( ScriptType . STORED ,    null ,     \" increment - field \"  ,    parameters )  ;", "request . script ( stored )  ;", "updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "assertEquals (  8  ,    updateResponse . getGetResult (  )  . getSource (  )  . get (  \" field \"  )  )  ;", "}", "{", "Map < String ,    Object >    jsonMap    =    new   HashMap <  >  (  )  ;", "jsonMap . put (  \" updated \"  ,    new   Date (  )  )  ;", "jsonMap . put (  \" reason \"  ,     \" daily   update \"  )  ;", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc ( jsonMap )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "}", "{", "XContentBuilder   builder    =    XContentFactory . jsonBuilder (  )  ;", "builder . startObject (  )  ;", "{", "builder . timeField (  \" updated \"  ,    new   Date (  )  )  ;", "builder . field (  \" reason \"  ,     \" daily   update \"  )  ;", "}", "builder . endObject (  )  ;", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc ( builder )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc (  \" updated \"  ,    new   Date (  )  ,     \" reason \"  ,     \" daily   update \"  )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  ;", "String   jsonString    =     \"  {  \"     +     (  (  \"  \\  \" updated \\  \"  :  \\  \"  2  0  1  7  -  0  1  -  0  1  \\  \"  ,  \"     +     \"  \\  \" reason \\  \"  :  \\  \" daily   update \\  \"  \"  )     +     \"  }  \"  )  ;", "request . doc ( jsonString ,    JSON )  ;", "request . fetchSource ( true )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "String   index    =    updateResponse . getIndex (  )  ;", "String   type    =    updateResponse . getType (  )  ;", "String   id    =    updateResponse . getId (  )  ;", "long   version    =    updateResponse . getVersion (  )  ;", "if    (  ( updateResponse . getResult (  )  )     =  =     ( Result . CREATED )  )     {", "} else", "if    (  ( updateResponse . getResult (  )  )     =  =     ( Result . UPDATED )  )     {", "} else", "if    (  ( updateResponse . getResult (  )  )     =  =     ( Result . DELETED )  )     {", "} else", "if    (  ( updateResponse . getResult (  )  )     =  =     ( Result . NOOP )  )     {", "}", "GetResult   result    =    updateResponse . getGetResult (  )  ;", "if    ( result . isExists (  )  )     {", "String   sourceAsString    =    result . sourceAsString (  )  ;", "Map < String ,    Object >    sourceAsMap    =    result . sourceAsMap (  )  ;", "byte [  ]    sourceAsBytes    =    result . source (  )  ;", "} else    {", "}", "assertNotNull ( result )  ;", "assertEquals (  3  ,    result . sourceAsMap (  )  . size (  )  )  ;", "ReplicationResponse . ShardInfo   shardInfo    =    updateResponse . getShardInfo (  )  ;", "if    (  ( shardInfo . getTotal (  )  )     !  =     ( shardInfo . getSuccessful (  )  )  )     {", "}", "if    (  ( shardInfo . getFailed (  )  )     >     0  )     {", "for    ( ReplicationResponse . ShardInfo . Failure   failure    :    shardInfo . getFailures (  )  )     {", "String   reason    =    failure . reason (  )  ;", "}", "}", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" type \"  ,     \" does _ not _ exist \"  )  . doc (  \" field \"  ,     \" value \"  )  ;", "try    {", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "}    catch    ( ElasticsearchException   e )     {", "if    (  ( e . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc (  \" field \"  ,     \" value \"  )  . version (  1  )  ;", "try    {", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "}    catch    ( ElasticsearchException   e )     {", "if    (  ( e . status (  )  )     =  =     ( RestStatus . CONFLICT )  )     {", "}", "}", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc (  \" reason \"  ,     \" no   source \"  )  ;", "request . fetchSource ( true )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "assertNotNull ( updateResponse . getGetResult (  )  )  ;", "assertEquals (  3  ,    updateResponse . getGetResult (  )  . sourceAsMap (  )  . size (  )  )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc (  \" reason \"  ,     \" source   includes \"  )  ;", "String [  ]    includes    =    new   String [  ]  {     \" updated \"  ,     \" r *  \"     }  ;", "String [  ]    excludes    =    Strings . EMPTY _ ARRAY ;", "request . fetchSource ( new   FetchSourceContext ( true ,    includes ,    excludes )  )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "Map < String ,    Object >    sourceAsMap    =    updateResponse . getGetResult (  )  . sourceAsMap (  )  ;", "assertEquals (  2  ,    sourceAsMap . size (  )  )  ;", "assertEquals (  \" source   includes \"  ,    sourceAsMap . get (  \" reason \"  )  )  ;", "assertTrue ( sourceAsMap . containsKey (  \" updated \"  )  )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . doc (  \" reason \"  ,     \" source   excludes \"  )  ;", "String [  ]    includes    =    Strings . EMPTY _ ARRAY ;", "String [  ]    excludes    =    new   String [  ]  {     \" updated \"     }  ;", "request . fetchSource ( new   FetchSourceContext ( true ,    includes ,    excludes )  )  ;", "UpdateResponse   updateResponse    =    client . update ( request )  ;", "assertEquals ( updateResponse . getResult (  )  ,    UPDATED )  ;", "Map < String ,    Object >    sourceAsMap    =    updateResponse . getGetResult (  )  . sourceAsMap (  )  ;", "assertEquals (  2  ,    sourceAsMap . size (  )  )  ;", "assertEquals (  \" source   excludes \"  ,    sourceAsMap . get (  \" reason \"  )  )  ;", "assertTrue ( sourceAsMap . containsKey (  \" field \"  )  )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \" id \"  )  ;", "request . routing (  \" routing \"  )  ;", "request . timeout ( TimeValue . timeValueSeconds (  1  )  )  ;", "request . timeout (  \"  1 s \"  )  ;", "request . retryOnConflict (  3  )  ;", "request . setRefreshPolicy ( WAIT _ UNTIL )  ;", "request . setRefreshPolicy (  \" wait _ for \"  )  ;", "request . version (  2  )  ;", "request . detectNoop ( false )  ;", "String   jsonString    =     \"  {  \\  \" created \\  \"  :  \\  \"  2  0  1  7  -  0  1  -  0  1  \\  \"  }  \"  ;", "request . upsert ( jsonString ,    JSON )  ;", "request . scriptedUpsert ( true )  ;", "request . docAsUpsert ( true )  ;", "request . waitForActiveShards (  2  )  ;", "request . waitForActiveShards ( ALL )  ;", "}", "{", "UpdateRequest   request    =    new   UpdateRequest (  \" posts \"  ,     \" doc \"  ,     \" async \"  )  . doc (  \" reason \"  ,     \" async   update \"  )  . docAsUpsert ( true )  ;", "ActionListener < UpdateResponse >    listener    =    new   ActionListener < UpdateResponse >  (  )     {", "@ Override", "public   void   onResponse ( UpdateResponse   updateResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . updateAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUpdate"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "assertThat ( response . getResponses (  )  ,    arrayWithSize (  1  )  )  ;", "MultiGetItemResponse   item    =    response . getResponses (  )  [  0  ]  ;", "assertEquals (  \" index \"  ,    item . getIndex (  )  )  ;", "assertEquals (  \" type \"  ,    item . getType (  )  )  ;", "assertEquals (  \" example _ id \"  ,    item . getId (  )  )  ;", "return   item ;", "}", "METHOD_END"], "methodName": ["unwrapAndAssertExample"], "fileName": "org.elasticsearch.client.documentation.CRUDDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "UpdateSettingsRequest   request    =    new   UpdateSettingsRequest (  )  ;", "String   transientSettingKey    =    INDICES _ RECOVERY _ MAX _ BYTES _ PER _ SEC _ SETTING . getKey (  )  ;", "int   transientSettingValue    =     1  0  ;", "Settings   transientSettings    =    Settings . builder (  )  . put ( transientSettingKey ,    transientSettingValue ,    BYTES )  . build (  )  ;", "String   persistentSettingKey    =    CLUSTER _ ROUTING _ ALLOCATION _ ENABLE _ SETTING . getKey (  )  ;", "String   persistentSettingValue    =    NONE . name (  )  ;", "Settings   persistentSettings    =    Settings . builder (  )  . put ( persistentSettingKey ,    persistentSettingValue )  . build (  )  ;", "request . transientSettings ( transientSettings )  ;", "request . persistentSettings ( persistentSettings )  ;", "{", "Settings . Builder   transientSettingsBuilder    =    Settings . builder (  )  . put ( transientSettingKey ,    transientSettingValue ,    BYTES )  ;", "request . transientSettings ( transientSettingsBuilder )  ;", "}", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( transientSettingKey ,     ( transientSettingValue    +     ( BYTES . getSuffix (  )  )  )  )  ;", "request . transientSettings ( map )  ;", "}", "{", "request . transientSettings (  \"  {  \\  \" indices . recovery . max _ bytes _ per _ sec \\  \"  :     \\  \"  1  0 b \\  \"  }  \"  ,    JSON )  ;", "}", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . flatSettings ( true )  ;", "UpdateSettingsResponse   response    =    client . cluster (  )  . putSettings ( request )  ;", "boolean   acknowledged    =    response . isAcknowledged (  )  ;", "Settings   transientSettingsResponse    =    response . getTransientSettings (  )  ;", "Settings   persistentSettingsResponse    =    response . getPersistentSettings (  )  ;", "assertTrue ( acknowledged )  ;", "assertThat ( transientSettingsResponse . get ( transientSettingKey )  ,    equalTo (  ( transientSettingValue    +     ( BYTES . getSuffix (  )  )  )  )  )  ;", "assertThat ( persistentSettingsResponse . get ( persistentSettingKey )  ,    equalTo ( persistentSettingValue )  )  ;", "request . transientSettings ( Settings . builder (  )  . putNull ( transientSettingKey )  . build (  )  )  ;", "request . persistentSettings ( Settings . builder (  )  . putNull ( persistentSettingKey )  )  ;", "UpdateSettingsResponse   resetResponse    =    client . cluster (  )  . putSettings ( request )  ;", "assertTrue ( resetResponse . isAcknowledged (  )  )  ;", "}", "METHOD_END"], "methodName": ["testClusterPutSettings"], "fileName": "org.elasticsearch.client.documentation.ClusterClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "ClusterUpdateSettingsRequest   request    =    new   ClusterUpdateSettingsRequest (  )  ;", "ActionListener < ClusterUpdateSettingsResponse >    listener    =    new   ActionListener < ClusterUpdateSettingsResponse >  (  )     {", "@ Override", "public   void   onResponse ( ClusterUpdateSettingsResponse   response )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . cluster (  )  . putSettingsAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testClusterUpdateSettingsAsync"], "fileName": "org.elasticsearch.client.documentation.ClusterClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "createIndex (  \" index 1  \"  ,    EMPTY )  ;", "}", "{", "ClearIndicesCacheRequest   request    =    new   ClearIndicesCacheRequest (  \" index 1  \"  )  ;", "ClearIndicesCacheRequest   requestMultiple    =    new   ClearIndicesCacheRequest (  \" index 1  \"  ,     \" index 2  \"  )  ;", "ClearIndicesCacheRequest   requestAll    =    new   ClearIndicesCacheRequest (  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "request . queryCache ( true )  ;", "request . requestCache ( true )  ;", "request . fieldDataCache ( true )  ;", "request . fields (  \" field 1  \"  ,     \" field 2  \"  ,     \" field 3  \"  )  ;", "ClearIndicesCacheResponse   clearCacheResponse    =    client . indices (  )  . clearCache ( request )  ;", "int   totalShards    =    clearCacheResponse . getTotalShards (  )  ;", "int   successfulShards    =    clearCacheResponse . getSuccessfulShards (  )  ;", "int   failedShards    =    clearCacheResponse . getFailedShards (  )  ;", "DefaultShardOperationFailedException [  ]    failures    =    clearCacheResponse . getShardFailures (  )  ;", "ActionListener < ClearIndicesCacheResponse >    listener    =    new   ActionListener < ClearIndicesCacheResponse >  (  )     {", "@ Override", "public   void   onResponse ( ClearIndicesCacheResponse   clearCacheResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . clearCacheAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "try    {", "ClearIndicesCacheRequest   request    =    new   ClearIndicesCacheRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . clearCache ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testClearCache"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "CloseIndexRequest   request    =    new   CloseIndexRequest (  \" index \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "CloseIndexResponse   closeIndexResponse    =    client . indices (  )  . close ( request )  ;", "boolean   acknowledged    =    closeIndexResponse . isAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "ActionListener < CloseIndexResponse >    listener    =    new   ActionListener < CloseIndexResponse >  (  )     {", "@ Override", "public   void   onResponse ( CloseIndexResponse   closeIndexResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . closeAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCloseIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexRequest   request    =    new   CreateIndexRequest (  \" twitter \"  )  ;", "request . settings ( Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     3  )  . put (  \" index . number _ of _ replicas \"  ,     2  )  )  ;", "{", "request . mapping (  \" tweet \"  ,     (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  \"        \\  \" tweet \\  \"  :     {  \\ n \"     +     \"              \\  \" properties \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" message \\  \"  :     {  \\ n \"  )     +     \"                          \\  \" type \\  \"  :     \\  \" text \\  \"  \\ n \"  )     +     \"                    }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  )  ,    JSON )  ;", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "request    =    new   CreateIndexRequest (  \" twitter 2  \"  )  ;", "Map < String ,    Object >    jsonMap    =    new   HashMap <  >  (  )  ;", "Map < String ,    Object >    message    =    new   HashMap <  >  (  )  ;", "message . put (  \" type \"  ,     \" text \"  )  ;", "Map < String ,    Object >    properties    =    new   HashMap <  >  (  )  ;", "properties . put (  \" message \"  ,    message )  ;", "Map < String ,    Object >    tweet    =    new   HashMap <  >  (  )  ;", "tweet . put (  \" properties \"  ,    properties )  ;", "jsonMap . put (  \" tweet \"  ,    tweet )  ;", "request . mapping (  \" tweet \"  ,    jsonMap )  ;", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "request    =    new   CreateIndexRequest (  \" twitter 3  \"  )  ;", "XContentBuilder   builder    =    XContentFactory . jsonBuilder (  )  ;", "builder . startObject (  )  ;", "{", "builder . startObject (  \" tweet \"  )  ;", "{", "builder . startObject (  \" properties \"  )  ;", "{", "builder . startObject (  \" message \"  )  ;", "{", "builder . field (  \" type \"  ,     \" text \"  )  ;", "}", "builder . endObject (  )  ;", "}", "builder . endObject (  )  ;", "}", "builder . endObject (  )  ;", "}", "builder . endObject (  )  ;", "request . mapping (  \" tweet \"  ,    builder )  ;", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "request    =    new   CreateIndexRequest (  \" twitter 4  \"  )  ;", "request . mapping (  \" tweet \"  ,     \" message \"  ,     \" type = text \"  )  ;", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "request    =    new   CreateIndexRequest (  \" twitter 5  \"  )  ;", "request . alias ( new   Alias (  \" twitter _ alias \"  )  . filter ( QueryBuilders . termQuery (  \" user \"  ,     \" kimchy \"  )  )  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . waitForActiveShards (  2  )  ;", "request . waitForActiveShards ( DEFAULT )  ;", "{", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "request    =    new   CreateIndexRequest (  \" twitter 6  \"  )  ;", "request . source (  (  \"  {  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"              \\  \" settings \\  \"     :     {  \\ n \"     +     \"                          \\  \" number _ of _ shards \\  \"     :     1  ,  \\ n \"  )     +     \"                          \\  \" number _ of _ replicas \\  \"     :     0  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" mappings \\  \"     :     {  \\ n \"  )     +     \"                          \\  \" tweet \\  \"     :     {  \\ n \"  )     +     \"                                      \\  \" properties \\  \"     :     {  \\ n \"  )     +     \"                                                  \\  \" message \\  \"     :     {     \\  \" type \\  \"     :     \\  \" text \\  \"     }  \\ n \"  )     +     \"                                      }  \\ n \"  )     +     \"                          }  \\ n \"  )     +     \"              }  ,  \\ n \"  )     +     \"              \\  \" aliases \\  \"     :     {  \\ n \"  )     +     \"                          \\  \" twitter _ alias \\  \"     :     {  }  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"  }  \"  )  )  ,    JSON )  ;", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( request )  ;", "boolean   acknowledged    =    createIndexResponse . isAcknowledged (  )  ;", "boolean   shardsAcknowledged    =    createIndexResponse . isShardsAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "assertTrue ( shardsAcknowledged )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "final   RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexRequest   request    =    new   CreateIndexRequest (  \" twitter \"  )  ;", "ActionListener < CreateIndexResponse >    listener    =    new   ActionListener < CreateIndexResponse >  (  )     {", "@ Override", "public   void   onResponse ( CreateIndexResponse   createIndexResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . createAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateIndexAsync"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" posts \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "DeleteIndexRequest   request    =    new   DeleteIndexRequest (  \" posts \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "DeleteIndexResponse   deleteIndexResponse    =    client . indices (  )  . delete ( request )  ;", "boolean   acknowledged    =    deleteIndexResponse . isAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "}", "{", "try    {", "DeleteIndexRequest   request    =    new   DeleteIndexRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . delete ( request )  ;", "}    catch    ( EException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testDeleteIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "final   RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" posts \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "DeleteIndexRequest   request    =    new   DeleteIndexRequest (  \" posts \"  )  ;", "ActionListener < DeleteIndexResponse >    listener    =    new   ActionListener < DeleteIndexResponse >  (  )     {", "@ Override", "public   void   onResponse ( DeleteIndexResponse   deleteIndexResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . deleteAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDeleteIndexAsync"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index \"  )  . alias ( new   Alias (  \" alias \"  )  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "GetAliasesRequest   request    =    new   GetAliasesRequest (  )  ;", "GetAliasesRequest   requestWithAlias    =    new   GetAliasesRequest (  \" alias 1  \"  )  ;", "GetAliasesRequest   requestWithAliases    =    new   GetAliasesRequest ( new   String [  ]  {     \" alias 1  \"  ,     \" alias 2  \"     }  )  ;", "request . aliases (  \" alias \"  )  ;", "request . indices (  \" index \"  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "request . local ( true )  ;", "boolean   exists    =    client . indices (  )  . existsAlias ( request )  ;", "assertTrue ( exists )  ;", "ActionListener < Boolean >    listener    =    new   ActionListener < Boolean >  (  )     {", "@ Override", "public   void   onResponse ( Boolean   exists )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . existsAliasAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testExistsAlias"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "createIndex (  \" index 1  \"  ,    EMPTY )  ;", "}", "{", "FlushRequest   request    =    new   FlushRequest (  \" index 1  \"  )  ;", "FlushRequest   requestMultiple    =    new   FlushRequest (  \" index 1  \"  ,     \" index 2  \"  )  ;", "FlushRequest   requestAll    =    new   FlushRequest (  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "request . waitIfOngoing ( true )  ;", "request . force ( true )  ;", "FlushResponse   flushResponse    =    client . indices (  )  . flush ( request )  ;", "int   totalShards    =    flushResponse . getTotalShards (  )  ;", "int   successfulShards    =    flushResponse . getSuccessfulShards (  )  ;", "int   failedShards    =    flushResponse . getFailedShards (  )  ;", "DefaultShardOperationFailedException [  ]    failures    =    flushResponse . getShardFailures (  )  ;", "ActionListener < FlushResponse >    listener    =    new   ActionListener < FlushResponse >  (  )     {", "@ Override", "public   void   onResponse ( FlushResponse   refreshResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . flushAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "try    {", "FlushRequest   request    =    new   FlushRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . flush ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testFlushIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "createIndex (  \" index \"  ,    EMPTY )  ;", "}", "{", "ForceMergeRequest   request    =    new   ForceMergeRequest (  \" index 1  \"  )  ;", "ForceMergeRequest   requestMultiple    =    new   ForceMergeRequest (  \" index 1  \"  ,     \" index 2  \"  )  ;", "ForceMergeRequest   requestAll    =    new   ForceMergeRequest (  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "request . maxNumSegments (  1  )  ;", "request . onlyExpungeDeletes ( true )  ;", "request . flush ( true )  ;", "ForceMergeResponse   forceMergeResponse    =    client . indices (  )  . forceMerge ( request )  ;", "int   totalShards    =    forceMergeResponse . getTotalShards (  )  ;", "int   successfulShards    =    forceMergeResponse . getSuccessfulShards (  )  ;", "int   failedShards    =    forceMergeResponse . getFailedShards (  )  ;", "DefaultShardOperationFailedException [  ]    failures    =    forceMergeResponse . getShardFailures (  )  ;", "ActionListener < ForceMergeResponse >    listener    =    new   ActionListener < ForceMergeResponse >  (  )     {", "@ Override", "public   void   onResponse ( ForceMergeResponse   forceMergeResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "client . indices (  )  . forceMergeAsync ( request ,    listener )  ;", "}", "{", "try    {", "ForceMergeRequest   request    =    new   ForceMergeRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . forceMerge ( request )  ;", "}    catch    ( EException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testForceMergeIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "UpdateSettingsRequest   request    =    new   UpdateSettingsRequest (  \" index 1  \"  )  ;", "UpdateSettingsRequest   requestMultiple    =    new   UpdateSettingsRequest (  \" index 1  \"  ,     \" index 2  \"  )  ;", "UpdateSettingsRequest   requestAll    =    new   UpdateSettingsRequest (  )  ;", "String   settingKey    =     \" index . number _ of _ replicas \"  ;", "int   settingValue    =     0  ;", "Settings   settings    =    Settings . builder (  )  . put ( settingKey ,    settingValue )  . build (  )  ;", "request . settings ( settings )  ;", "{", "Settings . Builder   settingsBuilder    =    Settings . builder (  )  . put ( settingKey ,    settingValue )  ;", "request . settings ( settingsBuilder )  ;", "}", "{", "Map < String ,    Object >    map    =    new   HashMap <  >  (  )  ;", "map . put ( settingKey ,    settingValue )  ;", "request . settings ( map )  ;", "}", "{", "request . settings (  \"  {  \\  \" index . number _ of _ replicas \\  \"  :     \\  \"  2  \\  \"  }  \"  ,    JSON )  ;", "}", "request . flatSettings ( true )  ;", "request . setPreserveExisting ( false )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "UpdateSettingsResponse   updateSettingsResponse    =    client . indices (  )  . putSettings ( request )  ;", "boolean   acknowledged    =    updateSettingsResponse . isAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "ActionListener < UpdateSettingsResponse >    listener    =    new   ActionListener < UpdateSettingsResponse >  (  )     {", "@ Override", "public   void   onResponse ( UpdateSettingsResponse   updateSettingsResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . putSettingsAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "METHOD_END"], "methodName": ["testIndexPutSettings"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( new   CreateIndexRequest (  \" twitter \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "GetIndexRequest   request    =    new   GetIndexRequest (  )  ;", "request . indices (  \" twitter \"  )  ;", "IndicesOptions   indicesOptions    =    IndicesOptions . strictExpand (  )  ;", "request . local ( false )  ;", "request . humanReadable ( true )  ;", "request . includeDefaults ( false )  ;", "request . flatSettings ( false )  ;", "request . indicesOptions ( indicesOptions )  ;", "boolean   exists    =    indices (  )  . exists ( request )  ;", "assertTrue ( exists )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndicesExist"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" twitter \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "GetIndexRequest   request    =    new   GetIndexRequest (  )  ;", "request . indices (  \" twitter \"  )  ;", "ActionListener < Boolean >    listener    =    new   ActionListener < Boolean >  (  )     {", "@ Override", "public   void   onResponse ( Boolean   exists )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . existsAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testIndicesExistAsync"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "OpenIndexRequest   request    =    new   OpenIndexRequest (  \" index \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . waitForActiveShards (  2  )  ;", "request . waitForActiveShards ( DEFAULT )  ;", "request . indicesOptions ( IndicesOptions . strictExpandOpen (  )  )  ;", "OpenIndexResponse   openIndexResponse    =    client . indices (  )  . open ( request )  ;", "boolean   acknowledged    =    openIndexResponse . isAcknowledged (  )  ;", "boolean   shardsAcked    =    openIndexResponse . isShardsAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "assertTrue ( shardsAcked )  ;", "ActionListener < OpenIndexResponse >    listener    =    new   ActionListener < OpenIndexResponse >  (  )     {", "@ Override", "public   void   onResponse ( OpenIndexResponse   openIndexResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . openAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "try    {", "OpenIndexRequest   request    =    new   OpenIndexRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . open ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . BAD _ REQUEST )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testOpenIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    indices (  )  . create ( new   CreateIndexRequest (  \" twitter \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "PutMappingRequest   request    =    new   PutMappingRequest (  \" twitter \"  )  ;", "request . type (  \" tweet \"  )  ;", "{", "request . source (  (  \"  {  \\ n \"     +     (  (  (  (  (  \"        \\  \" properties \\  \"  :     {  \\ n \"     +     \"              \\  \" message \\  \"  :     {  \\ n \"  )     +     \"                    \\  \" type \\  \"  :     \\  \" text \\  \"  \\ n \"  )     +     \"              }  \\ n \"  )     +     \"        }  \\ n \"  )     +     \"  }  \"  )  )  ,    JSON )  ;", "PutMappingResponse   putMappingResponse    =    indices (  )  . putMapping ( request )  ;", "assertTrue ( putMappingResponse . isAcknowledged (  )  )  ;", "}", "{", "Map < String ,    Object >    jsonMap    =    new   HashMap <  >  (  )  ;", "Map < String ,    Object >    message    =    new   HashMap <  >  (  )  ;", "message . put (  \" type \"  ,     \" text \"  )  ;", "Map < String ,    Object >    properties    =    new   HashMap <  >  (  )  ;", "properties . put (  \" message \"  ,    message )  ;", "jsonMap . put (  \" properties \"  ,    properties )  ;", "request . source ( jsonMap )  ;", "PutMappingResponse   putMappingResponse    =    indices (  )  . putMapping ( request )  ;", "assertTrue ( putMappingResponse . isAcknowledged (  )  )  ;", "}", "{", "XContentBuilder   builder    =    XContentFactory . jsonBuilder (  )  ;", "builder . startObject (  )  ;", "{", "builder . startObject (  \" properties \"  )  ;", "{", "builder . startObject (  \" message \"  )  ;", "{", "builder . field (  \" type \"  ,     \" text \"  )  ;", "}", "builder . endObject (  )  ;", "}", "builder . endObject (  )  ;", "}", "builder . endObject (  )  ;", "request . source ( builder )  ;", "PutMappingResponse   putMappingResponse    =    indices (  )  . putMapping ( request )  ;", "assertTrue ( putMappingResponse . isAcknowledged (  )  )  ;", "}", "{", "request . source (  \" message \"  ,     \" type = text \"  )  ;", "PutMappingResponse   putMappingResponse    =    indices (  )  . putMapping ( request )  ;", "assertTrue ( putMappingResponse . isAcknowledged (  )  )  ;", "}", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "PutMappingResponse   putMappingResponse    =    indices (  )  . putMapping ( request )  ;", "boolean   acknowledged    =    putMappingResponse . isAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "}", "}", "METHOD_END"], "methodName": ["testPutMapping"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "final   RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" twitter \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "PutMappingRequest   request    =    new   PutMappingRequest (  \" twitter \"  )  . type (  \" tweet \"  )  ;", "ActionListener < PutMappingResponse >    listener    =    new   ActionListener < PutMappingResponse >  (  )     {", "@ Override", "public   void   onResponse ( PutMappingResponse   putMappingResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . putMappingAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPutMappingAsync"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "createIndex (  \" index 1  \"  ,    EMPTY )  ;", "}", "{", "RefreshRequest   request    =    new   RefreshRequest (  \" index 1  \"  )  ;", "RefreshRequest   requestMultiple    =    new   RefreshRequest (  \" index 1  \"  ,     \" index 2  \"  )  ;", "RefreshRequest   requestAll    =    new   RefreshRequest (  )  ;", "request . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "RefreshResponse   refreshResponse    =    client . indices (  )  . refresh ( request )  ;", "int   totalShards    =    refreshResponse . getTotalShards (  )  ;", "int   successfulShards    =    refreshResponse . getSuccessfulShards (  )  ;", "int   failedShards    =    refreshResponse . getFailedShards (  )  ;", "DefaultShardOperationFailedException [  ]    failures    =    refreshResponse . getShardFailures (  )  ;", "ActionListener < RefreshResponse >    listener    =    new   ActionListener < RefreshResponse >  (  )     {", "@ Override", "public   void   onResponse ( RefreshResponse   refreshResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . refreshAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "try    {", "RefreshRequest   request    =    new   RefreshRequest (  \" does _ not _ exist \"  )  ;", "client . indices (  )  . refresh ( request )  ;", "}    catch    ( ElasticsearchException   exception )     {", "if    (  ( exception . status (  )  )     =  =     ( RestStatus . NOT _ FOUND )  )     {", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testRefreshIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "client . indices (  )  . create ( new   CreateIndexRequest (  \" index -  1  \"  )  . alias ( new   Alias (  \" alias \"  )  )  )  ;", "}", "RolloverRequest   request    =    new   RolloverRequest (  \" alias \"  ,     \" index -  2  \"  )  ;", "request . addMaxIndexAgeCondition ( new   TimeValue (  7  ,    TimeUnit . DAYS )  )  ;", "request . addMaxIndexDocsCondition (  1  0  0  0  )  ;", "request . addMaxIndexSizeCondition ( new   ommon . unit . ByteSizeValue (  5  ,    ByteSizeUnit . GB )  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . dryRun ( true )  ;", "request . getCreateIndexRequest (  )  . waitForActiveShards (  2  )  ;", "request . getCreateIndexRequest (  )  . waitForActiveShards ( DEFAULT )  ;", "request . getCreateIndexRequest (  )  . settings ( Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     4  )  )  ;", "request . getCreateIndexRequest (  )  . mapping (  \" type \"  ,     \" field \"  ,     \" type = keyword \"  )  ;", "request . getCreateIndexRequest (  )  . alias ( new   Alias (  \" another _ alias \"  )  )  ;", "RolloverResponse   rolloverResponse    =    client . indices (  )  . rollover ( request )  ;", "boolean   acknowledged    =    rolloverResponse . isAcknowledged (  )  ;", "boolean   shardsAcked    =    rolloverResponse . isShardsAcknowledged (  )  ;", "String   oldIndex    =    rolloverResponse . getOldIndex (  )  ;", "String   newIndex    =    rolloverResponse . getNewIndex (  )  ;", "boolean   isRolledOver    =    rolloverResponse . isRolledOver (  )  ;", "boolean   isDryRun    =    rolloverResponse . isDryRun (  )  ;", "Map < String ,    Boolean >    conditionStatus    =    rolloverResponse . getConditionStatus (  )  ;", "assertFalse ( acknowledged )  ;", "assertFalse ( shardsAcked )  ;", "assertEquals (  \" index -  1  \"  ,    oldIndex )  ;", "assertEquals (  \" index -  2  \"  ,    newIndex )  ;", "assertFalse ( isRolledOver )  ;", "assertTrue ( isDryRun )  ;", "assertEquals (  3  ,    conditionStatus . size (  )  )  ;", "ActionListener < RolloverResponse >    listener    =    new   ActionListener < RolloverResponse >  (  )     {", "@ Override", "public   void   onResponse ( RolloverResponse   rolloverResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . rolloverAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "METHOD_END"], "methodName": ["testRolloverIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "Map < String ,    Object >    nodes    =    getAsMap (  \"  _ nodes \"  )  ;", "@ SuppressWarnings (  \" unchecked \"  )", "String   firstNode    =     (  ( Map < String ,    Object >  )     ( nodes . get (  \" nodes \"  )  )  )  . keySet (  )  . iterator (  )  . next (  )  ;", "createIndex (  \" source _ index \"  ,    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     4  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . build (  )  )  ;", "updateIndexSettings (  \" source _ index \"  ,    Settings . builder (  )  . put (  \" index . routing . allocation . require .  _ name \"  ,    firstNode )  . put (  \" index . blocks . write \"  ,    true )  )  ;", "}", "ResizeRequest   request    =    new   ResizeRequest (  \" target _ index \"  ,     \" source _ index \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . setWaitForActiveShards (  2  )  ;", "request . setWaitForActiveShards ( DEFAULT )  ;", "request . getTargetIndexRequest (  )  . settings ( Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     2  )  )  ;", "request . getTargetIndexRequest (  )  . alias ( new   Alias (  \" target _ alias \"  )  )  ;", "ResizeResponse   resizeResponse    =    client . indices (  )  . shrink ( request )  ;", "boolean   acknowledged    =    resizeResponse . isAcknowledged (  )  ;", "boolean   shardsAcked    =    resizeResponse . isShardsAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "assertTrue ( shardsAcked )  ;", "ActionListener < ResizeResponse >    listener    =    new   ActionListener < ResizeResponse >  (  )     {", "@ Override", "public   void   onResponse ( ResizeResponse   resizeResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . shrinkAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "createIndex (  \" source _ index \"  ,    Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     2  )  . put (  \" index . number _ of _ replicas \"  ,     0  )  . put (  \" index . number _ of _ routing _ shards \"  ,     4  )  . build (  )  )  ;", "updateIndexSettings (  \" source _ index \"  ,    Settings . builder (  )  . put (  \" index . blocks . write \"  ,    true )  )  ;", "}", "ResizeRequest   request    =    new   ResizeRequest (  \" target _ index \"  ,     \" source _ index \"  )  ;", "request . setResizeType ( SPLIT )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "request . setWaitForActiveShards (  2  )  ;", "request . setWaitForActiveShards ( DEFAULT )  ;", "request . getTargetIndexRequest (  )  . settings ( Settings . builder (  )  . put (  \" index . number _ of _ shards \"  ,     4  )  )  ;", "request . getTargetIndexRequest (  )  . alias ( new   Alias (  \" target _ alias \"  )  )  ;", "ResizeResponse   resizeResponse    =    client . indices (  )  . split ( request )  ;", "boolean   acknowledged    =    resizeResponse . isAcknowledged (  )  ;", "boolean   shardsAcked    =    resizeResponse . isShardsAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "assertTrue ( shardsAcked )  ;", "ActionListener < ResizeResponse >    listener    =    new   ActionListener < ResizeResponse >  (  )     {", "@ Override", "public   void   onResponse ( ResizeResponse   resizeResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . splitAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "METHOD_END"], "methodName": ["testSplitIndex"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "CreateIndexResponse   createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index 1  \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index 2  \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index 3  \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "createIndexResponse    =    client . indices (  )  . create ( new   CreateIndexRequest (  \" index 4  \"  )  )  ;", "assertTrue ( createIndexResponse . isAcknowledged (  )  )  ;", "}", "{", "IndicesAliasesRequest   request    =    new   IndicesAliasesRequest (  )  ;", "AliasActions   aliasAction    =    new   AliasActions ( Type . ADD )  . index (  \" index 1  \"  )  . alias (  \" alias 1  \"  )  ;", "request . addAliasAction ( aliasAction )  ;", "AliasActions   addIndexAction    =    new   AliasActions ( Type . ADD )  . index (  \" index 1  \"  )  . alias (  \" alias 1  \"  )  . filter (  \"  {  \\  \" term \\  \"  :  {  \\  \" year \\  \"  :  2  0  1  6  }  }  \"  )  ;", "AliasActions   addIndicesAction    =    new   AliasActions ( Type . ADD )  . indices (  \" index 1  \"  ,     \" index 2  \"  )  . alias (  \" alias 2  \"  )  . routing (  \"  1  \"  )  ;", "AliasActions   removeAction    =    new   AliasActions ( Type . REMOVE )  . index (  \" index 3  \"  )  . alias (  \" alias 3  \"  )  ;", "AliasActions   removeIndexAction    =    new   AliasActions ( Type . REMOVE _ INDEX )  . index (  \" index 4  \"  )  ;", "request . timeout ( TimeValue . timeValueMinutes (  2  )  )  ;", "request . timeout (  \"  2 m \"  )  ;", "request . masterNodeTimeout ( TimeValue . timeValueMinutes (  1  )  )  ;", "request . masterNodeTimeout (  \"  1 m \"  )  ;", "IndicesAliasesResponse   indicesAliasesResponse    =    client . indices (  )  . updateAliases ( request )  ;", "boolean   acknowledged    =    indicesAliasesResponse . isAcknowledged (  )  ;", "assertTrue ( acknowledged )  ;", "}", "{", "IndicesAliasesRequest   request    =    new   IndicesAliasesRequest (  )  ;", "AliasActions   aliasAction    =    new   AliasActions ( Type . ADD )  . index (  \" index 1  \"  )  . alias (  \" async \"  )  ;", "request . addAliasAction ( aliasAction )  ;", "ActionListener < IndicesAliasesResponse >    listener    =    new   ActionListener < IndicesAliasesResponse >  (  )     {", "@ Override", "public   void   onResponse ( IndicesAliasesResponse   indicesAliasesResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . indices (  )  . updateAliasesAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUpdateAliases"], "fileName": "org.elasticsearch.client.documentation.IndicesClientDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "Map < String ,    String >    parameters    =    Collections . singletonMap (  \" wait _ for _ status \"  ,     \" green \"  )  ;", "Response   response    =    getLowLevelClient (  )  . performRequest (  \" GET \"  ,     \"  /  _ cluster / health \"  ,    parameters )  ;", "ClusterHealthStatus   healthStatus ;", "try    ( InputStream   is    =    response . getEntity (  )  . getContent (  )  )     {", "Map < String ,    Object >    map    =    XContentHelper . convertToMap ( JSON . xContent (  )  ,    is ,    true )  ;", "healthStatus    =    ClusterHealthStatus . fromString (  (  ( String )     ( map . get (  \" status \"  )  )  )  )  ;", "}", "if    ( healthStatus    =  =     ( ClusterHealthStatus . GREEN )  )     {", "}", "assertSame ( GREEN ,    healthStatus )  ;", "}", "}", "METHOD_END"], "methodName": ["testClusterHealth"], "fileName": "org.elasticsearch.client.documentation.MigrationDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "Settings   indexSettings    =    Settings . builder (  )  . put ( SETTING _ NUMBER _ OF _ SHARDS ,     1  )  . put ( SETTING _ NUMBER _ OF _ REPLICAS ,     0  )  . build (  )  ;", "String   payload    =    Strings . toString ( XContentFactory . jsonBuilder (  )  . startObject (  )  . startObject (  \" settings \"  )  . value ( indexSettings )  . endObject (  )  . startObject (  \" mappings \"  )  . startObject (  \" doc \"  )  . startObject (  \" properties \"  )  . startObject (  \" time \"  )  . field (  \" type \"  ,     \" date \"  )  . endObject (  )  . endObject (  )  . endObject (  )  . endObject (  )  . endObject (  )  )  ;", "HttpEntity   entity    =    new   NStringEntity ( payload ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    getLowLevelClient (  )  . performRequest (  \" PUT \"  ,     \" my - index \"  ,    Collections . emptyMap (  )  ,    entity )  ;", "if    (  ( response . getStatusLine (  )  . getStatusCode (  )  )     !  =     ( HttpStatus . SC _ OK )  )     {", "}", "assertEquals (  2  0  0  ,    response . getStatusLine (  )  . getStatusCode (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCreateIndex"], "fileName": "org.elasticsearch.client.documentation.MigrationDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "IndexRequest   request    =    new   IndexRequest (  \" index \"  ,     \" doc \"  ,     \" id \"  )  ;", "request . source (  \"  {  \\  \" field \\  \"  :  \\  \" value \\  \"  }  \"  ,    JSON )  ;", "IndexResponse   response    =    client . index ( request )  ;", "assertEquals ( CREATED ,    response . status (  )  )  ;", "}", "{", "DeleteRequest   request    =    new   DeleteRequest (  \" index \"  ,     \" doc \"  ,     \" id \"  )  ;", "client . deleteAsync ( request ,    new   action . ActionListener < DeleteResponse >  (  )     {", "@ Override", "public   void   onResponse ( DeleteResponse   deleteResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  )  ;", "assertBusy (  (  )     -  >    assertFalse ( client . exists ( new   GetRequest (  \" index \"  ,     \" doc \"  ,     \" id \"  )  )  )  )  ;", "}", "{", "DeleteRequest   request    =    new   DeleteRequest (  \" index \"  ,     \" doc \"  ,     \" id \"  )  ;", "DeleteResponse   response    =    client . delete ( request )  ;", "assertEquals ( NOT _ FOUND ,    response . status (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testRequests"], "fileName": "org.elasticsearch.client.documentation.MigrationDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    new   RestHighLevelClient ( RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  ,    new   HttpHost (  \" localhost \"  ,     9  2  0  1  ,     \" http \"  )  )  )  ;", "close (  )  ;", "}", "METHOD_END"], "methodName": ["testInitializationFromClientBuilder"], "fileName": "org.elasticsearch.client.documentation.MiscellaneousDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "MainResponse   response    =    info (  )  ;", "ClusterName   clusterName    =    response . getClusterName (  )  ;", "String   clusterUuid    =    response . getClusterUuid (  )  ;", "String   nodeName    =    response . getNodeName (  )  ;", "Version   version    =    response . getVersion (  )  ;", "Build   build    =    response . getBuild (  )  ;", "assertNotNull ( clusterName )  ;", "assertNotNull ( clusterUuid )  ;", "assertNotNull ( nodeName )  ;", "assertNotNull ( version )  ;", "assertNotNull ( build )  ;", "}", "}", "METHOD_END"], "methodName": ["testMain"], "fileName": "org.elasticsearch.client.documentation.MiscellaneousDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "boolean   response    =    ping (  )  ;", "assertTrue ( response )  ;", "}", "METHOD_END"], "methodName": ["testPing"], "fileName": "org.elasticsearch.client.documentation.MiscellaneousDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . boolQuery (  )  . must ( QueryBuilders . termQuery (  \" content \"  ,     \" test 1  \"  )  )  . must ( QueryBuilders . termQuery (  \" content \"  ,     \" test 4  \"  )  )  . mustNot ( QueryBuilders . termQuery (  \" content \"  ,     \" test 2  \"  )  )  . should ( QueryBuilders . termQuery (  \" content \"  ,     \" test 3  \"  )  )  . filter ( QueryBuilders . termQuery (  \" content \"  ,     \" test 5  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testBool"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . boostingQuery ( QueryBuilders . termQuery (  \" name \"  ,     \" kimchy \"  )  ,    QueryBuilders . termQuery (  \" name \"  ,     \" dadoonet \"  )  )  . negativeBoost (  0  .  2 F )  ;", "}", "METHOD_END"], "methodName": ["testBoosting"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . commonTermsQuery (  \" name \"  ,     \" kimchy \"  )  ;", "}", "METHOD_END"], "methodName": ["testCommonTerms"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . constantScoreQuery ( QueryBuilders . termQuery (  \" name \"  ,     \" kimchy \"  )  )  . boost (  2  .  0 F )  ;", "}", "METHOD_END"], "methodName": ["testConstantScore"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . disMaxQuery (  )  . add ( QueryBuilders . termQuery (  \" name \"  ,     \" kimchy \"  )  )  . add ( QueryBuilders . termQuery (  \" name \"  ,     \" elasticsearch \"  )  )  . boost (  1  .  2 F )  . tieBreaker (  0  .  7 F )  ;", "}", "METHOD_END"], "methodName": ["testDisMax"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . existsQuery (  \" name \"  )  ;", "}", "METHOD_END"], "methodName": ["testExists"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "FilterFunctionBuilder [  ]    functions    =    new   FilterFunctionBuilder [  ]  {    new   FilterFunctionBuilder ( QueryBuilders . matchQuery (  \" name \"  ,     \" kimchy \"  )  ,    ScoreFunctionBuilders . randomFunction (  )  )  ,    new   FilterFunctionBuilder ( ScoreFunctionBuilders . exponentialDecayFunction (  \" age \"  ,     0 L ,     1 L )  )     }  ;", "QueryBuilders . functionScoreQuery ( functions )  ;", "}", "METHOD_END"], "methodName": ["testFunctionScore"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . fuzzyQuery (  \" name \"  ,     \" kimchy \"  )  ;", "}", "METHOD_END"], "methodName": ["testFuzzy"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . geoBoundingBoxQuery (  \" pin . location \"  )  . setCorners (  4  0  .  7  3  ,     (  -  7  4  .  1  )  ,     4  0  .  7  1  7  ,     (  -  7  3  .  9  9  )  )  ;", "}", "METHOD_END"], "methodName": ["testGeoBoundingBox"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . geoDistanceQuery (  \" pin . location \"  )  . point (  4  0  ,     (  -  7  0  )  )  . distance (  2  0  0  ,    KILOMETERS )  ;", "}", "METHOD_END"], "methodName": ["testGeoDistance"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "List < GeoPoint >    points    =    new   ArrayList <  >  (  )  ;", "points . add ( new   GeoPoint (  4  0  ,     (  -  7  0  )  )  )  ;", "points . add ( new   GeoPoint (  3  0  ,     (  -  8  0  )  )  )  ;", "points . add ( new   GeoPoint (  2  0  ,     (  -  9  0  )  )  )  ;", "Builders . geoPolygon (  \" pin . location \"  ,    points )  ;", "}", "METHOD_END"], "methodName": ["testGeoPolygon"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "{", "GeoShapeQueryBuilder   qb    =    QueryBuilders . geoShapeQuery (  \" pin . location \"  ,    new   MultiPointBuilder ( new   CoordinatesBuilder (  )  . coordinate (  0  ,     0  )  . coordinate (  0  ,     1  0  )  . coordinate (  1  0  ,     1  0  )  . coordinate (  1  0  ,     0  )  . coordinate (  0  ,     0  )  . build (  )  )  )  ;", "qb . relation ( WITHIN )  ;", "}", "{", "GeoShapeQueryBuilder   qb    =    QueryBuilders . geoShapeQuery (  \" pin . location \"  ,     \" DEU \"  ,     \" countries \"  )  ;", "qb . relation ( WITHIN )  . indexedShapeIndex (  \" shapes \"  )  . indexedShapePath (  \" location \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testGeoShape"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "JoinQueryBuilders . hasChildQuery (  \" blog _ tag \"  ,    QueryBuilders . termQuery (  \" tag \"  ,     \" something \"  )  ,    None )  ;", "}", "METHOD_END"], "methodName": ["testHasChild"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "JoinQueryBuilders . hasParentQuery (  \" blog \"  ,    QueryBuilders . termQuery (  \" tag \"  ,     \" something \"  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["testHasParent"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . idsQuery (  \" my _ type \"  ,     \" type 2  \"  )  . addIds (  \"  1  \"  ,     \"  4  \"  ,     \"  1  0  0  \"  )  ;", "QueryBuilders . idsQuery (  )  . addIds (  \"  1  \"  ,     \"  4  \"  ,     \"  1  0  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIds"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . matchQuery (  \" name \"  ,     \" kimchy   elasticsearch \"  )  ;", "}", "METHOD_END"], "methodName": ["testMatch"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . matchAllQuery (  )  ;", "}", "METHOD_END"], "methodName": ["testMatchAll"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "String [  ]    fields    =    new   String [  ]  {     \" name . first \"  ,     \" name . last \"     }  ;", "String [  ]    texts    =    new   String [  ]  {     \" text   like   this   one \"     }  ;", "Builders . moreLikeThis ( fields ,    texts ,    null )  . minTermFreq (  1  )  . maxTerms (  1  2  )  ;", "}", "METHOD_END"], "methodName": ["testMoreLikeThis"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . multiMatchQuery (  \" kimchy   elasticsearch \"  ,     \" user \"  ,     \" message \"  )  ;", "}", "METHOD_END"], "methodName": ["testMultiMatch"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . nestedQuery (  \" obj 1  \"  ,    QueryBuilders . boolQuery (  )  . must ( QueryBuilders . matchQuery (  \" obj 1  . name \"  ,     \" blue \"  )  )  . must ( QueryBuilders . rangeQuery (  \" obj 1  . count \"  )  . gt (  5  )  )  ,    Avg )  ;", "}", "METHOD_END"], "methodName": ["testNested"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . prefixQuery (  \" brand \"  ,     \" heine \"  )  ;", "}", "METHOD_END"], "methodName": ["testPrefix"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . queryStringQuery (  \"  + kimchy    - elasticsearch \"  )  ;", "}", "METHOD_END"], "methodName": ["testQueryString"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . rangeQuery (  \" price \"  )  . from (  5  )  . to (  1  0  )  . includeLower ( true )  . includeUpper ( false )  ;", "QueryBuilders . rangeQuery (  \" age \"  )  . gte (  \"  1  0  \"  )  . lt (  \"  2  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRange"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . regexpQuery (  \" name . first \"  ,     \" s .  * y \"  )  ;", "}", "METHOD_END"], "methodName": ["testRegExp"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . scriptQuery ( new   Script (  \" doc [  ' num 1  '  ]  . value    >     1  \"  )  )  ;", "Map < String ,    Object >    parameters    =    new   HashMap <  >  (  )  ;", "parameters . put (  \" param 1  \"  ,     5  )  ;", "QueryBuilders . scriptQuery ( new   Script ( ScriptType . STORED ,    null ,     \" myscript \"  ,    Collections . singletonMap (  \" param 1  \"  ,     5  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testScript"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . simpleQueryStringQuery (  \"  + kimchy    - elasticsearch \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimpleQueryString"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanContainingQuery ( QueryBuilders . spanNearQuery ( QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" bar \"  )  ,     5  )  . addClause ( QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" baz \"  )  )  . inOrder ( true )  ,    QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpanContaining"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanFirstQuery ( QueryBuilders . spanTermQuery (  \" user \"  ,     \" kimchy \"  )  ,     3  )  ;", "}", "METHOD_END"], "methodName": ["testSpanFirst"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanMultiTermQueryBuilder ( QueryBuilders . prefixQuery (  \" user \"  ,     \" ki \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpanMultiTerm"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanNearQuery ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 1  \"  )  ,     1  2  )  . addClause ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 2  \"  )  )  . addClause ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 3  \"  )  )  . inOrder ( false )  ;", "}", "METHOD_END"], "methodName": ["testSpanNear"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanNotQuery ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 1  \"  )  ,    QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 2  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpanNot"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanOrQuery ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 1  \"  )  )  . addClause ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 2  \"  )  )  . addClause ( QueryBuilders . spanTermQuery (  \" field \"  ,     \" value 3  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpanOr"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanTermQuery (  \" user \"  ,     \" kimchy \"  )  ;", "}", "METHOD_END"], "methodName": ["testSpanTerm"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . spanWithinQuery ( QueryBuilders . spanNearQuery ( QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" bar \"  )  ,     5  )  . addClause ( QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" baz \"  )  )  . inOrder ( true )  ,    QueryBuilders . spanTermQuery (  \" field 1  \"  ,     \" foo \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testSpanWithin"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . termQuery (  \" name \"  ,     \" kimchy \"  )  ;", "}", "METHOD_END"], "methodName": ["testTerm"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . termsQuery (  \" tags \"  ,     \" blue \"  ,     \" pill \"  )  ;", "}", "METHOD_END"], "methodName": ["testTerms"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . typeQuery (  \" my _ type \"  )  ;", "}", "METHOD_END"], "methodName": ["testType"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "QueryBuilders . wildcardQuery (  \" user \"  ,     \" k ? mch *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testWildcard"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "String   query    =     \"  {  \\  \" term \\  \"  :     {  \\  \" user \\  \"  :     \\  \" kimchy \\  \"  }  }  \"  ;", "Builders . wrapper ( query )  ;", "}", "METHOD_END"], "methodName": ["testWrapper"], "fileName": "org.elasticsearch.client.documentation.QueryDSLDocumentationTests"}, {"methodBody": ["METHOD_START", "{", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setRequestConfigCallback ( new   RestClientBuilder . RequestConfigCallback (  )     {", "@ Override", "public   Builder   customizeRequestConfig ( RequestConfig . Builder   requestConfigBuilder )     {", "return   requestConfigBuilder . setConnectTimeout (  5  0  0  0  )  . setSocketTimeout (  6  0  0  0  0  )  ;", "}", "}  )  . setMaxRetryTimeoutMillis (  6  0  0  0  0  )  ;", "}", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "return   httpClientBuilder . setDefaultIOReactorConfig ( IOReactorConfig . custom (  )  . setIoThreadCount (  1  )  . build (  )  )  ;", "}", "}  )  ;", "}", "{", "final   CredentialsProvider   credentialsProvider    =    new   BasicCredentialsProvider (  )  ;", "credentialsProvider . setCredentials ( ANY ,    new   UsernamePasswordCredentials (  \" user \"  ,     \" password \"  )  )  ;", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "return   httpClientBuilder . setDefaultCredentialsProvider ( credentialsProvider )  ;", "}", "}  )  ;", "}", "{", "final   CredentialsProvider   credentialsProvider    =    new   BasicCredentialsProvider (  )  ;", "credentialsProvider . setCredentials ( ANY ,    new   UsernamePasswordCredentials (  \" user \"  ,     \" password \"  )  )  ;", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "httpClientBuilder . disableAuthCaching (  )  ;", "return   httpClientBuilder . setDefaultCredentialsProvider ( credentialsProvider )  ;", "}", "}  )  ;", "}", "{", "Path   keyStorePath    =    Paths . get (  \"  \"  )  ;", "String   keyStorePass    =     \"  \"  ;", "KeyStore   truststore    =    KeyStore . getInstance (  \" jks \"  )  ;", "try    ( InputStream   is    =    Files . newInputStream ( keyStorePath )  )     {", "truststore . load ( is ,    keyStorePass . toCharArray (  )  )  ;", "}", "SSLContextBuilder   sslBuilder    =    SSLContexts . custom (  )  . loadTrustMaterial ( truststore ,    null )  ;", "final   SSLContext   sslContext    =    sslBuilder . build (  )  ;", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" https \"  )  )  . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "return   httpClientBuilder . setSSLContext ( sslContext )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["testCommonConfiguration"], "fileName": "org.elasticsearch.client.documentation.RestClientDocumentation"}, {"methodBody": ["METHOD_START", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  ,    new   HttpHost (  \" localhost \"  ,     9  2  0  1  ,     \" http \"  )  )  . build (  )  ;", "restClient . close (  )  ;", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  ;", "Header [  ]    defaultHeaders    =    new   Header [  ]  {    new   BasicHeader (  \" header \"  ,     \" value \"  )     }  ;", "builder . setDefaultHeaders ( defaultHeaders )  ;", "}", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  ;", "builder . setMaxRetryTimeoutMillis (  1  0  0  0  0  )  ;", "}", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  ;", "builder . setFailureListener ( new   RestClient . FailureListener (  )     {", "@ Override", "public   void   onFailure ( HttpHost   host )     {", "}", "}  )  ;", "}", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  ;", "builder . setRequestConfigCallback ( new   RestClientBuilder . RequestConfigCallback (  )     {", "@ Override", "public   Builder   customizeRequestConfig ( RequestConfig . Builder   requestConfigBuilder )     {", "return   requestConfigBuilder . setSocketTimeout (  1  0  0  0  0  )  ;", "}", "}  )  ;", "}", "{", "RestClientBuilder   builder    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  ;", "builder . setHttpClientConfigCallback ( new   RestClientBuilder . HttpClientConfigCallback (  )     {", "@ Override", "public   HttpAsyncClientBuilder   customizeHttpClient ( HttpAsyncClientBuilder   httpClientBuilder )     {", "return   httpClientBuilder . setProxy ( new   HttpHost (  \" proxy \"  ,     9  0  0  0  ,     \" http \"  )  )  ;", "}", "}  )  ;", "}", "{", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  /  \"  )  ;", "}", "{", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  /  \"  ,    new   BasicHeader (  \" header \"  ,     \" value \"  )  )  ;", "}", "{", "Map < String ,    String >    params    =    Collections . singletonMap (  \" pretty \"  ,     \" true \"  )  ;", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  /  \"  ,    params )  ;", "}", "{", "Map < String ,    String >    params    =    Collections . emptyMap (  )  ;", "String   jsonString    =     \"  {  \"     +     (  (  (  \"  \\  \" user \\  \"  :  \\  \" kimchy \\  \"  ,  \"     +     \"  \\  \" postDate \\  \"  :  \\  \"  2  0  1  3  -  0  1  -  3  0  \\  \"  ,  \"  )     +     \"  \\  \" message \\  \"  :  \\  \" trying   out   E \\  \"  \"  )     +     \"  }  \"  )  ;", "HttpEntity   entity    =    new   NStringEntity ( jsonString ,    ContentType . APPLICATION _ JSON )  ;", "Response   response    =    restClient . performRequest (  \" PUT \"  ,     \"  / posts / doc /  1  \"  ,    params ,    entity )  ;", "}", "{", "Map < String ,    String >    params    =    Collections . emptyMap (  )  ;", "HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory   consumerFactory    =    new   HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory (  (  (  3  0     *     1  0  2  4  )     *     1  0  2  4  )  )  ;", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  / posts /  _ search \"  ,    params ,    null ,    consumerFactory )  ;", "}", "{", "ResponseListener   responseListener    =    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "}", "}  ;", "restClient . performRequestAsync (  \" GET \"  ,     \"  /  \"  ,    responseListener )  ;", "Header [  ]    headers    =    new   Header [  ]  {    new   BasicHeader (  \" header 1  \"  ,     \" value 1  \"  )  ,    new   BasicHeader (  \" header 2  \"  ,     \" value 2  \"  )     }  ;", "restClient . performRequestAsync (  \" GET \"  ,     \"  /  \"  ,    responseListener ,    headers )  ;", "Map < String ,    String >    params    =    Collections . singletonMap (  \" pretty \"  ,     \" true \"  )  ;", "restClient . performRequestAsync (  \" GET \"  ,     \"  /  \"  ,    params ,    responseListener )  ;", "String   jsonString    =     \"  {  \"     +     (  (  (  \"  \\  \" user \\  \"  :  \\  \" kimchy \\  \"  ,  \"     +     \"  \\  \" postDate \\  \"  :  \\  \"  2  0  1  3  -  0  1  -  3  0  \\  \"  ,  \"  )     +     \"  \\  \" message \\  \"  :  \\  \" trying   out   E \\  \"  \"  )     +     \"  }  \"  )  ;", "HttpEntity   entity    =    new   NStringEntity ( jsonString ,    ContentType . APPLICATION _ JSON )  ;", "restClient . performRequestAsync (  \" PUT \"  ,     \"  / posts / doc /  1  \"  ,    params ,    entity ,    responseListener )  ;", "HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory   consumerFactory    =    new   HttpAsyncResponseConsumerFactory . HeapBufferedResponseConsumerFactory (  (  (  3  0     *     1  0  2  4  )     *     1  0  2  4  )  )  ;", "restClient . performRequestAsync (  \" GET \"  ,     \"  / posts /  _ search \"  ,    params ,    null ,    consumerFactory ,    responseListener )  ;", "}", "{", "Response   response    =    restClient . performRequest (  \" GET \"  ,     \"  /  \"  )  ;", "RequestLine   requestLine    =    response . getRequestLine (  )  ;", "HttpHost   host    =    response . getHost (  )  ;", "int   statusCode    =    response . getStatusLine (  )  . getStatusCode (  )  ;", "Header [  ]    headers    =    response . getHeaders (  )  ;", "String   responseBody    =    EntityUtils . toString ( response . getEntity (  )  )  ;", "}", "{", "HttpEntity [  ]    documents    =    new   HttpEntity [  1  0  ]  ;", "final   CountDownLatch   latch    =    new   CountDownLatch ( documents . length )  ;", "for    ( int   i    =     0  ;    i    <     ( documents . length )  ;    i +  +  )     {", "restClient . performRequestAsync (  \" PUT \"  ,     (  \"  / posts / doc /  \"     +    i )  ,    Collections .  < String ,    String > emptyMap (  )  ,    documents [ i ]  ,    new   ResponseListener (  )     {", "@ Override", "public   void   onSuccess ( Response   response )     {", "latch . countDown (  )  ;", "}", "@ Override", "public   void   onFailure ( Exception   exception )     {", "latch . countDown (  )  ;", "}", "}  )  ;", "}", "latch . await (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUsage"], "fileName": "org.elasticsearch.client.documentation.RestClientDocumentation"}, {"methodBody": ["METHOD_START", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" title \"  ,     \" In   which   order   are   my   E   queries   executed ?  \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" luca \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" title \"  ,     \" Current   status   and   upcoming   changes   in   E \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" christoph \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" title \"  ,     \" The   Future   of   Federated   Search   in   E \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" tanguy \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . setRefreshPolicy ( IMMEDIATE )  ;", "BulkResponse   bulkResponse    =    ESRestHighLevelClientTestCase . highLevelClient (  )  . bulk ( request )  ;", "assertSame ( OK ,    bulkResponse . status (  )  )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "METHOD_END"], "methodName": ["indexSearchTestData"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "MatchQueryBuilder   matchQueryBuilder    =    new   MatchQueryBuilder (  \" user \"  ,     \" kimchy \"  )  ;", "matchQueryBuilder . fuzziness ( AUTO )  ;", "matchQueryBuilder . prefixLength (  3  )  ;", "matchQueryBuilder . maxExpansions (  1  0  )  ;", "}", "{", "QueryBuilder   matchQueryBuilder    =    QueryBuilders . matchQuery (  \" user \"  ,     \" kimchy \"  )  . fuzziness ( AUTO )  . prefixLength (  3  )  . maxExpansions (  1  0  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( matchQueryBuilder )  ;", "}", "}", "METHOD_END"], "methodName": ["testBuildingSearchQueries"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "indexSearchTestData (  )  ;", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "MultiSearchRequest   request    =    new   MultiSearchRequest (  )  ;", "SearchRequest   firstSearchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( QueryBuilders . matchQuery (  \" user \"  ,     \" kimchy \"  )  )  ;", "firstSearchRequest . source ( searchSourceBuilder )  ;", "request . add ( firstSearchRequest )  ;", "SearchRequest   secondSearchRequest    =    new   SearchRequest (  )  ;", "searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( QueryBuilders . matchQuery (  \" user \"  ,     \" luca \"  )  )  ;", "secondSearchRequest . source ( searchSourceBuilder )  ;", "request . add ( secondSearchRequest )  ;", "MultiSearchResponse   response    =    client . multiSearch ( request )  ;", "MultiSearchResponse . Item   firstResponse    =    response . getResponses (  )  [  0  ]  ;", "assertNull ( firstResponse . getFailure (  )  )  ;", "SearchResponse   searchResponse    =    firstResponse . getResponse (  )  ;", "assertEquals (  3  ,    searchResponse . getHits (  )  . getTotalHits (  )  )  ;", "MultiSearchResponse . Item   secondResponse    =    response . getResponses (  )  [  1  ]  ;", "assertNull ( secondResponse . getFailure (  )  )  ;", "searchResponse    =    secondResponse . getResponse (  )  ;", "assertEquals (  1  ,    searchResponse . getHits (  )  . getTotalHits (  )  )  ;", "ActionListener < MultiSearchResponse >    listener    =    new   ActionListener < MultiSearchResponse >  (  )     {", "@ Override", "public   void   onResponse ( MultiSearchResponse   response )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . multiSearchAsync ( request ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "MultiSearchRequest   request    =    new   MultiSearchRequest (  )  ;", "request . add ( new   SearchRequest (  \" posts \"  )  . types (  \" doc \"  )  )  ;", "MultiSearchResponse   response    =    client . multiSearch ( request )  ;", "MultiSearchResponse . Item   firstResponse    =    response . getResponses (  )  [  0  ]  ;", "assertNull ( firstResponse . getFailure (  )  )  ;", "SearchResponse   searchResponse    =    firstResponse . getResponse (  )  ;", "assertEquals (  3  ,    searchResponse . getHits (  )  . getTotalHits (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testMultiSearch"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" title \"  ,     \" In   which   order   are   my   Elasticsearch   queries   executed ?  \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" title \"  ,     \" Current   status   and   upcoming   changes   in   Elasticsearch \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" title \"  ,     \" The   Future   of   Federated   Search   in   Elasticsearch \"  )  )  ;", "request . setRefreshPolicy ( IMMEDIATE )  ;", "BulkResponse   bulkResponse    =    client . bulk ( request )  ;", "assertSame ( OK ,    bulkResponse . status (  )  )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "{", "int   size    =     1  ;", "SearchRequest   searchRequest    =    new   SearchRequest (  \" posts \"  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( QueryBuilders . matchQuery (  \" title \"  ,     \" Elasticsearch \"  )  )  ;", "searchSourceBuilder . size ( size )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "searchRequest . scroll ( TimeValue . timeValueMinutes (  1 L )  )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "String   scrollId    =    searchResponse . getScrollId (  )  ;", "SearchHits   hits    =    searchResponse . getHits (  )  ;", "assertEquals (  3  ,    hits . getTotalHits (  )  )  ;", "assertEquals (  1  ,    hits . getHits (  )  . length )  ;", "assertNotNull ( scrollId )  ;", "SearchScrollRequest   scrollRequest    =    new   SearchScrollRequest ( scrollId )  ;", "scrollRequest . scroll ( TimeValue . timeValueSeconds (  3  0  )  )  ;", "SearchResponse   searchScrollResponse    =    client . searchScroll ( scrollRequest )  ;", "scrollId    =    searchScrollResponse . getScrollId (  )  ;", "hits    =    searchScrollResponse . getHits (  )  ;", "assertEquals (  3  ,    hits . getTotalHits (  )  )  ;", "assertEquals (  1  ,    hits . getHits (  )  . length )  ;", "assertNotNull ( scrollId )  ;", "ClearScrollRequest   clearScrollRequest    =    new   ClearScrollRequest (  )  ;", "clearScrollRequest . addScrollId ( scrollId )  ;", "ClearScrollResponse   clearScrollResponse    =    client . clearScroll ( clearScrollRequest )  ;", "assertTrue ( clearScrollResponse . isSucceeded (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "searchRequest . scroll (  \"  6  0 s \"  )  ;", "SearchResponse   initialSearchResponse    =    client . search ( searchRequest )  ;", "String   scrollId    =    initialSearchResponse . getScrollId (  )  ;", "SearchScrollRequest   scrollRequest    =    new   SearchScrollRequest (  )  ;", "scrollRequest . scrollId ( scrollId )  ;", "scrollRequest . scroll ( TimeValue . timeValueSeconds (  6  0 L )  )  ;", "scrollRequest . scroll (  \"  6  0 s \"  )  ;", "SearchResponse   searchResponse    =    client . searchScroll ( scrollRequest )  ;", "assertEquals (  0  ,    searchResponse . getFailedShards (  )  )  ;", "assertEquals (  3 L ,    searchResponse . getHits (  )  . getTotalHits (  )  )  ;", "ActionListener < SearchResponse >    scrollListener    =    new   ActionListener < SearchResponse >  (  )     {", "@ Override", "public   void   onResponse ( SearchResponse   searchResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "scrollListener    =    new   action . LatchedActionListener ( scrollListener ,    latch )  ;", "client . searchScrollAsync ( scrollRequest ,    scrollListener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "ClearScrollRequest   request    =    new   ClearScrollRequest (  )  ;", "request . addScrollId ( scrollId )  ;", "request . addScrollId ( scrollId )  ;", "List < String >    scrollIds    =    Collections . singletonList ( scrollId )  ;", "request . setScrollIds ( scrollIds )  ;", "ClearScrollResponse   response    =    client . clearScroll ( request )  ;", "boolean   success    =    response . isSucceeded (  )  ;", "int   released    =    response . getNumFreed (  )  ;", "assertTrue ( success )  ;", "assertThat ( released ,    greaterThan (  0  )  )  ;", "ActionListener < ClearScrollResponse >    listener    =    new   ActionListener < ClearScrollResponse >  (  )     {", "@ Override", "public   void   onResponse ( ClearScrollResponse   clearScrollResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   clearScrollLatch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    clearScrollLatch )  ;", "client . clearScrollAsync ( request ,    listener )  ;", "assertTrue ( clearScrollLatch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "}", "{", "final   Scroll   scroll    =    new   Scroll ( TimeValue . timeValueMinutes (  1 L )  )  ;", "SearchRequest   searchRequest    =    new   SearchRequest (  \" posts \"  )  ;", "searchRequest . scroll ( scroll )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( QueryBuilders . matchQuery (  \" title \"  ,     \" Elasticsearch \"  )  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "String   scrollId    =    searchResponse . getScrollId (  )  ;", "SearchHit [  ]    searchHits    =    searchResponse . getHits (  )  . getHits (  )  ;", "while    (  ( searchHits    !  =    null )     &  &     (  ( searchHits . length )     >     0  )  )     {", "SearchScrollRequest   scrollRequest    =    new   SearchScrollRequest ( scrollId )  ;", "scrollRequest . scroll ( scroll )  ;", "searchResponse    =    client . searchScroll ( scrollRequest )  ;", "scrollId    =    searchResponse . getScrollId (  )  ;", "searchHits    =    searchResponse . getHits (  )  . getHits (  )  ;", "}", "ClearScrollRequest   clearScrollRequest    =    new   ClearScrollRequest (  )  ;", "clearScrollRequest . addScrollId ( scrollId )  ;", "ClearScrollResponse   clearScrollResponse    =    client . clearScroll ( clearScrollRequest )  ;", "boolean   succeeded    =    clearScrollResponse . isSucceeded (  )  ;", "assertTrue ( succeeded )  ;", "}", "}", "METHOD_END"], "methodName": ["testScroll"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "indexSearchTestData (  )  ;", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . query ( QueryBuilders . matchAllQuery (  )  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  \" posts \"  )  ;", "searchRequest . types (  \" doc \"  )  ;", "searchRequest . routing (  \" routing \"  )  ;", "searchRequest . indicesOptions ( IndicesOptions . lenientExpandOpen (  )  )  ;", "searchRequest . preference (  \"  _ local \"  )  ;", "assertNotNull ( client . search ( searchRequest )  )  ;", "}", "{", "SearchSourceBuilder   sourceBuilder    =    new   SearchSourceBuilder (  )  ;", "sourceBuilder . query ( QueryBuilders . termQuery (  \" user \"  ,     \" kimchy \"  )  )  ;", "sourceBuilder . from (  0  )  ;", "sourceBuilder . size (  5  )  ;", "sourceBuilder . timeout ( new   TimeValue (  6  0  ,    TimeUnit . SECONDS )  )  ;", "sourceBuilder . sort ( new   ScoreSortBuilder (  )  . order ( DESC )  )  ;", "sourceBuilder . sort ( new   FieldSortBuilder (  \"  _ id \"  )  . order ( ASC )  )  ;", "sourceBuilder . fetchSource ( false )  ;", "String [  ]    includeFields    =    new   String [  ]  {     \" title \"  ,     \" user \"  ,     \" innerObject .  *  \"     }  ;", "String [  ]    excludeFields    =    new   String [  ]  {     \"  _ type \"     }  ;", "sourceBuilder . fetchSource ( includeFields ,    excludeFields )  ;", "sourceBuilder . fetchSource ( true )  ;", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "searchRequest . source ( sourceBuilder )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "ActionListener < SearchResponse >    listener    =    new   ActionListener < SearchResponse >  (  )     {", "@ Override", "public   void   onResponse ( SearchResponse   searchResponse )     {", "}", "@ Override", "public   void   onFailure ( Exception   e )     {", "}", "}  ;", "final   CountDownLatch   latch    =    new   CountDownLatch (  1  )  ;", "listener    =    new   action . LatchedActionListener ( listener ,    latch )  ;", "client . searchAsync ( searchRequest ,    listener )  ;", "assertTrue ( latch . await (  3  0 L ,    TimeUnit . SECONDS )  )  ;", "RestStatus   status    =    searchResponse . status (  )  ;", "TimeValue   took    =    searchResponse . getTook (  )  ;", "Boolean   terminatedEarly    =    searchResponse . isTerminatedEarly (  )  ;", "boolean   timedOut    =    searchResponse . isTimedOut (  )  ;", "int   totalShards    =    searchResponse . getTotalShards (  )  ;", "int   successfulShards    =    searchResponse . getSuccessfulShards (  )  ;", "int   failedShards    =    searchResponse . getFailedShards (  )  ;", "for    ( ShardSearchFailure   failure    :    searchResponse . getShardFailures (  )  )     {", "}", "assertNotNull ( searchResponse )  ;", "SearchHits   hits    =    searchResponse . getHits (  )  ;", "long   totalHits    =    hits . getTotalHits (  )  ;", "float   maxScore    =    hits . getMaxScore (  )  ;", "SearchHit [  ]    searchHits    =    hits . getHits (  )  ;", "for    ( SearchHit   hit    :    searchHits )     {", "}", "for    ( SearchHit   hit    :    searchHits )     {", "String   index    =    hit . getIndex (  )  ;", "String   type    =    hit . getType (  )  ;", "String   id    =    hit . getId (  )  ;", "float   score    =    hit . getScore (  )  ;", "String   sourceAsString    =    hit . getSourceAsString (  )  ;", "Map < String ,    Object >    sourceAsMap    =    hit . getSourceAsMap (  )  ;", "String   documentTitle    =     (  ( String )     ( sourceAsMap . get (  \" title \"  )  )  )  ;", "List < Object >    users    =     (  ( List < Object >  )     ( sourceAsMap . get (  \" user \"  )  )  )  ;", "Map < String ,    Object >    innerObject    =     (  ( Map < String ,    Object >  )     ( sourceAsMap . get (  \" innerObject \"  )  )  )  ;", "}", "assertEquals (  3  ,    totalHits )  ;", "assertNotNull ( hits . getHits (  )  [  0  ]  . getSourceAsString (  )  )  ;", "assertNotNull ( hits . getHits (  )  [  0  ]  . getSourceAsMap (  )  . get (  \" title \"  )  )  ;", "assertNotNull ( hits . getHits (  )  [  0  ]  . getSourceAsMap (  )  . get (  \" user \"  )  )  ;", "assertNotNull ( hits . getHits (  )  [  0  ]  . getSourceAsMap (  )  . get (  \" innerObject \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearch"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" company \"  ,     \" Elastic \"  ,     \" age \"  ,     2  0  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" company \"  ,     \" Elastic \"  ,     \" age \"  ,     3  0  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" company \"  ,     \" Elastic \"  ,     \" age \"  ,     4  0  )  )  ;", "request . setRefreshPolicy ( IMMEDIATE )  ;", "BulkResponse   bulkResponse    =    client . bulk ( request )  ;", "assertSame ( OK ,    bulkResponse . status (  )  )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "TermsAggregationBuilder   aggregation    =    AggregationBuilders . terms (  \" by _ company \"  )  . field (  \" company . keyword \"  )  ;", "aggregation . subAggregation ( AggregationBuilders . avg (  \" average _ age \"  )  . field (  \" age \"  )  )  ;", "searchSourceBuilder . aggregation ( aggregation )  ;", "searchSourceBuilder . query ( QueryBuilders . matchAllQuery (  )  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "{", "Aggregations   aggregations    =    searchResponse . getAggregations (  )  ;", "Terms   byCompanyAggregation    =    aggregations . get (  \" by _ company \"  )  ;", "Bucket   elasticBucket    =    byCompanyAggregation . getBucketByKey (  \" Elastic \"  )  ;", "Avg   averageAge    =    elasticBucket . getAggregations (  )  . get (  \" average _ age \"  )  ;", "double   avg    =    averageAge . getValue (  )  ;", "try    {", "Range   range    =    aggregations . get (  \" by _ company \"  )  ;", "}    catch    ( ClassCastException   ex )     {", "assertEquals (  (  \" search . aggregations . bucket . terms . ParsedStringTerms \"     +     \"    cannot   be   cast   to   search . aggregations . bucket . range . Range \"  )  ,    ex . getMessage (  )  )  ;", "}", "assertEquals (  3  ,    elasticBucket . getDocCount (  )  )  ;", "assertEquals (  3  0  ,    avg ,     0  .  0  )  ;", "}", "Aggregations   aggregations    =    searchResponse . getAggregations (  )  ;", "{", "Map < String ,    Aggregation >    aggregationMap    =    aggregations . getAsMap (  )  ;", "Terms   companyAggregation    =     (  ( Terms )     ( aggregationMap . get (  \" by _ company \"  )  )  )  ;", "}", "{", "List < Aggregation >    aggregationList    =    aggregations . asList (  )  ;", "}", "{", "for    ( Aggregation   agg    :    aggregations )     {", "String   type    =    agg . getType (  )  ;", "if    ( type . equals ( NAME )  )     {", "Bucket   elasticBucket    =     (  ( Terms )     ( agg )  )  . getBucketByKey (  \" Elastic \"  )  ;", "long   numberOfDocs    =    elasticBucket . getDocCount (  )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testSearchRequestAggregations"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" title \"  ,     \" In   which   order   are   my   E   queries   executed ?  \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" luca \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" title \"  ,     \" Current   status   and   upcoming   changes   in   E \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" christoph \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" title \"  ,     \" The   Future   of   Federated   Search   in   E \"  ,     \" user \"  ,    Arrays . asList (  \" kimchy \"  ,     \" tanguy \"  )  ,     \" innerObject \"  ,    Collections . singletonMap (  \" key \"  ,     \" value \"  )  )  )  ;", "request . setRefreshPolicy ( IMMEDIATE )  ;", "BulkResponse   bulkResponse    =    client . bulk ( request )  ;", "assertSame ( OK ,    bulkResponse . status (  )  )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "HighlightBuilder   highlightBuilder    =    new   HighlightBuilder (  )  ;", "HighlightBuilder . Field   highlightTitle    =    new   HighlightBuilder . Field (  \" title \"  )  ;", "highlightTitle . highlighterType (  \" unified \"  )  ;", "highlightBuilder . field ( highlightTitle )  ;", "HighlightBuilder . Field   highlightUser    =    new   HighlightBuilder . Field (  \" user \"  )  ;", "highlightBuilder . field ( highlightUser )  ;", "searchSourceBuilder . highlighter ( highlightBuilder )  ;", "searchSourceBuilder . query ( QueryBuilders . boolQuery (  )  . should ( QueryBuilders . matchQuery (  \" title \"  ,     \" E \"  )  )  . should ( QueryBuilders . matchQuery (  \" user \"  ,     \" kimchy \"  )  )  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "{", "SearchHits   hits    =    searchResponse . getHits (  )  ;", "for    ( SearchHit   hit    :    hits . getHits (  )  )     {", "Map < String ,    HighlightField >    highlightFields    =    hit . getHighlightFields (  )  ;", "HighlightField   highlight    =    highlightFields . get (  \" title \"  )  ;", "Text [  ]    fragments    =    highlight . fragments (  )  ;", "String   fragmentString    =    fragments [  0  ]  . string (  )  ;", "}", "hits    =    searchResponse . getHits (  )  ;", "for    ( SearchHit   hit    :    hits . getHits (  )  )     {", "Map < String ,    HighlightField >    highlightFields    =    hit . getHighlightFields (  )  ;", "HighlightField   highlight    =    highlightFields . get (  \" title \"  )  ;", "Text [  ]    fragments    =    highlight . fragments (  )  ;", "assertEquals (  1  ,    fragments . length )  ;", "assertThat ( fragments [  0  ]  . string (  )  ,    containsString (  \"  < em > E <  / em >  \"  )  )  ;", "highlight    =    highlightFields . get (  \" user \"  )  ;", "fragments    =    highlight . fragments (  )  ;", "assertEquals (  1  ,    fragments . length )  ;", "assertThat ( fragments [  0  ]  . string (  )  ,    containsString (  \"  < em > kimchy <  / em >  \"  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testSearchRequestHighlighting"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient   client    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "IndexRequest   request    =    new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" tags \"  ,     \"  \"  ,     \" comments \"  ,     1  2  3  )  ;", "request . setRefreshPolicy ( WAIT _ UNTIL )  ;", "IndexResponse   indexResponse    =    client . index ( request )  ;", "assertSame ( CREATED ,    indexResponse . status (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "searchSourceBuilder . profile ( true )  ;", "searchSourceBuilder . query ( QueryBuilders . termQuery (  \" tags \"  ,     \"  \"  )  )  ;", "searchSourceBuilder . aggregation ( AggregationBuilders . histogram (  \" by _ comments \"  )  . field (  \" comments \"  )  . interval (  1  0  0  )  )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    client . search ( searchRequest )  ;", "Map < String ,    ProfileShardResult >    profilingResults    =    searchResponse . getProfileResults (  )  ;", "for    ( Map . Entry < String ,    ProfileShardResult >    profilingResult    :    profilingResults . entrySet (  )  )     {", "String   key    =    profilingResult . getKey (  )  ;", "ProfileShardResult   profileShardResult    =    profilingResult . getValue (  )  ;", "}", "ProfileShardResult   profileShardResult    =    profilingResults . values (  )  . iterator (  )  . next (  )  ;", "assertNotNull ( profileShardResult )  ;", "List < QueryProfileShardResult >    queryProfileShardResults    =    profileShardResult . getQueryProfileResults (  )  ;", "for    ( QueryProfileShardResult   queryProfileResult    :    queryProfileShardResults )     {", "}", "assertThat ( queryProfileShardResults . size (  )  ,    equalTo (  1  )  )  ;", "for    ( QueryProfileShardResult   queryProfileResult    :    queryProfileShardResults )     {", "for    ( ProfileResult   profileResult    :    queryProfileResult . getQueryResults (  )  )     {", "String   queryName    =    profileResult . getQueryName (  )  ;", "long   queryTimeInMillis    =    profileResult . getTime (  )  ;", "List < ProfileResult >    profiledChildren    =    profileResult . getProfiledChildren (  )  ;", "}", "CollectorResult   collectorResult    =    queryProfileResult . getCollectorResult (  )  ;", "String   collectorName    =    collectorResult . getName (  )  ;", "Long   collectorTimeInMillis    =    collectorResult . getTime (  )  ;", "List < CollectorResult >    profiledChildren    =    collectorResult . getProfiledChildren (  )  ;", "}", "AggregationProfileShardResult   aggsProfileResults    =    profileShardResult . getAggregationProfileResults (  )  ;", "for    ( ProfileResult   profileResult    :    aggsProfileResults . getProfileResults (  )  )     {", "String   aggName    =    profileResult . getQueryName (  )  ;", "long   aggTimeInMillis    =    profileResult . getTime (  )  ;", "List < ProfileResult >    profiledChildren    =    profileResult . getProfiledChildren (  )  ;", "}", "assertThat ( aggsProfileResults . getProfileResults (  )  . size (  )  ,    equalTo (  1  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSearchRequestProfiling"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "RestHighLevelClient    =    ESRestHighLevelClientTestCase . highLevelClient (  )  ;", "{", "BulkRequest   request    =    new   BulkRequest (  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  1  \"  )  . source ( JSON ,     \" user \"  ,     \" kimchy \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  2  \"  )  . source ( JSON ,     \" user \"  ,     \" javanna \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  3  \"  )  . source ( JSON ,     \" user \"  ,     \" tlrx \"  )  )  ;", "request . add ( new   IndexRequest (  \" posts \"  ,     \" doc \"  ,     \"  4  \"  )  . source ( JSON ,     \" user \"  ,     \" cbuescher \"  )  )  ;", "request . setRefreshPolicy ( IMMEDIATE )  ;", "BulkResponse   bulkResponse    =    bulk ( request )  ;", "assertSame ( OK ,    bulkResponse . status (  )  )  ;", "assertFalse ( bulkResponse . hasFailures (  )  )  ;", "}", "{", "SearchRequest   searchRequest    =    new   SearchRequest (  )  ;", "SearchSourceBuilder   searchSourceBuilder    =    new   SearchSourceBuilder (  )  ;", "SuggestionBuilder   termSuggestionBuilder    =    SuggestBuilders . termSuggestion (  \" user \"  )  . text (  \" kmichy \"  )  ;", "SuggestBuilder   suggestBuilder    =    new   SuggestBuilder (  )  ;", "suggestBuilder . addSuggestion (  \" suggest _ user \"  ,    termSuggestionBuilder )  ;", "searchSourceBuilder . suggest ( suggestBuilder )  ;", "searchRequest . source ( searchSourceBuilder )  ;", "SearchResponse   searchResponse    =    search ( searchRequest )  ;", "{", "Suggest   suggest    =    searchResponse . getSuggest (  )  ;", "TermSuggestion   termSuggestion    =    suggest . getSuggestion (  \" suggest _ user \"  )  ;", "for    ( TermSuggestion . Entry   entry    :    termSuggestion . getEntries (  )  )     {", "for    ( TermSuggestion . Entry . Option   option    :    entry )     {", "String   suggestText    =    option . getText (  )  . string (  )  ;", "}", "}", "assertEquals (  1  ,    termSuggestion . getEntries (  )  . size (  )  )  ;", "assertEquals (  1  ,    termSuggestion . getEntries (  )  . get (  0  )  . getOptions (  )  . size (  )  )  ;", "assertEquals (  \" kimchy \"  ,    termSuggestion . getEntries (  )  . get (  0  )  . getOptions (  )  . get (  0  )  . getText (  )  . string (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSearchRequestSuggestions"], "fileName": "org.elasticsearch.client.documentation.SearchDocumentationIT"}, {"methodBody": ["METHOD_START", "{", "HttpHost   httpHost    =    null ;", "String   fieldName    =    null ;", "while    (  ( parser . nextToken (  )  )     !  =     ( JsonToken . END _ OBJECT )  )     {", "if    (  ( parser . getCurrentToken (  )  )     =  =     ( JsonToken . FIELD _ NAME )  )     {", "fieldName    =    parser . getCurrentName (  )  ;", "} else", "if    (  ( parser . getCurrentToken (  )  )     =  =     ( JsonToken . START _ OBJECT )  )     {", "if    (  \" http \"  . equals ( fieldName )  )     {", "while    (  ( parser . nextToken (  )  )     !  =     ( JsonToken . END _ OBJECT )  )     {", "if    (  (  ( parser . getCurrentToken (  )  )     =  =     ( JsonToken . VALUE _ STRING )  )     &  &     (  \" publish _ address \"  . equals ( parser . getCurrentName (  )  )  )  )     {", "URI   boundAddressAsURI    =    create (  (  ( scheme    +     \"  :  /  /  \"  )     +     ( parser . getValueAsString (  )  )  )  )  ;", "httpHost    =    new   HttpHost ( boundAddressAsURI . getHost (  )  ,    boundAddressAsURI . getPort (  )  ,    boundAddressAsURI . getScheme (  )  )  ;", "} else", "if    (  ( parser . getCurrentToken (  )  )     =  =     ( JsonToken . START _ OBJECT )  )     {", "parser . skipChildren (  )  ;", "}", "}", "} else    {", "parser . skipChildren (  )  ;", "}", "}", "}", "if    ( httpHost    =  =    null )     {", ". logger . debug (  (  (  \" skipping   node    [  \"     +    nodeId )     +     \"  ]    with   http   disabled \"  )  )  ;", "return   null ;", "}", "return   httpHost ;", "}", "METHOD_END"], "methodName": ["readHost"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSniffer"}, {"methodBody": ["METHOD_START", "{", "try    ( InputStream   inputStream    =    entity . getContent (  )  )     {", "JsonParser   parser    =    jsonFactory . createParser ( inputStream )  ;", "if    (  ( parser . nextToken (  )  )     !  =     ( JsonToken . START _ OBJECT )  )     {", "throw   new   IOException (  \" expected   data   to   start   with   an   object \"  )  ;", "}", "List < HttpHost >    hosts    =    new   ArrayList <  >  (  )  ;", "while    (  ( parser . nextToken (  )  )     !  =     ( JsonToken . END _ OBJECT )  )     {", "if    (  ( parser . getCurrentToken (  )  )     =  =     ( JsonToken . START _ OBJECT )  )     {", "if    (  \" nodes \"  . equals ( parser . getCurrentName (  )  )  )     {", "while    (  ( parser . nextToken (  )  )     !  =     ( JsonToken . END _ OBJECT )  )     {", "JsonToken   token    =    parser . nextToken (  )  ;", "assert   token    =  =     ( JsonToken . START _ OBJECT )  ;", "String   nodeId    =    parser . getCurrentName (  )  ;", "HttpHost   sniffedHost    =     . readHost ( nodeId ,    parser ,    this . scheme )  ;", "if    ( sniffedHost    !  =    null )     {", ". logger . trace (  (  (  \" adding   node    [  \"     +    nodeId )     +     \"  ]  \"  )  )  ;", "hosts . add ( sniffedHost )  ;", "}", "}", "} else    {", "parser . skipChildren (  )  ;", "}", "}", "}", "return   hosts ;", "}", "}", "METHOD_END"], "methodName": ["readHosts"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSniffer"}, {"methodBody": ["METHOD_START", "{", "Response   response    =    restClient . performRequest (  \" get \"  ,     \"  /  _ nodes / http \"  ,    sniffRequestParams )  ;", "return   readHosts ( response . getEntity (  )  )  ;", "}", "METHOD_END"], "methodName": ["sniffHosts"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSniffer"}, {"methodBody": ["METHOD_START", "{", "int   numNodes    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,     5  )  ;", "List < HttpHost >    hosts    =    new   ArrayList <  >  ( numNodes )  ;", "JsonFactory   jsonFactory    =    new   JsonFactory (  )  ;", "StringWriter   writer    =    new   StringWriter (  )  ;", "JsonGenerator   generator    =    jsonFactory . createGenerator ( writer )  ;", "generator . writeStartObject (  )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeStringField (  \" cluster _ name \"  ,     \" elasticsearch \"  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeObjectFieldStart (  \" bogus _ object \"  )  ;", "generator . writeEndObject (  )  ;", "}", "generator . writeObjectFieldStart (  \" nodes \"  )  ;", "for    ( int   i    =     0  ;    i    <    numNodes ;    i +  +  )     {", "String   nodeId    =    RandomStrings . randomAsciiOfLengthBetween ( getRandom (  )  ,     5  ,     1  0  )  ;", "generator . writeObjectFieldStart ( nodeId )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeObjectFieldStart (  \" bogus _ object \"  )  ;", "generator . writeEndObject (  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeArrayFieldStart (  \" bogus _ array \"  )  ;", "generator . writeStartObject (  )  ;", "generator . writeEndObject (  )  ;", "generator . writeEndArray (  )  ;", "}", "boolean   isHttpEnabled    =     ( rarely (  )  )     =  =    false ;", "if    ( isHttpEnabled )     {", "String   host    =     \" host \"     +    i ;", "int   port    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     9  2  0  0  ,     9  2  9  9  )  ;", "HttpHost   httpHost    =    new   HttpHost ( host ,    port ,    scheme . toString (  )  )  ;", "hosts . add ( httpHost )  ;", "generator . writeObjectFieldStart (  \" http \"  )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeArrayFieldStart (  \" bound _ address \"  )  ;", "generator . writeString (  (  \"  [ fe 8  0  :  :  1  ]  :  \"     +    port )  )  ;", "generator . writeString (  (  \"  [  :  :  1  ]  :  \"     +    port )  )  ;", "generator . writeString (  (  \"  1  2  7  .  0  .  0  .  1  :  \"     +    port )  )  ;", "generator . writeEndArray (  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeObjectFieldStart (  \" bogus _ object \"  )  ;", "generator . writeEndObject (  )  ;", "}", "generator . writeStringField (  \" publish _ address \"  ,    httpHost . toHostString (  )  )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "generator . writeNumberField (  \" max _ content _ length _ in _ bytes \"  ,     1  0  4  8  5  7  6  0  0  )  ;", "}", "generator . writeEndObject (  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "String [  ]    roles    =    new   String [  ]  {     \" master \"  ,     \" data \"  ,     \" ingest \"     }  ;", "int   numRoles    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     0  ,     3  )  ;", "Set < String >    nodeRoles    =    new   HashSet <  >  ( numRoles )  ;", "for    ( int   j    =     0  ;    j    <    numRoles ;    j +  +  )     {", "String   role ;", "do    {", "role    =    RandomPicks . randomFrom ( getRandom (  )  ,    roles )  ;", "}    while    (  ( nodeRoles . add ( role )  )     =  =    false    )  ;", "}", "generator . writeArrayFieldStart (  \" roles \"  )  ;", "for    ( String   nodeRole    :    nodeRoles )     {", "generator . writeString ( nodeRole )  ;", "}", "generator . writeEndArray (  )  ;", "}", "int   numAttributes    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     0  ,     3  )  ;", "Map < String ,    String >    attributes    =    new   HashMap <  >  ( numAttributes )  ;", "for    ( int   j    =     0  ;    j    <    numAttributes ;    j +  +  )     {", "attributes . put (  (  \" attr \"     +    j )  ,     (  \" value \"     +    j )  )  ;", "}", "if    ( numAttributes    >     0  )     {", "generator . writeObjectFieldStart (  \" attributes \"  )  ;", "}", "for    ( Map . Entry < String ,    String >    entry    :    attributes . entrySet (  )  )     {", "generator . writeStringField ( entry . getKey (  )  ,    entry . getValue (  )  )  ;", "}", "if    ( numAttributes    >     0  )     {", "generator . writeEndObject (  )  ;", "}", "generator . writeEndObject (  )  ;", "}", "generator . writeEndObject (  )  ;", "generator . writeEndObject (  )  ;", "generator . close (  )  ;", "return    . SniffResponse . buildResponse ( writer . toString (  )  ,    hosts )  ;", "}", "METHOD_END"], "methodName": ["buildSniffResponse"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "HttpServer   httpServer    =    MockHttpServer . createHttp ( new   InetSocketAddress ( InetAddress . getLoopbackAddress (  )  ,     0  )  ,     0  )  ;", "httpServer . createContext (  \"  /  _ nodes / http \"  ,    new    . ResponseHandler ( sniffTimeoutMillis ,    sniffResponse )  )  ;", "return   httpServer ;", "}", "METHOD_END"], "methodName": ["createHttpServer"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "return   RandomNumbers . randomIntBetween ( getRandom (  )  ,     4  0  0  ,     5  9  9  )  ;", "}", "METHOD_END"], "methodName": ["randomErrorResponseCode"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "this . sniffRequestTimeout    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  0  0  0  ,     1  0  0  0  0  )  ;", "this . scheme    =    RandomPicks . randomFrom ( getRandom (  )  ,    ElasticsearchHostsSniffer . Scheme . values (  )  )  ;", "if    ( rarely (  )  )     {", "this . sniffResponse    =     . SniffResponse . buildFailure (  )  ;", "} else    {", "this . sniffResponse    =     . buildSniffResponse ( scheme )  ;", "}", "this . httpServer    =     . createHttpServer ( sniffResponse ,    sniffRequestTimeout )  ;", "this . httpServer . start (  )  ;", "}", "METHOD_END"], "methodName": ["startHttpServer"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "httpServer . stop (  0  )  ;", "}", "METHOD_END"], "methodName": ["stopHttpServer"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "try    {", "new    ( null ,     1  ,     . Scheme . HTTP )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" restClient   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "HttpHost   httpHost    =    new   HttpHost ( httpServer . getAddress (  )  . getHostString (  )  ,    httpServer . getAddress (  )  . getPort (  )  )  ;", "try    ( RestClient   restClient    =    RestClient . builder ( httpHost )  . build (  )  )     {", "try    {", "new    ( restClient ,     1  ,    null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals ( e . getMessage (  )  ,     \" scheme   cannot   be   null \"  )  ;", "}", "try    {", "new    ( restClient ,    RandomNumbers . randomIntBetween ( getRandom (  )  ,    Integer . MIN _ VALUE ,     0  )  ,     . Scheme . HTTP )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals ( e . getMessage (  )  ,     \" sniffRequestTimeoutMillis   must   be   greater   than    0  \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testConstructorValidation"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "HttpHost   httpHost    =    new   HttpHost ( httpServer . getAddress (  )  . getHostString (  )  ,    httpServer . getAddress (  )  . getPort (  )  )  ;", "try    ( RestClient   restClient    =    RestClient . builder ( httpHost )  . build (  )  )     {", "sniffer    =    new    ( restClient ,    sniffRequestTimeout ,    scheme )  ;", "try    {", "List < HttpHost >    sniffedHosts    =    sniffer . sniffHosts (  )  ;", "if    ( sniffResponse . isFailure )     {", "fail (  \" sniffNodes   should   have   failed \"  )  ;", "}", "assertThat ( sniffedHosts . size (  )  ,    equalTo ( sniffResponse . hosts . size (  )  )  )  ;", "Iterator < HttpHost >    responseHostsIterator    =    sniffResponse . hosts . iterator (  )  ;", "for    ( HttpHost   sniffedHost    :    sniffedHosts )     {", "assertEquals ( sniffedHost ,    responseHostsIterator . next (  )  )  ;", "}", "}    catch    ( ResponseException   e )     {", "Response   response    =    e . getResponse (  )  ;", "if    ( sniffResponse . isFailure )     {", "final   String   errorPrefix    =     (  (  (  \" method    [ GET ]  ,    host    [  \"     +    httpHost )     +     \"  ]  ,    URI    [  /  _ nodes / http ? timeout =  \"  )     +     ( sniffRequestTimeout )  )     +     \" ms ]  ,    status   line    [ HTTP /  1  .  1  \"  ;", "assertThat ( e . getMessage (  )  ,    startsWith ( errorPrefix )  )  ;", "assertThat ( e . getMessage (  )  ,    containsString ( Integer . toString ( sniffResponse . nodesInfoResponseCode )  )  )  ;", "assertThat ( response . getHost (  )  ,    equalTo ( httpHost )  )  ;", "assertThat ( response . getStatusLine (  )  . getStatusCode (  )  ,    equalTo ( sniffResponse . nodesInfoResponseCode )  )  ;", "assertThat ( response . getRequestLine (  )  . toString (  )  ,    equalTo (  (  (  \" GET    /  _ nodes / http ? timeout =  \"     +     ( sniffRequestTimeout )  )     +     \" ms   HTTP /  1  .  1  \"  )  )  )  ;", "} else    {", "fail (  (  \" sniffNodes   should   have   succeeded :     \"     +     ( response . getStatusLine (  )  )  )  )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["testSniffNodes"], "fileName": "org.elasticsearch.client.sniff.ElasticsearchHostsSnifferTests"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNuller ,    er   must   not   be   null \"  )  ;", "if    ( set . compareAndSet ( false ,    true )  )     {", "thiser    = er ;", "} else    {", "throw   new   IllegalStateException ( er   can   only   be   set   once \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSniffer"], "fileName": "org.elasticsearch.client.sniff.SniffOnFailureListener"}, {"methodBody": ["METHOD_START", "{", "SniffOnFailureListener   listener    =    new   SniffOnFailureListener (  )  ;", "try    {", "listener . onFailure ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals (  \" sniffer   was   not   set ,    unable   to   sniff   on   failure \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "listener . setSniffer ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" sniffer   must   not   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    ( RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . build (  )  )     {", "try    ( Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setHostsSniffer ( new   MockHostsSniffer (  )  )  . build (  )  )     {", "listener . setSniffer ( sniffer )  ;", "try    {", "listener . setSniffer ( sniffer )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalStateException   e )     {", "assertEquals (  \" sniffer   can   only   be   set   once \"  ,    e . getMessage (  )  )  ;", "}", "listener . onFailure ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testSetSniffer"], "fileName": "org.elasticsearch.client.sniff.SniffOnFailureListenerTests"}, {"methodBody": ["METHOD_START", "{", "return   new   SnifferBuilder ( restClient )  ;", "}", "METHOD_END"], "methodName": ["builder"], "fileName": "org.elasticsearch.client.sniff.Sniffer"}, {"methodBody": ["METHOD_START", "{", "this . task . sniffOnFailure ( failedHost )  ;", "}", "METHOD_END"], "methodName": ["sniffOnFailure"], "fileName": "org.elasticsearch.client.sniff.Sniffer"}, {"methodBody": ["METHOD_START", "{", "if    (  ( hostsSniffer )     =  =    null )     {", "this . hostsSniffer    =    new   EHostsSniffer ( restClient )  ;", "}", "return   new   Sniffer ( restClient ,    hostsSniffer ,    sniffIntervalMillis ,    sniffAfterFailureDelayMillis )  ;", "}", "METHOD_END"], "methodName": ["build"], "fileName": "org.elasticsearch.client.sniff.SnifferBuilder"}, {"methodBody": ["METHOD_START", "{", "Objects . requireNonNull ( hostsSniffer ,     \" hostsSniffer   cannot   be   null \"  )  ;", "this . hostsSniffer    =    hostsSniffer ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setHostsSniffer"], "fileName": "org.elasticsearch.client.sniff.SnifferBuilder"}, {"methodBody": ["METHOD_START", "{", "if   AfterFailureDelayMillis    <  =     0  )     {", "throw   new   IllegalArgumentException ( AfterFailureDelayMillis   must   be   greater   than    0  \"  )  ;", "}", "thisAfterFailureDelayMillis    = AfterFailureDelayMillis ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSniffAfterFailureDelayMillis"], "fileName": "org.elasticsearch.client.sniff.SnifferBuilder"}, {"methodBody": ["METHOD_START", "{", "if   IntervalMillis    <  =     0  )     {", "throw   new   IllegalArgumentException ( IntervalMillis   must   be   greater   than    0  \"  )  ;", "}", "thisIntervalMillis    = IntervalMillis ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSniffIntervalMillis"], "fileName": "org.elasticsearch.client.sniff.SnifferBuilder"}, {"methodBody": ["METHOD_START", "{", "int   numNodes    =    RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,     5  )  ;", "HttpHost [  ]    hosts    =    new   HttpHost [ numNodes ]  ;", "for    ( int   i    =     0  ;    i    <    numNodes ;    i +  +  )     {", "hosts [ i ]     =    new   HttpHost (  \" localhost \"  ,     (  9  2  0  0     +    i )  )  ;", "}", "try    ( RestClient   client    =    RestClient . builder ( hosts )  . build (  )  )     {", "try    {", "Sniffer . builder ( null )  . build (  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" restClient   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "Sniffer . builder ( client )  . setSniffIntervalMillis ( RandomNumbers . randomIntBetween ( getRandom (  )  ,    Integer . MIN _ VALUE ,     0  )  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" sniffIntervalMillis   must   be   greater   than    0  \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "Sniffer . builder ( client )  . setSniffAfterFailureDelayMillis ( RandomNumbers . randomIntBetween ( getRandom (  )  ,    Integer . MIN _ VALUE ,     0  )  )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "assertEquals (  \" sniffAfterFailureDelayMillis   must   be   greater   than    0  \"  ,    e . getMessage (  )  )  ;", "}", "try    {", "Sniffer . builder ( client )  . setHostsSniffer ( null )  ;", "fail (  \" should   have   failed \"  )  ;", "}    catch    ( NullPointerException   e )     {", "assertEquals (  \" hostsSniffer   cannot   be   null \"  ,    e . getMessage (  )  )  ;", "}", "try    ( Sniffer   sniffer    =    Sniffer . builder ( client )  . build (  )  )     {", "assertNotNull ( sniffer )  ;", "}", "builder    =    Sniffer . builder ( client )  ;", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "builder . setSniffIntervalMillis ( RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,    Integer . MAX _ VALUE )  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "builder . setSniffAfterFailureDelayMillis ( RandomNumbers . randomIntBetween ( getRandom (  )  ,     1  ,    Integer . MAX _ VALUE )  )  ;", "}", "if    ( getRandom (  )  . nextBoolean (  )  )     {", "builder . setHostsSniffer ( new   MockHostsSniffer (  )  )  ;", "}", "try    ( Sniffer   sniffer    =    builder . build (  )  )     {", "assertNotNull ( sniffer )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testBuild"], "fileName": "org.elasticsearch.client.sniff.SnifferBuilderTests"}, {"methodBody": ["METHOD_START", "{", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  . build (  )  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . build (  )  ;", "sniffer . close (  )  ;", "restClient . close (  )  ;", "}", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  . build (  )  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setSniffIntervalMillis (  6  0  0  0  0  )  . build (  )  ;", "}", "{", "SniffOnFailureListener   sniffOnFailureListener    =    new   SniffOnFailureListener (  )  ;", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  )  )  . setFailureListener ( sniffOnFailureListener )  . build (  )  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setSniffAfterFailureDelayMillis (  3  0  0  0  0  )  . build (  )  ;", "sniffOnFailureListener . setSniffer ( sniffer )  ;", "}", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  . build (  )  ;", "HostsSniffer   hostsSniffer    =    new   EHostsSniffer ( restClient ,    EHostsSniffer . DEFAULT _ SNIFF _ REQUEST _ TIMEOUT ,    EHostsSniffer . Scheme . HTTPS )  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setHostsSniffer ( hostsSniffer )  . build (  )  ;", "}", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  . build (  )  ;", "HostsSniffer   hostsSniffer    =    new   EHostsSniffer ( restClient ,    TimeUnit . SECONDS . toMillis (  5  )  ,    EHostsSniffer . Scheme . HTTP )  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setHostsSniffer ( hostsSniffer )  . build (  )  ;", "}", "{", "RestClient   restClient    =    RestClient . builder ( new   HttpHost (  \" localhost \"  ,     9  2  0  0  ,     \" http \"  )  )  . build (  )  ;", "HostsSniffer   hostsSniffer    =    new   HostsSniffer (  )     {", "@ Override", "public   List < HttpHost >    sniffHosts (  )    throws   IOException    {", "return   null ;", "}", "}  ;", "Sniffer   sniffer    =    Sniffer . builder ( restClient )  . setHostsSniffer ( hostsSniffer )  . build (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUsage"], "fileName": "org.elasticsearch.client.sniff.documentation.SnifferDocumentation"}, {"methodBody": ["METHOD_START", "{", "request . add ( data ,    from ,    length ,    defaultIndex ,    defaultType ,    xContentType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . add ( data ,    from ,    length ,    null ,    null ,    xContentType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request . request (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request . request (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "super . request . add ( request . request (  )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["add"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   request . numberOfActions (  )  ;", "}", "METHOD_END"], "methodName": ["numberOfActions"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . timeout ( timeout )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . timeout ( timeout )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "return   setWaitForActiveShards ( ActiveShardCount . from ( waitForActiveShards )  )  ;", "}", "METHOD_END"], "methodName": ["setWaitForActiveShards"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . waitForActiveShards ( waitForActiveShards )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setWaitForActiveShards"], "fileName": "org.elasticsearch.plugin.noop.action.bulk.NoopBulkRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . aggregation ( aggregation )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAggregation"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . aggregation ( aggregation )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addAggregation"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . docValueField ( name )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addDocValueField"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . indexBoost ( index ,    indexBoost )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addIndexBoost"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . addRescorer ( rescorer )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addRescorer"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . addRescorer ( rescorer . windowSize ( window )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addRescorer"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . scriptField ( name ,    script )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addScriptField"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . sort ( field ,    order )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addSort"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . sort ( sort )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addSort"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . storedField ( field )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["addStoredField"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . clearRescorers (  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["clearRescorers"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . highlighter ( highlightBuilder )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["highlighter"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . searchAfter ( values )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["searchAfter"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . explain ( explain )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setExplain"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . fetchSource ( fetch )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFetchSource"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . fetchSource ( include ,    exclude )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFetchSource"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . fetchSource ( includes ,    excludes )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFetchSource"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . from ( from )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setFrom"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . indices ( indices )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIndices"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request (  )  . indicesOptions ( indicesOptions )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIndicesOptions"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . minScore ( minScore )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setMinScore"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . postFilter ( postFilter )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPostFilter"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . preference ( preference )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPreference"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . profile ( profile )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setProfile"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . query ( queryBuilder )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setQuery"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . requestCache ( requestCache )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRequestCache"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . clearRescorers (  )  ;", "return   addRescorer ( rescorer )  ;", "}", "METHOD_END"], "methodName": ["setRescorer"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . clearRescorers (  )  ;", "return   addRescorer ( rescorer . windowSize ( window )  )  ;", "}", "METHOD_END"], "methodName": ["setRescorer"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . routing ( routing )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRouting"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . routing ( routing )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRouting"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . scroll ( keepAlive )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScroll"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . scroll ( keepAlive )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScroll"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . scroll ( scroll )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setScroll"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . searchType ( searchType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSearchType"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . searchType ( searchType )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSearchType"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . size ( size )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSize"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . source ( source )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setSource"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . stats ( Arrays . asList ( statsGroups )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStats"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . stats ( statsGroups )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStats"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . terminateAfter ( terminateAfter )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTerminateAfter"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . timeout ( timeout )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTimeout"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . trackScores ( trackScores )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTrackScores"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "request . types ( types )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setTypes"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . version ( version )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setVersion"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . slice ( builder )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["slice"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "if    (  ( request . source (  )  )     =  =    null )     {", "request . source ( new   SearchSource (  )  )  ;", "}", "return   request . source (  )  ;", "}", "METHOD_END"], "methodName": ["sourceBuilder"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . storedFields ( Arrays . asList ( fields )  )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["storedFields"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "sourceBuilder (  )  . suggest ( suggestBuilder )  ;", "return   this ;", "}", "METHOD_END"], "methodName": ["suggest"], "fileName": "org.elasticsearch.plugin.noop.action.search.NoopSearchRequestBuilder"}, {"methodBody": ["METHOD_START", "{", "PreBuiltTransportClient . setSystemPropertyIfUnset (  \" io . netty . noUnsafe \"  ,    Boolean . toString ( true )  )  ;", "PreBuiltTransportClient . setSystemPropertyIfUnset (  \" io . netty . noKeySetOptimization \"  ,    Boolean . toString ( true )  )  ;", "PreBuiltTransportClient . setSystemPropertyIfUnset (  \" io . netty . recycler . maxCapacityPerThread \"  ,    Integer . toString (  0  )  )  ;", "}", "METHOD_END"], "methodName": ["initializeNetty"], "fileName": "org.elasticsearch.transport.client.PreBuiltTransportClient"}, {"methodBody": ["METHOD_START", "{", "final   String   currentValue    =    System . getProperty ( key )  ;", "if    ( currentValue    =  =    null )     {", "System . setProperty ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setSystemPropertyIfUnset"], "fileName": "org.elasticsearch.transport.client.PreBuiltTransportClient"}, {"methodBody": ["METHOD_START", "{", "for    ( Class <  ?    extends   Plugin >    plugin    :    Arrays . asList ( ParentJoinPlugin . class ,    ReindexPlugin . class ,    PercolatorPlugin . class ,    MustachePlugin . class )  )     {", "try    {", "new    ( Settings . EMPTY ,    plugin )  ;", "fail (  \" exception   expected \"  )  ;", "}    catch    ( IllegalArgumentException   ex )     {", "assertTrue (  (  (  \" Expected   message   to   start   with    [ plugin   already   exists :     ]    but   was   instead    [  \"     +     ( ex . getMessage (  )  )  )     +     \"  ]  \"  )  ,    ex . getMessage (  )  . startsWith (  \" plugin   already   exists :     \"  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testInstallPluginTwice"], "fileName": "org.elasticsearch.transport.client.PreBuiltTransportClientTests"}, {"methodBody": ["METHOD_START", "{", "try    ( TransportClient   client    =    new   PreBuiltTransportClient ( Settings . EMPTY )  )     {", "Settings   settings    =    client . settings (  )  ;", "assertEquals ( NETTY _ TRANSPORT _ NAME ,    HTTP _ DEFAULT _ TYPE _ SETTING . get ( settings )  )  ;", "assertEquals ( NETTY _ TRANSPORT _ NAME ,    TRANSPORT _ DEFAULT _ TYPE _ SETTING . get ( settings )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testPluginInstalled"], "fileName": "org.elasticsearch.transport.client.PreBuiltTransportClientTests"}]