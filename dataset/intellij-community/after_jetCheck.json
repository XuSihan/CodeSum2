[{"methodBody": ["METHOD_START", "{", "return   Math . max (  1  ,     (  ( sizeHint )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["childSizeHint"], "fileName": "org.jetbrains.jetCheck.AbstractDataStructure"}, {"methodBody": ["METHOD_START", "{", "return   new   BoundedIntDistribution ( min ,    max ,     (    random )     -  >    Math . min ( Math . max ( distribution . generateInt ( random )  ,    min )  ,    max )  )     {", "@ Override", "public   boolean   isValidValue ( int   i )     {", "return    ( super . isValidValue ( i )  )     &  &     ( distribution . isValidValue ( i )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["bound"], "fileName": "org.jetbrains.jetCheck.BoundedIntDistribution"}, {"methodBody": ["METHOD_START", "{", "return   max ;", "}", "METHOD_END"], "methodName": ["getMax"], "fileName": "org.jetbrains.jetCheck.BoundedIntDistribution"}, {"methodBody": ["METHOD_START", "{", "return   min ;", "}", "METHOD_END"], "methodName": ["getMin"], "fileName": "org.jetbrains.jetCheck.BoundedIntDistribution"}, {"methodBody": ["METHOD_START", "{", "return   condition ;", "}", "METHOD_END"], "methodName": ["getCondition"], "fileName": "org.jetbrains.jetCheck.CannotSatisfyCondition"}, {"methodBody": ["METHOD_START", "{", "return   new   Iteration <  >  ( this ,    parameters . globalSeed ,     1  )  ;", "}", "METHOD_END"], "methodName": ["firstIteration"], "fileName": "org.jetbrains.jetCheck.CheckSession"}, {"methodBody": ["METHOD_START", "{", "return   valuesToTry . values (  )  . stream (  )  . mapToInt ( Set :  : size )  . reduce (  1  ,     (    a ,    b )     -  >    a    *    b )  ;", "}", "METHOD_END"], "methodName": ["countVariants"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    possibleValues    =    new   ArrayList <  >  (  )  ;", "int   fromStart    =     ( data . value )     -     ( original . getMin (  )  )  ;", "int   fromEnd    =     ( original . getMax (  )  )     -     ( data . value )  ;", "int   sameDistanceFromStart    =     ( current . getMin (  )  )     +    fromStart ;", "int   sameDistanceFromEnd    =     ( current . getMax (  )  )     -    fromEnd ;", "if    (  !  ( tooManyions (  )  )  )     {", "if    ( fromStart    <    fromEnd )     {", "possibleValues . add ( sameDistanceFromStart )  ;", "possibleValues . add ( sameDistanceFromEnd )  ;", "} else    {", "possibleValues . add ( sameDistanceFromEnd )  ;", "possibleValues . add ( sameDistanceFromStart )  ;", "}", "}", "possibleValues . add ( data . value )  ;", "return   possibleValues . stream (  )  . map (  (    value )     -  >    Math . min ( Math . max ( value ,    current . getMin (  )  )  ,    current . getMax (  )  )  )  . filter ( current :  : isValidValue )  . collect ( Collectors . toCollection ( LinkedHashSet :  : new )  )  ;", "}", "METHOD_END"], "methodName": ["getPossibleValues"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "Map < NodeId ,    Integer >    nextCombination    =    new   HashMap <  >  ( currentCombination )  ;", "for    ( Map . Entry < NodeId ,    Set < Integer >  >    entry    :    valuesToTry . entrySet (  )  )     {", "List < Integer >    possibleValues    =    new   ArrayList <  >  ( entry . getValue (  )  )  ;", "Integer   usedValue    =    currentCombination . get ( entry . getKey (  )  )  ;", "int   index    =    possibleValues . indexOf ( usedValue )  ;", "if    ( index    <     (  ( possibleValues . size (  )  )     -     1  )  )     {", "nextCombination . put ( entry . getKey (  )  ,    possibleValues . get (  ( index    +     1  )  )  )  ;", "return   new    ( valuesToTry ,    nextCombination )  ;", "}", "nextCombination . put ( entry . getKey (  )  ,    possibleValues . get (  0  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["nextAttempt"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "if    ( currentCombination . containsKey ( data . id )  )     {", "changedDistributions . put ( data . id ,    current )  ;", "return   true ;", "}", "if    (  (  ( original . getMax (  )  )     !  =     ( current . getMax (  )  )  )     |  |     (  ( original . getMin (  )  )     !  =     ( current . getMin (  )  )  )  )     {", "LinkedHashSet < Integer >    possibleValues    =    getPossibleValues ( data ,    current ,    original )  ;", "if    (  !  ( possibleValues . isEmpty (  )  )  )     {", "assert    !  ( valuesToTry . containsKey ( data . id )  )  ;", "valuesToTry . put ( data . id ,    possibleValues )  ;", "changedDistributions . put ( data . id ,    current )  ;", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["registerDifferentRange"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "int   value    =    currentCombination . computeIfAbsent ( data . id ,     (     _  _  )     -  >    valuesToTry . get ( data . id )  . iterator (  )  . next (  )  )  ;", "if    ( currentDistribution . isValidValue ( value )  )     {", "return   value ;", "}", "throw   new   CannotRestoreValue (  )  ;", "}", "METHOD_END"], "methodName": ["suggestCombinatorialVariant"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( data . distribution )    instanceof   BoundedIntDistribution )     &  &     ( currentDistribution   instanceof   BoundedIntDistribution )  )     &  &     ( registerDifferentRange ( data ,     (  ( BoundedIntDistribution )     ( currentDistribution )  )  ,     (  ( BoundedIntDistribution )     ( data . distribution )  )  )  )  )     {", "return   suggestVariant ( data ,    currentDistribution )  ;", "}", "return   IntCustomizer . checkValidInt ( data ,    currentDistribution )  ;", "}", "METHOD_END"], "methodName": ["suggestInt"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "return    ( valuesToTry . values (  )  . stream (  )  . filter (  (    s )     -  >     ( s . size (  )  )     >     1  )  . count (  )  )     >     3  ;", "}", "METHOD_END"], "methodName": ["tooManyCombinations"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "StructureNode   result    =    node ;", "for    ( Map . Entry < NodeId ,    IntDistribution >    entry    :    changedDistributions . entrySet (  )  )     {", "NodeId   id    =    entry . getKey (  )  ;", "result    =    result . replace ( id ,    new   IntData ( id ,    currention . get ( id )  ,    entry . getValue (  )  )  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["writeChanges"], "fileName": "org.jetbrains.jetCheck.CombinatorialIntCustomizer"}, {"methodBody": ["METHOD_START", "{", "try    {", "if    (  !  ( iteration . session . property . test ( value )  )  )     {", "return   new    <  >  ( node ,    value ,    null ,    iteration )  ;", "}", "}    catch    ( Throwable   e )     {", "return   new    <  >  ( node ,    value ,    e ,    iteration )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["checkProperty"], "fileName": "org.jetbrains.jetCheck.CounterExampleImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   ReplayDataStructure ( data ,    iteration . sizeHint ,    IntCustomizer :  : checkValidInt )  ;", "}", "METHOD_END"], "methodName": ["createReplayData"], "fileName": "org.jetbrains.jetCheck.CounterExampleImpl"}, {"methodBody": ["METHOD_START", "{", "ByteArrayInputStream   stream    =    new   ByteArrayInputStream ( Base 6  4  . getDecoder (  )  . decode ( data )  )  ;", "int   seedHigh    =     . readINT ( stream )  ;", "int   seedLow    =     . readINT ( stream )  ;", "parameters . globalSeed    =     (  (  ( long )     ( seedHigh )  )     <  <     3  2  )     |     ( seedLow    &     4  2  9  4  9  6  7  2  9  5 L )  ;", "int   hint    =     . readINT ( stream )  ;", "parameters . sizeHintFun    =     (     _  _  )     -  >    hint ;", "parameters . serializedData    =     (     _  _  )     -  >     . readINT ( stream )  ;", "}", "METHOD_END"], "methodName": ["deserializeInto"], "fileName": "org.jetbrains.jetCheck.DataSerializer"}, {"methodBody": ["METHOD_START", "{", "final   int   val    =    record . read (  )  ;", "if    ( val    <     1  9  2  )     {", "return   val ;", "}", "int   res    =    val    -     1  9  2  ;", "for    ( int   sh    =     6  ;     ;    sh    +  =     7  )     {", "int   next    =    record . read (  )  ;", "res    |  =     ( next    &     1  2  7  )     <  <    sh ;", "if    (  ( next    &     1  2  8  )     =  =     0  )     {", "return   res ;", "}", "}", "}", "METHOD_END"], "methodName": ["readINT"], "fileName": "org.jetbrains.jetCheck.DataSerializer"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   stream    =    new   ByteArrayOutputStream (  )  ;", "try    ( DataOutputStream   data    =    new   DataOutputStream ( stream )  )     {", ". writeINT ( data ,     (  ( int )     (  ( iteration . iterationSeed )     >  >     3  2  )  )  )  ;", ". writeINT ( data ,     (  ( int )     ( iteration . iterationSeed )  )  )  ;", ". writeINT ( data ,    iteration . sizeHint )  ;", "node . serialize ( data )  ;", "}    catch    ( IOException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "return   Base 6  4  . getEncoder (  )  . encodeToString ( stream . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["serialize"], "fileName": "org.jetbrains.jetCheck.DataSerializer"}, {"methodBody": ["METHOD_START", "{", "if    (  (  0     >    val )     |  |     ( val    >  =     1  9  2  )  )     {", "record . writeByte (  (  1  9  2     +     ( val    &     6  3  )  )  )  ;", "val    >  >  >  =     6  ;", "while    ( val    >  =     1  2  8  )     {", "record . writeByte (  (  ( val    &     1  2  7  )     |     1  2  8  )  )  ;", "val    >  >  >  =     7  ;", "}", "}", "record . writeByte ( val )  ;", "}", "METHOD_END"], "methodName": ["writeINT"], "fileName": "org.jetbrains.jetCheck.DataSerializer"}, {"methodBody": ["METHOD_START", "{", "return   drawInt ( BoundedIntDistribution . ALL _ INTS )  ;", "}", "METHOD_END"], "methodName": ["drawInt"], "fileName": "org.jetbrains.jetCheck.DataStructure"}, {"methodBody": ["METHOD_START", "{", "return   drawInt ( IntDistribution . uniform (  0  ,    getSizeHint (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["suggestCollectionSize"], "fileName": "org.jetbrains.jetCheck.DataStructure"}, {"methodBody": ["METHOD_START", "{", "try    {", "PropertyCheckerTestCase . STABLE . forAll ( Generator . from (  (    data )     -  >     {", "throw   new   AssertionError (  \" fail \"  )  ;", "}  )  ,     (    i )     -  >    true )  ;", "fail (  )  ;", "}    catch    ( Generator   ignore )     {", "}", "}", "METHOD_END"], "methodName": ["testExceptionWhileGeneratingValue"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFalsified   e    =    checkFails ( PropertyChecker . customized (  )  ,    Generator . listsOf ( Generator . integers (  )  )  . suchThat (  (    l )     -  >     {", "if    (  (  ( l . size (  )  )     =  =     1  )     &  &     (  ( l . get (  0  )  )     =  =     0  )  )", "throw   new   Runtime (  \" my   exception \"  )  ;", "return   true ;", "}  )  ,     (    l )     -  >    l . stream (  )  . allMatch (  (    i )     -  >    i    >     0  )  )  ;", "assertEquals (  \" my   exception \"  ,    e . getFailure (  )  . getStoppingReason (  )  . getMessage (  )  )  ;", "assertTrue ( StatusNotifier . printStackTrace ( e )  . contains (  \" my   exception \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testExceptionWhileShrinkingValue"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFalsified   e    =    checkFails ( PropertyCheckerTestCase . STABLE ,    Generator . integers (  )  ,     (    i )     -  >     {", "throw   i    =  =     0     ?    new   Runtime (  \" fail \"  )     :    new   IllegalArgument (  \" fail \"  )  ;", "}  )  ;", "assertTrue ( e . getMessage (  )  . contains ( PropertyFalsified . FAILURE _ REASON _ HAS _ CHANGED _ DURING _ MINIMIZATION )  )  ;", "}", "METHOD_END"], "methodName": ["testFailureReasonChangedExceptionClass"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFalsified   e    =    checkFails ( PropertyCheckerTestCase . STABLE ,    Generator . integers (  )  ,     (    i )     -  >     {", "if    ( i    =  =     0  )     {", "throw   new   AssertionError (  \" fail \"  )  ;", "} else    {", "throw   new   AssertionError (  \" fail 2  \"  )  ;", "}", "}  )  ;", "assertTrue ( e . getMessage (  )  . contains ( PropertyFalsified . FAILURE _ REASON _ HAS _ CHANGED _ DURING _ MINIMIZATION )  )  ;", "}", "METHOD_END"], "methodName": ["testFailureReasonChangedExceptionTrace"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFalsified   e    =    checkFails ( PropertyCheckerTestCase . STABLE ,    Generator . integers (  )  ,     (    i )     -  >     {", "throw   new   AssertionError (  \" fail \"  )  ;", "}  )  ;", "assertFalse ( e . getMessage (  )  . contains ( PropertyFalsified . FAILURE _ REASON _ HAS _ CHANGED _ DURING _ MINIMIZATION )  )  ;", "}", "METHOD_END"], "methodName": ["testFailureReasonUnchanged"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "try    {", "PropertyChecker . forAll ( Generator . integers (  (  -  1  )  ,     1  )  . suchThat (  (    i )     -  >    i    >     2  )  ,     (    i )     -  >    i    =  =     0  )  ;", "fail (  )  ;", "}    catch    ( Generator   e )     {", "assertTrue (  (  ( e . getCause (  )  )    instanceof   CannotSatisfyCondition )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testUnsatisfiableSuchThat"], "fileName": "org.jetbrains.jetCheck.ExceptionTest"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    weights    =    alternatives . stream (  )  . map (  (    w )     -  >    w . weight )  . collect ( Collectors . toList (  )  )  ;", "IntDistribution   distribution    =    IntDistribution . fDistribution ( weights )  ;", "return    (    data )     -  >    data . generate ( alternatives . get ( data . drawInt ( distribution )  )  . generator )  ;", "}", "METHOD_END"], "methodName": ["frequencyFunction"], "fileName": "org.jetbrains.jetCheck.FrequencyGenerator"}, {"methodBody": ["METHOD_START", "{", "List < FrequencyGenerator . WeightedGenerator < T >  >    alternatives    =    new   ArrayList <  >  (  )  ;", "alternatives . add ( new   FrequencyGenerator . WeightedGenerator <  >  ( weight 1  ,    alternative 1  )  )  ;", "alternatives . add ( new   FrequencyGenerator . WeightedGenerator <  >  ( weight 2  ,    alternative 2  )  )  ;", "return   alternatives ;", "}", "METHOD_END"], "methodName": ["weightedGenerators"], "fileName": "org.jetbrains.jetCheck.FrequencyGenerator"}, {"methodBody": ["METHOD_START", "{", "List < FrequencyGenerator . WeightedGenerator < T >  >    alternatives    =    new   ArrayList <  >  ( this . alternatives )  ;", "alternatives . add ( new   FrequencyGenerator . WeightedGenerator <  >  ( weight ,    alternative )  )  ;", "return   new   FrequencyGenerator <  >  ( alternatives )  ;", "}", "METHOD_END"], "methodName": ["with"], "fileName": "org.jetbrains.jetCheck.FrequencyGenerator"}, {"methodBody": ["METHOD_START", "{", "if    ( alternatives . isEmpty (  )  )", "throw   new   IllegalArgumentException (  \" No   alternatives   to   choose   from \"  )  ;", "return    . from (  (    data )     -  >     {", "int   index    =    data . generateNonShrinkable (  . integers (  0  ,     (  ( alternatives . size (  )  )     -     1  )  )  )  ;", "return   data . generate ( alternatives . get ( index )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["anyOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . anyOf ( Arrays . asList ( alternatives )  )  ;", "}", "METHOD_END"], "methodName": ["anyOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . stringsOf ( Generator . frequency (  5  0  ,    Generator . asciiLetters (  )  ,     5  ,    Generator . digits (  )  ,     1  ,    Generator . constant (  '  _  '  )  )  )  . suchThat (  (    s )     -  >     (  ( s . length (  )  )     >     0  )     &  &     (  !  ( Character . isDigit ( s . charAt (  0  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asciiIdentifiers"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . frequency (  9  ,    Generator . asciiLowercaseChars (  )  ,     1  ,    Generator . asciiUppercaseChars (  )  )  . noShrink (  )  ;", "}", "METHOD_END"], "methodName": ["asciiLetters"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . charsInRange (  ' a '  ,     ' z '  )  ;", "}", "METHOD_END"], "methodName": ["asciiLowercaseChars"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . charsInRange (  (  ( char )     (  3  2  )  )  ,     (  ( char )     (  1  2  6  )  )  )  ;", "}", "METHOD_END"], "methodName": ["asciiPrintableChars"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . charsInRange (  ' A '  ,     ' Z '  )  ;", "}", "METHOD_END"], "methodName": ["asciiUppercaseChars"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . integers (  0  ,     1  )  . map (  (    i )     -  >    i    =  =     1  )  ;", "}", "METHOD_END"], "methodName": ["booleans"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . integers ( min ,    max )  . map (  (    i )     -  >     (  ( char )     ( i . intValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["charsInRange"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    value )  ;", "}", "METHOD_END"], "methodName": ["constant"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . charsInRange (  '  0  '  ,     '  9  '  )  ;", "}", "METHOD_END"], "methodName": ["digits"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >     {", "long   i 1     =    data . drawInt (  )  ;", "long   i 2     =    data . drawInt (  )  ;", "return   Double . longBitsToDouble (  (  ( i 1     <  <     3  2  )     +     ( i 2     &     4  2  9  4  9  6  7  2  9  5 L )  )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["doubles"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >     {", "T   value    =    data . generate ( this )  ;", "Generator < V >    result    =    fun . apply ( value )  ;", "if    ( result    =  =    null )", "throw   new   NullPointerException (  (  ( fun    +     \"    returned   null   on    \"  )     +    value )  )  ;", "return   data . generate ( result )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["flatMap"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   new   FrequencyGenerator <  >  ( weight 1  ,    alternative 1  ,    weight 2  ,    alternative 2  )  ;", "}", "METHOD_END"], "methodName": ["frequency"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . frequency ( weight 1  ,    alternative 1  ,    weight 2  ,    alternative 2  )  . with ( weight 3  ,    alternative 3  )  ;", "}", "METHOD_END"], "methodName": ["frequency"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   new   Generator <  >  ( function )  ;", "}", "METHOD_END"], "methodName": ["from"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "List < T >    list    =    new   ArrayList <  >  ( size )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "list . add ( data . generate ( item )  )  ;", "}", "return   Collections . unmodifiableList ( list )  ;", "}", "METHOD_END"], "methodName": ["generateList"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   myFunction ;", "}", "METHOD_END"], "methodName": ["getGeneratorFunction"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    data . drawInt (  )  )  ;", "}", "METHOD_END"], "methodName": ["integers"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . integers ( IntDistribution . uniform ( min ,    max )  )  ;", "}", "METHOD_END"], "methodName": ["integers"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    data . drawInt ( distribution )  )  ;", "}", "METHOD_END"], "methodName": ["integers"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    Generator . generateList ( itemGenerator ,    data ,    data . suggestCollectionSize (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["listsOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    Generator . generateList ( itemGenerator ,    data ,    data . drawInt ( length )  )  )  ;", "}", "METHOD_END"], "methodName": ["listsOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    fun . apply ( myFunction . apply ( data )  )  )  ;", "}", "METHOD_END"], "methodName": ["map"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . integers (  0  ,    Integer . MAX _ VALUE )  ;", "}", "METHOD_END"], "methodName": ["naturals"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    data . generateNonShrinkable ( this )  )  ;", "}", "METHOD_END"], "methodName": ["noShrink"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . listsOf ( itemGenerator )  . suchThat (  (    l )     -  >     !  ( l . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["nonEmptyLists"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "AtomicReference < Generator < T >  >    ref    =    new   AtomicReference <  >  (  )  ;", "Generator < T >    result    =    Generator . from (  (    data )     -  >    ref . get (  )  . getGeneratorFunction (  )  . apply ( data )  )  ;", "ref . set ( createGenerator . apply ( result )  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["recursive"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . sampledFrom ( Arrays . asList ( values )  )  ;", "}", "METHOD_END"], "methodName": ["sampledFrom"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . anyOf ( values . stream (  )  . map ( Generator :  : constant )  . collect ( Collectors . toList (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["sampledFrom"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "List < Character >    chars    =    IntStream . range (  0  ,    possibleChars . length (  )  )  . mapToObj ( possibleChars :  : charAt )  . collect ( Collectors . toList (  )  )  ;", "return    . stringsOf (  . sampledFrom ( chars )  )  ;", "}", "METHOD_END"], "methodName": ["stringsOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . listsOf ( charGen )  . map (  (    chars )     -  >     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "chars . forEach ( sb :  : append )  ;", "return   sb . toString (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["stringsOf"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    data . generateConditional ( this ,    condition )  )  ;", "}", "METHOD_END"], "methodName": ["suchThat"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    zip . apply ( data . generate ( gen 1  )  ,    data . generate ( gen 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["zipWith"], "fileName": "org.jetbrains.jetCheck.Generator"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     (  ( list . size (  )  )     -     1  )  ;    i +  +  )     {", "double   d 1     =    list . get ( i )  ;", "double   d 2     =    list . get (  ( i    +     1  )  )  ;", "if    (  !  ( d 1     <  =    d 2  )  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isSorted"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . forAll ( Generator . asciiIdentifiers (  )  ,     (    s )     -  >     ( Character . isJavaIdentifierStart ( s . charAt (  0  )  )  )     &  &     ( s . chars (  )  . allMatch ( Character :  : isJavaIdentifierPart )  )  )  ;", "checkGeneratesExample ( Generator . asciiIdentifiers (  )  ,     (    s )     -  >    s . contains (  \"  _  \"  )  ,     1  0  )  ;", "}", "METHOD_END"], "methodName": ["testAsciiIdentifier"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "List < Boolean >    list    =    checkGeneratesExample ( Generator . listsOf ( Generator . booleans (  )  )  ,     (    l )     -  >     ( l . contains ( true )  )     &  &     ( l . contains ( false )  )  ,     4  )  ;", "assertEquals (  2  ,    list . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testBoolean"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFailure < List < Integer >  >    failure    =    checkFalsified ( Generator . nonEmptyLists ( Generator . integers (  )  )  ,     (    l )     -  >    l . stream (  )  . sorted (  )  . collect ( Collectors . toList (  )  )  . equals ( l )  ,     3  6  )  ;", "List < Integer >    value    =    failure . getMinimalCounterexample (  )  . getExampleValue (  )  ;", "assertEquals (  2  ,    value . size (  )  )  ;", "assertTrue ( value . toString (  )  ,    value . stream (  )  . allMatch (  (    i )     -  >     ( Math . abs ( i )  )     <     2  )  )  ;", "}", "METHOD_END"], "methodName": ["testIsSorted"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . stringsOf ( Generator . asciiLetters (  )  )  ,     (    s )     -  >     !  ( s . contains (  \" a \"  )  )  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testLetterStringContains"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkGeneratesExample ( Generator . nonEmptyLists ( Generator . integers (  )  )  ,     (    l )     -  >    l . stream (  )  . anyMatch (  (    i )     -  >     ( i    %     1  0  )     =  =     0  )  ,     4  )  ;", "}", "METHOD_END"], "methodName": ["testListContainsDivisible"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . customized (  )  . withIterationCount (  1  0  0  0  )  . forAll ( Generator . listsOf ( Generator . integers (  )  )  ,     (    l )     -  >     ( l . size (  )  )     <  =     ( PropertyChecker . DEFAULT _ MAX _ SIZE _ HINT )  )  ;", "}", "METHOD_END"], "methodName": ["testListNotLongerThanMaxDefaultSize"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . nonEmptyLists ( Generator . integers (  )  )  ,     (    l )     -  >     (  ( l . stream (  )  . mapToInt ( Integer :  : intValue )  . sum (  )  )     %     1  0  )     !  =     0  ,     3  0  1  )  ;", "}", "METHOD_END"], "methodName": ["testListSumMod"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . integers (  )  ,     (    i )     -  >     ( i    %     1  2  )     !  =     0  ,     1  )  ;", "}", "METHOD_END"], "methodName": ["testMod"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyCheckerTestCase . STABLE . forAll ( Generator . frequency (  5  0  ,    Generator . constant (  0  )  ,     1  ,    Generator . integers (  1  ,     1  0  0  0  )  )  . suchThat (  (    i )     -  >    i    >     0  )  ,     (    i )     -  >    i    >     0  )  ;", "}", "METHOD_END"], "methodName": ["testNestedSometimesVeryRareSuchThat"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Set < List < Integer >  >    visited    =    new   HashSet <  >  (  )  ;", "PropertyChecker . forAll (  . listsOf (  . integers (  )  )  ,     (    l )     -  >    visited . add ( l )  )  ;", "}", "METHOD_END"], "methodName": ["testNoDuplicateData"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . forAll ( Generator . nonEmptyLists ( Generator . integers (  )  )  ,     (    l )     -  >     !  ( l . isEmpty (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testNonEmptyList"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    values    =    new   ArrayList <  >  (  )  ;", "PropertyChecker . forAll (  . anyOf (  . integers (  0  ,     1  )  ,     . integers (  1  0  ,     1  1  0  0  )  )  ,     (    i )     -  >    values . add ( i )  )  ;", "assertTrue ( values . stream (  )  . anyMatch (  (    i )     -  >    i    <     2  )  )  ;", "assertTrue ( values . stream (  )  . anyMatch (  (    i )     -  >    i    >     5  )  )  ;", "}", "METHOD_END"], "methodName": ["testOneOf"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Generator < List < Integer >  >    gen    =    Generator . nonEmptyLists ( Generator . integers (  0  ,     1  0  0  )  )  ;", "Predicate < List < Integer >  >    property    =     (    l )     -  >     !  ( l . contains (  4  2  )  )  ;", "PropertyFailure <  ?  >    failure    =    checkFails ( PropertyChecker . customized (  )  . withSeed (  1  )  ,    gen ,    property )  . getFailure (  )  ;", "assertTrue (  (  ( failure . getIterationNumber (  )  )     >     1  )  )  ;", "PropertyFalsified   e ;", "e    =    checkFails ( PropertyChecker . customized (  )  . recheckingIteration ( failure . getIterationSeed (  )  ,    failure . getSizeHint (  )  )  ,    gen ,    property )  ;", "assertEquals (  1  ,    e . getFailure (  )  . getIterationNumber (  )  )  ;", "e    =    checkFails ( PropertyChecker . customized (  )  . withSeed ( failure . getGlobalSeed (  )  )  ,    gen ,    property )  ;", "assertEquals ( failure . getIterationNumber (  )  ,    e . getFailure (  )  . getIterationNumber (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRecheckWithGivenSeeds"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "List < List >    log    =    new   ArrayList <  >  (  )  ;", "PropertyFailure < List < Integer >  >    failure    =    checkFalsified (  . listsOf (  . integers (  0  ,     1  0  0  )  )  ,     (    l )     -  >     {", "log . add ( l )  ;", "return    !  ( l . contains (  4  2  )  )  ;", "}  ,     9  )  ;", "List < Integer >    goldMin    =    Collections . singletonList (  4  2  )  ;", "PropertyFailure . CounterExample < List < Integer >  >    first    =    failure . getFirstCounterExample (  )  ;", "PropertyFailure . CounterExample < List < Integer >  >    min    =    failure . getMinimalCounterexample (  )  ;", "assertEquals ( goldMin ,    min . getExampleValue (  )  )  ;", "assertTrue ( log . contains ( first . getExampleValue (  )  )  )  ;", "assertTrue ( log . contains ( min . getExampleValue (  )  )  )  ;", "log . clear (  )  ;", "PropertyFailure . CounterExample < List < Integer >  >    first 2     =    first . replay (  )  ;", "assertEquals ( first . getExampleValue (  )  ,    first 2  . getExampleValue (  )  )  ;", "assertEquals ( log ,    Collections . singletonList ( first 2  . getExampleValue (  )  )  )  ;", "log . clear (  )  ;", "PropertyFailure . CounterExample < List < Integer >  >    min 2     =    min . replay (  )  ;", "assertEquals ( goldMin ,    min 2  . getExampleValue (  )  )  ;", "assertEquals ( log ,    Collections . singletonList ( goldMin )  )  ;", "}", "METHOD_END"], "methodName": ["testReplay"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . listsOf ( Generator . frequency (  1  ,    Generator . constant (  1  )  ,     1  ,    Generator . constant (  2  )  )  )  ,     (    l )     -  >     (  !  ( l . contains (  1  )  )  )     |  |     (  !  ( l . contains (  2  )  )  )  ,     3  )  ;", "checkFalsified ( Generator . listsOf ( Generator . frequency (  1  ,    Generator . constant (  1  )  ,     1  ,    Generator . constant (  2  )  )  . with (  1  ,    Generator . constant (  3  )  )  )  ,     (    l )     -  >     (  (  !  ( l . contains (  1  )  )  )     |  |     (  !  ( l . contains (  2  )  )  )  )     |  |     (  !  ( l . contains (  3  )  )  )  ,     7  )  ;", "}", "METHOD_END"], "methodName": ["testSameFrequency"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFailure < String >    failure    =    checkFalsified ( Generator . stringsOf ( Generator . asciiUppercaseChars (  )  )  ,     (    s )     -  >     ( s . length (  )  )     <     5  ,     1  1  )  ;", "assertEquals (  \" AAAAA \"  ,    failure . getMinimalCounterexample (  )  . getExampleValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkToRangeStart"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyFailure < List < Double >  >    failure    =    checkFalsified ( Generator . listsOf ( Generator . doubles (  )  )  ,     (    l )     -  >    GeneratorTest . isSorted ( l . stream (  )  . sorted (  )  . collect ( Collectors . toList (  )  )  )  ,     2  3  )  ;", "assertEquals (  2  ,    failure . getMinimalCounterexample (  )  . getExampleValue (  )  . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSortedDoublesNonDescending"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "assertEquals (  \" a \"  ,    checkGeneratesExample ( Generator . stringsOf ( Generator . asciiPrintableChars (  )  )  ,     (    s )     -  >    s . contains (  \" a \"  )  ,     1  0  )  )  ;", "}", "METHOD_END"], "methodName": ["testStringContains"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . stringsOf (  \" abc    \"  )  ,     (    s )     -  >     !  ( s . contains (  \"     \"  )  )  ,     0  )  ;", "}", "METHOD_END"], "methodName": ["testStringOfStringChecksAllChars"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . forAll ( Generator . listsOf ( Generator . integers (  (  -  1  )  ,     1  )  )  ,     (    l )     -  >    l . stream (  )  . allMatch (  (    i )     -  >     ( Math . abs ( i )  )     <  =     1  )  )  ;", "}", "METHOD_END"], "methodName": ["testSuccess"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . forAll ( Generator . integers (  )  . suchThat (  (    i )     -  >    i    <     0  )  ,     (    i )     -  >    i    <     0  )  ;", "}", "METHOD_END"], "methodName": ["testSuchThat"], "fileName": "org.jetbrains.jetCheck.GeneratorTest"}, {"methodBody": ["METHOD_START", "{", "sb . insert ( index ,    c )  ;", "}", "METHOD_END"], "methodName": ["performOperation"], "fileName": "org.jetbrains.jetCheck.InsertChar"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "cmds . forEach (  (    cmd )     -  >    cmd . performOperation ( sb )  )  ;", "return   sb . toString (  )  ;", "}", "METHOD_END"], "methodName": ["performOperations"], "fileName": "org.jetbrains.jetCheck.InsertChar"}, {"methodBody": ["METHOD_START", "{", "int   value    =    data . value ;", "if    (  !  ( currentDistribution . isValidValue ( value )  )  )", "throw   new   CannotRereValue (  )  ;", "return   value ;", "}", "METHOD_END"], "methodName": ["checkValidInt"], "fileName": "org.jetbrains.jetCheck.IntCustomizer"}, {"methodBody": ["METHOD_START", "{", "if    ( value    =  =     0  )", "return   null ;", "int   divided    =    value    /     2  ;", "return   try ( divided ,     (  )     -  >    divisionLoop ( divided )  ,    null )  ;", "}", "METHOD_END"], "methodName": ["divisionLoop"], "fileName": "org.jetbrains.jetCheck.IntData"}, {"methodBody": ["METHOD_START", "{", "return   distribution . isValidValue ( value )     ?    ShrinkStep . create ( id ,    new   IntData ( id ,    value ,    distribution )  ,     (     _  _  )     -  >    success . get (  )  ,    fail )     :    null ;", "}", "METHOD_END"], "methodName": ["tryInt"], "fileName": "org.jetbrains.jetCheck.IntData"}, {"methodBody": ["METHOD_START", "{", "if    (  ( value )     <     0  )     {", "return   try (  (  -  ( value )  )  ,     (  )     -  >    divisionLoop (  (  -  ( value )  )  )  ,     (  )     -  >    divisionLoop ( value )  )  ;", "}", "return   divisionLoop ( value )  ;", "}", "METHOD_END"], "methodName": ["tryNegation"], "fileName": "org.jetbrains.jetCheck.IntData"}, {"methodBody": ["METHOD_START", "{", "if    ( weights . isEmpty (  )  )", "throw   new   IllegalArgumentException (  \" No   alternatives   to   choose   from \"  )  ;", "int   sum    =    weights . stream (  )  . reduce (  0  ,     (    a ,    b )     -  >    a    +    b )  ;", "return   new   Bounded (  0  ,     (  ( weights . size (  )  )     -     1  )  ,     (    r )     -  >     {", "int   value    =    r . nextInt ( sum )  ;", "for    ( int   i    =     0  ;    i    <     ( weights . size (  )  )  ;    i +  +  )     {", "value    -  =    weights . get ( i )  ;", "if    ( value    <     0  )", "return   i ;", "}", "throw   new   IllegalArgumentException (  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["frequencyDistribution"], "fileName": "org.jetbrains.jetCheck.IntDistribution"}, {"methodBody": ["METHOD_START", "{", "double   p    =     1  .  0     /     ( mean    +     1  )  ;", "return   new    (  )     {", "@ Override", "public   int   generateInt ( Random   random )     {", "double   u    =    random . nextDouble (  )  ;", "return    (  ( int )     (  ( Math . log ( u )  )     /     ( Math . log (  (  1     -    p )  )  )  )  )  ;", "}", "@ Override", "public   boolean   isValidValue ( int   i )     {", "return   i    >  =     0  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["geometric"], "fileName": "org.jetbrains.jetCheck.IntDistribution"}, {"methodBody": ["METHOD_START", "{", "return   new   BoundedIntDistribution ( min ,    max ,     (    r )     -  >     {", "if    ( min    =  =    max )", "return   min ;", "int   i    =    r . nextInt (  )  ;", "return    ( i    >  =    min )     &  &     ( i    <  =    max )     ?    i    :     (  ( Math . abs ( i )  )     %     (  ( max    -    min )     +     1  )  )     +    min ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["uniform"], "fileName": "org.jetbrains.jetCheck.IntDistribution"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  0  ;    i +  +  )     {", "if    ( i    >     0  )     {", "initSeed ( random . nextLong (  )  )  ;", "}", "StructureNode   node    =    new   StructureNode ( new   NodeId ( session . generator )  )  ;", "T   value ;", "try    {", "IntSource   source    =     (  ( session . parameters . serializedData )     !  =    null )     ?    session . parameters . serializedData    :     (    d )     -  >    d . generateInt ( random )  ;", "value    =    session . generator . getGeneratorFunction (  )  . apply ( new   GenerativeDataStructure ( source ,    node ,    sizeHint )  )  ;", "}    catch    ( CannotSatisfyCondition   e )     {", "continue ;", "}    catch    ( Throwable   e )     {", "throw   new   GeneratorException ( this ,    e )  ;", "}", "if    (  !  ( session . generatedNodes . add ( node )  )  )", "continue ;", "return   CounterExampleImpl . checkProperty ( this ,    value ,    node )  ;", "}", "throw   new   GeneratorException ( this ,    new   CannotSatisfyCondition (  . DATA _ IS _ DIFFERENT )  )  ;", "}", "METHOD_END"], "methodName": ["findCounterExample"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "return   session . generator . getGeneratorFunction (  )  . apply ( data )  ;", "}", "METHOD_END"], "methodName": ["generateValue"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "iterationSeed    =    seed ;", "random    =    new   Random ( seed )  ;", "}", "METHOD_END"], "methodName": ["initSeed"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "session . notifier . iterationStarted ( iterationNumber )  ;", "CounterExampleImpl < T >    example    =    findCounterExample (  )  ;", "if    ( example    !  =    null )     {", "session . notifier . counterExampleFound ( this )  ;", "throw   new   PropertyFalsified ( new   PropertyFailureImpl <  >  ( example ,    this )  )  ;", "}", "if    (  ( iterationNumber )     >  =     ( session . parameters . iterationCount )  )     {", "return   null ;", "}", "return   new    <  >  ( session ,    random . nextLong (  )  ,     (  ( iterationNumber )     +     1  )  )  ;", "}", "METHOD_END"], "methodName": ["performIteration"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "return    (  (  (  (  (  (  (  \" iteration   seed =  \"     +     ( iterationSeed )  )     +     \" L ,     \"  )     +     \" size   hint =  \"  )     +     ( sizeHint )  )     +     \"  ,     \"  )     +     \" global   seed =  \"  )     +     ( session . parameters . globalSeed )  )     +     \" L \"  ;", "}", "METHOD_END"], "methodName": ["printSeeds"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "String   data    =    minimalCounterExample . getSerializedData (  )  ;", "boolean   scenarios    =     ( failureReason    !  =    null )     &  &     ( StatusNotifier . printStackTrace ( failureReason )  . contains (  \" PropertyChecker $ Parameters . checkScenarios \"  )  )  ;", "String   rechecking    =     (  (  (  \" PropertyChecker . customized (  )  . rechecking (  \\  \"  \"     +    data )     +     \"  \\  \"  )  \\ n             .  \"  )     +     ( scenarios    ?     \" checkScenarios \"     :     \" forAll \"  )  )     +     \"  (  .  .  .  )  \\ n \"  ;", "return    (  (  (  (  (  (  (  \" To   reproduce   the   minimal   failing   case ,    run \\ n       \"     +    rechecking )     +     \" To   re - run   the   test   with   all   intermediate   minimization   steps ,    use    ` rechecking (  \"  )     +     ( iterationSeed )  )     +     \" L ,     \"  )     +     ( sizeHint )  )     +     \"  )  `    instead   for   last   iteration ,    or    ` withSeed (  \"  )     +     ( session . parameters . globalSeed )  )     +     \" L )  `    for   all   iterations \"  ;", "}", "METHOD_END"], "methodName": ["printToReproduce"], "fileName": "org.jetbrains.jetCheck.Iteration"}, {"methodBody": ["METHOD_START", "{", "return   new   NodeId ( counter ,    generator )  ;", "}", "METHOD_END"], "methodName": ["childId"], "fileName": "org.jetbrains.jetCheck.NodeId"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . customized (  )  . checkScenarios ( command )  ;", "}", "METHOD_END"], "methodName": ["checkScenarios"], "fileName": "org.jetbrains.jetCheck.PropertyChecker"}, {"methodBody": ["METHOD_START", "{", "return   new   PropertyChecker . Parameters (  )  ;", "}", "METHOD_END"], "methodName": ["customized"], "fileName": "org.jetbrains.jetCheck.PropertyChecker"}, {"methodBody": ["METHOD_START", "{", "PropertyChecker . customized (  )  . forAll ( generator ,    property )  ;", "}", "METHOD_END"], "methodName": ["forAll"], "fileName": "org.jetbrains.jetCheck.PropertyChecker"}, {"methodBody": ["METHOD_START", "{", "try    {", "parameters . silent (  )  . forAll ( checker ,    predicate )  ;", "throw   new   AssertionError (  (  \" Can ' t   falsify    \"     +     ( getName (  )  )  )  )  ;", "}    catch    ( Falsified   e )     {", "return   e ;", "}", "}", "METHOD_END"], "methodName": ["checkFails"], "fileName": "org.jetbrains.jetCheck.PropertyCheckerTestCase"}, {"methodBody": ["METHOD_START", "{", "PropertyFalsified   e    =    checkFails ( PropertyCheckerTestCase . STABLE ,    generator ,    predicate )  ;", "PropertyFailure < T >    failure    =     (  ( PropertyFailure < T >  )     ( e . getFailure (  )  )  )  ;", "assertEquals ( minimizationSteps ,    failure . getTotalMinimizationExampleCount (  )  )  ;", "assertEquals ( e . getBreakingValue (  )  ,    generator . getGeneratorFunction (  )  . apply (  (  ( CounterExampleImpl )     ( failure . getMinimalCounterexample (  )  )  )  . createReplayData (  )  )  )  ;", "String   strData    =    failure . getMinimalCounterexample (  )  . getSerializedData (  )  ;", "assertNotNull ( checkFails ( PropertyChecker . customized (  )  . rechecking ( strData )  ,    generator ,    predicate )  )  ;", "return   failure ;", "}", "METHOD_END"], "methodName": ["checkFalsified"], "fileName": "org.jetbrains.jetCheck.PropertyCheckerTestCase"}, {"methodBody": ["METHOD_START", "{", "return   checkFalsified ( generator ,    predicate . negate (  )  ,    minimizationSteps )  . getMinimalCounterexample (  )  . getExampleValue (  )  ;", "}", "METHOD_END"], "methodName": ["checkGeneratesExample"], "fileName": "org.jetbrains.jetCheck.PropertyCheckerTestCase"}, {"methodBody": ["METHOD_START", "{", "List < PropertyFailureImpl . CustomizedNode >    combinatorial    =    new   ArrayList <  >  (  )  ;", "while    (  ( step    !  =    null )     &  &     (  !  ( step . equals ( limit )  )  )  )     {", "StructureNode   node    =    step . apply ( minimized . data )  ;", "if    (  ( node    !  =    null )     &  &     ( iteration . session . generatedNodes . add ( node )  )  )     {", "CombinatorialIntCustomizer   customizer    =    new   CombinatorialIntCustomizer (  )  ;", "if    ( tryStep ( node ,    customizer )  )     {", "return   step ;", "}", "CombinatorialIntCustomizer   next    =    customizer . nextAttempt (  )  ;", "if    ( next    !  =    null )     {", "combinatorial . add ( new   PropertyFailureImpl . CustomizedNode ( next ,    step )  )  ;", "}", "}", "step    =    step . onFailure (  )  ;", "}", "return   processDelayedCombinations ( combinatorial )  ;", "}", "METHOD_END"], "methodName": ["findSuccessfulShrink"], "fileName": "org.jetbrains.jetCheck.PropertyFailureImpl"}, {"methodBody": ["METHOD_START", "{", "Collections . sort ( delayed )  ;", "for    (  . CustomizedNode   customizedNode    :    delayed )     {", "CombinatorialIntCustomizer   customizer    =    customizedNode . customizer ;", "while    ( customizer    !  =    null )     {", "if    ( tryStep ( customizedNode . step . apply ( minimized . data )  ,    customizer )  )     {", "return   customizedNode . step ;", "}", "customizer    =    customizer . nextAttempt (  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["processDelayedCombinations"], "fileName": "org.jetbrains.jetCheck.PropertyFailureImpl"}, {"methodBody": ["METHOD_START", "{", "ShrinkStep   lastSuccessfulShrink    =    null ;", "do    {", "lastSuccessfulShrink    =    shrinkIteration ( lastSuccessfulShrink )  ;", "}    while    ( lastSuccessfulShrink    !  =    null    )  ;", "}", "METHOD_END"], "methodName": ["shrink"], "fileName": "org.jetbrains.jetCheck.PropertyFailureImpl"}, {"methodBody": ["METHOD_START", "{", "ShrinkStep   lastSuccessfulShrink    =    null ;", "ShrinkStep   step    =    minimized . data . shrink (  )  ;", "while    ( step    !  =    null )     {", "step    =    findSuccessfulShrink ( step ,    limit )  ;", "if    ( step    !  =    null )     {", "lastSuccessfulShrink    =    step ;", "step    =    step . onSuccess ( minimized . data )  ;", "}", "}", "return   lastSuccessfulShrink ;", "}", "METHOD_END"], "methodName": ["shrinkIteration"], "fileName": "org.jetbrains.jetCheck.PropertyFailureImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "iteration . session . notifier . shrinkAttempt ( this ,    iteration )  ;", "( totalSteps )  +  +  ;", "T   value    =    iteration . generateValue ( new   ReplayDataStructure ( node ,    iteration . sizeHint ,    customizer )  )  ;", "CounterExampleImpl < T >    example    =    CounterExampleImpl . check ( iteration ,    value ,    customizer . writeChanges ( node )  )  ;", "if    ( example    !  =    null )     {", "minimized    =    example ;", "( successfulSteps )  +  +  ;", "return   true ;", "}", "}    catch    ( CannotRestoreValue   ignored )     {", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["tryStep"], "fileName": "org.jetbrains.jetCheck.PropertyFailureImpl"}, {"methodBody": ["METHOD_START", "{", "traceBuilder . append (  \"  \\ n    \"  )  . append ( prefix )  . append ( StatusNotifier . printStackTrace ( e )  )  . append ( PropertyFalsified . SEPARATOR )  ;", "}", "METHOD_END"], "methodName": ["appendTrace"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "StringBuilder   traceBuilder    =    new   StringBuilder (  )  ;", "String   exampleString    =     . valueToString ( failure . getMinimalCounterexample (  )  ,    traceBuilder )  ;", "Throwable   failureReason    =    failure . getMinimalCounterexample (  )  . getExceptionCause (  )  ;", "Throwable   rootCause    =     ( failureReason    =  =    null )     ?    null    :     . getRootCause ( failureReason )  ;", "String   msg    =     ( rootCause    !  =    null )     ?     (  (  \" Failed   with    \"     +    rootCause )     +     \"  \\ nOn    \"  )     +    exampleString    :     \" Falsified   on    \"     +    exampleString ;", "msg    +  =     (  (  (  \"  \\ n \"     +     ( getMinimizationStats (  )  )  )     +     \"  \\ n \"  )     +     ( failure . iteration . printToReproduce ( failureReason ,    failure . getMinimalCounterexample (  )  )  )  )     +     \"  \\ n \"  ;", "if    ( failureReason    !  =    null )     {", ". appendTrace ( traceBuilder ,     ( rootCause    =  =    failureReason    ?     \" Property   failure   reason :     \"     :     \" Property   failure   reason ,    innermost   exception    ( see   full   trace   below )  :     \"  )  ,    rootCause )  ;", "}", "if    (  ( failure . getStoppingReason (  )  )     !  =    null )     {", "msg    +  =     \"  \\ n   Minimization   stopped   prematurely ,    see   the   reason   below .  \"  ;", ". appendTrace ( traceBuilder ,     \" An   unexpected   exception   happened   during   minimization :     \"  ,    failure . getStoppingReason (  )  )  ;", "}", "Throwable   first    =    failure . getFirstCounterExample (  )  . getExceptionCause (  )  ;", "if    (  . exceptionsDiffer ( first ,    failure . getMinimalCounterexample (  )  . getExceptionCause (  )  )  )     {", "msg    +  =     \"  \\ n    \"     +     (  . FAILURE _ REASON _ HAS _ CHANGED _ DURING _ MINIMIZATION )  ;", "StringBuilder   secondaryTrace    =    new   StringBuilder (  )  ;", "traceBuilder . append (  \"  \\ n   Initial   value :     \"  )  . append (  . valueToString ( failure . getFirstCounterExample (  )  ,    secondaryTrace )  )  ;", "if    ( first    =  =    null )     {", "traceBuilder . append (  \"  \\ n   Initially   property   was   falsified   without   exceptions \"  )  ;", "traceBuilder . append ( secondaryTrace )  ;", "} else    {", "traceBuilder . append ( secondaryTrace )  ;", ". appendTrace ( traceBuilder ,     \" Initially   failed   because   of    \"  ,    first )  ;", "}", "}", "return   msg    +    traceBuilder ;", "}", "METHOD_END"], "methodName": ["calcMessage"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "if    (  ( e 1     =  =    null )     &  &     ( e 2     =  =    null )  )", "return   false ;", "if    (  ( e 1     =  =    null )     !  =     ( e 2     =  =    null )  )", "return   true ;", "if    (  !  ( e 1  . getClass (  )  . equals ( e 2  . getClass (  )  )  )  )", "return   true ;", "if    ( e 1    instanceof   StackOverflowError )", "return   false ;", "return    !  (  . getUserTrace ( e 1  )  . equals (  . getUserTrace ( e 2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["exceptionsDiffer"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "return   failure . getMinimalCounterexample (  )  . getExampleValue (  )  ;", "}", "METHOD_END"], "methodName": ["getBreakingValue"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "return   failure ;", "}", "METHOD_END"], "methodName": ["getFailure"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "int   exampleCount    =    failure . getTotalMinimizationExampleCount (  )  ;", "if    ( exampleCount    =  =     0  )", "return    \"  \"  ;", "String   examples    =     ( exampleCount    =  =     1  )     ?     \" example \"     :     \" examples \"  ;", "int   stageCount    =    failure . getMinimizationStageCount (  )  ;", "if    ( stageCount    =  =     0  )", "return    (  (  (  \" Couldn ' t   minimize ,    tr    \"     +    exampleCount )     +     \"     \"  )     +    examples )     +     \"  \\ n \"  ;", "String   stages    =     ( stageCount    =  =     1  )     ?     \" stage \"     :     \" stages \"  ;", "return    (  (  (  (  (  (  (  \" Minimized   in    \"     +    stageCount )     +     \"     \"  )     +    stages )     +     \"  ,    by   trying    \"  )     +    exampleCount )     +     \"     \"  )     +    examples )     +     \"  \\ n \"  ;", "}", "METHOD_END"], "methodName": ["getMinimizationStats"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "while    (  ( t . getCause (  )  )     !  =    null )     {", "t    =    t . getCause (  )  ;", "}", "return   t ;", "}", "METHOD_END"], "methodName": ["getRootCause"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "for    ( StackTraceElement   element    :    e . getStackTrace (  )  )     {", "String   s    =    element . toString (  )  ;", "if    (  ( s . startsWith (  \"  \"  )  )     &  &     (  !  ( s . contains (  \" Test .  \"  )  )  )  )     {", "break ;", "}", "result . add ( s )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["getUserTrace"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   String . valueOf ( example . getExampleValue (  )  )  ;", "}    catch    ( Throwable   e )     {", ". appendTrace ( traceBuilder ,     \" Exception   during   toString   evaluation :     \"  ,    e )  ;", "return    \"  < can ' t   evaluate   toString (  )  ,    see   exception   below >  \"  ;", "}", "}", "METHOD_END"], "methodName": ["valueToString"], "fileName": "org.jetbrains.jetCheck.PropertyFalsified"}, {"methodBody": ["METHOD_START", "{", "PropertyFailure <  ?  >    failure    =    checkFails ( PropertyCheckerTestCase . STABLE ,    nodes ,     (    tree )     -  >     !  ( tree . toString (  )  . contains (  \" a \"  )  )  )  . getFailure (  )  ;", "assertTrue (  (  ( failure . getMinimalCounterexample (  )  . getExampleValue (  )  )    instanceof    . Leaf )  )  ;", "}", "METHOD_END"], "methodName": ["checkShrinksToLeaf"], "fileName": "org.jetbrains.jetCheck.RecursiveGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkShrinksToLeaf ( Generator . recursive (  (    nodes )     -  >    Generator . frequency (  2  ,    RecursiveGeneratorTest . leaves ,     1  ,    Generator . from (  (    data )     -  >    data . generate ( Generator . listsOf ( nodes )  . map ( RecursiveGeneratorTest . Composite :  : new )  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinksToLeafDespiteWrapping"], "fileName": "org.jetbrains.jetCheck.RecursiveGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkShrinksToLeaf ( Generator . recursive (  (    nodes )     -  >    Generator . anyOf ( RecursiveGeneratorTest . leaves ,    Generator . listsOf ( nodes )  . map ( RecursiveGeneratorTest . Composite :  : new )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinksToLeafWithAnyOf"], "fileName": "org.jetbrains.jetCheck.RecursiveGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "checkShrinksToLeaf ( Generator . recursive (  (    nodes )     -  >    Generator . frequency (  2  ,    RecursiveGeneratorTest . leaves ,     1  ,    Generator . listsOf ( nodes )  . map ( RecursiveGeneratorTest . Composite :  : new )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinksToLeafWithFrequency"], "fileName": "org.jetbrains.jetCheck.RecursiveGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( iterator . hasNext (  )  )  )", "throw   new   CannotRestoreValue (  )  ;", "Object   next    =    iterator . next (  )  ;", "if    (  !  ( required . isInstance ( next )  )  )", "throw   new   CannotRestoreValue (  )  ;", "ren    (  ( E )     ( next )  )  ;", "}", "METHOD_END"], "methodName": ["nextChild"], "fileName": "org.jetbrains.jetCheck.ReplayDataStructure"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failure )     =  =    null )     {", "failure    =    e ;", "}", "}", "METHOD_END"], "methodName": ["addFailure"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "if    (  ( failure )    instanceof   Error )", "throw    (  ( Error )     ( failure )  )  ;", "if    (  ( failure )    instanceof   RuntimeException )", "throw    (  ( RuntimeException )     ( failure )  )  ;", "if    (  ( failure )     !  =    null )", "throw   new   RuntimeException ( failure )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["ensureSuccessful"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "command . performCommand ( new   ImperativeCommand . Environment (  )     {", "@ Override", "public   void   logMessage (  @ NotNull", "String   message )     {", "log . add ( message )  ;", "}", "@ Override", "public    < T >    T   generateValue (  @ NotNull", "Generator < T >    generator ,     @ Nullable", "String   logMessage )     {", "T   value    =    safeGenerate ( data ,    generator )  ;", "if    ( logMessage    !  =    null )     {", "logMessage ( String . format ( logMessage ,    value )  )  ;", "}", "return   value ;", "}", "@ Override", "public   void   executeCommands ( IntDistribution   count ,    Generator <  ?    extends   ImperativeCommand >    cmdGen )     {", "innerCommandLists ( Generator . listsOf ( count ,    innerCommands ( cmdGen )  )  )  ;", "}", "@ Override", "public   void   executeCommands ( Generator <  ?    extends   ImperativeCommand >    cmdGen )     {", "innerCommandLists ( Generator . nonEmptyLists ( innerCommands ( cmdGen )  )  )  ;", "}", "private   void   innerCommandLists ( final   Generator < List < Object >  >    listGen )     {", "data . generate ( Generator . from ( new    . EquivalentGenerator < List < Object >  >  (  )     {", "@ Override", "public   List < Object >    apply ( DataStructure   data )     {", "return   listGen . getGeneratorFunction (  )  . apply ( data )  ;", "}", "}  )  )  ;", "}", "@ NotNull", "private   Generator < Object >    innerCommands ( Generator <  ?    extends   ImperativeCommand >    cmdGen )     {", "return   Generator . from ( new    . EquivalentGenerator < Object >  (  )     {", "@ Override", "public   Object   apply ( DataStructure   cmdData )     {", "List < Object >    localLog    =    new   ArrayList <  >  (  )  ;", "log . add ( localLog )  ;", "performCommand ( safeGenerate ( cmdData ,    cmdGen )  ,    cmdData ,    localLog )  ;", "return   null ;", "}", "}  )  ;", "}", "}  )  ;", "}", "METHOD_END"], "methodName": ["performCommand"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "for    ( Object   o    :    log )     {", "if    ( o   instanceof   String )     {", "sb . append (  \"  \\ n \"  )  . append ( indent )  . append ( o )  ;", "} else    {", ". printLog ( sb ,     ( indent    +     \"        \"  )  ,     (  ( List )     ( o )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["printLog"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "try    {", "return   data . generate ( generat )  ;", "}    catch    ( CannotResteValue   e )     {", "addFailure ( e )  ;", "throw   e ;", "}", "}", "METHOD_END"], "methodName": ["safeGenerate"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "return   Generator . from (  (    data )     -  >    new   Scenario ( command . get (  )  ,    data )  )  ;", "}", "METHOD_END"], "methodName": ["scenarios"], "fileName": "org.jetbrains.jetCheck.Scenario"}, {"methodBody": ["METHOD_START", "{", "return   new   ShrinkStep (  )     {", "@ Override", "StructureNode   apply ( StructureNode   root )     {", "return   root . replace ( replaced ,    replacement )  ;", "}", "@ Nullable", "@ Override", "ShrinkStep   onSuccess ( StructureNode   smallerRoot )     {", "return   onSuccess    =  =    null    ?    null    :    onSuccess . apply ( smallerRoot )  ;", "}", "@ Nullable", "@ Override", "ShrinkStep   onFailure (  )     {", "return   onFailure    =  =    null    ?    null    :    onFailure . get (  )  ;", "}", "@ Override", "public   String   toString (  )     {", "return    (  (  \" replace    \"     +    replaced )     +     \"    with    \"  )     +    replacement ;", "}", "@ Override", "List <  ?  >    getEqualityObjects (  )     {", "return   Arrays . asList ( replaced ,    replacement )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "org.jetbrains.jetCheck.ShrinkStep"}, {"methodBody": ["METHOD_START", "{", "checkFalsified ( Generator . listsOf ( Generator . stringsOf ( Generator . asciiPrintableChars (  )  )  )  ,     (    l )     -  >     {", "String   s    =    l . toString (  )  ;", "return    !  (  \" abcdefghijklmnopqrstuvwxyz (  )  [  ]  #  !  \"  . chars (  )  . allMatch (  (    c )     -  >     ( s . indexOf (  (  ( char )     ( c )  )  )  )     >  =     0  )  )  ;", "}  ,     3  7  1  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkingComplexString"], "fileName": "org.jetbrains.jetCheck.ShrinkTest"}, {"methodBody": ["METHOD_START", "{", "List < Integer >    list    =    checkGeneratesExample ( Generator . nonEmptyLists ( Generator . integers (  0  ,     1  0  0  )  )  ,     (    l )     -  >    l . contains (  4  2  )  ,     1  2  )  ;", "assertEquals (  1  ,    list . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkingNonEmptyList"], "fileName": "org.jetbrains.jetCheck.ShrinkTest"}, {"methodBody": ["METHOD_START", "{", "Generator < String >    gen    =    Generator . listsOf ( IntDistribution . uniform (  0  ,     2  )  ,    Generator . listsOf ( IntDistribution . uniform (  0  ,     2  )  ,    Generator . sampledFrom (  ' a '  ,     ' b '  )  )  )  . map ( List :  : toString )  ;", "Set < String >    failing    =    new   HashSet <  >  ( Arrays . asList (  \"  [  [ a ,    b ]  ,     [ a ,    b ]  ]  \"  ,     \"  [  [ a ,    b ]  ,     [ a ]  ]  \"  ,     \"  [  [ a ]  ,     [ a ]  ]  \"  ,     \"  [  [ a ]  ]  \"  ,     \"  [  ]  \"  )  )  ;", "Predicate < String >    property    =     (    s )     -  >     !  ( failing . contains ( s )  )  ;", "checkFalsified ( gen ,    property ,     0  )  ;", "for    ( int   i    =     0  ;    i    <     1  0  0  0  ;    i +  +  )     {", "try    {", "Propertyer . customized (  )  . silent (  )  . forAll ( gen ,    property )  ;", "}    catch    ( PropertyFalsified   e )     {", "assertEquals (  \"  [  ]  \"  ,    e . getBreakingValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testWhenEarlyObjectsCannotBeShrunkBeforeLater"], "fileName": "org.jetbrains.jetCheck.ShrinkTest"}, {"methodBody": ["METHOD_START", "{", "return    (    env )     -  >     {", "env . logMessage (  \" c \"  )  ;", "if    (  ( sb . indexOf ( infix )  )     >  =     0  )", "throw   new   AssertionError (  )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["checkDoesNotContain"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "return    (    env )     -  >     {", "int   start    =    env . generateValue ( Generator . integers (  0  ,    sb . length (  )  )  ,    null )  ;", "int   end    =    env . generateValue ( Generator . integers ( start ,    sb . length (  )  )  ,     (  (  (  (  . DELETING )     +     \"     (  \"  )     +    start )     +     \"  ,     % s )  \"  )  )  ;", "sb . delete ( start ,    end )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["deleteStringCmd"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "return    (    env )     -  >     {", "int   index    =    env . generateValue (  . integers (  0  ,    sb . length (  )  )  ,    null )  ;", "String   toInsert    =    env . generateValue (  . stringsOf (  . asciiLetters (  )  )  ,     (  \" insert    % s   at    \"     +    index )  )  ;", "sb . insert ( index ,    toInsert )  ;", "}  ;", "}", "METHOD_END"], "methodName": ["insertStringCmd"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "AtomicInteger   counter    =    new   AtomicInteger (  )  ;", "Supplier < ImperativeCommand >    command    =     (  )     -  >     (    env )     -  >     {", "List < Integer >    list    =    env . generateValue (  . listsOf (  . integers (  )  )  ,     \"  % s \"  )  ;", "if    (  (  ( list . size (  )  )     >     5  )     |  |     (  ( counter . incrementAndGet (  )  )     >     5  0  )  )     {", "throw   new   AssertionError (  )  ;", "}", "}  ;", "try    {", "PropertyChecker . customized (  )  . silent (  )  . checkScenarios ( command )  ;", "fail (  )  ;", "}    catch    ( PropertyFalsified   e )     {", "assertFalse ( e . getMessage (  )  ,    e . getMessage (  )  . contains (  \" forAll (  .  .  .  \"  )  )  ;", "assertTrue ( e . getMessage (  )  ,    e . getMessage (  )  . contains (  \" rechecking (  \"  )  )  ;", "assertTrue ( e . getMessage (  )  ,    e . getMessage (  )  . contains (  \" checkScenarios (  .  .  .  \"  )  )  ;", "PropertyFailure <  ?  >    failure    =    e . getFailure (  )  ;", "try    {", "PropertyChecker . customized (  )  . silent (  )  . rechecking ( failure . getMinimalCounterexample (  )  . getSerializedData (  )  )  . checkScenarios ( command )  ;", "fail (  )  ;", "}    catch    ( PropertyFalsified   fromRecheck )     {", "assertEquals ( e . getBreakingValue (  )  ,    fromRecheck . getBreakingValue (  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["testImperativeCommandRechecking"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Scenario   minHistory    =    checkFalsified ( Scenario . scenarios (  (  )     -  >     (    env )     -  >     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "env . executeCommands (  . withRecursion (  . insertStringCmd ( sb )  ,     . deleteStringCmd ( sb )  ,     . checkDoesNotContain ( sb ,     \" A \"  )  )  )  ;", "}  )  ,    Scenario :  : ensureSuccessful ,     3  3  )  . getMinimalCounterexample (  )  . getExampleValue (  )  ;", "assertEquals (  (  \" commands :  \\ n \"     +     (  \"       insert   A   at    0  \\ n \"     +     \"       check \"  )  )  ,    minHistory . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testImperativeInsertDeleteCheckCommands"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Scenario   minHistory    =    checkFalsified ( Scenario . scenarios (  (  )     -  >     (    env )     -  >     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "ImperativeCommand   replace    =     (    env 1  )     -  >     {", "if    (  ( sb . length (  )  )     =  =     0  )", "return ;", "int   index    =    env 1  . generateValue ( Generator . integers (  0  ,     (  ( sb . length (  )  )     -     1  )  )  ,    null )  ;", "char   toReplace    =    env 1  . generateValue ( Generator . asciiLetters (  )  . suchThat (  (    c )     -  >    c    !  =     ' A '  )  ,     (  (  (  \" replace    \"     +     ( sb . charAt ( index )  )  )     +     \"    with    % s   at    \"  )     +    index )  )  ;", "sb . setCharAt ( index ,    toReplace )  ;", "}  ;", "env . executeCommands (  . withRecursion (  . insertStringCmd ( sb )  ,    replace ,     . deleteStringCmd ( sb )  ,     . checkDoesNotContain ( sb ,     \" A \"  )  )  )  ;", "}  )  ,    Scenario :  : ensureSuccessful ,     5  8  )  . getMinimalCounterexample (  )  . getExampleValue (  )  ;", "assertEquals (  (  \" commands :  \\ n \"     +     (  \"       insert   A   at    0  \\ n \"     +     \"       check \"  )  )  ,    minHistory . toString (  )  )  ;", "}", "METHOD_END"], "methodName": ["testImperativeInsertReplaceDeleteCommands"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "Generator < List < InsertChar >  >    gen    =    Generator . from (  (    data )     -  >     {", "AtomicInteger   modelLength    =    new   AtomicInteger (  0  )  ;", "Generator < List < InsertChar >  >    cmds    =    Generator . listsOf ( Generator . from (  (    cmdData )     -  >     {", "int   index    =    cmdData . drawInt ( IntDistribution . uniform (  0  ,    modelLength . getAndIncrement (  )  )  )  ;", "char   c    =    cmdData . generate ( Generator . asciiLetters (  )  )  ;", "return   new   InsertChar ( c ,    index )  ;", "}  )  )  ;", "return   data . generate ( cmds )  ;", "}  )  ;", "List < InsertChar >    minCmds    =    checkGeneratesExample ( gen ,     (    cmds )     -  >    InsertChar . performOperations ( cmds )  . contains (  \" ab \"  )  ,     1  7  )  ;", "assertEquals ( minCmds . toString (  )  ,     2  ,    minCmds . size (  )  )  ;", "}", "METHOD_END"], "methodName": ["testShrinkingIntsWithDistributionsDependingOnListSize"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "return   Generator . recursive (  (    rec )     -  >     {", "ImperativeCommand   group    =     (    env )     -  >     {", "env . logMessage (  \" Group \"  )  ;", "env . executeCommands ( rec )  ;", "}  ;", "return   Generator . frequency (  2  ,    Generator . constant ( group )  ,     3  ,    Generator . sampledFrom ( commands )  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["withRecursion"], "fileName": "org.jetbrains.jetCheck.StatefulGeneratorTest"}, {"methodBody": ["METHOD_START", "{", "lastPrinted    =    System . currentTimeMillis (  )  ;", "System . err . println (  (  (  (  (  (  (  . formatCurrentTime (  )  )     +     \"  :    failed   on   iteration    \"  )     +     ( currentIteration )  )     +     \"     (  \"  )     +     ( iteration . printSeeds (  )  )  )     +     \"  )  ,    shrinking .  .  .  \"  )  )  ;", "}", "METHOD_END"], "methodName": ["counterExampleFound"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "return   LocalTime . now (  )  . format ( DateTimeFormatter . ofLocalizedTime ( FormatStyle . MEDIUM )  . withLocale ( Locale . getDefault (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["formatCurrentTime"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "currentIteration    =    iteration ;", "if    ( shouldPrint (  )  )     {", "System . out . println (  (  (  (  (  (  (  . formatCurrentTime (  )  )     +     \"  :    iteration    \"  )     +     ( currentIteration )  )     +     \"    of    \"  )     +     ( iterationCount )  )     +     \"  .  .  .  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["iterationStarted"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "StringWriter   stringWriter    =    new   StringWriter (  )  ;", "PrintWriter   writer    =    new   PrintWriter ( stringWriter )  ;", "e . printckTrace ( writer )  ;", "return   stringWriter . getBuffer (  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["printStackTrace"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "String   trace    =    StatusNotifier . printStackTrace ( e )  ;", "return    ( trace . length (  )  )     >     1  0  0  0     ?     ( trace . substring (  0  ,     1  0  0  0  )  )     +     \"  .  .  .  \"     :    trace ;", "}", "METHOD_END"], "methodName": ["shortenStackTrace"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( System . currentTimeMillis (  )  )     -     ( lastPrinted )  )     >     5  0  0  0  )     {", "lastPrinted    =    System . currentTimeMillis (  )  ;", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["shouldPrint"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "if    ( shouldPrint (  )  )     {", "int   stage    =    failure . getMinimizationStageCount (  )  ;", "System . out . println (  (  (  (  (  (  (  (  (  . formatCurrentTime (  )  )     +     \"  :    still   shrinking    (  \"  )     +     ( iteration . printSeeds (  )  )  )     +     \"  )  .     \"  )     +     \" Examples   tried :     \"  )     +     ( failure . getTotalMinimizationExampleCount (  )  )  )     +     \"  ,    successful   minimizations :     \"  )     +    stage )  )  ;", "if    (  ( lastReportedStage )     !  =    stage )     {", "lastReportedStage    =    stage ;", "System . err . println (  (  \"    Current   minimal   example :     \"     +     ( failure . getMinimalCounterexample (  )  . getExampleValue (  )  )  )  )  ;", "Throwable   exceptionCause    =    failure . getMinimalCounterexample (  )  . getExceptionCause (  )  ;", "if    ( exceptionCause    !  =    null )     {", "String   trace    =     . shortenStackTrace ( exceptionCause )  ;", "if    (  !  ( trace . equals ( lastReportedTrace )  )  )     {", "lastReportedTrace    =    trace ;", "System . err . println (  (  \"    Reason :     \"     +    trace )  )  ;", "}", "}", "System . err . println (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["shrinkAttempt"], "fileName": "org.jetbrains.jetCheck.StatusNotifier"}, {"methodBody": ["METHOD_START", "{", "children . add ( child )  ;", "}", "METHOD_END"], "methodName": ["addChild"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "return   children . iterator (  )  ;", "}", "METHOD_END"], "methodName": ["childrenIterator"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "for    ( StructureElement   child    :    children )     {", "if    ( child   instanceof    )     {", "Generator <  ?  >    childGen    =    child . id . generator ;", "if    (  ( childGen    !  =    null )     &  &     ( generator . getGeneratorFunction (  )  . equals ( childGen . getGeneratorFunction (  )  )  )  )     {", "result . add (  (  (  )     ( child )  )  )  ;", "} else    {", "(  (  )     ( child )  )  . findChildrenWithGenerator ( generator ,    result )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["findChildrenWithGenerator"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "while    (  ( i    <     ( children . size (  )  )  )     &  &     (  ( children . get ( i )  . id . number )     <  =     ( id . number )  )  )", "i +  +  ;", "ren   i    -     1  ;", "}", "METHOD_END"], "methodName": ["indexOfChildContaining"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "if    (  (  (  ( children . size (  )  )     >     1  )     &  &     (  ( children . get (  0  )  )    instanceof   IntData )  )     &  &     (  (  (  ( IntData )     ( children . get (  0  )  )  )  . value )     >  =     (  ( children . size (  )  )     -     1  )  )  )     {", "for    ( int   i    =     1  ;    i    <     ( children . size (  )  )  ;    i +  +  )     {", "if    (  !  (  ( children . get ( i )  )    instanceof    )  )", "return   false ;", "}", "return   true ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isList"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( children . isEmpty (  )  )     |  |     (  ( children . get (  (  ( children . size (  )  )     -     1  )  )  )     !  =    node )  )     {", "throw   new   IllegalStateException (  \" Last   sub - s   changed \"  )  ;", "}", "children . remove (  (  ( children . size (  )  )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["removeLastChild"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "int   minIndex    =     ( isList (  )  )     ?     1     :     0  ;", "for    (  ;    index    >  =    minIndex ;    index -  -  )     {", "ShrinkStep   childShrink    =    children . get ( index )  . shrink (  )  ;", "if    ( childShrink    !  =    null )", "ren   wrapChildShrink ( index ,    childShrink )  ;", "}", "ren   shrinkRecursion (  )  ;", "}", "METHOD_END"], "methodName": ["shrinkChild"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "if    (  ( id . generator )     !  =    null )     {", "List <  >    sameGeneratorChildren    =    new   ArrayList <  >  (  )  ;", "findChildrenWithGenerator ( id . generator ,    sameGeneratorChildren )  ;", "return   tryReplacing ( sameGeneratorChildren ,     0  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["shrinkRecursion"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "StructureNode   e    =    new   StructureNode ( id . childId ( generator )  )  ;", "addChild ( e )  ;", "return   e ;", "}", "METHOD_END"], "methodName": ["subStructure"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "if    ( index    <     ( candidates . size (  )  )  )     {", "replacement    =    candidates . get ( index )  ;", "return   ShrinkStep . create ( id ,    replacement ,     (     _  _  )     -  >    replacement . shrink (  )  ,     (  )     -  >    tryReplacing ( candidates ,     ( index    +     1  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["tryReplacing"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "if    ( step    =  =    null )", "return   shrinkChild (  ( index    -     1  )  )  ;", "NodeId   oldChild    =    children . get ( index )  . id ;", "return   new   ShrinkStep (  )     {", "@ Override", "List <  ?  >    getEqualityObjects (  )     {", "return   Collections . singletonList ( step )  ;", "}", "@ Nullable", "@ Override", "apply (    root )     {", "return   step . apply ( root )  ;", "}", "@ Override", "ShrinkStep   onSuccess (    smallerRoot )     {", "inheritor    =     (  (  )     ( Objects . requireNonNull ( smallerRoot . findChildById ( id )  )  )  )  ;", "assert    ( inheritor . children . size (  )  )     =  =     ( children . size (  )  )  ;", "if    (  ( inheritor . children . get ( index )  . id )     !  =    oldChild )     {", "return   inheritor . shrink (  )  ;", "}", "return   inheritor . wrapChildShrink ( index ,    step . onSuccess ( smallerRoot )  )  ;", "}", "@ Override", "ShrinkStep   onFailure (  )     {", "return   wrapChildShrink ( index ,    step . onFailure (  )  )  ;", "}", "@ Override", "public   String   toString (  )     {", "return    \"  -  \"     +     ( step . toString (  )  )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["wrapChildShrink"], "fileName": "org.jetbrains.jetCheck.StructureNode"}, {"methodBody": ["METHOD_START", "{", "PropertyFailure . CounterExample < Scenario >    example    =    checkFalsified ( Scenario . scenarios (  (  )     -  >     (    env )     -  >     {", "StringBuilder   sb    =    new   StringBuilder (  )  ;", "env . executeCommands ( StatefulGeneratorTest . withRecursion ( StatefulGeneratorTest . insertStringCmd ( sb )  ,    StatefulGeneratorTest . deleteStringCmd ( sb )  ,     (    e )     -  >     {", "if    (  . containsSubSequence ( sb . toString (  )  ,    subSequence )  )     {", "throw   new   AssertionError (  (  \" Found    \"     +     ( sb . toString (  )  )  )  )  ;", "}", "}  )  )  ;", "}  )  ,    Scenario :  : ensureSuccessful ,    expectedMinimizations )  . getMinimalCounterexample (  )  ;", "String   log    =    example . getExampleValue (  )  . toString (  )  ;", "assertEquals ( log ,     (  \" Found    \"     +     ( subSequence )  )  ,    example . getExceptionCause (  )  . getMessage (  )  )  ;", "assertFalse ( log ,    log . contains ( StatefulGeneratorTest . DELETING )  )  ;", "}", "METHOD_END"], "methodName": ["checkGeneratesSubSequence"], "fileName": "org.jetbrains.jetCheck.SubSequenceTest"}, {"methodBody": ["METHOD_START", "{", "int   pos    =     -  1  ;", "for    ( int   i    =     0  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "pos    =    string . indexOf ( s . charAt ( i )  ,     ( pos    +     1  )  )  ;", "if    ( pos    <     0  )", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["containsSubSequence"], "fileName": "org.jetbrains.jetCheck.SubSequenceTest"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( new   Object [  ]  {     \" abcde \"  ,     4  4  8     }  ,    new   Object [  ]  {     \" abcdef \"  ,     4  6  3     }  ,    new   Object [  ]  {     \" sadf \"  ,     1  1  7     }  ,    new   Object [  ]  {     \" asdf \"  ,     1  3  2     }  ,    new   Object [  ]  {     \" xxx \"  ,     9  6     }  ,    new   Object [  ]  {     \" AA \"  ,     6  0     }  )  ;", "}", "METHOD_END"], "methodName": ["data"], "fileName": "org.jetbrains.jetCheck.SubSequenceTest"}]