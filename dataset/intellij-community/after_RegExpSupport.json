[{"methodBody": ["METHOD_START", "{", "return   IconLoader . getIcon ( path ,    RegExpSupportIcons . class )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "icons.RegExpSupportIcons"}, {"methodBody": ["METHOD_START", "{", "return    ( c    >  =     '  0  '  )     &  &     ( c    <  =     '  9  '  )  ;", "}", "METHOD_END"], "methodName": ["isDigit"], "fileName": "org.intellij.lang.regexp.AsciiUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( AsciiUtil . isUpperCase ( c )  )     |  |     ( AsciiUtil . isLowerCase ( c )  )  ;", "}", "METHOD_END"], "methodName": ["isLetter"], "fileName": "org.intellij.lang.regexp.AsciiUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( AsciiUtil . isLetter ( c )  )     |  |     ( AsciiUtil . isDigit ( c )  )  ;", "}", "METHOD_END"], "methodName": ["isLetterOrDigit"], "fileName": "org.intellij.lang.regexp.AsciiUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( c    >  =     ' a '  )     &  &     ( c    <  =     ' z '  )  ;", "}", "METHOD_END"], "methodName": ["isLowerCase"], "fileName": "org.intellij.lang.regexp.AsciiUtil"}, {"methodBody": ["METHOD_START", "{", "return    ( c    >  =     ' A '  )     &  &     ( c    <  =     ' Z '  )  ;", "}", "METHOD_END"], "methodName": ["isUpperCase"], "fileName": "org.intellij.lang.regexp.AsciiUtil"}, {"methodBody": ["METHOD_START", "{", "return   myPropertyNames ;", "}", "METHOD_END"], "methodName": ["getAllKnownProperties"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "return   DefaultRegExpPropertiesProvider . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "return   myCharacterClasses ;", "}", "METHOD_END"], "methodName": ["getKnownCharacterClasses"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "return   myPosixCharacterClasses ;", "}", "METHOD_END"], "methodName": ["getPosixCharacterClasses"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmptyOrSpaces ( name )  )     {", "return   null ;", "}", "for    ( String [  ]    stringArray    :    myyNames )     {", "if    ( stringArray [  0  ]  . equals ( name )  )     {", "return    ( stringArray . length )     >     1     ?    stringArray [  1  ]     :    stringArray [  0  ]  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getPropertyDescription"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "if    ( category . startsWith (  \" In \"  )  )     {", "try    {", "return    ( Character . UnicodeBlock . forName ( category . substring (  2  )  )  )     !  =    null ;", "}    catch    ( IllegalArgumentException   e )     {", "return   false ;", "}", "}", "category    =    StringUtil . trimStart ( category ,     \" Is \"  )  ;", "for    ( String [  ]    name    :    myyNames )     {", "if    ( name [  0  ]  . equals ( category )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isValidCategory"], "fileName": "org.intellij.lang.regexp.DefaultRegExpPropertiesProvider"}, {"methodBody": ["METHOD_START", "{", "result . addElement ( RegExpCompletionContributor . createLookupElement ( name ,    type ,    icon )  )  ;", "}", "METHOD_END"], "methodName": ["addLookupElement"], "fileName": "org.intellij.lang.regexp.RegExpCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "return   LookupElementBuilder . create ( name )  . withTypeText ( type )  . withIcon ( icon )  ;", "}", "METHOD_END"], "methodName": ["createLookupElement"], "fileName": "org.intellij.lang.regexp.RegExpCompletionContributor"}, {"methodBody": ["METHOD_START", "{", "String   inputDataFileName    =    RegExpCompletionTest . getInputDataFileName ( getTestName ( true )  )  ;", "String   expectedResultFileName    =    RegExpCompletionTest . getExpectedResultFileName ( getTestName ( true )  )  ;", "myFixture . testCompletion ( inputDataFileName ,    expectedResultFileName )  ;", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( Character . toUpperCase ( testName . charAt (  0  )  )  )     +     ( testName . substring (  1  )  )  )     +     \" Expected \"  )     +     \"  . regexp \"  ;", "}", "METHOD_END"], "methodName": ["getExpectedResultFileName"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Character . toUpperCase ( testName . charAt (  0  )  )  )     +     ( testName . substring (  1  )  )  )     +     \"  . regexp \"  ;", "}", "METHOD_END"], "methodName": ["getInputDataFileName"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    nameList    =    new   ArrayList <  >  ( Arrays . asList (  \" d \"  ,     \" D \"  ,     \" s \"  ,     \" S \"  ,     \" w \"  ,     \" W \"  ,     \" b \"  ,     \" B \"  ,     \" A \"  ,     \" G \"  ,     \" Z \"  ,     \" z \"  ,     \" Q \"  ,     \" E \"  ,     \" t \"  ,     \" n \"  ,     \" r \"  ,     \" f \"  ,     \" a \"  ,     \" e \"  ,     \" h \"  ,     \" H \"  ,     \" v \"  ,     \" V \"  ,     \" R \"  ,     \" X \"  ,     \" b { g }  \"  )  )  ;", "for    ( String [  ]    stringArray    :    DefaultRegExpPropertiesProvider . getInstance (  )  . getAllKnownProperties (  )  )     {", "nameList . add (  (  (  \" p {  \"     +     ( stringArray [  0  ]  )  )     +     \"  }  \"  )  )  ;", "}", "myFixture . testCompletionVariants (  . getInputDataFileName ( getTestName ( true )  )  ,    ArrayUtil . toStringArray ( nameList )  )  ;", "}", "METHOD_END"], "methodName": ["testBackSlashVariants"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( RegExpFileType . INSTANCE ,     \"  \\  \\ N { SMILE < caret >  }  \"  )  ;", "final   LookupElement [  ]    elements    =    myFixture . completeBasic (  )  ;", "final   List < String >    strings    =    ContainerUtil . map ( elements ,    LookupElement :  : getLookupString )  ;", "assertEquals ( Arrays . asList (  \" SMILE \"  ,     \" SMILING   FACE   WITH   SMILING   EYES \"  ,     \" SMILING   FACE   WITH   HEART - SHAPED   EYES \"  ,     \" SMILING   CAT   FACE   WITH   HEART - SHAPED   EYES \"  ,     \" SMILING   FACE   WITH   OPEN   MOUTH   AND   SMILING   EYES \"  ,     \" SMILING   FACE   WITH   OPEN   MOUTH   AND   TIGHTLY - CLOSED   EYES \"  ,     \" CAT   FACE   WITH   WRY   SMILE \"  ,     \" GRINNING   CAT   FACE   WITH   SMILING   EYES \"  ,     \" GRINNING   FACE   WITH   SMILING   EYES \"  ,     \" KISSING   FACE   WITH   SMILING   EYES \"  )  ,    strings )  ;", "}", "METHOD_END"], "methodName": ["testNamedCharacter"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "myFixture . configureByText ( RegExpFileType . INSTANCE ,     \"  \\  \\ P { Alp < caret >  }  \"  )  ;", "myFixture . completeBasic (  )  ;", "myFixture . checkResult (  \"  \\  \\ P { Alpha < caret >  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyAlpha"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "List < String >    nameList    =    new   ArrayList <  >  (  )  ;", "for    ( String [  ]    stringArray    :    DefaultRegExpPropertiesProvider . getInstance (  )  . getAllKnownProperties (  )  )     {", "nameList . add (  (  (  \"  {  \"     +     ( stringArray [  0  ]  )  )     +     \"  }  \"  )  )  ;", "}", "myFixture . testCompletionVariants (  . getInputDataFileName ( getTestName ( true )  )  ,    ArrayUtil . toStringArray ( nameList )  )  ;", "}", "METHOD_END"], "methodName": ["testPropertyVariants"], "fileName": "org.intellij.lang.regexp.RegExpCompletionTest"}, {"methodBody": ["METHOD_START", "{", "return   RegExpFileType . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getFileType"], "fileName": "org.intellij.lang.regexp.RegExpFile"}, {"methodBody": ["METHOD_START", "{", "return   PsiTreeUtil . findChildrenOfType ( this ,    RegExpGroup . class )  ;", "}", "METHOD_END"], "methodName": ["getGroups"], "fileName": "org.intellij.lang.regexp.RegExpFile"}, {"methodBody": ["METHOD_START", "{", "PsiElement   host    =    InjectedLanguageUtil . findInjectionHost ( psi )  ;", "if    (  ( host    =  =    null )     &  &     (  !  ( psi   instanceof   PsiFile )  )  )", "host    =    psi . getParent (  )  ;", "Language   language    =     ( host    =  =    null )     ?    null    :    host . getLanguage (  )  ;", "RegExpCapabilitiesProvider   provider    =     ( language    =  =    null )     ?    null    :    RegExpCapabilitiesProvider . EP . forLanguage ( language )  ;", "return   provider    =  =    null    ?    capabilities    :    EnumSet . copyOf ( provider . setup ( host ,    capabilities )  )  ;", "}", "METHOD_END"], "methodName": ["setupCapabilities"], "fileName": "org.intellij.lang.regexp.RegExpFileElementType"}, {"methodBody": ["METHOD_START", "{", "return    \" Regular   Expression \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.intellij.lang.regexp.RegExpFileType"}, {"methodBody": ["METHOD_START", "{", "return   myIcon ;", "}", "METHOD_END"], "methodName": ["getIcon"], "fileName": "org.intellij.lang.regexp.RegExpFileType"}, {"methodBody": ["METHOD_START", "{", "return    \" RegExp \"  ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.intellij.lang.regexp.RegExpFileType"}, {"methodBody": ["METHOD_START", "{", "return   Double . parseDouble ( number . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["getQuantifierValue"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   RegExpLanguageHost . EMPTY _ NAMED _ GROUP _ TYPES ;", "}", "METHOD_END"], "methodName": ["getSupportedNamedGroupTypes"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ,    length    =    name . length (  )  ;    i    <    length ;    i +  +  )     {", "final   char   c    =    name . charAt ( i )  ;", "if    (  (  !  ( AsciiUtil . isLetterOrDigit ( c )  )  )     &  &     ( c    !  =     '  _  '  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isValidGroupName"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   supportsNamedCharacters ( namedCharacter )  ;", "}", "METHOD_END"], "methodName": ["isValidNamedCharacter"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "switch    ( boundary . getType (  )  )     {", "case   UNICODE _ EXTENDED _ GRAPHEME    :", "return   false ;", "case   LINE _ START    :", "case   LINE _ END    :", "case   WORD    :", "case   NON _ WORD    :", "case   BEGIN    :", "case   END    :", "case   END _ NO _ LINE _ TERM    :", "case   PREVIOUS _ MATCH    :", "default    :", "return   true ;", "}", "}", "METHOD_END"], "methodName": ["supportsBoundary"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsInlineOptionFlag"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsLiteralBackspace"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   RegExpLanguageHost . Lookbehind . FULL ;", "}", "METHOD_END"], "methodName": ["supportsLookbehind"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["supportsNamedCharacters"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["supportsSimpleClass"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHost"}, {"methodBody": ["METHOD_START", "{", "if    ( element    =  =    null )     {", "return   null ;", "}", "final   PsiFile   file    =    element . getContainingFile (  )  ;", "final   PsiElement   context    =    file . getContext (  )  ;", "if    ( context   instanceof   RegExpLanguageHost )     {", "return    (  ( RegExpLanguageHost )     ( context )  )  ;", "}", "if    ( context    !  =    null )     {", "return    . INSTANCE . forClass ( context . getClass (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findRegExpHost"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( element )  ;", "return   host    !  =    null    ?    host . getAllKnownProperties (  )     :    myDefaultProvider . getAllKnownProperties (  )  ;", "}", "METHOD_END"], "methodName": ["getAllKnownProperties"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "return   RegExpLanguageHosts . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( element )  ;", "return   host    !  =    null    ?    host . getKnownCharacterClasses (  )     :    myDefaultProvider . getKnownCharacterClasses (  )  ;", "}", "METHOD_END"], "methodName": ["getKnownCharacterClasses"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "return   myDefaultProvider . getPosixCharacterClasses (  )  ;", "}", "METHOD_END"], "methodName": ["getPosixCharacterClasses"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( element )  ;", "return   host    !  =    null    ?    host . getPropertyDescription ( name )     :    myDefaultProvider . getPropertyDescription ( name )  ;", "}", "METHOD_END"], "methodName": ["getPropertyDescription"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( valueElement )  ;", "if    ( host    =  =    null )     {", "return   Double . valueOf ( valueElement . getText (  )  )  ;", "}", "return   host . getQuantifierValue ( valueElement )  ;", "}", "METHOD_END"], "methodName": ["getQuantifierValue"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( context )  ;", "if    ( host    =  =    null )     {", "return   Collections . emptySet (  )  ;", "}", "return   host . getSupportedNamedGroupTypes ( context )  ;", "}", "METHOD_END"], "methodName": ["getSupportedNamedGroupTypes"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "if    (  ( text . length (  )  )     <  =     1  )     {", "return   false ;", "}", "final   RegExpLanguageHost   host    =     . findRegExpHost ( ch )  ;", "if    ( host    !  =    null )     {", "final   char   c    =    text . charAt (  1  )  ;", "return    !  ( host . characterNeedsEscaping ( c )  )  ;", "} else    {", "return    !  (  (  \"  \\  \\  ]  \"  . equals ( text )  )     |  |     (  \"  \\  \\  }  \"  . equals ( text )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["isRedundantEscape"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( element )  ;", "return   host    !  =    null    ?    host . isValidCategory ( category )     :    myDefaultProvider . isValidCategory ( category )  ;", "}", "METHOD_END"], "methodName": ["isValidCategory"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( group )  ;", "return    ( host    !  =    null )     &  &     ( host . isValidGroupName ( name ,    group )  )  ;", "}", "METHOD_END"], "methodName": ["isValidGroupName"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( namedCharacter )  ;", "return    ( host    !  =    null )     &  &     ( host . isValidNamedCharacter ( namedCharacter )  )  ;", "}", "METHOD_END"], "methodName": ["isValidNamedCharacter"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( boundary )  ;", "return    ( host    =  =    null )     |  |     ( host . supportsBoundary ( boundary )  )  ;", "}", "METHOD_END"], "methodName": ["supportsBoundary"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( regExpChar )  ;", "try    {", "return    ( host    !  =    null )     &  &     ( host . supportsExtendedHexCharacter ( regExpChar )  )  ;", "}    catch    ( AbstractMethodError   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["supportsExtendedHexCharacter"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( context )  ;", "return    ( host    =  =    null )     |  |     ( host . supportsInlineOptionFlag ( flag ,    context )  )  ;", "}", "METHOD_END"], "methodName": ["supportsInlineOptionFlag"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( regExpChar )  ;", "return    ( host    !  =    null )     &  &     ( host . supportsLiteralBackspace ( regExpChar )  )  ;", "}", "METHOD_END"], "methodName": ["supportsLiteralBackspace"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( group )  ;", "if    ( host    =  =    null )     {", "return   RegExpLanguageHost . Lookbehind . FULL ;", "}", "return   host . supportsLookbehind ( group )  ;", "}", "METHOD_END"], "methodName": ["supportsLookbehind"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( namedCharacter )  ;", "return    ( host    !  =    null )     &  &     ( host . supportsNamedCharacters ( namedCharacter )  )  ;", "}", "METHOD_END"], "methodName": ["supportsNamedCharacters"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( ref )  ;", "try    {", "return    ( host    !  =    null )     &  &     ( host . supportsNamedGroupRefSyntax ( ref )  )  ;", "}    catch    ( AbstractMethodError   e )     {", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["supportsNamedGroupRefSyntax"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( group )  ;", "return    ( host    !  =    null )     &  &     ( host . supportsNamedGroupSyntax ( group )  )  ;", "}", "METHOD_END"], "methodName": ["supportsNamedGroupSyntax"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( comment )  ;", "return    ( host    !  =    null )     &  &     ( host . supportsPerl 5 EmbeddedComments (  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsPerl5EmbeddedComments"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( context )  ;", "return    ( host    =  =    null )     |  |     ( host . supportsPossessiveQuantifiers (  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsPossessiveQuantifiers"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( condRef )  ;", "return    ( host    !  =    null )     &  &     ( host . supportsPythonConditionalRefs (  )  )  ;", "}", "METHOD_END"], "methodName": ["supportsPythonConditionalRefs"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLanguageHost   host    =    RegExpLanguageHosts . findRegExpHost ( simpleClass )  ;", "return    ( host    =  =    null )     |  |     ( host . supportsSimpleClass ( simpleClass )  )  ;", "}", "METHOD_END"], "methodName": ["supportsSimpleClass"], "fileName": "org.intellij.lang.regexp.RegExpLanguageHosts"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  [ a &  &  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  &  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  &  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testAmpersand"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  (  ?  > atom )  \"  ,     (  \" ATOMIC _ GROUP    (  \\  '  (  ?  >  \\  '  )  \\ n \"     +     (  (  (  (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  ' t \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' o \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' m \\  '  )  \\ n \"  )     +     \" GROUP _ END    (  '  )  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  (  ?  : no )  \"  ,     (  \" NON _ CAPT _ GROUP    (  \\  '  (  ?  :  \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  ' n \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  ' o \\  '  )  \\ n \"  )     +     \" GROUP _ END    (  '  )  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testAtomicGroup"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  ( a )  ( b )  ( c )  ( d )  ( e )  ( f )  ( g )  ( h )  ( i )  ( j )  \\  \\  1  0  5  \"  ,    null ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testBackReference"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\ b \\  \\ b { g }  \\  \\ B \\  \\ A \\  \\ z \\  \\ Z \\  \\ G [  \\  \\ b \\  \\ b { g }  \\  \\ B \\  \\ A \\  \\ z \\  \\ Z \\  \\ G ]  \"  ,     (  \" BOUNDARY    (  \\  '  \\  \\ b \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" BOUNDARY    (  \\  '  \\  \\ b { g }  \\  '  )  \\ n \"     +     \" BOUNDARY    (  \\  '  \\  \\ B \\  '  )  \\ n \"  )     +     \" BOUNDARY    (  \\  '  \\  \\ A \\  '  )  \\ n \"  )     +     \" BOUNDARY    (  \\  '  \\  \\ z \\  '  )  \\ n \"  )     +     \" BOUNDARY    (  \\  '  \\  \\ Z \\  '  )  \\ n \"  )     +     \" BOUNDARY    (  \\  '  \\  \\ G \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ b \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ b \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' g \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  }  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ B \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ A \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ z \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ Z \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ G \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testBoundaries"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  [  \\  \\  ^  \\  \\  ^  ]  \\  \\  ^  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" ESC _ CHARACTER    (  \\  '  \\  \\  ^  \\  '  )  \\ n \"     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  ^  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  ^  \\  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testCaret"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  ^  \\  \\  ^  [  ^  ^  ]  \"  ,     (  \" CARET    (  \\  '  ^  \\  '  )  \\ n \"     +     (  (  (  (  \" ESC _ CHARACTER    (  \\  '  \\  \\  ^  \\  '  )  \\ n \"     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" CARET    (  \\  '  ^  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ^  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testCarets"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\ n \\  \\ b \\  \\ t \\  \\ r \\  \\ f [  \\  \\ n \\  \\ b \\  \\ t \\  \\ r \\  \\ f ]  \"  ,     (  \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ n \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" BOUNDARY    (  \\  '  \\  \\ b \\  '  )  \\ n \"     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ t \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ r \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ f \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ n \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ b \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ t \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ r \\  '  )  \\ n \"  )     +     \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\ f \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  \\ n \\ t \\ r \\ f [  \\ n \\ t \\ r \\ f ]  \"  ,     (  \" CTRL _ CHARACTER    (  \\  '  \\  \\ n \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  \" CTRL _ CHARACTER    (  \\  '  \\ t \\  '  )  \\ n \"     +     \" CTRL _ CHARACTER    (  \\  '  \\ n \\  '  )  \\ n \"  )     +     \" CTRL _ CHARACTER    (  \\  '  \\ f \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" CTRL _ CHARACTER    (  \\  '  \\  \\ n \\  '  )  \\ n \"  )     +     \" CTRL _ CHARACTER    (  \\  '  \\ t \\  '  )  \\ n \"  )     +     \" CTRL _ CHARACTER    (  \\  '  \\ n \\  '  )  \\ n \"  )     +     \" CTRL _ CHARACTER    (  \\  '  \\ f \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testControlCharacters"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . TRANSFORMATION _ ESCAPES )  )  ;", "final   String   text    =     \"  \\  \\ U $  1  \\  \\ E \\  \\ u $  3  \\  \\ l $  4  \\  \\ L $  2  \\  \\ E \"  ;", "doTest ( text ,     (  \" CHAR _ CLASS    (  \\  '  \\  \\ U \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHAR _ CLASS    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" CHAR _ CLASS    (  \\  '  \\  \\ u \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  3  \\  '  )  \\ n \"  )     +     \" CHAR _ CLASS    (  \\  '  \\  \\ l \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  4  \\  '  )  \\ n \"  )     +     \" CHAR _ CLASS    (  \\  '  \\  \\ L \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" CHAR _ CLASS    (  \\  '  \\  \\ E \\  '  )  \"  )  )  ,    lexer )  ;", "lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest ( text ,     (  \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ U \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" INVALID _ UNICODE _ ESCAPE _ TOKEN    (  \\  '  \\  \\ u \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  3  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ l \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  4  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ L \\  '  )  \\ n \"  )     +     \" DOLLAR    (  \\  '  $  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ E \\  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testEditorReplacement"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  [  \\  \\ k < a >     (  ?  < t > t )  \\  \\ g \\  ' q \\  '  \\  \\ R ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ k \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  <  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  >  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '     \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  (  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ?  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  <  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' t \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  >  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' t \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ g \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  \\  '  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' q \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  \\  '  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\ R \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  \\  \\  {  \\  \\  *  \\  \\  +  \\  \\  ?  \\  \\  $  [  \\  \\  {  \\  \\  *  \\  \\  +  \\  \\  ?  \\  \\  $  ]  \"  ,     (  \" ESC _ CHARACTER    (  \\  '  \\  \\  {  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" ESC _ CHARACTER    (  \\  '  \\  \\  *  \\  '  )  \\ n \"     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  +  \\  '  )  \\ n \"  )     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  ?  \\  '  )  \\ n \"  )     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  $  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  {  \\  '  )  \\ n \"  )     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  *  \\  '  )  \\ n \"  )     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  +  \\  '  )  \\ n \"  )     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  ?  \\  '  )  \\ n \"  )     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  $  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testEscapesInsideCharClass"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . ONE _ HEX _ CHAR _ ESCAPE )  )  ;", "doTest (  \"  \\  \\ x \\  \\ x 1  \\  \\ x 0  1  \"  ,     (  \" BAD _ HEX _ VALUE    (  \\  '  \\  \\ x \\  '  )  \\ n \"     +     (  \" HEX _ CHAR    (  \\  '  \\  \\ x 1  \\  '  )  \\ n \"     +     \" HEX _ CHAR    (  \\  '  \\  \\ x 0  1  \\  '  )  \"  )  )  ,    lexer )  ;", "final   RegExpLexer   lexer 2     =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\ x \\  \\ x 1  \\  \\ x 0  1  \"  ,     (  \" BAD _ HEX _ VALUE    (  \\  '  \\  \\ x \\  '  )  \\ n \"     +     (  (  \" BAD _ HEX _ VALUE    (  \\  '  \\  \\ x \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" HEX _ CHAR    (  \\  '  \\  \\ x 0  1  \\  '  )  \"  )  )  ,    lexer 2  )  ;", "}", "METHOD_END"], "methodName": ["testHexChar"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . NESTED _ CHARACTER _ CLASSES )  )  ;", "doTest (  \"  [ a &  &  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" ANDAND    (  \\  '  &  &  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testIntersection"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO ,    RegExpCapability . MAX _ OCTAL _  1  7  7  )  )  ;", "doTest (  \"  \\  \\  1  7  7  \\  \\  2  0  0  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  1  7  7  \\  '  )  \\ n \"     +     (  \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  2  0  \\  '  )  \\ n \"     +     \" CHARACTER    (  '  0  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testMaxOctalNoLeadingZero1"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO ,    RegExpCapability . MAX _ OCTAL _  3  7  7  )  )  ;", "doTest (  \"  \\  \\  1  7  7  \\  \\  2  0  0  \\  \\  3  7  7  \\  \\  4  0  0  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  1  7  7  \\  '  )  \\ n \"     +     (  (  (  \" OCT _ CHAR    (  \\  '  \\  \\  2  0  0  \\  '  )  \\ n \"     +     \" OCT _ CHAR    (  \\  '  \\  \\  3  7  7  \\  '  )  \\ n \"  )     +     \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  4  0  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  0  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testMaxOctalNoLeadingZero2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  \"  \\  \\  1  7  7  \\  \\  2  0  0  \\  \\  3  7  7  \\  \\  4  0  0  \\  \\  7  7  7  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  1  7  7  \\  '  )  \\ n \"     +     (  (  (  \" OCT _ CHAR    (  \\  '  \\  \\  2  0  0  \\  '  )  \\ n \"     +     \" OCT _ CHAR    (  \\  '  \\  \\  3  7  7  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  4  0  0  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  7  7  7  \\  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testMaxOctalNoLeadingZero3"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . MYSQL _ BRACKET _ EXPRESSIONS )  )  ;", "doTest (  \"  [  [  =  .  =  ]  [  = c =  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  \" MYSQL _ CHAR _ EQ _ BEGIN    (  \\  '  [  =  \\  '  )  \\ nCHARACTER    (  \\  '  .  \\  '  )  \\ nMYSQL _ CHAR _ EQ _ END    (  \\  '  =  ]  \\  '  )  \\ n \"     +     \" MYSQL _ CHAR _ EQ _ BEGIN    (  \\  '  [  =  \\  '  )  \\ nCHARACTER    (  \\  ' c \\  '  )  \\ nMYSQL _ CHAR _ EQ _ END    (  \\  '  =  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testMysqlCharEqExpressions"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . MYSQL _ BRACKET _ EXPRESSIONS )  )  ;", "doTest (  \"  [  [  .  ~  .  ]  [  . tilda .  ]  [  . NUL .  ]  [  . plus - sign .  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" MYSQL _ CHAR _ BEGIN    (  \\  '  [  .  \\  '  )  \\ nCHARACTER    (  \\  '  ~  \\  '  )  \\ nMYSQL _ CHAR _ END    (  \\  '  .  ]  \\  '  )  \\ n \"     +     \" MYSQL _ CHAR _ BEGIN    (  \\  '  [  .  \\  '  )  \\ nNAME    (  \\  ' tilda \\  '  )  \\ nMYSQL _ CHAR _ END    (  \\  '  .  ]  \\  '  )  \\ n \"  )     +     \" MYSQL _ CHAR _ BEGIN    (  \\  '  [  .  \\  '  )  \\ nNAME    (  \\  ' NUL \\  '  )  \\ nMYSQL _ CHAR _ END    (  \\  '  .  ]  \\  '  )  \\ n \"  )     +     \" MYSQL _ CHAR _ BEGIN    (  \\  '  [  .  \\  '  )  \\ nNAME    (  \\  ' plus - sign \\  '  )  \\ nMYSQL _ CHAR _ END    (  \\  '  .  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testMysqlCharExpressions"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . POSIX _ BRACKET _ EXPRESSIONS )  )  ;", "doTest (  \"  [  [  :  ^ xdigit :  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" BRACKET _ EXPRESSION _ BEGIN    (  \\  '  [  :  \\  '  )  \\ n \"     +     \" CARET    (  \\  '  ^  \\  '  )  \\ n \"  )     +     \" NAME    (  \\  ' xdigit \\  '  )  \\ n \"  )     +     \" BRACKET _ EXPRESSION _ END    (  \\  '  :  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testNegatedPosixBracketExpression"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . NESTED _ CHARACTER _ CLASSES )  )  ;", "doTest (  \"  [ a - z &  &  [  ^ aeuoi ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" MINUS    (  \\  '  -  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' z \\  '  )  \\ n \"  )     +     \" ANDAND    (  \\  '  &  &  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" CARET    (  \\  '  ^  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' e \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' u \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' o \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' i \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testNestedCharacterClasses1"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . NESTED _ CHARACTER _ CLASSES )  )  ;", "doTest (  \"  [  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  \\  \\  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  ]  \\  '  )  \\ n \"     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  [  ]  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [     \\  \\  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '     \\  '  )  \\ n \"     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  \\  \\ Q \\  \\ E ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" QUOTE _ BEGIN    (  \\  '  \\  \\ Q \\  '  )  \\ n \"     +     \" QUOTE _ END    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  \\  \\ Q +  \\  \\ E ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" QUOTE _ BEGIN    (  \\  '  \\  \\ Q \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  +  \\  '  )  \\ n \"  )     +     \" QUOTE _ END    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  ^  \\  \\ Q \\  \\ E ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" CARET    (  \\  '  ^  \\  '  )  \\ n \"     +     \" QUOTE _ BEGIN    (  \\  '  \\  \\ Q \\  '  )  \\ n \"  )     +     \" QUOTE _ END    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  ^  \\  \\ Q +  \\  \\ E ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  \" CARET    (  \\  '  ^  \\  '  )  \\ n \"     +     \" QUOTE _ BEGIN    (  \\  '  \\  \\ Q \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  +  \\  '  )  \\ n \"  )     +     \" QUOTE _ END    (  \\  '  \\  \\ E \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "final   RegExpLexer   lexer 2     =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . COMMENT _ MODE )  )  ;", "doTest (  \"  [     \\ t \\ n ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" WHITE _ SPACE    (  \\  '     \\  '  )  \\ n \"     +     \" WHITE _ SPACE    (  \\  '  \\ t \\  '  )  \\ n \"  )     +     \" WHITE _ SPACE    (  \\  '  \\  \\ n \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer 2  )  ;", "doTest (  \"  [  \\  \\     ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  \" ESC _ CTRL _ CHARACTER    (  \\  '  \\  \\     \\  '  )  \\ n \"     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer 2  )  ;", "final   RegExpLexer   lexer 3     =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . ALLOW _ EMPTY _ CHARACTER _ CLASS )  )  ;", "doTest (  \"  [  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"     +     \" CHARACTER    (  '  ]  '  )  \"  )  )  ,    lexer 3  )  ;", "doTest (  \"  [  [  ]  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" CHARACTER    (  \\  '  [  \\  '  )  \\ n \"     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  ]  '  )  \"  )  )  ,    lexer 3  )  ;", "doTest (  \"  [  \\  \\  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  \" ESC _ CHARACTER    (  \\  '  \\  \\  ]  \\  '  )  \\ n \"     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer 3  )  ;", "doTest (  \"  [     \\  \\  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '     \\  '  )  \\ n \"     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer 3  )  ;", "}", "METHOD_END"], "methodName": ["testNestedCharacterClasses2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  [  [  \\  \\  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '  [  \\  '  )  \\ n \"     +     \" ESC _ CHARACTER    (  \\  '  \\  \\  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testNoNestedCharacterClasses1"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  [ a - z &  &  [  ^ aeuoi ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" MINUS    (  \\  '  -  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' z \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  &  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  &  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ^  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' e \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' u \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' o \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' i \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  \\  '  ]  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testNoNestedCharacterClasses2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  \"  \\  \\  3  9  [  \\  \\  3  9  ]  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  3  \\  '  )  \\ n \"     +     (  (  (  (  \" CHARACTER    (  \\  '  9  \\  '  )  \\ n \"     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  3  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  9  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalFollowedByDigit"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  [  \\  \\  1  \\  \\  1  0  \\  \\  1  0  0  ]  \"  ,     (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ nGROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  0  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  0  0  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalInsideCharClass"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  \"  \\  \\  1  (  )  \\  \\  1  \\  \\  1  1  [  \\  \\  1  \\  \\  1  1  ]  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  1  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ n \"     +     \" GROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" BACKREF    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalNoLeadingZero1"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO ,    RegExpCapability . MIN _ OCTAL _  2  _ DIGITS )  )  ;", "doTest (  \"  \\  \\  1  (  )  \\  \\  1  \\  \\  1  1  [  \\  \\  1  \\  \\  1  1  ]  \"  ,     (  \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  1  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ n \"     +     \" GROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" BACKREF    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalNoLeadingZero2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO ,    RegExpCapability . MIN _ OCTAL _  3  _ DIGITS )  )  ;", "doTest (  \"  \\  \\  1  (  )  \\  \\  1  \\  \\  1  1  \\  \\  1  1  1  [  \\  \\  1  \\  \\  1  1  \\  \\  1  1  1  ]  \"  ,     (  \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  1  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ n \"     +     \" GROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" BACKREF    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  1  1  1  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalNoLeadingZero3"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\  0  \\  \\  1  2  3  [  \\  \\  1  2  3  ]  \"  ,     (  \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  0  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  \" BACKREF    (  \\  '  \\  \\  1  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  3  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" INVALID _ CHARACTER _ ESCAPE _ TOKEN    (  \\  '  \\  \\  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  3  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalWithLeadingZero"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\  0  8  \\  \\  0  1  \\  \\  0  0  \\  \\  0  1  2  \\  \\  0  1  2  3  \\  \\  0  3  7  7  \\  \\  0  4  0  0  \"  ,     (  \" BAD _ OCT _ VALUE    (  \\  '  \\  \\  0  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  \" CHARACTER    (  \\  '  8  \\  '  )  \\ n \"     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  1  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  0  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  1  2  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  1  2  3  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  3  7  7  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  4  0  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  0  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testOctalWithLeadingZero2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . POSIX _ BRACKET _ EXPRESSIONS )  )  ;", "doTest (  \"  [  [  : xdigit :  ]  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  \" BRACKET _ EXPRESSION _ BEGIN    (  \\  '  [  :  \\  '  )  \\ n \"     +     \" NAME    (  \\  ' xdigit \\  '  )  \\ n \"  )     +     \" BRACKET _ EXPRESSION _ END    (  \\  '  :  ]  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testPosixBracketExpression"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\ Q \\ r \\ n \\  \\ E \"  ,     (  \" QUOTE _ BEGIN    (  \\  '  \\  \\ Q \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '  \\ n \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  \\  \\ n \\  '  )  \\ n \"  )     +     \" QUOTE _ END    (  \\  '  \\  \\ E \\  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testQE"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . DANGLING _ METACHARACTERS ,    RegExpCapability . OMIT _ NUMBERS _ IN _ QUANTIFIERS )  )  ;", "doTest (  \" a {  ,  1  0  }  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  (  \" LBRACE    (  \\  '  {  \\  '  )  \\ n \"     +     \" COMMA    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" NUMBER    (  \\  '  1  0  \\  '  )  \\ n \"  )     +     \" RBRACE    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" a {  1  0  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  (  \" LBRACE    (  \\  '  {  \\  '  )  \\ n \"     +     \" NUMBER    (  \\  '  1  0  \\  '  )  \\ n \"  )     +     \" COMMA    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" RBRACE    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" a {  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     \" CHARACTER    (  '  {  '  )  \"  )  ,    lexer )  ;", "doTest (  \" a {  1  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  '  1  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" a {  1  ,  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  ,  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" a {  ,  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [  {  1  ,  2  }  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  }  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" x \\  \\  {  9  }  \"  ,     (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     (  (  \" ESC _ CHARACTER    (  \\  '  \\  \\  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  9  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \"  [ x \\  \\  {  9  }  ]  \"  ,     (  \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"     +     (  (  (  (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  {  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  9  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  }  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" x \\  \\  {  }  \"  ,     (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     (  \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" x {  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" x \\  \\  {  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     (  (  \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testQuantifier"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . DANGLING _ METACHARACTERS )  )  ;", "doTest (  \" a {  ,  1  0  }  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  0  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testQuantifier2"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . DANGLING _ METACHARACTERS ,    RegExpCapability . OMIT _ NUMBERS _ IN _ QUANTIFIERS ,    RegExpCapability . OMIT _ BOTH _ NUMBERS _ IN _ QUANTIFIERS )  )  ;", "doTest (  \" a {  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' a \\  '  )  \\ n \"     +     (  (  \" LBRACE    (  \\  '  {  \\  '  )  \\ n \"     +     \" COMMA    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" RBRACE    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "doTest (  \" x \\  \\  {  ,  }  \"  ,     (  \" CHARACTER    (  \\  ' x \\  '  )  \\ n \"     +     (  (  \" ESC _ CHARACTER    (  \\  '  \\  \\  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  ,  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testQuantifier3"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  (  \"  \\  \\  1  0  0  \"     +     (  (  (  (  (  (  (  (  (  \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \"  )     +     \"  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  (  )  \\  \\  1  0  0  [  \\  \\  1  0  0  ]  \"  )  )  ,    null ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testThreeDigitOctalNoLeadingZero"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . EXTENDED _ UNICODE _ CHARACTER )  )  ;", "doTest (  \"  \\  \\ u {  1 F 6  8  0  }  \\  \\ x {  1 F 6  8  0  }  \\  \\ u {  }  \\  \\ u {  1  }  \\  \\ u { FF }  \\  \\ x { fff }  \\  \\ u 1  2  3  4  \\  \\ u 1  2  3  \\  \\ u \"  ,     (  \" UNICODE _ CHAR    (  \\  '  \\  \\ u {  1 F 6  8  0  }  \\  '  )  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  \" HEX _ CHAR    (  \\  '  \\  \\ x {  1 F 6  8  0  }  \\  '  )  \\ n \"     +     \" INVALID _ UNICODE _ ESCAPE _ TOKEN    (  \\  '  \\  \\ u {  }  \\  '  )  \\ n \"  )     +     \" UNICODE _ CHAR    (  \\  '  \\  \\ u {  1  }  \\  '  )  \\ n \"  )     +     \" UNICODE _ CHAR    (  \\  '  \\  \\ u { FF }  \\  '  )  \\ n \"  )     +     \" HEX _ CHAR    (  \\  '  \\  \\ x { fff }  \\  '  )  \\ n \"  )     +     \" UNICODE _ CHAR    (  \\  '  \\  \\ u 1  2  3  4  \\  '  )  \\ n \"  )     +     \" INVALID _ UNICODE _ ESCAPE _ TOKEN    (  \\  '  \\  \\ u \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  2  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  3  \\  '  )  \\ n \"  )     +     \" INVALID _ UNICODE _ ESCAPE _ TOKEN    (  \\  '  \\  \\ u \\  '  )  \"  )  )  ,    lexer )  ;", "final   RegExpLexer   lexer 2     =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . DANGLING _ METACHARACTERS )  )  ;", "doTest (  \"  \\  \\ u {  1 F 6  8  0  }  \"  ,     (  \" INVALID _ UNICODE _ ESCAPE _ TOKEN    (  \\  '  \\  \\ u \\  '  )  \\ n \"     +     (  (  (  (  (  (  \" CHARACTER    (  \\  '  {  \\  '  )  \\ n \"     +     \" CHARACTER    (  \\  '  1  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  ' F \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  6  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  8  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  \\  '  0  \\  '  )  \\ n \"  )     +     \" CHARACTER    (  '  }  '  )  \"  )  )  ,    lexer 2  )  ;", "}", "METHOD_END"], "methodName": ["testUnicode"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . noneOf ( RegExpCapability . class )  )  ;", "doTest (  \"  \\  \\  %  \\  \\  \\ u 0  0 e 4  \"  ,     (  \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  %  \\  '  )  \\ n \"     +     \" REDUNDANT _ ESCAPE    (  \\  '  \\  \\  \\ u 0  0 e 4  \\  '  )  \"  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testValidEscapes"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpLexer   lexer    =    new   RegExpLexer ( EnumSet . of ( RegExpCapability . OCTAL _ NO _ LEADING _ ZERO )  )  ;", "doTest (  \"  \\  \\  0  (  )  \\  \\  0  [  \\  \\  0  ]  \"  ,     (  \" OCT _ CHAR    (  \\  '  \\  \\  0  \\  '  )  \\ n \"     +     (  (  (  (  (  \" GROUP _ BEGIN    (  \\  '  (  \\  '  )  \\ n \"     +     \" GROUP _ END    (  \\  '  )  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  \\  '  )  \\ n \"  )     +     \" CLASS _ BEGIN    (  \\  '  [  \\  '  )  \\ n \"  )     +     \" OCT _ CHAR    (  \\  '  \\  \\  0  \\  '  )  \\ n \"  )     +     \" CLASS _ END    (  '  ]  '  )  \"  )  )  ,    lexer )  ;", "}", "METHOD_END"], "methodName": ["testZeroOctalNoLeadingZero"], "fileName": "org.intellij.lang.regexp.RegExpLexerTest"}, {"methodBody": ["METHOD_START", "{", "if    (  ( builder . getTokenType (  )  )     =  =    token )     {", "builder . advanceLexer (  )  ;", "return   true ;", "} else    {", "builder . error ( message )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["checkMatches"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "assert    ( text . length (  )  )     =  =     1  ;", "final   char   c    =    text . charAt (  0  )  ;", "return   AsciiUtil . isLetter ( c )  ;", "}", "METHOD_END"], "methodName": ["isLetter"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    parseGroup ( builder )  ;", "if    ( marker    =  =    null )     {", "return   false ;", "}", "final   PsiBuilder . Marker   marker 2     =    marker . precede (  )  ;", "if    ( parseQuantifier ( builder )  )     {", "marker 2  . done ( ElementTypes . CLOSURE )  ;", "} else    {", "marker 2  . drop (  )  ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseAtom"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . CARET )  )     {", "builder . advanceLexer (  )  ;", "}", ". checkMatches ( builder ,    RegExpTT . NAME ,     \" POSIX   character   class   name   expected \"  )  ;", ". checkMatches ( builder ,    RegExpTT . BRACKET _ EXPRESSION _ END ,     \" Unclosed   POSIX   bracket   expression \"  )  ;", "marker . done ( RegExpElementTypes . POSIX _ BRACKET _ EXPRESSION )  ;", "}", "METHOD_END"], "methodName": ["parseBracketExpression"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "if    (  !  ( parseAtom ( builder )  )  )     {", "final   IElementType   token    =    builder . getTokenType (  )  ;", "if    (  (  ( token    =  =     ( TT . GROUP _ END )  )     |  |     ( token    =  =     ( TT . UNION )  )  )     |  |     ( token    =  =    null )  )     {", "marker . done ( ElementTypes . BRANCH )  ;", "return   true ;", "}", "marker . drop (  )  ;", "return   false ;", "}", "while    ( parseAtom ( builder )  )     {", "}", "marker . done ( ElementTypes . BRANCH )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["parseBranch"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NAMED _ CHARACTER )  )     {", "builder . advanceLexer (  )  ;", ". checkMatches ( builder ,    RegExpTT . LBRACE ,     \"  '  {  '    expected \"  )  ;", ". checkMatches ( builder ,    RegExpTT . NAME ,     \" Unicode   character   name   expected \"  )  ;", ". checkMatches ( builder ,    RegExpTT . RBRACE ,     \"  '  }  '    expected \"  )  ;", "marker . done ( RegExpElementTypes . NAMED _ CHARACTER )  ;", "} else    {", "builder . advanceLexer (  )  ;", "marker . done ( RegExpElementTypes . CHAR )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCharacter"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   rangeMarker    =    builder . mark (  )  ;", ". parseCharacter ( builder )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . MINUS )  )     {", "final   PsiBuilder . Marker   minusMarker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "final   IElementType   t    =    builder . getTokenType (  )  ;", "if    (  ( RegExpTT . CHARACTERS . contains ( t )  )     |  |     ( t    =  =     ( RegExpTT . NAMED _ CHARACTER )  )  )     {", "minusMarker . drop (  )  ;", ". parseCharacter ( builder )  ;", "rangeMarker . done ( RegExpElementTypes . CHAR _ RANGE )  ;", "} else    {", "if    ( t    =  =     ( RegExpTT . CLASS _ END )  )     {", "rangeMarker . drop (  )  ;", "minusMarker . done ( RegExpElementTypes . CHAR )  ;", "} else", "if    ( t    =  =     ( RegExpTT . CLASS _ BEGIN )  )     {", "rangeMarker . drop (  )  ;", "minusMarker . done ( RegExpElementTypes . CHAR )  ;", "parseClassdef ( builder )  ;", "} else    {", "minusMarker . drop (  )  ;", "builder . error (  \" Illegal   character   range \"  )  ;", "rangeMarker . done ( RegExpElementTypes . CHAR _ RANGE )  ;", "}", "}", "} else    {", "rangeMarker . drop (  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseCharacterRange"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . CARET )  )     {", "builder . advanceLexer (  )  ;", "}", "parseClassIntersection ( builder )  ;", ". checkMatches ( builder ,    RegExpTT . CLASS _ END ,     \" Unclosed   character   class \"  )  ;", "marker . done ( RegExpElementTypes . CLASS )  ;", "return   marker ;", "}", "METHOD_END"], "methodName": ["parseClass"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "boolean   left    =    parseClassdef ( builder )  ;", "if    (  ( TT . ANDAND )     !  =     ( builder . getTokenType (  )  )  )     {", "marker . drop (  )  ;", "return ;", "}", "while    (  ( TT . ANDAND )     =  =     ( builder . getTokenType (  )  )  )     {", "builder . advanceLexer (  )  ;", "final   boolean   right    =    parseClassdef ( builder )  ;", "if    (  (  ! left )     &  &     (  ! right )  )     {", "builder . error (  \" character   class   expected \"  )  ;", "}", "left    =    right ;", "}", "marker . done ( ElementTypes . INTERSECTION )  ;", "}", "METHOD_END"], "methodName": ["parseClassIntersection"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "int   count    =     0  ;", "while    ( true )     {", "final   IElementType   token    =    builder . getTokenType (  )  ;", "if    ( token    =  =     ( RegExpTT . CLASS _ BEGIN )  )     {", "parseClass ( builder )  ;", "} else", "if    ( token    =  =     ( RegExpTT . BRACKET _ EXPRESSION _ BEGIN )  )     {", ". parseBracketExpression ( builder )  ;", "} else", "if    ( token    =  =     ( RegExpTT . MYSQL _ CHAR _ BEGIN )  )     {", ". parseMysqlCharExpression ( builder )  ;", "} else", "if    ( token    =  =     ( RegExpTT . MYSQL _ CHAR _ EQ _ BEGIN )  )     {", ". parseMysqlCharEqExpression ( builder )  ;", "} else", "if    (  ( RegExpTT . CHARACTERS . contains ( token )  )     |  |     ( token    =  =     ( RegExpTT . NAMED _ CHARACTER )  )  )     {", "parseCharacterRange ( builder )  ;", "} else", "if    ( token    =  =     ( RegExpTT . CHAR _ CLASS )  )     {", "final   PsiBuilder . Marker   m    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "m . done ( RegExpElementTypes . SIMPLE _ CLASS )  ;", "} else", "if    ( token    =  =     ( RegExpTT . PROPERTY )  )     {", "parseProperty ( builder )  ;", "} else    {", "return   count    >     0  ;", "}", "count +  +  ;", "}", "}", "METHOD_END"], "methodName": ["parseClassdef"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   type    =    builder . getTokenType (  )  ;", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "if    ( RegExpTT . GROUPS . contains ( type )  )     {", "builder . advanceLexer (  )  ;", "parseGroupEnd ( builder )  ;", "marker . done ( RegExpElementTypes . GROUP )  ;", "} else", "if    ( type    =  =     ( RegExpTT . SET _ OPTIONS )  )     {", "builder . advanceLexer (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . OPTIONS _ ON )  )     {", "final   PsiBuilder . Marker   o    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "o . done ( RegExpElementTypes . OPTIONS )  ;", "}", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . OPTIONS _ OFF )  )     {", "final   PsiBuilder . Marker   o    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "o . done ( RegExpElementTypes . OPTIONS )  ;", "}", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . COLON )  )     {", "builder . advanceLexer (  )  ;", "parseGroupEnd ( builder )  ;", "marker . done ( RegExpElementTypes . GROUP )  ;", "} else    {", ". checkMatches ( builder ,    RegExpTT . GROUP _ END ,     \" Unclosed   options   group \"  )  ;", "marker . done ( RegExpElementTypes . SET _ OPTIONS )  ;", "}", "} else", "if    (  ( RegExpTT . CHARACTERS . contains ( type )  )     |  |     ( type    =  =     ( RegExpTT . NAMED _ CHARACTER )  )  )     {", "marker . drop (  )  ;", ". parseCharacter ( builder )  ;", "} else", "if    ( RegExpTT . BOUNDARIES . contains ( type )  )     {", "builder . advanceLexer (  )  ;", "marker . done ( RegExpElementTypes . BOUNDARY )  ;", "} else", "if    ( type    =  =     ( RegExpTT . BACKREF )  )     {", "builder . advanceLexer (  )  ;", "marker . done ( RegExpElementTypes . BACKREF )  ;", "} else", "if    (  (  ( type    =  =     ( RegExpTT . PYTHON _ NAMED _ GROUP )  )     |  |     ( type    =  =     ( RegExpTT . RUBY _ NAMED _ GROUP )  )  )     |  |     ( type    =  =     ( RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP )  )  )     {", "builder . advanceLexer (  )  ;", ". checkMatches ( builder ,    RegExpTT . NAME ,     \" Group   name   expected \"  )  ;", ". checkMatches ( builder ,     ( type    =  =     ( RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP )     ?    RegExpTT . QUOTE    :    RegExpTT . GT )  ,     \" Unclosed   group   name \"  )  ;", "parseGroupEnd ( builder )  ;", "marker . done ( RegExpElementTypes . GROUP )  ;", "} else", "if    ( type    =  =     ( RegExpTT . PYTHON _ NAMED _ GROUP _ REF )  )     {", ". parseNamedGroupRef ( builder ,    marker ,    RegExpTT . GROUP _ END )  ;", "} else", "if    (  ( type    =  =     ( RegExpTT . RUBY _ NAMED _ GROUP _ REF )  )     |  |     ( type    =  =     ( RegExpTT . RUBY _ NAMED _ GROUP _ CALL )  )  )     {", ". parseNamedGroupRef ( builder ,    marker ,    RegExpTT . GT )  ;", "} else", "if    (  ( type    =  =     ( RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP _ REF )  )     |  |     ( type    =  =     ( RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP _ CALL )  )  )     {", ". parseNamedGroupRef ( builder ,    marker ,    RegExpTT . QUOTE )  ;", "} else", "if    ( type    =  =     ( RegExpTT . PYTHON _ COND _ REF )  )     {", "builder . advanceLexer (  )  ;", "if    (  (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NAME )  )     |  |     (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NUMBER )  )  )     {", "builder . advanceLexer (  )  ;", "} else    {", "builder . error (  \" Group   name   or   number   expected \"  )  ;", "}", ". checkMatches ( builder ,    RegExpTT . GROUP _ END ,     \" Unclosed   group   reference \"  )  ;", "if    (  !  ( parseBranch ( builder )  )  )     {", ". patternExpected ( builder )  ;", "} else    {", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . UNION )  )     {", "builder . advanceLexer (  )  ;", "if    (  !  ( parseBranch ( builder )  )  )     {", ". patternExpected ( builder )  ;", "}", "}", ". checkMatches ( builder ,    RegExpTT . GROUP _ END ,     \" Unclosed   group \"  )  ;", "}", "marker . done ( RegExpElementTypes . PY _ COND _ REF )  ;", "} else", "if    ( type    =  =     ( RegExpTT . PROPERTY )  )     {", "marker . drop (  )  ;", "parseProperty ( builder )  ;", "} else", "if    (  ( type    =  =     ( RegExpTT . DOT )  )     |  |     ( type    =  =     ( RegExpTT . CHAR _ CLASS )  )  )     {", "builder . advanceLexer (  )  ;", "marker . done ( RegExpElementTypes . SIMPLE _ CLASS )  ;", "} else", "if    ( type    =  =     ( RegExpTT . CLASS _ BEGIN )  )     {", "marker . drop (  )  ;", "return   parseClass ( builder )  ;", "} else    {", "marker . drop (  )  ;", "return   null ;", "}", "return   marker ;", "}", "METHOD_END"], "methodName": ["parseGroup"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( parsePattern ( builder )  )  )     {", ". patternExpected ( builder )  ;", "} else    {", ". checkMatches ( builder ,    RegExpTT . GROUP _ END ,     \" Unclosed   group \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["parseGroupEnd"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", ". checkMatches ( builder ,    RegExpTT . CHARACTER ,     \" Character   expected \"  )  ;", ". checkMatches ( builder ,    RegExpTT . MYSQL _ CHAR _ EQ _ END ,     \" Unclosed   MySQL   character   equivalence   class \"  )  ;", "marker . done ( RegExpElementTypes . MYSQL _ CHAR _ EQ _ EXPRESSION )  ;", "}", "METHOD_END"], "methodName": ["parseMysqlCharEqExpression"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NAME )  )     {", "builder . advanceLexer (  )  ;", "} else    {", ". checkMatches ( builder ,    RegExpTT . CHARACTER ,     \" Character   or   MySQL   character   name   expected \"  )  ;", "}", ". checkMatches ( builder ,    RegExpTT . MYSQL _ CHAR _ END ,     \" Unclosed   MySQL   character   expression \"  )  ;", "marker . done ( RegExpElementTypes . MYSQL _ CHAR _ EXPRESSION )  ;", "}", "METHOD_END"], "methodName": ["parseMysqlCharExpression"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "builder . advanceLexer (  )  ;", ". checkMatches ( builder ,    RegExpTT . NAME ,     \" Group   name   expected \"  )  ;", ". checkMatches ( builder ,    type ,     \" Unclosed   group   reference \"  )  ;", "marker . done ( RegExpElementTypes . NAMED _ GROUP _ REF )  ;", "}", "METHOD_END"], "methodName": ["parseNamedGroupRef"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "if    (  !  ( parseBranch ( builder )  )  )     {", "marker . drop (  )  ;", "return   false ;", "}", "while    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . UNION )  )     {", "builder . advanceLexer (  )  ;", "if    (  !  ( parseBranch ( builder )  )  )     {", ". patternExpected ( builder )  ;", "break ;", "}", "}", "marker . done ( RegExpElementTypes . PATTERN )  ;", "return   true ;", "}", "METHOD_END"], "methodName": ["parsePattern"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . CATEGORY _ SHORT _ HAND )  )     {", "if    (  !  ( myCapabilities . contains ( RegExpCapability . UNICODE _ CATEGORY _ SHORTHAND )  )  )     {", "builder . error (  \" Category   shorthand   not   allowed   in   this   regular   expression   dialect \"  )  ;", "}", "builder . advanceLexer (  )  ;", "} else    {", "if    (  (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . CHARACTER )  )     &  &     (  . isLetter ( builder . getTokenText (  )  )  )  )     {", "builder . error (  ( myCapabilities . contains ( RegExpCapability . UNICODE _ CATEGORY _ SHORTHAND )     ?     \" Illegal   category   shorthand \"     :     \"  '  {  '    expected \"  )  )  ;", "builder . advanceLexer (  )  ;", "} else", "if    (  . checkMatches ( builder ,    RegExpTT . LBRACE ,     ( myCapabilities . contains ( RegExpCapability . UNICODE _ CATEGORY _ SHORTHAND )     ?     \"  '  {  '    or   category   shorthand   expected \"     :     \"  '  {  '    expected \"  )  )  )     {", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . CARET )  )     {", "if    (  !  ( myCapabilities . contains ( RegExpCapability . CARET _ NEGATED _ PROPERTIES )  )  )     {", "builder . error (  \" Negating   a   property   not   allowed   in   this   regular   expression   dialect \"  )  ;", "}", "builder . advanceLexer (  )  ;", "}", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NAME )  )     {", "builder . advanceLexer (  )  ;", ". checkMatches ( builder ,    RegExpTT . RBRACE ,     \" Unclosed   property \"  )  ;", "} else    {", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . RBRACE )  )     {", "builder . error (  \" Empty   property \"  )  ;", "builder . advanceLexer (  )  ;", "} else    {", "builder . error (  \" Property   name   expected \"  )  ;", "}", "while    (  . PROPERTY _ TOKENS . contains ( builder . getTokenType (  )  )  )     {", "builder . advanceLexer (  )  ;", "}", "}", "}", "}", "marker . done ( RegExpElementTypes . PROPERTY )  ;", "}", "METHOD_END"], "methodName": ["parseProperty"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   PsiBuilder . Marker   marker    =    builder . mark (  )  ;", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . LBRACE )  )     {", "builder . advanceLexer (  )  ;", "final   boolean   minOmitted    =     (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . COMMA )  )     &  &     ( myCapabilities . contains ( RegExpCapability . OMIT _ NUMBERS _ IN _ QUANTIFIERS )  )  ;", "if    ( minOmitted )     {", "builder . advanceLexer (  )  ;", "} else    {", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NUMBER )  )     {", "final   PsiBuilder . Marker   numberMark    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "numberMark . done ( RegExpElementTypes . NUMBER )  ;", "} else    {", "builder . error (  \" Number   expected \"  )  ;", "}", "}", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . RBRACE )  )     {", "builder . advanceLexer (  )  ;", ". parseQuantifierType ( builder )  ;", "marker . done ( RegExpElementTypes . QUANTIFIER )  ;", "} else    {", "if    (  ! minOmitted )     {", ". checkMatches ( builder ,    RegExpTT . COMMA ,     \"  '  ,  '    expected \"  )  ;", "}", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . RBRACE )  )     {", "builder . advanceLexer (  )  ;", ". parseQuantifierType ( builder )  ;", "marker . done ( RegExpElementTypes . QUANTIFIER )  ;", "} else", "if    (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . NUMBER )  )     {", "final   PsiBuilder . Marker   numberMark    =    builder . mark (  )  ;", "builder . advanceLexer (  )  ;", "numberMark . done ( RegExpElementTypes . NUMBER )  ;", ". checkMatches ( builder ,    RegExpTT . RBRACE ,     \"  '  }  '    expected \"  )  ;", ". parseQuantifierType ( builder )  ;", "marker . done ( RegExpElementTypes . QUANTIFIER )  ;", "} else    {", "builder . error (  \"  '  }  '    or   number   expected \"  )  ;", "marker . done ( RegExpElementTypes . QUANTIFIER )  ;", "return   true ;", "}", "}", "} else", "if    ( RegExpTT . QUANTIFIERS . contains ( builder . getTokenType (  )  )  )     {", "builder . advanceLexer (  )  ;", ". parseQuantifierType ( builder )  ;", "marker . done ( RegExpElementTypes . QUANTIFIER )  ;", "} else    {", "marker . drop (  )  ;", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["parseQuantifier"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . PLUS )  )     |  |     (  ( builder . getTokenType (  )  )     =  =     ( RegExpTT . QUEST )  )  )     {", "builder . advanceLexer (  )  ;", "} else    {", "if    ( RegExpTT . QUANTIFIERS . contains ( builder . getTokenType (  )  )  )     {", "builder . error (  \" Dangling   metacharacter \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["parseQuantifierType"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "final   IElementType   token    =    builder . getTokenType (  )  ;", "if    ( token    =  =     ( TT . GROUP _ END )  )     {", "builder . error (  \" Unmatched   closing    '  )  '  \"  )  ;", "} else", "if    (  (  ( TT . QUANTIFIERS . contains ( token )  )     |  |     ( token    =  =     ( TT . RBRACE )  )  )     |  |     ( token    =  =     ( TT . CLASS _ END )  )  )     {", "builder . error (  \" Dangling   metacharacter \"  )  ;", "} else    {", "builder . error (  \" Pattern   expected \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["patternExpected"], "fileName": "org.intellij.lang.regexp.RegExpParser"}, {"methodBody": ["METHOD_START", "{", "return   new   RegExpLexer ( capabilities )  ;", "}", "METHOD_END"], "methodName": ["createLexer"], "fileName": "org.intellij.lang.regexp.RegExpParserDefinition"}, {"methodBody": ["METHOD_START", "{", "return   new   RegExpParser ( capabilities )  ;", "}", "METHOD_END"], "methodName": ["createParser"], "fileName": "org.intellij.lang.regexp.RegExpParserDefinition"}, {"methodBody": ["METHOD_START", "{", "return   RegExpParserDefinition . CAPABILITIES ;", "}", "METHOD_END"], "methodName": ["getDefaultCapabilities"], "fileName": "org.intellij.lang.regexp.RegExpParserDefinition"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^ a ( bc +  | b [ eh ]  ) g |  . h $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  $  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^ abc \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^ abc $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  $ b \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  ( ab | cd ) e \"  )  ;", "}", "METHOD_END"], "methodName": ["testAnchors9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( ac *  ) c * d [ ac ]  *  \\  \\  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  .  )  =  \\  \\  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  )  =  \\  \\  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  +  )  =  \\  \\  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a )  ( b )  ( c )  ( d )  ( e )  ( f )  ( g )  ( h )  ( i )  ( j )  \\  \\  1  0  5  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  .  )  \\  \\  1  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  +  )  =  \\  \\  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  +  )  =  \\  \\  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  +  =  \\  \\  1  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBackrefs9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  {  ]  [  \\  \\ w \\  \\  .  ]  *  [  }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ h    \\  \\ H    \\  \\ v    \\  \\ V \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a - z 0  -  9  !  \\  \\  #  $  %  &  \\  '  *  +  /  =  ?  ^  _  `  {  |  }  ~  -  ]  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\  {  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  <  =  \\  \\ s )  -  {  3  ,  }  (  ?  >  \\  \\ s )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? x ) a \\  \\    b \\  \\    c \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\    b \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ^  |  \\  \\  .  )  \\  \\  *  (  ?  =  (  \\  \\  .  |  $  )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testBug9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "RegExpCapabilitiesProvider   provider    =     (    host ,    def )     -  >    EnumSet . of ( RegExpCapability . POSIX _ BRACKET _ EXPRESSIONS )  ;", "try    {", "RegExpCapabilitiesProvider . EP . addExplicitExtension ( RegExpLanguage . INSTANCE ,    provider )  ;", "PsiComment   context    =    SyntaxTraverser . psiTraverser ( createPsiFile (  \" c \"  ,     \"  (  ?  # xxx )  \"  )  )  . filter ( PsiComment . class )  . first (  )  ;", "myFile    =    createPsiFile (  \" a \"  ,     \"  [  [  : blank :  ]  ]  \"  )  ;", "INJECTED _ IN _ ELEMENT . set ( myFile ,    new   compsi . IdentitySmartPointer ( context )  )  ;", "ensureParsed ( myFile )  ;", "checkResult (  (  ( myFilePrefix )     +     ( getTestName (  )  )  )  ,    myFile )  ;", "}    finally    {", "RegExpCapabilitiesProvider . EP . removeExplicitExtension ( RegExpLanguage . INSTANCE ,    provider )  ;", "}", "}", "METHOD_END"], "methodName": ["testCapabilitiesProvider"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ pL \"  )  ;", "}", "METHOD_END"], "methodName": ["testCategoryShorthand1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p {  ^ L }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharClasses69"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  &  &  &  & a ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharClasses70"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  \\  \\ Qz \\  \\ E ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharClasses71"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [  \\  \\  ^  ]  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharClasses72"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ bc ] d \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b &  &  -  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b &  &  - b ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  &  &  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  &  &  [  ^  \\  \\ d ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a &  &  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b &  & c &  & d ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b &  & c &  & d - e &  & f ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a &  &  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ a [ b ]  [ c ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  [  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b - d ] e \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  [ b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a [  ^ b ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ a [ b [ c ]  ]  [ d ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses22"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  \\  \\ t -  -  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses23"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  \\  \\ t -  -  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses24"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  \\  \\ t -  -  -  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses25"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  -  ]  ? c \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses26"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses27"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses28"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  [  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses29"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b - d ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses30"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  ^ bc ] d \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses31"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  ^ bc ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses32"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  ] b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses33"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  ^  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses34"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ abhgefdc ] ij \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses35"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a - zA - Z _  ]  [ a - zA - Z 0  -  9  _  ]  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses36"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ a - c ]  +  ?  ) c \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses37"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  *  ?  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses38"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  *  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses39"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b - a ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ ab ]  ?  ?  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses40"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( c [ ab ]  ?  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses41"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( c [ ab ]  ?  ?  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses42"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( c [ ab ]  *  ?  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses43"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ bcd ]  + dcdcde \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses44"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ k ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses45"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ bcd ]  * dcdcde \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses46"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  ^ ab ]  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses47"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  .  ] b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses48"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  +  *  ?  ] b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses49"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  - b ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [  \\  \\ p { IsDigit }  \\  \\ p { IsAlpha }  ] b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses50"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ p { L }  &  &  [  ^  \\  \\ p { Lu }  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses51"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ pL \\  \\ pM \\  \\ pZ \\  \\ pS \\  \\ pN \\  \\ pP \\  \\ pC \\  \\ PL \\  \\ PM \\  \\ PZ \\  \\ PS \\  \\ PN \\  \\ PP \\  \\ PC \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses52"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ pA \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses53"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ pl \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses54"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ p \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses55"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ p {  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses56"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ p }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses57"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ p {  1  2  3  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses58"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ p { nothing }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses59"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b -  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ p {  *  } b \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses60"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ w -  \\  \\ w ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses61"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  \\  \\ w ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses62"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? x ) abc    # foo    \\  \\ q   bar \\ n #    foo \\ n (  ?  - xi ) xyz (  ? i : ABC )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses63"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ ud 8  0  0  \\  \\ udc 0  0  -  \\  \\ udbff \\  \\ udfff ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses64"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ R \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses65"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ X \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses66"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  -  [  \\  \\  *  \\  \\  -  \\  \\  [  \\  \\  ]  \\  \\  \\  \\  \\  \\  +  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses67"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ b ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses68"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a -  [ b ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b &  &  [ cd ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a [ b -  &  &  [ cd ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharclasses9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" z (  \\  \\ w \\  \\ s +  (  ?  :  \\  \\ w \\  \\ s +  \\  \\ w )  +  ) z \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  ?  :  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  ?  :  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  :  (  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  (  ?  :  (  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  (  ?  :  (  ?  :  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  \\  \\  /  \\  \\  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  ?  :  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testComplex7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ q \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ x 4 a \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ x {  0  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ x {  2  0  1  1 F }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ x 4 a -  \\  \\ x 4 b ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a - a ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ x 4 a -  \\  \\ x 3 f ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ udbff \\  \\ udfff -  \\  \\ ud 8  0  0  \\  \\ udc 0  0  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ ud 8  0  0  \\  \\ udc 0  0  -  \\  \\ udbff \\  \\ udfff ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ z - a ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a - z ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  #  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ Qabc ?  *  +  .  )  )  ]  ]  [  ]  \\  \\ Eb \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a \\  \\ Qabc ?  *  +  .  )  )  ]  ]  [  ]  \\  \\ Eb )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ Qabc ?  *  +  .  )  )  ]  ]  [  ]  \\  \\ E ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes22"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\ Qabc ?  *  +  .  )  )  ]  ]  [  ]  \\  \\ E )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes23"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ Q \\  \\ j \\  \\ E \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes24"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ c 0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes25"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes26"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  ^  \\  \\  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes27"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a \\  \\  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes28"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  ^ a \\  \\  ]  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes29"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\  ( b \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\  (  * b \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a \\  \\  \\  \\ b \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ u 0  0  4 a \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  0  1  2  3  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ) ef \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a |  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( ab | cd ) e \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  .  *  ) c (  .  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  (  (  .  *  )  ,     (  .  *  )  \\  \\  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ( bc ) d \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ abc ]  )  * d \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  (  (  (  (  (  (  (  ( a )  )  )  )  )  )  )  )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  [ abc ]  )  * bcd \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a | b ) c * d \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a (  [ bc ]  *  ) c *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ( a )  ( b ) c )  ( d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( ab | a ) b * c \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( ab | ab *  ) bc \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups22"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a | b | c | d | e ) f \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups23"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a (  [ bc ]  *  )  ( c * d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups24"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a (  [ bc ]  +  )  ( c * d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups25"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a (  [ bc ]  *  )  ( c + d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups26"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a +  | b )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups27"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a +  | b )  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups28"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a +  | b )  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups29"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ^  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups30"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  )  (  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups31"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? i :  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups32"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  < asdf >  [ a - c ]  )  \\  \\  1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups33"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  < asdf >  [ a - c ]  )  \\  \\ k < asdf >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups34"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ k < adsf >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups35"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? P < name >  {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups36"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? P = name )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups37"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ g \\  ' name \\  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups38"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  ( name ) yes - pattern | no - pattern )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups39"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  |  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  ( name ) yes - pattern |  {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups40"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  > atomic )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups41"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  : non - capturing )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups42"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  ( name ) yes - pattern | no _ pattern | maybe - pattern )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups43"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  *  ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ( a )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a ) b ( c )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a *  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a *  )  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testGroups9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ Qabc \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ Q \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ E \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a |  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc [  \\  \\  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ x \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ x 1  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ x {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ x {  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ x {  0  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ u \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \\  \\ u 2  2  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIncomplete9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a * b \\  \\ s + c \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p { unknown }  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  :  ^ xdigit :  ]  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p { InArabic   Extended - A }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ N { Mahjong   Tile   Winter }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ N { Mahjong   Tile   Winter }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  \\  \\ N { LATIN   SMALL   LETTER   A }  -  \\  \\ N { LATIN   SMALL   LETTER   Z }  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ d +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  \\  \\ p { javaJavaIdentifierStart }  +  \\  \\ p { javaJavaIdentifierPart }  +  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p { IsDigit }  \\  \\ p { IsAlpha }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p { InLATIN _  1  _ SUPPLEMENT }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [ a - e ]  ? d \\  \\  \\  \\ e \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  \\  \\ w +  )  /  )  *  (  \\  \\ w +  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ p { Digit }  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  : xdigit :  ]  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNamedchars9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? iZm ) abc \"  )  ;", "}", "METHOD_END"], "methodName": ["testOptions1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? idmsuxU ) nice \"  )  ;", "}", "METHOD_END"], "methodName": ["testOptions2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ? idm - suxU ) one (  ? suxU - idm ) two \"  )  ;", "}", "METHOD_END"], "methodName": ["testOptions3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  1  2  3     |     4  5  6  \"  )  ;", "}", "METHOD_END"], "methodName": ["testParse1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  1  *  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testParse2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  [ hH ]  [ tT ]  {  2  }  [ pP ]  |  [ fF ]  [ tT ]  [ pP ]  )  :  /  /  )  ?  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  (  \\  \\  .  [ a - zA - Z 0  -  9  \\  \\  -  ]  +  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testParse3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  2  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  ,  2  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  2  ,  1  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  0  ,  1  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  ,  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  0  ,  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  3  ,  3  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ?  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a +  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ?  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a +  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuantifiers9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" x : found =  \\  \"  ( true | false )  \\  \"  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  .  *  ?  (  <  ( error | warning | info )  (  ?  :    descr =  \\  \"  (  (  ?  :  [  ^  \\  \"  \\  \\  \\  \\  ]  |  \\  \\  \\  \\  \\  \"  )  *  )  \\  \"  )  ?  (  ?  :    type =  \\  \"  (  [  0  -  9 A - Z _  ]  +  )  \\  \"  )  ?  (  ?  :    foreground =  \\  \"  (  [  0  -  9 xa - f ]  +  )  \\  \"  )  ?  (  ?  :    background =  \\  \"  (  [  0  -  9 xa - f ]  +  )  \\  \"  )  ?  (  ?  :    effectcolor =  \\  \"  (  [  0  -  9 xa - f ]  +  )  \\  \"  )  ?  (  ?  :    effecttype =  \\  \"  (  [ A - Z ]  +  )  \\  \"  )  ?  (  ?  :    fonttype =  \\  \"  (  [  0  -  9  ]  +  )  \\  \"  )  ?  (  /  )  ?  >  )  (  .  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  :  \\  \\ s )  |  (  ?  :  /  \\  \\  *  .  *  \\  \\  *  /  )  |  (  ?  :  /  /  [  ^  \\  \\ n ]  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  ?  :  \\  \\ p { Alpha }  \\  \\  :  )  ?  [  0  -  9    a - z _ A - Z \\  \\  -  \\  \\  \\  \\  .  /  ]  +  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  [  \\  \\ w \\  \\  +  \\  \\  .  \\  \\  -  ]  {  2  ,  }  :  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  #  (  .  *  )  $  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ^  (  (  [  ^  :  ]  +  )  :  /  /  )  ?  (  [  ^  :  /  ]  +  )  (  :  (  [  0  -  9  ]  +  )  )  ?  (  /  .  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  (  [  ^  :  ]  +  )  :  /  /  )  ?  (  [  ^  :  /  ]  +  )  (  :  (  [  0  -  9  ]  +  )  )  ?  (  /  .  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" usd    [  +  -  ]  ?  [  0  -  9  ]  +  .  [  0  -  9  ]  [  0  -  9  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ b (  \\  \\ w +  )  (  \\  \\ s +  \\  \\  1  )  +  \\  \\ b \"  )  ;", "}", "METHOD_END"], "methodName": ["testRealLife9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRegressions1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  [  ^  ^  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRegressions2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ) b \"  )  ;", "}", "METHOD_END"], "methodName": ["testRegressions3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\ s *  @ return (  ?  : s )  ?  \\  \\ s *  (  ?  :  (  ?  :  \\  \\  {  |  :  )  ?  \\  \\ s *  (  ?  (  [  ^  \\  \\ s \\  \\  }  ]  +  )  \\  \\ s *  \\  \\  }  ?  \\  \\ s *  )  ?  (  .  *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRegressions4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  |  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab ? bc \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab ? c \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a . c \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a .  * c \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  * a \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  ,  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  |  \\  \\  $  .  *  )  \\  \\  . class \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  ,  2  }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a {  1  , foo }  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  \\  \\  ;  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple22"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" multiple   words   of   text \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab | cd \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab * c \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab * bc \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab + bc \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests1"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  ( b * c *  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests10"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a ? b + c *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests11"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" i   am   a   green    ( giant | man | martian )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests12"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( wee | week )  ( knights | knight )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests13"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a .  * b )  ( a .  * b )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests14"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  \\  \\ s *  \\  \\ w +  )  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests15"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  : a )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests16"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  :  \\  \\ w )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests17"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  (  ?  :  \\  \\ w \\  \\ s \\  \\ w )  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests18"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( a \\  \\ w )  (  ?  :  ,  ( a \\  \\ w )  )  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests19"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( abc \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests2"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc .  *  ? x + yz \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests20"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abc .  +  ? x + yz \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests21"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a .  +  ?  ( c | d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests22"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a .  +  ( c | d )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests23"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a +  ? b +  ? c +  ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests24"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a + b + c \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests3"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a *  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests4"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a +  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests5"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" ab *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests6"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" abcd * efg \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests7"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \" a | b | c | d | e \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests8"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "doCodeTest (  \"  ( bc + d $  | ef * g .  | h ? i ( j | k )  )  \"  )  ;", "}", "METHOD_END"], "methodName": ["testTests9"], "fileName": "org.intellij.lang.regexp.RegExpParsingTest"}, {"methodBody": ["METHOD_START", "{", "consumer . consume ( RegExpSupportLoader . FILE _ TYPE ,    RegExpSupportLoader . FILE _ TYPE . getDefaultExtension (  )  )  ;", "}", "METHOD_END"], "methodName": ["createFileTypes"], "fileName": "org.intellij.lang.regexp.RegExpSupportLoader"}, {"methodBody": ["METHOD_START", "{", "return   new   RegExpHighlighter ( null ,    myParserDefinition )  ;", "}", "METHOD_END"], "methodName": ["createHighlighter"], "fileName": "org.intellij.lang.regexp.RegExpSyntaxHighlighterFactory"}, {"methodBody": ["METHOD_START", "{", "assert    ( afters    !  =    null )     &  &     (  ( afters . length )     >     0  )  ;", "myFixture . configureByText (  \" test \"  ,    before )  ;", "final   SelectWordHandler   action    =    new   SelectWordHandler ( null )  ;", "final   DataContext   dataContext    =    DataManager . getInstance (  )  . getDataContext ( myFixture . getEditor (  )  . getComponent (  )  )  ;", "final   Editor   editor    =    myFixture . getEditor (  )  ;", "for    ( String   after    :    afters )     {", "action . execute ( editor ,    editor . getCaretModel (  )  . getCurrentCaret (  )  ,    dataContext )  ;", "myFixture . checkResult ( after )  ;", "}", "}", "METHOD_END"], "methodName": ["doTest"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" graafm \\  \\ x < caret >  6  1 chine \"  ,     \" graafm \\  \\  < selection > x 6  1  <  / selection > chine \"  ,     \" graafm < selection >  \\  \\ x 6  1  <  / selection > chine \"  ,     \"  < selection > graafm \\  \\ x 6  1 chine <  / selection >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelectHexChar"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" graafm \\  \\ N { LATIN   SMALL < caret >    LETTER   A } chine \"  ,     \" graafm \\  \\ N { LATIN    < selection > SMALL <  / selection >    LETTER   A } chine \"  ,     \" graafm \\  \\ N {  < selection > LATIN   SMALL   LETTER   A <  / selection >  } chine \"  ,     \" graafm < selection >  \\  \\ N { LATIN   SMALL   LETTER   A }  <  / selection > chine \"  ,     \"  < selection > graafm \\  \\ N { LATIN   SMALL   LETTER   A } chine <  / selection >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelectNamedCharacter"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" graafm \\  \\  0  1  < caret >  4 chine \"  ,     \" graafm \\  \\  < selection >  0  1  4  <  / selection > chine \"  ,     \" graafm < selection >  \\  \\  0  1  4  <  / selection > chine \"  ,     \"  < selection > graafm \\  \\  0  1  4 chine <  / selection >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelectOctalChar"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" graafm \\  \\ u 0  < caret >  0  6  1 chine \"  ,     \" graafm \\  \\  < selection > u 0  0  6  1  <  / selection > chine \"  ,     \" graafm < selection >  \\  \\ u 0  0  6  1  <  / selection > chine \"  ,     \"  < selection > graafm \\  \\ u 0  0  6  1 chine <  / selection >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelectUnicodeEscape"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "doTest (  \" graafm < caret > achine \"  ,     \"  < selection > graafmachine <  / selection >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSelectWordSkipChar"], "fileName": "org.intellij.lang.regexp.RegExpWordSelectionFilterTest"}, {"methodBody": ["METHOD_START", "{", "if    ( name    =  =    null )     {", "return    -  1  ;", "}", "final   Method   method    =    ReflectionUtil . getMethod ( Character . class ,     \" codePointOf \"  ,    String . class )  ;", "if    ( method    !  =    null )     {", "try    {", "return    (  ( int )     ( method . invoke ( null ,    name )  )  )  ;", "}    catch    ( IllegalArgumentException   e )     {", "return    -  1  ;", "}    catch    ( IllegalAccessException    |    InvocationTargetException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "try    {", "final   Class <  ?  >    aClass    =    Class . forName (  \" CharacterName \"  )  ;", "final   Method   initNamePool    =    ReflectionUtil . getDeclaredMethod ( aClass ,     \" initNamePool \"  )  ;", "if    ( initNamePool    =  =    null )     {", "return    -  1  ;", "}", "byte [  ]    namePool    =     (  ( byte [  ]  )     ( initNamePool . invoke ( null )  )  )  ;", "name    =    name . trim (  )  . toUpperCase ( Locale . ROOT )  ;", "byte [  ]    key    =    name . getBytes ( StandardCharsets . ISO _  8  8  5  9  _  1  )  ;", "final   int [  ]  [  ]    lookup    =    ReflectionUtil . getField ( aClass ,    null ,    int [  ]  [  ]  . class ,     \" lookup \"  )  ;", "if    ( lookup    =  =    null )", "throw   new   RuntimeException (  )  ;", "for    ( int   i    =     0  ;    i    <     ( lookup . length )  ;    i +  +  )     {", "int [  ]    indexes    =    lookup [ i ]  ;", "if    ( indexes    !  =    null )     {", "for    ( int   j    =     0  ;    j    <     ( indexes . length )  ;    j +  +  )     {", "int   index    =    indexes [ j ]  ;", "if    (  (  ( index    &     2  5  5  )     =  =     ( key . length )  )     &  &     (  . matches ( namePool ,     ( index    >  >  >     8  )  ,    key )  )  )     {", "return    ( i    <  <     8  )     |    j ;", "}", "}", "}", "}", "return    . getUnnamedUnicodeCharacterCodePoint ( name )  ;", "}    catch    ( ClassNotFoundException    |    InvocationTargetException    |    IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["getCodePoint"], "fileName": "org.intellij.lang.regexp.UnicodeCharacterNames"}, {"methodBody": ["METHOD_START", "{", "int   index    =    name . lastIndexOf (  '     '  )  ;", "if    ( index    !  =     (  -  1  )  )     {", "try    {", "int   c    =    Integer . parseInt ( name . substring (  ( index    +     1  )  )  ,     1  6  )  ;", "if    (  (  . isValidCodePoint ( c )  )     &  &     ( name . equals (  . getName ( c )  )  )  )", "return   c ;", "}    catch    ( NumberFormatException   ignore )     {", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["getUnnamedUnicodeCharacterCodePoint"], "fileName": "org.intellij.lang.regexp.UnicodeCharacterNames"}, {"methodBody": ["METHOD_START", "{", "try    {", "final   Class <  ?  >    aClass    =    Class . forName (  \" \"  )  ;", "final   Method   initNamePool    =    ReflectionUtil . getDeclaredMethod ( aClass ,     \" initNamePool \"  )  ;", "if    ( initNamePool    !  =    null )     {", "byte [  ]    namePool    =     (  ( byte [  ]  )     ( initNamePool . invoke ( null )  )  )  ;", "final   int [  ]  [  ]    lookup 2 d    =    ReflectionUtil . getStaticFieldValue ( aClass ,    int [  ]  [  ]  . class ,     \" lookup \"  )  ;", "if    ( lookup 2 d    =  =    null )     {", "return ;", "}", "for    ( int [  ]    indexes    :    lookup 2 d )     {", "if    ( indexes    !  =    null )     {", "for    ( int   index    :    indexes )     {", "if    ( index    !  =     0  )     {", "final   String   name    =    new   String ( namePool ,     ( index    >  >  >     8  )  ,     ( index    &     2  5  5  )  ,    AsciiUtil . ASCII _ CHARSET )  ;", "consumer . accept ( name )  ;", "}", "}", "}", "}", "} else    {", "final   Method   instance    =    ReflectionUtil . getDeclaredMethod ( aClass ,     \" getInstance \"  )  ;", "final   Field   field 1     =    ReflectionUtil . getDeclaredField ( aClass ,     \" strPool \"  )  ;", "final   Field   field 2     =    ReflectionUtil . getDeclaredField ( aClass ,     \" lookup \"  )  ;", "if    (  (  ( instance    !  =    null )     &  &     ( field 1     !  =    null )  )     &  &     ( field 2     !  =    null )  )     {", "final   Object   characterName    =    instance . invoke ( null )  ;", "byte [  ]    namePool    =     (  ( byte [  ]  )     ( field 1  . get ( characterName )  )  )  ;", "final   int [  ]    lookup    =     (  ( int [  ]  )     ( field 2  . get ( characterName )  )  )  ;", "for    ( int   index    :    lookup )     {", "if    ( index    !  =     0  )     {", "final   String   name    =    new   String ( namePool ,     ( index    >  >  >     8  )  ,     ( index    &     2  5  5  )  ,    AsciiUtil . ASCII _ CHARSET )  ;", "consumer . accept ( name )  ;", "}", "}", "}", "}", "}    catch    ( ClassNotFoundException    |    InvocationTargetException    |    IllegalAccessException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["iterate"], "fileName": "org.intellij.lang.regexp.UnicodeCharacterNames"}, {"methodBody": ["METHOD_START", "{", "if    (  ( offset    <     0  )     |  |     (  ( offset    +     ( key . length )  )     >     ( bytes . length )  )  )     {", "throw   new   IllegalArgumentException (  )  ;", "}", "for    (    i    =     0  ;    i    <     ( key . length )  ;    i +  +  )     {", "if    (  ( bytes [  ( i    +    offset )  ]  )     !  =     ( key [ i ]  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["matches"], "fileName": "org.intellij.lang.regexp.UnicodeCharacterNames"}, {"methodBody": ["METHOD_START", "{", "return    _ RegExLexer . ZZ _ CMAP _ A [  (  (  (  _ RegExLexer . ZZ _ CMAP _ Y [  (  (  (  _ RegExLexer . ZZ _ CMAP _ Z [  ( ch    >  >     1  0  )  ]  )     <  <     6  )     |     (  ( ch    >  >     4  )     &     6  3  )  )  ]  )     <  <     4  )     |     ( ch    &     1  5  )  )  ]  ;", "}", "METHOD_END"], "methodName": ["ZZ_CMAP"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   zzInput ;", "int   zzAction ;", "int   zzCurrentPosL ;", "int   zzMarkedPosL ;", "int   zzEndReadL    =    zzEndRead ;", "CharSequence   zzBufferL    =    zzBuffer ;", "int [  ]    zzTransL    =     . ZZ _ TRANS ;", "int [  ]    zzRowMapL    =     . ZZ _ ROWMAP ;", "int [  ]    zzAttrL    =     . ZZ _ ATTRIBUTE ;", "while    ( true )     {", "zzMarkedPosL    =    zzMarkedPos ;", "zzAction    =     -  1  ;", "zzCurrentPosL    =    zzCurrentPos    =    zzStartRead    =    zzMarkedPosL ;", "zzState    =     . ZZ _ LEXSTATE [ zzLexicalState ]  ;", "int   zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "}", "zzForAction    :     {", "while    ( true )     {", "if    ( zzCurrentPosL    <    zzEndReadL )     {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "} else", "if    ( zzAtEOF )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzCurrentPos    =    zzCurrentPosL ;", "zzMarkedPos    =    zzMarkedPosL ;", "boolean   eof    =    zzRefill (  )  ;", "zzCurrentPosL    =    zzCurrentPos ;", "zzMarkedPosL    =    zzMarkedPos ;", "zzBufferL    =    zzBuffer ;", "zzEndReadL    =    zzEndRead ;", "if    ( eof )     {", "zzInput    =     . YYEOF ;", "break   zzForAction ;", "} else    {", "zzInput    =    Character . codePointAt ( zzBufferL ,    zzCurrentPosL )  ;", "zzCurrentPosL    +  =    Character . charCount ( zzInput )  ;", "}", "}", "int   zzNext    =    zzTransL [  (  ( zzRowMapL [ zzState ]  )     +     (  . ZZ _ CMAP ( zzInput )  )  )  ]  ;", "if    ( zzNext    =  =     (  -  1  )  )", "break   zzForAction ;", "zzState    =    zzNext ;", "zzAttributes    =    zzAttrL [ zzState ]  ;", "if    (  ( zzAttributes    &     1  )     =  =     1  )     {", "zzAction    =    zzState ;", "zzMarkedPosL    =    zzCurrentPosL ;", "if    (  ( zzAttributes    &     8  )     =  =     8  )", "break   zzForAction ;", "}", "}", "}", "zzMarkedPos    =    zzMarkedPosL ;", "if    (  ( zzInput    =  =     (  . YYEOF )  )     &  &     (  ( zzStartRead )     =  =     ( zzCurrentPos )  )  )     {", "zzAtEOF    =    true ;", "return   null ;", "} else    {", "switch    ( zzAction    <     0     ?    zzAction    :     . ZZ _ ACTION [ zzAction ]  )     {", "case    1     :", "{", "yypopstate (  )  ;", "return   RegExpTT . COMMENT ;", "}", "case    1  1  3     :", "break ;", "case    2     :", "{", "return   RegExpTT . CHARACTER ;", "}", "case    1  1  4     :", "break ;", "case    3     :", "{", "return   RegExpTT . DOT ;", "}", "case    1  1  5     :", "break ;", "case    4     :", "{", "( capturingGroupCount )  +  +  ;", "return   RegExpTT . GROUP _ BEGIN ;", "}", "case    1  1  6     :", "break ;", "case    5     :", "{", "return   RegExpTT . GROUP _ END ;", "}", "case    1  1  7     :", "break ;", "case    6     :", "{", "if    (  ( allowDanglingMetacharacters )     !  =     ( Boolean . TRUE )  )     {", "yypushstate (  . QUANTIFIER )  ;", "return   RegExpTT . LBRACE ;", "}", "return   RegExpTT . CHARACTER ;", "}", "case    1  1  8     :", "break ;", "case    7     :", "{", "return    ( allowDanglingMetacharacters )     !  =     ( Boolean . FALSE )     ?    RegExpTT . CHARACTER    :    RegExpTT . RBRACE ;", "}", "case    1  1  9     :", "break ;", "case    8     :", "{", "yypushstate (  . CLASS 1  )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "case    1  2  0     :", "break ;", "case    9     :", "{", "return    ( allowDanglingMetacharacters )     =  =     ( Boolean . FALSE )     ?    RegExpTT . CLASS _ END    :    RegExpTT . CHARACTER ;", "}", "case    1  2  1     :", "break ;", "case    1  0     :", "{", "return   StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "}", "case    1  2  2     :", "break ;", "case    1  1     :", "{", "return   commentMode    ?    TokenType . WHITE _ SPACE    :    RegExpTT . CHARACTER ;", "}", "case    1  2  3     :", "break ;", "case    1  2     :", "{", "return   RegExpTT . DOLLAR ;", "}", "case    1  2  4     :", "break ;", "case    1  3     :", "{", "return   RegExpTT . QUEST ;", "}", "case    1  2  5     :", "break ;", "case    1  4     :", "{", "return   RegExpTT . STAR ;", "}", "case    1  2  6     :", "break ;", "case    1  5     :", "{", "return   RegExpTT . PLUS ;", "}", "case    1  2  7     :", "break ;", "case    1  6     :", "{", "return   RegExpTT . UNION ;", "}", "case    1  2  8     :", "break ;", "case    1  7     :", "{", "return   RegExpTT . CARET ;", "}", "case    1  2  9     :", "break ;", "case    1  8     :", "{", "return   commentMode    ?    TokenType . WHITE _ SPACE    :    RegExpTT . CTRL _ CHARACTER ;", "}", "case    1  3  0     :", "break ;", "case    1  9     :", "{", "if    ( commentMode )     {", "yypushstate (  . COMMENT )  ;", "return   RegExpTT . COMMENT ;", "} else", "return   RegExpTT . CHARACTER ;", "}", "case    1  3  1     :", "break ;", "case    2  0     :", "{", "yypopstate (  )  ;", "yypushback (  1  )  ;", "}", "case    1  3  2     :", "break ;", "case    2  1     :", "{", "yypopstate (  )  ;", "return   RegExpTT . RBRACE ;", "}", "case    1  3  3     :", "break ;", "case    2  2     :", "{", "return   RegExpTT . NAME ;", "}", "case    1  3  4     :", "break ;", "case    2  3     :", "{", "return   RegExpTT . NUMBER ;", "}", "case    1  3  5     :", "break ;", "case    2  4     :", "{", "return   RegExpTT . COMMA ;", "}", "case    1  3  6     :", "break ;", "case    2  5     :", "{", "yybegin (  . CLASS 1  )  ;", "return   RegExpTT . CARET ;", "}", "case    1  3  7     :", "break ;", "case    2  6     :", "{", "states . set (  (  ( states . size (  )  )     -     1  )  ,     . CLASS 2  )  ;", "return   RegExpTT . CHARACTER ;", "}", "case    1  3  8     :", "break ;", "case    2  7     :", "{", "yypushback (  1  )  ;", "yybegin (  . CLASS 2  )  ;", "}", "case    1  3  9     :", "break ;", "case    2  8     :", "{", "yybegin (  . CLASS 2  )  ;", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . CLASS 1  )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "return   RegExpTT . CHARACTER ;", "}", "case    1  4  0     :", "break ;", "case    2  9     :", "{", "if    ( allowEmptyCharacterClass )     {", "yypopstate (  )  ;", "return   RegExpTT . CLASS _ END ;", "}", "yybegin (  . CLASS 2  )  ;", "return   RegExpTT . CHARACTER ;", "}", "case    1  4  1     :", "break ;", "case    3  0     :", "{", "if    ( commentMode )", "return   TokenType . WHITE _ SPACE ;", "yypushback (  1  )  ;", "yybegin (  . CLASS 2  )  ;", "}", "case    1  4  2     :", "break ;", "case    3  1     :", "{", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . CLASS 1  )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "return   RegExpTT . CHARACTER ;", "}", "case    1  4  3     :", "break ;", "case    3  2     :", "{", "yypopstate (  )  ;", "return   RegExpTT . CLASS _ END ;", "}", "case    1  4  4     :", "break ;", "case    3  3     :", "{", "return   RegExpTT . MINUS ;", "}", "case    1  4  5     :", "break ;", "case    3  4     :", "{", "yypopstate (  )  ;", "yypushstate (  . EMBRACED )  ;", "return   RegExpTT . LBRACE ;", "}", "case    1  4  6     :", "break ;", "case    3  5     :", "{", "yypopstate (  )  ;", "return   RegExpTT . CATEGORY _ SHORT _ HAND ;", "}", "case    1  4  7     :", "break ;", "case    3  6     :", "{", "yybegin (  . YYINITIAL )  ;", "return   RegExpTT . BAD _ CHARACTER ;", "}", "case    1  4  8     :", "break ;", "case    3  7     :", "{", "yybegin (  . YYINITIAL )  ;", "return   RegExpTT . GROUP _ END ;", "}", "case    1  4  9     :", "break ;", "case    3  8     :", "{", "handleOptions (  )  ;", "return   RegExpTT . OPTIONS _ ON ;", "}", "case    1  5  0     :", "break ;", "case    3  9     :", "{", "handleOptions (  )  ;", "return   RegExpTT . OPTIONS _ OFF ;", "}", "case    1  5  1     :", "break ;", "case    4  0     :", "{", "yybegin (  . YYINITIAL )  ;", "return   RegExpTT . COLON ;", "}", "case    1  5  2     :", "break ;", "case    4  1     :", "{", "yybegin (  . YYINITIAL )  ;", "return   RegExpTT . GT ;", "}", "case    1  5  3     :", "break ;", "case    4  2     :", "{", "yybegin (  . YYINITIAL )  ;", "return   RegExpTT . QUOTE ;", "}", "case    1  5  4     :", "break ;", "case    4  3     :", "{", "return   RegExpTT . BAD _ CHARACTER ;", "}", "case    1  5  5     :", "break ;", "case    4  4     :", "{", "return   allowMysqlBracketExpressions    ?    RegExpTT . NAME    :    RegExpTT . BAD _ CHARACTER ;", "}", "case    1  5  6     :", "break ;", "case    4  5     :", "{", "yypopstate (  )  ;", "return    ( yycharat (  (  -  1  )  )  )     =  =     ' u '     ?    StringEscapesTokenTypes . INVALID _ UNICODE _ ESCAPE _ TOKEN    :    RegExpTT . BAD _ HEX _ VALUE ;", "}", "case    1  5  7     :", "break ;", "case    4  6     :", "{", "yybegin (  . OPTIONS )  ;", "return   RegExpTT . SET _ OPTIONS ;", "}", "case    1  5  8     :", "break ;", "case    4  7     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "yypushstate (  . NEGATED _ CLASS )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "case    1  5  9     :", "break ;", "case    4  8     :", "{", "return   RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  6  0     :", "break ;", "case    4  9     :", "{", "return   RegExpTT . ESC _ CHARACTER ;", "}", "case    1  6  1     :", "break ;", "case    5  0     :", "{", "return    ( allowDanglingMetacharacters )     !  =     ( Boolean . TRUE )     ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  6  2     :", "break ;", "case    5  1     :", "{", "return    ( allowDanglingMetacharacters )     =  =     ( Boolean . FALSE )     ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  6  3     :", "break ;", "case    5  2     :", "{", "return    ( yystate (  )  )     =  =     (  . CLASS 2  )     ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  6  4     :", "break ;", "case    5  3     :", "{", "return   commentMode    ?    RegExpTT . ESC _ CTRL _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  6  5     :", "break ;", "case    5  4     :", "{", "return   RegExpTT . ESC _ CTRL _ CHARACTER ;", "}", "case    1  6  6     :", "break ;", "case    5  5     :", "{", "return   RegExpTT . BOUNDARY ;", "}", "case    1  6  7     :", "break ;", "case    5  6     :", "{", "return   RegExpTT . CHAR _ CLASS ;", "}", "case    1  6  8     :", "break ;", "case    5  7     :", "{", "if    ( xmlSchemaMode )", "return   RegExpTT . CHAR _ CLASS ;", "else", "return   StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "}", "case    1  6  9     :", "break ;", "case    5  8     :", "{", "yypushstate (  . PROP )  ;", "return   RegExpTT . PROPERTY ;", "}", "case    1  7  0     :", "break ;", "case    5  9     :", "{", "return   allowTransformationEscapes    ?    RegExpTT . CHAR _ CLASS    :    StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "}", "case    1  7  1     :", "break ;", "case    6  0     :", "{", "String   text    =    yytext (  )  . toString (  )  . substring (  1  )  ;", "if    ( allowOctalNoLeadingZero )     {", "if    (  (  ( Integer . parseInt ( text )  )     <  =     ( capturingGroupCount )  )     &  &     (  ( yystate (  )  )     !  =     (  . CLASS 2  )  )  )", "return   RegExpTT . BACKREF ;", "int   i    =     0  ;", "int   value    =     0  ;", "for    (  ;    i    <     ( text . length (  )  )  ;    i +  +  )     {", "char   c    =    text . charAt ( i )  ;", "if    ( c    >     '  7  '  )", "break ;", "value    =     ( value    *     8  )     +     ( c    -     '  0  '  )  ;", "}", "if    ( i    >     0  )     {", "yypushback (  (  ( text . length (  )  )     -    i )  )  ;", "if    ( value    >     ( maxOctal )  )     {", "yypushback (  1  )  ;", "return   RegExpTT . BAD _ OCT _ VALUE ;", "}", "if    (  (  ( minOctalDigits )     >    i )     &  &     (  ( yystate (  )  )     !  =     (  . CLASS 2  )  )  )     {", "return   RegExpTT . BAD _ OCT _ VALUE ;", "}", "return   RegExpTT . OCT _ CHAR ;", "}", "return   StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "} else    {", "if    (  ( yystate (  )  )     =  =     (  . CLASS 2  )  )     {", "yypushback (  (  ( yylength (  )  )     -     2  )  )  ;", "return   StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "}", "while    (  (  ( yylength (  )  )     >     2  )     &  &     (  ( Integer . parseInt ( yytext (  )  . toString (  )  . substring (  1  )  )  )     >     ( capturingGroupCount )  )  )     {", "yypushback (  1  )  ;", "}", "return   RegExpTT . BACKREF ;", "}", "}", "case    1  7  2     :", "break ;", "case    6  1     :", "{", "yypushstate (  . QUOTED )  ;", "return   RegExpTT . QUOTE _ BEGIN ;", "}", "case    1  7  3     :", "break ;", "case    6  2     :", "{", "return   RegExpTT . BAD _ HEX _ VALUE ;", "}", "case    1  7  4     :", "break ;", "case    6  3     :", "{", "return   allowTransformationEscapes    ?    RegExpTT . CHAR _ CLASS    :    StringEscapesTokenTypes . INVALID _ UNICODE _ ESCAPE _ TOKEN ;", "}", "case    1  7  5     :", "break ;", "case    6  4     :", "{", "return   allowOctalNoLeadingZero    ?    RegExpTT . OCT _ CHAR    :    RegExpTT . BAD _ OCT _ VALUE ;", "}", "case    1  7  6     :", "break ;", "case    6  5     :", "{", "return    ( allowHexDigitClass )     |  |     ( allowHorizontalWhitespaceClass )     ?    RegExpTT . CHAR _ CLASS    :    StringEscapesTokenTypes . INVALID _ CHARACTER _ ESCAPE _ TOKEN ;", "}", "case    1  7  7     :", "break ;", "case    6  6     :", "{", "yypushstate (  . NAMED )  ;", "return   RegExpTT . NAMED _ CHARACTER ;", "}", "case    1  7  8     :", "break ;", "case    6  7     :", "{", "yypopstate (  )  ;", "return   RegExpTT . QUOTE _ END ;", "}", "case    1  7  9     :", "break ;", "case    6  8     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "yybegin (  . CLASS 2  )  ;", "if    ( allowMysqlBracketExpressions )     {", "yypushback (  1  )  ;", "} else", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . CLASS 1  )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "} else    {", "return   RegExpTT . CHARACTER ;", "}", "}", "case    1  8  0     :", "break ;", "case    6  9     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "yybegin (  . CLASS 2  )  ;", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . NEGATED _ CLASS )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "return   RegExpTT . CHARACTER ;", "}", "case    1  8  1     :", "break ;", "case    7  0     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "yybegin (  . CLASS 2  )  ;", "if    ( allowPosixBracketExpressions )     {", "yypushback (  1  )  ;", "} else", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . CLASS 1  )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "} else    {", "return   RegExpTT . CHARACTER ;", "}", "}", "case    1  8  2     :", "break ;", "case    7  1     :", "{", "yybegin (  . CLASS 2  )  ;", "return   allowEmptyCharacterClass    ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    1  8  3     :", "break ;", "case    7  2     :", "{", "yybegin (  . CLASS 2  )  ;", "return   RegExpTT . ESC _ CHARACTER ;", "}", "case    1  8  4     :", "break ;", "case    7  3     :", "{", "yypushstate (  . QUOTED _ CLASS 1  )  ;", "return   RegExpTT . QUOTE _ BEGIN ;", "}", "case    1  8  5     :", "break ;", "case    7  4     :", "{", "char   c    =    yycharat (  1  )  ;", "if    (  ( allowPosixBracketExpressions )     &  &     ( c    =  =     '  :  '  )  )     {", "yybegin (  . BRACKET _ EXPRESSION )  ;", "return   RegExpTT . BRACKET _ EXPRESSION _ BEGIN ;", "} else", "if    (  ( allowMysqlBracketExpressions )     &  &     ( c    =  =     '  =  '  )  )     {", "yybegin (  . MYSQL _ CHAR _ EQ _ EXPRESSION )  ;", "return   RegExpTT . MYSQL _ CHAR _ EQ _ BEGIN ;", "} else", "if    (  ( allowMysqlBracketExpressions )     &  &     ( c    =  =     '  .  '  )  )     {", "yybegin (  . MYSQL _ CHAR _ EXPRESSION )  ;", "return   RegExpTT . MYSQL _ CHAR _ BEGIN ;", "} else    {", "yypushback (  1  )  ;", "return   allowNestedCharacterClasses    ?    RegExpTT . CLASS _ BEGIN    :    RegExpTT . CHARACTER ;", "}", "}", "case    1  8  6     :", "break ;", "case    7  5     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "if    ( allowNestedCharacterClasses )     {", "yypushstate (  . NEGATED _ CLASS )  ;", "return   RegExpTT . CLASS _ BEGIN ;", "}", "return   RegExpTT . CHARACTER ;", "}", "case    1  8  7     :", "break ;", "case    7  6     :", "{", "if    ( allowNestedCharacterClasses )", "return   RegExpTT . ANDAND ;", "else", "yypushback (  1  )  ;", "return   RegExpTT . CHARACTER ;", "}", "case    1  8  8     :", "break ;", "case    7  7     :", "{", "yybegin (  . CLASS 2  )  ;", "return   RegExpTT . BRACKET _ EXPRESSION _ END ;", "}", "case    1  8  9     :", "break ;", "case    7  8     :", "{", "yybegin (  . CLASS 2  )  ;", "return   RegExpTT . MYSQL _ CHAR _ END ;", "}", "case    1  9  0     :", "break ;", "case    7  9     :", "{", "yybegin (  . CLASS 2  )  ;", "return   RegExpTT . MYSQL _ CHAR _ EQ _ END ;", "}", "case    1  9  1     :", "break ;", "case    8  0     :", "{", "yybegin (  . PY _ COND _ REF )  ;", "return   RegExpTT . PYTHON _ COND _ REF ;", "}", "case    1  9  2     :", "break ;", "case    8  1     :", "{", "yybegin (  . NAMED _ GROUP )  ;", "( capturingGroupCount )  +  +  ;", "return   RegExpTT . RUBY _ NAMED _ GROUP ;", "}", "case    1  9  3     :", "break ;", "case    8  2     :", "{", "yybegin (  . QUOTED _ NAMED _ GROUP )  ;", "( capturingGroupCount )  +  +  ;", "return   RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP ;", "}", "case    1  9  4     :", "break ;", "case    8  3     :", "{", "return   RegExpTT . NON _ CAPT _ GROUP ;", "}", "case    1  9  5     :", "break ;", "case    8  4     :", "{", "return   RegExpTT . POS _ LOOKAHEAD ;", "}", "case    1  9  6     :", "break ;", "case    8  5     :", "{", "return   RegExpTT . ATOMIC _ GROUP ;", "}", "case    1  9  7     :", "break ;", "case    8  6     :", "{", "return   RegExpTT . NEG _ LOOKAHEAD ;", "}", "case    1  9  8     :", "break ;", "case    8  7     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "yypushstate (  . QUANTIFIER )  ;", "return   RegExpTT . LBRACE ;", "}", "case    1  9  9     :", "break ;", "case    8  8     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "if    (  ( allowOmitBothNumbersInQuantifiers )     |  |     (  ( allowDanglingMetacharacters )     !  =     ( Boolean . TRUE )  )  )     {", "yypushstate (  . QUANTIFIER )  ;", "return   RegExpTT . LBRACE ;", "} else", "return   RegExpTT . CHARACTER ;", "}", "case    2  0  0     :", "break ;", "case    8  9     :", "{", "yybegin (  . NAMED _ GROUP )  ;", "return   RegExpTT . RUBY _ NAMED _ GROUP _ CALL ;", "}", "case    2  0  1     :", "break ;", "case    9  0     :", "{", "yybegin (  . QUOTED _ NAMED _ GROUP )  ;", "return   RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP _ CALL ;", "}", "case    2  0  2     :", "break ;", "case    9  1     :", "{", "if    ( xmlSchemaMode )     {", "yypushback (  1  )  ;", "return   RegExpTT . CHAR _ CLASS ;", "} else", "return   RegExpTT . CTRL ;", "}", "case    2  0  3     :", "break ;", "case    9  2     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     2  )  ;", "{", "if    ( allowExtendedUnicodeCharacter )", "yypushstate (  . EMBRACED _ HEX )  ;", "else", "return   RegExpTT . BAD _ HEX _ VALUE ;", "}", "case    2  0  4     :", "break ;", "case    9  3     :", "{", "if    ( allowOneHexCharEscape )     {", "return   RegExpTT . HEX _ CHAR ;", "} else    {", "yypushback (  1  )  ;", "return   RegExpTT . BAD _ HEX _ VALUE ;", "}", "}", "case    2  0  5     :", "break ;", "case    9  4     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     2  )  ;", "{", "if    ( allowExtendedUnicodeCharacter )", "yypushstate (  . EMBRACED _ HEX )  ;", "else", "return   StringEscapesTokenTypes . INVALID _ UNICODE _ ESCAPE _ TOKEN ;", "}", "case    2  0  6     :", "break ;", "case    9  5     :", "{", "yypushback (  (  ( yylength (  )  )     -     2  )  )  ;", "return   StringEscapesTokenTypes . INVALID _ UNICODE _ ESCAPE _ TOKEN ;", "}", "case    2  0  7     :", "break ;", "case    9  6     :", "{", "return   RegExpTT . OCT _ CHAR ;", "}", "case    2  0  8     :", "break ;", "case    9  7     :", "{", "yybegin (  . NAMED _ GROUP )  ;", "return   RegExpTT . RUBY _ NAMED _ GROUP _ REF ;", "}", "case    2  0  9     :", "break ;", "case    9  8     :", "{", "yybegin (  . QUOTED _ NAMED _ GROUP )  ;", "return   RegExpTT . RUBY _ QUOTED _ NAMED _ GROUP _ REF ;", "}", "case    2  1  0     :", "break ;", "case    9  9     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "return   RegExpTT . CHARACTER ;", "}", "case    2  1  1     :", "break ;", "case    1  0  0     :", "{", "yypopstate (  )  ;", "return    ( yycharat (  (  -  1  )  )  )     =  =     ' u '     ?    RegExpTT . UNICODE _ CHAR    :    RegExpTT . HEX _ CHAR ;", "}", "case    2  1  2     :", "break ;", "case    1  0  1     :", "{", "yybegin (  . NAMED _ GROUP )  ;", "( capturingGroupCount )  +  +  ;", "return   RegExpTT . PYTHON _ NAMED _ GROUP ;", "}", "case    2  1  3     :", "break ;", "case    1  0  2     :", "{", "yybegin (  . PY _ NAMED _ GROUP _ REF )  ;", "return   RegExpTT . PYTHON _ NAMED _ GROUP _ REF ;", "}", "case    2  1  4     :", "break ;", "case    1  0  3     :", "{", "return   RegExpTT . POS _ LOOKBEHIND ;", "}", "case    2  1  5     :", "break ;", "case    1  0  4     :", "{", "return   RegExpTT . NEG _ LOOKBEHIND ;", "}", "case    2  1  6     :", "break ;", "case    1  0  5     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     1  )  ;", "{", "if    (  ( allowOmitNumbersInQuantifiers )     |  |     (  ( allowDanglingMetacharacters )     !  =     ( Boolean . TRUE )  )  )     {", "yypushstate (  . QUANTIFIER )  ;", "return   RegExpTT . LBRACE ;", "} else", "return   RegExpTT . CHARACTER ;", "}", "case    2  1  7     :", "break ;", "case    1  0  6     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     2  )  ;", "{", "return   RegExpTT . ESC _ CHARACTER ;", "}", "case    2  1  8     :", "break ;", "case    1  0  7     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     2  )  ;", "{", "return   allowOmitBothNumbersInQuantifiers    ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    2  1  9     :", "break ;", "case    1  0  8     :", "{", "return   RegExpTT . HEX _ CHAR ;", "}", "case    2  2  0     :", "break ;", "case    1  0  9     :", "{", "return   RegExpTT . COMMENT ;", "}", "case    2  2  1     :", "break ;", "case    1  1  0     :", "zzMarkedPos    =    Character . offsetByCodePoints ( zzBufferL ,    zzStartRead ,     2  )  ;", "{", "return   allowOmitNumbersInQuantifiers    ?    RegExpTT . ESC _ CHARACTER    :    RegExpTT . REDUNDANT _ ESCAPE ;", "}", "case    2  2  2     :", "break ;", "case    1  1  1     :", "{", "if    ( allowOctalNoLeadingZero )", "yypushback (  1  )  ;", "return   RegExpTT . OCT _ CHAR ;", "}", "case    2  2  3     :", "break ;", "case    1  1  2     :", "{", "return   RegExpTT . UNICODE _ CHAR ;", "}", "case    2  2  4     :", "break ;", "default    :", "zzScanError (  . ZZ _ NO _ MATCH )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["advance"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( getTokenStart (  )  )     +     ( yylength (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTokenEnd"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzStartRead ;", "}", "METHOD_END"], "methodName": ["getTokenStart"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "final   String   o    =    yytext (  )  . toString (  )  ;", "if    ( o . contains (  \" x \"  )  )     {", "commentMode    =     !  ( o . startsWith (  \"  -  \"  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["handleOptions"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "zzBuffer    =    buffer ;", "zzCurrentPos    =    zzMarkedPos    =    zzStartRead    =    start ;", "zzAtEOF    =    false ;", "zzAtBOL    =    true ;", "zzEndRead    =    end ;", "yybegin ( initialState )  ;", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "zzLexicalState    =    newState ;", "}", "METHOD_END"], "methodName": ["yybegin"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . charAt (  (  ( zzStartRead )     +    pos )  )  ;", "}", "METHOD_END"], "methodName": ["yycharat"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return    ( zzMarkedPos )     -     ( zzStartRead )  ;", "}", "METHOD_END"], "methodName": ["yylength"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "final   int   state    =    states . remove (  (  ( states . size (  )  )     -     1  )  )  ;", "yybegin ( state )  ;", "}", "METHOD_END"], "methodName": ["yypopstate"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "if    ( number    >     ( yylength (  )  )  )", "zzScanError (  . ZZ _ PUSHBACK _  2 BIG )  ;", "zzMarkedPos    -  =    number ;", "}", "METHOD_END"], "methodName": ["yypushback"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "states . add ( yystate (  )  )  ;", "yybegin ( state )  ;", "}", "METHOD_END"], "methodName": ["yypushstate"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzLexicalState ;", "}", "METHOD_END"], "methodName": ["yystate"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return   zzBuffer . subSequence ( zzStartRead ,    zzMarkedPos )  ;", "}", "METHOD_END"], "methodName": ["yytext"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["zzRefill"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "String   message ;", "try    {", "message    =     . ZZ _ ERROR _ MSG [ errorCode ]  ;", "}    catch    ( ArrayIndexOutOfBoundsException   e )     {", "message    =     . ZZ _ ERROR _ MSG [  . ZZ _ UNKNOWN _ ERROR ]  ;", "}", "throw   new   Error ( message )  ;", "}", "METHOD_END"], "methodName": ["zzScanError"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  7  6  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAction (  . ZZ _ ACTION _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAction"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  7  6  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackAttribute (  . ZZ _ ATTRIBUTE _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackAttribute"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( int   i    =     0  ,    length    =    packed . length (  )  ;    i    <    length ;    i    +  =     2  )     {", "size    +  =    packed . charAt ( i )  ;", "}", "char [  ]    map    =    new   char [ size ]  ;", "int   i    =     0  ;", "int   j    =     0  ;", "while    ( i    <     ( packed . length (  )  )  )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "char   value    =    packed . charAt (  ( i +  +  )  )  ;", "do", "map [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["zzUnpackCMap"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  1  7  6  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackRowMap (  . ZZ _ ROWMAP _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   high    =     ( packed . charAt (  ( i +  +  )  )  )     <  <     1  6  ;", "result [  ( j +  +  )  ]     =    high    |     ( packed . charAt (  ( i +  +  )  )  )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackRowMap"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int [  ]    result    =    new   int [  5  0  4  0  ]  ;", "int   offset    =     0  ;", "offset    =     . zzUnpackTrans (  . ZZ _ TRANS _ PACKED _  0  ,    offset ,    result )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "int   i    =     0  ;", "int   j    =    offset ;", "int   l    =    packed . length (  )  ;", "while    ( i    <    l )     {", "int   count    =    packed . charAt (  ( i +  +  )  )  ;", "int   value    =    packed . charAt (  ( i +  +  )  )  ;", "value -  -  ;", "do", "result [  ( j +  +  )  ]     =    value ;", "while    (  (  -  - count )     >     0     )  ;", "}", "return   j ;", "}", "METHOD_END"], "methodName": ["zzUnpackTrans"], "fileName": "org.intellij.lang.regexp._RegExLexer"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  |  |  |  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyBranches"], "fileName": "org.intellij.lang.regexp.inspection.DuplicateAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  > a {  3  }  <  / warning >  |  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  > a < caret >  < weak _ warning   descr =  \\  \" Fixed   repetition   range \\  \"  >  {  3  ,  3  }  <  / weak _ warning >  <  / warning >  | b | c \"  ,     \" a {  3  }  | b | c \"  ,     \" Remove   duplicate   branch \"  )  ;", "}", "METHOD_END"], "methodName": ["testMoreBranches"], "fileName": "org.intellij.lang.regexp.inspection.DuplicateAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  (  [ aeiou ]  [  ^ aeiou ]  )  *  |  (  [  ^ aeiou ]  [ aeiou ]  )  *  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoWarn"], "fileName": "org.intellij.lang.regexp.inspection.DuplicateAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  >  [ abc ]  <  / warning >  |  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  >  [ cba ]  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testOrderIrrelevant"], "fileName": "org.intellij.lang.regexp.inspection.DuplicateAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  >  \\  \\ t < caret >  <  / warning >  |  < warning   descr =  \\  \" Duplicate   branch   in   alternation \\  \"  >  \\  \\ x 0  9  <  / warning >  \"  ,     \"  \\  \\ x 0  9  \"  ,     \" Remove   duplicate   branch \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.DuplicateAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  | right \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyLeft"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  | m < warning   descr =  \\  \" Empty   branch   in   alternation \\  \"  >  |  < caret >  <  / warning >  \"  ,     \"  | m \"  ,     \" Remove   empty   branch \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyLeftAndRight"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \" a < warning   descr =  \\  \" Empty   branch   in   alternation \\  \"  >  < caret >  |  <  / warning >  | b \"  ,     \" a | b \"  ,     \" Remove   empty   branch \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyMiddle"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \" left |  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEmptyRight"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  (  | kb | mb | gb ) s ?  \"  )  ;", "}", "METHOD_END"], "methodName": ["testLogbackUnit"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Empty   branch   in   alternation \\  \"  >  |  <  / warning >  \"  ,     \"  \"  ,     \" Remove   empty   branch \"  )  ;", "}", "METHOD_END"], "methodName": ["testVeryEmpty"], "fileName": "org.intellij.lang.regexp.inspection.EmptyAlternationBranchInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  (  \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  {  \\  '  \\  \"  >  \\  \\  {  <  / warning >  \"     +     (  (  (  (  (  (  (  (  \"  \\  \\  }  \"     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  (  \\  '  \\  \"  >  \\  \\  (  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  )  \\  '  \\  \"  >  \\  \\  )  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  .  \\  '  \\  \"  >  \\  \\  .  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  *  \\  '  \\  \"  >  \\  \\  *  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  +  \\  '  \\  \"  >  \\  \\  +  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  ?  \\  '  \\  \"  >  \\  \\  ?  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  |  \\  '  \\  \"  >  \\  \\  |  <  / warning >  \"  )     +     \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  $  \\  '  \\  \"  >  \\  \\  $  <  / warning >  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testHighlighting"], "fileName": "org.intellij.lang.regexp.inspection.EscapedMetaCharacterInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  \\  \\  [  \\  \\  ^  \\  \\  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoWarn"], "fileName": "org.intellij.lang.regexp.inspection.EscapedMetaCharacterInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Escaped   meta   character    \\  '  .  \\  '  \\  \"  >  \\  \\  .  <  / warning >  \"  ,     \"  [  .  ]  \"  ,     \" Replace   with    '  [  .  ]  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.EscapedMetaCharacterInspectionTest"}, {"methodBody": ["METHOD_START", "{", "final   int   value    =    aChar . getValue (  )  ;", "final   String   hex    =    Integer . toHexString ( value )  ;", "final   String   result    =     (  ( hex . length (  )  )     =  =     1     ?     \"  \\  \\ x 0  \"     :     \"  \\  \\ x \"  )     +    hex ;", "return   RegExpReplacementUtil . eForContext ( result ,    aChar )  ;", "}", "METHOD_END"], "methodName": ["buildReplacementText"], "fileName": "org.intellij.lang.regexp.inspection.OctalEscapeInspection"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Octal   escape    \\  '  \\  \\  0  1  1  \\  '    in   RegExp \\  \"  >  \\  \\  0  1  1  <  / warning >  \"  ,     \"  \\  \\ x 0  9  \"  ,     \" Replace   with    \\  '  \\  \\ x 0  9  \\  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.OctalEscapeInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  (  ?  > a +  )  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testAtomicGroup"], "fileName": "org.intellij.lang.regexp.inspection.ReDoSInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Potential   exponential   backtracking \\  \"  >  (  .  * a )  {  1  0  }  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedQuantifiers1"], "fileName": "org.intellij.lang.regexp.inspection.ReDoSInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Potential   exponential   backtracking \\  \"  >  ( a +  )  +  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testNestedQuantifiers2"], "fileName": "org.intellij.lang.regexp.inspection.ReDoSInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  ( a +  )  +  +  \"  )  ;", "}", "METHOD_END"], "methodName": ["testPossessiveQuantifier"], "fileName": "org.intellij.lang.regexp.inspection.ReDoSInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\  -  \\  '    in   RegExp \\  \"  >  \\  \\  -  <  / warning >  [  < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\  *  \\  '    in   RegExp \\  \"  >  \\  \\  *  <  / warning >  \\  \\  -  \\  \\  [  \\  \\  ]  \\  \\  \\  \\  < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\  +  \\  '    in   RegExp \\  \"  >  \\  \\  +  <  / warning >  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testCharacterClass"], "fileName": "org.intellij.lang.regexp.inspection.RedundantEscapeInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\  ;  \\  '    in   RegExp \\  \"  >  \\  \\  ;  <  / warning >  \"  ,     \"  ;  \"  ,     \" Remove   redundant   escape \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.RedundantEscapeInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \" a < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\     \\  '    in   RegExp \\  \"  >  \\  \\     <  / warning > b < warning   descr =  \\  \" Redundant   character   escape    \\  '  \\  \\     \\  '    in   RegExp \\  \"  >  \\  \\     <  / warning > c \"  )  ;", "}", "METHOD_END"], "methodName": ["testWhitespace"], "fileName": "org.intellij.lang.regexp.inspection.RedundantEscapeInspectionTest"}, {"methodBody": ["METHOD_START", "{", "final   RegExpAtom [  ]    atoms 1     =    branch 1  . getAtoms (  )  ;", "final   RegExpAtom [  ]    atoms 2     =    branch 2  . getAtoms (  )  ;", "if    (  ( atoms 1  . length )     !  =     ( atoms 2  . length )  )     {", "return   false ;", "}", "for    ( int   i    =     0  ;    i    <     ( atoms 1  . length )  ;    i +  +  )     {", "if    (  !  (  . areElementsEquivalent ( atoms 1  [ i ]  ,    atoms 2  [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areBranchesEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "return    ( RegExpEquivalenceChecker . areCharsEquivalent ( charRange 1  . getFrom (  )  ,    charRange 2  . getFrom (  )  )  )     &  &     ( RegExpEquivalenceChecker . areCharsEquivalent ( charRange 1  . getTo (  )  ,    charRange 2  . getTo (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["areCharRangesEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "return    ( aChar 1  . getValue (  )  )     =  =     ( aChar 2  . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["areCharsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    (  ( aClass 1  . isNegated (  )  )     !  =     ( aClass 2  . isNegated (  )  )  )     {", "return   false ;", "}", "final   RegExpClassElement [  ]    elements 1     =    aClass 1  . getElements (  )  ;", "final   RegExpClassElement [  ]    elements 2     =    aClass 2  . getElements (  )  ;", "if    (  ( elements 1  . length )     !  =     ( elements 2  . length )  )     {", "return   false ;", "}", "Arrays . sort ( elements 1  ,     . TEXT _ COMPARATOR )  ;", "Arrays . sort ( elements 2  ,     . TEXT _ COMPARATOR )  ;", "for    ( int   i    =     0  ;    i    <     ( elements 1  . length )  ;    i +  +  )     {", "if    (  !  (  . areElementsEquivalent ( elements 1  [ i ]  ,    elements 2  [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areClassesEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "return    ( RegExpEquivalenceChecker . areElementsEquivalent ( element 1  . getAtom (  )  ,    element 2  . getAtom (  )  )  )     &  &     ( RegExpEquivalenceChecker . areQuantifiersEquivalent ( element 1  . getQuantifier (  )  ,    element 2  . getQuantifier (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["areClosuresEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( element 1     =  =    null )     {", "return   element 2     =  =    null ;", "}", "if    (  ( element 1  . getClass (  )  )     !  =     ( element 2  . getClass (  )  )  )     {", "return   false ;", "}", "if    ( element 1    instanceof   RegExpChar )     {", "return   RegExpEquivalenceChecker . areCharsEquivalent (  (  ( RegExpChar )     ( element 1  )  )  ,     (  ( RegExpChar )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpBranch )     {", "return   RegExpEquivalenceChecker . areBranchesEquivalent (  (  ( psi . RegExpBranch )     ( element 1  )  )  ,     (  ( psi . RegExpBranch )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpClass )     {", "return   RegExpEquivalenceChecker . areClassesEquivalent (  (  ( psi . RegExpClass )     ( element 1  )  )  ,     (  ( psi . RegExpClass )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpCharRange )     {", "return   RegExpEquivalenceChecker . areCharRangesEquivalent (  (  ( psi . RegExpCharRange )     ( element 1  )  )  ,     (  ( psi . RegExpCharRange )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpClosure )     {", "return   RegExpEquivalenceChecker . areClosuresEquivalent (  (  ( psi . RegExpClosure )     ( element 1  )  )  ,     (  ( psi . RegExpClosure )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpGroup )     {", "return   RegExpEquivalenceChecker . areGroupsEquivalent (  (  ( psi . RegExpGroup )     ( element 1  )  )  ,     (  ( psi . RegExpGroup )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpIntersection )     {", "return   RegExpEquivalenceChecker . areIntersectionsEquivalent (  (  ( psi . RegExpIntersection )     ( element 1  )  )  ,     (  ( psi . RegExpIntersection )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpNamedGroupRef )     {", "return   RegExpEquivalenceChecker . areNamedGroupRefsEquivalent (  (  ( psi . RegExpNamedGroupRef )     ( element 1  )  )  ,     (  ( psi . RegExpNamedGroupRef )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpNumber )     {", "return   RegExpEquivalenceChecker . areNumbersEquivalent (  (  ( psi . RegExpNumber )     ( element 1  )  )  ,     (  ( psi . RegExpNumber )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpOptions )     {", "return   RegExpEquivalenceChecker . areOptionsEquivalent (  (  ( psi . RegExpOptions )     ( element 1  )  )  ,     (  ( psi . RegExpOptions )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpPattern )     {", "return   RegExpEquivalenceChecker . arePatternsEquivalent (  (  ( psi . RegExpPattern )     ( element 1  )  )  ,     (  ( psi . RegExpPattern )     ( element 2  )  )  )  ;", "} else", "if    ( element 1    instanceof   psi . RegExpSetOptions )     {", "return   RegExpEquivalenceChecker . areSetOptionsEquivalent (  (  ( psi . RegExpSetOptions )     ( element 1  )  )  ,     (  ( psi . RegExpSetOptions )     ( element 2  )  )  )  ;", "}", "return   element 1  . textMatches ( element 2  )  ;", "}", "METHOD_END"], "methodName": ["areElementsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "return    (  ( group 1  . getType (  )  )     =  =     ( group 2  . getType (  )  )  )     &  &     ( RegExpEquivalenceChecker . arePatternsEquivalent ( group 1  . getPattern (  )  ,    group 2  . getPattern (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["areGroupsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "final   RegExpClassElement [  ]    operands 1     =    intersection 1  . getOperands (  )  ;", "final   RegExpClassElement [  ]    operands 2     =    intersection 2  . getOperands (  )  ;", "if    (  ( operands 1  . length )     !  =     ( operands 2  . length )  )     {", "return   false ;", "}", "Arrays . sort ( operands 1  ,     . TEXT _ COMPARATOR )  ;", "Arrays . sort ( operands 2  ,     . TEXT _ COMPARATOR )  ;", "for    ( int   i    =     0  ;    i    <     ( operands 1  . length )  ;    i +  +  )     {", "if    (  !  (  . areElementsEquivalent ( operands 1  [ i ]  ,    operands 2  [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["areIntersectionsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "final   String   name    =    namedGroupRef 1  . getGroupName (  )  ;", "return    ( name    !  =    null )     &  &     ( name . equals ( namedGroupRef 2  . getGroupName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["areNamedGroupRefsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( number 1     =  =    null )     {", "return   number 2     =  =    null ;", "} else", "if    ( number 2     =  =    null )     {", "return   false ;", "}", "final   Number   ue 1     =    number 1  . getValue (  )  ;", "final   Number   ue 2     =    number 2  . getValue (  )  ;", "return    ( ue 1     !  =    null )     &  &     ( ue 1  . equals ( ue 2  )  )  ;", "}", "METHOD_END"], "methodName": ["areNumbersEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( options 1     =  =    null )     {", "return   options 2     =  =    null ;", "} else", "if    ( options 2     =  =    null )     {", "return   false ;", "}", "return   StringUtil . containsAnyChar ( options 1  . getText (  )  ,    options 2  . getText (  )  )  ;", "}", "METHOD_END"], "methodName": ["areOptionsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( pattern 1     =  =    null )", "return   pattern 2     =  =    null ;", "if    ( pattern 2     =  =    null )", "return   false ;", "final   RegExpBranch [  ]    branches 1     =    pattern 1  . getBranches (  )  ;", "final   RegExpBranch [  ]    branches 2     =    pattern 2  . getBranches (  )  ;", "if    (  ( branches 1  . length )     !  =     ( branches 2  . length )  )     {", "return   false ;", "}", "Arrays . sort ( branches 1  ,     . TEXT _ COMPARATOR )  ;", "Arrays . sort ( branches 2  ,     . TEXT _ COMPARATOR )  ;", "for    ( int   i    =     0  ;    i    <     ( branches 1  . length )  ;    i +  +  )     {", "if    (  !  (  . areBranchesEquivalent ( branches 1  [ i ]  ,    branches 2  [ i ]  )  )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["arePatternsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "if    ( quantifier 1  . isCounted (  )  )     {", "return    (  ( quantifier 2  . isCounted (  )  )     &  &     (  . areNumbersEquivalent ( quantifier 1  . getMin (  )  ,    quantifier 2  . getMin (  )  )  )  )     &  &     (  . areNumbersEquivalent ( quantifier 1  . getMax (  )  ,    quantifier 2  . getMax (  )  )  )  ;", "}", "return   quantifier 1  . textMatches ( quantifier 2  )  ;", "}", "METHOD_END"], "methodName": ["areQuantifiersEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "return    ( RegExpEquivalenceChecker . areOptionsEquivalent ( setOptions 1  . getOnOptions (  )  ,    setOptions 2  . getOnOptions (  )  )  )     &  &     ( RegExpEquivalenceChecker . areOptionsEquivalent ( setOptions 1  . getOffOptions (  )  ,    setOptions 2  . getOffOptions (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["areSetOptionsEquivalent"], "fileName": "org.intellij.lang.regexp.inspection.RegExpEquivalenceChecker"}, {"methodBody": ["METHOD_START", "{", "final   RegExpPattern   pattern    =    RegExpFactory . createPatternFromText ( text ,    context )  ;", "final   RegExpBranch   branch    =    PsiTreeUtil . getChildOfType ( pattern ,    RegExpBranch . class )  ;", "assert   branch    !  =    null ;", "return   branch ;", "}", "METHOD_END"], "methodName": ["createBranchFromText"], "fileName": "org.intellij.lang.regexp.inspection.RegExpFactory"}, {"methodBody": ["METHOD_START", "{", "final   PsiFileFactory   factory    =    PsiFileFactory . getInstance ( context . getProject (  )  )  ;", "final   PsiFile   file    =    factory . createFileFromText (  \" dummy . regexp \"  ,    RegExpFileType . INSTANCE ,    text )  ;", "final   RegExpPattern   pattern    =    PsiTreeUtil . getChildOfType ( file ,    RegExpPattern . class )  ;", "assert   pattern    !  =    null ;", "return   pattern ;", "}", "METHOD_END"], "methodName": ["createPatternFromText"], "fileName": "org.intellij.lang.regexp.inspection.RegExpFactory"}, {"methodBody": ["METHOD_START", "{", "final   LocalInspectionTool   inspection    =    getInspection (  )  ;", "myFixture . enableInspections ( inspection )  ;", "final   HighlightDisplayKey   displayKey    =    HighlightDisplayKey . find ( inspection . getShortName (  )  )  ;", "if    ( displayKey    !  =    null )     {", "final   Project   project    =    myFixture . getProject (  )  ;", "final   InspectionProfileImpl   currentProfile    =    ProjectInspectionProfileManager . getInstance ( project )  . getCurrentProfile (  )  ;", "final   HighlightDisplayLevel   errorLevel    =    currentProfile . getErrorLevel ( displayKey ,    null )  ;", "if    ( errorLevel    =  =     ( HighlightDisplayLevel . DO _ NOT _ SHOW )  )     {", "currentProfile . setErrorLevel ( displayKey ,    WARNING ,    project )  ;", "}", "}", "myFixture . configureByText ( RegExpFileType . INSTANCE ,    code )  ;", "myFixture . testHighlighting (  )  ;", "}", "METHOD_END"], "methodName": ["highlightTest"], "fileName": "org.intellij.lang.regexp.inspection.RegExpInspectionTestCase"}, {"methodBody": ["METHOD_START", "{", "highlightTest ( before )  ;", "myFixture . launchA ( myFixture . findSingleIntention ( hint )  )  ;", "myFixture . checkResult ( after )  ;", "}", "METHOD_END"], "methodName": ["quickfixTest"], "fileName": "org.intellij.lang.regexp.inspection.RegExpInspectionTestCase"}, {"methodBody": ["METHOD_START", "{", "final   PsiElement   context    =    element . getContainingFile (  )  . getContext (  )  ;", "ElementManipulator < PsiElement >    manipulator    =     ( context    =  =    null )     ?    null    :    ElementManipulators . getManipulator ( context )  ;", "if    ( manipulator    !  =    null )     {", "PsiElement   copy    =    context . copy (  )  ;", "PsiElement   newElement    =    manipulator . handleContentChange ( copy ,    text )  ;", "if    ( newElement    !  =    null )     {", "String   newElementText    =    newElement . getText (  )  ;", "TextRange   newRange    =    manipulator . getRangeInElement ( newElement )  ;", "return   newElementText . substring ( newRange . getStartOffset (  )  ,    newRange . getEndOffset (  )  )  ;", "}", "}", "if    ( RegExpElementImpl . isLiteralExpression ( context )  )     {", "return   StringUtil . escapeStringCharacters ( text )  ;", "} else", "if    ( context   instanceof   compsi . xml . XmlElement )     {", "return   comxml . util . XmlStringUtil . escapeString ( text )  ;", "} else    {", "return   text ;", "}", "}", "METHOD_END"], "methodName": ["escapeForContext"], "fileName": "org.intellij.lang.regexp.inspection.RegExpReplacementUtil"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  [     < warning   descr =  \\  \" Duplicate   character    \\  '     \\  '    inside   character   class \\  \"  >     <  / warning >  < warning   descr =  \\  \" Duplicate   character    \\  '     \\  '    inside   character   class \\  \"  >     <  / warning >  ]  \"  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreInClass"], "fileName": "org.intellij.lang.regexp.inspection.RepeatedSpaceInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  \\  \\ Q                \\  \\ E \"  )  ;", "}", "METHOD_END"], "methodName": ["testIgnoreQuoted"], "fileName": "org.intellij.lang.regexp.inspection.RepeatedSpaceInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \"  5    consecutive   spaces   in   RegExp \\  \"  >                 <  / warning >  \"  ,     \"     {  5  }  \"  ,     \" Replace   with    '     {  5  }  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testReplacement"], "fileName": "org.intellij.lang.regexp.inspection.RepeatedSpaceInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \"  2    consecutive   spaces   in   RegExp \\  \"  >        <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.RepeatedSpaceInspectionTest"}, {"methodBody": ["METHOD_START", "{", "final   StringBuilder   text    =    new   StringBuilder (  \"  [  \"  )  ;", "for    ( RegExpBranch   branch    :    pat . getBranches (  )  )     {", "for    ( PsiElement   child    :    branch . getChildren (  )  )     {", "final   RegExpChar   ch    =     (  ( RegExpChar )     ( child )  )  ;", "final   IElementType   type    =    ch . getNode (  )  . getFirstChildNode (  )  . getElementType (  )  ;", "if    ( type    =  =     ( RegExpTT . REDUNDANT _ ESCAPE )  )     {", "text . append (  (  ( char )     ( ch . getValue (  )  )  )  )  ;", "} else", "if    ( type    =  =     ( RegExpTT . ESC _ CHARACTER )  )     {", "final   int   value    =    ch . getValue (  )  ;", "switch    ( value )     {", "case    '  .  '     :", "case    '  $  '     :", "case    '  ?  '     :", "case    '  *  '     :", "case    '  +  '     :", "case    '  |  '     :", "case    '  {  '     :", "case    '  (  '     :", "case    '  )  '     :", "text . append (  (  ( char )     ( value )  )  )  ;", "break ;", "case    '  ^  '     :", "if    (  ( text . length (  )  )     =  =     1  )     {", "text . append ( ch . getUnescapedText (  )  )  ;", "} else    {", "text . append (  (  ( char )     ( value )  )  )  ;", "}", "break ;", "default    :", "text . append ( ch . getUnescapedText (  )  )  ;", "}", "} else    {", "final   int   value    =    ch . getValue (  )  ;", "switch    ( value )     {", "case    '  ]  '     :", "text . append (  \"  \\  \\  ]  \"  )  ;", "break ;", "case    '  -  '     :", "case    '  ^  '     :", "if    (  ( text . length (  )  )     !  =     1  )     {", "text . append (  \"  \\  \\  -  \"  )  ;", "break ;", "}", "default    :", "text . append ( ch . getUnescapedText (  )  )  ;", "}", "}", "}", "}", "text . append (  \"  ]  \"  )  ;", "return   RegExpReplacementUtil . escapeForContext ( text . toString (  )  ,    pat )  ;", "}", "METHOD_END"], "methodName": ["buildReplacementText"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspection"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  (  < warning   descr =  \\  \" Single   character   alternation   in   RegExp \\  \"  >  \\  \\  .  |  < caret >  \\  \\  [  |  ]  |  \\  \\  (  |  \\  \\  )  |  \\  \\  {  |  }  |  \\  \\  ^  |  \\  \\  ?  |  \\  \\  *  |  \\  \\  |  |  \\  \\  +  |  -  |  \\  \\  $  <  / warning >  ) ab \"  ,     \"  (  [  .  \\  \\  [  \\  \\  ]  (  )  {  }  ^  ?  *  |  +  \\  \\  -  $  ]  ) ab \"  ,     \" Replace   with    \\  '  [  .  \\  \\  [  \\  \\  ]  (  )  {  }  ^  ?  *  |  +  \\  \\  -  $  ]  \\  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testEscapes"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \" a | b | cc | d \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoWarn"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  (  ? i ) x | y \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoWarnNoException"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Single   character   alternation   in   RegExp \\  \"  > x | y | z <  / warning >  \"  ,     \"  [ xyz ]  \"  ,     \" Replace   with    '  [ xyz ]  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testQuickfix"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  < warning   descr =  \\  \" Single   character   alternation   in   RegExp \\  \"  >  \\  \\  ^  |  \\  \\  \\ u 0  0 e 5  |  \\  \\  {  |  \\  \\  \\  \\  |  \\  \\  [  <  / warning >  \"  ,     \"  [  \\  \\  ^  \\ u 0  0 e 5  {  \\  \\  \\  \\  \\  \\  [  ]  \"  ,     \" Replace   with    \\  '  [  \\  \\  ^  \\ u 0  0 e 5  {  \\  \\  \\  \\  \\  \\  [  ]  \\  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveEscaping"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "quickfixTest (  \"  (  ?  :  < warning   descr =  \\  \" Single   character   alternation   in   RegExp \\  \"  > k < caret >  | l | m <  / warning >  )  \"  ,     \"  [ klm ]  \"  ,     \" Replace   with    '  [ klm ]  '  \"  )  ;", "}", "METHOD_END"], "methodName": ["testRemoveNonCapturingGroup"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Single   character   alternation   in   RegExp \\  \"  > a | b | c | d <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.SingleCharAlternationInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  \\ n < warning   descr =  \\  \" Anchor    \\  '  \\  \\ A \\  '    in   unexpected   position \\  \"  >  \\  \\ A <  / warning >  < warning   descr =  \\  \" Anchor    \\  '  \\  \\ Z \\  '    in   unexpected   position \\  \"  >  \\  \\ Z <  / warning >  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testAZ"], "fileName": "org.intellij.lang.regexp.inspection.UnexpectedAnchorInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  (  \"  (  ? x )  \\ n \"     +     (  \"  #    comment \\ n \"     +     \"  ^ impedance \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testCommentMode"], "fileName": "org.intellij.lang.regexp.inspection.UnexpectedAnchorInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  \\  \\  (  \\  \\ s *  <  =  \\  \\ s *  ;  \\  \\ s *  `  < warning   descr =  \\  \" Anchor    \\  '  $  \\  '    in   unexpected   position \\  \"  >  $  <  / warning >  \\  \" SeqNo \\  \"  \\  \\ s *  ;  \\  \\ s *  -  ?  \\  \\ d + j \\  \\ s *  \\  \\  ) s \"  )  ;", "}", "METHOD_END"], "methodName": ["testIDEA184428"], "fileName": "org.intellij.lang.regexp.inspection.UnexpectedAnchorInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  ^  $  \"  )  ;", "highlightTest (  \"  \\ n ^  $  \\ n \"  )  ;", "}", "METHOD_END"], "methodName": ["testNoWarn"], "fileName": "org.intellij.lang.regexp.inspection.UnexpectedAnchorInspectionTest"}, {"methodBody": ["METHOD_START", "{", "highlightTest (  \"  < warning   descr =  \\  \" Anchor    \\  '  $  \\  '    in   unexpected   position \\  \"  >  $  <  / warning >  < warning   descr =  \\  \" Anchor    \\  '  ^  \\  '    in   unexpected   position \\  \"  >  ^  <  / warning >  \"  )  ;", "}", "METHOD_END"], "methodName": ["testSimple"], "fileName": "org.intellij.lang.regexp.inspection.UnexpectedAnchorInspectionTest"}, {"methodBody": ["METHOD_START", "{", "myProject    =    myRegexpFile . getProject (  )  ;", "Document   document    =    PsiDocumentManager . getInstance ( myProject )  . getDocument ( myRegexpFile )  ;", "final   Language   language    =    myRegexpFile . getLanguage (  )  ;", "final   LanguageFileType   fileType ;", "if    ( language   instanceof   RegExpLanguage )     {", "fileType    =    RegExpLanguage . INSTANCE . getAssociatedFileType (  )  ;", "} else    {", "fileType    =    new   RegExpFileType ( language )  ;", "}", "myRegExp    =    new   EditorTextField ( document ,    myProject ,    fileType ,    false ,    false )     {", "@ Override", "public   void   addNotify (  )     {", "super . addNotify (  )  ;", "final   Editor   editor    =    getEditor (  )  ;", "assert   editor    !  =    null    :     \" Editor   not   initialized   in   addNotify (  )  \"  ;", "editor . putUserData (  . CHECK _ REG _ EXP _ EDITOR ,    Boolean . TRUE )  ;", "}", "@ Override", "protected   void   updateBorder (  @ NotNull", "EditorEx   editor )     {", "setupBorder ( editor )  ;", "}", "}  ;", "final   String   sampleText    =    PropertiesComponent . getInstance ( myProject )  . getValue (  . LAST _ EDITED _ REGEXP ,     \" Sample   Text \"  )  ;", "mySampleText    =    new   EditorTextField ( sampleText ,    myProject ,    PlainTextFileType . INSTANCE )     {", "@ Override", "protected   void   updateBorder (  @ NotNull", "EditorEx   editor )     {", "setupBorder ( editor )  ;", "}", "}  ;", "mySampleText . setOneLineMode ( false )  ;", "int   preferredWidth    =    Math . max ( JBUI . scale (  2  5  0  )  ,    myRegExp . getPreferredSize (  )  . width )  ;", "myRegExp . setPreferredWidth ( preferredWidth )  ;", "mySampleText . setPreferredWidth ( preferredWidth )  ;", "myRootPanel    =    new   JPanel ( new   BorderLayout (  )  )     {", "Disposable   disposable ;", "Alarm   updater ;", "@ Override", "public   void   addNotify (  )     {", "super . addNotify (  )  ;", "disposable    =    Disposer . newDisposable (  )  ;", "IdeFocusManager . getGlobalInstance (  )  . requestFocus ( mySampleText ,    true )  ;", "new   AnAction (  )     {", "@ Override", "public   void   actionPerformed ( AnActionEvent   e )     {", "IdeFocusManager . findInstance (  )  . requestFocus ( myRegExp . getFocusTarget (  )  ,    true )  ;", "}", "}  . registerCustomShortcutSet ( CustomShortcutSet . fromString (  \" shift   TAB \"  )  ,    mySampleText )  ;", "updater    =    new   Alarm ( ThreadToUse . POOLED _ THREAD ,    disposable )  ;", "DocumentListener   documentListener    =    new   DocumentListener (  )     {", "@ Override", "public   void   documentChanged ( DocumentEvent   e )     {", "update (  )  ;", "}", "}  ;", "myRegExp . addDocumentListener ( documentListener )  ;", "mySampleText . addDocumentListener ( documentListener )  ;", "update (  )  ;", "mySampleText . selectAll (  )  ;", "}", "public   void   update (  )     {", "final   TransactionId   transactionId    =    TransactionGuard . getInstance (  )  . getContextTransaction (  )  ;", "updater . cancelAllRequests (  )  ;", "if    (  !  ( updater . isDisposed (  )  )  )     {", "updater . addRequest (  (  )     -  >     {", "final   RegExpMatchResult   result    =    isMatchingText ( myRegexpFile ,    mySampleText . getText (  )  )  ;", "TransactionGuard . getInstance (  )  . submitTransaction ( myProject ,    transactionId ,     (  )     -  >    setBalloonState ( result )  )  ;", "}  ,     2  0  0  )  ;", "}", "}", "@ Override", "public   void   removeNotify (  )     {", "super . removeNotify (  )  ;", "Disposer . dispose ( disposable )  ;", "PropertiesComponent . getInstance ( myProject )  . setValue (  . LAST _ EDITED _ REGEXP ,    mySampleText . getText (  )  )  ;", "}", "}  ;", "myRootPanel . setBorder ( Borders . empty ( DEFAULT _ VGAP ,    DEFAULT _ HGAP )  )  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "return   mySampleText ;", "}", "METHOD_END"], "methodName": ["getPreferredFocusedComponent"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "return   myRootPanel ;", "}", "METHOD_END"], "methodName": ["getRootPanel"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "final   String   regExp    =    regexpFile . getText (  )  ;", "final   Language   regexpFileLanguage    =    regexpFile . getLanguage (  )  ;", "final   RegExpMatcherProvider   matcherProvider    =    RegExpMatcherProvider . EP . forLanguage ( regexpFileLanguage )  ;", "if    ( matcherProvider    !  =    null )     {", "final   RegExpMatchResult   result    =    ReadAction . compute (  (  )     -  >     {", "final   PsiLanguageInjectionHost   host    =    InjectedLanguageUtil . findInjectionHost ( regexpFile )  ;", "if    ( host    !  =    null )     {", "return   matcherProvider . matches ( regExp ,    regexpFile ,    host ,    sampleText ,     1  0  0  0 L )  ;", "}", "return   null ;", "}  )  ;", "if    ( result    !  =    null )     {", "return   result ;", "}", "}", "final   Integer   patternFlags    =    ReadAction . compute (  (  )     -  >     {", "final   PsiLanguageInjectionHost   host    =    InjectedLanguageUtil . findInjectionHost ( regexpFile )  ;", "int   flags    =     0  ;", "if    ( host    !  =    null )     {", "for    ( RegExpModifierProvider   provider    :    RegExpModifierProvider . EP . allForLanguage ( host . getLanguage (  )  )  )     {", "flags    =    provider . getFlags ( host ,    regexpFile )  ;", "if    ( flags    >     0  )", "break ;", "}", "}", "return   flags ;", "}  )  ;", "try    {", "return   Pattern . compile ( regExp ,    patternFlags )  . matcher ( StringUtil . newBombedCharSequence ( sampleText ,     1  0  0  0  )  )  . matches (  )     ?    RegExpMatchResult . MATCHES    :    RegExpMatchResult . NO _ MATCH ;", "}    catch    ( ProcessCanceledException   pc )     {", "return   RegExpMatchResult . TIMEOUT ;", "}    catch    ( Exception   ignore )     {", "}", "return   RegExpMatchResult . BAD _ REGEXP ;", "}", "METHOD_END"], "methodName": ["isMatchingText"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "final   RegExpMatchResult   result    =    CheckRegExpForm . isMatchingText ( regexpFile ,    sampleText )  ;", "return    ( result    !  =    null )     &  &     ( result    =  =     ( RegExpMatchResult . MATCHES )  )  ;", "}", "METHOD_END"], "methodName": ["isMatchingTextTest"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "mySampleText . setBackground (  ( result    =  =     ( RegExpMatchResult . MATCHES )     ?    CheckRegExpForm . BACKGROUND _ COLOR _ MATCH    :    CheckRegExpForm . BACKGROUND _ COLOR _ NOMATCH )  )  ;", "switch    ( result )     {", "case   MATCHES    :", "myMessage . setText (  \" Matches !  \"  )  ;", "break ;", "case   NO _ MATCH    :", "myMessage . setText (  \" No   match \"  )  ;", "break ;", "case   TIMEOUT    :", "myMessage . setText (  \" Pattern   is   too   complex \"  )  ;", "break ;", "case   BAD _ REGEXP    :", "myMessage . setText (  \" Bad   pattern \"  )  ;", "break ;", "}", "myRootPanel . revalidate (  )  ;", "Balloon   balloon    =    JBPopupFactory . getInstance (  )  . getParentBalloonFor ( myRootPanel )  ;", "if    (  ( balloon    !  =    null )     &  &     (  !  ( balloon . isDisposed (  )  )  )  )", "balloon . revalidate (  )  ;", "}", "METHOD_END"], "methodName": ["setBalloonState"], "fileName": "org.intellij.lang.regexp.intention.CheckRegExpForm"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( posixBracketExpression )  ;", "}", "METHOD_END"], "methodName": ["visitPosixBracketExpression"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( backref )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpBackref"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( boundary )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpBoundary"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( branch )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpBranch"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( ch )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpChar"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( range )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpCharRange"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( expClass )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpClass"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( closure )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpClosure"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitElement ( element )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpElement"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( group )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpGroup"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( intersection )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpIntersection"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpChar ( namedCharacter )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpNamedCharacter"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( groupRef )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpNamedGroupRef"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( number )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpNumber"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( options )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpOptions"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( pattern )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpPattern"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( property )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpProperty"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( condRef )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpPyCondRef"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( quantifier )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpQuantifier"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( options )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpSetOptions"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitRegExpElement ( simpleClass )  ;", "}", "METHOD_END"], "methodName": ["visitSimpleClass"], "fileName": "org.intellij.lang.regexp.psi.RegExpElementVisitor"}, {"methodBody": ["METHOD_START", "{", "element . acceptChildren ( this )  ;", "}", "METHOD_END"], "methodName": ["visitRegExpElement"], "fileName": "org.intellij.lang.regexp.psi.RegExpRecursiveElementVisitor"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpBackref ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBackrefImpl"}, {"methodBody": ["METHOD_START", "{", "final   String   s    =    getUnescapedText (  )  ;", "assert    ( s . charAt (  0  )  )     =  =     '  \\  \\  '  ;", "return   Iger . parseInt ( s . substring (  1  )  )  ;", "}", "METHOD_END"], "methodName": ["getIndex"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBackrefImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   PsiReference (  )     {", "@ NotNull", "public   PsiElement   getElement (  )     {", "return    . this ;", "}", "@ NotNull", "public   TextRange   getRangeInElement (  )     {", "return   TextRange . from (  0  ,    getElement (  )  . getTextLength (  )  )  ;", "}", "@ NotNull", "public   String   getCanonicalText (  )     {", "return   getElement (  )  . getText (  )  ;", "}", "public   PsiElement   handleElementRename ( String   newElementName )    throws   IncorrectOperationException    {", "throw   new   IncorrectOperationException (  )  ;", "}", "public   PsiElement   bindToElement (  @ NotNull", "PsiElement   element )    throws   IncorrectOperationException    {", "throw   new   IncorrectOperationException (  )  ;", "}", "public   boolean   isReferenceTo ( PsiElement   element )     {", "return   Comparing . equal ( element ,    resolve (  )  )  ;", "}", "public   boolean   isSoft (  )     {", "return   false ;", "}", "public   PsiElement   resolve (  )     {", "return    . this . resolve (  )  ;", "}", "@ NotNull", "public   Object [  ]    getVariants (  )     {", "return   ArrayUtil . EMPTY _ OBJECT _ ARRAY ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBackrefImpl"}, {"methodBody": ["METHOD_START", "{", "final   int   index    =    getIndex (  )  ;", "final   PsiElementProcessor . FindFilteredElement < RegExpElement >    processor    =    new   PsiElementProcessor . FindFilteredElement <  >  ( new   PsiElementFilter (  )     {", "int   groupCount ;", "public   boolean   isAccepted ( PsiElement   element )     {", "if    ( element   instanceof   RegExpGroup )     {", "if    (  (  (  ( RegExpGroup )     ( element )  )  . isCapturing (  )  )     &  &     (  (  +  +  ( groupCount )  )     =  =    index )  )     {", "return   true ;", "}", "}", "return   element    =  =     (  . this )  ;", "}", "}  )  ;", "PsiTreeUtil . processElements ( getContainingFile (  )  ,    processor )  ;", "if    (  ( processor . getFoundElement (  )  )    instanceof   RegExpGroup )     {", "return    (  ( RegExpGroup )     ( processor . getFoundElement (  )  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["resolve"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBackrefImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpBoundary ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBoundaryImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   child    =    getNode (  )  . getFirstChildNode (  )  ;", "assert   child    !  =    null ;", "final   IElementType   type    =    child . getElementType (  )  ;", "if    ( type    =  =     ( RegExpTT . CARET )  )     {", "return    . Type . LINE _ START ;", "} else", "if    ( type    =  =     ( RegExpTT . DOLLAR )  )     {", "return    . Type . LINE _ END ;", "} else", "if    ( type    =  =     ( RegExpTT . BOUNDARY )  )     {", "final   String   s    =    getUnescapedText (  )  ;", "if    ( s . equals (  \"  \\  \\ b \"  )  )     {", "return    . Type . WORD ;", "} else", "if    ( s . equals (  \"  \\  \\ b { g }  \"  )  )     {", "return    . Type . UNICODE _ EXTENDED _ GRAPHEME ;", "} else", "if    ( s . equals (  \"  \\  \\ B \"  )  )     {", "return    . Type . NON _ WORD ;", "} else", "if    ( s . equals (  \"  \\  \\ A \"  )  )     {", "return    . Type . BEGIN ;", "} else", "if    ( s . equals (  \"  \\  \\ Z \"  )  )     {", "return    . Type . END _ NO _ LINE _ TERM ;", "} else", "if    ( s . equals (  \"  \\  \\ z \"  )  )     {", "return    . Type . END ;", "} else", "if    ( s . equals (  \"  \\  \\ G \"  )  )     {", "return    . Type . PREVIOUS _ MATCH ;", "}", "}", "assert   false ;", "return   null ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBoundaryImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpBranch ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBranchImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode [  ]    nodes    =    getNode (  )  . getChildren ( RegExpElementTypes . ATOMS )  ;", "final   RegExpAtom [  ]    atoms    =    new   RegExpAtom [ nodes . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( atoms . length )  ;    i +  +  )     {", "atoms [ i ]     =     (  ( RegExpAtom )     ( nodes [ i ]  . getPsi (  )  )  )  ;", "}", "return   atoms ;", "}", "METHOD_END"], "methodName": ["getAtoms"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpBranchImpl"}, {"methodBody": ["METHOD_START", "{", "int   sum    =     0  ;", "int   i    =    offset ;", "for    (  ;    i    <     ( s . length (  )  )  ;    i +  +  )     {", "final   int   digit    =    acter . digit ( s . charAt ( i )  ,    radix )  ;", "if    ( digit    <     0  )     {", "break ;", "}", "sum    =     ( sum    *    radix )     +    digit ;", "if    ( sum    >     ( acter . MAX _ CODE _ POINT )  )     {", "return    -  1  ;", "}", "}", "if    (  ( i    -    offset )     <  =     0  )", "return    -  1  ;", "return   sum ;", "}", "METHOD_END"], "methodName": ["parseNumber"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpCharImpl"}, {"methodBody": ["METHOD_START", "{", "final   int   length    =    s . length (  )  ;", "assert   length    >     0  ;", "boolean   escaped    =    false ;", "for    ( int   idx    =     0  ;    idx    <    length ;    idx +  +  )     {", "final   char   ch    =    s . charAt ( idx )  ;", "if    (  ! escaped )     {", "if    ( ch    =  =     '  \\  \\  '  )     {", "escaped    =    true ;", "} else    {", "return   ch ;", "}", "} else    {", "switch    ( ch )     {", "case    ' n '     :", "return    '  \\ n '  ;", "case    ' r '     :", "return    '  \\ r '  ;", "case    ' t '     :", "return    '  \\ t '  ;", "case    ' a '     :", "return    '  \\ u 0  0  0  7  '  ;", "case    ' e '     :", "return    '  \\ u 0  0  1 b '  ;", "case    ' f '     :", "return    '  \\ f '  ;", "case    ' b '     :", "return    '  \\ b '  ;", "case    ' c '     :", "return    (  ( char )     ( ch    ^     6  4  )  )  ;", "case    ' N '     :", "if    (  (  ( length    <     ( idx    +     3  )  )     |  |     (  ( s . charAt (  ( idx    +     1  )  )  )     !  =     '  {  '  )  )     |  |     (  ( s . charAt (  ( length    -     1  )  )  )     !  =     '  }  '  )  )     {", "return    -  1  ;", "}", "final   int   codePoint    =    UnicodeCharacterNames . getCodePoint ( s . substring (  ( idx    +     2  )  ,     ( length    -     1  )  )  )  ;", "if    ( codePoint    =  =     (  -  1  )  )     {", "return    -  1  ;", "}", "return   codePoint ;", "case    ' x '     :", "if    ( length    <  =     ( idx    +     1  )  )", "return    -  1  ;", "if    (  ( s . charAt (  ( idx    +     1  )  )  )     =  =     '  {  '  )     {", "final   char   c    =    s . charAt (  ( length    -     1  )  )  ;", "return   c    !  =     '  }  '     ?     -  1     :     . parseNumber ( s ,     ( idx    +     2  )  ,     1  6  )  ;", "}", "if    ( length    =  =     3  )     {", "return    . parseNumber ( s ,     ( idx    +     1  )  ,     1  6  )  ;", "}", "return   length    =  =     4     ?     . parseNumber ( s ,     ( idx    +     1  )  ,     1  6  )     :     -  1  ;", "case    ' u '     :", "if    ( length    <  =     ( idx    +     1  )  )", "return    -  1  ;", "if    (  ( length    >     ( idx    +     1  )  )     &  &     (  ( s . charAt (  ( idx    +     1  )  )  )     =  =     '  {  '  )  )     {", "final   char   c    =    s . charAt (  ( length    -     1  )  )  ;", "return   c    !  =     '  }  '     ?     -  1     :     . parseNumber ( s ,     ( idx    +     2  )  ,     1  6  )  ;", "}", "if    ( length    !  =     6  )     {", "return   ch ;", "}", "return    . parseNumber ( s ,     ( idx    +     1  )  ,     1  6  )  ;", "case    '  0  '     :", "case    '  1  '     :", "case    '  2  '     :", "case    '  3  '     :", "case    '  4  '     :", "case    '  5  '     :", "case    '  6  '     :", "case    '  7  '     :", "return    . parseNumber ( s ,    idx ,     8  )  ;", "default    :", "return   ch ;", "}", "}", "}", "return    -  1  ;", "}", "METHOD_END"], "methodName": ["unescapeChar"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpCharImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpClosure ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpClosureImpl"}, {"methodBody": ["METHOD_START", "{", "final   RegExpAtom   atom    =    PsiTreeUtil . getChildOfType ( this ,    RegExpAtom . class )  ;", "assert   atom    !  =    null ;", "return   atom ;", "}", "METHOD_END"], "methodName": ["getAtom"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpClosureImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    getNode (  )  . findChildByType ( RegExpElementTypes . QUANTIFIER )  ;", "assert   node    !  =    null ;", "return    (  ( RegExpQuantifier )     ( node . getPsi (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getQuantifier"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpClosureImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( visitor   instanceof   RegExpElementVisitor )     {", "accept (  (  ( RegExpElementVisitor )     ( visitor )  )  )  ;", "} else    {", "super . accept ( visitor )  ;", "}", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpElement ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "getNode (  )  . getTreeParent (  )  . removeChild ( getNode (  )  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "return   RegExpLanguage . INSTANCE ;", "}", "METHOD_END"], "methodName": ["getLanguage"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( InjectedLanguageUtil . isInInjectedLanguagePrefixSuffix ( this )  )     {", "return   getText (  )  ;", "}", "return   InjectedLanguageManager . getInstance ( getProject (  )  )  . getUnescapedText ( this )  ;", "}", "METHOD_END"], "methodName": ["getUnescapedText"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( context    =  =    null )", "return   false ;", "ASTNode   astNode    =    context . getNode (  )  ;", "if    ( astNode    =  =    null )     {", "return   false ;", "}", "if    ( astNode   instanceof   Composite )     {", "ASTNode [  ]    children    =    astNode . getChildren ( null )  ;", "if    (  ( children . length )     !  =     1  )", "return   false ;", "astNode    =    children [  0  ]  ;", "}", "final   IType   elementType    =    astNode . getType (  )  ;", "final   ParserDefinition   parserDefinition    =    INSTANCE . forLanguage ( context . getLanguage (  )  )  ;", "return   parserDefinition . getStringLiterals (  )  . contains ( elementType )  ;", "}", "METHOD_END"], "methodName": ["isLiteralExpression"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node    =    psiElement . getNode (  )  ;", "assert   node    !  =    null ;", "getNode (  )  . getTreeParent (  )  . replaceChild ( getNode (  )  ,    node )  ;", "return   psiElement ;", "}", "METHOD_END"], "methodName": ["replace"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  (  ( getClass (  )  . getSimpleName (  )  )     +     \"  :     <  \"  )     +     ( getText (  )  )  )     +     \"  >  \"  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpElementImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpProperty ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "return   getNode (  )  . findChildByType ( RegExpTT . NAME )  ;", "}", "METHOD_END"], "methodName": ["getCategoryNode"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   lbrace    =    getNode (  )  . findChildByType ( RegExpTT . LBRACE )  ;", "if    ( lbrace    =  =    null )", "return   null ;", "return   new    . MyPsiReference (  )  ;", "}", "METHOD_END"], "methodName": ["getReference"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode   node 1     =    getNode (  )  . findChildByType ( RegExpTT . PROPERTY )  ;", "final   ASTNode   node 2     =    getNode (  )  . findChildByType ( RegExpTT . CARET )  ;", "return    (  ( node 1     !  =    null )     &  &     ( node 1  . textContains (  ' P '  )  )  )     ^     ( node 2     !  =    null )  ;", "}", "METHOD_END"], "methodName": ["isNegated"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpPropertyImpl"}, {"methodBody": ["METHOD_START", "{", "visitor . visitRegExpSetOptions ( this )  ;", "}", "METHOD_END"], "methodName": ["accept"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpSetOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode [  ]    nodes    =    getNode (  )  . getChildren ( TokenSet . create ( RegExpElementTypes . OPTIONS )  )  ;", "for    ( ASTNode   node    :    nodes )     {", "if    ( node . textContains (  '  -  '  )  )     {", "return    (  ( RegExp )     ( node . getPsi (  )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getOffOptions"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpSetOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "final   ASTNode [  ]    nodes    =    getNode (  )  . getChildren ( TokenSet . create ( RegExpElementTypes . OPTIONS )  )  ;", "for    ( ASTNode   node    :    nodes )     {", "if    (  !  ( node . textContains (  '  -  '  )  )  )     {", "return    (  ( RegExp )     ( node . getPsi (  )  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getOnOptions"], "fileName": "org.intellij.lang.regexp.psi.impl.RegExpSetOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   myTitle ;", "}", "METHOD_END"], "methodName": ["getTemplateDescription"], "fileName": "org.intellij.lang.regexp.surroundWith.GroupSurrounder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( elements . length )     =  =     1  )     |  |     (  ( PsiTreeUtil . findCommonParent ( elements )  )     =  =     ( elements [  0  ]  . getParent (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isApplicable"], "fileName": "org.intellij.lang.regexp.surroundWith.GroupSurrounder"}, {"methodBody": ["METHOD_START", "{", "while    ( context    !  =    null )     {", "if    ( RegExpElementImpl . isLiteralExpression ( context )  )     {", "return   true ;", "}", "context    =    context . getContext (  )  ;", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isInsideStringLiteral"], "fileName": "org.intellij.lang.regexp.surroundWith.GroupSurrounder"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myGroupStart )     +    s )     +     \"  )  \"  ;", "}", "METHOD_END"], "methodName": ["makeReplacement"], "fileName": "org.intellij.lang.regexp.surroundWith.GroupSurrounder"}, {"methodBody": ["METHOD_START", "{", "assert    (  ( elements . length )     =  =     1  )     |  |     (  ( PsiTreeUtil . findCommonParent ( elements )  )     =  =     ( elements [  0  ]  . getParent (  )  )  )  ;", "final   PsiElement   e    =    elements [  0  ]  ;", "final   ASTNode   node    =    e . getNode (  )  ;", "assert   node    !  =    null ;", "final   ASTNode   parent    =    node . getTreeParent (  )  ;", "final   StringBuilder   s    =    new   StringBuilder (  )  ;", "for    ( int   i    =     0  ;    i    <     ( elements . length )  ;    i +  +  )     {", "final   PsiElement   element    =    elements [ i ]  ;", "if    ( element   instanceof   RegExpElementImpl )     {", "s . append (  (  ( RegExpElementImpl )     ( element )  )  . getUnescapedText (  )  )  ;", "} else    {", "s . append ( element . getText (  )  )  ;", "}", "if    ( i    >     0  )     {", "final   ASTNode   child    =    element . getNode (  )  ;", "assert   child    !  =    null ;", "parent . removeChild ( child )  ;", "}", "}", "final   PsiFileFactory   factory    =    PsiFileFactory . getInstance ( project )  ;", "final   PsiFile   f    =    factory . createFileFromText (  \" dummy . regexp \"  ,    RegExpFileType . INSTANCE ,    makeReplacement ( s )  )  ;", "final   RegExpPattern   pattern    =    PsiTreeUtil . getChildOfType ( f ,    RegExpPattern . class )  ;", "assert   pattern    !  =    null ;", "final   RegExpAtom   element    =    pattern . getBranches (  )  [  0  ]  . getAtoms (  )  [  0  ]  ;", "if    (  . isInsideStringLiteral ( e )  )     {", "final   Document   doc    =    editor . getDocument (  )  ;", "PsiDocumentManager . getInstance ( project )  . doPostponedOperationsAndUnblockDocument ( doc )  ;", "final   TextRange   tr    =    e . getTextRange (  )  ;", "doc . replaceString ( tr . getStartOffset (  )  ,    tr . getEndOffset (  )  ,    StringUtil . escapeStringCharacters ( element . getText (  )  )  )  ;", "return   TextRange . from ( e . getTextRange (  )  . getEndOffset (  )  ,     0  )  ;", "} else    {", "final   PsiElement   n    =    e . replace ( element )  ;", "return   TextRange . from ( n . getTextRange (  )  . getEndOffset (  )  ,     0  )  ;", "}", "}", "METHOD_END"], "methodName": ["surroundElements"], "fileName": "org.intellij.lang.regexp.surroundWith.GroupSurrounder"}, {"methodBody": ["METHOD_START", "{", "T   element    =    PsiTreeUtil . findElementOfClassAtRange ( file ,    startOffset ,    endOffset ,    clazz )  ;", "if    (  ( element    =  =    null )     |  |     (  ( element . getTextRange (  )  . getEndOffset (  )  )     <    endOffset )  )", "return   null ;", "return   element ;", "}", "METHOD_END"], "methodName": ["findElementAtStrict"], "fileName": "org.intellij.lang.regexp.surroundWith.SimpleSurroundDescriptor"}, {"methodBody": ["METHOD_START", "{", "PsiElement   element 1     =    file . findElementAt ( startOffset )  ;", "PsiElement   element 2     =    file . findElementAt (  ( endOffset    -     1  )  )  ;", "if    ( element 1    instanceof   PsiWhiteSpace )     {", "startOffset    =    element 1  . getTextRange (  )  . getEndOffset (  )  ;", "}", "if    ( element 2    instanceof   PsiWhiteSpace )     {", "endOffset    =    element 2  . getTextRange (  )  . getStartOffset (  )  ;", "}", "RegExpElement   pattern    =     . findElementAtStrict ( file ,    startOffset ,    endOffset ,    RegExpPattern . class )  ;", "if    ( pattern    !  =    null )", "return   new   RegExpElement [  ]  {    pattern    }  ;", "RegExpElement   branch    =     . findElementAtStrict ( file ,    startOffset ,    endOffset ,    RegExpBranch . class )  ;", "if    ( branch    !  =    null )", "return   new   RegExpElement [  ]  {    branch    }  ;", "List < PsiElement >    atoms    =    new   ArrayList <  >  (  )  ;", "RegExpAtom   atom    =    PsiTreeUtil . findElementOfClassAtRange ( file ,    startOffset ,    endOffset ,    RegExpAtom . class )  ;", "for    (  ;    atom    !  =    null ;    atom    =    PsiTreeUtil . findElementOfClassAtRange ( file ,    startOffset ,    endOffset ,    RegExpAtom . class )  )     {", "atoms . add ( atom )  ;", "startOffset    =    atom . getTextRange (  )  . getEndOffset (  )  ;", "if    (  ( element 1     =    file . findElementAt ( startOffset )  )    instanceof   PsiWhiteSpace )     {", "startOffset    =    element 1  . getTextRange (  )  . getEndOffset (  )  ;", "atoms . add ( element 1  )  ;", "}", "}", "if    (  ( startOffset    =  =    endOffset )     &  &     (  ( atoms . size (  )  )     >     0  )  )     {", "PsiElement [  ]    elements    =    PsiUtilCore . toPsiElementArray ( atoms )  ;", "if    (  (  ( atoms . size (  )  )     =  =     1  )     |  |     (  ( PsiTreeUtil . findCommonParent ( elements )  )     =  =     ( elements [  0  ]  . getParent (  )  )  )  )     {", "return   elements ;", "}", "}", "return   PsiElement . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getElementsToSurround"], "fileName": "org.intellij.lang.regexp.surroundWith.SimpleSurroundDescriptor"}, {"methodBody": ["METHOD_START", "{", "return   SimpleSurroundDescriptor . SURROUNDERS ;", "}", "METHOD_END"], "methodName": ["getSurrounders"], "fileName": "org.intellij.lang.regexp.surroundWith.SimpleSurroundDescriptor"}, {"methodBody": ["METHOD_START", "{", "if    ( element   instanceof   RegExpChar )     {", "final   RegExpChar   regExpChar    =     (  ( RegExpChar )     ( element )  )  ;", "final   int   value    =    regExpChar . getValue (  )  ;", "if    (  ( value    !  =     (  -  1  )  )     &  &     (  !  ( seen . add ( value )  )  )  )     {", "myHolder . createWarningAnnotation ( regExpChar ,     (  (  \" Duplicate   character    '  \"     +     ( regExpChar . getText (  )  )  )     +     \"  '    inside   character   class \"  )  )  ;", "}", "} else", "if    ( element   instanceof   psi . RegExpSimpleClass )     {", "final   psi . RegExpSimpleClass   regExpSimpleClass    =     (  ( psi . RegExpSimpleClass )     ( element )  )  ;", "final   psi . RegExpSimpleClass . Kind   kind    =    regExpSimpleClass . getKind (  )  ;", "if    (  !  ( seen . add ( kind )  )  )     {", "myHolder . createWarningAnnotation ( regExpSimpleClass ,     (  (  \" Duplicate   predefined   character   class    '  \"     +     ( regExpSimpleClass . getText (  )  )  )     +     \"  '    inside   character   class \"  )  )  ;", "}", "} else", "if    ( element   instanceof   psi . RegExpClass )     {", "final   psi . RegExpClass   regExpClass    =     (  ( psi . RegExpClass )     ( element )  )  ;", "for    ( RegExpClassElement   classElement    :    regExpClass . getElements (  )  )     {", "checkForDuplicates ( classElement ,    seen )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkForDuplicates"], "fileName": "org.intellij.lang.regexp.validation.RegExpAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    (  ( fromCodePoint    =  =     (  -  1  )  )     |  |     ( toCodePoint    =  =     (  -  1  )  )  )     {", "return ;", "}", "int   errorStart    =    range . getTextOffset (  )  ;", "int   errorEnd    =    errorStart    +     ( range . getTextLength (  )  )  ;", "if    (  (  !  ( Character . isSupplementaryCodePoint ( fromCodePoint )  )  )     &  &     ( Character . isLowSurrogate (  (  ( char )     ( fromCodePoint )  )  )  )  )     {", "final   PsiElement   prevSibling    =    range . getPrevSibling (  )  ;", "if    ( prevSibling   instanceof   RegExpChar )     {", "final   int   prevSiblingValue    =     (  ( RegExpChar )     ( prevSibling )  )  . getValue (  )  ;", "if    (  (  !  ( Character . isSupplementaryCodePoint ( prevSiblingValue )  )  )     &  &     ( Character . isHighSurrogate (  (  ( char )     ( prevSiblingValue )  )  )  )  )     {", "fromCodePoint    =    Character . toCodePoint (  (  ( char )     ( prevSiblingValue )  )  ,     (  ( char )     ( fromCodePoint )  )  )  ;", "errorStart    -  =    prevSibling . getTextLength (  )  ;", "}", "}", "}", "if    (  (  !  ( Character . isSupplementaryCodePoint ( toCodePoint )  )  )     &  &     ( Character . isHighSurrogate (  (  ( char )     ( toCodePoint )  )  )  )  )     {", "final   PsiElement   nextSibling    =    range . getNextSibling (  )  ;", "if    ( nextSibling   instanceof   RegExpChar )     {", "final   int   nextSiblingValue    =     (  ( RegExpChar )     ( nextSibling )  )  . getValue (  )  ;", "if    (  (  !  ( Character . isSupplementaryCodePoint ( nextSiblingValue )  )  )     &  &     ( Character . isLowSurrogate (  (  ( char )     ( nextSiblingValue )  )  )  )  )     {", "toCodePoint    =    Character . toCodePoint (  (  ( char )     ( toCodePoint )  )  ,     (  ( char )     ( nextSiblingValue )  )  )  ;", "errorEnd    +  =    nextSibling . getTextLength (  )  ;", "}", "}", "}", "if    ( toCodePoint    <    fromCodePoint )     {", "myHolder . createErrorion ( new   TextRange ( errorStart ,    errorEnd )  ,     \" Illegal   character   range    ( to    <    from )  \"  )  ;", "} else", "if    ( toCodePoint    =  =    fromCodePoint )     {", "myHolder . createWarningion ( new   TextRange ( errorStart ,    errorEnd )  ,     \" Redundant   character   range \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["checkRange"], "fileName": "org.intellij.lang.regexp.validation.RegExpAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( options    =  =    null )     {", "return ;", "}", "final   String   text    =    options . getText (  )  ;", "final   int   start    =     ( skipMinus )     ?     1     :     0  ;", "for    ( int   i    =    start ,    length    =    text . length (  )  ;    i    <    length ;    i +  +  )     {", "final   int   c    =    text . codePointAt ( i )  ;", "if    (  (  !  ( Character . isBmpCodePoint ( c )  )  )     |  |     (  !  ( myLanguageHosts . supportsInlineOptionFlag (  (  ( char )     ( c )  )  ,    options )  )  )  )     {", "final   int   offset    =     ( options . getTextOffset (  )  )     +    i ;", "myHolder . createErrorion ( new   TextRange ( offset ,     ( offset    +     1  )  )  ,     \" Unknown   inline   option   flag \"  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["checkValidFlag"], "fileName": "org.intellij.lang.regexp.validation.RegExpAnnotator"}, {"methodBody": ["METHOD_START", "{", "for    ( RegExpBranch   branch    :    branches )     {", "if    (  ( branch . getAtoms (  )  . length )     >     0  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["isEmpty"], "fileName": "org.intellij.lang.regexp.validation.RegExpAnnotator"}, {"methodBody": ["METHOD_START", "{", "if    ( a    !  =    null )     {", "aisterFix ( action )  ;", "}", "}", "METHOD_END"], "methodName": ["registerFix"], "fileName": "org.intellij.lang.regexp.validation.RegExpAnnotator"}, {"methodBody": ["METHOD_START", "{", "return    \" Simplify   Quantifier \"  ;", "}", "METHOD_END"], "methodName": ["getFamilyName"], "fileName": "org.intellij.lang.regexp.validation.SimplifyQuantifierAction"}, {"methodBody": ["METHOD_START", "{", "return    ( myReplacement )     =  =    null    ?     \" Simplify \"     :     (  \" Replace   with    '  \"     +     ( myReplacement )  )     +     \"  '  \"  ;", "}", "METHOD_END"], "methodName": ["getText"], "fileName": "org.intellij.lang.regexp.validation.SimplifyQuantifierAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myReplacement )     =  =    null )     {", "m . delete (  )  ;", "} else    {", "final   PsiFileFactory   factory    =    PsiFileFactory . getInstance ( project )  ;", "final   ASTNode   modifier    =    m . getModifier (  )  ;", "final   PsiFile   f    =    factory . createFileFromText (  \" dummy . regexp \"  ,    RegExpFileType . INSTANCE ,     (  (  \" a \"     +     ( myReplacement )  )     +     ( modifier    !  =    null    ?    modifier . getText (  )     :     \"  \"  )  )  )  ;", "final   RegExpPattern   pattern    =    PsiTreeUtil . getChildOfType ( f ,    RegExpPattern . class )  ;", "assert   pattern    !  =    null ;", "final   RegExpClosure   closure    =     (  ( RegExpClosure )     ( pattern . getBranches (  )  [  0  ]  . getAtoms (  )  [  0  ]  )  )  ;", "m . replace ( closure . getQuantifier (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["invoke"], "fileName": "org.intellij.lang.regexp.validation.SimplifyQuantifierAction"}, {"methodBody": ["METHOD_START", "{", "return   myQuantifier . isValid (  )  ;", "}", "METHOD_END"], "methodName": ["isAvailable"], "fileName": "org.intellij.lang.regexp.validation.SimplifyQuantifierAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["startInWriteAction"], "fileName": "org.intellij.lang.regexp.validation.SimplifyQuantifierAction"}]