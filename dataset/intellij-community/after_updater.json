[{"methodBody": ["METHOD_START", "{", "int   type    =    patchInput . read (  )  ;", "if    ( type    =  =     (  . COMPRESSED )  )     {", "JBPatch . bspatch ( oldFileIn ,    toFileOut ,    patchInput )  ;", "} else", "if    ( type    =  =     (  . RAW )  )     {", "Utils . copyStream ( patchInput ,    toFileOut )  ;", "} else    {", "throw   new   IOException (  \" Corrupted   patch \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["applyDiff"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( toDir ,    mySource )  ;", "}", "METHOD_END"], "methodName": ["getSource"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "return   mySource ;", "}", "METHOD_END"], "methodName": ["getSourcePath"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "return   myIsMove ;", "}", "METHOD_END"], "methodName": ["isMove"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "Utils . delete ( dest )  ;", "Utils . copy ( from ,    dest )  ;", "}", "METHOD_END"], "methodName": ["replaceUpdated"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "try    ( BufferedInputStream   olderFileIn    =    new   BufferedInputStream ( Utils . newFileInputStream ( olderFile ,    myPatch . isNormalized (  )  )  )  ; BufferedInputStream   newerFileIn    =    new   BufferedInputStream ( new   FileInputStream ( newerFile )  )  )     {", "writeDiff ( olderFileIn ,    newerFileIn ,    patchOutput )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDiff"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  \" writing   diff \"  )  ;", "ByteArrayOutputStream   diffOutput    =    new   Utils . OpenByteArrayOutputStream (  )  ;", "byte [  ]    newerFileBuffer    =    JBDiff . bsdiff ( olderFileIn ,    newerFileIn ,    diffOutput )  ;", "diffOutput . close (  )  ;", "if    (  (  !  ( isCritical (  )  )  )     &  &     (  ( diffOutput . size (  )  )     <     ( newerFileBuffer . length )  )  )     {", "patchOutput . write (  . COMPRESSED )  ;", "diffOutput . writeTo ( patchOutput )  ;", "} else    {", "patchOutput . write (  . RAW )  ;", "Utils . writeBytes ( newerFileBuffer ,    newerFileBuffer . length ,    patchOutput )  ;", "}", "}", "METHOD_END"], "methodName": ["writeDiff"], "fileName": "com.intellij.updater.BaseUpdateAction"}, {"methodBody": ["METHOD_START", "{", "Bootstrap . log (  \" Cleaning   up .  .  .  \"  )  ;", "try    {", "Path   file    =    Files . createTempFile (  \"  \"  ,     \"  \"  )  ;", "try    ( Stream < Path >    listing    =    Files . list ( file . getParent (  )  )  )     {", "listing . forEach (  (    p )     -  >     {", "if    (  (  !  ( p . toFile (  )  . isDirectory (  )  )  )     &  &     ( p . toFile (  )  . getName (  )  . startsWith ( Bootstrap . IJ _ PLATFORM _ UPDATER )  )  )     {", "try    {", "Bootstrap . log (  (  \" Deleting    \"     +     ( p . toString (  )  )  )  )  ;", "Files . delete ( p )  ;", "}    catch    ( IOException   e )     {", "Bootstrap . log (  (  \" Can ' t   delete    \"     +     ( p . toString (  )  )  )  )  ;", "Bootstrap . log ( e )  ;", "}", "}", "}  )  ;", "}", "Files . delete ( file )  ;", "}    catch    ( IOException   e )     {", "Bootstrap . log ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["cleanUp"], "fileName": "com.intellij.updater.Bootstrap"}, {"methodBody": ["METHOD_START", "{", "return   System . getProperty (  \" os . name \"  )  . toLowerCase ( Locale . US )  . startsWith (  \" mac \"  )  ;", "}", "METHOD_END"], "methodName": ["isMac"], "fileName": "com.intellij.updater.Bootstrap"}, {"methodBody": ["METHOD_START", "{", "System . out . println ( msg )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "com.intellij.updater.Bootstrap"}, {"methodBody": ["METHOD_START", "{", "ex . printStackTrace ( System . err )  ;", "}", "METHOD_END"], "methodName": ["log"], "fileName": "com.intellij.updater.Bootstrap"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     1  )", "return ;", "String   path    =     (  ( args [  0  ]  . endsWith (  \"  \\  \\  \"  )  )     |  |     ( args [  0  ]  . endsWith (  \"  /  \"  )  )  )     ?    args [  0  ]     :     ( args [  0  ]  )     +     ( File . separator )  ;", "if    (  ( Bootstrap . isMac (  )  )     &  &     ( path . endsWith (  \"  . app /  \"  )  )  )     {", "File   file    =    new   File (  ( path    +     \" Contents \"  )  )  ;", "if    (  ( file . exists (  )  )     &  &     ( file . isDirectory (  )  )  )     {", "path    +  =     \" Contents /  \"  ;", "}", "}", "Bootstrap . cleanUp (  )  ;", "ClassLoader   cl    =    Bootstrap . class . getClassLoader (  )  ;", "URL   dependencies    =    cl . getResource (  \" dependencies . txt \"  )  ;", "if    ( dependencies    =  =    null )     {", "Bootstrap . log (  \" missing   dependencies   file \"  )  ;", "return ;", "}", "List < URL >    urls    =    new   ArrayList <  >  (  )  ;", "List < File >    files    =    new   ArrayList <  >  (  )  ;", "urls . add (  (  ( JarURLConnection )     ( dependencies . openConnection (  )  )  )  . getJarFileURL (  )  )  ;", "try    ( BufferedReader   br    =    new   BufferedReader ( new   InputStreamReader ( dependencies . openStream (  )  )  )  )     {", "String   line ;", "while    (  ( line    =    br . readLine (  )  )     !  =    null )     {", "File   file    =    new   File (  ( path    +    line )  )  ;", "Path   tmp    =    Files . createTempFile (  (  ( Bootstrap . IJ _ PLATFORM _ UPDATER )     +     ( file . getName (  )  )  )  ,     \"  \"  )  ;", "try    ( OutputStream   targetStream    =    Files . newOutputStream ( tmp )  )     {", "Files . copy ( file . toPath (  )  ,    targetStream )  ;", "}", "urls . add ( tmp . toFile (  )  . toURI (  )  . toURL (  )  )  ;", "files . add ( tmp . toFile (  )  )  ;", "}", "}", "Runtime . getRuntime (  )  . addShutdownHook ( new   Thread (  (  )     -  >     {", "Bootstrap . log ( System . getProperty (  \" os . name \"  )  )  ;", "try    {", "for    ( File   file    :    files )     {", "Bootstrap . log (  (  (  (  \" Deleting    \"     +     ( file . getName (  )  )  )     +     \"     -     \"  )     +     ( file . delete (  )     ?     \" OK \"     :     \" FAIL \"  )  )  )  ;", "}", "}    catch    ( Exception   e )     {", "Bootstrap . log ( e )  ;", "}", "}  )  )  ;", "try    ( URLClassLoader   loader    =    new   URLClassLoader ( urls . toArray ( new   URL [  0  ]  )  ,    null )  )     {", "Class <  ?  >    runner    =    loader . loadClass (  \" Runner \"  )  ;", "Method   main    =    runner . getMethod (  \" main \"  ,    String [  ]  . class )  ;", "List < String >    runnerArgs    =    new   ArrayList <  >  (  )  ;", "runnerArgs . add (  \" apply \"  )  ;", "runnerArgs . add ( args [  0  ]  )  ;", "runnerArgs . add (  \"  -  - toolbox - ui \"  )  ;", "if    ( Boolean . getBoolean ( Bootstrap . NO _ BACKUP _ PROPERTY )  )     {", "runnerArgs . add (  \"  -  - no - backup \"  )  ;", "}", "main . invoke ( null ,     (  ( Object )     ( runnerArgs . toArray ( new   String [  0  ]  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.intellij.updater.Bootstrap"}, {"methodBody": ["METHOD_START", "{", "Utils . delete ( toFile )  ;", "}", "METHOD_END"], "methodName": ["doRevert"], "fileName": "com.intellij.updater.CreateAction"}, {"methodBody": ["METHOD_START", "{", "if    ( file . exists (  )  )     {", "Uls . delete ( file )  ;", "return ;", "}", "while    (  ( file    !  =    null )     &  &     (  !  ( file . exists (  )  )  )  )     {", "file    =    file . getParentFile (  )  ;", "}", "if    (  ( file    !  =    null )     &  &     (  !  ( file . isDirectory (  )  )  )  )     {", "Uls . delete ( file )  ;", "}", "}", "METHOD_END"], "methodName": ["prepareToWriteFile"], "fileName": "com.intellij.updater.CreateAction"}, {"methodBody": ["METHOD_START", "{", "int   length    =    in . read (  )  ;", "if    ( length    <  =     0  )", "throw   new   IOExcep (  \" Stream   format   error \"  )  ;", "byte [  ]    bytes    =    Utils . readBytes ( in ,    length )  ;", "return   new   String ( bytes ,    StandardCharsets . UTF _  8  )  ;", "}", "METHOD_END"], "methodName": ["readLinkInfo"], "fileName": "com.intellij.updater.CreateAction"}, {"methodBody": ["METHOD_START", "{", "String   target    =    Utils . readLink ( file )  ;", "if    ( target . isEmpty (  )  )", "throw   new   IOExcep (  (  \" Invalid   link :     \"     +    file )  )  ;", "byte [  ]    bytes    =    target . getBytes ( StandardCharsets . UTF _  8  )  ;", "out . write ( bytes . length )  ;", "out . write ( bytes )  ;", "}", "METHOD_END"], "methodName": ["writeLinkInfo"], "fileName": "com.intellij.updater.CreateAction"}, {"methodBody": ["METHOD_START", "{", "return   DiffCalculator . calculate ( oldChecksums ,    newChecksums ,    Collections . emptyList (  )  ,    Collections . emptyList (  )  ,    false )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "DiffCalculator . Result   result    =    new   DiffCalculator . Result (  )  ;", "result . commonFiles    =    DiffCalculator . collect ( oldChecksums ,    newChecksums ,    critical ,    true )  ;", "result . filesToDelete    =    DiffCalculator . withAllRemoved ( oldChecksums ,    newChecksums )  ;", "Map < String ,    Long >    toUpdate    =    DiffCalculator . collect ( oldChecksums ,    newChecksums ,    critical ,    false )  ;", "Map < String ,    Long >    toCreate    =    DiffCalculator . withAllRemoved ( newChecksums ,    oldChecksums )  ;", "result . filesToCreate    =     ( lookForMoved )     ?    new   LinkedHashMap <  >  (  )     :    toCreate ;", "result . filesToUpdate    =    new   LinkedHashMap <  >  (  )  ;", "for    ( Map . Entry < String ,    Long >    update    :    toUpdate . entrySet (  )  )     {", "if    ( Digester . isSymlink ( update . getValue (  )  )  )     {", "result . filesToDelete . put ( update . getKey (  )  ,    update . getValue (  )  )  ;", "result . filesToCreate . put ( update . getKey (  )  ,    Digester . INVALID )  ;", "} else    {", "result . filesToUpdate . put ( update . getKey (  )  ,    new   DiffCalculator . Update ( update . getKey (  )  ,    update . getValue (  )  ,    false )  )  ;", "}", "}", "if    ( lookForMoved )     {", "Map < Long ,    List < String >  >    byContent    =    DiffCalculator . groupFilesByContent ( result . filesToDelete )  ;", "Map < String ,    List < String >  >    byName    =    DiffCalculator . groupFilesByName ( result . filesToDelete )  ;", "for    ( Map . Entry < String ,    Long >    create    :    toCreate . entrySet (  )  )     {", "if    ( Digester . isFile ( create . getValue (  )  )  )     {", "List < String >    sameContent    =    byContent . get ( create . getValue (  )  )  ;", "String   source    =    DiffCalculator . findBestCandidateForMove ( sameContent ,    create . getKey (  )  ,    optional )  ;", "boolean   move    =    true ;", "if    ( source    =  =    null )     {", "List < String >    sameName    =    byName . get ( new   File ( create . getKey (  )  )  . getName (  )  )  ;", "source    =    DiffCalculator . findBestCandidateForMove ( sameName ,    create . getKey (  )  ,    optional )  ;", "move    =    false ;", "}", "if    (  ( source    !  =    null )     &  &     (  !  ( critical . contains ( source )  )  )  )     {", "result . filesToUpdate . put ( create . getKey (  )  ,    new   DiffCalculator . Update ( source ,    result . filesToDelete . get ( source )  ,    move )  )  ;", "continue ;", "}", "}", "result . filesToCreate . put ( create . getKey (  )  ,    create . getValue (  )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Long >    result    =    new   LinkedHashMap <  >  (  )  ;", "for    ( Map . Entry < String ,    Long >    each    :    newentrySet (  )  )     {", "String   file    =    each . getKey (  )  ;", "Long   oldChecksum    =    oldget ( file )  ;", "Long   newChecksum    =    newget ( file )  ;", "if    (  (  ( oldChecksum    !  =    null )     &  &     ( newChecksum    !  =    null )  )     &  &     (  (  ( oldChecksum . equals ( newChecksum )  )     &  &     (  !  ( critical . contains ( file )  )  )  )     =  =    equal )  )     {", "result . put ( file ,    oldChecksum )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["collect"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "int   matches    =     0  ;", "for    ( int   i    =     0  ;     ( i    <     ( dirs . length )  )     &  &     ( i    <     ( others . length )  )  ;    i +  +  )     {", "if    ( dirs [ i ]  . equals ( others [ i ]  )  )     {", "matches    =    i    +     1  ;", "} else    {", "break ;", "}", "}", "return   matches ;", "}", "METHOD_END"], "methodName": ["compareRootFolders"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "if    ( paths    =  =    null )", "return   null ;", "boolean   mandatory    =     !  ( optional . contains ( path )  )  ;", "String   best    =     \"  \"  ;", "String [  ]    dirs    =    path . split (  \"  /  \"  )  ;", "int   common    =     0  ;", "for    ( String   other    :    paths )     {", "if    ( mandatory    &  &     ( optional . contains ( other )  )  )", "continue ;", "String [  ]    others    =    other . split (  \"  /  \"  )  ;", "for    ( int   i    =     0  ;     ( i    <     ( dirs . length )  )     &  &     ( i    <     ( others . length )  )  ;    i +  +  )     {", "if    ( dirs [  (  (  ( dirs . length )     -    i )     -     1  )  ]  . equals ( others [  (  (  ( others . length )     -    i )     -     1  )  ]  )  )     {", "if    (  ( i    +     1  )     >    common )     {", "best    =    other ;", "common    =    i    +     1  ;", "} else", "if    (  (  ( i    +     1  )     =  =    common )     &  &     (  (  . compareRootFolders ( dirs ,    best . split (  \"  /  \"  )  )  )     <     (  . compareRootFolders ( dirs ,    other . split (  \"  /  \"  )  )  )  )  )     {", "best    =    other ;", "}", "} else    {", "break ;", "}", "}", "}", "return    !  ( best . isEmpty (  )  )     ?    best    :    null ;", "}", "METHOD_END"], "methodName": ["findBestCandidateForMove"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "Map < Long ,    List < String >  >    result    =    new   HashMap <  >  (  )  ;", "for    ( Map . Entry < String ,    Long >    entry    :    map . entrySet (  )  )     {", "String   path    =    entry . getKey (  )  ;", "if    (  !  ( path . endsWith (  \"  /  \"  )  )  )     {", "Long   hash    =    entry . getValue (  )  ;", "List < String >    paths    =    result . get ( hash )  ;", "if    ( paths    =  =    null )", "result . put ( hash ,     ( paths    =    new   LinkedList <  >  (  )  )  )  ;", "paths . add ( path )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["groupFilesByContent"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    List < String >  >    result    =    new   HashMap <  >  (  )  ;", "for    ( String   path    :    toDelete . keySet (  )  )     {", "if    (  !  ( path . endsWith (  \"  /  \"  )  )  )     {", "String   name    =    new   File ( path )  . getName (  )  ;", "List < String >    paths    =    result . get ( name )  ;", "if    ( paths    =  =    null )", "result . put ( name ,     ( paths    =    new   LinkedList <  >  (  )  )  )  ;", "paths . add ( path )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["groupFilesByName"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Long >    result    =    new   LinkedHashMap <  >  ( from )  ;", "for    ( String   each    :    toRemove . keySet (  )  )     {", "result . remove ( each )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["withAllRemoved"], "fileName": "com.intellij.updater.DiffCalculator"}, {"methodBody": ["METHOD_START", "{", "Path   path    =    file . toPath (  )  ;", "BasicFileAttributes   attrs    =    Files . readAttributes ( path ,    BasicFileAttributes . class ,    LinkOption . NOFOLLOW _ LINKS )  ;", "if    ( attrs . isSymbolicLink (  )  )     {", "Path   target    =    Files . readSymbolicLink ( path )  ;", "if    ( target . isAbsolute (  )  )", "throw   new   IOException (  (  (  (  \" Absolute   link :     \"     +    file )     +     \"     -  >     \"  )     +    target )  )  ;", "return    (  . digestStream ( new   ByteArrayInputStream ( target . toString (  )  . getBytes ( StandardCharsets . UTF _  8  )  )  )  )     |     (  . LINK _ MASK )  ;", "}", "if    ( attrs . isDirectory (  )  )", "return    . DIRECTORY ;", "try    ( InputStream   in    =    new   BufferedInputStream ( Utils . newFileInputStream ( file ,    normalize )  )  )     {", "return    . digestStream ( in )  ;", "}", "}", "METHOD_END"], "methodName": ["digestRegularFile"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", ". doDigestStream ( in ,    crc )  ;", "return   crc . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["digestStream"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "ZipFile   zipFile ;", "try    {", "zipFile    =    new   ZipFile ( file )  ;", "}    catch    ( ZipException   e )     {", "return    . digestRegularFile ( file ,    false )  ;", "}", "try    {", "List < ZipEntry >    sorted    =    new   ArrayList <  >  (  )  ;", "Enumeration <  ?    extends   ZipEntry >    temp    =    zipFile . entries (  )  ;", "while    ( temp . hasMoreElements (  )  )     {", "ZipEntry   each    =    temp . nextElement (  )  ;", "if    (  !  ( each . isDirectory (  )  )  )     {", "sorted . add ( each )  ;", "}", "}", "Collections . sort ( sorted ,    Comparator . comparing ( ZipEntry :  : getName )  )  ;", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", "for    ( ZipEntry   each    :    sorted )     {", "try    ( InputStream   in    =    zipFile . getInputStream ( each )  )     {", ". doDigestStream ( in ,    crc )  ;", "}", "}", "return   crc . getValue (  )  ;", "}    finally    {", "zipFile . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["digestZipFile"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    BUFFER    =    new   byte [  8  1  9  2  ]  ;", "int   size ;", "while    (  ( size    =    in . read ( BUFFER )  )     !  =     (  -  1  )  )     {", "crc ( BUFFER ,     0  ,    size )  ;", "}", "}", "METHOD_END"], "methodName": ["doDigestStream"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "return    ( digest    &     ( Digester . FLAG _ MASK )  )     =  =     0  ;", "}", "METHOD_END"], "methodName": ["isFile"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "return    ( digest    &     ( Digester . LINK _ MASK )  )     =  =     ( Digester . LINK _ MASK )  ;", "}", "METHOD_END"], "methodName": ["isSymlink"], "fileName": "com.intellij.updater.Digester"}, {"methodBody": ["METHOD_START", "{", "File   binDir    =    new   File ( dataDir ,     \" bin \"  )  ;", "File   libDir    =    new   File ( dataDir ,     \" lib \"  )  ;", "assertEquals (  . DIRECTORY ,     . digestRegularFile ( binDir ,    false )  )  ;", "assertEquals (  . DIRECTORY ,     . digestRegularFile ( libDir ,    true )  )  ;", "assertEquals ( CHECKSUMS . README _ TXT ,     . digestRegularFile ( new   File ( dataDir ,     \" Readme . txt \"  )  ,    false )  )  ;", "assertEquals ( CHECKSUMS . BOOTSTRAP _ JAR _ BIN ,     . digestRegularFile ( new   File ( libDir ,     \" bootstrap . jar \"  )  ,    false )  )  ;", "assertEquals ( CHECKSUMS . ANNOTATIONS _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" annotations . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . ANNOTATIONS _ CHANGED _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" annotations _ changed . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOT _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" boot . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOT 2  _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" boot 2  . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOT 2  _ CHANGED _ WITH _ UNCHANGED _ CONTENT _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" boot 2  _ changed _ with _ unchanged _ content . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOT _ WITH _ DIRECTORY _ BECOMES _ FILE _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" boot _ with _ directory _ becomes _ file . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOTSTRAP _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" bootstrap . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOTSTRAP _ DELETED _ JAR ,     . digestRegularFile ( new   File ( libDir ,     \" bootstrap _ deleted . jar \"  )  ,    true )  )  ;", "assertEquals ( CHECKSUMS . BOOTSTRAP _ JAR ,     . digestZipFile ( new   File ( libDir ,     \" bootstrap . jar \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["testBasics"], "fileName": "com.intellij.updater.DigesterTest"}, {"methodBody": ["METHOD_START", "{", "assertTrue ( Digester . isFile ( CHECKSUMS . README _ TXT )  )  ;", "assertTrue ( Digester . isFile ( CHECKSUMS . ANNOTATIONS _ JAR )  )  ;", "assertFalse ( Digester . isFile ( Digester . INVALID )  )  ;", "assertFalse ( Digester . isFile ( Digester . DIRECTORY )  )  ;", "assertTrue ( Digester . isSymlink ( CHECKSUMS . LINK _ TO _ README _ TXT )  )  ;", "assertFalse ( Digester . isSymlink ( CHECKSUMS . README _ TXT )  )  ;", "assertFalse ( Digester . isSymlink ( Digester . INVALID )  )  ;", "assertFalse ( Digester . isSymlink ( Digester . DIRECTORY )  )  ;", "}", "METHOD_END"], "methodName": ["testHelpers"], "fileName": "com.intellij.updater.DigesterTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "File   simpleLink    =    getTempFile (  \" Readme . simple . link \"  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    simpleLink )  ;", "File   relativeLink    =    getTempFile (  \" Readme . relative . link \"  )  ;", "Utils . createLink (  \"  .  / Readme . txt \"  ,    relativeLink )  ;", "File   absoluteLink    =    getTempFile (  \" Readme . absolute . link \"  )  ;", "Utils . createLink (  (  ( dataDir . getPath (  )  )     +     \"  / Readme . txt \"  )  ,    absoluteLink )  ;", "assertEquals ( CHECKSUMS . LINK _ TO _ README _ TXT ,     . digestRegularFile ( simpleLink ,    false )  )  ;", "assertEquals ( CHECKSUMS . LINK _ TO _ DOT _ README _ TXT ,     . digestRegularFile ( relativeLink ,    false )  )  ;", "try    {", ". digestRegularFile ( absoluteLink ,    false )  ;", "fail (  \" Absolute   links   should   cause   indigestion \"  )  ;", "}    catch    ( IOException   e )     {", "assertThat ( e . getMessage (  )  )  . startsWith (  \" Absolute   link \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["testSymlinks"], "fileName": "com.intellij.updater.DigesterTest"}, {"methodBody": ["METHOD_START", "{", "List < NativeFileManager . Process >    processes    =    new   LinkedList <  >  (  )  ;", "if    ( NativeFileManager . ourFailed )     {", "return   processes ;", "}", "try    {", "IntByReference   session    =    new   IntByReference (  )  ;", "char [  ]    sessionKey    =    new   char [  ( Win 3  2 RestartManager . CCH _ RM _ SESSION _ KEY )     +     1  ]  ;", "int   error    =    Win 3  2 RestartManager . INSTANCE . RmStartSession ( session ,     0  ,    sessionKey )  ;", "if    ( error    !  =     0  )     {", "Runner . logger (  )  . warn (  \" Unable   to   start   restart   manager   session \"  )  ;", "return   processes ;", "}", "StringArray   resources    =    new   StringArray ( new   WString [  ]  {    new   WString ( file . toString (  )  )     }  )  ;", "error    =    Win 3  2 RestartManager . INSTANCE . RmRegisterResources ( session . getValue (  )  ,     1  ,    resources ,     0  ,    NULL ,     0  ,    null )  ;", "if    ( error    !  =     0  )     {", "Runner . logger (  )  . warn (  (  \" Unable   to   register   restart   manager   resource    \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "return   processes ;", "}", "IntByReference   procInfoNeeded    =    new   IntByReference (  )  ;", "Win 3  2 RestartManager . RmProcessInfo   info    =    new   Win 3  2 RestartManager . RmProcessInfo (  )  ;", "Win 3  2 RestartManager . RmProcessInfo [  ]    infos    =     (  ( Win 3  2 RestartManager . RmProcessInfo [  ]  )     ( info . toArray ( NativeFileManager . MAX _ PROCESSES )  )  )  ;", "IntByReference   procInfo    =    new   IntByReference ( infos . length )  ;", "error    =    Win 3  2 RestartManager . INSTANCE . RmGetList ( session . getValue (  )  ,    procInfoNeeded ,    procInfo ,    info ,    new   LongByReference (  )  )  ;", "if    ( error    !  =     0  )     {", "Runner . logger (  )  . warn (  (  \" Unable   to   get   the   list   of   processes   using    \"     +     ( file . getAbsolutePath (  )  )  )  )  ;", "return   processes ;", "}", "for    ( int   i    =     0  ;    i    <     ( procInfo . getValue (  )  )  ;    i +  +  )     {", "processes . add ( new   NativeFileManager . Process ( infos [ i ]  . Process . dwProcessId ,    new   String ( infos [ i ]  . strAppName )  . trim (  )  )  )  ;", "}", "Win 3  2 RestartManager . INSTANCE . RmEndSession ( session . getValue (  )  )  ;", "}    catch    ( Throwable   t )     {", "NativeFileManager . ourFailed    =    true ;", "}", "return   processes ;", "}", "METHOD_END"], "methodName": ["getProcessesUsing"], "fileName": "com.intellij.updater.NativeFileManager"}, {"methodBody": ["METHOD_START", "{", "File   toDir    =    toBaseDir ( rootDir )  ;", "List < Action >    actionsToApply    =    new   ArrayList <  >  ( myActions . size (  )  )  ;", "try    {", "for    ( Action   each    :    myActions )     {", "ui . checkCancelled (  )  ;", "if    ( each . shouldApply ( toDir ,    options )  )     {", "actionsToApply . add ( each )  ;", "}", "}", "if    ( actionsToApply . isEmpty (  )  )     {", "Runner . logger (  )  . info (  \" nothing   to   apply \"  )  ;", "return   new   FileCreator . ApplicationResult ( false ,    Collections . emptyList (  )  )  ;", "}", "if    ( backupDir    !  =    null )     {", ". forEach ( actionsToApply ,     \" Backing   up   files .  .  .  \"  ,    ui ,     (    action )     -  >    action . backup ( toDir ,    backupDir )  )  ;", "}", "}    catch    ( OperationCancelledException   e )     {", "Runner . logger (  )  . warn (  \" cancelled \"  ,    e )  ;", "return   new   FileCreator . ApplicationResult ( false ,    Collections . emptyList (  )  )  ;", "}", "List < Action >    appliedActions    =    new   ArrayList <  >  ( actionsToApply . size (  )  )  ;", "List < File >    createdDirectories    =    new   ArrayList <  >  (  )  ;", "Set < File >    createdOptionalFiles    =    new   HashSet <  >  (  )  ;", "try    {", ". forEach ( actionsToApply ,     \" Applying   patch .  .  .  \"  ,    ui ,     (    action )     -  >     {", "if    (  ( action   instanceof   CreateAction )     &  &     (  !  ( new   File ( toDir ,    action . getPath (  )  )  . getParentFile (  )  . exists (  )  )  )  )     {", "Runner . logger (  )  . info (  (  (  \" Create   action :     \"     +     ( action . getPath (  )  )  )     +     \"    skipped .    The   parent   folder   is   absent .  \"  )  )  ;", "} else", "if    (  ( action   instanceof   UpdateAction )     &  &     (  !  ( new   File ( toDir ,    action . getPath (  )  )  . getParentFile (  )  . exists (  )  )  )  )     {", "Runner . logger (  )  . info (  (  (  \" Update   action :     \"     +     ( action . getPath (  )  )  )     +     \"    skipped .    The   parent   folder   is   absent .  \"  )  )  ;", "} else    {", "appliedActions . add ( action )  ;", "action . apply ( patchFile ,    backupDir ,    toDir )  ;", "if    ( action   instanceof   CreateAction )     {", "File   file    =    action . getFile ( toDir )  ;", "if    ( file . isDirectory (  )  )     {", "createdDirectories . add (  0  ,    file )  ;", "} else", "if    ( action . isOptional (  )  )     {", "createdOptionalFiles . add ( file )  ;", "}", "}", "}", "}  )  ;", "}    catch    ( OperationCancelledException   e )     {", "Runner . logger (  )  . warn (  \" cancelled \"  ,    e )  ;", "return   new   FileCreator . ApplicationResult ( false ,    appliedActions )  ;", "}    catch    ( Throwable   t )     {", "Runner . logger (  )  . error (  \" apply   failed \"  ,    t )  ;", "return   new   FileCreator . ApplicationResult ( false ,    appliedActions ,    t )  ;", "}", "for    ( File   directory    :    createdDirectories )     {", "File [  ]    children    =    directory . listFiles (  )  ;", "if    (  ( children    !  =    null )     &  &     ( createdOptionalFiles . containsAll ( Arrays . asList ( children )  )  )  )     {", "Runner . logger (  )  . info (  (  \" Pruning   empty   directory :     \"     +    directory )  )  ;", "try    {", "Utils . delete ( directory )  ;", "}    catch    ( IOException   e )     {", "Runner . logger (  )  . warn (  (  \" pruning :     \"     +    directory )  ,    e )  ;", "}", "}", "}", "try    {", "Files . setLastModifiedTime ( toDir . toPath (  )  ,    FileTime . from ( Instant . now (  )  )  )  ;", "}    catch    ( IOException   e )     {", "Runner . logger (  )  . warn (  (  \" setLastModified :     \"     +    toDir )  ,    e )  ;", "}", "return   new   FileCreator . ApplicationResult ( true ,    appliedActions )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  \" Calculating   difference .  .  .  \"  )  ;", "ui . startProcess (  \" Calculating   difference .  .  .  \"  )  ;", "File   olderDir    =    new   File ( spec . getOldFolder (  )  )  ;", "File   newerDir    =    new   File ( spec . getNewFolder (  )  )  ;", "Map < String ,    Long >    oldChecksums    =    digestFiles ( olderDir ,    spec . getIgnoredFiles (  )  ,    isNormalized (  )  )  ;", "Map < String ,    Long >    newChecksums    =    digestFiles ( newerDir ,    spec . getIgnoredFiles (  )  ,    false )  ;", "DiffCalculator . Result   diff    =    DiffCalculator . calculate ( oldChecksums ,    newChecksums ,    spec . getCriticalFiles (  )  ,    spec . getOptionalFiles (  )  ,    true )  ;", "List < PatchAction >    tempActions    =    new   ArrayList <  >  (  )  ;", "for    ( Map . Entry < String ,    Long >    each    :    diff . filesToDelete . entrySet (  )  )     {", "tempActions . add (  0  ,    new   DeleteAction ( this ,    each . getKey (  )  ,    each . getValue (  )  )  )  ;", "}", "for    ( String   each    :    diff . filesToCreate . keySet (  )  )     {", "tempActions . add ( new   CreateAction ( this ,    each )  )  ;", "}", "for    ( Map . Entry < String ,    DiffCalculator . Update >    each    :    diff . filesToUpdate . entrySet (  )  )     {", "DiffCalculator . Update       =    each . getValue (  )  ;", "if    (  (  (  !  ( spec . isBinary (  )  )  )     &  &     (  !  (  . move )  )  )     &  &     ( Utils . isZipFile ( each . getKey (  )  )  )  )     {", "tempActions . add ( new   UpdateZipAction ( this ,    each . getKey (  )  ,     . source ,     . checksum )  )  ;", "} else    {", "tempActions . add ( new   UpdateAction ( this ,    each . getKey (  )  ,     . source ,     . checksum ,     . move )  )  ;", "}", "}", "if    ( spec . isStrict (  )  )     {", "for    ( Map . Entry < String ,    Long >    each    :    diff . commonFiles . entrySet (  )  )     {", "tempActions . add ( new   ValidateAction ( this ,    each . getKey (  )  ,    each . getValue (  )  )  )  ;", "}", "}", "Runner . logger (  )  . info (  \" Preparing   actions .  .  .  \"  )  ;", "ui . startProcess (  \" Preparing   actions .  .  .  \"  )  ;", "List < PatchAction >    actions    =    new   ArrayList <  >  (  )  ;", "for    ( PatchAction   action    :    tempActions )     {", "Runner . logger (  )  . info ( action . getPath (  )  )  ;", "if    ( action . calculate ( olderDir ,    newerDir )  )     {", "actions . add ( action )  ;", "action . setCritical ( spec . getCriticalFiles (  )  . contains ( action . getPath (  )  )  )  ;", "action . setOptional ( spec . getOptionalFiles (  )  . contains ( action . getPath (  )  )  )  ;", "}", "}", "return   actions ;", "}", "METHOD_END"], "methodName": ["calculateActions"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( myIsBinary )  )     &  &     ( Utils . isZipFile ( toFile . getName (  )  )  )  )     {", "return   DigesdigestZipFile ( toFile )  ;", "} else    {", "return   DigesdigestRegularFile ( toFile ,    normalize )  ;", "}", "}", "METHOD_END"], "methodName": ["digestFile"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Long >    result    =    new   LinkedHashMap <  >  (  )  ;", "LinkedHashSet < String >    paths    =    Utils . collectRelativehs ( dir )  ;", "for    ( String   each    :    paths )     {", "if    (  !  ( ignoredFiles . contains ( each )  )  )     {", "result . put ( each ,    digestFile ( new   File ( dir ,    each )  ,    normalize )  )  ;", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["digestFiles"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  (  (  ( title    +     \"     [  \"  )     +     ( actions . size (  )  )  )     +     \"    actions ]  \"  )  )  ;", "ui . startProcess ( title )  ;", "ui . checkCancelled (  )  ;", "for    ( int   i    =     0  ;    i    <     ( actions . size (  )  )  ;    i +  +  )     {", "Action   each    =    actions . get ( i )  ;", "ui . checkCancelled (  )  ;", "processor . forEach ( each )  ;", "ui . setProgress (  (  (  ( i    +     1  )     *     1  0  0  )     /     ( actions . size (  )  )  )  )  ;", "}", "ui . checkCancelled (  )  ;", "}", "METHOD_END"], "methodName": ["forEach"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   myActions ;", "}", "METHOD_END"], "methodName": ["getActions"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   myNewBuild ;", "}", "METHOD_END"], "methodName": ["getNewBuild"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   myOldBuild ;", "}", "METHOD_END"], "methodName": ["getOldBuild"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   myIsNormalized ;", "}", "METHOD_END"], "methodName": ["isNormalized"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   myIsStrict ;", "}", "METHOD_END"], "methodName": ["isStrict"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "return   Runner . isCaseSensitiveFs (  )     ?    path    :    path . toLowerCase ( Locale . getDefault (  )  )  ;", "}", "METHOD_END"], "methodName": ["mapPath"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "List < PatchAction >    actions    =    new   ArrayList <  >  (  )  ;", "int   size    =    in . readInt (  )  ;", "while    (  ( size -  -  )     >     0  )     {", "int   key    =    in . readInt (  )  ;", "PatchAction   a ;", "switch    ( key )     {", "case   Patch . CREATE _ ACTION _ KEY    :", "a    =    new   CreateAction ( this ,    in )  ;", "break ;", "case   Patch . UPDATE _ ACTION _ KEY    :", "a    =    new   UpdateAction ( this ,    in )  ;", "break ;", "case   Patch . UPDATE _ ZIP _ ACTION _ KEY    :", "a    =    new   UpdateZipAction ( this ,    in )  ;", "break ;", "case   Patch . DELETE _ ACTION _ KEY    :", "a    =    new   DeleteAction ( this ,    in )  ;", "break ;", "case   Patch . VALIDATE _ ACTION _ KEY    :", "a    =    new   ValidateAction ( this ,    in )  ;", "break ;", "default    :", "throw   new   RuntimeException (  (  \" Unknown   action   type    \"     +    key )  )  ;", "}", "actions . add ( a )  ;", "}", "return   actions ;", "}", "METHOD_END"], "methodName": ["readActions"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "int   size    =    in . readInt (  )  ;", "List < String >    list    =    new   ArrayList <  >  ( size )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "list . add ( in . readUTF (  )  )  ;", "}", "return   list ;", "}", "METHOD_END"], "methodName": ["readList"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "int   size    =    in . readInt (  )  ;", "Map < String ,    String >    map    =    new   HashMap <  >  (  )  ;", "for    ( int   i    =     0  ;    i    <    size ;    i +  +  )     {", "String   key    =    in . readUTF (  )  ;", "map . put ( key ,    in . readUTF (  )  )  ;", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["readMap"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  (  (  \" Reverting .  .  .     [  \"     +     ( actions . size (  )  )  )     +     \"    actions ]  \"  )  )  ;", "ui . startProcess (  \" Reverting .  .  .  \"  )  ;", "List < Action >    reverse    =    new   ArrayList <  >  ( actions )  ;", "Collections . reverse ( reverse )  ;", "File   toDir    =    toBaseDir ( rootDir )  ;", "for    ( int   i    =     0  ;    i    <     ( reverse . size (  )  )  ;    i +  +  )     {", "reverse . get ( i )  . revert ( toDir ,    backupDir )  ;", "ui . setProgress (  (  (  ( i    +     1  )     *     1  0  0  )     /     ( reverse . size (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["revert"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "String   path    =    toDir . toURI (  )  . getPath (  )  ;", "if    (  !  ( path . endsWith ( myRoot )  )  )     {", "throw   new   IOException (  (  \" The   p   must   be   applied   to   the   root   folder    \"     +     ( myRoot )  )  )  ;", "}", "return   new   File ( path . substring (  0  ,     (  ( path . length (  )  )     -     ( myRoot . length (  )  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["toBaseDir"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "LinkedHashSet < String >    files    =    null ;", "File   toDir    =    toBaseDir ( rootDir )  ;", "boolean   checkWarnings    =    true ;", "while    ( checkWarnings )     {", "files    =    Utils . collectRelativePaths ( toDir )  ;", "checkWarnings    =    false ;", "for    ( String   file    :    files )     {", "String   warning    =    myWarnings . get ( file )  ;", "if    ( warning    !  =    null )     {", "ui . askUser ( warning )  ;", "checkWarnings    =    true ;", "break ;", "}", "}", "}", "if    ( myIsStrict )     {", "for    ( Action   action    :    myActions )     {", "files . remove ( action . getPath (  )  )  ;", "}", "for    ( String   file    :    files )     {", "myActions . add (  0  ,    new   DeleteAction ( this ,    file ,    Digester . INVALID )  )  ;", "}", "}", "List < ValidationResult >    results    =    new   ArrayList <  >  (  )  ;", "Set < String >    deletedPaths    =    new   HashSet <  >  (  )  ;", ". forEach ( myActions ,     \" Validating   installation .  .  .  \"  ,    ui ,     (    action )     -  >     {", "ValidationResult   result    =    action . validate ( toDir )  ;", "if    ( action   instanceof   DeleteAction )     {", "deletedPaths . add (  . mapPath ( action . getPath (  )  )  )  ;", "} else", "if    (  (  (  ( action   instanceof   CreateAction )     &  &     ( result    !  =    null )  )     &  &     ( ValidationResult . ALREADY _ EXISTS _ MESSAGE . equals ( result . message )  )  )     &  &     ( deletedPaths . contains (  . mapPath ( action . getPath (  )  )  )  )  )     {", "result    =    null ;", "}", "if    ( result    !  =    null )", "results . add ( result )  ;", "}  )  ;", "return   results ;", "}", "METHOD_END"], "methodName": ["validate"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "for    ( String   delete    :    myDeleteFiles )     {", "if    ( path . mes ( delete )  )     {", "return   false ;", "}", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["validateDeletion"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "@ SuppressWarnings (  \" IOResourceOpenedButNotSafelyClosed \"  )", "DataOutputStream   dataOut    =    new   DataOutputStream ( out )  ;", "try    {", "dataOut . writeUTF ( myOldBuild )  ;", "dataOut . writeUTF ( myNewBuild )  ;", "dataOut . writeUTF ( myRoot )  ;", "dataOut . writeBoolean ( myIsBinary )  ;", "dataOut . writeBoolean ( myIsStrict )  ;", "dataOut . writeBoolean ( myIsNormalized )  ;", ". writeMap ( dataOut ,    myWarnings )  ;", ". writeList ( dataOut ,    myDeleteFiles )  ;", ". writeActions ( dataOut ,    myActions )  ;", "}    finally    {", "dataOut . flush (  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "dataOut . writeInt ( actions . size (  )  )  ;", "for    ( Action   each    :    actions )     {", "int   key ;", "Class   clazz    =    each . getClass (  )  ;", "if    ( clazz    =  =     ( CreateAction . class )  )     {", "key    =     . CREATE _ ACTION _ KEY ;", "} else", "if    ( clazz    =  =     ( UpdateAction . class )  )     {", "key    =     . UPDATE _ ACTION _ KEY ;", "} else", "if    ( clazz    =  =     ( UpdateZipAction . class )  )     {", "key    =     . UPDATE _ ZIP _ ACTION _ KEY ;", "} else", "if    ( clazz    =  =     ( DeleteAction . class )  )     {", "key    =     . DELETE _ ACTION _ KEY ;", "} else", "if    ( clazz    =  =     ( ValidateAction . class )  )     {", "key    =     . VALIDATE _ ACTION _ KEY ;", "} else    {", "throw   new   RuntimeException (  (  \" Unknown   action    \"     +    each )  )  ;", "}", "dataOut . writeInt ( key )  ;", "each . write ( dataOut )  ;", "}", "}", "METHOD_END"], "methodName": ["writeActions"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "dataOut . writeInt ( list . size (  )  )  ;", "for    ( String   string    :    list )     {", "dataOut . writeUTF ( string )  ;", "}", "}", "METHOD_END"], "methodName": ["writeList"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "dataOut . writeInt ( map . size (  )  )  ;", "for    ( Map . Entry < String ,    String >    entry    :    map . entrySet (  )  )     {", "dataOut . writeUTF ( entry . getKey (  )  )  ;", "dataOut . writeUTF ( entry . getValue (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeMap"], "fileName": "com.intellij.updater.Patch"}, {"methodBody": ["METHOD_START", "{", "doApply ( patchFile ,    backupDir ,    getFile ( toDir )  )  ;", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "doBackup ( getFile ( toDir )  ,    getFile ( backupDir )  )  ;", "}", "METHOD_END"], "methodName": ["backup"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "doBuildPatchFile ( getFile ( olderDir )  ,    getFile ( newerDir )  ,    patchOutput )  ;", "}", "METHOD_END"], "methodName": ["buildPatchFile"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   doCalculate ( getFile ( olderDir )  ,    getFile ( newerDir )  )  ;", "}", "METHOD_END"], "methodName": ["calculate"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["doCalculate"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["doShouldApply"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    (  (  !  ( toFile . exists (  )  )  )     |  |     ( toFile . isDirectory (  )  )  )", "return   null ;", "ValidationResult   result    =    validateProcessLock ( toFile ,    action )  ;", "if    ( result    !  =    null )", "return   result ;", "if    (  ! checkWriteable )", "return   null ;", "if    (  (  ( toFile . canRead (  )  )     &  &     ( toFile . canWrite (  )  )  )     &  &     (  . isWritable ( toFile )  )  )", "return   null ;", "ValidationResult . Option [  ]    options    =    new   ValidationResult . Option [  ]  {    myPatch . isStrict (  )     ?    ValidationResult . Option . NONE    :    ValidationResult . Option . IGNORE    }  ;", "return   new   ValidationResult ( ValidationResult . Kind . ERROR ,    myPath ,    action ,    ValidationResult . ACCESS _ DENIED _ MESSAGE ,    options )  ;", "}", "METHOD_END"], "methodName": ["doValidateAccess"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    ( toFile . exists (  )  )     {", "if    ( isModified ( toFile )  )     {", "ValidationResult . Option [  ]    options ;", "if    ( my . isStrict (  )  )     {", "if    ( isCritical (  )  )     {", "options    =    new   ValidationResult . Option [  ]  {    ValidationResult . Option . REPLACE    }  ;", "} else    {", "options    =    new   ValidationResult . Option [  ]  {    ValidationResult . Option . NONE    }  ;", "}", "} else    {", "if    ( isCritical (  )  )     {", "options    =    new   ValidationResult . Option [  ]  {    ValidationResult . Option . REPLACE ,    ValidationResult . Option . IGNORE    }  ;", "} else    {", "options    =    new   ValidationResult . Option [  ]  {    ValidationResult . Option . IGNORE    }  ;", "}", "}", "return   new   ValidationResult ( kind ,    myPath ,    action ,    ValidationResult . MODIFIED _ MESSAGE ,    options )  ;", "}", "} else", "if    (  !  ( isOptional (  )  )  )     {", "ValidationResult . Option [  ]    options    =    new   ValidationResult . Option [  ]  {    my . isStrict (  )     ?    ValidationResult . Option . NONE    :    ValidationResult . Option . IGNORE    }  ;", "return   new   ValidationResult ( kind ,    myPath ,    action ,    ValidationResult . ABSENT _ MESSAGE ,    options )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["doValidateNotChanged"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   myChecksum ;", "}", "METHOD_END"], "methodName": ["getChecksum"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( baseDir ,    myPath )  ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    ( Utils . isLink ( file )  )", "return    . FileType . SYMLINK ;", "if    ( Utils . isExecutable ( file )  )", "return    . FileType . EXECUTABLE _ FILE ;", "return    . FileType . REGULAR _ FILE ;", "}", "METHOD_END"], "methodName": ["getFileType"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return   myPath ;", "}", "METHOD_END"], "methodName": ["getPath"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myFlags )     &     ( PatchAction . CRITICAL )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isCritical"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myChecksum )     =  =     ( Digester . INVALID )  )     |  |     (  ( myChecksum )     !  =     ( myPatch . digestFile ( toFile ,    myPatch . isNormalized (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myFlags )     &     ( PatchAction . OPTIONAL )  )     !  =     0  ;", "}", "METHOD_END"], "methodName": ["isOptional"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "try    ( FileOutputStream   s    =    new   FileOutputStream ( toFile ,    true )  ; FileChannel   ch    =    s . getChannel (  )  ; FileLock   lock    =    ch . tryLock (  )  )     {", "return   lock    !  =    null ;", "}    c    ( OverlappingFileLockException    |    IOException   e )     {", "Runner . logger (  )  . warn ( toFile ,    e )  ;", "return   false ;", "}", "}", "METHOD_END"], "methodName": ["isWritable"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "int   value    =    in . read (  )  ;", ". FileType [  ]    types    =     . FileType . values (  )  ;", "if    (  ( value    <     0  )     |  |     ( value    >  =     ( types . length )  )  )", "throw   new   IOException (  \" Stream   format   error \"  )  ;", "return   types [ value ]  ;", "}", "METHOD_END"], "methodName": ["readFileType"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "doRevert ( getFile ( toDir )  ,    getFile ( backupDir )  )  ;", "}", "METHOD_END"], "methodName": ["revert"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    ( critical )", "myFlags    |  =     . CRITICAL ;", "else", "myFlags    &  =     ~  (  . CRITICAL )  ;", "}", "METHOD_END"], "methodName": ["setCritical"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    ( optional )", "myFlags    |  =     . OPTIONAL ;", "else", "myFlags    &  =     ~  (  . OPTIONAL )  ;", "}", "METHOD_END"], "methodName": ["setOptional"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "File   file    =    getFile ( toDir )  ;", "ValidaResult . Op   op    =    ops . get ( myPath )  ;", "if    (  ( op    =  =     ( ValidaResult . Op . KEEP )  )     |  |     ( op    =  =     ( ValidaResult . Op . IGNORE )  )  )", "return   false ;", "if    ( op    =  =     ( ValidaResult . Op . KILL _ PROCESS )  )     {", "NativeFileManager . getProcessesUsing ( file )  . forEach (  (    p )     -  >    p . terminate (  )  )  ;", "}", "return   doShouldApply ( toDir )  ;", "}", "METHOD_END"], "methodName": ["shouldApply"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "List < NativeFileManager . Process >    processes    =    NativeFileManager . getProcessesUsing ( toFile )  ;", "if    (  ( processes . size (  )  )     =  =     0  )", "return   null ;", "String   message    =     \" Locked   by :     \"     +     ( processes . stream (  )  . map (  (    p )     -  >    p . name )  . collect ( Collectors . joining (  \"  ,     \"  )  )  )  ;", "return   new   ValidationResult ( ValidationResult . Kind . ERROR ,    myPath ,    a ,    message ,    ValidationResult . Option . KILL _ PROCESS )  ;", "}", "METHOD_END"], "methodName": ["validateProcessLock"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "out . writeUTF ( myPath )  ;", "out . writeLong ( myChecksum )  ;", "out . writeByte ( myFlags )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "out . write ( type . ordinal (  )  )  ;", "}", "METHOD_END"], "methodName": ["writeFileType"], "fileName": "com.intellij.updater.PatchAction"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myFile . exists (  )  )  )     {", "createPatch (  )  ;", "}", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >     {", "}  )  ;", "}", "METHOD_END"], "methodName": ["assertAppliedAndReverted"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assertAppliedAndReverted ( preparationResult ,     (    expected )     -  >     {", "}  )  ;", "}", "METHOD_END"], "methodName": ["assertAppliedAndReverted"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    preparationResult . patch ;", "Map < String ,    Long >    original    =    PatchTestCase . digest ( patch ,    myOlderDir )  ;", "Map < String ,    Long >    target    =    PatchTestCase . digest ( patch ,    myNewerDir )  ;", "corrector . accept ( target )  ;", "File   backup    =    getTempFile (  \" backup \"  )  ;", "Map < String ,    ValidationResult . Option >    options    =    new   HashMap <  >  (  )  ;", "for    ( ValidationResult   each    :    preparationResult . validationResults )     {", "if    ( patch . isStrict (  )  )     {", "assertThat ( each . options )  . isNotEmpty (  )  . doesNotContain ( ValidationResult . Option . NONE )  ;", "options . put ( each . path ,    each . options . get (  0  )  )  ;", "} else    {", "assertTrue ( each . toString (  )  ,     (  ( each . kind )     !  =     ( ValidationResult . Kind . ERROR )  )  )  ;", "}", "}", "PatchFileCreator . ApplicationResult   applicationResult    =    PatchFileCreator . apply ( preparationResult ,    options ,    backup ,    TEST _ UI )  ;", "assertTrue ( applicationResult . applied )  ;", "assertEquals ( target ,    PatchTestCase . digest ( patch ,    myOlderDir )  )  ;", "PatchFileCreator . revert ( preparationResult ,    applicationResult . appliedActions ,    backup ,    TEST _ UI )  ;", "assertEquals ( original ,    PatchTestCase . digest ( patch ,    myOlderDir )  )  ;", "}", "METHOD_END"], "methodName": ["assertAppliedAndReverted"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assertNotApplied ( preparationResult ,    Collections . emptyMap (  )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotApplied"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    preparationResult . patch ;", "File   backup    =    getTempFile (  \" backup \"  )  ;", "Map < String ,    Long >    original    =    PatchTestCase . digest ( patch ,    myOlderDir )  ;", "PatchFileCreator . ApplicationResult   applicationResult    =    PatchFileCreator . apply ( preparationResult ,    options ,    backup ,    TEST _ UI )  ;", "assertFalse ( applicationResult . applied )  ;", "PatchFileCreator . revert ( preparationResult ,    applicationResult . appliedActions ,    backup ,    TEST _ UI )  ;", "assertEquals ( original ,    PatchTestCase . digest ( patch ,    myOlderDir )  )  ;", "}", "METHOD_END"], "methodName": ["assertNotApplied"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assertFalse ( myFile . exists (  )  )  ;", "patch    =    FileCreator . create ( mySpec ,    myFile ,    TEST _ UI )  ;", "assertTrue ( myFile . exists (  )  )  ;", "return   patch ;", "}", "METHOD_END"], "methodName": ["createPatch"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "try    ( RandomAccessFile   raf    =    new   RandomAccessFile ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  ,     \" rw \"  )  )     {", "int   b    =    raf . read (  )  ;", "raf . seek (  0  )  ;", "raf . write ( b )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertNotApplied ( preparationResult )  ;", "}", "}", "METHOD_END"], "methodName": ["doLockedFileTest"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "return   ContainerUtil . find ( patch . getActions (  )  ,     (    a )     -  >    a . getPath (  )  . equals ( path )  )  ;", "}", "METHOD_END"], "methodName": ["findAction"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "try    ( RandomAccessFile   raf    =    new   RandomAccessFile ( file ,     \" rw \"  )  )     {", "raf . seek (  2  0  )  ;", "raf . write (  4  2  )  ;", "}", "}", "METHOD_END"], "methodName": ["modifyFile"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / bootstrap . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / boot . jar \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "long   hash    =     ( myPatchSpec . isBinary (  )  )     ?    CHECKSUMS . BOOTSTRAP _ JAR _ BIN    :    CHECKSUMS . BOOTSTRAP _ JAR ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >    expected . put (  \" lib / boot . jar \"  ,    hash )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenCommonFileChanges"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "createPatch (  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / bootstrap . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / boot . jar \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" lib / boot . jar \"  ,    ValidationResult . Action . VALIDATE ,    ValidationResult . MODIFIED _ MESSAGE ,    ValidationResult . Option . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenCommonFileChangesStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "myPatchSpec . setDeleteFiles ( Collections . singletonList (  \" lib / *  \\  \\  . hprof \"  )  )  ;", "createPatch (  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" lib / hprof \"  )  ,     \" bye !  \"  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "assertAppliedAnded ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenNewDeletableFileExistsStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" delete / delete _ me . txt \"  )  ,     \" bye !  \"  )  ;", "createPatch (  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" unexpected _ new _ dir / unexpected . txt \"  )  ,     \" bye !  \"  )  ;", "FileUtil . createDirectory ( new   File ( myOlderDir ,     \" newDir \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" unexpected _ new _ dir / unexpected . txt \"  ,    ValidationResult . Action . VALIDATE ,     \" Unexpected   file \"  ,    ValidationResult . Option . DELETE )  ,    new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" unexpected _ new _ dir /  \"  ,    ValidationResult . Action . VALIDATE ,     \" Unexpected   file \"  ,    ValidationResult . Option . DELETE )  ,    new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" newDir /  \"  ,    ValidationResult . Action . CREATE ,    ValidationResult . ALREADY _ EXISTS _ MESSAGE ,    ValidationResult . Option . REPLACE )  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" newDir \"  )  )  ;", "assertAppliedAnded ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenNewDirectoryExistsStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" Readme . txt \"  )  ,    new   File ( myOlderDir ,     \" new _ file . txt \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >    expected . put (  \" new _ file . txt \"  ,    CHECKSUMS . README _ TXT )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenNewFileExists"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "myPatchSpec . setDeleteFiles ( Collections . singletonList (  \" lib / *  \\  \\  . hprof \"  )  )  ;", "createPatch (  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" new _ file . txt \"  )  ,     \" hello \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" lib / hprof \"  )  ,     \" bye !  \"  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" new _ file . txt \"  ,    ValidationResult . Action . VALIDATE ,     \" Unexpected   file \"  ,    ValidationResult . Option . DELETE )  )  ;", "assertAppliedAnded ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testApplyWhenNewFileExistsStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithAbsentFileToDelete"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "createPatch (  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" lib / annotations . jar \"  ,    ValidationResult . Action . UPDATE ,    ValidationResult . ABSENT _ MESSAGE ,    ValidationResult . Option . NONE )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithAbsentFileToUpdateStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" bin / idea . bat \"  )  ,     \" new   content \"  . getBytes ( StandardCharsets . UTF _  8  )  )  ;", "myPatchSpec . setOptionalFiles ( Collections . singletonList (  \" bin / idea . bat \"  )  )  ;", "createPatch (  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >    expected . remove (  \" bin / idea . bat \"  )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithAbsentOptionalFile"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . rename ( new   File ( myOlderDir ,     \" Readme . txt \"  )  ,    new   File ( myOlderDir ,     \" README . txt \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithCaseChangedNames"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setCriticalFiles ( Collections . singletonList (  \" lib / annotations . jar \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithCriticalFiles"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "myPatchSpec . setCriticalFiles ( Collections . singletonList (  \" lib / annotations . jar \"  )  )  ;", "createPatch (  )  ;", ". modifyFile ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  )  ;", "assertAppliedAndReverted (  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithModifiedCriticalFiles"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "myPatchSpec . setRoot (  \" lib /  \"  )  ;", "myPatchSpec . setCriticalFiles ( Collections . singletonList (  \" lib / annotations . jar \"  )  )  ;", "createPatch (  )  ;", ". modifyFile ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  )  ;", "assertAppliedAndReverted ( PatchFileCreator . prepareAndValidate ( myFile ,    new   File ( myOlderDir ,     \" lib /  \"  )  ,    TEST _ UI )  )  ;", "}", "METHOD_END"], "methodName": ["testApplyingWithModifiedCriticalFilesAndDifferentRoot"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "List < PatchAction >    actions    =    preparationResult . patch . getActions (  )  ;", "actions . add ( new    . MyFailOnApplyPatchAction ( preparationResult . patch )     {", "@ Override", "protected   void   doApply ( ZipFile   patchFile ,    File   backupDir ,    File   toFile )     {", "TEST _ UI . cancelled    =    true ;", "}", "}  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testCancelledAtApplying"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "List < PatchAction >    actions    =    preparationResult . patch . getActions (  )  ;", "actions . add ( new    . MyFailOnApplyPatchAction ( preparationResult . patch )     {", "@ Override", "protected   void   doBackup ( File   toFile ,    File   backupFile )     {", "TEST _ UI . cancelled    =    true ;", "}", "}  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testCancelledAtBackingUp"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "Map < String ,    ValidationResult . Option >    options    =    preparationResult . patch . getActions (  )  . stream (  )  . collect ( Collectors . toMap ( ction :  : getPath ,     (    a )     -  >    ValidationResult . Option . IGNORE )  )  ;", "assertNotApplied ( preparationResult ,    options )  ;", "}", "METHOD_END"], "methodName": ["testConsideringOptions"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assertAppliedAndReverted (  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplying"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setRoot (  \" bin /  \"  )  ;", "myPatchSpec . setStrict ( true )  ;", "createPatch (  )  ;", "assertAppliedAnded ( PatchFileCreator . prepareAndValidate ( myFile ,    new   File ( myOlderDir ,     \" bin \"  )  ,    TEST _ UI )  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplyingOnADifferentRoot"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplyingStrict"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( myOlderDir ,     \" Readme . txt \"  )  ;", "FileUtil . delete ( file )  ;", "FileUtil . createDirectory ( file )  ;", "FileUtil . writeToFile ( new   File ( file ,     \" subFile . txt \"  )  ,     \"  \"  )  ;", "FileUtil . writeToFile ( new   File ( file ,     \" subDir / subFile . txt \"  )  ,     \"  \"  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / boot . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / boot _ with _ directory _ becomes _ file . jar \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplyingWhenDirectoryBecomesFile"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( myOlderDir ,     \" bin \"  )  ;", "FileUtil . delete ( file )  ;", "FileUtil . writeToFile ( file ,     \"  \"  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / boot _ with _ directory _ becomes _ file . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / boot . jar \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplyingWhenFileBecomesDirectory"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "Map < String ,    Long >    expected    =    PatchTestCase . digest ( preparationResult . patch ,    myNewerDir )  ;", "PatchFileCreator . ApplicationResult   applicationResult    =    PatchFileCreator . apply ( preparationResult ,    Collections . emptyMap (  )  ,    null ,    TEST _ UI )  ;", "assertTrue ( applicationResult . applied )  ;", "assertEquals ( expected ,    PatchTestCase . digest ( preparationResult . patch ,    myOlderDir )  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndApplyingWithoutBackup"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setRoot (  \" bin /  \"  )  ;", "myPatchSpec . setStrict ( true )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    new   File ( myOlderDir ,     \" bin \"  )  ,    TEST _ UI )  ;", "preparationResult . patch . getActions (  )  . add ( new    . MyFailOnApplyPatchAction ( preparationResult . patch )  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testCreatingAndFailingOnADifferentRoot"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . createDirectory ( new   File ( myNewerDir ,     \" new _ empty _ dir / sub _ dir \"  )  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >     {", "expected . remove (  \" new _ empty _ dir /  \"  )  ;", "expected . remove (  \" new _ empty _ dir / sub _ dir /  \"  )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testDoNotLeaveEmptyDirectories"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "FileUtil . createDirectory ( new   File ( myOlderDir ,     \" from / move . me \"  )  )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" move / to / move . me \"  )  ,     \" different \"  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "assertThat (  . findAction ( preparationResult . patch ,     \" move / to / move . me \"  )  )  . isInstanceOf ( CreateAction . class )  ;", "assertThat (  . findAction ( preparationResult . patch ,     \" from / move . me /  \"  )  )  . isInstanceOf ( DeleteAction . class )  ;", "assertAppliedAndReverted ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testDontMoveFromDirectoryToFile"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "myPatchSpec . setCriticalFiles ( Collections . singletonList (  \" a / deleted / file / that / is / a / copy / move . me \"  )  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" move / from / this / directory / move . me \"  )  ,     \" old _ content \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" a / deleted / file / that / is / a / copy / move . me \"  )  ,     \" new _ content \"  )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" move / to / this / directory / move . me \"  )  ,     \" new _ content \"  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat (  . findAction ( preparationResult . patch ,     \" move / to / this / directory / move . me \"  )  )  . isInstanceOf ( CreateAction . class )  ;", "assertAppliedAndReverted ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testMoveCriticalFileByContent"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" move / from / this / directory / move . me \"  )  ,     \" old _ content \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" a / deleted / file / that / is / a / copy / move . me \"  )  ,     \" new _ content \"  )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" move / to / this / directory / move . me \"  )  ,     \" new _ content \"  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat (  . findAction ( preparationResult . patch ,     \" move / to / this / directory / move . me \"  )  )  . isInstanceOf ( UpdateAction . class )  . hasFieldOrPropertyWithValue (  \" move \"  ,    true )  . hasFieldOrPropertyWithValue (  \" sourcePath \"  ,     \" a / deleted / file / that / is / a / copy / move . me \"  )  ;", "assertAppliedAndReverted ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testMoveFileByContent"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "myPatchSpec . setStrict ( true )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" move / from / this / directory / move . me \"  )  ,     \" they \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" not / from / this / one / move . me \"  )  ,     \" are \"  )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" move / to / this / directory / move . me \"  )  ,     \" different \"  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat (  . findAction ( preparationResult . patch ,     \" move / to / this / directory / move . me \"  )  )  . isInstanceOf ( UpdateAction . class )  . hasFieldOrPropertyWithValue (  \" move \"  ,    false )  . hasFieldOrPropertyWithValue (  \" sourcePath \"  ,     \" move / from / this / directory / move . me \"  )  ;", "assertAppliedAndReverted ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testMoveFileByLocation"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "File   file    =    new   File ( myOlderDir ,     \" bin / read _ only _ to _ delete \"  )  ;", "FileUtil . writeToFile ( file ,     \" bye \"  )  ;", "assertTrue ( file . setWritable ( false ,    false )  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertThat ( preparationResult . validationResults )  . isEmpty (  )  ;", "assertAppliedAnded ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testReadOnlyFilesAreDeletable"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "PatchAction   original    =     . findAction ( preparationResult . patch ,     \" bin / idea . bat \"  )  ;", "assertThat ( original )  . isInstanceOf ( DeleteAction . class )  ;", "List < PatchAction >    actions    =    preparationResult . patch . getActions (  )  ;", "actions . set ( actions . indexOf ( original )  ,    new   DeleteAction ( preparationResult . patch ,    original . getPath (  )  ,    original . getChecksum (  )  )     {", "@ Override", "protected   void   doApply ( ZipFile   patchFile ,    File   backupDir ,    File   toFile )    throws   IOException    {", "throw   new   IOException (  \" dummy   exception \"  )  ;", "}", "}  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testRevertedWhenDeleteFailed"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( UtilsTest . IS _ WINDOWS )  ;", "doLockedFileTest (  )  ;", "}", "METHOD_END"], "methodName": ["testRevertedWhenFileToDeleteIsLocked"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( UtilsTest . IS _ WINDOWS )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" bin / idea . bat \"  )  ,     \" new   text \"  )  ;", "doLockedFileTest (  )  ;", "}", "METHOD_END"], "methodName": ["testRevertedWhenFileToUpdateIsLocked"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" bin / idea . bat \"  )  ,     \" new   text \"  )  ;", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "PatchAction   original    =     . findAction ( preparationResult . patch ,     \" bin / idea . bat \"  )  ;", "assertThat ( original )  . isInstanceOf ( UpdateAction . class )  ;", "List < PatchAction >    actions    =    preparationResult . patch . getActions (  )  ;", "actions . set ( actions . indexOf ( original )  ,    new   UpdateAction ( preparationResult . patch ,    original . getPath (  )  ,    original . getChecksum (  )  )     {", "@ Override", "protected   void   doApply ( ZipFile   patchFile ,    File   backupDir ,    File   toFile )    throws   IOException    {", "throw   new   IOException (  \" dummy   exception \"  )  ;", "}", "}  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testRevertedWhenUpdateFailed"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "preparationResult . patch . getActions (  )  . add ( new    . MyFailOnApplyPatchAction ( preparationResult . patch )  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testReverting"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "createPatch (  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "preparationResult . patch . getActions (  )  . add ( new    . MyFailOnApplyPatchAction ( preparationResult . patch )  )  ;", "assertNotApplied ( preparationResult )  ;", "}", "METHOD_END"], "methodName": ["testRevertingWithAbsentFileToDelete"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testSymlinkAdded"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testSymlinkRemoved"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . lnk \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testSymlinkRenamed"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "Utils . createLink (  \"  .  / Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testSymlinkRetargeted"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . copy ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  ,    new   File ( myOlderDir ,     \" jre / bin / java \"  )  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  ,    new   File ( myOlderDir ,     \" jre / lib / rt . jar \"  )  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / boot . jar \"  )  ,    new   File ( myOlderDir ,     \" jre / lib / tools . jar \"  )  )  ;", "resetNewerDir (  )  ;", "FileUtil . rename ( new   File ( myNewerDir ,     \" jre \"  )  ,    new   File ( myNewerDir ,     \" jre 3  2  \"  )  )  ;", "FileUtil . writeToFile ( new   File ( myNewerDir ,     \" jre 3  2  / lib / font - config . bfc \"  )  ,     \"  #    empty \"  )  ;", "myPatchSpec . setOptionalFiles ( Arrays . asList (  \" jre / bin / java \"  ,     \" jre / bin / jvm . dll \"  ,     \" jre / lib / rt . jar \"  ,     \" jre / lib / tools . jar \"  ,     \" jre 3  2  / bin / java \"  ,     \" jre 3  2  / bin / jvm . dll \"  ,     \" jre 3  2  / lib / rt . jar \"  ,     \" jre 3  2  / lib / tools . jar \"  ,     \" jre 3  2  / lib / font - config . bfc \"  )  )  ;", "createPatch (  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" jre \"  )  )  ;", "PatchFileCreator . PreparationResult   preparationResult    =    PatchFileCreator . prepareAndValidate ( myFile ,    myOlderDir ,    TEST _ UI )  ;", "assertAppliedAnded ( preparationResult ,     (    expected )     -  >     {", "List < String >    keys    =    ContainerUtil . findAll ( expected . keySet (  )  ,     (    k )     -  >    k . startsWith (  \" jre 3  2  /  \"  )  )  ;", "keys . forEach ( expected :  : remove )  ;", "}  )  ;", "}", "METHOD_END"], "methodName": ["testUpdatingMissingOptionalDirectory"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . rename ( new   File ( myNewerDir ,     \" lib / annotations . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annotations . jar \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testZipFileMove"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . delete ( new   File ( myNewerDir ,     \" lib / annotations . jar \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annotations _ changed . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annotations . jar \"  )  )  ;", "assertAppliedAnded (  )  ;", "}", "METHOD_END"], "methodName": ["testZipFileMoveWithUpdate"], "fileName": "com.intellij.updater.PatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createPatch (  )  ;", "assertThat ( patch . getActions (  )  . get (  0  )  )  . isInstanceOf ( DeleteAction . class )  . hasFieldOrPropertyWithValue (  \" path \"  ,     \" bin / idea . bat \"  )  ;", "patch . getActions (  )  . add (  1  ,    new   CreateAction ( patch ,     \" bin / IDEA . bat \"  )  )  ;", "return   patch ;", "}", "METHOD_END"], "methodName": ["createCaseOnlyRenamePatch"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createPatch (  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" bin / idea . bat \"  ,    CHECKSUMS . IDEA _ BAT )  ,    new   CreateAction ( patch ,     \" newDir /  \"  )  ,    new   CreateAction ( patch ,     \" newDir / newFile . txt \"  )  ,    new   UpdateAction ( patch ,     \" Readme . txt \"  ,    CHECKSUMS . README _ TXT )  ,    new   UpdateZipAction ( patch ,     \" lib / annotations . jar \"  ,    Collections . singletonList (  \" org / jetbrains / annotations / NewClass . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annotations / Nullable . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annotations / TestOnly . class \"  )  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   UpdateZipAction ( patch ,     \" lib / bootstrap . jar \"  ,    Collections . emptyList (  )  ,    Collections . emptyList (  )  ,    Collections . singletonList (  \" com /  / ide / ClassloaderUtil . class \"  )  ,    CHECKSUMS . BOOTSTRAP _ JAR )  )  ;", "}", "METHOD_END"], "methodName": ["testBasics"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "PatchSpec   spec    =    new   PatchSpec (  )  . setOldFolder ( myOlderDir . getAbsolutePath (  )  )  . setNewFolder ( myNewerDir . getAbsolutePath (  )  )  . setIgnoredFiles ( Arrays . asList (  \" Readme . txt \"  ,     \" bin / idea . bat \"  )  )  ;", "Patch   patch    =    new   Patch ( spec ,    TEST _ UI )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   CreateAction ( patch ,     \" newDir /  \"  )  ,    new   CreateAction ( patch ,     \" newDir / newFile . txt \"  )  ,    new   UpdateZipAction ( patch ,     \" lib / annotations . jar \"  ,    Collections . singletonList (  \" org / jetbrains / annotations / NewClass . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annotations / Nullable . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annotations / TestOnly . class \"  )  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   UpdateZipAction ( patch ,     \" lib / bootstrap . jar \"  ,    Collections . emptyList (  )  ,    Collections . emptyList (  )  ,    Collections . singletonList (  \" com /  / ide / ClassloaderUtil . class \"  )  ,    CHECKSUMS . BOOTSTRAP _ JAR )  )  ;", "}", "METHOD_END"], "methodName": ["testCreatingWithIgnoredFiles"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createPatch (  )  ;", "Map < String ,    Long >    checkSums    =    PatchTestCase . digest ( patch ,    myOlderDir )  ;", "assertThat ( checkSums . size (  )  )  . isEqualTo (  1  1  )  ;", "}", "METHOD_END"], "methodName": ["testDigestFiles"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots _ changed . jar \"  )  ,    new   File ( myOlderDir ,     \" lib 6  4  / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myNewerDir ,     \" lib 6  4  / redist / annots . bin \"  )  )  ;", "Patch   patch    =    createPatch (  (    spec )     -  >    spec . setOptionalFiles ( Arrays . asList (  \" lib / annots . bin \"  ,     \" lib / redist / annots . bin \"  )  )  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" lib / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ JAR _ BIN )  ,    new   DeleteAction ( patch ,     \" lib 6  4  / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ CHANGED _ JAR _ BIN )  ,    new   CreateAction ( patch ,     \" lib / redist /  \"  )  ,    new   CreateAction ( patch ,     \" lib 6  4  / redist /  \"  )  ,    new   UpdateAction ( patch ,     \" lib / redist / annots . bin \"  ,     \" lib / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ JAR _ BIN ,    true )  ,    new   UpdateAction ( patch ,     \" lib 6  4  / redist / annots . bin \"  ,     \" lib 6  4  / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ CHANGED _ JAR _ BIN ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["testNoOptionalFileMove1"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots _ changed . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myOlderDir ,     \" lib 6  4  / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annots . bin \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots . jar \"  )  ,    new   File ( myNewerDir ,     \" lib 6  4  / redist / annots . bin \"  )  )  ;", "Patch   patch    =    createPatch (  (    spec )     -  >    spec . setOptionalFiles ( Arrays . asList (  \" lib / annots . bin \"  ,     \" lib / redist / annots . bin \"  )  )  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" lib / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ CHANGED _ JAR _ BIN )  ,    new   DeleteAction ( patch ,     \" lib 6  4  / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ JAR _ BIN )  ,    new   CreateAction ( patch ,     \" lib / redist /  \"  )  ,    new   CreateAction ( patch ,     \" lib 6  4  / redist /  \"  )  ,    new   UpdateAction ( patch ,     \" lib / redist / annots . bin \"  ,     \" lib 6  4  / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ JAR _ BIN ,    true )  ,    new   UpdateAction ( patch ,     \" lib 6  4  / redist / annots . bin \"  ,     \" lib 6  4  / annots . bin \"  ,    CHECKSUMS . ANNOTATIONS _ JAR _ BIN ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testNoOptionalFileMove2"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   original    =    createPatch (  )  ;", "File   f    =    getTempFile (  \" file \"  )  ;", "try    ( FileOutputStream   out    =    new   FileOutputStream ( f )  )     {", "original . write ( out )  ;", "}", "Patch   recreated ;", "try    ( FileInputStream   in    =    new   FileInputStream ( f )  )     {", "recreated    =    new   Patch ( in )  ;", "}", "assertThat ( recreated . getActions (  )  )  . isEqualTo ( original . getActions (  )  )  ;", "}", "METHOD_END"], "methodName": ["testSaveLoad"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createCaseOnlyRenamePatch (  )  ;", "assertThat ( patch . validate ( myOlderDir ,    TEST _ UI )  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["testValidatingCaseOnlyRename"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "assertThat ( Runner . isCaseSensitiveFs (  )  )  . isEqualTo ( isFileSystemCaseSensitive )  ;", "patch    =    createCaseOnlyRename (  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" bin / IDEA . bat \"  )  ,    FileUtil . loadFileBytes ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  )  )  ;", "List < ValidationResult >    results    =    patch . validate ( myOlderDir ,    TEST _ UI )  ;", "if    ( SystemInfo . isFileSystemCaseSensitive )     {", "assertThat ( results )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" bin / IDEA . bat \"  ,    ValidationResult . Action . CREATE ,    ValidationResult . ALREADY _ EXISTS _ MESSAGE ,    ValidationResult . Option . REPLACE ,    ValidationResult . Option . KEEP )  )  ;", "} else    {", "assertThat ( results )  . isEmpty (  )  ;", "}", "}", "METHOD_END"], "methodName": ["testValidatingCaseOnlyRenameWithConflict"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createPatch (  )  ;", "File   f    =    new   File ( myOlderDir ,     \" Readme . txt \"  )  ;", "try    ( FileOutputStream   s    =    new   FileOutputStream ( f ,    true )  ; FileLock   ignored    =    s . getChannel (  )  . lock (  )  )     {", "String   message    =     ( UtilsTest . IS _ WINDOWS )     ?    System . getProperty (  \" name \"  )  . contains (  \" OpenJDK \"  )     ?     \" Locked   by :    OpenJDK   Platform   binary \"     :     \" Locked   by :    Java ( TM )    Platform   SE   binary \"     :    ValidationResult . ACCESS _ DENIED _ MESSAGE ;", "ValidationResult . Option   option    =     ( UtilsTest . IS _ WINDOWS )     ?    ValidationResult . Option . KILL _ PROCESS    :    ValidationResult . Option . IGNORE ;", "assertThat ( patch . validate ( myOlderDir ,    TEST _ UI )  )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" Readme . txt \"  ,    ValidationResult . Action . UPDATE ,    message ,    option )  )  ;", "}", "}", "METHOD_END"], "methodName": ["testValidatingNonAccessibleFiles"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch    =    createPatch (  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" bin / idea . bat \"  )  ,     \" changed \"  )  ;", "FileUtil . createDirectory ( new   File ( myOlderDir ,     \" extraDir \"  )  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" extraDir / extraFile . txt \"  )  ,     \"  \"  )  ;", "FileUtil . createDirectory ( new   File ( myOlderDir ,     \" newDir \"  )  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" newDir / newFile . txt \"  )  ,     \"  \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" Readme . txt \"  )  ,     \" changed \"  )  ;", "FileUtil . writeToFile ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  ,     \" changed \"  )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" lib / bootstrap . jar \"  )  )  ;", "assertThat ( PatchTestCase . sortResults ( patch . validate ( myOlderDir ,    TEST _ UI )  )  )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" bin / idea . bat \"  ,    ValidationResult . Action . DELETE ,    ValidationResult . MODIFIED _ MESSAGE ,    ValidationResult . Option . DELETE ,    ValidationResult . Option . KEEP )  ,    new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" newDir /  \"  ,    ValidationResult . Action . CREATE ,    ValidationResult . ALREADY _ EXISTS _ MESSAGE ,    ValidationResult . Option . REPLACE ,    ValidationResult . Option . KEEP )  ,    new   ValidationResult ( ValidationResult . Kind . CONFLICT ,     \" newDir / newFile . txt \"  ,    ValidationResult . Action . CREATE ,    ValidationResult . ALREADY _ EXISTS _ MESSAGE ,    ValidationResult . Option . REPLACE ,    ValidationResult . Option . KEEP )  ,    new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" Readme . txt \"  ,    ValidationResult . Action . UPDATE ,    ValidationResult . MODIFIED _ MESSAGE ,    ValidationResult . Option . IGNORE )  ,    new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" lib / annotations . jar \"  ,    ValidationResult . Action . UPDATE ,    ValidationResult . MODIFIED _ MESSAGE ,    ValidationResult . Option . IGNORE )  ,    new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" lib / bootstrap . jar \"  ,    ValidationResult . Action . UPDATE ,    ValidationResult . ABSENT _ MESSAGE ,    ValidationResult . Option . IGNORE )  )  ;", "}", "METHOD_END"], "methodName": ["testValidation"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "Patch   patch 1     =    createPatch (  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / boot . jar \"  )  ,    new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  )  ;", "assertThat ( patch 1  . validate ( myOlderDir ,    TEST _ UI )  )  . containsExactly ( new   ValidationResult ( ValidationResult . Kind . ERROR ,     \" lib / annotations . jar \"  ,    ValidationResult . Action . UPDATE ,    ValidationResult . MODIFIED _ MESSAGE ,    ValidationResult . Option . IGNORE )  )  ;", "PatchSpec   spec    =    new   PatchSpec (  )  . setOldFolder ( myOlderDir . getAbsolutePath (  )  )  . setNewFolder ( myNewerDir . getAbsolutePath (  )  )  . setOptionalFiles ( Collections . singletonList (  \" lib / annotations . jar \"  )  )  ;", "Patch   patch 2     =    new   Patch ( spec ,    TEST _ UI )  ;", "FileUtil . delete ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  )  ;", "assertThat ( patch 2  . validate ( myOlderDir ,    TEST _ UI )  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["testValidationWithOptionalFiles"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . rename ( new   File ( myNewerDir ,     \" lib / annots . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annots . jar \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" lib / annots . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   CreateAction ( patch ,     \" lib / redist /  \"  )  ,    new   UpdateAction ( patch ,     \" lib / redist / annots . jar \"  ,     \" lib / annots . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testZipFileMove"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  ,    new   File ( myOlderDir ,     \" lib 6  4  / annotations . jar \"  )  )  ;", "resetNewerDir (  )  ;", "FileUtil . rename ( new   File ( myNewerDir ,     \" lib / annotations . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annotations . jar \"  )  )  ;", "FileUtil . rename ( new   File ( myNewerDir ,     \" lib 6  4  / annotations . jar \"  )  ,    new   File ( myNewerDir ,     \" lib 6  4  / redist / annotations . jar \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" lib / annotations . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   DeleteAction ( patch ,     \" lib 6  4  / annotations . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   CreateAction ( patch ,     \" lib / redist /  \"  )  ,    new   CreateAction ( patch ,     \" lib 6  4  / redist /  \"  )  ,    new   UpdateAction ( patch ,     \" lib / redist / annotations . jar \"  ,     \" lib / annotations . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR ,    true )  ,    new   UpdateAction ( patch ,     \" lib 6  4  / redist / annotations . jar \"  ,     \" lib 6  4  / annotations . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR ,    true )  )  ;", "}", "METHOD_END"], "methodName": ["testZipFileMoveWithAlternatives"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "resetNewerDir (  )  ;", "FileUtil . delete ( new   File ( myNewerDir ,     \" lib / annots . jar \"  )  )  ;", "FileUtil . copy ( new   File ( dataDir ,     \" lib / annots _ changed . jar \"  )  ,    new   File ( myNewerDir ,     \" lib / redist / annots . jar \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( PatchTestCase . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" lib / annots . jar \"  ,    CHECKSUMS . ANNOTATIONS _ JAR )  ,    new   CreateAction ( patch ,     \" lib / redist /  \"  )  ,    new   UpdateZipAction ( patch ,     \" lib / redist / annots . jar \"  ,     \" lib / annots . jar \"  ,    Collections . singletonList (  \" org / jetbrains / annots / NewClass . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annots / Nullable . class \"  )  ,    Collections . singletonList (  \" org / jetbrains / annots / TestOnly . class \"  )  ,    CHECKSUMS . ANNOTATIONS _ JAR )  )  ;", "}", "METHOD_END"], "methodName": ["testZipFileMoveWithUpdate"], "fileName": "com.intellij.updater.PatchCreationTest"}, {"methodBody": ["METHOD_START", "{", "try    ( ZipFile   zipFile    =    new   ZipFile ( preparationResult . patchFile )  )     {", "return   preparationResult . patch . apply ( zipFile ,    preparationResult . toDir ,    backupDir ,    options ,    ui )  ;", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "com.intellij.updater.PatchFileCreator"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  (  (  \" Creating   the   patch   file    '  \"     +    patchFile )     +     \"  '  .  .  .  \"  )  )  ;", "ui . startProcess (  (  (  \" Creating   the   patch   file    '  \"     +    patchFile )     +     \"  '  .  .  .  \"  )  )  ;", "Patch   patchInfo    =    new   Patch ( spec ,    ui )  ;", "try    ( ZipOutputStream   out    =    new   ZipOutputStream ( new   FileOutputStream ( patchFile )  )  )     {", "out . setLevel (  9  )  ;", "out . putNextEntry ( new   ZipEntry (  . PATCH _ INFO _ FILE _ NAME )  )  ;", "patchInfo . write ( out )  ;", "out . closeEntry (  )  ;", "File   olderDir    =    new   File ( spec . getOldFolder (  )  )  ;", "File   newerDir    =    new   File ( spec . getNewFolder (  )  )  ;", "List < PatchAction >    actions    =    patchInfo . getActions (  )  ;", "for    ( PatchAction   each    :    actions )     {", "Runner . logger (  )  . info (  (  \" Packing    \"     +     ( each . getPath (  )  )  )  )  ;", "each . buildPatchFile ( olderDir ,    newerDir ,    out )  ;", "}", "}", "return   patchInfo ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.updater.PatchFileCreator"}, {"methodBody": ["METHOD_START", "{", "Patch   patch ;", "try    ( ZipFile   zipFile    =    new   ZipFile ( patchFile )  ; InputStream   in    =    Utils . getEntryInputStream ( zipFile ,     . PATCH _ INFO _ FILE _ NAME )  )     {", "patch    =    new   Patch ( in )  ;", "}", "Runner . logger (  )  . info (  (  (  ( patch . getOldBuild (  )  )     +     \"     -  >     \"  )     +     ( patch . getNewBuild (  )  )  )  )  ;", "ui . setDescription ( patch . getOldBuild (  )  ,    patch . getNewBuild (  )  )  ;", "List < ValidationResult >    validationResults    =    patch . validate ( toDir ,    ui )  ;", "return   new    . PreparationResult ( patch ,    patchFile ,    toDir ,    validationResults )  ;", "}", "METHOD_END"], "methodName": ["prepareAndValidate"], "fileName": "com.intellij.updater.PatchFileCreator"}, {"methodBody": ["METHOD_START", "{", "preparationResult . patch . revert ( actionsToRevert ,    backupDir ,    preparationResult . toDir ,    ui )  ;", "}", "METHOD_END"], "methodName": ["revert"], "fileName": "com.intellij.updater.PatchFileCreator"}, {"methodBody": ["METHOD_START", "{", "return   myCriticalFiles ;", "}", "METHOD_END"], "methodName": ["getCriticalFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myDeleteFiles ;", "}", "METHOD_END"], "methodName": ["getDeleteFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myIgnoredFiles ;", "}", "METHOD_END"], "methodName": ["getIgnoredFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myJarFile ;", "}", "METHOD_END"], "methodName": ["getJarFile"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myNewFolder ;", "}", "METHOD_END"], "methodName": ["getNewFolder"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myNewVersionDescription ;", "}", "METHOD_END"], "methodName": ["getNewVersionDescription"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myOldFolder ;", "}", "METHOD_END"], "methodName": ["getOldFolder"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myOldVersionDescription ;", "}", "METHOD_END"], "methodName": ["getOldVersionDescription"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myOptionalFiles ;", "}", "METHOD_END"], "methodName": ["getOptionalFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myPatchFile ;", "}", "METHOD_END"], "methodName": ["getPatchFile"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myRoot ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myWarnings ;", "}", "METHOD_END"], "methodName": ["getWarnings"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myIsBinary ;", "}", "METHOD_END"], "methodName": ["isBinary"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myIsNormalized ;", "}", "METHOD_END"], "methodName": ["isNormalized"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   myIsStrict ;", "}", "METHOD_END"], "methodName": ["isStrict"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myIsBinary    =    binary ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setBinary"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myCriticalFiles    =    criticalFiles ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setCriticalFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myDeleteFiles    =    deleteFiles ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setDeleteFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myIgnoredFiles    =    ignoredFiles ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setIgnoredFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myJarFile    =    jarFile ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setJarFile"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myNewFolder    =    newFolder ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNewFolder"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myNewVersionDescription    =    newVersionDescription ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNewVersionDescription"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myIsNormalized    =    normalized ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setNormalized"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myOldFolder    =    oldFolder ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOldFolder"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myOldVersionDescription    =    oldVersionDescription ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOldVersionDescription"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myOptionalFiles    =    optionalFiles ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setOptionalFiles"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myPatchFile    =    patchFile ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setPatchFile"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myRoot    =    root ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setRoot"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myIsStrict    =    strict ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setStrict"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "myWarnings    =    warnings ;", "return   this ;", "}", "METHOD_END"], "methodName": ["setWarnings"], "fileName": "com.intellij.updater.PatchSpec"}, {"methodBody": ["METHOD_START", "{", "return   createPatch ( Function . identity (  )  )  ;", "}", "METHOD_END"], "methodName": ["createPatch"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "PatchSpec   spec    =    tuner . apply ( new   PatchSpec (  )  . setOldFolder ( myOlderDir . getAbsolutePath (  )  )  . setNewFolder ( myNewerDir . getAbsolutePath (  )  )  )  ;", "return   new   Patch ( spec ,    TEST _ UI )  ;", "}", "METHOD_END"], "methodName": ["createPatch"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "return   new   TreeMap <  >  ( patch . digestFiles ( dir ,    Collections . emptyList (  )  ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["digest"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "FileUtil . delete ( myNewerDir )  ;", "FileUtil . copyDir ( myOlderDir ,    myNewerDir )  ;", "}", "METHOD_END"], "methodName": ["resetNewerDir"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "Collection < List < T >  >    groups    =    list . stream (  )  . collect ( Collectors . groupingBy ( classifier ,    LinkedHashMap :  : new ,    Collectors . toList (  )  )  )  . values (  )  ;", "assertThat ( list )  . isEqualTo ( groups . stream (  )  . flatMap ( Collection :  : stream )  . collect ( Collectors . toList (  )  )  )  ;", "return   groups . stream (  )  . map (  (    elements )     -  >    elements . stream (  )  . sorted ( sor )  )  . flatMap (  (    stream )     -  >    stream )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["sort"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "return   PatchTestCase . sort ( actions ,     (    a )     -  >    a . getClass (  )  . getSimpleName (  )  . charAt (  0  )  ,    Comparator . comparing ( PatchAction :  : getPath )  )  ;", "}", "METHOD_END"], "methodName": ["sortActions"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "return   PatchTestCase . sort ( results ,     (    r )     -  >    r . action ,    Comparator . comparing (  (    r )     -  >    r . path )  )  ;", "}", "METHOD_END"], "methodName": ["sortResults"], "fileName": "com.intellij.updater.PatchTestCase"}, {"methodBody": ["METHOD_START", "{", "Map < Stg ,    Stg >    map    =    new   HashMap <  >  (  )  ;", "for    ( Stg   warg    :    wargs )     {", "t   ix    =    wargdexOf (  \"  :  \"  )  ;", "if    ( ix    !  =     (  -  1  )  )     {", "Stg   path    =    warg . substg (  0  ,    ix )  ;", "Stg   message    =    warg . substg (  ( ix    +     1  )  )  . replace (  \"  \\  \\ n \"  ,     \"  \\ n \"  )  ;", "map . put ( path ,    message )  ;", "}", "}", "return   map ;", "}", "METHOD_END"], "methodName": ["buildWarningMap"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "boolean   orig    =    new   File ( path )  . exists (  )  ;", ". ourCaseSensitiveFs    =     ( orig    !  =     ( new   File ( path . toUpperCase (  )  )  . exists (  )  )  )     |  |     ( orig    !  =     ( new   File ( path . toLowerCase (  )  )  . exists (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["checkCaseSensitivity"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  \" Cleaning   up .  .  .  \"  )  ;", "ui . startProcess (  \" Cleaning   up .  .  .  \"  )  ;", "ui . setProgressIndeterminate (  )  ;", "Utils . cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "ConsoleUpdaterUI   ui    =    new   ConsoleUpdaterUI (  )  ;", "boolean   success    =    false ;", "try    {", "File   tempPatchFile    =    Utils . getTempFile (  \" patch \"  )  ;", "PatchFileCreator . create ( spec ,    tempPatchFile ,    ui )  ;", "Runner . logger (  )  . info (  (  \" Packing   JAR   file :     \"     +     ( spec . getPatchFile (  )  )  )  )  ;", "ui . startProcess (  (  (  \" Packing   JAR   file    '  \"     +     ( spec . getPatchFile (  )  )  )     +     \"  '  .  .  .  \"  )  )  ;", "try    ( ZipOutputWrapper   out    =    new   ZipOutputWrapper ( new   FileOutputStream ( spec . getPatchFile (  )  )  )  ; ZipInputStream   in    =    new   ZipInputStream ( new   FileInputStream ( new   File ( spec . getJarFile (  )  )  )  )  )     {", "ZipEntry   e ;", "while    (  ( e    =    in . getNextEntry (  )  )     !  =    null )     {", "out . zipEntry ( e ,    in )  ;", "}", "out . zipFile ( Runner . PATCH _ FILE _ NAME ,    tempPatchFile )  ;", "out . finish (  )  ;", "}", "success    =    true ;", "}    catch    ( Throwable   t )     {", "Runner . logger (  )  . error (  \" create   failed \"  ,    t )  ;", "ui . showError ( Runner . printStackTrace ( t )  )  ;", "}    finally    {", "try    {", "Runner . cleanup ( ui )  ;", "}    catch    ( Throwable   t )     {", "success    =    false ;", "Runner . logger (  )  . error (  \" cleanup   failed \"  ,    t )  ;", "ui . showError ( Runner . printStackTrace ( t )  )  ;", "}", "}", "return   success ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "List < String >    result    =    new   ArrayList <  >  (  )  ;", "String   prefix    =    paramName    +     '  =  '  ;", "for    ( String   param    :    args )     {", "if    ( param . startsWith ( prefix )  )     {", "StringTokeniztokeniz =    new   StringTokenizparam . substring ( prefix . length (  )  )  ,     \"  ;  \"  )  ;", "while    ( tokenizhasMoreTokens (  )  )     {", "result . add ( tokeniznextToken (  )  )  ;", "}", "}", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["extractArguments"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "String   flag    =     (  \"  -  -  \"     +    name )     +     \"  =  \"  ;", "for    ( String   param    :    args )     {", "if    ( param . startsWith ( flag )  )     {", "return   param . substring ( flag . length (  )  )  ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getArgument"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "return   Arrays . asList ( args )  . contains (  (  \"  -  -  \"     +    name )  )  ;", "}", "METHOD_END"], "methodName": ["hasArgument"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Runner . logger )     =  =    null )     {", "String   logDirectory    =    Utils . findDirectory (  1  0  0  0  0  0  0 L )  ;", "Runner . logPath    =    new   File ( logDirectory ,     \" idea _ updater . log \"  )  . getAbsolutePath (  )  ;", "FileAppender   update    =    new   FileAppender (  )  ;", "update . setFile ( Runner . logPath )  ;", "update . setLayout ( new   PatternLayout (  \"  % d { dd / MM   HH : mm : ss }     %  -  5 p    % C {  1  }  .  % M    -     % m % n \"  )  )  ;", "update . setThreshold ( Level . ALL )  ;", "update . setAppend ( true )  ;", "update . activateOptions (  )  ;", "FileAppender   updateError    =    new   FileAppender (  )  ;", "updateError . setFile ( new   File ( logDirectory ,     \" idea _ updater _ error . log \"  )  . getAbsolutePath (  )  )  ;", "updateError . setLayout ( new   PatternLayout (  \"  % d { dd / MM   HH : mm : ss }     %  -  5 p    % C {  1  }  .  % M    -     % m % n \"  )  )  ;", "updateError . setThreshold ( Level . ERROR )  ;", "updateError . setAppend ( false )  ;", "updateError . activateOptions (  )  ;", "Runner . logger    =    Logger . getLogger (  \"  \"  )  ;", "Runner . logger . addAppender ( updateError )  ;", "Runner . logger . addAppender ( update )  ;", "Runner . logger . setLevel ( Level . ALL )  ;", "Runner . logger . info (  \"  -  -  -    Updater   started    -  -  -  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["initLogger"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Runner . logger )     =  =    null )     {", "Runner . logger    =    new   NOPLogger ( new   NOPLoggerRepository (  )  ,     \" root \"  )  ;", "} else", "if    (  !  (  ( Runner . logger )    instanceof   NOPLogger )  )     {", "throw   new   IllegalStateException (  \" Non - test   logger   already   defined \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["initTestLogger"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "try    {", "PatchFileCreator . PreparationResult   preparationResult ;", "Map < String ,    ValidationResult . Option >    resolutions ;", "File   backupDir ;", "PatchFileCreator . ApplicationResult   applicationResult ;", "try    {", "File   patchFile    =    Utils . getTempFile (  \" patch \"  )  ;", ". logger (  )  . info (  \" Extracting   patch   file .  .  .  \"  )  ;", "ui . startProcess (  \" Extracting   patch   file .  .  .  \"  )  ;", "ui . setProgressIndeterminate (  )  ;", "try    ( ZipFile   zipFile    =    new   ZipFile ( jarFile )  ; InputStream   in    =    Utils . getEntryInputStream ( zipFile ,     . PATCH _ FILE _ NAME )  ; OutputStream   out    =    new   BufferedOutputStream ( new   FileOutputStream ( patchFile )  )  )     {", "Utils . copyStream ( in ,    out )  ;", "}", "ui . checkCancelled (  )  ;", "File   destDir    =    new   File ( destPath )  ;", "preparationResult    =    PatchFileCreator . prepareAndValidate ( patchFile ,    destDir ,    ui )  ;", "List < ValidationResult >    problems    =    preparationResult . validationResults ;", "resolutions    =     ( problems . isEmpty (  )  )     ?    Collections . emptyMap (  )     :    ui . askUser ( problems )  ;", "backupDir    =    null ;", "if    ( backup )     {", "backupDir    =    Utils . getTempFile (  \" backup \"  )  ;", "if    (  !  ( backupDir . mkdir (  )  )  )", "throw   new   IOException (  (  \" Cannot   create   backup   directory :     \"     +    backupDir )  )  ;", "}", "applicationResult    =    PatchFileCreator . apply ( preparationResult ,    resolutions ,    backupDir ,    ui )  ;", "}    catch    ( OperationCancelledException   e )     {", ". logger (  )  . warn (  \" cancelled \"  ,    e )  ;", "return   false ;", "}    catch    ( IOException    |    RuntimeException    |    Error   t )     {", ". logger (  )  . error (  \" prepare   failed \"  ,    t )  ;", "String   message    =     (  (  (  (  (  (  (  \" An   error   occurred   when   preparing   the   patch :  \\ n \"     +     ( t . getClass (  )  . getSimpleName (  )  )  )     +     \"  :     \"  )     +     ( t . getMessage (  )  )  )     +     \"  \\ n \\ n \"  )     +     ( ui . bold (  \" No   files   were   changed .    Please   retry   applying   the   patch .  \"  )  )  )     +     \"  \\ n \\ n \"  )     +     \" More   details   in   the   log :     \"  )     +     (  . logPath )  ;", "ui . showError ( message )  ;", "return   false ;", "}", "if    (  !  ( applicationResult . applied )  )     {", "List < PatchAction >    appliedActions    =    applicationResult . appliedActions ;", "Throwable   error    =    applicationResult . error ;", "if    ( error    !  =    null )     {", "String   message    =     (  (  (  \" An   error   occurred   when   applying   the   patch :  \\ n \"     +     ( error . getClass (  )  . getSimpleName (  )  )  )     +     \"  :     \"  )     +     ( error . getMessage (  )  )  )     +     \"  \\ n \\ n \"  ;", "if    ( appliedActions . isEmpty (  )  )     {", "message    +  =    ui . bold (  \" No   files   were   changed .    Please   retry   applying   the   patch .  \"  )  ;", "} else", "if    ( backupDir    =  =    null )     {", "message    +  =    ui . bold (  \" Files   may   be   corrupted .    Please   reinstall   the   IDE .  \"  )  ;", "} else    {", "message    +  =    ui . bold (  \" Files   may   be   corrupted .    The   patch   will   attempt   to   revert   the   changes .  \"  )  ;", "}", "message    +  =     \"  \\ n \\ nMore   details   in   the   log :     \"     +     (  . logPath )  ;", "ui . showError ( message )  ;", "}", "if    (  (  !  ( appliedActions . isEmpty (  )  )  )     &  &     ( backupDir    !  =    null )  )     {", "try    {", "PatchFileCreator . revert ( preparationResult ,    appliedActions ,    backupDir ,    ui )  ;", "}    catch    ( Throwable   t )     {", ". logger (  )  . error (  \" revert   failed \"  ,    t )  ;", "String   message    =     (  (  (  (  (  (  (  \" An   error   occurred   when   reverting   the   patch :  \\ n \"     +     ( t . getClass (  )  . getSimpleName (  )  )  )     +     \"  :     \"  )     +     ( t . getMessage (  )  )  )     +     \"  \\ n \\ n \"  )     +     ( ui . bold (  \" Files   may   be   corrupted .    Please   reinstall   the   IDE .  \"  )  )  )     +     \"  \\ n \\ n \"  )     +     \" More   details   in   the   log :     \"  )     +     (  . logPath )  ;", "ui . showError ( message )  ;", "}", "}", "}", "return   applicationResult . applied ;", "}    finally    {", "try    {", ". cleanup ( ui )  ;", "}    catch    ( Throwable   t )     {", ". logger (  )  . warn (  \" cleanup   failed \"  ,    t )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["install"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "return   Runner . ourCaseSensitiveFs ;", "}", "METHOD_END"], "methodName": ["isCaseSensitiveFs"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "return   Runner . logger ;", "}", "METHOD_END"], "methodName": ["logger"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "String   jarFile    =    Runner . getArgument ( args ,     \" jar \"  )  ;", "if    ( jarFile    =  =    null )     {", "jarFile    =    Runner . resolveJarFile (  )  ;", "}", "if    (  (  ( args . length )     >  =     6  )     &  &     (  \" create \"  . equals ( args [  0  ]  )  )  )     {", "String   oldVersionDesc    =    args [  1  ]  ;", "String   newVersionDesc    =    args [  2  ]  ;", "String   oldFolder    =    args [  3  ]  ;", "String   newFolder    =    args [  4  ]  ;", "String   patchFile    =    args [  5  ]  ;", "Runner . checkCaseSensitivity ( newFolder )  ;", "Runner . initLogger (  )  ;", "boolean   binary    =    Runner . hasArgument ( args ,     \" zip _ as _ binary \"  )  ;", "boolean   strict    =    Runner . hasArgument ( args ,     \" strict \"  )  ;", "boolean   normalized    =    Runner . hasArgument ( args ,     \" normalized \"  )  ;", "String   root    =    Runner . getArgument ( args ,     \" root \"  )  ;", "if    ( root    =  =    null )     {", "root    =     \"  \"  ;", "} else", "if    (  !  ( root . endsWith (  \"  /  \"  )  )  )     {", "root    +  =     \"  /  \"  ;", "}", "List < String >    ignoredFiles    =    Runner . extractArguments ( args ,     \" ignored \"  )  ;", "List < String >    criticalFiles    =    Runner . extractArguments ( args ,     \" critical \"  )  ;", "List < String >    optionalFiles    =    Runner . extractArguments ( args ,     \" optional \"  )  ;", "List < String >    deleteFiles    =    Runner . extractArguments ( args ,     \" delete \"  )  ;", "Map < String ,    String >    warnings    =    Runner . buildWarningMap ( Runner . extractArguments ( args ,     \" warning \"  )  )  ;", "PatchSpec   spec    =    new   PatchSpec (  )  . setOldVersionDescription ( oldVersionDesc )  . setNewVersionDescription ( newVersionDesc )  . setRoot ( root )  . setOldFolder ( oldFolder )  . setNewFolder ( newFolder )  . setPatchFile ( patchFile )  . setJarFile ( jarFile )  . setStrict ( strict )  . setBinary ( binary )  . setNormalized ( normalized )  . setIgnoredFiles ( ignoredFiles )  . setCriticalFiles ( criticalFiles )  . setOptionalFiles ( optionalFiles )  . setDeleteFiles ( deleteFiles )  . setWarnings ( warnings )  ;", "boolean   success    =    Runner . create ( spec )  ;", "System . exit (  ( success    ?     0     :     1  )  )  ;", "} else", "if    (  (  ( args . length )     >  =     2  )     &  &     (  (  \" install \"  . equals ( args [  0  ]  )  )     |  |     (  \" apply \"  . equals ( args [  0  ]  )  )  )  )     {", "String   destFolder    =    args [  1  ]  ;", "Runner . checkCaseSensitivity ( destFolder )  ;", "Runner . initLogger (  )  ;", "Runner . logger (  )  . info (  (  \" args :     \"     +     ( toString ( args )  )  )  )  ;", "Runner . logger (  )  . info (  (  (  (  \" destFolder :     \"     +    destFolder )     +     \"  ,    case - sensitive :     \"  )     +     ( Runner . ourCaseSensitiveFs )  )  )  ;", "UpdaterUI   ui ;", "if    (  \" install \"  . equals ( args [  0  ]  )  )     {", "ui    =    new   SwingUpdaterUI (  )  ;", "} else", "if    ( Runner . hasArgument ( args ,     \" toolbox - ui \"  )  )     {", "ui    =    new   ToolboxUpdaterUI (  )  ;", "} else    {", "ui    =    new   ConsoleUpdaterUI (  )  ;", "}", "boolean   backup    =     !  ( Runner . hasArgument ( args ,     \" no - backup \"  )  )  ;", "boolean   success    =    Runner . install ( jarFile ,    destFolder ,    ui ,    backup )  ;", "System . exit (  ( success    ?     0     :     1  )  )  ;", "} else    {", "Runner . printUsage (  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "StringWriwri =    new   StringWri )  ;", "t . printStackTrace ( new   PrintWriwri )  ;", "return   writoString (  )  ;", "}", "METHOD_END"], "methodName": ["printStackTrace"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "System . err . println (  (  \" Usage :  \\ n \"     +     (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  (  \"       Runner   create    < old _ version >     < new _ version >     < old _ folder >     < new _ folder >     < patch _ file >     [  < file _ set >  = file 1  ; file 2  ;  .  .  .  ]     [  < flags >  ]  \\ n \"     +     \"       Runner   install    < folder >  \\ n \"  )     +     \"  \\ n \"  )     +     \" Where :  \\ n \"  )     +     \"        < old _ version >  :    A   description   of   the   version   to   generate   the   patch   from .  \\ n \"  )     +     \"        < new _ version >  :    A   description   of   the   version   to   generate   the   patch   to .  \\ n \"  )     +     \"        < old _ folder >  :    The   folder   where   to   find   the   old   version .  \\ n \"  )     +     \"        < new _ folder >  :    The   folder   where   to   find   the   new   version .  \\ n \"  )     +     \"        < patch _ file >  :    The    . jar   patch   file   to   create   which   contains   the   patch   and   the   patcher .  \\ n \"  )     +     \"        < file _ set >  :    Can   be   one   of :  \\ n \"  )     +     \"             ignored :    The   set   of   files   that   will   not   be   included   in   the   patch .  \\ n \"  )     +     \"             critical :    Fully   included   in   the   patch ,    so   they   can   be   replaced   at   destination   even   if   they   have   changed .  \\ n \"  )     +     \"             optional :    A   set   of   files   that   is   ok   for   them   no   to   exist   when   applying   the   patch .  \\ n \"  )     +     \"             delete :    A   set   of   regular   expressions   for   paths   that   is   safe   to   delete   without   user   confirmation .  \\ n \"  )     +     \"        < flags >  :    Can   be :  \\ n \"  )     +     \"              -  - zip _ as _ binary :    Zip   and   jar   files   will   be   treated   as   binary   files   and   not   inspected   internally .  \\ n \"  )     +     \"              -  - strict :    The   created   patch   will   contain   extra   information   to   fully   validate   an   installation .    A   strict \\ n \"  )     +     \"                                           patch   will   only   be   applied   if   it   is   guaranteed   that   the   patched   version   will   match   exactly \\ n \"  )     +     \"                                           the   source   of   the   patch .    This   means   that   unexpected   files   will   be   deleted   and   all   existing   files \\ n \"  )     +     \"                                           will   be   validated \\ n \"  )     +     \"              -  - root =  < dir >  :    Sets   dir   as   the   root   directory   of   the   patch .    The   root   directory   is   the   directory   where   the   patch   should   be \"  )     +     \"                                                       applied   to .    For   example   on   Mac ,    you   can   diff   the   two    . app   folders   and   set   Contents   as   the   root .  \"  )     +     \"                                                       The   root   directory   is   relative   to    < old _ folder >    and   uses   forwards - slashes   as   separators .  \"  )     +     \"              -  - normalized :    This   creates   a   normalized   patch .    This   flag   only   makes   sense   in   addition   to    -  - zip _ as _ binary \\ n \"  )     +     \"                                                       A   normalized   patch   must   be   used   to   move   from   an   installation   that   was   patched \\ n \"  )     +     \"                                                       in   a   non - binary   way   to   a   fully   binary   patch .    This   will   yield   a   larger   patch ,    but   the \\ n \"  )     +     \"                                                       generated   patch   can   be   applied   on   versions   where   non - binary   patches   have   been   applied   to   and   it \\ n \"  )     +     \"                                                       guarantees   that   the   patched   version   will   match   exactly   the   original   one .  \\ n \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["printUsage"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "URL   url    =    Runner . class . getResource (  \"  \"  )  ;", "if    ( url    =  =    null )", "throw   new   IllegalArgumentException (  \" Cannot   resolve   JAR   file   path \"  )  ;", "if    (  !  (  \" jar \"  . equals ( url . getProtocol (  )  )  )  )", "throw   new   IllegalArgumentException (  \" Patch   file   is   not   a   JAR   file \"  )  ;", "String   path    =    url . getPath (  )  ;", "int   start    =    path . indexOf (  \" file :  /  \"  )  ;", "int   end    =    path . indexOf (  \"  !  /  \"  )  ;", "if    (  ( start    =  =     (  -  1  )  )     |  |     ( end    =  =     (  -  1  )  )  )", "throw   new   IllegalArgumentException (  (  \" Unknown   protocol :     \"     +    url )  )  ;", "String   jarFileUrl    =    path . substring ( start ,    end )  ;", "try    {", "return   new   File ( new   URI ( jarFileUrl )  )  . getAbsolutePath (  )  ;", "}    catch    ( URISyntaxException   e )     {", "throw   new   IllegalArgumentException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["resolveJarFile"], "fileName": "com.intellij.updater.Runner"}, {"methodBody": ["METHOD_START", "{", "String [  ]    args    =    new   String [  ]  {     \" bar \"  ,     \" ignored = xxx ; yyy ; zzz / zzz \"  ,     \" critical =  \"  ,     \" ignored = aaa \"  ,     \" baz \"  ,     \" critical = ccc \"     }  ;", "assertThat (  . extractArguments ( args ,     \" ignored \"  )  )  . containsExactly (  \" xxx \"  ,     \" yyy \"  ,     \" zzz / zzz \"  ,     \" aaa \"  )  ;", "assertThat (  . extractArguments ( args ,     \" critical \"  )  )  . containsExactly (  \" ccc \"  )  ;", "assertThat (  . extractArguments ( args ,     \" unknown \"  )  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["testExtractingFiles"], "fileName": "com.intellij.updater.RunnerTest"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( myCancelled )  )     {", "myPaused    =    true ;", "String   message    =     \" The   patch   has   not   been   applied   yet .  \\ nAre   you   sure   you   want   to   abort   the   operation ?  \"  ;", "int   result    =    JOptionPane . showConfirmDialog ( myFrame ,    message ,     . TITLE ,    JOptionPane . YES _ NO _ OPTION )  ;", "if    ( result    =  =     ( JOptionPane . YES _ OPTION )  )     {", "myCancelled    =    true ;", "myCancelButton . setEnabled ( false )  ;", "}", "myPaused    =    false ;", "}", "}", "METHOD_END"], "methodName": ["doCancel"], "fileName": "com.intellij.updater.SwingUpdaterUI"}, {"methodBody": ["METHOD_START", "{", "try    {", "tilities . invokeAndWait ( runnable )  ;", "}    catch    ( InterruptedException    |    InvocationTargetException   e )     {", "throw   new   RuntimeException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["invokeAndWait"], "fileName": "com.intellij.updater.SwingUpdaterUI"}, {"methodBody": ["METHOD_START", "{", "SwingUtilities . invokeLater ( runnable )  ;", "}", "METHOD_END"], "methodName": ["invokeLater"], "fileName": "com.intellij.updater.SwingUpdaterUI"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( Case . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   CreateAction ( patch ,     \" Readme . link \"  )  )  ;", "}", "METHOD_END"], "methodName": ["create"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( Case . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" Readme . link \"  ,    CHECKSUMS . LINK _ TO _ README _ TXT )  )  ;", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . lnk \"  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( Case . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" Readme . lnk \"  ,    CHECKSUMS . LINK _ TO _ README _ TXT )  ,    new   CreateAction ( patch ,     \" Readme . link \"  )  )  ;", "}", "METHOD_END"], "methodName": ["rename"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \"  .  / Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . lnk \"  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( Case . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" Readme . lnk \"  ,    CHECKSUMS . LINK _ TO _ DOT _ README _ TXT )  ,    new   CreateAction ( patch ,     \" Readme . link \"  )  )  ;", "}", "METHOD_END"], "methodName": ["renameAndRetarget"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "Utils . createLink (  \"  .  / Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "Patch   patch    =    createPatch (  )  ;", "assertThat ( Case . sortActions ( patch . getActions (  )  )  )  . containsExactly ( new   DeleteAction ( patch ,     \" Readme . link \"  ,    CHECKSUMS . LINK _ TO _ README _ TXT )  ,    new   CreateAction ( patch ,     \" Readme . link \"  )  )  ;", "}", "METHOD_END"], "methodName": ["retarget"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myOlderDir ,     \" Readme . link \"  )  )  ;", "Utils . createLink (  \" Readme . txt \"  ,    new   File ( myNewerDir ,     \" Readme . link \"  )  )  ;", "assertThat ( create (  )  . getActions (  )  )  . containsExactly (  )  ;", "}", "METHOD_END"], "methodName": ["same"], "fileName": "com.intellij.updater.SymlinkPatchTest"}, {"methodBody": ["METHOD_START", "{", "ZipFile   zip ;", "try    {", "zip    =    new   ZipFile ( file )  ;", "}    catch    ( IOExcep   e )     {", "throw   new   IOExcep (  (  \" Corrupted   file :     \"     +    file )  ,    e )  ;", "}", "try    {", "Set < String >    processed    =    new   HashSet <  >  (  )  ;", "Enumera <  ?    extends   ZipEntry >    entries    =    zip . entries (  )  ;", "while    ( entries . hasMoreElements (  )  )     {", "ZipEntry   inEntry    =    entries . nextElement (  )  ;", "if    ( inEntry . isDirectory (  )  )", "continue ;", "if    ( processed . contains ( inEntry . getName (  )  )  )     {", "throw   new   IOExcep (  (  (  (  \" Duplicate   entry    '  \"     +     ( inEntry . getName (  )  )  )     +     \"  '    in    \"  )     +     ( file . getPath (  )  )  )  )  ;", "}", "try    ( InputStream   in    =    new   BufferedInputStream ( zip . getInputStream ( inEntry )  )  )     {", "processor . process ( inEntry ,    new   BufferedInputStream ( in )  )  ;", "processed . add ( inEntry . getName (  )  )  ;", "}", "}", "}    finally    {", "zip . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["processZipFile"], "fileName": "com.intellij.updater.UpdateZipAction"}, {"methodBody": ["METHOD_START", "{", "return   new   File ( tempDir . getRoot (  )  ,    fileName )  ;", "}", "METHOD_END"], "methodName": ["getTempFile"], "fileName": "com.intellij.updater.UpdaterTestCase"}, {"methodBody": ["METHOD_START", "{", "dataDir    =    PathManagerEx . findFileUnderCommunityHome (  \" updater / testData \"  )  ;", "Runner . checkCaseSensitivity ( dataDir . getPath (  )  )  ;", "Runner . initTestLogger (  )  ;", "TEST _ UI    =    new    . TestUpdaterUI (  )  ;", "boolean   windowsLineEnds    =     ( new   File ( dataDir ,     \" Readme . txt \"  )  . length (  )  )     =  =     7  1  3  2  ;", "CHECKSUMS    =    new    . CheckSums ( windowsLineEnds )  ;", "}", "METHOD_END"], "methodName": ["setUp"], "fileName": "com.intellij.updater.UpdaterTestCase"}, {"methodBody": ["METHOD_START", "{", "Utils . cleanup (  )  ;", "}", "METHOD_END"], "methodName": ["tearDown"], "fileName": "com.intellij.updater.UpdaterTestCase"}, {"methodBody": ["METHOD_START", "{", "return   text ;", "}", "METHOD_END"], "methodName": ["bold"], "fileName": "com.intellij.updater.UpdaterUI"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Utils . myTempDir )     =  =    null )", "return ;", "Utils . delete ( Utils . myTempDir )  ;", "Runner . logger (  )  . info (  (  \" deleted   working   directory :     \"     +     ( Utils . myTempDir . getPath (  )  )  )  )  ;", "Utils . myTempDir    =    null ;", "}", "METHOD_END"], "methodName": ["cleanup"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "LinkedHashSet < String >    result    =    new   LinkedHashSet <  >  (  )  ;", ". collectRelativePaths ( dir ,    result ,    null )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["collectRelativePaths"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "File [  ]    children    =    dir . listFiles (  )  ;", "if    ( children    =  =    null )", "return ;", "for    ( File   each    :    children )     {", "String   relativePath    =     ( parentPath    =  =    null    ?     \"  \"     :    parentPath    +     '  /  '  )     +     ( each . getName (  )  )  ;", "if    ( each . isDirectory (  )  )     {", "result . add (  ( relativePath    +     '  /  '  )  )  ;", ". collectRelativePaths ( each ,    result ,    relativePath )  ;", "} else    {", "result . add ( relativePath )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["collectRelativePaths"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( from . exists (  )  )  )", "throw   new   IOException (  (  \" Source   does   not   exist :     \"     +    from )  )  ;", "if    (  . isLink ( from )  )     {", "if    ( to . exists (  )  )", "throw   new   IOException (  (  \" Target   already   exists :     \"     +    to )  )  ;", "Runner . logger (  )  . info (  (  (  (  \" Link :     \"     +     ( from . getPath (  )  )  )     +     \"    to    \"  )     +     ( to . getPath (  )  )  )  )  ;", "File   dir    =    to . getParentFile (  )  ;", "if    (  !  (  ( dir . isDirectory (  )  )     |  |     ( dir . mkdirs (  )  )  )  )", "throw   new   IOException (  (  \" Cannot   create :     \"     +    dir )  )  ;", ". createLink (  . readLink ( from )  ,    to )  ;", "} else", "if    ( from . isDirectory (  )  )     {", "Runner . logger (  )  . info (  (  (  (  \" Dir :     \"     +     ( from . getPath (  )  )  )     +     \"    to    \"  )     +     ( to . getPath (  )  )  )  )  ;", "if    (  !  (  ( to . mkdirs (  )  )     |  |     ( to . isDirectory (  )  )  )  )", "throw   new   IOException (  (  \" Cannot   create :     \"     +    to )  )  ;", "} else    {", "if    ( to . exists (  )  )", "throw   new   IOException (  (  \" Target   already   exists :     \"     +    to )  )  ;", "Runner . logger (  )  . info (  (  (  (  \" File :     \"     +     ( from . getPath (  )  )  )     +     \"    to    \"  )     +     ( to . getPath (  )  )  )  )  ;", "File   dir    =    to . getParentFile (  )  ;", "if    (  !  (  ( dir . isDirectory (  )  )     |  |     ( dir . mkdirs (  )  )  )  )", "throw   new   IOException (  (  \" Cannot   create :     \"     +    dir )  )  ;", "try    ( InputStream   in    =    new   BufferedInputStream ( new   FileInputStream ( from )  )  )     {", ". copyStreamToFile ( in ,    to )  ;", "}", "if    (  . isExecutable ( from )  )     {", ". setExecutable ( to )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["copy"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "try    ( InputStream   in    =    new   BufferedInputStream ( new   FileInputStream ( from )  )  )     {", ". copyStream ( in ,    out )  ;", "}", "}", "METHOD_END"], "methodName": ["copyFileToStream"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "while    ( true )     {", "int   read    =    from . read (  . BUFFER )  ;", "if    ( read    <     0  )", "break ;", "to . write (  . BUFFER ,     0  ,    read )  ;", "}", "}", "METHOD_END"], "methodName": ["copyStream"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "File   directory    =    to . getParentFile (  )  ;", "if    (  !  (  ( directory . isDirectory (  )  )     |  |     ( directory . mkdirs (  )  )  )  )     {", "throw   new   IOException (  (  \" Cannot   create :     \"     +    directory )  )  ;", "}", "try    ( OutputStream   out    =    new   BufferedOutputStream ( new   FileOutputStream ( to )  )  )     {", ". copyStream ( from ,    out )  ;", "}", "}", "METHOD_END"], "methodName": ["copyStreamToFile"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "Path   path    =    link . toPath (  )  ;", "Files . deleteIfExists ( path )  ;", "Files . creSymbolicLink ( path ,    Paths . get ( target )  )  ;", "}", "METHOD_END"], "methodName": ["createLink"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "Path   start    =    file . toPath (  )  ;", "if    ( Files . exists ( start ,    LinkOption . NOFOLLOW _ LINKS )  )     {", "Files . walkFileTree ( start ,    new   SimpleFileVisitor < Path >  (  )     {", "@ Override", "public   FileVisitResult   visitFile ( Path   file ,    BasicFileAttributes   attrs )    throws   IOException    {", ". tryDelete ( file )  ;", "return   FileVisitResult . CONTINUE ;", "}", "@ Override", "public   FileVisitResult   postVisitDirectory ( Path   dir ,    IOException   exc )    throws   IOException    {", ". tryDelete ( dir )  ;", "return   FileVisitResult . CONTINUE ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["delete"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "String   dir    =    System . getProperty (  \" idea . updater . log \"  )  ;", "if    (  ( dir    =  =    null )     |  |     (  !  ( Utils . isValidDir ( dir ,    requiredFreeSpace )  )  )  )     {", "dir    =    System . getProperty (  \" tmpdir \"  )  ;", "if    (  !  ( Utils . isValidDir ( dir ,    requiredFreeSpace )  )  )     {", "dir    =    System . getProperty (  \" user . home \"  )  ;", "}", "}", "return   dir ;", "}", "METHOD_END"], "methodName": ["findDirectory"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "ZipEntry   entry    =    zipFile . getEntry ( entryPath )  ;", "return   entry    !  =    null    ?     . findEntryInputStreamForEntry ( zipFile ,    entry )     :    null ;", "}", "METHOD_END"], "methodName": ["findEntryInputStream"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "if    ( entry . isDirectory (  )  )", "return   null ;", "if    (  ( zipFile . getEntry (  (  ( entry . getName (  )  )     +     \"  /  \"  )  )  )     !  =    null )", "return   null ;", "return   new   BufferedInputStream ( zipFile . getInputStream ( entry )  )  ;", "}", "METHOD_END"], "methodName": ["findEntryInputStreamForEntry"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "ZipEntry   entry    =    Utils . getZipEntry ( zipFile ,    entryPath )  ;", "return   Utils . findEntryInputStreamForEntry ( zipFile ,    entry )  ;", "}", "METHOD_END"], "methodName": ["getEntryInputStream"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "if    (  ( Utils . myTempDir )     =  =    null )     {", "Utils . myTempDir    =    Files . createTempDirectory ( Paths . get ( Utils . findDirectory ( Utils . REQUIRED _ FREE _ SPACE )  )  ,     \" ideafiles .  \"  )  . toFile (  )  ;", "Runner . logger (  )  . info (  (  \" created   working   directory :     \"     +     ( Utils . myTempDir )  )  )  ;", "}", "File   myTempFile ;", "int   index    =     0  ;", "do    {", "myTempFile    =    new   File ( Utils . myTempDir ,     (  ( name    +     \"  . tmp .  \"  )     +     ( index +  +  )  )  )  ;", "}    while    ( myTempFile . exists (  )     )  ;", "return   myTempFile ;", "}", "METHOD_END"], "methodName": ["getTempFile"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "ZipEntry   entry    =    zipFile . getEntry ( entryPath )  ;", "if    ( entry    =  =    null )", "throw   new   IOException (  (  (  \" Entry    \"     +    entryPath )     +     \"    not   found \"  )  )  ;", "Runner . logger (  ) fo (  (  \" entryPath :     \"     +    entryPath )  )  ;", "return   entry ;", "}", "METHOD_END"], "methodName": ["getZipEntry"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "return   file . canExecute (  )  ;", "}", "METHOD_END"], "methodName": ["isExecutable"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "return   Files . isSymbolicLink ( file . toPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["isLink"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "File   dir    =    new   File ( path )  ;", "return    (  ( dir . isDirectory (  )  )     &  &     ( dir . canWrite (  )  )  )     &  &     (  ( dir . getUsableSpace (  )  )     >  =    space )  ;", "}", "METHOD_END"], "methodName": ["isValidDir"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "return    ( fileName . endsWith (  \"  . zip \"  )  )     |  |     ( fileName . endsWith (  \"  . jar \"  )  )  ;", "}", "METHOD_END"], "methodName": ["isZipFile"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "return   normalize    &  &     ( Utils . isZipFile ( file . getName (  )  )  )     ?    new   Utils . NormalizedZipInputStream ( file )     :    new   FileInputStream ( file )  ;", "}", "METHOD_END"], "methodName": ["newFileInputStream"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "try    {", "Thread . sleep ( mis )  ;", "}    catch    ( InterruptedException   ignore )     {", "}", "}", "METHOD_END"], "methodName": ["pause"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   byteOut    =    new   ByteArrayOutputStream (  )  ;", ". copyStream ( in ,    byteOut )  ;", "return   byteOut . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    bytes    =    new   byte [ count ]  ;", "offset    =     0  ;", "while    ( offset    <    count )     {", "n    =    in . read ( bytes ,    offset ,     ( count    -    offset )  )  ;", "if    ( n    <     0  )", "throw   new   IOException (  \" Premature   end   of   stream \"  )  ;", "offset    +  =    n ;", "}", "return   bytes ;", "}", "METHOD_END"], "methodName": ["readBytes"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "return   Files . readSymbolicLink ( link . toPath (  )  )  . toString (  )  ;", "}", "METHOD_END"], "methodName": ["readLink"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "Runner . logger (  )  . info (  (  \" Setting   executable   permissions   for :     \"     +    file )  )  ;", "if    (  !  ( file . setExecutable ( true ,    false )  )  )     {", "throw   new   IOException (  (  \" Cannot   set   executable   permissions   for :     \"     +    file )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setExecutable"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     1  0  ;    i +  +  )     {", "try    {", "if    (  ( Files . deleteIfExists ( path )  )     |  |     (  !  ( Files . exists ( path )  )  )  )     {", "Runner . logger (  )  . info (  (  \" deleted :     \"     +    path )  )  ;", "return ;", "}", "}    catch    ( AccessDeniedException   e )     {", "try    {", "DosFileAttributeView   view    =    Files . getFileAttributeView ( path ,    DosFileAttributeView . class )  ;", "if    (  ( view    !  =    null )     &  &     ( view . readAttributes (  )  . isReadOnly (  )  )  )     {", "view . setReadOnly ( false )  ;", "continue ;", "}", "}    catch    ( IOException   ignore )     {", "}", "}    catch    ( IOException   ignore )     {", "}", ". pause (  1  0  )  ;", "}", "throw   new   IOException (  (  \" Cannot   delete :     \"     +    path )  )  ;", "}", "METHOD_END"], "methodName": ["tryDelete"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "int   offset    =     0  ;", "while    ( offset    <    length )     {", "int   chunkSize    =    Math . min (  . BUFFER _ SIZE ,     ( length    -    offset )  )  ;", "to . write ( from ,    offset ,    chunkSize )  ;", "offset    +  =    chunkSize ;", "}", "}", "METHOD_END"], "methodName": ["writeBytes"], "fileName": "com.intellij.updater.Utils"}, {"methodBody": ["METHOD_START", "{", "Runner . initTestLogger (  )  ;", "}", "METHOD_END"], "methodName": ["initLogger"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "File   f    =    tempDir . newFile (  \" temp _ file \"  )  ;", "assertTrue ( f . exists (  )  )  ;", ". delete ( f )  ;", "assertFalse ( f . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDelete"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "File   dir    =    tempDir . newFolder (  \" temp _ dir \"  )  ;", "File   link    =    new   File ( dir ,     \" link \"  )  ;", "Utils . createLink (  \" dangling \"  ,    link )  ;", "assertThat ( dir . listFiles (  )  )  . containsExactly ( link )  ;", "Utils . delete ( link )  ;", "assertThat ( dir . listFiles (  )  )  . isEmpty (  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteDanglingSymlink"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "File   f    =    tempDir . newFile (  \" temp _ file \"  )  ;", "assertTrue ( f . exists (  )  )  ;", "try    ( FileWriter   fw    =    new   FileWriter ( f )  )     {", "fw . write (  \" test \"  )  ;", "Utils . delete ( f )  ;", "}", "}", "METHOD_END"], "methodName": ["testDeleteLockedFileOnUnix"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue ( UtilsTest . IS _ WINDOWS )  ;", "File   f    =    tempDir . newFile (  \" temp _ file \"  )  ;", "assertTrue ( f . exists (  )  )  ;", "long   ts    =     0  ;", "try    ( FileWriter   fw    =    new   FileWriter ( f )  )     {", "fw . write (  \" test \"  )  ;", "ts    =    System . nanoTime (  )  ;", "Utils . delete ( f )  ;", "fail (  \" Utils . delete   did   not   fail   with   the   expected   IOException   on   Windows \"  )  ;", "}    catch    ( IOException   e )     {", "ts    =     (  ( System . nanoTime (  )  )     -    ts )     /     1  0  0  0  0  0  0  ;", "assertEquals (  (  \" Cannot   delete :     \"     +     ( f . getAbsolutePath (  )  )  )  ,    e . getMessage (  )  )  ;", "assertThat ( ts )  . as (  (  (  \" Utils . delete   took    \"     +    ts )     +     \"    ms ,    which   is   less   than   expected \"  )  )  . isGreaterThanOrEqualTo (  9  5  )  ;", "}", "}", "METHOD_END"], "methodName": ["testDeleteLockedFileOnWindows"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "File   f    =    tempDir . newFile (  \" temp _ dir / temp _ file \"  )  ;", "assertTrue ( f . setWritable ( false ,    false )  )  ;", "File   d    =    f . getParentFile (  )  ;", "assertTrue ( d . exists (  )  )  ;", ". delete ( d )  ;", "assertFalse ( d . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testDeleteReadonlyFile"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "assumeTrue (  (  !  ( UtilsTest . IS _ WINDOWS )  )  )  ;", "File   dir    =    tempDir . newFolder (  \" temp _ dir \"  )  ;", "File   file    =    new   File ( dir ,     \" file \"  )  ;", "FileUtil . writeToFile ( file ,     \" test \"  )  ;", "assertThat ( dir . listFiles (  )  )  . containsExactly ( file )  ;", "File   link    =    new   File ( tempDir . getRoot (  )  ,     \" link \"  )  ;", "Utils . createLink ( dir . getName (  )  ,    link )  ;", "assertTrue ( Utils . isLink ( link )  )  ;", "assertThat ( link . listFiles (  )  )  . hasSize (  1  )  ;", "Utils . delete ( link )  ;", "assertFalse ( link . exists (  )  )  ;", "assertThat ( dir . listFiles (  )  )  . containsExactly ( file )  ;", "}", "METHOD_END"], "methodName": ["testNonRecursiveSymlinkDelete"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "File   topDir    =    tempDir . newFolder (  \" temp _ dir \"  )  ;", "for    ( int   i    =     0  ;    i    <     3  ;    i +  +  )     {", "for    ( int   j    =     0  ;    j    <     3  ;    j +  +  )     {", "File   file    =    new   File ( topDir ,     (  (  (  \" dir \"     +    i )     +     \"  / file \"  )     +    j )  )  ;", "FileUtil . writeToFile ( file ,     \" test \"  )  ;", "assertTrue ( file . exists (  )  )  ;", "}", "}", ". delete ( topDir )  ;", "assertFalse ( topDir . exists (  )  )  ;", "}", "METHOD_END"], "methodName": ["testRecursiveDelete"], "fileName": "com.intellij.updater.UtilsTest"}, {"methodBody": ["METHOD_START", "{", "return   path . compareToIgnoreCase ( o . path )  ;", "}", "METHOD_END"], "methodName": ["compareTo"], "fileName": "com.intellij.updater.ValidationResult"}, {"methodBody": ["METHOD_START", "{", "File   sourceJar    =    new   File ( myOlderDir ,     \" lib / empty . jar \"  )  ;", "FileUtil . writeToFile ( sourceJar ,     \" x \"  )  ;", "try    {", "File   targetJar    =    new   File ( myNewerDir ,     \" lib / empty . jar \"  )  ;", "FileUtil . copy ( new   File ( myNewerDir ,     \" lib / annotations . jar \"  )  ,    targetJar )  ;", "try    {", "creat (  )  ;", "fail (  \" Should   have   failed   to   create   a   patch   from   empty    . jar \"  )  ;", "}    catch    ( IOException   e )     {", "assertEquals (  (  \" Corrupted   file :     \"     +    sourceJar )  ,    e . getMessage (  )  )  ;", "}    finally    {", "FileUtil . delete ( targetJar )  ;", "}", "}    finally    {", "FileUtil . delete ( sourceJar )  ;", "}", "}", "METHOD_END"], "methodName": ["failOnEmptySourceJar"], "fileName": "com.intellij.updater.ZipAwarePatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "File   sourceJar    =    new   File ( myOlderDir ,     \" lib / empty . jar \"  )  ;", "FileUtil . copy ( new   File ( myOlderDir ,     \" lib / annotations . jar \"  )  ,    sourceJar )  ;", "try    {", "File   targetJar    =    new   File ( myNewerDir ,     \" lib / empty . jar \"  )  ;", "FileUtil . writeToFile ( targetJar ,     \" x \"  )  ;", "try    {", "creat (  )  ;", "fail (  \" Should   have   failed   to   create   a   patch   against   empty    . jar \"  )  ;", "}    catch    ( IOException   e )     {", "assertEquals (  (  \" Corrupted   file :     \"     +    targetJar )  ,    e . getMessage (  )  )  ;", "}    finally    {", "FileUtil . delete ( targetJar )  ;", "}", "}    finally    {", "FileUtil . delete ( sourceJar )  ;", "}", "}", "METHOD_END"], "methodName": ["failOnEmptyTargetJar"], "fileName": "com.intellij.updater.ZipAwarePatchApplyingRevertingTest"}, {"methodBody": ["METHOD_START", "{", "if    ( isDir    &  &     (  !  ( relPath . endsWith (  \"  /  \"  )  )  )  )", "relPath    +  =     \"  /  \"  ;", "index    =     0  ;", "while    (  ( index    =    relPath . indexOf (  '  /  '  ,     ( index    +     1  )  )  )     !  =     (  -  1  )  )     {", "myDirs . add ( relPath . substring (  0  ,    index )  )  ;", "}", "}", "METHOD_END"], "methodName": ["addDirs"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "for    ( String   each    :    myDirs )     {", "if    (  !  ( each . endsWith (  \"  /  \"  )  )  )", "each    +  =     \"  /  \"  ;", "Entry   e    =    new   Entry ( each )  ;", "e . setMethod ( Entry . STORED )  ;", "e . setSize (  0  )  ;", "e . setCrc (  0  )  ;", "myOut . putNextEntry ( e )  ;", "myOut . closeEntry (  )  ;", "}", "}", "METHOD_END"], "methodName": ["finish"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "addDirs ( entryPath ,    false )  ;", "ZipEntry   entry    =    new   ZipEntry ( entryPath )  ;", "if    (  !  ( myCompressed )  )     {", "entry . setSize ( byteOut . size (  )  )  ;", "CRC 3  2    crc    =    new   CRC 3  2  (  )  ;", "byteOutChecksum ( crc )  ;", "entry . setCrc ( crc . getValue (  )  )  ;", "}", "myOut . putNextEntry ( entry )  ;", "byteOut . writeTo ( myOut )  ;", "myOut . closeEntry (  )  ;", "}", "METHOD_END"], "methodName": ["zipBytes"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "ZipOutputWrapper . OptByteArrayOutputStream   tempOut    =    new   ZipOutputWrapper . OptByteArrayOutputStream (  )  ;", "Utils . copyStream ( from ,    tempOut )  ;", "zipBytes ( entryPath ,    tempOut )  ;", "}", "METHOD_END"], "methodName": ["zipEntry"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( entry . isDirectory (  )  )     {", "addDirs ( entry . getName (  )  ,    true )  ;", "} else    {", "zipEntry ( entry . getName (  )  ,    from )  ;", "}", "}", "METHOD_END"], "methodName": ["zipEntry"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "if    ( file . isDirectory (  )  )     {", "throw   new   IllegalArgumentException (  \" Doesn ' t   make   sense \"  )  ;", "}", "try    ( InStream   from    =    new   BufferedInStream ( new   FileInStream ( file )  )  )     {", "zipEntry ( new   ZipEntry ( entryPath )  ,    from )  ;", "}", "}", "METHOD_END"], "methodName": ["zipFile"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "return   new   ZipOutputWrapper . OptByteArrayOutputStream (  )     {", "@ Override", "public   void   close (  )    throws   IOException    {", "super . close (  )  ;", "zipBytes ( entryPath ,    this )  ;", "}", "}  ;", "}", "METHOD_END"], "methodName": ["zipStream"], "fileName": "com.intellij.updater.ZipOutputWrapper"}, {"methodBody": ["METHOD_START", "{", "byte [  ]    oldBuf    =    Utils . readBytes ( oldFileIn )  ;", "int   oldsize    =    oldBuf . length ;", "int [  ]    I    =    new   int [ oldsize    +     1  ]  ;", "int [  ]    V    =    new   int [ oldsize    +     1  ]  ;", ". qsufsort ( I ,    V ,    oldBuf )  ;", "V    =    null ;", "System . gc (  )  ;", "byte [  ]    newBuf    =    Utils . readBytes ( newFileIn )  ;", "int   newsize    =    newBuf . length ;", "int   dblen    =     0  ;", "byte [  ]    db    =    new   byte [ newsize ]  ;", "int   eblen    =     0  ;", "byte [  ]    eb    =    new   byte [ newsize ]  ;", "ByteArrayOutputStream   arrayOut    =    new   Utils . OpenByteArrayOutputStream (  )  ;", "DataOutputStream   diffOut    =    new   DataOutputStream ( arrayOut )  ;", "int   oldscore ;", "int   scsc ;", "int   overlap ;", "int   Ss ;", "int   lens ;", "int   i ;", "int   scan    =     0  ;", "int   len    =     0  ;", "int   lastscan    =     0  ;", "int   lastpos    =     0  ;", "int   lastoffset    =     0  ;", ". IntByRef   pos    =    new    . IntByRef (  )  ;", "int   ctrlBlockLen    =     0  ;", "while    ( scan    <    newsize )     {", "oldscore    =     0  ;", "for    ( scsc    =    scan    +  =    len ;    scan    <    newsize ;    scan +  +  )     {", "len    =     . search ( I ,    oldBuf ,    newBuf ,    scan ,     0  ,    oldsize ,    pos )  ;", "for    (  ;    scsc    <     ( scan    +    len )  ;    scsc +  +  )     {", "if    (  (  ( scsc    +    lastoffset )     <    oldsize )     &  &     (  ( oldBuf [  ( scsc    +    lastoffset )  ]  )     =  =     ( newBuf [ scsc ]  )  )  )     {", "oldscore +  +  ;", "}", "}", "if    (  (  ( len    =  =    oldscore )     &  &     ( len    !  =     0  )  )     |  |     ( len    >     ( oldscore    +     8  )  )  )     {", "break ;", "}", "if    (  (  ( scan    +    lastoffset )     <    oldsize )     &  &     (  ( oldBuf [  ( scan    +    lastoffset )  ]  )     =  =     ( newBuf [ scan ]  )  )  )     {", "oldscore -  -  ;", "}", "}", "if    (  ( len    !  =    oldscore )     |  |     ( scan    =  =    newsize )  )     {", "int   s    =     0  ;", "int   Sf    =     0  ;", "int   lenf    =     0  ;", "for    ( i    =     0  ;     (  ( lastscan    +    i )     <    scan )     &  &     (  ( lastpos    +    i )     <    oldsize )  ;  )     {", "if    (  ( oldBuf [  ( lastpos    +    i )  ]  )     =  =     ( newBuf [  ( lastscan    +    i )  ]  )  )     {", "s +  +  ;", "}", "i +  +  ;", "if    (  (  ( s    *     2  )     -    i )     >     (  ( Sf    *     2  )     -    lenf )  )     {", "Sf    =    s ;", "lenf    =    i ;", "}", "}", "int   lenb    =     0  ;", "if    ( scan    <    newsize )     {", "s    =     0  ;", "int   Sb    =     0  ;", "for    ( i    =     1  ;     ( scan    >  =     ( lastscan    +    i )  )     &  &     (  ( pos . value )     >  =    i )  ;    i +  +  )     {", "if    (  ( oldBuf [  (  ( pos . value )     -    i )  ]  )     =  =     ( newBuf [  ( scan    -    i )  ]  )  )     {", "s +  +  ;", "}", "if    (  (  ( s    *     2  )     -    i )     >     (  ( Sb    *     2  )     -    lenb )  )     {", "Sb    =    s ;", "lenb    =    i ;", "}", "}", "}", "if    (  ( lastscan    +    lenf )     >     ( scan    -    lenb )  )     {", "overlap    =     ( lastscan    +    lenf )     -     ( scan    -    lenb )  ;", "s    =     0  ;", "Ss    =     0  ;", "lens    =     0  ;", "for    ( i    =     0  ;    i    <    overlap ;    i +  +  )     {", "if    (  ( newBuf [  (  (  ( lastscan    +    lenf )     -    overlap )     +    i )  ]  )     =  =     ( oldBuf [  (  (  ( lastpos    +    lenf )     -    overlap )     +    i )  ]  )  )     {", "s +  +  ;", "}", "if    (  ( newBuf [  (  ( scan    -    lenb )     +    i )  ]  )     =  =     ( oldBuf [  (  (  ( pos . value )     -    lenb )     +    i )  ]  )  )     {", "s -  -  ;", "}", "if    ( s    >    Ss )     {", "Ss    =    s ;", "lens    =    i    +     1  ;", "}", "}", "lenf    +  =    lens    -    overlap ;", "lenb    -  =    lens ;", "}", "for    ( i    =     0  ;    i    <    lenf ;    i +  +  )     {", "db [  ( dblen    +    i )  ]     =     (  ( byte )     (  ( newBuf [  ( lastscan    +    i )  ]  )     -     ( oldBuf [  ( lastpos    +    i )  ]  )  )  )  ;", "}", "for    ( i    =     0  ;    i    <     (  ( scan    -    lenb )     -     ( lastscan    +    lenf )  )  ;    i +  +  )     {", "eb [  ( eblen    +    i )  ]     =    newBuf [  (  ( lastscan    +    lenf )     +    i )  ]  ;", "}", "dblen    +  =    lenf ;", "eblen    +  =     ( scan    -    lenb )     -     ( lastscan    +    lenf )  ;", "diffOut . writeInt ( lenf )  ;", "diffOut . writeInt (  (  ( scan    -    lenb )     -     ( lastscan    +    lenf )  )  )  ;", "diffOut . writeInt (  (  (  ( pos . value )     -    lenb )     -     ( lastpos    +    lenf )  )  )  ;", "ctrlBlockLen    +  =     1  2  ;", "lastscan    =    scan    -    lenb ;", "lastpos    =     ( pos . value )     -    lenb ;", "lastoffset    =     ( pos . value )     -    scan ;", "}", "}", "GZIPOutputStream   gzOut ;", "gzOut    =    new   GZIPOutputStream ( diffOut )  ;", "gzOut . write ( db ,     0  ,    dblen )  ;", "gzOut . finish (  )  ;", "int   diffBlockLen    =     ( diffOut . size (  )  )     -    ctrlBlockLen ;", "gzOut    =    new   GZIPOutputStream ( diffOut )  ;", "gzOut . write ( eb ,     0  ,    eblen )  ;", "gzOut . finish (  )  ;", "diffOut . close (  )  ;", "DataOutputStream   headerStream    =    new   DataOutputStream ( diffFileOut )  ;", "headerStream . write (  \" jbdiff 4  0  \"  . getBytes ( StandardCharsets . US _ ASCII )  )  ;", "headerStream . writeLong ( ctrlBlockLen )  ;", "headerStream . writeLong ( diffBlockLen )  ;", "headerStream . writeLong ( newsize )  ;", "headerStream . flush (  )  ;", "arrayOut . writeTo ( diffFileOut )  ;", "return   newBuf ;", "}", "METHOD_END"], "methodName": ["bsdiff"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "int   end    =    JBDiff . min (  (  ( oldBuf . length )     -    oldOffset )  ,     (  ( newBuf . length )     -    newOffset )  )  ;", "int   i ;", "for    ( i    =     0  ;    i    <    end ;    i +  +  )     {", "if    (  ( oldBuf [  ( oldOffset    +    i )  ]  )     !  =     ( newBuf [  ( newOffset    +    i )  ]  )  )     {", "break ;", "}", "}", "return   i ;", "}", "METHOD_END"], "methodName": ["matchlen"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "return   x    <    y    ?    x    :    y ;", "}", "METHOD_END"], "methodName": ["min"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "int   oldsize    =    oldBuf . length ;", "int [  ]    buckets    =    new   int [  2  5  6  ]  ;", "int   i ;", "int   h ;", "int   len ;", "for    ( i    =     0  ;    i    <     2  5  6  ;    i +  +  )     {", "buckets [ i ]     =     0  ;", "}", "for    ( i    =     0  ;    i    <    oldsize ;    i +  +  )     {", "( buckets [  (  (  ( int )     ( oldBuf [ i ]  )  )     &     2  5  5  )  ]  )  +  +  ;", "}", "for    ( i    =     1  ;    i    <     2  5  6  ;    i +  +  )     {", "buckets [ i ]     +  =    buckets [  ( i    -     1  )  ]  ;", "}", "for    ( i    =     2  5  5  ;    i    >     0  ;    i -  -  )     {", "buckets [ i ]     =    buckets [  ( i    -     1  )  ]  ;", "}", "buckets [  0  ]     =     0  ;", "for    ( i    =     0  ;    i    <    oldsize ;    i +  +  )     {", "I [  (  +  +  ( buckets [  (  (  ( int )     ( oldBuf [ i ]  )  )     &     2  5  5  )  ]  )  )  ]     =    i ;", "}", "I [  0  ]     =    oldsize ;", "for    ( i    =     0  ;    i    <    oldsize ;    i +  +  )     {", "V [ i ]     =    buckets [  (  (  ( int )     ( oldBuf [ i ]  )  )     &     2  5  5  )  ]  ;", "}", "V [ oldsize ]     =     0  ;", "for    ( i    =     1  ;    i    <     2  5  6  ;    i +  +  )     {", "if    (  ( buckets [ i ]  )     =  =     (  ( buckets [  ( i    -     1  )  ]  )     +     1  )  )     {", "I [ buckets [ i ]  ]     =     -  1  ;", "}", "}", "I [  0  ]     =     -  1  ;", "for    ( h    =     1  ;     ( I [  0  ]  )     !  =     (  -  ( oldsize    +     1  )  )  ;    h    +  =    h )     {", "len    =     0  ;", "for    ( i    =     0  ;    i    <     ( oldsize    +     1  )  ;  )     {", "if    (  ( I [ i ]  )     <     0  )     {", "len    -  =    I [ i ]  ;", "i    -  =    I [ i ]  ;", "} else    {", "if    ( len    !  =     0  )     {", "I [  ( i    -    len )  ]     =     - len ;", "}", "len    =     (  ( V [ I [ i ]  ]  )     +     1  )     -    i ;", ". split ( I ,    V ,    i ,    len ,    h )  ;", "i    +  =    len ;", "len    =     0  ;", "}", "}", "if    ( len    !  =     0  )     {", "I [  ( i    -    len )  ]     =     - len ;", "}", "}", "for    ( i    =     0  ;    i    <     ( oldsize    +     1  )  ;    i +  +  )     {", "I [ V [ i ]  ]     =    i ;", "}", "}", "METHOD_END"], "methodName": ["qsufsort"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "int   x ;", "int   y ;", "if    (  ( end    -    start )     <     2  )     {", "x    =     . matchlen ( oldBuf ,    I [ start ]  ,    newBuf ,    newBufOffset )  ;", "y    =     . matchlen ( oldBuf ,    I [ end ]  ,    newBuf ,    newBufOffset )  ;", "if    ( x    >    y )     {", "pos . value    =    I [ start ]  ;", "return   x ;", "} else    {", "pos . value    =    I [ end ]  ;", "return   y ;", "}", "}", "x    =    start    +     (  ( end    -    start )     /     2  )  ;", "if    (  ( Util . memcmp ( oldBuf ,    I [ x ]  ,    newBuf ,    newBufOffset )  )     <     0  )     {", "return    . search ( I ,    oldBuf ,    newBuf ,    newBufOffset ,    x ,    end ,    pos )  ;", "} else    {", "return    . search ( I ,    oldBuf ,    newBuf ,    newBufOffset ,    start ,    x ,    pos )  ;", "}", "}", "METHOD_END"], "methodName": ["search"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "int   i ;", "int   j ;", "int   k ;", "int   x ;", "int   tmp ;", "int   jj ;", "int   kk ;", "if    ( len    <     1  6  )     {", "for    ( k    =    start ;    k    <     ( start    +    len )  ;    k    +  =    j )     {", "j    =     1  ;", "x    =    V [  (  ( I [ k ]  )     +    h )  ]  ;", "for    ( i    =     1  ;     ( k    +    i )     <     ( start    +    len )  ;    i +  +  )     {", "if    (  ( V [  (  ( I [  ( k    +    i )  ]  )     +    h )  ]  )     <    x )     {", "x    =    V [  (  ( I [  ( k    +    i )  ]  )     +    h )  ]  ;", "j    =     0  ;", "}", "if    (  ( V [  (  ( I [  ( k    +    i )  ]  )     +    h )  ]  )     =  =    x )     {", "tmp    =    I [  ( k    +    j )  ]  ;", "I [  ( k    +    j )  ]     =    I [  ( k    +    i )  ]  ;", "I [  ( k    +    i )  ]     =    tmp ;", "j +  +  ;", "}", "}", "for    ( i    =     0  ;    i    <    j ;    i +  +  )     {", "V [ I [  ( k    +    i )  ]  ]     =     ( k    +    j )     -     1  ;", "}", "if    ( j    =  =     1  )     {", "I [ k ]     =     -  1  ;", "}", "}", "return ;", "}", "x    =    V [  (  ( I [  ( start    +     ( len    /     2  )  )  ]  )     +    h )  ]  ;", "jj    =     0  ;", "kk    =     0  ;", "for    ( i    =    start ;    i    <     ( start    +    len )  ;    i +  +  )     {", "if    (  ( V [  (  ( I [ i ]  )     +    h )  ]  )     <    x )     {", "jj +  +  ;", "}", "if    (  ( V [  (  ( I [ i ]  )     +    h )  ]  )     =  =    x )     {", "kk +  +  ;", "}", "}", "jj    +  =    start ;", "kk    +  =    jj ;", "i    =    start ;", "j    =     0  ;", "k    =     0  ;", "while    ( i    <    jj )     {", "if    (  ( V [  (  ( I [ i ]  )     +    h )  ]  )     <    x )     {", "i +  +  ;", "} else", "if    (  ( V [  (  ( I [ i ]  )     +    h )  ]  )     =  =    x )     {", "tmp    =    I [ i ]  ;", "I [ i ]     =    I [  ( jj    +    j )  ]  ;", "I [  ( jj    +    j )  ]     =    tmp ;", "j +  +  ;", "} else    {", "tmp    =    I [ i ]  ;", "I [ i ]     =    I [  ( kk    +    k )  ]  ;", "I [  ( kk    +    k )  ]     =    tmp ;", "k +  +  ;", "}", "}", "while    (  ( jj    +    j )     <    kk )     {", "if    (  ( V [  (  ( I [  ( jj    +    j )  ]  )     +    h )  ]  )     =  =    x )     {", "j +  +  ;", "} else    {", "tmp    =    I [  ( jj    +    j )  ]  ;", "I [  ( jj    +    j )  ]     =    I [  ( kk    +    k )  ]  ;", "I [  ( kk    +    k )  ]     =    tmp ;", "k +  +  ;", "}", "}", "if    ( jj    >    start )     {", ". split ( I ,    V ,    start ,     ( jj    -    start )  ,    h )  ;", "}", "for    ( i    =     0  ;    i    <     ( kk    -    jj )  ;    i +  +  )     {", "V [ I [  ( jj    +    i )  ]  ]     =    kk    -     1  ;", "}", "if    ( jj    =  =     ( kk    -     1  )  )     {", "I [ jj ]     =     -  1  ;", "}", "if    (  ( start    +    len )     >    kk )     {", ". split ( I ,    V ,    kk ,     (  ( start    +    len )     -    kk )  ,    h )  ;", "}", "}", "METHOD_END"], "methodName": ["split"], "fileName": "ie.wombat.jbdiff.JBDiff"}, {"methodBody": ["METHOD_START", "{", "int   oldpos ;", "int   newpos ;", "byte [  ]    diffData    =    Utils . readBytes ( diffFileIn )  ;", "DataInputStream   diffIn    =    new   DataInputStream ( new   ByteArrayInputStream ( diffData )  )  ;", "long   headerMagic    =    diffIn . readLong (  )  ;", "long   ctrlBlockLen    =    diffIn . readLong (  )  ;", "long   diffBlockLen    =    diffIn . readLong (  )  ;", "int   newsize    =     (  ( int )     ( diffIn . readLong (  )  )  )  ;", "InputStream   in ;", "in    =    new   ByteArrayInputStream ( diffData )  ;", "in . skip (  ( ctrlBlockLen    +     3  2  )  )  ;", "GZIPInputStream   diffBlockIn    =    new   GZIPInputStream ( in )  ;", "in    =    new   ByteArrayInputStream ( diffData )  ;", "in . skip (  (  ( diffBlockLen    +    ctrlBlockLen )     +     3  2  )  )  ;", "GZIPInputStream   extraBlockIn    =    new   GZIPInputStream ( in )  ;", "final   byte [  ]    oldBuf    =     . realAllFileContent ( oldFileIn )  ;", "final   int   oldsize    =    oldBuf . length ;", "final   byte [  ]    newBuf    =    new   byte [  . block _ size ]  ;", "oldpos    =     0  ;", "newpos    =     0  ;", "while    ( newpos    <    newsize )     {", "final   int   bytesToReadFromDiffAndOld    =    diffIn . readInt (  )  ;", "final   int   bytesToReadFromExtraBlockIn    =    diffIn . readInt (  )  ;", "final   int   bytesToSkipFromOld    =    diffIn . readInt (  )  ;", "if    (  ( newpos    +    bytesToReadFromDiffAndOld )     >    newsize )     {", "System . err . println (  \" Corrupted   patch \\ n \"  )  ;", "return ;", "}", "int   nbytes    =     0  ;", "while    ( nbytes    <    bytesToReadFromDiffAndOld )     {", "int   nBytesFromDiff    =    diffBlockIn . read ( newBuf ,     0  ,    Math . min ( newBuf . length ,     ( bytesToReadFromDiffAndOld    -    nbytes )  )  )  ;", "if    ( nBytesFromDiff    <     0  )     {", "System . err . println (  \" error   reading   from   diffBlockIn \"  )  ;", "return ;", "}", "int   nbytesFromOld    =    Math . min ( nBytesFromDiff ,     ( oldsize    -    oldpos )  )  ;", "for    ( int   i    =     0  ;    i    <    nbytesFromOld ;     +  + i )     {", "newBuf [ i ]     +  =    oldBuf [  ( oldpos    +    i )  ]  ;", "}", "nbytes    +  =    nBytesFromDiff ;", "newpos    +  =    nBytesFromDiff ;", "oldpos    +  =    nBytesFromDiff ;", "Utils . writeBytes ( newBuf ,    nBytesFromDiff ,    newFileOut )  ;", "}", "if    ( bytesToReadFromExtraBlockIn    >     0  )     {", "if    (  ( newpos    +    bytesToReadFromExtraBlockIn )     >    newsize )     {", "System . err . println (  \" Corrupted   patch \"  )  ;", "return ;", "}", "nbytes    =     0  ;", "while    ( nbytes    <    bytesToReadFromExtraBlockIn )     {", "int   nBytesFromExtraBlockIn    =    extraBlockIn . read ( newBuf ,     0  ,    Math . min ( newBuf . length ,     ( bytesToReadFromExtraBlockIn    -    nbytes )  )  )  ;", "if    ( nBytesFromExtraBlockIn    <     0  )     {", "System . err . println (  \" error   reading   from   extraBlockIn \"  )  ;", "return ;", "}", "nbytes    +  =    nBytesFromExtraBlockIn ;", "newpos    +  =    nBytesFromExtraBlockIn ;", "Utils . writeBytes ( newBuf ,    nBytesFromExtraBlockIn ,    newFileOut )  ;", "}", "}", "oldpos    +  =    bytesToSkipFromOld ;", "}", "diffBlockIn . close (  )  ;", "extraBlockIn . close (  )  ;", "diffIn . close (  )  ;", "}", "METHOD_END"], "methodName": ["bspatch"], "fileName": "ie.wombat.jbdiff.JBPatch"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   oldFileByteOut    =    new   ByteArrayOutputStream ( Math . max ( oldFileIn . available (  )  ,     3  2  )  )  ;", "try    {", "Utils . copyStream ( oldFileIn ,    oldFileByteOut )  ;", "}    finally    {", "oldFileByteOut . close (  )  ;", "}", "return   oldFileByteOut . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["realAllFileContent"], "fileName": "ie.wombat.jbdiff.JBPatch"}, {"methodBody": ["METHOD_START", "{", "int   n    =     ( s 1  . length )     -    s 1 offset ;", "if    ( n    >     (  ( s 2  . length )     -    s 2 offset )  )     {", "n    =     ( s 2  . length )     -    s 2 offset ;", "}", "for    ( int   i    =     0  ;    i    <    n ;    i +  +  )     {", "if    (  ( s 1  [  ( i    +    s 1 offset )  ]  )     !  =     ( s 2  [  ( i    +    s 2 offset )  ]  )  )     {", "return    ( s 1  [  ( i    +    s 1 offset )  ]  )     <     ( s 2  [  ( i    +    s 2 offset )  ]  )     ?     -  1     :     1  ;", "}", "}", "return    0  ;", "}", "METHOD_END"], "methodName": ["memcmp"], "fileName": "ie.wombat.jbdiff.Util"}, {"methodBody": ["METHOD_START", "{", "int   totalBytesRead    =     0  ;", "int   nbytes ;", "whe    ( totalBytesRead    <    len )     {", "nbytes    =    in . read ( buf ,     ( offset    +    totalBytesRead )  ,     ( len    -    totalBytesRead )  )  ;", "if    ( nbytes    <     0  )     {", "System . err . println (  (  (  \" readFromStream (  )  :    returning   prematurely .    Read    \"     +    totalBytesRead )     +     \"    bytes \"  )  )  ;", "return   false ;", "}", "totalBytesRead    +  =    nbytes ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["readFromStream"], "fileName": "ie.wombat.jbdiff.Util"}]