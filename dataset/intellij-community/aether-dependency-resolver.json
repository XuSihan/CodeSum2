[{"fileName":"org.jetbrains.idea.maven.aether.ArtifactKind","methodName":["getClassifier"],"methodBody":["METHOD_START","{","return   myClassifier ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactKind","methodName":["getExtension"],"methodBody":["METHOD_START","{","return   myExtension ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["addRemoteRepository"],"methodBody":["METHOD_START","{","myRemoteRepositories . add ( ArtifactRepositoryManager . createRemoteRepository ( id ,    url )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["asVersion"],"methodBody":["METHOD_START","{","return   ArtifactRepositoryManager . ourVersioning . parseVersion (  ( str    \u003d  \u003d    null    ?     \"  \"     :    str )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["asVersionConstraint"],"methodBody":["METHOD_START","{","return   ArtifactRepositoryManager . ourVersioning . parseVersionConstraint (  ( str    \u003d  \u003d    null    ?     \"  \"     :    str )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["asVersionRange"],"methodBody":["METHOD_START","{","return   ArtifactRepositoryManager . ourVersioning . parseVersionRange (  ( str    \u003d  \u003d    null    ?     \"  \"     :    str )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["createCollectRequest"],"methodBody":["METHOD_START","{","final   CollectRequest   request    \u003d    new   CollectRequest (  )  ;","for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    versions ,    kinds )  )     {","request . addDependency ( new   org . eclipse . aether . graph . Dependency ( artifact ,    JavaScopes . COMPILE )  )  ;","}","return   request . setRepositories ( Collections . unmodifiableList ( myRemoteRepositories )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["createRemoteRepository"],"methodBody":["METHOD_START","{","return   new   RemoteRepository . Builder ( id ,     \" default \"  ,    url )  . setProxy ( ArtifactRepositoryManager . ourProxySelector . getProxy ( url )  )  . build (  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["createRemoteRepository"],"methodBody":["METHOD_START","{","final   String   url    \u003d    prototype . getUrl (  )  ;","return   new   RemoteRepository . Builder ( prototype . getId (  )  ,    prototype . getContentType (  )  ,    url )  . setProxy (  . ourProxySelector . getProxy ( url )  )  . build (  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["createVersionRangeRequest"],"methodBody":["METHOD_START","{","final   VersionRangeRequest   request    \u003d    new   VersionRangeRequest (  )  ;","for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    Collections . singleton ( versioning )  ,    EnumSet . of ( artifactKind )  )  )     {","request . setArtifact ( artifact )  ;","}","return   request . setRepositories ( Collections . unmodifiableList ( myRemoteRepositories )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["getAvailableVersions"],"methodBody":["METHOD_START","{","final   VersionRangeResult   result    \u003d    ArtifactRepositoryManager . ourSystem . resolveVersionRange ( mySession ,    createVersionRangeRequest ( groupId ,    artifactId ,    ArtifactRepositoryManager . asVersionConstraint ( versionConstraint )  ,    artifactKind )  )  ;","return   result . getVersions (  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["getClassesFromDependencies"],"methodBody":["METHOD_START","{","return   Arrays . asList ( ArtifactRepositoryManager . class ,    VersionsMetadataGeneratorFactory . class ,    Artifact . class ,    StringUtils . class ,    Base 6  4  . class ,    Problem . class ,    Model . class ,    ModelBuilder . class ,    Metadata . class ,    Component . class ,    Interpolator . class ,    RepositorySystem . class ,    BasicRepositoryConnectorFactory . class ,    RepositoryConnector . class ,    org . eclipse . aether . util . StringUtils . class ,    ArtifactResolver . class ,    FileTransporterFactory . class ,    HttpTransporterFactory . class ,    Predicate . class ,    HttpConnection . class ,    HttpClient . class ,    org . apache . commons . codec . binary . Base 6  4  . class ,    LogFactory . class ,    Marker . class )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["resolveDependency"],"methodBody":["METHOD_START","{","final   List \u003c File \u003e    files    \u003d    new   ArrayList \u003c  \u003e  (  )  ;","for    (    artifact    :    resolveDependencyAs ( groupId ,    artifactId ,    version ,    EnumSet . of ( Kind . ARTIFACT )  ,    includeTransitiveDependencies )  )     {","files . add ( artifact . getFile (  )  )  ;","}","return   files ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["resolveDependencyAsArtifact"],"methodBody":["METHOD_START","{","final   List \u003c Artifact \u003e    artifacts    \u003d    new   ArrayList \u003c  \u003e  (  )  ;","final   Set \u003c VersionConstraint \u003e    constraints    \u003d    Collections . singleton (  . asVersionConstraint ( versionConstraint )  )  ;","for    ( ArtifactKind   kind    :    artifactKinds )     {","try    {","final   List \u003c ArtifactRequest \u003e    requests ;","if    ( includeTransitiveDependencies )     {","final   CollectResult   collectResult    \u003d     . ourSystem . collectDependencies ( mySession ,    createCollectRequest ( groupId ,    artifactId ,    constraints ,    EnumSet . of ( kind )  )  )  ;","final    . ArtifactRequestBuilder   builder    \u003d    new    . ArtifactRequestBuilder ( kind )  ;","collectResult . getRoot (  )  . accept ( new   TreeDependencyVisitor ( new   org . eclipse . aether . util . graph . visitor . FilteringDependencyVisitor ( builder ,    DependencyFilterUtils . classpathFilter ( COMPILE )  )  )  )  ;","requests    \u003d    builder . getRequests (  )  ;","} else    {","requests    \u003d    new   ArrayList (  )  ;","for    ( Artifact   artifact    :     . toArtifacts ( groupId ,    artifactId ,    constraints ,    Collections . singleton ( kind )  )  )     {","requests . add ( new   ArtifactRequest ( artifact ,    Collections . unmodifiableList ( myRemoteRepositories )  ,    null )  )  ;","}","}","if    (  !  ( requests . isEmpty (  )  )  )     {","try    {","for    ( ArtifactResult   result    :     . ourSystem . resolveArtifacts ( mySession ,    requests )  )     {","artifacts . add ( result . getArtifact (  )  )  ;","}","}    catch    ( ArtifactResolutionException   e )     {","if    ( kind    !  \u003d     ( ArtifactKind . ARTIFACT )  )     {","if    (  ( requests . size (  )  )     \u003e     1  )     {","for    ( ArtifactRequest   request    :    requests )     {","try    {","final   ArtifactResult   result    \u003d     . ourSystem . resolveArtifact ( mySession ,    request )  ;","artifacts . add ( result . getArtifact (  )  )  ;","}    catch    ( ArtifactResolutionException   ignored )     {","}","}","}","} else    {","throw   e ;","}","}","}","}    catch    ( DependencyCollectionException   e )     {","if    ( kind    \u003d  \u003d     ( ArtifactKind . ARTIFACT )  )     {","throw   e ;","}","}","}","return   artifacts ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManager","methodName":["toArtifacts"],"methodBody":["METHOD_START","{","if    (  ( constraints . isEmpty (  )  )     |  |     ( kinds . isEmpty (  )  )  )     {","return   Collections . emptyList (  )  ;","}","final   List \u003c  \u003e    result    \u003d    new   java . util . ArrayList (  (  ( kinds . size (  )  )     *     ( constraints . size (  )  )  )  )  ;","for    ( Kind   kind    :    kinds )     {","for    ( VersionConstraint   constr    :    constraints )     {","result . add ( new   org . eclipse . aether . artifact . Default ( groupId ,    artifactId ,    kind . getClassifier (  )  ,    kind . getExtension (  )  ,    constr . toString (  )  )  )  ;","}","}","return   result ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManagerTest","methodName":["testResolveNonTransitively"],"methodBody":["METHOD_START","{","Collection \u003c File \u003e    files    \u003d    myRepositoryManager . resolveDependency (  \" junit \"  ,     \" junit \"  ,     \"  4  .  1  2  \"  ,    false )  ;","assertSameElements ( ContainerUtil . map ( files ,    File :  : getName )  ,     \" junit -  4  .  1  2  . jar \"  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ArtifactRepositoryManagerTest","methodName":["testResolveTransitively"],"methodBody":["METHOD_START","{","Collection \u003c File \u003e    files    \u003d    myRepositoryManager . resolveDependency (  \" junit \"  ,     \" junit \"  ,     \"  4  .  1  2  \"  ,    true )  ;","assertSameElements ( ContainerUtil . map ( files ,    File :  : getName )  ,     \" junit -  4  .  1  2  . jar \"  ,     \" hamcrest - core -  1  .  3  . jar \"  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.JreProxySelector","methodName":["chooseProxyType"],"methodBody":["METHOD_START","{","if    ( TYPE _ HTTP . equals ( protocol )  )     {","return   TYPE _ HTTP ;","}","if    ( TYPE _ HTTPS . equals ( protocol )  )     {","return   TYPE _ HTTPS ;","}","return   null ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.JreProxySelector","methodName":["getProxy"],"methodBody":["METHOD_START","{","try    {","final   ProxySelector   systemSelector    \u003d    ProxySelector . getDefault (  )  ;","if    ( systemSelector    \u003d  \u003d    null )     {","return   null ;","}","final   URI   uri    \u003d    new   URI ( url )  . parseServerAuthority (  )  ;","final   List \u003c Proxy \u003e    selected    \u003d    systemSelector . select ( uri )  ;","if    (  ( selected    \u003d  \u003d    null )     |  |     ( selected . isEmpty (  )  )  )     {","return   null ;","}","for    ( Proxy   proxy    :    selected )     {","if    (  (  ( proxy . type (  )  )     \u003d  \u003d     ( Proxy . Type . HTTP )  )     \u0026  \u0026     (  . isValid ( proxy . address (  )  )  )  )     {","final   String   proxyType    \u003d     . chooseProxyType ( uri . getScheme (  )  )  ;","if    ( proxyType    !  \u003d    null )     {","final   InetSocketAddress   addr    \u003d     (  ( InetSocketAddress )     ( proxy . address (  )  )  )  ;","return   new   Proxy ( proxyType ,    addr . getHostName (  )  ,    addr . getPort (  )  ,     . JreProxyAuthentication . INSTANCE )  ;","}","}","}","}    catch    ( Throwable   e )     {","}","return   null ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.JreProxySelector","methodName":["getProxy"],"methodBody":["METHOD_START","{","return   getProxy ( repository . getUrl (  )  )  ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.JreProxySelector","methodName":["isValid"],"methodBody":["METHOD_START","{","if    ( address   instanceof   InetSocketAddress )     {","final   InetSocketAddress   addr    \u003d     (  ( InetSocketAddress )     ( address )  )  ;","return    (  (  ( addr . getPort (  )  )     \u003e     0  )     \u0026  \u0026     (  ( addr . getHostName (  )  )     !  \u003d    null )  )     \u0026  \u0026     (  !  ( addr . getHostName (  )  . isEmpty (  )  )  )  ;","}","return   false ;","}","METHOD_END"]},{"fileName":"org.jetbrains.idea.maven.aether.ProgressConsumer","methodName":["isCanceled"],"methodBody":["METHOD_START","{","return   false ;","}","METHOD_END"]}]