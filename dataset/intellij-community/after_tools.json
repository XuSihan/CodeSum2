[{"methodBody": ["METHOD_START", "{", "buffer . write (  (  \"  \\ n \"     +    message )  )  ;", "}", "METHOD_END"], "methodName": ["_report"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "buffer . write (  (  (  (  \"  \\ n \"     +    name )     +     \"     :     \"  )     +     ( BitsUtil . byteToHexString ( value )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["_report"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "buffer . write (  (  (  (  \"  \\ n \"     +    name )     +     \"     :     \"  )     +     ( BitsUtil . intToHexString ( value )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["_report"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "buffer . write (  (  (  (  \"  \\ n \"     +    name )     +     \"     :     \"  )     +     ( BitsUtil . shortToHexString ( value )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["_report"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "myOffsetHolders . add ( offsetHolder )  ;", "}", "METHOD_END"], "methodName": ["addOffsetHolder"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "mySizeHolders . add ( sizeHolder )  ;", "}", "METHOD_END"], "methodName": ["addSizeHolder"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myDescription )     !  =    null )     {", "return   myDescription ;", "}", "return   myNa ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "return   myOffset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "myOffset    =    offset ;", "updateSizeOffsetHolders (  )  ;", "}", "METHOD_END"], "methodName": ["resetOffsets"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "myDescription    =    description ;", "}", "METHOD_END"], "methodName": ["setDescription"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "myName    =    name ;", "}", "METHOD_END"], "methodName": ["setName"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "for    ( Bin . Value   holder    :    myOffsetHolders )     {", "holder . setValue ( myOffset )  ;", "}", "for    ( Bin . Value   holder    :    mySizeHolders )     {", "holder . setValue ( sizeInBytes (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateSizeOffsetHolders"], "fileName": "com.pme.exe.Bin"}, {"methodBody": ["METHOD_START", "{", "long   machine    =    myPeHeader . getImageFileHeader (  )  . getMachine (  )  ;", "if    ( machine    =  =     3  3  2  )     {", "return   ExeFormat . X 8  6  ;", "}", "if    ( machine    =  =     3  4  4  0  4  )     {", "return   ExeFormat . X 6  4  ;", "}", "throw   new   UnsupportedOperationException (  (  \" Unsupported   machine   code    \"     +    machine )  )  ;", "}", "METHOD_END"], "methodName": ["getExeFormat"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "return   mySectionHeaders ;", "}", "METHOD_END"], "methodName": ["getSectionHeaders"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "for    ( SectionReader   section    :    mySections )     {", "if    ( sectionName . equals ( section . getSectionName (  )  )  )     {", "return   section ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSectionReader"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "return   mySections ;", "}", "METHOD_END"], "methodName": ["getSections"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "if    (  ( mySectionHeaders )     =  =    null )     {", "return ;", "}", "long   filePointer    =     ( getOffset (  )  )     +     ( sizeOfHeaders (  )  )  ;", "Bin . Value   mainSectionsOffset ;", "mySections    =    new   Section [ mySectionHeaders . size (  )  ]  ;", "for    ( int   i    =     0  ;    i    <     ( mySectionHeaders . size (  )  )  ;     +  + i )     {", "ImageSectionHeader   sectionHeader    =     (  ( ImageSectionHeader )     ( mySectionHeaders . get ( i )  )  )  ;", "Bin . Value   startOffset    =    sectionHeader . getValueMember (  \" PointerToRawData \"  )  ;", "Bin . Value   rva    =    sectionHeader . getValueMember (  \" VirtualAddress \"  )  ;", "if    ( i    =  =     0  )     {", "long   size    =     ( startOffset . getValue (  )  )     -    filePointer ;", "if    (  ( myBytes )     =  =    null )     {", "myBytes    =    new   Bin . Bytes (  \" Aligment \"  ,    size )  ;", "addMemberToMapOnly ( myBytes )  ;", "} else    {", "myBytes    =     (  ( Bin . Bytes )     ( getMember (  \" Aligment \"  )  )  )  ;", "myBytes . reset (  (  ( int )     ( filePointer )  )  ,     (  ( int )     ( size )  )  )  ;", "}", "myBytes . read ( stream )  ;", "}", "mainSectionsOffset    =    new   ValuesAdd ( rva ,    startOffset )  ;", "mySections [ i ]     =    new   Section ( sectionHeader ,    startOffset ,    mainSectionsOffset ,    myImageOptionalHeader )  ;", "mySections [ i ]  . read ( stream )  ;", "}", "resetOffsets (  0  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "super . report ( writer )  ;", "myBytes . report ( writer )  ;", "mySectionHeaders . report ( writer )  ;", "for    ( Section   section    :    mySections )     {", "section . report ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["report"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "super . resetOffsets ( newOffset )  ;", "long   mainOffset    =     (  ( myPeHeader . getOffset (  )  )     +     ( myPeHeader . sizeInBytes (  )  )  )     +     ( myBytes . sizeInBytes (  )  )  ;", "long   offset    =     0  ;", "for    ( Section   section    :    mySections )     {", "section . resetOffsets (  ( mainOffset    +    offset )  )  ;", "offset    +  =    section . sizeInBytes (  )  ;", "}", "}", "METHOD_END"], "methodName": ["resetOffsets"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "long   result    =     0  ;", "long   va    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( mySectionHs . size (  )  )  ;     +  + i )     {", "ImageSectionH   h    =     (  ( ImageSectionH )     ( mySectionHs . get ( i )  )  )  ;", "Bin . Value   virtualAddress    =    h . getValueMember (  \" VirtualAddress \"  )  ;", "if    ( va    <     ( virtualAddress . getValue (  )  )  )     {", "result    =     ( mySections [ i ]  . sizeInBytes (  )  )     +     ( virtualAddress . getValue (  )  )  ;", "}", "}", "long   div    =    result    /     4  0  9  6  ;", "long   r    =    result    %     4  0  9  6  ;", "if    ( r    !  =     0  )     {", "div +  +  ;", "}", "result    =    div    *     4  0  9  6  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["sizeInBytes"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( myPeHeader . sizeInBytes (  )  )     +     ( myMsDosStub . sizeInBytes (  )  )  )     +     ( myMsDosHeader . sizeInBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["sizeOfHeaders"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "super . write ( stream )  ;", "myBytes . write ( stream )  ;", "for    ( Section   section    :    mySections )     {", "section . write ( stream )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.pme.exe.ExeReader"}, {"methodBody": ["METHOD_START", "{", "return   myMachine . getValue (  )  ;", "}", "METHOD_END"], "methodName": ["getMachine"], "fileName": "com.pme.exe.ImageFileHeader"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "long   magic    =    getValue (  \" magic \"  )  ;", "if    ( magic    !  =     2  3  1  1  7  )     {", "throw   new   InvalidException (  \" First   two   chars   in   exe   file   must   be    ' MZ '  \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.MsDosHeader"}, {"methodBody": ["METHOD_START", "{", "return   myImageFileHeader ;", "}", "METHOD_END"], "methodName": ["getImageFileHeader"], "fileName": "com.pme.exe.PeHeaderReader"}, {"methodBody": ["METHOD_START", "{", "return   myName . getText (  )  ;", "}", "METHOD_END"], "methodName": ["getSectionName"], "fileName": "com.pme.exe.SectionReader"}, {"methodBody": ["METHOD_START", "{", "_ report ( writer ,     (  \" Section   name :     \"     +     ( myName . getText (  )  )  )  )  ;", "super . report ( writer )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "com.pme.exe.SectionReader"}, {"methodBody": ["METHOD_START", "{", "return   myRawResource ;", "}", "METHOD_END"], "methodName": ["getRawResource"], "fileName": "com.pme.exe.res.DataEntry"}, {"methodBody": ["METHOD_START", "{", "myRawResource    =    new   RawResource ( mySection ,     (  ( Bin . DWord )     ( getValueMember (  \" RVA \"  )  )  )  ,     (  ( Bin . DWord )     ( getValueMember (  \" Size \"  )  )  )  )  ;", "getLevel (  )  . addLevel ( myRawResource )  ;", "}", "METHOD_END"], "methodName": ["initRawData"], "fileName": "com.pme.exe.res.DataEntry"}, {"methodBody": ["METHOD_START", "{", "myRawResource    =    new   RawResource ( mySection ,     (  ( Bin . DWord )     ( getValueMember (  \" RVA \"  )  )  )  ,     (  ( Bin . DWord )     ( getValueMember (  \" Size \"  )  )  )  )  ;", "getLevel (  )  . insertLevel ( index ,    myRawResource )  ;", "}", "METHOD_END"], "methodName": ["insertRawData"], "fileName": "com.pme.exe.res.DataEntry"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "initRaw (  )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.DataEntry"}, {"methodBody": ["METHOD_START", "{", "super . write ( stream )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.pme.exe.res.DataEntry"}, {"methodBody": ["METHOD_START", "{", "myDatas . add ( dataEntry )  ;", "getLevel (  )  . addLevelEntry ( dataEntry )  ;", "}", "METHOD_END"], "methodName": ["addDataEntry"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "getLevel (  )  . addLevelEntry ( dir )  ;", "mySubDirs . add ( dir )  ;", "}", "METHOD_END"], "methodName": ["addDirectoryEntry"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myIdEntries )     =  =    null )     {", "Bin . Word   numberOfNamedEntries    =     (  ( Bin . Word )     ( getMember (  \" NumberOfIdEntries \"  )  )  )  ;", "myIdEntries    =    new   Bin . ArrayOfBins < Description >  (  \" Id   entries \"  ,    Description . class ,     0  )  ;", "addMember ( myIdEntries )  ;", "myIdEntries . setCountHolder ( numberOfNamedEntries )  ;", "}", "myIdEntries . addBin ( entry )  ;", "}", "METHOD_END"], "methodName": ["addIdEntry"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "String   name    =     \" IRD \"  ;", "if    ( e    !  =    null )     {", "name    +  =    e . getValueMember (  \" Name \"  )  . getValue (  )  ;", "}", "return   name ;", "}", "METHOD_END"], "methodName": ["createName"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "for    ( DirectoryEntry   directoryEntry    :    mySubDirs )     {", "if    ( directoryEntry . getName (  )  . equals ( name )  )     {", "return   directoryEntry ;", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["findSubDir"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "return   myIdOrName ;", "}", "METHOD_END"], "methodName": ["getIdOrName"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "DataEntry   dataEntry    =    myDatas . get ( index )  ;", "return   dataEntry . getRawResource (  )  ;", "}", "METHOD_END"], "methodName": ["getRawResource"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "return   mySection ;", "}", "METHOD_END"], "methodName": ["getSection"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "return   mySubDirs ;", "}", "METHOD_END"], "methodName": ["getSubDirs"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "myDatas . add ( dataEntry )  ;", "getLevel (  )  . insertLevelEntry ( index ,    dataEntry )  ;", "}", "METHOD_END"], "methodName": ["insertDataEntry"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "getLevel (  )  . insertLevelEntry ( index ,    dir )  ;", "mySubDirs . add ( dir )  ;", "}", "METHOD_END"], "methodName": ["insertDirectoryEntry"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "for    ( int   i    =     0  ;    i    <     ( entries . size (  )  )  ;     +  + i )     {", "EntryDescription   entry    =    entries . get ( i )  ;", "Bin . Value   offset    =    entry . getValueMember (  \" OffsetToData \"  )  ;", "Bin . Value   name    =    entry . getValueMember (  \" Name \"  )  ;", "if    (  (  ( offset . getValue (  )  )     &     -  2  1  4  7  4  8  3  6  4  8  )     !  =     0  )     {", "add ( new    ( mySection ,    entry ,    name . getValue (  )  )  )  ;", "} else    {", "addDataEntry ( new   DataEntry ( mySection ,    offset )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["processEntries"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "Bin . Word   numberOfNamedEntries    =     (  ( Bin . Word )     ( getMember (  \" NumberOfNamedEntries \"  )  )  )  ;", "myNamedEntries    =    new   Bin . ArrayOfBins < Description >  (  \" Named   entries \"  ,    Description . class ,    numberOfNamedEntries )  ;", "addMember ( myNamedEntries )  ;", "myNamedEntries . setCountHolder ( numberOfNamedEntries )  ;", "myNamedEntries . read ( stream )  ;", "Bin . Word   numberOfIdEntries    =     (  ( Bin . Word )     ( getMember (  \" NumberOfIdEntries \"  )  )  )  ;", "myIdEntries    =    new   Bin . ArrayOfBins < Description >  (  \" Id   entries \"  ,    Description . class ,    numberOfIdEntries )  ;", "addMember ( myIdEntries )  ;", "myIdEntries . setCountHolder ( numberOfIdEntries )  ;", "myIdEntries . read ( stream )  ;", "processEntries ( myNamedEntries )  ;", "processEntries ( myIdEntries )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "super . report ( writer )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "return   super . sizeInBytes (  )  ;", "}", "METHOD_END"], "methodName": ["sizeInBytes"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "super . write ( stream )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.pme.exe.res.DirectoryEntry"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mySubLevel )     =  =    null )     {", "mySubLevel    =    new   Level (  )  ;", "}", "dir . setLevel ( mySubLevel )  ;", "addMember ( dir )  ;", "}", "METHOD_END"], "methodName": ["addLevelEntry"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mySubLevel )     =  =    null )     {", "mySubLevel    =    new   Level (  )  ;", "}", "dir . setLevel ( mySubLevel )  ;", "insertMember ( index ,    dir )  ;", "}", "METHOD_END"], "methodName": ["insertLevelEntry"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "if    (  ( mySub )     !  =    null )     {", "mySub . read ( stream )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "super . report ( writer )  ;", "if    (  ( mySub )     !  =    null )     {", "mySub . report ( writer )  ;", "}", "}", "METHOD_END"], "methodName": ["report"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "super . resetOffsets ( newOffset )  ;", "if    (  ( mySub )     !  =    null )     {", "mySub . resetOffsets (  (  ( getOffset (  )  )     +     ( super . sizeInBytes (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["resetOffsets"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "if    (  ( mySubLevel )     !  =    null )     {", "return    ( super . sizeInBytes (  )  )     +     ( mySubLevel . sizeInBytes (  )  )  ;", "}", "return   super . sizeInBytes (  )  ;", "}", "METHOD_END"], "methodName": ["sizeInBytes"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "super . write ( stream )  ;", "if    (  ( mySub )     !  =    null )     {", "mySub . write ( stream )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.pme.exe.res.Level"}, {"methodBody": ["METHOD_START", "{", "return   myLevel ;", "}", "METHOD_END"], "methodName": ["getLevel"], "fileName": "com.pme.exe.res.LevelEntry"}, {"methodBody": ["METHOD_START", "{", "myLevel    =    level ;", "}", "METHOD_END"], "methodName": ["setLevel"], "fileName": "com.pme.exe.res.LevelEntry"}, {"methodBody": ["METHOD_START", "{", "return    (  ( Bin . Bytes )     ( getMember (  \" Raw   Resource \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getBytes"], "fileName": "com.pme.exe.res.RawResource"}, {"methodBody": ["METHOD_START", "{", "Bin . Bytes   mem    =     (  ( Bin . Bytes )     ( getMember (  \" Raw   Resource \"  )  )  )  ;", "mem . setBytes ( bytes )  ;", "}", "METHOD_END"], "methodName": ["setBytes"], "fileName": "com.pme.exe.res.RawResource"}, {"methodBody": ["METHOD_START", "{", "return   myMainSectionsOffset ;", "}", "METHOD_END"], "methodName": ["getMainSectionsOffset"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "return    (  ( DirectoryEntry )     ( myRoot . getMember (  \" IRD \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "return   myStartOffset ;", "}", "METHOD_END"], "methodName": ["getStartOffset"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "Bin . DWord   size    =    new   Bin . DWord (  \" size \"  )  ;", "size . setValue (  (  ( mySize . getValue (  )  )     -     ( myRoot . sizeInBytes (  )  )  )  )  ;", "Bin . DWord   startOffset    =    new   Bin . DWord (  \" startOffset \"  )  ;", "startOffset . setValue (  (  ( myStartOffset . getValue (  )  )     +     ( myRoot . sizeInBytes (  )  )  )  )  ;", "myBytes    =    new   Bin . Bytes (  \" Raw   data \"  ,    startOffset ,    size )  ;", "myBytes . read ( stream )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "super . report ( writer )  ;", "myBytes . report ( writer )  ;", "}", "METHOD_END"], "methodName": ["report"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "return    ( super . sizeInBytes (  )  )     +     ( myBytes . sizeInBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["sizeInBytes"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "super . write ( stream )  ;", "myBytwrite ( stream )  ;", "}", "METHOD_END"], "methodName": ["write"], "fileName": "com.pme.exe.res.ResourceSectionReader"}, {"methodBody": ["METHOD_START", "{", "int   size    =     0  ;", "for    ( int   i    =     0  ;    i    <     ( ss . length )  ;     +  + i )     {", "size    +  =     2     +     (  ( ss [ i ]  . length (  )  )     *     2  )  ;", "}", "ByteArrayOutputStream   bytesStream    =    new   ByteArrayOutputStream ( size )  ;", "DataOutputStream   stream    =    new   DataOutputStream ( bytesStream )  ;", "for    ( int   i    =     0  ;    i    <     ( ss . length )  ;     +  + i )     {", "int   count    =    ss [ i ]  . length (  )  ;", "new   Bin . Word (  )  . setValue ( count )  . write ( stream )  ;", "if    ( count    !  =     0  )     {", "new   Bin . Txt (  \"  \"  ,    ss [ i ]  )  . write ( stream )  ;", "}", "}", "return   bytesStream . toByteArray (  )  ;", "}", "METHOD_END"], "methodName": ["getBytes"], "fileName": "com.pme.exe.res.StringTable"}, {"methodBody": ["METHOD_START", "{", "strings [ index ]     =    string ;", "}", "METHOD_END"], "methodName": ["setString"], "fileName": "com.pme.exe.res.StringTable"}, {"methodBody": ["METHOD_START", "{", "for    ( StringTableDirectory . Entry   entry    :    myEntries )     {", "entry . resource . setBytes ( entry . table . getBytes (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["save"], "fileName": "com.pme.exe.res.StringTableDirectory"}, {"methodBody": ["METHOD_START", "{", "boolean   found    =    false ;", "for    (  . Entry   entry    :    myEntries )     {", "if    (  ( entry . startID )     =  =     (  ( id    /     1  6  )     +     1  )  )     {", "entry . table . setString (  ( id    %     1  6  )  ,    value )  ;", "found    =    true ;", "break ;", "}", "}", "if    (  ! found )     {", "throw   new   IllegalArgumentException (  (  \" Cannot   find   string   entry   with   ID    \"     +    id )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setString"], "fileName": "com.pme.exe.res.StringTableDirectory"}, {"methodBody": ["METHOD_START", "{", "return    ( myActual . getValue (  )  )     -     ( myMinus . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.pme.exe.res.ValuesAdd"}, {"methodBody": ["METHOD_START", "{", "return   myActual . setValue (  ( value    +     ( myMinus . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.pme.exe.res.ValuesAdd"}, {"methodBody": ["METHOD_START", "{", "return    ( myActual . getValue (  )  )     +     ( myMinus . getValue (  )  )  ;", "}", "METHOD_END"], "methodName": ["getValue"], "fileName": "com.pme.exe.res.ValuesSub"}, {"methodBody": ["METHOD_START", "{", "return   myActual . setValue (  ( value    -     ( myMinus . getValue (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "com.pme.exe.res.ValuesSub"}, {"methodBody": ["METHOD_START", "{", "Bin . Bytes   bytes    =     (  ( Bin . Bytes )     ( myRawBytes . getMember (  \" Raw   Bytes \"  )  )  )  ;", "return   bytes . getBytes (  )  ;", "}", "METHOD_END"], "methodName": ["getRawBytes"], "fileName": "com.pme.exe.res.icon.IconDirectory"}, {"methodBody": ["METHOD_START", "{", "super . read ( stream )  ;", "RawBytes   bytes    =    new   RawBytes ( getValueMember (  \" dwImageOffset \"  )  ,    getValueMember (  \" dwBytesInRes \"  )  )  ;", "myRawBytes    =    bytes ;", "getLevel (  )  . addLevelEntry ( bytes )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.icon.IconDirectory"}, {"methodBody": ["METHOD_START", "{", "RandomAccessFile   stream    =    null ;", "try    {", "stream    =    new   RandomAccessFile ( myFile ,     \" r \"  )  ;", "read ( stream )  ;", "}    finally    {", "if    ( stream    !  =    null )     {", "stream . close (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.icon.IconFile"}, {"methodBody": ["METHOD_START", "{", "try    {", "super . read ( stream )  ;", "Bin . Word   idCount    =     (  ( Bin . Word )     (  (  ( Bin . Structure )     ( getMember (  \" Header \"  )  )  )  . getMember (  \" idCount \"  )  )  )  ;", "Bin . ArrayOfBins < IconDirectory >    iconDirs    =    new   Bin . ArrayOfBins < IconDirectory >  (  \" Icon   directories \"  ,    IconDirectory . class ,    idCount )  ;", "iconDirs . setCountHolder ( idCount )  ;", "addMember ( myImages )  ;", "Bin [  ]    array    =    iconDirs . getArray (  )  ;", "for    ( Bin   bin    :    array )     {", "myImages . addLevelEntry (  (  ( LevelEntry )     ( bin )  )  )  ;", "}", "myImages . read ( stream )  ;", "}    catch    ( IOException   exception )     {", "throw   new    . IconWrongFormat ( myFile )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.exe.res.icon.IconFile"}, {"methodBody": ["METHOD_START", "{", "IconFile   iconFile    =    new   IconFile ( file )  ;", "iconFile . read (  )  ;", "DirectoryEntry   iconsDir    =    root . findSubDir (  \" IRD 3  \"  )  ;", "Level   iconFileLevel    =     (  ( Level )     ( iconFile . getMember (  \" Level \"  )  )  )  ;", "ArrayList   icons    =    iconFileLevel . getMembers (  )  ;", "if    (  ( icons . size (  )  )     =  =     ( iconsDir . getSubDirs (  )  . size (  )  )  )     {", "for    ( int   i    =     0  ;    i    <     ( icons . size (  )  )  ;    i +  +  )     {", "DirectoryEntry   subDirIcon    =    iconsDir . findSubDir (  (  \" IRD \"     +     ( i    +     1  )  )  )  ;", "IconDirectory   iconDirectory    =     (  ( IconDirectory )     ( iconFileLevel . getMembers (  )  . get ( i )  )  )  ;", "Raw   raw    =    subDirIcon . getRaw (  0  )  ;", "raw . setBytes ( iconDirectory . getRawBytes (  )  )  ;", "}", "} else    {", "throw   new   IOException (  \" Count   of   icons   in   template   file   doesn ' t   match   the   count   of   icons   in   provided   icon   file \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["injectIcon"], "fileName": "com.pme.exe.res.icon.IconResourceInjector"}, {"methodBody": ["METHOD_START", "{", "EntryDescription   entryDescription    =    new   EntryDescription (  )  ;", "Bin . Value   name    =    entryDescription . getValueMember (  \" Name \"  )  ;", "name . setValue (  ( index    +     1  )  )  ;", "DirectoryEntry   entryDirIcon 2     =    new   DirectoryEntry ( iconsDir . getSection (  )  ,    entryDescription ,    name . getValue (  )  )  ;", "iconsDir . insertDirectoryEntry ( index ,    entryDirIcon 2  )  ;", "iconsDir . addIdEntry ( entryDescription )  ;", "EntryDescription   entry 4  0  9     =    new   EntryDescription (  )  ;", "Bin . Value   name 4  0  9     =    entry 4  0  9  . getValueMember (  \" Name \"  )  ;", "name 4  0  9  . setValue (  1  0  3  3  )  ;", "entryDirIcon 2  . addIdEntry ( entry 4  0  9  )  ;", "Bin . Value   offset    =    entry 4  0  9  . getValueMember (  \" OffsetToData \"  )  ;", "DataEntry   dataEntry    =    new   DataEntry ( entryDirIcon 2  . getSection (  )  ,    offset )  ;", "entryDirIcon 2  . insertDataEntry ( index ,    dataEntry )  ;", "dataEntry . insertRawData ( index )  ;", "Raw   rawRes    =    dataEntry . getRaw (  )  ;", "rawRes . setBytes ( iconDirectory . getRawBytes (  )  )  ;", "}", "METHOD_END"], "methodName": ["insertIcon"], "fileName": "com.pme.exe.res.icon.IconResourceInjector"}, {"methodBody": ["METHOD_START", "{", "DirectoryEntry   subDirGroupIcon    =    root . findSubDir (  \" IRD 1  4  \"  )  . findSubDir ( iconId )  ;", "RawResource   groupIcon    =    subDirGroupIcon . getRawResource (  0  )  ;", "Bin . Value   idCount    =    iconFile . getStructureMember (  \" Header \"  )  . getValueMember (  \" idCount \"  )  ;", "Group   group    =    new   Group ( idCount )  ;", "group . copyFrom ( iconFile )  ;", "Level   level    =     (  ( Level )     ( group . getMember (  \" Level \"  )  )  )  ;", "ArrayList   directories    =    level . getMembers (  )  ;", "for    ( int   i    =     0  ;    i    <     ( directories . size (  )  )  ;     +  + i )     {", "GroupDirectory   grpDir    =     (  ( GroupDirectory )     ( directories . get ( i )  )  )  ;", "grpDir . getValueMember (  \" dwId \"  )  . setValue (  ( i    +     1  )  )  ;", "}", "long   size    =    group . sizeInBytes (  )  ;", "ByteArrayOutputStream   bytesStream    =    new   ByteArrayOutputStream (  (  ( int )     ( size )  )  )  ;", "DataOutputStream   stream    =    new   DataOutputStream ( bytesStream )  ;", "group . write ( stream )  ;", "groupIcon . getBytes (  )  . setBytes ( bytesStream . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateGroupIcon"], "fileName": "com.pme.exe.res.icon.IconResourceInjector"}, {"methodBody": ["METHOD_START", "{", "(  ( Bin . DWord )     ( getMember ( FixedFileInfo . FILE _ VERSION _ MS )  )  )  . setValue ( mostSignificantVersion )  ;", "(  ( Bin . DWord )     ( getMember ( FixedFileInfo . FILE _ VERSION _ LS )  )  )  . setValue ( leastSignificantVersion )  ;", "}", "METHOD_END"], "methodName": ["setFileVersion"], "fileName": "com.pme.exe.res.vi.FixedFileInfo"}, {"methodBody": ["METHOD_START", "{", "(  ( Bin . DWord )     ( getMember ( FixedFileInfo . PRODUCT _ VERSION _ MS )  )  )  . setValue ( mostSignificantVersion )  ;", "(  ( Bin . DWord )     ( getMember ( FixedFileInfo . PRODUCT _ VERSION _ LS )  )  )  . setValue ( leastSignificantVersion )  ;", "}", "METHOD_END"], "methodName": ["setProductVersion"], "fileName": "com.pme.exe.res.vi.FixedFileInfo"}, {"methodBody": ["METHOD_START", "{", "return    (  ( StringTable )     ( getMember (  \" StringTable 0  \"  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getFirstStringTable"], "fileName": "com.pme.exe.res.vi.StringFileInfo"}, {"methodBody": ["METHOD_START", "{", "for    ( Bin   bin    :    getMembers (  )  )     {", "if    ( bin . getName (  )  . equals ( key )  )     {", "Entry   entry    =     (  ( Entry )     ( bin )  )  ;", "(  ( Bin . WChar )     ( entry . getMember (  \" Value \"  )  )  )  . setValue ( value )  ;", "(  ( Bin . Word )     ( entry . getMember (  \" wValueLength \"  )  )  )  . setValue (  (  ( value . length (  )  )     +     1  )  )  ;", "return ;", "}", "}", "assert   false    :     \" Could   not   find   string   with   key    \"     +    key ;", "}", "METHOD_END"], "methodName": ["setStringValue"], "fileName": "com.pme.exe.res.vi.StringTable"}, {"methodBody": ["METHOD_START", "{", "return   myFixedFileInfo ;", "}", "METHOD_END"], "methodName": ["getFixedFileInfo"], "fileName": "com.pme.exe.res.vi.VersionInfo"}, {"methodBody": ["METHOD_START", "{", "return   myStringFileInfo ;", "}", "METHOD_END"], "methodName": ["getStringFileInfo"], "fileName": "com.pme.exe.res.vi.VersionInfo"}, {"methodBody": ["METHOD_START", "{", "myStringTableDirectory . save (  )  ;", "saveVersionInfo (  )  ;", "myReader . resetOffsets (  0  )  ;", "myExePath . getParentFile (  )  . mkdirs (  )  ;", "myExePath . createNewFile (  )  ;", "RandomAccessFile   exeStream    =    new   RandomAccessFile ( myExePath ,     \" rw \"  )  ;", "myReader . write ( exeStream )  ;", "exeStream . close (  )  ;", "}", "METHOD_END"], "methodName": ["generate"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "DirectoryEntry   viDir    =    myRoot . findSubDir (  \" IRD 1  6  \"  )  . findSubDir (  \" IRD 1  \"  )  ;", "return   viDir . getRawResource (  0  )  ;", "}", "METHOD_END"], "methodName": ["getVersionInfoResource"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "DirectoryEntry   subDirBmp    =    myRoot . findSubDir (  \" IRD 2  \"  )  . findSubDir (  (  \" IRD \"     +    id )  )  ;", "RawResource   bmpRes    =    subDirBmp . getRawResource (  0  )  ;", "byte [  ]    bitmapResourceData    =    new   byte [  ( bitmapFileData . length )     -     1  4  ]  ;", "System . arraycopy ( bitmapFileData ,     1  4  ,    bitmapResourceData ,     0  ,    bitmapResourceData . length )  ;", "bmpRes . setBytes ( bitmapResourceData )  ;", "}", "METHOD_END"], "methodName": ["injectBitmap"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "Path   f    =    Files . createTempFile (  \" launcher \"  ,     \" ico \"  )  ;", "try    {", "Files . copy ( iconStream ,    f ,    StandardCopyOption . REPLACE _ EXISTING )  ;", "}    finally    {", "iconStream . close (  )  ;", "}", "new   IconResourceInjector (  )  . injectIcon ( f . toFile (  )  ,    myRoot ,     (  \" IRD \"     +    id )  )  ;", "}", "METHOD_END"], "methodName": ["injectIcon"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "RandomAccessFile   stream    =    new   RandomAccessFile ( myTemplate ,     \" r \"  )  ;", "ExeReadformatRead =    new   ExeReadmyTemplate . getName (  )  ,    ExeFormat . UNKNOWN )  ;", "formatReadread ( stream )  ;", "stream . seek (  0 L )  ;", "myRead =    new   ExeReadmyTemplate . getName (  )  ,    formatReadgetExeFormat (  )  )  ;", "myReadread ( stream )  ;", "stream . close (  )  ;", "SectionReadsectionRead =    myReadgetSectionRead \"  . rsrc \"  )  ;", "ResourceSectionReadresourceRead =     (  ( ResourceSectionRead    ( sectionReadgetMemb \"  . rsrc \"  )  )  )  ;", "myRoot    =    resourceReadgetRoot (  )  ;", "DirectoryEntry   subDir    =    myRoot . findSubDir (  \" IRD 6  \"  )  ;", "myStringTableDirectory    =    new   StringTableDirectory ( subDir )  ;", "RawResource   vionInfoResource    =    getVionInfoResource (  )  ;", "ByteArrayInputStream   bytesStream    =    new   ByteArrayInputStream ( vionInfoResource . getBytes (  )  . getBytes (  )  )  ;", "myVionInfo    =    new   VionInfo (  )  ;", "myVionInfo . read ( new   OffsetTrackingInputStream ( new   DataInputStream ( bytesStream )  )  )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "ByteArrayOutputStream   baos    =    new   ByteArrayOutputStream (  )  ;", "myVersionInfo . resetOffsets (  0  )  ;", "myVersionInfo . write ( new   DataOutputStream ( baos )  )  ;", "getVersionInfoResource (  )  . setBytes ( baos . toByteArray (  )  )  ;", "}", "METHOD_END"], "methodName": ["saveVersionInfo"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "myStringTableDirectory . setString ( id ,    value )  ;", "}", "METHOD_END"], "methodName": ["setResourceString"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "StringTable   stringTable    =    myVersionInfo . getStringFileInfo (  )  . getFirstStringTable (  )  ;", "if    ( stringTable    !  =    null )     {", "stringTable . setStringValue ( key ,    value )  ;", "}", "}", "METHOD_END"], "methodName": ["setVersionInfoString"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "int   mostSignificantVersion    =     ( majorVersion    <  <     1  6  )     |    minorVersion ;", "int   leastSignificantVersion    =    bugfixVersion    <  <     1  6  ;", "myVersionInfo . getFixedFileInfo (  )  . setFileVersion ( mostSignificantVersion ,    leastSignificantVersion )  ;", "myVersionInfo . getFixedFileInfo (  )  . setProductVersion ( mostSignificantVersion ,    leastSignificantVersion )  ;", "}", "METHOD_END"], "methodName": ["setVersionNumber"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "String   versionInfoPath    =     ( myExePath )     +     \"  . version \"  ;", "RandomAccessFile   versionInfoStream    =    new   RandomAccessFile ( versionInfoPath ,     \" rw \"  )  ;", "try    {", "myVersionInfo . resetOffsets (  0  )  ;", "myVersionInfo . write ( versionInfoStream )  ;", "}    finally    {", "versionInfoStream . close (  )  ;", "}", "VersionInfo   copy    =    new   VersionInfo (  )  ;", "copy . read ( new   OffsetTrackingInputStream ( new   DataInputStream ( new   FileInputStream ( versionInfoPath )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["verifyVersionInfo"], "fileName": "com.pme.launcher.LauncherGenerator"}, {"methodBody": ["METHOD_START", "{", "return   appInfoRoot . getChild ( logo ,    appInfoRoot . getNamespace (  )  )  ;", "}", "METHOD_END"], "methodName": ["getChild"], "fileName": "com.pme.launcher.LauncherGeneratorMain"}, {"methodBody": ["METHOD_START", "{", "Map < String ,    Integer >    result    =    new   HashMap < String ,    Integer >  (  )  ;", "BufferedReader   reader    =    new   BufferedReader ( new   InputStreamReader ( new   FileInputStream ( arg )  )  )  ;", "Pattern   pattern    =    Pattern . compile (  \"  # define    (  \\  \\ w +  )  \\  \\ s +  (  \\  \\ d +  )  \"  )  ;", "try    {", "while    ( true )     {", "String   line    =    reader . readLine (  )  ;", "if    ( line    =  =    null )", "break ;", "Mat   m    =    pattern . mat ( line )  ;", "if    ( m . matches (  )  )     {", "result . put ( m . group (  1  )  ,    Integer . parseInt ( m . group (  2  )  )  )  ;", "}", "}", "}    finally    {", "reader . close (  )  ;", "}", "return   result ;", "}", "METHOD_END"], "methodName": ["loadResourceIDs"], "fileName": "com.pme.launcher.LauncherGeneratorMain"}, {"methodBody": ["METHOD_START", "{", "if    (  ( args . length )     !  =     5  )     {", "System . err . println (  \" Usage :        < template   EXE   file >     < app   info   file >     < resource . h   file >     < properties >     < output >  \"  )  ;", "System . exit (  1  )  ;", "}", "File   template    =    new   File ( args [  0  ]  )  ;", "if    (  !  ( template . exists (  )  )  )     {", "System . err . println (  (  (  \" Launcher   template   EXE   file    \"     +     ( args [  0  ]  )  )     +     \"    not   found \"  )  )  ;", "System . exit (  2  )  ;", "}", "String   appInfoFileName    =    args [  1  ]  ;", "InputStream   appInfoStream ;", "try    {", "appInfoStream    =    new   FileInputStream ( appInfoFileName )  ;", "}    catch    ( FileNotFoundException   e )     {", "appInfoStream    =     . class . getClassLoader (  )  . getResourceAsStream ( appInfoFileName )  ;", "}", "if    ( appInfoStream    =  =    null )     {", "System . err . println (  (  (  \" Application   info   file    \"     +    appInfoFileName )     +     \"    not   found \"  )  )  ;", "System . exit (  3  )  ;", "}", "Document   appInfo ;", "try    {", "appInfo    =    new   SAXBuilder (  )  . build ( appInfoStream )  ;", "}    catch    ( Exception   e )     {", "System . err . println (  (  (  (  \" Error   loading   application   info   file    \"     +    appInfoFileName )     +     \"  :     \"  )     +     ( e . getMessage (  )  )  )  )  ;", "System . exit (  4  )  ;", "return ;", "}", "Element   appInfoRoot    =    appInfo . getRootElement (  )  ;", "String   splashUrl    =     . getChild ( appInfoRoot ,     \" logo \"  )  . getAttributeValue (  \" url \"  )  ;", "if    ( splashUrl . startsWith (  \"  /  \"  )  )     {", "splashUrl    =    splashUrl . substring (  1  )  ;", "}", "InputStream   splashStream    =     . class . getClassLoader (  )  . getResourceAsStream ( splashUrl )  ;", "if    ( splashStream    =  =    null )     {", "System . err . println (  (  (  \" Splash   screen   image   file   file    \"     +    splashUrl )     +     \"    not   found \"  )  )  ;", "System . exit (  5  )  ;", "}", "ByteArrayOutputStream   splashBmpStream    =    new   ByteArrayOutputStream (  )  ;", "try    {", "BufferedImage   bufferedImage    =    Imaging . getBufferedImage ( splashStream )  ;", "Imaging . writeImage ( bufferedImage ,    splashBmpStream ,    BMP ,    new   HashMap (  )  )  ;", "}    catch    ( Exception   e )     {", "System . err . println (  (  \" Error   converting   splash   screen   to   BMP :     \"     +     ( e . getMessage (  )  )  )  )  ;", "System . exit (  6  )  ;", "}", "String   icoUrl    =     . getChild ( appInfoRoot ,     \" icon \"  )  . getAttributeValue (  \" ico \"  )  ;", "if    ( icoUrl    =  =    null )     {", "System . err . println (  (  \"  . ico   file   URL   not   specified   in   application   info   file    \"     +    appInfoFileName )  )  ;", "System . exit (  1  1  )  ;", "}", "InputStream   iconStream    =     . class . getClassLoader (  )  . getResourceAsStream ( icoUrl )  ;", "if    ( iconStream    =  =    null )     {", "System . err . println (  (  (  \"  . ico   file    \"     +    icoUrl )     +     \"    not   found \"  )  )  ;", "System . exit (  1  2  )  ;", "}", "Map < String ,    Integer >    resourceIDs ;", "try    {", "resourceIDs    =     . loadResourceIDs ( args [  2  ]  )  ;", "}    catch    ( Exception   e )     {", "System . err . println (  (  \" Error   loading   resource . h :     \"     +     ( e . getMessage (  )  )  )  )  ;", "System . exit (  7  )  ;", "return ;", "}", "Properties   properties    =    new   Properties (  )  ;", "try    {", "FileInputStream   fis    =    new   FileInputStream ( args [  3  ]  )  ;", "try    {", "properties . load ( fis )  ;", "}    finally    {", "fis . close (  )  ;", "}", "}    catch    ( IOException   e )     {", "System . err . println (  (  \" Error   loading   launcher   properties :     \"     +     ( e . getMessage (  )  )  )  )  ;", "System . exit (  8  )  ;", "}", "String   companyName    =     . getChild ( appInfoRoot ,     \" company \"  )  . getAttributeValue (  \" name \"  )  ;", "Element   names    =     . getChild ( appInfoRoot ,     \" names \"  )  ;", "String   productShortName    =    names . getAttributeValue (  \" product \"  )  ;", "String   productFullName    =    names . getAttributeValue (  \" fullname \"  ,    productShortName )  ;", "Element   versionElement    =     . getChild ( appInfoRoot ,     \" version \"  )  ;", "int   majorVersion    =    Integer . parseInt ( versionElement . getAttributeValue (  \" major \"  )  )  ;", "String   minorVersionString    =    versionElement . getAttributeValue (  \" minor \"  )  ;", "Pattern   p    =    Pattern . compile (  \"  (  \\  \\ d +  )  (  \\  \\  .  (  \\  \\ d +  )  )  ?  \"  )  ;", "Matcher   matcher    =    p . matcher ( minorVersionString )  ;", "if    (  !  ( matcher . matches (  )  )  )     {", "System . err . println (  (  \" Unexpected   minor   version   format :     \"     +    minorVersionString )  )  ;", "}", "int   minorVersion    =    Integer . parseInt ( matcher . group (  1  )  )  ;", "int   bugfixVersion    =     (  ( matcher . group (  3  )  )     !  =    null )     ?    Integer . parseInt ( matcher . group (  3  )  )     :     0  ;", "String   buildNumber    =     . getChild ( appInfoRoot ,     \" build \"  )  . getAttributeValue (  \" number \"  )  ;", "String   versionString    =     (  (  (  (  (  (  \"  \"     +    majorVersion )     +     \"  .  \"  )     +    minorVersion )     +     \"  .  \"  )     +    bugfixVersion )     +     \"  .  \"  )     +    buildNumber ;", "int   year    =    new   GregorianCalendar (  )  . get ( Calendar . YEAR )  ;", "LauncherGenerator   generator    =    new   LauncherGenerator ( template ,    new   File ( args [  4  ]  )  )  ;", "try    {", "generator . load (  )  ;", "for    ( Map . Entry < Object ,    Object >    pair    :    properties . entrySet (  )  )     {", "String   key    =     (  ( String )     ( pair . getKey (  )  )  )  ;", "Integer   id    =    resourceIDs . get ( key )  ;", "if    ( id    =  =    null )     {", "System . err . println (  (  \" Invalid   stringtable   ID   found :     \"     +    key )  )  ;", "System . exit (  9  )  ;", "}", "generator . setResourceString ( id ,     (  ( String )     ( pair . getValue (  )  )  )  )  ;", "}", "generator . injectBitmap ( resourceIDs . get (  \" IDB _ SPLASH \"  )  ,    splashBmpStream . toByteArray (  )  )  ;", "generator . injectIcon ( resourceIDs . get (  \" IDI _ WINLAUNCHER \"  )  ,    iconStream )  ;", "generator . setVersionInfoString (  \" LegalCopyright \"  ,     (  (  (  \" Copyright    ( C )     2  0  0  0  -  \"     +    year )     +     \"     \"  )     +    companyName )  )  ;", "generator . setVersionInfoString (  \" ProductName \"  ,    productFullName )  ;", "generator . setVersionInfoString (  \" FileVersion \"  ,    versionString )  ;", "generator . setVersionInfoString (  \" FileDescription \"  ,    productFullName )  ;", "generator . setVersionInfoString (  \" ProductVersion \"  ,    versionString )  ;", "generator . setVersionInfoString (  \" InternalName \"  ,     (  ( productShortName . toLowerCase (  )  )     +     \"  . exe \"  )  )  ;", "generator . setVersionInfoString (  \" OriginalFilename \"  ,     (  ( productShortName . toLowerCase (  )  )     +     \"  . exe \"  )  )  ;", "generator . setVersionNumber ( majorVersion ,    minorVersion ,    bugfixVersion )  ;", "generator . generate (  )  ;", "}    catch    ( IOException   e )     {", "e . printStackTrace (  )  ;", "System . exit (  1  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["main"], "fileName": "com.pme.launcher.LauncherGeneratorMain"}, {"methodBody": ["METHOD_START", "{", "return   myData ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "com.pme.util.AttributeInfo"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.pme.util.AttributeInfo"}, {"methodBody": ["METHOD_START", "{", "myName    =    pool [ stream . readShort (  )  ]  ;", "int   len    =    stream . readInt (  )  ;", "myData    =    new   byte [ len ]  ;", "len    =    stream . read ( myData )  ;", "if    ( len    !  =     ( myData . length )  )     {", "throw   new   InvalidClassException (  (  \" Cannot   read   content   for   a :     \"     +     ( myName . getStrValue (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.util.AttributeInfo"}, {"methodBody": ["METHOD_START", "{", "return   BitsUtil . toHexString ( value ,     2  )  ;", "}", "METHOD_END"], "methodName": ["byteToHexString"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "return   BitsUtil . toHexString ( value ,     8  )  ;", "}", "METHOD_END"], "methodName": ["intToHexString"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "int   b 1     =    stream . readByte (  )  ;", "int   b 2     =    stream . readByte (  )  ;", "return    (  ( char )     ( b 1     +     ( b 2     <  <     8  )  )  )  ;", "}", "METHOD_END"], "methodName": ["readChar"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "long   result    =    intValue    &     2  5  5  ;", "result    <  <  =     2  4  ;", "result    +  =     (  (  ( intValue    &     6  5  2  8  0  )     <  <     8  )     +     (  ( intValue    &     1  6  7  1  1  6  8  0  )     >  >     8  )  )     +     (  ( intValue    >  >     2  4  )     &     2  5  5  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["revertBytesOfInt"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "long   ms    =    BitsUtil . revertBytesOfInt (  (  ( int )     ( longValue    >  >     3  2  )  )  )  ;", "long   ls    =    BitsUtil . revertBytesOfInt (  (  ( int )     ( longValue )  )  )  ;", "return   ms    |     ( ls    <  <     3  2  )  ;", "}", "METHOD_END"], "methodName": ["revertBytesOfLong"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "return    (  ( shortValue    <  <     8  )     &     6  5  2  8  0  )     +     (  ( shortValue    >  >     8  )     &     2  5  5  )  ;", "}", "METHOD_END"], "methodName": ["revertBytesOfShort"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "return   BitsUtil . toHexString ( value ,     4  )  ;", "}", "METHOD_END"], "methodName": ["shortToHexString"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "String   strValu =    Long . toHString ( valu ;", "if    (  ( strValulgth (  )  )     >    siz    {", "strValu =    strValusubstring (  (  ( strValulgth (  )  )     -    siz )  ;", "}", "StringBuff   buff    =    n   StringBuff (  (  (  ( strValulgth (  )  )     +     1  )     +    siz )  ;", "buff . appd (  \"  0 x \"  )  ;", "int   dif    =    siz -     ( strValulgth (  )  )  ;", "for    ( int   i    =     0  ;    i    <    dif ;     +  + i )     {", "buff . appd (  \"  0  \"  )  ;", "}", "buff . appd ( strValu ;", "rurn   buff . toString (  )  ;", "}", "METHOD_END"], "methodName": ["toHexString"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "int   result    =    byteValue ;", "return   result    &     2  5  5  ;", "}", "METHOD_END"], "methodName": ["unsignedByte"], "fileName": "com.pme.util.BitsUtil"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myAttributes )     !  =    null )     {", "for    ( int   i    =     0  ;    i    <     ( myAttributes . length )  ;    i +  +  )     {", "String   attrName    =    myAttributes [ i ]  . getName (  )  . getStrValue (  )  ;", "if    (  (  \" Source \"  . compareTo ( attrName )  )     =  =     0  )     {", "try    {", "DataInputStream   dis    =    new   DataInputStream ( new   ByteArrayInputStream ( myAttributes [ i ]  . getData (  )  )  )  ;", "ConstantPoolInfo   cpi    =    myConstantPool [ dis . readShort (  )  ]  ;", "return   cpi . getStrValue (  )  ;", "}    catch    ( IOException   e )     {", "}", "}", "}", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getSourceName"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "DataInputStream   stream    =    new   DataInputStream ( in )  ;", "myMagic    =    stream . readInt (  )  ;", "if    (  ( myMagic )     !  =     -  8  8  9  2  7  5  7  1  4  )     {", "throw   new   InvalidException (  \" There   is   no   magic   number \"  )  ;", "}", "myMajorVersion    =    stream . readShort (  )  ;", "myMinorVersion    =    stream . readShort (  )  ;", "readConstantPool ( stream )  ;", "myAccessFlags    =    stream . readShort (  )  ;", "myThis    =    myConstantPool [ stream . readShort (  )  ]  ;", "mySuper    =    myConstantPool [ stream . readShort (  )  ]  ;", "readInterfaces ( stream )  ;", "readFields ( stream )  ;", "readMethods ( stream )  ;", "readAttributes ( stream )  ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myAttributes    =    new   AttributeInfo [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "myAttributes [ i ]     =    new   AttributeInfo (  )  ;", "myAttributes [ i ]  . read ( stream ,    myConstantPool )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readAttributes"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "FileInputStream   stream    =    new   FileInputStream ( file )  ;", "classFile    =    new    (  )  ;", "try    {", "classFile . read ( stream )  ;", "return   classFile . getSourceName (  )  ;", "}    finally    {", "stream . close (  )  ;", "}", "}", "METHOD_END"], "methodName": ["readClassName"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "myConstantPool    =    new   ConstantPoolInfo [ stream . readShort (  )  ]  ;", "myConstantPool [  0  ]     =    new   ConstantPoolInfo (  )  ;", "for    ( int   i    =     1  ;    i    <     ( myConstantPool . length )  ;    i +  +  )     {", "myConstantPool [ i ]     =    new   ConstantPoolInfo (  )  ;", "myConstantPool [ i ]  . read ( stream )  ;", "if    (  (  ( myConstantPool [ i ]  . getType (  )  )     =  =     ( ConstantPoolInfo . LONG )  )     |  |     (  ( myConstantPool [ i ]  . getType (  )  )     =  =     ( ConstantPoolInfo . DOUBLE )  )  )", "i +  +  ;", "}", "}", "METHOD_END"], "methodName": ["readConstantPool"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myFields    =    new   FieldInfo [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "myFields [ i ]     =    new   FieldInfo (  )  ;", "myFields [ i ]  . read ( stream ,    myConstantPool )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readFields"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myInterfaces    =    new   ConstantPoolInfo [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "int   index    =    stream . readShort (  )  ;", "if    (  ( index    <     1  )     |  |     ( index    >     (  ( myConstantPool . length )     -     1  )  )  )", "throw   new   InvalidException (  \" Wrong   count   for   constant   pool \"  )  ;", "myInterfaces [ i ]     =    myConstantPool [ index ]  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readInterfaces"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myMethods    =    new   MethodInfo [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "myMethods [ i ]     =    new   MethodInfo (  )  ;", "myMethods [ i ]  . read ( stream ,    myConstantPool )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["readMethods"], "fileName": "com.pme.util.ClassFile"}, {"methodBody": ["METHOD_START", "{", "return   myStrValue ;", "}", "METHOD_END"], "methodName": ["getStrValue"], "fileName": "com.pme.util.ConstantPoolInfo"}, {"methodBody": ["METHOD_START", "{", "return   myType ;", "}", "METHOD_END"], "methodName": ["getType"], "fileName": "com.pme.util.ConstantPoolInfo"}, {"methodBody": ["METHOD_START", "{", "myType    =    stream . readByte (  )  ;", "switch    ( myType )     {", "case    . CLASS    :", "myIindex 1     =    stream . readShort (  )  ;", "break ;", "case    . FIELDREF    :", "myIindex 1     =    stream . readShort (  )  ;", "myIndex 2     =    stream . readShort (  )  ;", "break ;", "case    . METHODREF    :", "myIindex 1     =    stream . readShort (  )  ;", "myIndex 2     =    stream . readShort (  )  ;", "break ;", "case    . INTERFACE    :", "myIindex 1     =    stream . readShort (  )  ;", "myIndex 2     =    stream . readShort (  )  ;", "break ;", "case    . NAMEANDTYPE    :", "myIindex 1     =    stream . readShort (  )  ;", "myIndex 2     =    stream . readShort (  )  ;", "break ;", "case    . STRING    :", "myIindex 1     =    stream . readShort (  )  ;", "break ;", "case    . INTEGER    :", "myIntValue    =    stream . readInt (  )  ;", "break ;", "case    . FLOAT    :", "myFloatValue    =    stream . readFloat (  )  ;", "break ;", "case    . LONG    :", "myLongValue    =    stream . readLong (  )  ;", "break ;", "case    . DOUBLE    :", "myDoubleValue    =    stream . readDouble (  )  ;", "break ;", "case    . ASCIZ    :", "case    . UNICODE    :", "StringBuffer   buff    =    new   StringBuffer (  )  ;", "int   len    =    stream . readShort (  )  ;", "while    ( len    >     0  )     {", "char   c    =     (  ( char )     ( stream . readByte (  )  )  )  ;", "buff . append ( c )  ;", "len -  -  ;", "}", "myStrValue    =    buff . toString (  )  ;", "break ;", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.util.ConstantPoolInfo"}, {"methodBody": ["METHOD_START", "{", "return   myAccessFlags ;", "}", "METHOD_END"], "methodName": ["getAccessFlags"], "fileName": "com.pme.util.FieldInfo"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.pme.util.FieldInfo"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.pme.util.FieldInfo"}, {"methodBody": ["METHOD_START", "{", "return   mySignature ;", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "com.pme.util.FieldInfo"}, {"methodBody": ["METHOD_START", "{", "myAccessFlags    =    stream . readShort (  )  ;", "myName    =    pool [ stream . readShort (  )  ]  ;", "mySignature    =    pool [ stream . readShort (  )  ]  ;", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myAttributes    =    new   Attribute [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "myAttributes [ i ]     =    new   Attribute (  )  ;", "myAttributes [ i ]  . read ( stream ,    pool )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.util.FieldInfo"}, {"methodBody": ["METHOD_START", "{", "return   myAccessFlags ;", "}", "METHOD_END"], "methodName": ["getAccessFlags"], "fileName": "com.pme.util.MethodInfo"}, {"methodBody": ["METHOD_START", "{", "return   myAttributes ;", "}", "METHOD_END"], "methodName": ["getAttributes"], "fileName": "com.pme.util.MethodInfo"}, {"methodBody": ["METHOD_START", "{", "return   myName ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "com.pme.util.MethodInfo"}, {"methodBody": ["METHOD_START", "{", "return   mySignature ;", "}", "METHOD_END"], "methodName": ["getSignature"], "fileName": "com.pme.util.MethodInfo"}, {"methodBody": ["METHOD_START", "{", "myAccessFlags    =    stream . readShort (  )  ;", "myName    =    pool [ stream . readShort (  )  ]  ;", "mySignature    =    pool [ stream . readShort (  )  ]  ;", "int   count    =    stream . readShort (  )  ;", "if    ( count    !  =     0  )     {", "myAttributes    =    new   Attribute [ count ]  ;", "for    ( int   i    =     0  ;    i    <    count ;    i +  +  )     {", "myAttributes [ i ]     =    new   Attribute (  )  ;", "myAttributes [ i ]  . read ( stream ,    pool )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["read"], "fileName": "com.pme.util.MethodInfo"}, {"methodBody": ["METHOD_START", "{", "return   myOffset ;", "}", "METHOD_END"], "methodName": ["getOffset"], "fileName": "com.pme.util.OffsetTrackingInputStream"}]