[{"methodBody": ["METHOD_START", "{", "return   IconLoader . getIcon ( path ,    ImagesIcons . class )  ;", "}", "METHOD_END"], "methodName": ["load"], "fileName": "icons.ImagesIcons"}, {"methodBody": ["METHOD_START", "{", "ResourceBundle   bundle    =    SoftReference . dereference ( ImagesBundle . ourBundle )  ;", "if    ( bundle    =  =    null )     {", "bundle    =    ResourceBundle . getBundle ( ImagesBundle . BUNDLE )  ;", "ImagesBundle . ourBundle    =    new   SoftReference <  >  ( bundle )  ;", "}", "return   bundle ;", "}", "METHOD_END"], "methodName": ["getBundle"], "fileName": "org.intellij.images.ImagesBundle"}, {"methodBody": ["METHOD_START", "{", "return   CommonBundle . message ( ImagesBundle . getBundle (  )  ,    key ,    params )  ;", "}", "METHOD_END"], "methodName": ["message"], "fileName": "org.intellij.images.ImagesBundle"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    e . getData ( PROJECT )  ;", "VirtualFile [  ]    files    =    e . getData ( VIRTUAL _ FILE _ ARRAY )  ;", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "String   executablePath    =    options . geEditorOptions (  )  . getExecutablePath (  )  ;", "if    ( StringUtil . isEmpty ( executablePath )  )     {", "Messages . showErrorDialog ( project ,    ImagesBundle . message (  \" error . empty . external . editor . path \"  )  ,    ImagesBundle . message (  \" error . title . empty . external . editor . path \"  )  )  ;", "ImagesConfigurable . show ( project )  ;", "} else    {", "if    ( files    !  =    null )     {", "Map < String ,    String >    env    =    EnvironmentUtil . getEnvironmentMap (  )  ;", "for    ( String   varName    :    env . keySet (  )  )     {", "if    ( SystemInfo . isWindows )     {", "executablePath    =    StringUtil . replace ( executablePath ,     (  (  \"  %  \"     +    varName )     +     \"  %  \"  )  ,    env . get ( varName )  ,    true )  ;", "} else    {", "executablePath    =    StringUtil . replace ( executablePath ,     (  (  \"  $  {  \"     +    varName )     +     \"  }  \"  )  ,    env . get ( varName )  ,    false )  ;", "}", "}", "executablePath    =    FileUtil . toSystemDependentName ( executablePath )  ;", "File   executable    =    new   File ( executablePath )  ;", "GeneralCommandLine   commandLine    =    new   GeneralCommandLine (  )  ;", "final   String   path    =     ( executable . exists (  )  )     ?    executable . getAbsolutePath (  )     :    executablePath ;", "if    ( SystemInfo . isMac )     {", "commandLine . setExePath ( ExecUtil . getOpenCommandPath (  )  )  ;", "commandLine . addParameter (  \"  - a \"  )  ;", "commandLine . addParameter ( path )  ;", "} else    {", "commandLine . setExePath ( path )  ;", "}", "ImageFileTypeManager   typeManager    =    ImageFileTypeManager . getInstance (  )  ;", "for    ( VirtualFile   file    :    files )     {", "if    (  ( file . isInLocalFileSystem (  )  )     &  &     ( typeManager . isImage ( file )  )  )     {", "commandLine . addParameter ( VfsUtilCore . virtualToIoFile ( file )  . getAbsolutePath (  )  )  ;", "}", "}", "commandLine . setWorkDirectory ( new   File ( executablePath )  . getParentFile (  )  )  ;", "try    {", "commandLine . createProcess (  )  ;", "}    catch    ( ExecutionException   ex )     {", "Messages . showErrorDialog ( project ,    ex . getLocalizedMessage (  )  ,    ImagesBundle . message (  \" error . title . launching . external . editor \"  )  )  ;", "ImagesConfigurable . show ( project )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.actions.EditExternallyAction"}, {"methodBody": ["METHOD_START", "{", "VirtualFile [  ]    files    =    e . getData ( VIRTUAL _ FILE _ ARRAY )  ;", "final   boolean   isEnabled    =     . isImages ( files )  ;", "if    ( e . getPlace (  )  . equals ( PROJECT _ VIEW _ POPUP )  )     {", "e . getPresentation (  )  . setVisible ( isEnabled )  ;", "} else    {", "e . getPresentation (  )  . setEnabled ( isEnabled )  ;", "}", "}", "METHOD_END"], "methodName": ["doUpdate"], "fileName": "org.intellij.images.actions.EditExternallyAction"}, {"methodBody": ["METHOD_START", "{", "boolean   isImagesFound    =    false ;", "if    ( files    !  =    null )     {", "ImageFileTypeManager   typeManager    =    ImageFileTypeManager . getInstance (  )  ;", "for    ( VirtualFile   file    :    files )     {", "boolean   isImage    =    typeManager . isImage ( file )  ;", "isImagesFound    |  =    isImage ;", "if    (  (  !  ( file . isInLocalFileSystem (  )  )  )     |  |     (  ! isImage )  )     {", "return   false ;", "}", "}", "}", "return   isImagesFound ;", "}", "METHOD_END"], "methodName": ["isImages"], "fileName": "org.intellij.images.actions.EditExternallyAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", ". doUpdate ( e )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.actions.EditExternallyAction"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    e . getData ( PROJECT )  ;", "VirtualFile   file    =    e . getData ( VIRTUAL _ FILE )  ;", "if    (  (  ( project    !  =    null )     &  &     ( file    !  =    null )  )     &  &     ( file . isDirectory (  )  )  )     {", "Manager   thumbnailManager    =    Manager . getManager ( project )  ;", "View   thumbnailView    =    thumbnailManager . getView (  )  ;", "thumbnailView . setRoot ( file )  ;", "thumbnailView . setVisible ( true )  ;", "thumbnailView . activate (  )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.actions.ShowThumbnailsAction"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =    e . getData ( VIRTUAL _ FILE )  ;", "boolean   enabled    =     ( file    !  =    null )     &  &     ( file . isDirectory (  )  )  ;", "if    ( Places . isPopupPlace ( e . getPlace (  )  )  )     {", "e . getPresentation (  )  . setEnabledAndVisible ( enabled )  ;", "} else    {", "e . getPresentation (  )  . setEnabled ( enabled )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.actions.ShowThumbnailsAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "return    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     &  &     ( decorator . isVisible (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.actions.ToggleTransparencyChessboardAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "if    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     {", "decorator . setVisible ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.actions.ToggleTransparencyChessboardAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "e . getPresentation (  )  . setEnabled (  (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )  )  ;", "e . getPresentation (  )  . setText (  ( isSelected ( e )     ?     \" Hide    \"     :     \" Show    \"  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.actions.ToggleTransparencyChessboardAction"}, {"methodBody": ["METHOD_START", "{", "final   String [  ]    s    =    new   String [  ]  {    null    }  ;", "InfoIndex . processValues ( file ,     (    file 1  ,    value )     -  >     {", "s [  0  ]     =    String . format (  \"  % sx % s \"  ,    value . width ,    value . height )  ;", "return   true ;", "}  ,    project )  ;", "return    ( s [  0  ]  )     =  =    null    ?    null    :    Couple . of ( file . getName (  )  ,    s [  0  ]  )  ;", "}", "METHOD_END"], "methodName": ["getLookupInfo"], "fileName": "org.intellij.images.completion.ImageLookupInfoProvider"}, {"methodBody": ["METHOD_START", "{", "DataContext   dataContext    =    e . getDataContext (  )  ;", "return   ComponentDecorator . DATA _ KEY . getData ( dataContext )  ;", "}", "METHOD_END"], "methodName": ["getImageComponentDecorator"], "fileName": "org.intellij.images.editor.actionSystem.ImageEditorActionUtil"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "Presentation   presentation    =    e . getPresentation (  )  ;", "presentation . setEnabled (  ( decorator    !  =    null )  )  ;", "return   presentation . isEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.intellij.images.editor.actionSystem.ImageEditorActionUtil"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "if    ( decorator    !  =    null )     {", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "zoomModel . setZoomFactor (  1  .  0  )  ;", "zoomModel . setZoomLevelChanged ( true )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.editor.actions.ActualSizeAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "if    ( ImageEditorUtil . setEnabled ( e )  )     {", "ImageComponentDecorator   decorator    =    ImageEditorUtil . getImageComponentDecorator ( e )  ;", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "e . getPresentation (  )  . setEnabled (  (  ( zoomModel . getZoomFactor (  )  )     !  =     1  .  0  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.editor.actions.ActualSizeAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "if    ( decorator    !  =    null )     {", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "zoomModel . f (  )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.editor.actions.FitZoomToWindowAction"}, {"methodBody": ["METHOD_START", "{", "if    ( ImageEditorActionUtil . setEnabled ( e )  )     {", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "ZoomOptions   zoomOptions    =    options . getEditorOptions (  )  . getZoomOptions (  )  ;", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "e . getPresentation (  )  . setEnabled (  (  ( zoomModel . isZoomLevelChanged (  )  )     |  |     (  !  ( zoomOptions . isSmartZooming (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.editor.actions.FitZoomToWindowAction"}, {"methodBody": ["METHOD_START", "{", "JBPanelWithEmptyText   panel    =    new   JBPanelWithEmptyText (  )     {", "@ Override", "public   Dimension   getPreferredSize (  )     {", "Dimension   d    =    super . getSize (  )  ;", "d . width    =    Math . max ( d . width ,    d . height )  ;", "d . height    =    Math . max ( d . width ,    d . height )  ;", "return   d ;", "}", "@ Override", "public   Dimension   getMinimumSize (  )     {", "return   getPreferredSize (  )  ;", "}", "@ Override", "public   Dimension   getMaximumSize (  )     {", "return   getPreferredSize (  )  ;", "}", "@ Override", "public   Color   g (  )     {", "return   button . isSelected (  )     ?    color    :    super . g (  )  ;", "}", "@ Override", "public   boolean   isOpaque (  )     {", "return   true ;", "}", "}  ;", "panel . getEmptyText (  )  . clear (  )  ;", "new   ClickListener (  )     {", "@ Override", "public   boolean   onClick (  @ NotNull", "MouseEvent   event ,    int   clickCount )     {", "button . setSelected ( true )  ;", "buttonPanel . invalidate (  )  ;", "buttonPanel . repaint (  )  ;", "return   true ;", "}", "}  . installOn ( panel )  ;", "panel . setBorder ( BorderFactory . createLineBorder ( color )  )  ;", "buttonGroup . add ( button )  ;", "buttonPanel . add ( panel )  ;", "return   panel ;", "}", "METHOD_END"], "methodName": ["addClickablePanel"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "String   path    =     (  ( String )     ( myPathField . getComboBox (  )  . getEditor (  )  . getItem (  )  )  )  ;", "String   type    =    getFillRbGroup (  )  . getSelection (  )  . getActionCommand (  )  . replace (  '  -  '  ,     '  _  '  )  ;", "String   anchor    =    getAnchorRbGroup (  )  . getSelection (  )  . getActionCommand (  )  . replace (  '  -  '  ,     '  _  '  )  ;", "return    (  (  (  ( path . trim (  )  )     +     \"  ,  \"  )     +     ( myOpacitySpinner . getValue (  )  )  )     +     \"  ,  \"  )     +     (  (  ( type    +     \"  ,  \"  )     +    anchor )  . toLowerCase ( Locale . ENGLISH )  )  ;", "}", "METHOD_END"], "methodName": ["calcNewValue"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "IdeBackgroundUtil [  ]    values    =    Anchor . values (  )  ;", "String [  ]    names    =    new   String [ values . length ]  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "names [ i ]     =    values [ i ]  . name (  )  . replace (  '  _  '  ,     '  -  '  )  . toLowerCase ( Locale . ENGLISH )  ;", "}", "Color   color    =     . getSelectionBackground (  )  ;", "JPanel   buttonPanel    =    new   JPanel ( new   GridLayout (  3  ,     3  ,     1  ,     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "JRadioButton   button    =    new   JRadioButton ( names [ i ]  ,     (  ( values [ i ]  )     =  =     ( Anchor . CENTER )  )  )  ;", ". addClickablePanel ( buttonPanel ,    buttonGroup ,    button ,    color )  ;", "}", "return   buttonPanel ;", "}", "METHOD_END"], "methodName": ["createAnchorPanel"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "EditorColorsScheme   scheme    =    EditorColorsManager . getInstance (  )  . getGlobalScheme (  )  ;", "ColorAndFontOptions   options    =    new   ColorAndFontOptions (  )  ;", "options . reset (  )  ;", "options . selectScheme ( scheme . getName (  )  )  ;", "ColorSettingsPage [  ]    pages    =    ColorSettingsPages . getInstance (  )  . getRegisteredPages (  )  ;", "int   index ;", "int   attempt    =     0  ;", "do    {", "index    =     (  ( int )     ( Math . round (  (  ( Math . random (  )  )     *     (  ( pages . length )     -     1  )  )  )  )  )  ;", "}    while    (  (  ( StringUtil . countNewLines ( pages [ index ]  . getDemoText (  )  )  )     <     8  )     &  &     (  (  +  + attempt )     <     1  0  )     )  ;", "return   new   comapplication . options . colors . SimpleEditorPreview ( options ,    pages [ index ]  ,    false )  ;", "}", "METHOD_END"], "methodName": ["createEditorPreview"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "Fill [  ]    values    =    Fill . values (  )  ;", "String [  ]    names    =    new   String [ values . length ]  ;", "BufferedImage   image    =     . sampleImage (  )  ;", "for    ( int   i    =     0  ;    i    <     ( names . length )  ;    i +  +  )     {", "names [ i ]     =    values [ i ]  . name (  )  . replace (  '  _  '  ,     '  -  '  )  . toLowerCase ( Locale . ENGLISH )  ;", "}", "Color   color    =     . getSelectionBackground (  )  ;", "JPanel   buttonPanel    =    new   JPanel ( new   GridLayout (  1  ,    values . length ,     1  ,     1  )  )  ;", "for    ( int   i    =     0  ;    i    <     ( values . length )  ;    i +  +  )     {", "JRadioButton   radioButton    =    new   JRadioButton ( names [ i ]  ,     (  ( values [ i ]  )     =  =     ( Fill . SCALE )  )  )  ;", "JBPanelWithEmptyText   clickablePanel    =     . addClickablePanel ( buttonPanel ,    buttonGroup ,    radioButton ,    color )  ;", "createTemporaryBackgroundTransform ( clickablePanel ,    image ,    values [ i ]  ,    CENTER ,     1  .  0 F ,    JBUI . insets (  2  )  ,    disposable )  ;", "}", "return   buttonPanel ;", "}", "METHOD_END"], "methodName": ["createFillPanel"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "EditorEmptyTextPainter   painter    =    ServiceManager . getService ( EditorEmptyTextPainter . class )  ;", "JBPanelWithEmptyText   panel    =    new   JBPanelWithEmptyText (  )     {", "@ Override", "protected   void   paintComponent ( Graphics   g )     {", "super . paintComponent ( g )  ;", "painter . paintEmptyText ( this ,    g )  ;", "}", "@ Override", "public   Color   g (  )     {", "return   getIdeBackgroundColor (  )  ;", "}", "@ Override", "public   boolean   isOpaque (  )     {", "return   true ;", "}", "}  ;", "panel . getEmptyText (  )  . clear (  )  ;", "return   panel ;", "}", "METHOD_END"], "methodName": ["createFramePreview"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "class   A   extends   IconWithTextAction   implements   DumbAware    ,    Toggleable    {", "@ Override", "public   void   update ( AnActionEvent   e )     {", "e . getPresentation (  )  . setText ( text )  ;", "e . getPresentation (  )  . putClientProperty ( SELECTED _ PROPERTY ,    target . equals ( myPreviewTarget )  )  ;", "super . update ( e )  ;", "}", "@ Override", "public   void   Performed ( AnActionEvent   e )     {", "targetChanged ( target )  ;", "myToolbar . updateActionsImmediately (  )  ;", "}", "}", "return   new   A (  )  ;", "}", "METHOD_END"], "methodName": ["createToggleAction"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "ComboBox < String >    comboBox    =    new   ComboBox ( new   CollectionComboBoxModel < String >  (  )  ,     1  0  0  )  ;", "myPathField    =    new   ComboboxWithBrowseButton ( comboBox )  ;", "}", "METHOD_END"], "methodName": ["createUIComponents"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "close ( OK _ EXIT _ CODE )  ;", "storeRecents (  )  ;", "String   prop    =    getSystemProp (  )  ;", "PropertiesComponent . getInstance ( myProject )  . setValue ( prop ,    null )  ;", "PropertiesComponent . getInstance (  )  . setValue ( prop ,    null )  ;", "repaintAllWindows (  )  ;", "}", "METHOD_END"], "methodName": ["doClearAction"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "updatePreview (  )  ;", "}", "METHOD_END"], "methodName": ["fillOrAnchorChanged"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return   myAnchorGroup ;", "}", "METHOD_END"], "methodName": ["getAnchorRbGroup"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return    (  ( JTextComponent )     ( myPathField . getComboBox (  )  . getEditor (  )  . getEditorComponent (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComboEditor"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return    (  ( CollectionComboBoxModel < String >  )     ( myPathField . getComboBox (  )  . getModel (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getComboModel"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return   myFillGroup ;", "}", "METHOD_END"], "methodName": ["getFillRbGroup"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return    ( getDimensionServiceKey (  )  )     +     \"  # recent \"  ;", "}", "METHOD_END"], "methodName": ["getRecentItemsKey"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return   ColorUtil . mix ( UIUtil . getListSelectionBackground (  )  ,    UIUtil . getLabelBackground (  )  ,     ( UIUtil . isUnderDarcula (  )     ?     0  .  5     :     0  .  7  5  )  )  ;", "}", "METHOD_END"], "methodName": ["getSelectionBackground"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return   SetBackgroundImageDialog . getSystemProp ( SetBackgroundImageDialog . EDITOR . equals ( myPreviewTarget )  )  ;", "}", "METHOD_END"], "methodName": ["getSystemProp"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "return   forEditor    ?    EDITOR _ PROP    :    FRAME _ PROP ;", "}", "METHOD_END"], "methodName": ["getSystemProp"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "updatePreview (  )  ;", "}", "METHOD_END"], "methodName": ["imagePathChanged"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "updatePreview (  )  ;", "}", "METHOD_END"], "methodName": ["opacityChanged"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "String   value    =    PropertiesComponent . getInstance (  )  . getValue ( getRecentItemsKey (  )  )  ;", "if    ( value    =  =    null )", "return ;", "ColleComboBoxModel < String >    model    =    getComboModel (  )  ;", "for    ( String   s    :    value . split (  \"  \\ n \"  )  )     {", "if    (  ( StringUtil . isEmptyOrSpaces ( s )  )     |  |     ( model . contains ( s )  )  )", "continue ;", "model . add ( s )  ;", "}", "}", "METHOD_END"], "methodName": ["restoreRecentImages"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "myAdjusting    =    true ;", "String   prop    =    getSystemProp (  )  ;", "JBIterable < String >    possibleValues    =    JBIterable . of ( myResults . get ( prop )  )  . append ( StringUtil . nullize ( getBackgroundSpec ( myProject ,    prop )  )  )  . append ( myResults . values (  )  )  ;", "String   value    =    StringUtil . notNullize ( ObjectUtils . coalesce ( possibleValues )  )  ;", "String [  ]    split    =    value . split (  \"  ,  \"  )  ;", "int   opacity    =     (  ( split . length )     >     1  )     ?    StringUtil . parseInt ( split [  1  ]  ,     1  5  )     :     1  5  ;", "String   fill    =     (  ( split . length )     >     2  )     ?    split [  2  ]     :     \" scale \"  ;", "String   anchor    =     (  ( split . length )     >     3  )     ?    split [  3  ]     :     \" center \"  ;", "setSelectedPath ( split [  0  ]  )  ;", "myOpacitySlider . setValue ( opacity )  ;", "myOpacitySpinner . setValue ( opacity )  ;", ". setSelected ( getFillRbGroup (  )  ,    fill )  ;", ". setSelected ( getAnchorRbGroup (  )  ,    anchor )  ;", "myAdjusting    =    false ;", "}", "METHOD_END"], "methodName": ["retrieveExistingValue"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "int   size    =     1  6  ;", "Buffere   image    =    new   Buffere ( size ,    size ,    Buffere . TYPE _ INT _ ARGB )  ;", "Graphics   ig    =    image . getGraphics (  )  ;", "ig . setColor ( new   Color (  0  ,    true )  )  ;", "ig . fillRect (  0  ,     0  ,    size ,    size )  ;", "Color   imageColor    =    UIUtil . getLabelForeground (  )  ;", "ig . setColor ( imageColor )  ;", "ig . drawRect (  ( size    /     4  )  ,     ( size    /     4  )  ,     (  ( size    /     2  )     -     1  )  ,     (  ( size    /     2  )     -     1  )  )  ;", "ig . drawRect (  1  ,     1  ,     ( size    -     3  )  ,     ( size    -     3  )  )  ;", "ig . dispose (  )  ;", "return   image ;", "}", "METHOD_END"], "methodName": ["sampleImage"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "for    ( Enumeration < AbstractButton >    e    =    group . getElements (  )  ;    e . hasMoreElements (  )  ;  )     {", "AbstractButton   button    =    e . nextElement (  )  ;", "String   s    =    button . getACommand (  )  . replace (  '  -  '  ,     '  _  '  )  ;", "if    ( s . equalsIgnoreCase ( fill )  )     {", "button . setSelected ( true )  ;", "break ;", "}", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "if    ( StringUtil . isEmptyOrSpaces ( path )  )     {", "getComboE (  )  . setText (  \"  \"  )  ;", "} else    {", "CollectionComboBoxModel < String >    comboModel    =    getComboModel (  )  ;", "if    (  !  ( comboModel . contains ( path )  )  )     {", "comboModel . add ( path )  ;", "}", "comboModel . setSelectedItem ( path )  ;", "getComboE (  )  . setCaretPosition (  0  )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelectedPath"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "myAdjusting    =    true ;", "myPreviewPanel . setLayout ( new   CardLayout (  )  )  ;", "myPreviewPanel . add ( myEditorPreview . getPanel (  )  ,     . EDITOR )  ;", "myPreviewPanel . add ( myIdePreview ,     . FRAME )  ;", "UIUtil . removeScrollBorder ( myPreviewPanel )  ;", "myPreviewPanel . setBorder ( new   SideBorder ( JBColor . border (  )  ,    SideBorder . ALL )  )  ;", "DefaultActionGroup   actionGroup    =    new   DefaultActionGroup (  )  ;", "actionGroup . add ( createToggleAction (  . EDITOR ,     \" Editor   and   tools \"  )  )  ;", "actionGroup . add ( createToggleAction (  . FRAME ,     \" Empty   frame \"  )  )  ;", "myToolbar    =    ActionManager . getInstance (  )  . createActionToolbar ( getTitle (  )  ,    actionGroup ,    true )  ;", "JComponent   toolbarComponent    =    myToolbar . getComponent (  )  ;", "toolbarComponent . setBorder ( Borders . empty (  )  )  ;", "myTargetPanel . add ( toolbarComponent )  ;", "myAnchorPanel . add (  . createAnchorPanel ( myAnchorGroup )  ,    BorderLayout . CENTER )  ;", "myFillPanel . add (  . createFillPanel ( myFillGroup ,    getDisposable (  )  )  ,    BorderLayout . CENTER )  ;", "(  ( CardLayout )     ( myPreviewPanel . getLayout (  )  )  )  . show ( myPreviewPanel ,     . EDITOR )  ;", "myPathField . getComboBox (  )  . setEditable ( true )  ;", "FileChooserDescriptor   descriptor    =    new   FileChooserDescriptor ( true ,    false ,    false ,    false ,    true ,    false )  . withFileFilter (  (    file )     -  >    ImageFileTypeManager . getInstance (  )  . isImage ( file )  )  ;", "myPathField . addBrowseFolderListener ( null ,    null ,    null ,    descriptor ,    STRING _ COMBOBOX _ WHOLE _ TEXT )  ;", "JTextComponent   textComponent    =    getComboEditor (  )  ;", "textComponent . getDocument (  )  . addDocumentListener ( new   DocumentAdapter (  )     {", "@ Override", "protected   void   textChanged ( DocumentEvent   e )     {", "if    ( myAdjusting )", "return ;", "imagePathChanged (  )  ;", "}", "}  )  ;", "for    ( Enumeration < AbstractButton >    e    =    getFillRbGroup (  )  . getElements (  )  ;    e . hasMoreElements (  )  ;  )     {", "AbstractButton   button    =    e . nextElement (  )  ;", "button . setActionCommand ( button . getText (  )  )  ;", "button . addItemListener ( this :  : fillOrAnchorChanged )  ;", "}", "for    ( Enumeration < AbstractButton >    e    =    getAnchorRbGroup (  )  . getElements (  )  ;    e . hasMoreElements (  )  ;  )     {", "AbstractButton   button    =    e . nextElement (  )  ;", "button . setActionCommand ( button . getText (  )  )  ;", "button . addItemListener ( this :  : fillOrAnchorChanged )  ;", "}", "ChangeListener   opacitySync    =    new   ChangeListener (  )     {", "@ Override", "public   void   stateChanged ( ChangeEvent   e )     {", "if    ( myAdjusting )", "return ;", "myAdjusting    =    true ;", "boolean   b    =     ( e . getSource (  )  )     =  =     ( myOpacitySpinner )  ;", "if    ( b )     {", "int   value    =     (  ( Integer )     ( myOpacitySpinner . getValue (  )  )  )  ;", "myOpacitySpinner . setValue ( Math . min ( Math . max (  0  ,    value )  ,     1  0  0  )  )  ;", "myOpacitySlider . setValue ( value )  ;", "} else    {", "myOpacitySpinner . setValue ( myOpacitySlider . getValue (  )  )  ;", "}", "myAdjusting    =    false ;", "opacityChanged (  )  ;", "}", "}  ;", "myOpacitySpinner . addChangeListener ( opacitySync )  ;", "myOpacitySlider . addChangeListener ( opacitySync )  ;", "myOpacitySlider . setValue (  1  5  )  ;", "myOpacitySpinner . setValue (  1  5  )  ;", "boolean   perProject    =     !  ( Comparing . equal ( getBackgroundSpec ( myProject ,     . getSystemProp ( true )  )  ,    getBackgroundSpec ( null ,     . getSystemProp ( true )  )  )  )  ;", "myThisProjectOnlyCb . setSelected ( perProject )  ;", "myAdjusting    =    false ;", "}", "METHOD_END"], "methodName": ["setupComponents"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "List < String >    items    =    getComboModel (  )  . getItems (  )  ;", "PropertiesComponent . getInstance (  )  . setValue ( getRecentItemsKey (  )  ,    StringUtil . join ( items . subList (  0  ,    Math . min ( items . size (  )  ,     5  )  )  ,     \"  \\ n \"  )  )  ;", "}", "METHOD_END"], "methodName": ["storeRecentImages"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "myPreviewTarget    =    target ;", "retrieveExistingValue (  )  ;", "(  ( CardLayout )     ( myPreviewPanel . getLayout (  )  )  )  . show ( myPreviewPanel ,    myPreviewTarget )  ;", "if    (  . EDITOR . equals ( myPreviewTarget )  )     {", "myEditorPreview . updateView (  )  ;", "}", "updatePreview (  )  ;", "}", "METHOD_END"], "methodName": ["targetChanged"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "if    ( myAdjusting )", "return ;", "String   prop    =    getSystemProp (  )  ;", "String   value    =    calcNewValue (  )  ;", "System . setProperty ( myPropertyTmp ,    value )  ;", "myResults . put ( prop ,    value )  ;", "myPreviewPanel . validate (  )  ;", "myPreviewPanel . repaint (  )  ;", "boolean   clear    =    value . startsWith (  \"  ,  \"  )  ;", "getOKA (  )  . setEnabled (  (  ! clear )  )  ;", "}", "METHOD_END"], "methodName": ["updatePreview"], "fileName": "org.intellij.images.editor.actions.SetBackgroundImageDialog"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "return    ( decorator    !  =    null )     &  &     ( decorator . isGridVisible (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.editor.actions.ToggleGridAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "if    ( decorator    !  =    null )     {", "decorator . setGridVisible ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.editor.actions.ToggleGridAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "ImageEditorUtil . setEnabled ( e )  ;", "e . getPresentation (  )  . setText (  ( isSelected ( e )     ?     \" Hide   Grid \"     :     \" Show   Grid \"  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.editor.actions.ToggleGridAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "if    ( decorator    !  =    null )     {", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "zoomModel . zoomIn (  )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.editor.actions.ZoomInAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "if    ( ImageEditorUtil . setEnabled ( e )  )     {", "ImageComponentDecorator   decorator    =    ImageEditorUtil . getImageComponentDecorator ( e )  ;", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "e . getPresentation (  )  . setEnabled ( zoomModel . canZoomIn (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.editor.actions.ZoomInAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "if    ( decorator    !  =    null )     {", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "zoomModel . zoomOut (  )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.editor.actions.ZoomOutAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "if    ( ImageEditorActionUtil . setEnabled ( e )  )     {", "ImageComponentDecorator   decorator    =    ImageEditorActionUtil . getImageComponentDecorator ( e )  ;", "ImageZoomModel   zoomModel    =    decorator . getZoomModel (  )  ;", "e . getPresentation (  )  . setEnabled ( zoomModel . can (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.editor.actions.ZoomOutAction"}, {"methodBody": ["METHOD_START", "{", "if    ( file . equals ( event . getFile (  )  )  )     {", "Runnable   postRunnable    =     (  )     -  >    setValue ( file )  ;", "RefreshQueue . getInstance (  )  . refresh ( true ,    false ,    postRunnable ,    ModalityState . current (  )  ,    file )  ;", "}", "}", "METHOD_END"], "methodName": ["contentsChanged"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "disposed    =    true ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI . getImageComponent (  )  ;", "}", "METHOD_END"], "methodName": ["getContentComponent"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI . getImageComponent (  )  . getDocument (  )  ;", "}", "METHOD_END"], "methodName": ["getDocument"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   file ;", "}", "METHOD_END"], "methodName": ["getFile"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI . getZoomModel (  )  ;", "}", "METHOD_END"], "methodName": ["getZoomModel"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   disposed ;", "}", "METHOD_END"], "methodName": ["isDisposed"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return    !  ( ThumbnailViewActions . ACTION _ PLACE . equals ( place )  )  ;", "}", "METHOD_END"], "methodName": ["isEnabledForActionPlace"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI . getImageComponent (  )  . isGridVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isGridVisible"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorUI . getImageComponent (  )  . isTransparencyChessboardVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isTransparencyChessboardVisible"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "ImageDocument   document    =    editorUI . getImageComponent (  )  . getDocument (  )  ;", "return    ( document . getValue (  )  )     !  =    null ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( file . equals ( event . getFile (  )  )  )     {", "file . refresh ( true ,    false ,     (  )     -  >     {", "if    ( ImageFileTypeManager . getInstance (  )  . isImage ( file )  )     {", "setValue ( file )  ;", "} else    {", "setValue ( null )  ;", "FilManager   editorManager    =    FilManager . getInstance ( project )  ;", "editorManager . closeFile ( file )  ;", "}", "}  )  ;", "}", "}", "METHOD_END"], "methodName": ["propertyChanged"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "editorUI . getImageComponent (  )  . setGridVisible ( visible )  ;", "editorUI . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setGridVisible"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "editorUI . getImageComponent (  )  . setTransparencyChessboardVisible ( visible )  ;", "editorUI . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardVisible"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "try    {", "UI . setImageProvider ( IfsUtil . getImageProvider ( file )  ,    IfsUtil . getFormat ( file )  )  ;", "}    catch    ( Exception   e )     {", "UI . setImageProvider ( null ,    null )  ;", "}", "}", "METHOD_END"], "methodName": ["setValue"], "fileName": "org.intellij.images.editor.impl.ImageEditorImpl"}, {"methodBody": ["METHOD_START", "{", "ImageEditorUI   ui    =    new   ImageEditorUI ( null )  ;", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "EditorOptions   editorOptions    =    options . getEditorOptions (  )  ;", "GridOptions   gridOptions    =    editorOptions . getGridOptions (  )  ;", "TransparencyChessboardOptions   transparencyChessboardOptions    =    editorOptions . getTransparencyChessboardOptions (  )  ;", "ui . getImageComponent (  )  . setGridVisible ( gridOptions . isShowDefault (  )  )  ;", "ui . getImageComponent (  )  . setTransparencyChessboardVisible ( transparencyChessboardOptions . isShowDefault (  )  )  ;", "ui . setImageProvider (  (    ignore )     -  >    image ,    null )  ;", "return   ui ;", "}", "METHOD_END"], "methodName": ["createImageEditorUI"], "fileName": "org.intellij.images.editor.impl.ImageEditorManagerImpl"}, {"methodBody": ["METHOD_START", "{", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "options . removePropertyChangeListener ( optionsChangeListener )  ;", "Component . removeMouseWheelListener ( wheelAdapter )  ;", "Component . getDocument (  )  . removeChangeListener ( changeListener )  ;", "removeAll (  )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "VirtualFile   file    =     (  ( editor )     !  =    null )     ?    editor . getFile (  )     :    null ;", "return    ( file    !  =    null )     &  &     ( file . isValid (  )  )     ?    PsiManager . getInstance ( editor . getProject (  )  )  . findFile ( file )     :    null ;", "}", "METHOD_END"], "methodName": ["findPsiFile"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "return   contentPanel ;", "}", "METHOD_END"], "methodName": ["getContentComponent"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "if    ( PROJECT . is ( dataId )  )     {", "return    ( editor )     !  =    null    ?    editor . getProject (  )     :    null ;", "} else", "if    ( CommonDataKeys . VIRTUAL _ FILE . is ( dataId )  )     {", "return    ( editor )     !  =    null    ?    editor . getFile (  )     :    null ;", "} else", "if    ( CommonDataKeys . VIRTUAL _ FILE _ ARRAY . is ( dataId )  )     {", "return    ( editor )     !  =    null    ?    new   com . intellij . openapi . vfs . VirtualFile [  ]  {    editor . getFile (  )     }     :    com . intellij . openapi . vfs . VirtualFile . EMPTY _ ARRAY ;", "} else", "if    ( CommonDataKeys . PSI _ FILE . is ( dataId )  )     {", "return   findPsiFile (  )  ;", "} else", "if    ( CommonDataKeys . PSI _ ELEMENT . is ( dataId )  )     {", "return   findPsiFile (  )  ;", "} else", "if    ( LangDataKeys . PSI _ ELEMENT _ ARRAY . is ( dataId )  )     {", "com . intellij . psi . PsiElement   psi    =    findPsiFile (  )  ;", "return   psi    !  =    null    ?    new   com . intellij . psi . PsiElement [  ]  {    psi    }     :    com . intellij . psi . PsiElement . EMPTY _ ARRAY ;", "} else", "if    (  ( PlatformDataKeys . COPY _ PROVIDER . is ( dataId )  )     &  &     (  ( copyPasteSupport )     !  =    null )  )     {", "return   this ;", "} else", "if    (  ( PlatformDataKeys . CUT _ PROVIDER . is ( dataId )  )     &  &     (  ( copyPasteSupport )     !  =    null )  )     {", "return   copyPasteSupport . getCutProvider (  )  ;", "} else", "if    ( PlatformDataKeys . DELETE _ ELEMENT _ PROVIDER . is ( dataId )  )     {", "return   deleteProvider ;", "} else", "if    ( ui . ImageComponentDecorator . DATA _ KEY . is ( dataId )  )     {", "return    ( editor )     !  =    null    ?    editor    :    this ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "return   imageComponent ;", "}", "METHOD_END"], "methodName": ["getImageComponent"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image    =    imageComponent . getDocument (  )  . getValue (  )  ;", "if    ( image    =  =    null )", "return   null ;", "if    (  (  ( image . getWidth (  )  )     =  =     0  )     |  |     (  ( image . getHeight (  )  )     =  =     0  )  )", "return   null ;", "Dimension   preferredMinimumSize    =    zoomOptions . getPrefferedSize (  )  ;", "if    (  (  ( image . getWidth (  )  )     <     ( preferredMinimumSize . width )  )     &  &     (  ( image . getHeight (  )  )     <     ( preferredMinimumSize . height )  )  )     {", "double   factor    =     (  (  ( preferredMinimumSize . getWidth (  )  )     /     (  ( double )     ( image . getWidth (  )  )  )  )     +     (  ( preferredMinimumSize . getHeight (  )  )     /     (  ( double )     ( image . getHeight (  )  )  )  )  )     /     2  .  0  ;", "return   Math . ceil ( factor )  ;", "}", "Dimension   canvasSize    =    myScrollPane . getViewport (  )  . getExtentSize (  )  ;", "canvasSize . height    -  =     ( ImageComponent . IMAGE _ INSETS )     *     2  ;", "canvasSize . width    -  =     ( ImageComponent . IMAGE _ INSETS )     *     2  ;", "if    (  (  ( canvasSize . width )     <  =     0  )     |  |     (  ( canvasSize . height )     <  =     0  )  )", "return   null ;", "if    (  (  ( canvasSize . width )     <     ( image . getWidth (  )  )  )     |  |     (  ( canvasSize . height )     <     ( image . getHeight (  )  )  )  )     {", "return   Math . min (  (  (  ( double )     ( canvasSize . height )  )     /     ( image . getHeight (  )  )  )  ,     (  (  ( double )     ( canvasSize . width )  )     /     ( image . getWidth (  )  )  )  )  ;", "}", "return    1  .  0  ;", "}", "METHOD_END"], "methodName": ["getSmartZoomFactor"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "return   zoomModel ;", "}", "METHOD_END"], "methodName": ["getZoomModel"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "ImageDocument   document    =    imageComponent . getDocument (  )  ;", "BufferedImage   previousImage    =    document . getValue (  )  ;", "document . setValue ( imageProvider )  ;", "if    ( imageProvider    =  =    null )", "return ;", "document . setFormat ( format )  ;", "if    (  ( previousImage    =  =    null )     |  |     (  !  ( zoomModel . isZoomLevelChanged (  )  )  )  )     {", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "ZoomOptions   zoomOptions    =    options . getOptions (  )  . getZoomOptions (  )  ;", "if    ( zoomOptions . isSmartZooming (  )  )     {", "updateZoomFactor (  )  ;", "} else    {", "zoomModel . setZoomFactor (  1  .  0  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["setImageProvider"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image    =    imageComponent . getDocument (  )  . getValue (  )  ;", "if    ( image    !  =    null )     {", "final   double   zoom    =    getZoomModel (  )  . getZoomFactor (  )  ;", "imageComponent . setCanvasSize (  (  ( int )     ( Math . ceil (  (  ( image . getWidth (  )  )     *    zoom )  )  )  )  ,     (  ( int )     ( Math . ceil (  (  ( image . getHeight (  )  )     *    zoom )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateImageComponentSize"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "ImageDocument   document    =    imageComponent . getDocument (  )  ;", "BufferedImage   image    =    document . getValue (  )  ;", "if    ( image    !  =    null )     {", "ColorModel   colorModel    =    image . getColorModel (  )  ;", "String   format    =    document . getFormat (  )  ;", "if    ( format    =  =    null )     {", "format    =     (  (     !  =    null )     ?    ImagesBundle . message (  \" unknown . format \"  )     :     \"  \"  ;", "} else    {", "format    =    format . toUpperCase ( Locale . ENGLISH )  ;", "}", "VirtualFile   file    =     (  (     !  =    null )     ?    getFile (  )     :    null ;", "infoLabel . setText ( ImagesBundle . message (  \" image . info \"  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    format ,    colorModel . getPixelSize (  )  ,     ( file    !  =    null    ?    StringUtil . formatFileSize ( file . getLength (  )  )     :     \"  \"  )  )  )  ;", "} else    {", "infoLabel . setText ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["updateInfo"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "ZoomOptions   zoomOptions    =    options . getOptions (  )  . getZoomOptions (  )  ;", "if    (  ( zoomOptions . isSmartZooming (  )  )     &  &     (  !  ( zoomModel . isZoomLevelChanged (  )  )  )  )     {", "Double   smartZoomFactor    =    getSmartZoomFactor ( zoomOptions )  ;", "if    ( smartZoomFactor    !  =    null )     {", "zoomModel . setZoomFactor ( smartZoomFactor )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["updateZoomFactor"], "fileName": "org.intellij.images.editor.impl.ImageEditorUI"}, {"methodBody": ["METHOD_START", "{", "myDispatcher . addListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addPropertyChangeListener"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getBackgroundHighlighter"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   imageEditor . getComponent (  )  ;", "}", "METHOD_END"], "methodName": ["getComponent"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getCurrentLocation"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   imageEditor ;", "}", "METHOD_END"], "methodName": ["getImageEditor"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   ImageFileEditorImpl . NAME ;", "}", "METHOD_END"], "methodName": ["getName"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   imageEditor . getContentComponent (  )  ;", "}", "METHOD_END"], "methodName": ["getPreferredFocusedComponent"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "ImageZoomModel   zoomModel    =    imageEditor . getZoomModel (  )  ;", "return   new   State ( imageEditor . isTransparencyChessboardVisible (  )  ,    imageEditor . isGridVisible (  )  ,    zoomModel . getZoomFactor (  )  ,    zoomModel . isZoomLevelChanged (  )  )  ;", "}", "METHOD_END"], "methodName": ["getState"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   null ;", "}", "METHOD_END"], "methodName": ["getStructureViewBuilder"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   false ;", "}", "METHOD_END"], "methodName": ["isModified"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isValid"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "myDispatcher . removeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removePropertyChangeListener"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( state   instanceof   ImageFileEditorState )     {", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "ZoomOptions   zoomOptions    =    options . getEditorOptions (  )  . getZoomOptions (  )  ;", "ImageFileEditorState   editorState    =     (  ( ImageFileEditorState )     ( state )  )  ;", "ImageZoomModel   zoomModel    =    imageEditor . getZoomModel (  )  ;", "imageEditor . setTransparencyChessboardVisible ( editorState . isBackgroundVisible (  )  )  ;", "imageEditor . setGridVisible ( editorState . isGridVisible (  )  )  ;", "if    (  ( editorState . isZoomFactorChanged (  )  )     |  |     (  !  ( zoomOptions . isSmartZooming (  )  )  )  )     {", "zoomModel . setZoomFactor ( editorState . getZoomFactor (  )  )  ;", "}", "zoomModel . setZoomLevelChanged ( editorState . isZoomFactorChanged (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setState"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorImpl"}, {"methodBody": ["METHOD_START", "{", "return   zoomFactor ;", "}", "METHOD_END"], "methodName": ["getZoomFactor"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorState"}, {"methodBody": ["METHOD_START", "{", "return   backgroundVisible ;", "}", "METHOD_END"], "methodName": ["isBackgroundVisible"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorState"}, {"methodBody": ["METHOD_START", "{", "return   gridVisible ;", "}", "METHOD_END"], "methodName": ["isGridVisible"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorState"}, {"methodBody": ["METHOD_START", "{", "return   zoomFactorChanged ;", "}", "METHOD_END"], "methodName": ["isZoomFactorChanged"], "fileName": "org.intellij.images.editor.impl.ImageFileEditorState"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( ImageFileTypeManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.images.fileTypes.ImageFileTypeManager"}, {"methodBody": ["METHOD_START", "{", "final   Set < String >    processed    =    new   gnu . trove . THashSet (  )  ;", "final   String [  ]    readerFormatNames    =    ImageIO . getReaderFormatNames (  )  ;", "for    ( String   format    :    readerFormatNames )     {", "final   String   ext    =    format . toLowerCase (  )  ;", "processed . add ( ext )  ;", "}", "processed . add ( IfsUtil . ICO _ FORMAT . toLowerCase (  )  )  ;", "consumer . consume (  . imageFileType ,    StringUtil . join ( processed ,    EXTENSION _ DELIMITER )  )  ;", "consumer . consume ( SvgFileType . INSTANCE ,     \" svg \"  )  ;", "}", "METHOD_END"], "methodName": ["createFileTypes"], "fileName": "org.intellij.images.fileTypes.impl.ImageFileTypeManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   ImageFileTypeManagerImpl . imageFileType ;", "}", "METHOD_END"], "methodName": ["getImageFileType"], "fileName": "org.intellij.images.fileTypes.impl.ImageFileTypeManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( file . getFileType (  )  )    instanceof   ImageFileTypeManagerImpl . ImageFileType )     |  |     (  ( file . getFileType (  )  )    instanceof   SvgFileType )  ;", "}", "METHOD_END"], "methodName": ["isImage"], "fileName": "org.intellij.images.fileTypes.impl.ImageFileTypeManagerImpl"}, {"methodBody": ["METHOD_START", "{", "FileBasedIndex . getInstance (  )  . processValues ( ImageInfoIndex . INDEX _ ID ,    Math . abs ( FileBasedIndex . getFileId ( virtualFile )  )  ,    virtualFile ,    processor ,    GlobalSearchScope . fileScope ( project ,    virtualFile )  )  ;", "}", "METHOD_END"], "methodName": ["processValues"], "fileName": "org.intellij.images.index.ImageInfoIndex"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( OptionsManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.images.options.OptionsManager"}, {"methodBody": ["METHOD_START", "{", "return    (  ( EditorOptions )     ( super . clone (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )     {", "return   true ;", "}", "if    (  !  ( obj   instanceof    )  )     {", "return   false ;", "}", "otherOptions    =     (  (  )     ( obj )  )  ;", "GridOptions   gridOptions    =    otherOptions . getGridOptions (  )  ;", "TransparencyChessboardOptions   chessboardOptions    =    otherOptions . getTransparencyChessboardOptions (  )  ;", "ZoomOptions   zoomOptions    =    otherOptions . getZoomOptions (  )  ;", "return    (  (  (  (  ( gridOptions    !  =    null )     &  &     ( gridOptions . equals ( getGridOptions (  )  )  )  )     &  &     ( chessboardOptions    !  =    null )  )     &  &     ( chessboardOptions . equals ( getTransparencyChessboardOptions (  )  )  )  )     &  &     ( zoomOptions    !  =    null )  )     &  &     ( zoomOptions . equals ( getZoomOptions (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   gridOptions ;", "}", "METHOD_END"], "methodName": ["getGridOptions"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   transparencyChessboardOptions ;", "}", "METHOD_END"], "methodName": ["getTransparencyChessboardOptions"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   zoomOptions ;", "}", "METHOD_END"], "methodName": ["getZoomOptions"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( gridO    !  =    null )     ?    gridOhashCode (  )     :     0  ;", "result    =     (  2  9     *    result )     +     (  ( transparencyChessboardO    !  =    null    ?    transparencyChessboardOhashCode (  )     :     0  )  ;", "result    =     (  2  9     *    result )     +     (  ( zoomO    !  =    null    ?    zoomOhashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "gridOptions . inject ( options . getGridOptions (  )  )  ;", "transparencyChessboardOptions . inject ( options . getTransparencyChessboardOptions (  )  )  ;", "zoomOptions . inject ( options . getZoomOptions (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "(  ( JDOMExternalizable )     ( gridOptions )  )  . readExternal ( element )  ;", "(  ( JDOMExternalizable )     ( transparencyChessboardOptions )  )  . readExternal ( element )  ;", "(  ( JDOMExternalizable )     ( zoomOptions )  )  . readExternal ( element )  ;", "String   fileNameVisibleAttr    =    element . getAttributeValue (  \" fileNameVisible \"  )  ;", "fileNameVisible    =     ( fileNameVisibleAttr    =  =    null )     |  |     ( Boolean . parseBoolean ( fileNameVisibleAttr )  )  ;", "String   fileSizeVisibleAttr    =    element . getAttributeValue (  \" fileSizeVisible \"  )  ;", "fileSizeVisible    =     ( fileNameVisibleAttr    =  =    null )     |  |     ( Boolean . parseBoolean ( fileSizeVisibleAttr )  )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( gridOptions . setOption ( name ,    value )  )     |  |     ( transparencyChessboardOptions . setOption ( name ,    value )  )  )     |  |     ( zoomOptions . setOption ( name ,    value )  )  ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "(  ( JDOMExternalizable )     ( gridOptions )  )  . writeExternal ( element )  ;", "(  ( JDOMExternalizable )     ( transparencyChessboardOptions )  )  . writeExternal ( element )  ;", "(  ( JDOMExternalizable )     ( zoomOptions )  )  . writeExternal ( element )  ;", "if    (  !  ( fileNameVisible )  )     {", "element . setAttribute (  \" fileNameVisible \"  ,     \" false \"  )  ;", "}", "if    (  !  ( fileSizeVisible )  )     {", "element . setAttribute (  \" fileSizeVisible \"  ,     \" false \"  )  ;", "}", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.EditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return    (  ( ExternalEditorOptions )     ( super . clone (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["clone"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  !  ( o   instanceof    )  )     {", "return   false ;", "}", "otherOptions    =     (  (  )     ( o )  )  ;", "return    ( executablePath )     !  =    null    ?    executablePath . equals ( otherOptions . getExecutablePath (  )  )     :     ( otherOptions . getExecutablePath (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   executablePath ;", "}", "METHOD_END"], "methodName": ["getExecutablePath"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( executablePath )     !  =    null    ?    executablePath . hashCode (  )     :     0  ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setExecutablePath ( options . getExecutablePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "executablePath    =    JDOMExternalizer . readString ( element ,    ExternalEditorOptions . ATTR _ EXECUTABLE _ PATH )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "String   oldValue    =    this . executablePath ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( executablePath )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( executablePath    !  =    null )  )  )     {", "this . executablePath    =    executablePath ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ EXECUTABLE _ PATH ,    oldValue ,    this . executablePath )  ;", "}", "}", "METHOD_END"], "methodName": ["setExecutablePath"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( ExternalEditorOptions . ATTR _ EXECUTABLE _ PATH . equals ( name )  )     {", "setExecutablePath (  (  ( String )     ( value )  )  )  ;", "} else    {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "JDOMExternalizer . write ( element ,    ExternalEditorOptions . ATTR _ EXECUTABLE _ PATH ,    executablePath )  ;", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.ExternalEditorOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    obj )     {", "return   true ;", "}", "if    (  !  ( obj   instanceof    )  )     {", "return   false ;", "}", "otherOptions    =     (  (  )     ( obj )  )  ;", "return    (  (  (  ( lineMinZoomFactor )     =  =     ( otherOptions . getLineZoomFactor (  )  )  )     &  &     (  ( lineSpan )     =  =     ( otherOptions . getLineSpan (  )  )  )  )     &  &     (  ( showDefault )     =  =     ( otherOptions . isShowDefault (  )  )  )  )     &  &     (  ( lineColor )     !  =    null )     ?    lineColor . equals ( otherOptions . getLineColor (  )  )     :     ( otherOptions . getLineColor (  )  )     =  =    null ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   lineColor ;", "}", "METHOD_END"], "methodName": ["getLineColor"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   lineSpan ;", "}", "METHOD_END"], "methodName": ["getLineSpan"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   lineMinZoomFactor ;", "}", "METHOD_END"], "methodName": ["getLineZoomFactor"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     ( showDefault )     ?     1     :     0  ;", "result    =     (  2  9     *    result )     +     ( lineMinZoomFactor )  ;", "result    =     (  2  9     *    result )     +     ( lineSpan )  ;", "result    =     (  2  9     *    result )     +     (  ( lineColor )     !  =    null    ?    lineColor . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setShowDefault ( options . isShowDefault (  )  )  ;", "setLineMinZoomFactor ( options . getLineZoomFactor (  )  )  ;", "setLineSpan ( options . getLineSpan (  )  )  ;", "setLineColor ( options . getLineColor (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   showDefault ;", "}", "METHOD_END"], "methodName": ["isShowDefault"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "showDefault    =    JDOMExternalizer . readBoolean ( element ,    GridOptions . ATTR _ SHOW _ DEFAULT )  ;", "lineMinZoomFactor    =    JDOMExternalizer . readInteger ( element ,    GridOptions . ATTR _ LINE _ ZOOM _ FACTOR ,    GridOptions . DEFAULT _ LINE _ ZOOM _ FACTOR )  ;", "lineSpan    =    JDOMExternalizer . readInteger ( element ,    GridOptions . ATTR _ LINE _ SPAN ,    GridOptions . DEFAULT _ LINE _ SPAN )  ;", "lineColor    =    JDOMExternalizerEx . readColor ( element ,    GridOptions . ATTR _ LINE _ COLOR ,    GridOptions . DEFAULT _ LINE _ COLOR )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "Color   oldColor    =    this . lineColor ;", "if    ( lineColor    =  =    null )     {", "this . lineColor    =     . DEFAULT _ LINE _ COLOR ;", "}", "if    (  !  ( oldColor . equals ( lineColor )  )  )     {", "this . lineColor    =    lineColor ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ LINE _ COLOR ,    oldColor ,    this . lineColor )  ;", "}", "}", "METHOD_END"], "methodName": ["setLineColor"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . lineMinZoomFactor ;", "if    ( oldValue    !  =    lineMinZoomFactor )     {", "this . lineMinZoomFactor    =    lineMinZoomFactor ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ LINE _ ZOOM _ FACTOR ,    oldValue ,    this . lineMinZoomFactor )  ;", "}", "}", "METHOD_END"], "methodName": ["setLineMinZoomFactor"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . lineSpan ;", "if    ( oldValue    !  =    lineSpan )     {", "this . lineSpan    =    lineSpan ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ LINE _ SPAN ,    oldValue ,    this . lineSpan )  ;", "}", "}", "METHOD_END"], "methodName": ["setLineSpan"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( GridOptions . ATTR _ SHOW _ DEFAULT . equals ( name )  )     {", "setShowDefault (  (  ( Boolean )     ( value )  )  )  ;", "} else", "if    ( GridOptions . ATTR _ LINE _ ZOOM _ FACTOR . equals ( name )  )     {", "setLineMinZoomFactor (  (  ( Integer )     ( value )  )  )  ;", "} else", "if    ( GridOptions . ATTR _ LINE _ SPAN . equals ( name )  )     {", "setLineSpan (  (  ( Integer )     ( value )  )  )  ;", "} else", "if    ( GridOptions . ATTR _ LINE _ COLOR . equals ( name )  )     {", "setLineColor (  (  ( Color )     ( value )  )  )  ;", "} else    {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    this . showDefault ;", "if    ( oldValue    !  =    showDefault )     {", "this . showDefault    =    showDefault ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ SHOW _ DEFAULT ,    oldValue ,    this . showDefault )  ;", "}", "}", "METHOD_END"], "methodName": ["setShowDefault"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "JDOMExternalizer . write ( element ,    GridOptions . ATTR _ SHOW _ DEFAULT ,    showDefault )  ;", "JDOMExternalizer . write ( element ,    GridOptions . ATTR _ LINE _ ZOOM _ FACTOR ,    lineMinZoomFactor )  ;", "JDOMExternalizer . write ( element ,    GridOptions . ATTR _ LINE _ SPAN ,    lineSpan )  ;", "JDOMExternalizerEx . write ( element ,    GridOptions . ATTR _ LINE _ COLOR ,    lineColor )  ;", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.GridOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myComponent )     !  =    null )     {", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "nject ( myComponent . getOptions (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["apply"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myComponent )     =  =    null )     {", "myComponent    =    new   ImagesOptionsComponent (  )  ;", "Options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "addPropertyChangeListener ( this )  ;", "myComponent . getOptions (  )  . inject (  ;", "myComponent . updateUI (  )  ;", "myComponent . getOptions (  )  . addPropertyChangeListener ( this )  ;", "setModified ( false )  ;", "}", "return   myComponent . getContentPane (  )  ;", "}", "METHOD_END"], "methodName": ["createComponent"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myComponent )     !  =    null )     {", "Options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "removePropertyChangeListener ( this )  ;", "myComponent . getOptions (  )  . removePropertyChangeListener ( this )  ;", "myComponent    =    null ;", "}", "}", "METHOD_END"], "methodName": ["disposeUIResources"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   ImagesConfigurable . DISPLAY _ NAME ;", "}", "METHOD_END"], "methodName": ["getDisplayName"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "return    \" Images \"  ;", "}", "METHOD_END"], "methodName": ["getId"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "Options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "Options   uiOptions    =    myComponent . getOptions (  )  ;", "setModified (  (  !  ( equals ( uiOptions )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["propertyChange"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "if    (  ( myComponent )     !  =    null )     {", "Options       =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "myComponent . getOptions (  )  . inject (  )  ;", "myComponent . updateUI (  )  ;", "}", "}", "METHOD_END"], "methodName": ["reset"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "ShowSettingsUtil . getInstance (  )  . editConfigurable ( project ,    new   ImagesConfigurable (  )  )  ;", "}", "METHOD_END"], "methodName": ["show"], "fileName": "org.intellij.images.options.impl.ImagesConfigurable"}, {"methodBody": ["METHOD_START", "{", "return   contentPane ;", "}", "METHOD_END"], "methodName": ["getContentPane"], "fileName": "org.intellij.images.options.impl.ImagesOptionsComponent"}, {"methodBody": ["METHOD_START", "{", "return   options ;", "}", "METHOD_END"], "methodName": ["getOptions"], "fileName": "org.intellij.images.options.impl.ImagesOptionsComponent"}, {"methodBody": ["METHOD_START", "{", "EditorOptions   editorOptions    =    options . getEditorOptions (  )  ;", "ExternalEditorOptions   externalEditorOptions    =    options . getExternalEditorOptions (  )  ;", "GridOptions   gridOptions    =    editorOptions . getGridOptions (  )  ;", "showGrid . setSelected ( gridOptions . isShowDefault (  )  )  ;", "gridLineZoomFactor . setValue ( gridOptions . getLineZoomFactor (  )  )  ;", "gridLineSpan . setValue ( gridOptions . getLineSpan (  )  )  ;", "gridLineColor . setSelectedColor ( gridOptions . getLineColor (  )  )  ;", "TransparencyChessboardOptions   transparencyChessboardOptions    =    editorOptions . getTransparencyChessboardOptions (  )  ;", "showChessboard . setSelected ( transparencyChessboardOptions . isShowDefault (  )  )  ;", "chessboardSize . setValue ( transparencyChessboardOptions . getCellSize (  )  )  ;", "chessboardWhiteColor . setSelectedColor ( transparencyChessboardOptions . getWhiteColor (  )  )  ;", "chessboardBlackColor . setSelectedColor ( transparencyChessboardOptions . getBlackColor (  )  )  ;", "ZoomOptions   zoomOptions    =    editorOptions . getZoomOptions (  )  ;", "wheelZooming . setSelected ( zoomOptions . isWheelZooming (  )  )  ;", "smartZooming . setSelected ( zoomOptions . isSmartZooming (  )  )  ;", "Dimension   prefferedSize    =    zoomOptions . getPrefferedSize (  )  ;", "smartZoomingWidth . setValue ( prefferedSize . width )  ;", "smartZoomingHeight . setValue ( prefferedSize . height )  ;", "externalEditorPath . setText ( externalEditorOptions . getExecutablePath (  )  )  ;", "}", "METHOD_END"], "methodName": ["updateUI"], "fileName": "org.intellij.images.options.impl.ImagesOptionsComponent"}, {"methodBody": ["METHOD_START", "{", "String   colorValue    =    JDOMExternalizer . readString ( root ,    name )  ;", "if    ( colorValue    !  =    null )     {", "try    {", "return   new   Color ( Integer . parseInt ( colorValue ,     1  6  )  )  ;", "}    catch    ( NumberFormatException   e )     {", "}", "}", "return   defaultValue ;", "}", "METHOD_END"], "methodName": ["readColor"], "fileName": "org.intellij.images.options.impl.JDOMExternalizerEx"}, {"methodBody": ["METHOD_START", "{", "if    ( value    !  =    null )     {", ". write ( root ,    name ,    Integer . toString (  (  ( value . getRGB (  )  )     &     1  6  7  7  7  2  1  5  )  ,     1  6  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["write"], "fileName": "org.intellij.images.options.impl.JDOMExternalizerEx"}, {"methodBody": ["METHOD_START", "{", "propertyChangeSupport . addPropertyChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["addPropertyChangeListener"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "propertyChangeSupport . addPropertyChangeListener ( propertyName ,    listener )  ;", "}", "METHOD_END"], "methodName": ["addPropertyChangeListener"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( obj    =  =     ( this )  )     {", "return   true ;", "}", "if    (  !  ( obj   instanceof    )  )     {", "return   false ;", "}", "other    =     (  (  )     ( obj )  )  ;", "Editor   editor    =    other . getEditor (  )  ;", "ExternalEditor   externalEditor    =    other . getExternalEditor (  )  ;", "return    (  (  ( editor    !  =    null )     &  &     ( editor . equals ( getEditor (  )  )  )  )     &  &     ( externalEditor    !  =    null )  )     &  &     ( externalEditor . equals ( getExternalEditor (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   editorOptions ;", "}", "METHOD_END"], "methodName": ["getEditorOptions"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   externalEditorOptions ;", "}", "METHOD_END"], "methodName": ["getExternalEditorOptions"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     (  ( editorO    !  =    null )     ?    editorOhashCode (  )     :     0  ;", "result    =     (  2  9     *    result )     +     (  ( externalEditorO    !  =    null    ?    externalEditorOhashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "editorOptions . inject ( options . getEditorOptions (  )  )  ;", "externalEditorOptions . inject ( options . getExternalEditorOptions (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "(  ( JDOMExternalizable )     ( editorOptions )  )  . readExternal ( element )  ;", "(  ( JDOMExternalizable )     ( externalEditorOptions )  )  . readExternal ( element )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "propertyChangeSupport . removePropertyChangeListener ( listener )  ;", "}", "METHOD_END"], "methodName": ["removePropertyChangeListener"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "propertyChangeSupport . removePropertyChangeListener ( propertyName ,    listener )  ;", "}", "METHOD_END"], "methodName": ["removePropertyChangeListener"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( editorOptions . setOption ( name ,    value )  )     |  |     ( externalEditorOptions . setOption ( name ,    value )  )  ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "(  ( JDOMExternalizable )     ( editorOptions )  )  . writeExternal ( element )  ;", "(  ( JDOMExternalizable )     ( externalEditorOptions )  )  . writeExternal ( element )  ;", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.OptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    o )     {", "return   true ;", "}", "if    (  !  ( o   instanceof    )  )     {", "return   false ;", "}", "otherOptions    =     (  (  )     ( o )  )  ;", "return    (  (  (  ( cellSize )     =  =     ( otherOptions . getCellSize (  )  )  )     &  &     (  ( showDefault )     =  =     ( otherOptions . isShowDefault (  )  )  )  )     &  &     (  ( blackColor )     !  =    null    ?    blackColor . equals ( otherOptions . getBlackColor (  )  )     :     ( otherOptions . getBlackColor (  )  )     =  =    null )  )     &  &     (  ( whiteColor )     !  =    null    ?    whiteColor . equals ( otherOptions . getWhiteColor (  )  )     :     ( otherOptions . getWhiteColor (  )  )     =  =    null )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   blackColor ;", "}", "METHOD_END"], "methodName": ["getBlackColor"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   cellSize ;", "}", "METHOD_END"], "methodName": ["getCellSize"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   whiteColor ;", "}", "METHOD_END"], "methodName": ["getWhiteColor"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     ( showDefault )     ?     1     :     0  ;", "result    =     (  2  9     *    result )     +     ( cellSize )  ;", "result    =     (  2  9     *    result )     +     (  ( whiteColor )     !  =    null    ?    whiteColor . hashCode (  )     :     0  )  ;", "result    =     (  2  9     *    result )     +     (  ( blackColor )     !  =    null    ?    blackColor . hashCode (  )     :     0  )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setShowDefault ( options . isShowDefault (  )  )  ;", "setCellSize ( options . getCellSize (  )  )  ;", "setWhiteColor ( options . getWhiteColor (  )  )  ;", "setBlackColor ( options . getBlackColor (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   showDefault ;", "}", "METHOD_END"], "methodName": ["isShowDefault"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setShowDefault ( JDOMExternalizer . readBoolean ( element ,    TransparencyChessboardOptions . ATTR _ SHOW _ DEFAULT )  )  ;", "setCellSize ( JDOMExternalizer . readInteger ( element ,    TransparencyChessboardOptions . ATTR _ CELL _ SIZE ,    TransparencyChessboardOptions . DEFAULT _ CELL _ SIZE )  )  ;", "setWhiteColor ( JDOMExternalizerEx . readColor ( element ,    TransparencyChessboardOptions . ATTR _ WHITE _ COLOR ,    TransparencyChessboardOptions . DEFAULT _ WHITE _ COLOR )  )  ;", "setBlackColor ( JDOMExternalizerEx . readColor ( element ,    TransparencyChessboardOptions . ATTR _ BLACK _ COLOR ,    TransparencyChessboardOptions . DEFAULT _ BLACK _ COLOR )  )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "Color   oldValue    =    this . blackColor ;", "if    ( blackColor    =  =    null )     {", "blackColor    =     . DEFAULT _ BLACK _ COLOR ;", "}", "if    (  !  ( oldValue . equals ( blackColor )  )  )     {", "this . blackColor    =    blackColor ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ BLACK _ COLOR ,    oldValue ,    this . blackColor )  ;", "}", "}", "METHOD_END"], "methodName": ["setBlackColor"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . cellSize ;", "if    ( oldValue    !  =    cellSize )     {", "this . cellSize    =    cellSize ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ CELL _ SIZE ,    oldValue ,    this . cellSize )  ;", "}", "}", "METHOD_END"], "methodName": ["setCellSize"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( TransparencyChessboardOptions . ATTR _ SHOW _ DEFAULT . equals ( name )  )     {", "setShowDefault (  (  ( Boolean )     ( value )  )  )  ;", "} else", "if    ( TransparencyChessboardOptions . ATTR _ CELL _ SIZE . equals ( name )  )     {", "setCellSize (  (  ( Integer )     ( value )  )  )  ;", "} else", "if    ( TransparencyChessboardOptions . ATTR _ WHITE _ COLOR . equals ( name )  )     {", "setWhiteColor (  (  ( Color )     ( value )  )  )  ;", "} else", "if    ( TransparencyChessboardOptions . ATTR _ BLACK _ COLOR . equals ( name )  )     {", "setBlackColor (  (  ( Color )     ( value )  )  )  ;", "} else    {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    this . showDefault ;", "if    ( oldValue    !  =    showDefault )     {", "this . showDefault    =    showDefault ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ SHOW _ DEFAULT ,    oldValue ,    this . showDefault )  ;", "}", "}", "METHOD_END"], "methodName": ["setShowDefault"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "Color   oldValue    =    this . whiteColor ;", "if    ( whiteColor    =  =    null )     {", "this . whiteColor    =     . DEFAULT _ WHITE _ COLOR ;", "}", "if    (  !  ( oldValue . equals ( whiteColor )  )  )     {", "this . whiteColor    =    whiteColor ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ WHITE _ COLOR ,    oldValue ,    this . whiteColor )  ;", "}", "}", "METHOD_END"], "methodName": ["setWhiteColor"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "JDOMExternalizer . write ( element ,    TransparencyChessboardOptions . ATTR _ SHOW _ DEFAULT ,    showDefault )  ;", "JDOMExternalizer . write ( element ,    TransparencyChessboardOptions . ATTR _ CELL _ SIZE ,    cellSize )  ;", "JDOMExternalizerEx . write ( element ,    TransparencyChessboardOptions . ATTR _ WHITE _ COLOR ,    whiteColor )  ;", "JDOMExternalizerEx . write ( element ,    TransparencyChessboardOptions . ATTR _ BLACK _ COLOR ,    blackColor )  ;", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.TransparencyChessboardOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( this )     =  =    obj )     {", "return   true ;", "}", "if    (  !  ( obj   instanceof    )  )     {", "return   false ;", "}", "otherOptions    =     (  (  )     ( obj )  )  ;", "Dimension   prefferedSize    =    otherOptions . getPrefferedSize (  )  ;", "return    (  (  (  ( prefferedSize    !  =    null )     &  &     (  ( prefferedHeight )     =  =     ( prefferedSize . height )  )  )     &  &     (  ( prefferedWidth )     =  =     ( prefferedSize . width )  )  )     &  &     (  ( smartZooming )     =  =     ( otherOptions . isSmartZooming (  )  )  )  )     &  &     (  ( wheelZooming )     =  =     ( otherOptions . isWheelZooming (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["equals"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   new   Dimension ( prefferedWidth ,    prefferedHeight )  ;", "}", "METHOD_END"], "methodName": ["getPrefferedSize"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   result ;", "result    =     ( wheeling )     ?     1     :     0  ;", "result    =     (  2  9     *    result )     +     ( smarting    ?     1     :     0  )  ;", "result    =     (  2  9     *    result )     +     ( prefferedWidth )  ;", "result    =     (  2  9     *    result )     +     ( prefferedHeight )  ;", "return   result ;", "}", "METHOD_END"], "methodName": ["hashCode"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setWheelZooming ( options . isWheelZooming (  )  )  ;", "setSmartZooming ( options . isSmartZooming (  )  )  ;", "setPrefferedSize ( options . getPrefferedSize (  )  )  ;", "}", "METHOD_END"], "methodName": ["inject"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   smartZooming ;", "}", "METHOD_END"], "methodName": ["isSmartZooming"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "return   wheelZooming ;", "}", "METHOD_END"], "methodName": ["isWheelZooming"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "setWheelZooming ( JDOMExternalizer . readBoolean ( element ,    ZoomOptions . ATTR _ WHEEL _ ZOOMING )  )  ;", "setSmartZooming ( JDOMExternalizer . readBoolean ( element ,    ZoomOptions . ATTR _ SMART _ ZOOMING )  )  ;", "setPrefferedWidth ( JDOMExternalizer . readInteger ( element ,    ZoomOptions . ATTR _ PREFFERED _ WIDTH ,     . DEFAULT _ PREFFERED _ SIZE . width )  )  ;", "setPrefferedHeight ( JDOMExternalizer . readInteger ( element ,    ZoomOptions . ATTR _ PREFFERED _ HEIGHT ,     . DEFAULT _ PREFFERED _ SIZE . height )  )  ;", "}", "METHOD_END"], "methodName": ["readExternal"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( ZoomOptions . ATTR _ WHEEL _ ZOOMING . equals ( name )  )     {", "setWheelZooming (  (  ( Boolean )     ( value )  )  )  ;", "} else", "if    ( ZoomOptions . ATTR _ SMART _ ZOOMING . equals ( name )  )     {", "setSmartZooming (  (  ( Boolean )     ( value )  )  )  ;", "} else", "if    ( ZoomOptions . ATTR _ PREFFERED _ WIDTH . equals ( name )  )     {", "setPrefferedWidth (  (  ( Integer )     ( value )  )  )  ;", "} else", "if    ( ZoomOptions . ATTR _ PREFFERED _ HEIGHT . equals ( name )  )     {", "setPrefferedHeight (  (  ( Integer )     ( value )  )  )  ;", "} else    {", "return   false ;", "}", "return   true ;", "}", "METHOD_END"], "methodName": ["setOption"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . prefferedHeight ;", "if    ( oldValue    !  =    prefferedHeight )     {", "this . prefferedHeight    =    prefferedHeight ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ PREFFERED _ HEIGHT ,    oldValue ,    this . prefferedHeight )  ;", "}", "}", "METHOD_END"], "methodName": ["setPrefferedHeight"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( prefferedSize    =  =    null )     {", "prefferedSize    =     . DEFAULT _ PREFFERED _ SIZE ;", "}", "setPrefferedWidth ( prefferedSize . width )  ;", "setPrefferedHeight ( prefferedSize . height )  ;", "}", "METHOD_END"], "methodName": ["setPrefferedSize"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . prefferedWidth ;", "if    ( oldValue    !  =    prefferedWidth )     {", "this . prefferedWidth    =    prefferedWidth ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ PREFFERED _ WIDTH ,    oldValue ,    this . prefferedWidth )  ;", "}", "}", "METHOD_END"], "methodName": ["setPrefferedWidth"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    this . smartZooming ;", "if    ( oldValue    !  =    smartZooming )     {", "this . smartZooming    =    smartZooming ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ SMART _ ZOOMING ,    oldValue ,    this . smartZooming )  ;", "}", "}", "METHOD_END"], "methodName": ["setSmartZooming"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    this . wheelZooming ;", "if    ( oldValue    !  =    wheelZooming )     {", "this . wheelZooming    =    wheelZooming ;", "propertyChangeSupport . firePropertyChange (  . ATTR _ WHEEL _ ZOOMING ,    oldValue ,    this . wheelZooming )  ;", "}", "}", "METHOD_END"], "methodName": ["setWheelZooming"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "JDOMExternalizer . write ( element ,    ZoomOptions . ATTR _ WHEEL _ ZOOMING ,    wheelZooming )  ;", "JDOMExternalizer . write ( element ,    ZoomOptions . ATTR _ SMART _ ZOOMING ,    smartZooming )  ;", "JDOMExternalizer . write ( element ,    ZoomOptions . ATTR _ PREFFERED _ WIDTH ,    prefferedWidth )  ;", "JDOMExternalizer . write ( element ,    ZoomOptions . ATTR _ PREFFERED _ HEIGHT ,    prefferedHeight )  ;", "}", "METHOD_END"], "methodName": ["writeExternal"], "fileName": "org.intellij.images.options.impl.ZoomOptionsImpl"}, {"methodBody": ["METHOD_START", "{", "ImageTagManager . State . Files   files    =    myState . myTags . get ( tag )  ;", "if    ( files    =  =    null )     {", "files    =    new   ImageTagManager . State . Files (  )  ;", "myState . myTags . put ( tag ,    files )  ;", "}", "files . add ( file . getPath (  )  )  ;", "}", "METHOD_END"], "methodName": ["addTag"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "return   new   ArrayList <  >  ( myState . myTags . keySet (  )  )  ;", "}", "METHOD_END"], "methodName": ["getAllTags"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    ImageTagManager . class )  ;", "}", "METHOD_END"], "methodName": ["getInstance"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "return   myState . myTags . keySet (  )  . stream (  )  . filter (  (    tag )     -  >    hasTag ( tag ,    file )  )  . collect ( Collectors . toList (  )  )  ;", "}", "METHOD_END"], "methodName": ["getTags"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "ImageTagManager . State . Files   files    =    myState . myTags . get ( tag )  ;", "return    ( files    !  =    null )     &  &     ( files . contains ( file . getPath (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["hasTag"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "ImageTagManager . State . Files   files    =    myState . myTags . get ( tag )  ;", "if    ( files    !  =    null )     {", "files . remove ( file . getPath (  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["removeTag"], "fileName": "org.intellij.images.search.ImageTagManager"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ! editor )     &  &     (  ! frame )  )", "return   Collections . emptySet (  )  ;", "if    ( editor    &  &    frame )", "return   com . intellij . util . containers . ContainerUtil . newHashSet (  . EDITOR ,     . FRAME )  ;", "return   Collections . singleton (  ( editor    ?     . EDITOR    :     . FRAME )  )  ;", "}", "METHOD_END"], "methodName": ["usageSet"], "fileName": "org.intellij.images.statistics.BackgroundImagesUsageCollector"}, {"methodBody": ["METHOD_START", "{", "return   ServiceManager . getService ( project ,    ThumbnailManager . class )  ;", "}", "METHOD_END"], "methodName": ["getManager"], "fileName": "org.intellij.images.thumbnail.ThumbnailManager"}, {"methodBody": ["METHOD_START", "{", "return   ThumbnailView . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "}", "METHOD_END"], "methodName": ["getThumbnailView"], "fileName": "org.intellij.images.thumbnail.actionSystem.ThumbnailViewActionUtil"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   thumbnailView    =    ThumbnailViewActionUtil . getThumbnailView ( e )  ;", "if    (  ( thumbnailView    !  =    null )     &  &     ( thumbnailView . isVisible (  )  )  )     {", "return   thumbnailView ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getVisibleThumbnailView"], "fileName": "org.intellij.images.thumbnail.actionSystem.ThumbnailViewActionUtil"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   thumbnailView    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "Presentation   presentation    =    e . getPresentation (  )  ;", "presentation . setEnabled (  ( thumbnailView    !  =    null )  )  ;", "return   presentation . isEnabled (  )  ;", "}", "METHOD_END"], "methodName": ["setEnabled"], "fileName": "org.intellij.images.thumbnail.actionSystem.ThumbnailViewActionUtil"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "if    ( view    !  =    null )     {", "VirtualFile [  ]    selection    =    view . getSelection (  )  ;", "if    (  (  ( selection . length )     =  =     1  )     &  &     ( selection [  0  ]  . isDirectory (  )  )  )     {", "view . setRoot ( selection [  0  ]  )  ;", "} else", "if    (  ( selection . length )     >     0  )     {", "com . intellij . openapi . fileEditor . FileEditorManager   fileEditorManager    =    com . intellij . openapi . fileEditor . FileEditorManager . getInstance ( view . getProject (  )  )  ;", "fileTypes . ImageFileTypeManager   typeManager    =    fileTypes . ImageFileTypeManager . getInstance (  )  ;", "for    ( VirtualFile   file    :    selection )     {", "if    ( typeManager . isImage ( file )  )     {", "fileEditorManager . openFile ( file ,    false )  ;", "}", "}", "}", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.thumbnail.actions.EnterAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "if    ( TViewActionUtil . setEnabled ( e )  )     {", "Presentation   presentation    =    e . getPresentation (  )  ;", "TView   view    =    TViewActionUtil . getVisibleTView ( e )  ;", "VirtualFile [  ]    selection    =    view . getSelection (  )  ;", "if    (  ( selection . length )     >     0  )     {", "if    (  (  ( selection . length )     =  =     1  )     &  &     ( selection [  0  ]  . isDirectory (  )  )  )     {", "presentation . setVisible ( true )  ;", "} else    {", "boolean   notImages    =    false ;", "ImageFileTypeManager   typeManager    =    ImageFileTypeManager . getInstance (  )  ;", "for    ( VirtualFile   file    :    selection )     {", "notImages    |  =     !  ( typeManager . isImage ( file )  )  ;", "}", "presentation . setEnabled (  (  ! notImages )  )  ;", "presentation . setVisible ( false )  ;", "}", "} else    {", "presentation . setVisible ( false )  ;", "presentation . setEnabled ( false )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.EnterAction"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    e . getProject (  )  ;", "if    ( project    =  =    null )     {", "e . getPresentation (  )  . setEnabledAndVisible ( false )  ;", "return ;", "}", "TView   view    =    TViewActionUtil . getVisibleTView ( e )  ;", "ImageTagManager   tagManager    =    ImageTagManager . getInstance ( project )  ;", "e . getPresentation (  )  . setVisible (  (  ( view    !  =    null )     &  &     (  !  ( tagManager . getAllTags (  )  . isEmpty (  )  )  )  )  )  ;", "TagFilter [  ]    filters    =     ( view    !  =    null )     ?    view . getTagFilters (  )     :    null ;", "e . getPresentation (  )  . setText (  ( filters    =  =    null    ?     \" All \"     :    StringUtil . join ( filters ,     (    filter )     -  >    filter . getDisplayName (  )  ,     \"  ,  \"  )  )  )  ;", "e . getPresentation (  )  . setIcon ( SendToTheRight )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.FilterByTagActionGroup"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    e . getProject (  )  ;", "TView   view    =    TViewActionUtil . getVisibleTView ( e )  ;", "boolean   hasApplicableExtension    =    Arrays . stream ( ThemeFilter . EP _ NAME . getExtensions (  )  )  . allMatch (  (    filter )     -  >     ( project    !  =    null )     &  &     ( filter . isApplicableToProject ( project )  )  )  ;", "e . getPresentation (  )  . setVisible (  (  ( view    !  =    null )     &  &    hasApplicableExtension )  )  ;", "ThemeFilter   filter    =     ( view    !  =    null )     ?    view . getFilter (  )     :    null ;", "e . getPresentation (  )  . setText (  ( filter    =  =    null    ?     \" All \"     :    filter . getDisplayName (  )  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.FilterByThemeComboBoxAction"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "if    ( view    !  =    null )     {", "view . setVisible ( false )  ;", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.thumbnail.actions.HideThumbnailsAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "ViewActionUtil . setEnabled ( e )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.HideThumbnailsAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "return    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     &  &     ( decorator . isVisible (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileNameAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "if    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     {", "decorator . setVisible ( state )  ;", "OptionsManager . getInstance (  )  . getOptions (  )  . getEditorOptions (  )  . setVisible ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileNameAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "e . getPresentation (  )  . setEnabled (  (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForPlace ( e . getPlace (  )  )  )  )  )  ;", "e . getPresentation (  )  . setText (  ( isSelected ( e )     ?     \" Hide   File   Name \"     :     \" Show   File   Name \"  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileNameAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "return    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     &  &     ( decorator . isVisible (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileSizeAction"}, {"methodBody": ["METHOD_START", "{", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "if    (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForActionPlace ( e . getPlace (  )  )  )  )     {", "decorator . setVisible ( state )  ;", "OptionsManager . getInstance (  )  . getOptions (  )  . getEditorOptions (  )  . setVisible ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileSizeAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "ImageComponentDecorator   decorator    =    ImageComponentDecorator . DATA _ KEY . getData ( e . getDataContext (  )  )  ;", "e . getPresentation (  )  . setEnabled (  (  ( decorator    !  =    null )     &  &     ( decorator . isEnabledForPlace ( e . getPlace (  )  )  )  )  )  ;", "e . getPresentation (  )  . setText (  ( isSelected ( e )     ?     \" Hide   File   Size \"     :     \" Show   File   Size \"  )  )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.ToggleFileSizeAction"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "return    ( view    !  =    null )     &  &     ( view . is (  )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleRecursiveAction"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "if    ( view    !  =    null )     {", "view . set ( state )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleRecursiveAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "TViewActionUtil . setEnabled ( e )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.ToggleRecursiveAction"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    e . getProject (  )  ;", "return    ( project    !  =    null )     &  &     ( PropertiesComponent . getInstance ( project )  . getBoolean (  . TAGS _ PANEL _ VISIBLE ,    false )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleTagsPanelAction"}, {"methodBody": ["METHOD_START", "{", "PropertiesComponent . getInstance ( e . getProject (  )  )  . setValue ( ToggleTagsPanelAction . TAGS _ PANEL _ VISIBLE ,    state )  ;", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "assert   view    !  =    null ;", "view . refresh (  )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.actions.ToggleTagsPanelAction"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "e . getPresentation (  )  . setEnabledAndVisible (  ( view    !  =    null )  )  ;", "e . getPresentation (  )  . setText (  ( isSelected ( e )     ?     \" Hide   Tags   Panel \"     :     \" Show   Tags   Panel \"  )  )  ;", "super . update ( e )  ;", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.ToggleTagsPanelAction"}, {"methodBody": ["METHOD_START", "{", "ThumbnailView   view    =    ThumbnailViewActionUtil . getVisibleThumbnailView ( e )  ;", "if    ( view    !  =    null )     {", "VirtualFile   root    =    view . getRoot (  )  ;", "if    ( root    !  =    null )     {", "VirtualFile   parent    =    root . getParent (  )  ;", "if    ( parent    !  =    null )     {", "view . setRoot ( parent )  ;", "}", "}", "}", "}", "METHOD_END"], "methodName": ["actionPerformed"], "fileName": "org.intellij.images.thumbnail.actions.UpFolderAction"}, {"methodBody": ["METHOD_START", "{", "super . update ( e )  ;", "if    ( TViewActionUtil . setEnabled ( e )  )     {", "TView   view    =    TViewActionUtil . getVisibleTView ( e )  ;", "VirtualFile   root    =    view . getRoot (  )  ;", "e . getPresentation (  )  . setEnabled (  (  (  ( root    !  =    null )     &  &     (  ( root . getParent (  )  )     !  =    null )  )     &  &     (  !  ( view . isRecursive (  )  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["update"], "fileName": "org.intellij.images.thumbnail.actions.UpFolderAction"}, {"methodBody": ["METHOD_START", "{", "if    (  ( thumbnailView )     !  =    null )     {", "thumbnailView . dispose (  )  ;", "thumbnailView    =    null ;", "}", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailManagerImpl"}, {"methodBody": ["METHOD_START", "{", "if    (  ( thumbnailView )     =  =    null )     {", "thumbnailView    =    new   ThumbnailViewImpl ( project )  ;", "}", "return   thumbnailView ;", "}", "METHOD_END"], "methodName": ["getThumbnailView"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailManagerImpl"}, {"methodBody": ["METHOD_START", "{", "return   ThumbnailView . TOOLWINDOW _ ID ;", "}", "METHOD_END"], "methodName": ["getToolWindowId"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailSelectInTarget"}, {"methodBody": ["METHOD_START", "{", "return    1  0  ;", "}", "METHOD_END"], "methodName": ["getWeight"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailSelectInTarget"}, {"methodBody": ["METHOD_START", "{", "return   getToolWindowId (  )  ;", "}", "METHOD_END"], "methodName": ["toString"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailSelectInTarget"}, {"methodBody": ["METHOD_START", "{", "if    (  ( isVisible (  )  )     &  &     (  !  ( toolWindow . isActive (  )  )  )  )     {", "toolWindow . activate ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["activate"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "Disposer . dispose ( getUI (  )  )  ;", "ToolWindowManager   windowManager    =    ToolWindowManager . getInstance ( project )  ;", "windowManager . unregisterToolWindow (  . TOOLWINDOW _ ID )  ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return   project ;", "}", "METHOD_END"], "methodName": ["getProject"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return   root ;", "}", "METHOD_END"], "methodName": ["getRoot"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isVisible (  )  )     {", "return   getUI (  )  . getSelection (  )  ;", "}", "return   VirtualFile . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return   myThubmnailViewUi ;", "}", "METHOD_END"], "methodName": ["getUI"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( isVisible (  )  )     &  &     (  !  ( ImageEditorActions . ACTION _ PLACE . equals ( place )  )  )  ;", "}", "METHOD_END"], "methodName": ["isEnabledForActionPlace"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return   recursive ;", "}", "METHOD_END"], "methodName": ["isRecursive"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( isVisible (  )  )     &  &     ( getUI (  )  . isSelected ( file )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return    ( isVisible (  )  )     &  &     ( getUI (  )  . isTransparencyChessboardVisible (  )  )  ;", "}", "METHOD_END"], "methodName": ["isTransparencyChessboardVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "return   toolWindow . isAvailable (  )  ;", "}", "METHOD_END"], "methodName": ["isVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isVisible (  )  )     {", "if    (  !  ( toolWindow . isActive (  )  )  )     {", "toolWindow . activate ( new    . LazyScroller (  )  )  ;", "} else    {", "getUI (  )  . scrollToSelection (  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["scrollToSelection"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "this . recursive    =    recursive ;", "updateUI (  )  ;", "}", "METHOD_END"], "methodName": ["setRecursive"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "this . root    =    root ;", "updateUI (  )  ;", "}", "METHOD_END"], "methodName": ["setRoot"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isVisible (  )  )     {", "getUI (  )  . setSelected ( file ,    selected )  ;", "}", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "toolWindow . setTitle (  (  ( root )     !  =    null    ?    IfsUtil . getReferencePath ( project ,    root )     :    null )  )  ;", "}", "METHOD_END"], "methodName": ["setTitle"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isVisible (  )  )     {", "getUI (  )  . setTransparencyChessboardVisible ( visible )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "toolWindow . setAvailable ( visible ,    null )  ;", "if    ( visible )     {", "setTitle (  )  ;", "getUI (  )  . refresh (  )  ;", "} else    {", "getUI (  )  . dispose (  )  ;", "}", "}", "METHOD_END"], "methodName": ["setVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "if    ( isVisible (  )  )     {", "setTitle (  )  ;", "getUI (  )  . refresh (  )  ;", "}", "}", "METHOD_END"], "methodName": ["updateUI"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewImpl"}, {"methodBody": ["METHOD_START", "{", "listModel    =    new   DefaultListModel <  >  (  )  ;", "updateTagsPreviewModel (  )  ;", "JBList < String >    tagsList    =    new   JBList ( listModel )  ;", "tagsList . setEmptyText (  \" No   tags   defined \"  )  ;", "ImageTagManager   imageTagManager    =    ImageTagManager . getInstance ( thumbnailView . getProject (  )  )  ;", "return   ToolbarDecorator . createDecorator ( tagsList )  . setAddAction ( new   AnActionButtonRunnable (  )     {", "@ Override", "public   void   run ( AnActionButton   button )     {", "JBPopupFactory . getInstance (  )  . createActionGroupPopup (  \" Add   Tags \"  ,    new    . AddTagGroup (  )  ,    button . getDataContext (  )  ,    SPEEDSEARCH ,    false )  . show ( button . getPreferredPopupPoint (  )  )  ;", "}", "}  )  . setRemoveAction ( new   AnActionButtonRunnable (  )     {", "@ Override", "public   void   run ( AnActionButton   button )     {", "String   selectedValue    =    tagsList . getSelectedValue (  )  ;", "if    ( selectedValue    !  =    null )     {", "Arrays . stream ( getSelection (  )  )  . forEach (  (    virtualFile )     -  >    imageTagManager . removeTag ( selectedValue ,    virtualFile )  )  ;", "}", "updateTagsPreviewModel (  )  ;", "}", "}  )  . disableUpDownActions (  )  . setToolbarPosition ( RIGHT )  . createPanel (  )  ;", "}", "METHOD_END"], "methodName": ["createTagPreviewPanel"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "if    (  (  ( cellRenderer )     =  =    null )     |  |     (  ( list )     =  =    null )  )     {", "cellRenderer    =    new    . ThumbnailListCellRenderer (  )  ;", "ImageComponent   imageComponent    =    cellRenderer . getImageComponent (  )  ;", "VirtualFileManager . getInstance (  )  . addVirtualFileListener ( vfsListener )  ;", "Options   options    =    OptionsManager . getInstance (  )  . getOptions (  )  ;", "EditorOptions   editorOptions    =    options . getEditorOptions (  )  ;", "TransparencyChessboardOptions   chessboardOptions    =    editorOptions . getTransparencyChessboardOptions (  )  ;", "imageComponent . setTransparencyChessboardVisible ( chessboardOptions . isShowDefault (  )  )  ;", "imageComponent . setTransparencyChessboardCellSize ( chessboardOptions . getCellSize (  )  )  ;", "imageComponent . setTransparencyChessboardWhiteColor ( chessboardOptions . getWhiteColor (  )  )  ;", "imageComponent . setTransparencyChessboardBlankColor ( chessboardOptions . getBlackColor (  )  )  ;", "imageComponent . setFileNameVisible ( editorOptions . isFileNameVisible (  )  )  ;", "imageComponent . setFileSizeVisible ( editorOptions . isFileSizeVisible (  )  )  ;", "options . addPropertyChangeListener ( optionsListener )  ;", "list    =    new   JBList (  )  ;", "list . setModel ( new   DefaultListModel (  )  )  ;", "list . setLayoutOrientation ( JList . HORIZONTAL _ WRAP )  ;", "list . setVisibleRowCount (  (  -  1  )  )  ;", "list . setCellRenderer ( cellRenderer )  ;", "list . setSelectionMode ( ListSelectionModel . MULTIPLE _ INTERVAL _ SELECTION )  ;", "list . addListSelectionListener (  (    e )     -  >    updateTagsPreviewModel (  )  )  ;", ". ThumbnailsMouseAdapter   mouseListener    =    new    . ThumbnailsMouseAdapter (  )  ;", "list . addMouseListener ( mouseListener )  ;", "list . addMouseMotionListener ( mouseListener )  ;", "ThumbnailComponentUI   componentUI    =     (  ( ThumbnailComponentUI )     ( UIManager . getUI ( cellRenderer )  )  )  ;", "Dimension   preferredSize    =    componentUI . getPreferredSize ( cellRenderer )  ;", "list . setFixedCellWidth ( preferredSize . width )  ;", "list . setFixedCellHeight ( preferredSize . height )  ;", "JScrollPane   scrollPane    =    ScrollPaneFactory . createScrollPane ( list ,    ScrollPaneConstants . VERTICAL _ SCROLLBAR _ AS _ NEEDED ,    ScrollPaneConstants . HORIZONTAL _ SCROLLBAR _ NEVER )  ;", "scrollPane . setBorder ( IdeBorderFactory . createBorder ( TOP )  )  ;", "ActionManager   actionManager    =    ActionManager . getInstance (  )  ;", "ActionGroup   actionGroup    =     (  ( ActionGroup )     ( actionManager . getAction ( ThumbnailViewActions . GROUP _ TOOLBAR )  )  )  ;", "ActionToolbar   actionToolbar    =    actionManager . createActionToolbar ( ThumbnailViewActions . ACTION _ PLACE ,    actionGroup ,    true )  ;", "actionToolbar . setTargetComponent ( this )  ;", "JComponent   toolbar    =    actionToolbar . getComponent (  )  ;", ". FocusRequester   focusRequester    =    new    . FocusRequester (  )  ;", "toolbar . addMouseListener ( focusRequester )  ;", "scrollPane . addMouseListener ( focusRequester )  ;", "add ( toolbar ,    BorderLayout . NORTH )  ;", "previewSplitter    =    new   Splitter (  )  ;", "previewSplitter . setFirstComponent ( scrollPane )  ;", "previewSplitter . setProportion (  1  )  ;", "previewSplitter . setSecondComponent ( null )  ;", "add ( previewSplitter ,    BorderLayout . CENTER )  ;", "}", "updateTagsPreview (  )  ;", "}", "METHOD_END"], "methodName": ["createUI"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "removeAll (  )  ;", "Options   options    =    OptionsManr . getInstance (  )  . getOptions (  )  ;", "options . removePropertyChangeListener ( optionsListener )  ;", "VirtualFileManr . getInstance (  )  . removeVirtualFileListener ( vfsListener )  ;", "list    =    null ;", "cellRenderer    =    null ;", "tagsPanel    =    null ;", "}", "METHOD_END"], "methodName": ["dispose"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "Set < VirtualFile >    files    =    new   HashSet <  >  (  0  )  ;", "Project   project    =    t . getProject (  )  ;", "if    (  !  ( project . isDisposed (  )  )  )     {", "ProjectRootManager   rootManager    =    ProjectRootManager . getInstance ( project )  ;", "boolean   projectIgnored    =    rootManager . getFileIndex (  )  . isExcluded ( file )  ;", "if    (  (  ! projectIgnored )     &  &     (  !  ( FileTypeManager . getInstance (  )  . isFileIgnored ( file )  )  )  )     {", "ImageFileTypeManager   typeManager    =    ImageFileTypeManager . getInstance (  )  ;", "if    ( file . isDirectory (  )  )     {", "if    ( t . isRecursive (  )  )     {", "files . addAll ( findFiles ( file . getChildren (  )  )  )  ;", "} else", "if    ( isImagesInDirectory ( file )  )     {", "files . add ( file )  ;", "}", "} else", "if    ( typeManager . isImage ( file )  )     {", "files . add ( file )  ;", "}", "}", "}", "return   files ;", "}", "METHOD_END"], "methodName": ["findFiles"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "Set < VirtualFile >    fil =    new   HashSet <  >  (  )  ;", "for    ( VirtualFile   root    :    roots )     {", "filaddAll ( findFilroot )  )  ;", "}", "return   fil", "}", "METHOD_END"], "methodName": ["findFiles"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "if    ( PROJECT . is ( dataId )  )     {", "return   thumbnailView . getProject (  )  ;", "} else", "if    ( CommonDataKeys . VIRTUAL _ FILE . is ( dataId )  )     {", "VirtualFile [  ]    selectedFiles    =    getSelectedFiles (  )  ;", "return    ( selectedFiles . length )     >     0     ?    selectedFiles [  0  ]     :    null ;", "} else", "if    ( CommonDataKeys . VIRTUAL _ FILE _ ARRAY . is ( dataId )  )     {", "return   getSelectedFiles (  )  ;", "} else", "if    ( CommonDataKeys . PSI _ FILE . is ( dataId )  )     {", "return   getData ( CommonDataKeys . PSI _ ELEMENT . getName (  )  )  ;", "} else", "if    ( CommonDataKeys . PSI _ ELEMENT . is ( dataId )  )     {", "VirtualFile [  ]    selectedFiles    =    getSelectedFiles (  )  ;", "return    ( selectedFiles . length )     >     0     ?    com . intellij . psi . PsiManager . getInstance ( thumbnailView . getProject (  )  )  . findFile ( selectedFiles [  0  ]  )     :    null ;", "} else", "if    ( LangDataKeys . PSI _ ELEMENT _ ARRAY . is ( dataId )  )     {", "return   getSelectedElements (  )  ;", "} else", "if    ( CommonDataKeys . NAVIGATABLE . is ( dataId )  )     {", "VirtualFile [  ]    selectedFiles    =    getSelectedFiles (  )  ;", "return   new   ThumbnailViewUI . ThumbnailNavigatable (  (  ( selectedFiles . length )     >     0     ?    selectedFiles [  0  ]     :    null )  )  ;", "} else", "if    ( PlatformDataKeys . COPY _ PROVIDER . is ( dataId )  )     {", "return   copyPasteSupport . getCopyProvider (  )  ;", "} else", "if    ( PlatformDataKeys . CUT _ PROVIDER . is ( dataId )  )     {", "return   copyPasteSupport . getCutProvider (  )  ;", "} else", "if    ( PlatformDataKeys . PASTE _ PROVIDER . is ( dataId )  )     {", "return   copyPasteSupport . getPasteProvider (  )  ;", "} else", "if    ( PlatformDataKeys . DELETE _ ELEMENT _ PROVIDER . is ( dataId )  )     {", "return   deleteProvider ;", "} else", "if    ( CommonDataKeys . NAVIGATABLE _ ARRAY . is ( dataId )  )     {", "VirtualFile [  ]    selectedFiles    =    getSelectedFiles (  )  ;", "Set < com . intellij . pom . Navigatable >    navigatables    =    new   HashSet ( selectedFiles . length )  ;", "for    ( VirtualFile   selectedFile    :    selectedFiles )     {", "if    (  !  ( selectedFile . isDirectory (  )  )  )     {", "navigatables . add ( new   ThumbnailViewUI . ThumbnailNavigatable ( selectedFile )  )  ;", "}", "}", "return   navigatables . toArray ( ThumbnailViewUI . EMPTY _ NAVIGATABLE _ ARRAY )  ;", "} else", "if    ( ThumbnailView . DATA _ KEY . is ( dataId )  )     {", "return   thumbnailView ;", "} else", "if    ( is ( dataId )  )     {", "return   thumbnailView ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getData"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "VirtualFile [  ]    selectedFiles    =    getSelectedFiles (  )  ;", "Set < PsiElement >    psiElements    =    new   HashSet ( selectedFiles . length )  ;", "PsiManager   psiManager    =    PsiManager . getInstance ( t . getProject (  )  )  ;", "for    ( VirtualFile   file    :    selectedFiles )     {", "PsiFile   psiFile    =    psiManager . findFile ( file )  ;", "PsiElement   element    =     ( psiFile    !  =    null )     ?    psiFile    :    psiManager . findDirectory ( file )  ;", "if    ( element    !  =    null )     {", "psiElements . add ( element )  ;", "}", "}", "return   PsiUtilCore . toPsiElementArray ( psiElements )  ;", "}", "METHOD_END"], "methodName": ["getSelectedElements"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "if    (  ( list )     !  =    null )     {", "Object [  ]    selectedValu =    list . getSelectedValu )  ;", "if    ( selectedValu !  =    null )     {", "VirtualFile [  ]    fil =    new   VirtualFile [ selectedValulength ]  ;", "for    ( int   i    =     0  ;    i    <     ( selectedValulength )  ;    i +  +  )     {", "fili ]     =     (  ( VirtualFile )     ( selectedValui ]  )  )  ;", "}", "return   fil", "}", "}", "return   VirtualFile . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getSelectedFiles"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "if    (  ( list )     !  =    null )     {", "Object [  ]    selectedValu =    list . getSelectedValu )  ;", "if    ( selectedValu !  =    null )     {", "VirtualFile [  ]    fil =    new   VirtualFile [ selectedValulength ]  ;", "for    ( int   i    =     0  ;    i    <     ( selectedValulength )  ;    i +  +  )     {", "fili ]     =     (  ( VirtualFile )     ( selectedValui ]  )  )  ;", "}", "return   fil", "}", "}", "return   VirtualFile . EMPTY _ ARRAY ;", "}", "METHOD_END"], "methodName": ["getSelection"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "return   cellRenderer . getIComponent (  )  . isFileNameVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isFileNameVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "return   cellRenderer . getIComponent (  )  . isFileSizeVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isFileSizeVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "ImageFileTypeManager   typeManager    =    ImageFileTypeManager . getInstance (  )  ;", "VirtualFile [  ]    files    =    dir . getChildren (  )  ;", "for    ( VirtualFile   file    :    files )     {", "if    ( file . isDirectory (  )  )     {", "return   true ;", "}", "if    ( typeManager . isImage ( file )  )     {", "return   true ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["isImagesInDirectory"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "int   index    =     (  ( DefaultListModel )     ( list . getModel (  )  )  )  . indexOf ( file )  ;", "return    ( index    !  =     (  -  1  )  )     &  &     ( list . isSelectedIndex ( index )  )  ;", "}", "METHOD_END"], "methodName": ["isSelected"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "return   cellRenderer . getIComponent (  )  . isTransparencyChessboardVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isTransparencyChessboardVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "if    (  ( list )     !  =    null )     {", "DefaultListModel   model    =     (  ( DefaultListModel )     ( list . getModel (  )  )  )  ;", "model . clear (  )  ;", "VirtualFile   root    =    thumbnailView . getRoot (  )  ;", "if    (  (  ( root    !  =    null )     &  &     ( root . isValid (  )  )  )     &  &     ( root . isDirectory (  )  )  )     {", "Set < VirtualFile >    files    =    findFiles ( root . getChildren (  )  )  ;", "VirtualFile [  ]    virtualFiles    =    VfsUtilCore . toVirtualFileArray ( files )  ;", "Arrays . sort ( virtualFiles ,     . VIRTUAL _ FILE _ COMPARATOR )  ;", "model . ensureCapacity (  (  (  ( model . size (  )  )     +     ( virtualFiles . length )  )     +     1  )  )  ;", "ThemeFilter   filter    =    thumbnailView . getFilter (  )  ;", "TagFilter [  ]    tagFilters    =    thumbnailView . getTagFilters (  )  ;", "for    ( VirtualFile   virtualFile    :    virtualFiles )     {", "if    (  ( filter    =  =    null )     |  |     ( filter . accepts ( virtualFile )  )  )     {", "if    (  ( tagFilters    =  =    null )     |  |     ( Arrays . stream ( tagFilters )  . anyMatch (  (    tagFilter )     -  >    tagFilter . accepts ( virtualFile )  )  )  )     {", "model . addElement ( virtualFile )  ;", "}", "}", "}", "if    (  ( model . size (  )  )     >     0  )     {", "list . setSelectedIndex (  0  )  ;", "}", "} else    {", "thumbnailView . setVisible ( false )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["refresh"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "int   minSelectionIndex    =    list . getMinSelectionIndex (  )  ;", "int   maxSelectionIndex    =    list . getMaxSelectionIndex (  )  ;", "if    (  ( minSelectionIndex    !  =     (  -  1  )  )     &  &     ( maxSelectionIndex    !  =     (  -  1  )  )  )     {", "list . scrollRectToVisible ( list . getCellBounds ( minSelectionIndex ,    maxSelectionIndex )  )  ;", "}", "}", "METHOD_END"], "methodName": ["scrollToSelection"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "cellRenderer . getIComponent (  )  . setFileNameVisible ( visible )  ;", "list . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setFileNameVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "cellRenderer . getIComponent (  )  . setFileSizeVisible ( visible )  ;", "list . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setFileSizeVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "list . setSelectedValue ( file ,    false )  ;", "}", "METHOD_END"], "methodName": ["setSelected"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "createUI (  )  ;", "cellRenderer . getIComponent (  )  . setTransparencyChessboardVisible ( visible )  ;", "list . repaint (  )  ;", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardVisible"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "Project   project    =    thumbnailView . getProject (  )  ;", "boolean   enabled    =    PropertiesComponent . getInstance ( project )  . getBoolean ( ToggleTagsPanelAction . TAGS _ PANEL _ VISIBLE ,    false )  ;", "float   splitterProportion    =    previewSplitter . getProportion (  )  ;", "if    ( enabled )     {", "if    ( splitterProportion    =  =     1  )     {", "previewSplitter . setProportion ( Float . valueOf ( PropertiesComponent . getInstance ( project )  . getValue ( ToggleTagsPanelAction . TAGS _ PANEL _ PROPORTION ,     \"  0  .  5 f \"  )  )  )  ;", "}", "if    (  ( tagsPanel )     =  =    null )     {", "tagsPanel    =    createTagPreviewPanel (  )  ;", "}", "previewSplitter . setSecondComponent ( tagsPanel )  ;", "} else    {", "if    ( splitterProportion    !  =     1  )     {", "PropertiesComponent . getInstance ( thumbnailView . getProject (  )  )  . setValue ( ToggleTagsPanelAction . TAGS _ PANEL _ PROPORTION ,    String . valueOf ( splitterProportion )  )  ;", "}", "previewSplitter . setProportion (  1  )  ;", "previewSplitter . setSecondComponent ( null )  ;", "}", "}", "METHOD_END"], "methodName": ["updateTagsPreview"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "if    (  ( listModel )     =  =    null )", "return ;", "listModel . clear (  )  ;", "VirtualFile [  ]    selection    =    getSelection (  )  ;", "ImageTagManager   tagManager    =    ImageTagManager . getInstance ( t . getProject (  )  )  ;", "List < String >    commonTags    =    null ;", "for    ( VirtualFile   virtualFile    :    selection )     {", "List < String >    tags    =    tagManager . getTags ( virtualFile )  ;", "if    ( commonTags    =  =    null )     {", "commonTags    =    new   ArrayList <  >  ( tags )  ;", "} else    {", "commonTags . retainAll ( tags )  ;", "}", "}", "if    ( commonTags    !  =    null )     {", "commonTags . forEach ( listModel :  : addElement )  ;", "}", "}", "METHOD_END"], "methodName": ["updateTagsPreviewModel"], "fileName": "org.intellij.images.thumbnail.impl.ThumbnailViewUI"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    getSize (  )  ;", "return   new   Dimension (  (  ( size . width )     -     (  (  . IMAGE _ INSETS )     *     2  )  )  ,     (  ( size . height )     -     (  (  . IMAGE _ INSETS )     *     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["getCanvasSize"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "BufferedImage   image    =    getDocument (  )  . getValue (  )  ;", "if    ( image    !  =    null )     {", "return   ImagesBundle . message (  \" icon . dimensions \"  ,    image . getWidth (  )  ,    image . getHeight (  )  ,    image . getColorModel (  )  . getPixelSize (  )  )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   document ;", "}", "METHOD_END"], "methodName": ["getDocument"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   grid . getLineColor (  )  ;", "}", "METHOD_END"], "methodName": ["getGridLineColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   grid . getLineSpan (  )  ;", "}", "METHOD_END"], "methodName": ["getGridLineSpan"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   grid . getLineZoomFactor (  )  ;", "}", "METHOD_END"], "methodName": ["getGridLineZoomFactor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   chessboard . getBlackColor (  )  ;", "}", "METHOD_END"], "methodName": ["getTransparencyChessboardBlackColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   chessboard . getCellSize (  )  ;", "}", "METHOD_END"], "methodName": ["getTransparencyChessboardCellSize"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   chessboard . getWhiteColor (  )  ;", "}", "METHOD_END"], "methodName": ["getTransparencyChessboardWhiteColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   ImageComponent . uiClassID ;", "}", "METHOD_END"], "methodName": ["getUIClassID"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   zoomFactor ;", "}", "METHOD_END"], "methodName": ["getZoomFactor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   myFileNameVisible ;", "}", "METHOD_END"], "methodName": ["isFileNameVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   myFileSizeVisible ;", "}", "METHOD_END"], "methodName": ["isFileSizeVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   grid . isVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isGridVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   chessboard . isVisible (  )  ;", "}", "METHOD_END"], "methodName": ["isTransparencyChessboardVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "setSize (  ( width    +     (  ( ImageComponent . IMAGE _ INSETS )     *     2  )  )  ,     ( height    +     (  ( ImageComponent . IMAGE _ INSETS )     *     2  )  )  )  ;", "}", "METHOD_END"], "methodName": ["setCanvasSize"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "setCanvasSize ( dimension . width ,    dimension . height )  ;", "}", "METHOD_END"], "methodName": ["setCanvasSize"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    myFileNameVisible ;", "myFileNameVisible    =    fileNameVisible ;", "firePropertyChange (  . FILE _ NAME _ VISIBLE _ PROP ,    oldValue ,    fileNameVisible )  ;", "}", "METHOD_END"], "methodName": ["setFileNameVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    myFileSizeVisible ;", "myFileSizeVisible    =    fileSizeVisible ;", "firePropertyChange (  . FILE _ SIZE _ VISIBLE _ PROP ,    oldValue ,    fileSizeVisible )  ;", "}", "METHOD_END"], "methodName": ["setFileSizeVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "Color   oldValue    =    grid . getLineColor (  )  ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( color )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( color    !  =    null )  )  )     {", "grid . setLineColor ( color )  ;", "firePropertyChange (  . GRID _ LINE _ COLOR _ PROP ,    oldValue ,    color )  ;", "}", "}", "METHOD_END"], "methodName": ["setGridLineColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    grid . getLineSpan (  )  ;", "if    ( oldValue    !  =    lineSpan )     {", "grid . setLineSpan ( lineSpan )  ;", "firePropertyChange (  . GRID _ LINE _ SPAN _ PROP ,    oldValue ,    lineSpan )  ;", "}", "}", "METHOD_END"], "methodName": ["setGridLineSpan"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    grid . getLineZoomFactor (  )  ;", "if    ( oldValue    !  =    lineZoomFactor )     {", "grid . setLineZoomFactor ( lineZoomFactor )  ;", "firePropertyChange (  . GRID _ LINE _ ZOOM _ FACTOR _ PROP ,    oldValue ,    lineZoomFactor )  ;", "}", "}", "METHOD_END"], "methodName": ["setGridLineZoomFactor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    grid . isVisible (  )  ;", "if    ( oldValue    !  =    visible )     {", "grid . setVisible ( visible )  ;", "firePropertyChange (  . GRID _ VISIBLE _ PROP ,    oldValue ,    visible )  ;", "}", "}", "METHOD_END"], "methodName": ["setGridVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "Color   oldValue    =    chessboard . getBlackColor (  )  ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( color )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( color    !  =    null )  )  )     {", "chessboard . setBlackColor ( color )  ;", "firePropertyChange (  . TRANSPARENCY _ CHESSBOARD _ BLACK _ COLOR _ PROP ,    oldValue ,    color )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardBlankColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    chessboard . getCellSize (  )  ;", "if    ( oldValue    !  =    cellSize )     {", "chessboard . setCellSize ( cellSize )  ;", "firePropertyChange (  . TRANSPARENCY _ CHESSBOARD _ CELL _ SIZE _ PROP ,    oldValue ,    cellSize )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardCellSize"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    chessboard . isVisible (  )  ;", "if    ( oldValue    !  =    visible )     {", "chessboard . setVisible ( visible )  ;", "firePropertyChange (  . TRANSPARENCY _ CHESSBOARD _ VISIBLE _ PROP ,    oldValue ,    visible )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardVisible"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "Color   oldValue    =    chessboard . getWhiteColor (  )  ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( color )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( color    !  =    null )  )  )     {", "chessboard . setWhiteColor ( color )  ;", "firePropertyChange (  . TRANSPARENCY _ CHESSBOARD _ WHITE _ COLOR _ PROP ,    oldValue ,    color )  ;", "}", "}", "METHOD_END"], "methodName": ["setTransparencyChessboardWhiteColor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "this . zoomFactor    =    zoomFactor ;", "}", "METHOD_END"], "methodName": ["setZoomFactor"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "setUI ( UIManager . getUI ( this )  )  ;", "}", "METHOD_END"], "methodName": ["updateUI"], "fileName": "org.intellij.images.ui.ImageComponent"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isFileNameVisible"], "fileName": "org.intellij.images.ui.ImageComponentDecorator"}, {"methodBody": ["METHOD_START", "{", "return   true ;", "}", "METHOD_END"], "methodName": ["isFileSizeVisible"], "fileName": "org.intellij.images.ui.ImageComponentDecorator"}, {"methodBody": ["METHOD_START", "{", "return   new   ImageComponentUI ( c )  ;", "}", "METHOD_END"], "methodName": ["createUI"], "fileName": "org.intellij.images.ui.ImageComponentUI"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    ic . getSize (  )  ;", "g . setColor ( ic . getTransparencyChessboardBlackColor (  )  )  ;", "g . drawRect (  0  ,     0  ,     (  ( size . width )     -     1  )  ,     (  ( size . height )     -     1  )  )  ;", "}", "METHOD_END"], "methodName": ["paintBorder"], "fileName": "org.intellij.images.ui.ImageComponentUI"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    ic . getCanvasSize (  )  ;", "int   cellSize    =    ic . getTransparencyChessboardCellSize (  )  ;", "int   patternSize    =     2     *    cellSize ;", "if    (  ( pattern )     =  =    null )     {", "pattern    =    UIUtil . create ( g ,    patternSize ,    patternSize ,    Buffered . TYPE _ INT _ ARGB )  ;", "Graphics   imageGraphics    =    pattern . getGraphics (  )  ;", "imageGraphics . setColor ( ic . getTransparencyChessboardWhiteColor (  )  )  ;", "imageGraphics . fillRect (  0  ,     0  ,    patternSize ,    patternSize )  ;", "imageGraphics . setColor ( ic . getTransparencyChessboardBlackColor (  )  )  ;", "imageGraphics . fillRect (  0  ,    cellSize ,    cellSize ,    cellSize )  ;", "imageGraphics . fillRect ( cellSize ,     0  ,    cellSize ,    cellSize )  ;", "}", "(  ( Graphics 2 D )     ( g )  )  . setPaint ( new   TexturePaint ( pattern ,    new   Rectangle (  0  ,     0  ,    patternSize ,    patternSize )  )  )  ;", "g . fillRect (  0  ,     0  ,    size . width ,    size . height )  ;", "}", "METHOD_END"], "methodName": ["paintChessboard"], "fileName": "org.intellij.images.ui.ImageComponentUI"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    ic . getCanvasSize (  )  ;", "BufferedImage       =    ic . getDocument (  )  . getValue (  )  ;", "int   Width    =     . getWidth (  )  ;", "int   Height    =     . getHeight (  )  ;", "double   zoomX    =     (  ( double )     ( size . width )  )     /     (  ( double )     ( Width )  )  ;", "double   zoomY    =     (  ( double )     ( size . height )  )     /     (  ( double )     ( Height )  )  ;", "double   zoomFactor    =     ( zoomX    +    zoomY )     /     2  .  0  ;", "if    ( zoomFactor    >  =     ( ic . getGridLineZoomFactor (  )  )  )     {", "g . setColor ( ic . getGridLineColor (  )  )  ;", "int   ls    =    ic . getGridLineSpan (  )  ;", "for    ( int   dx    =    ls ;    dx    <    Width ;    dx    +  =    ls )     {", "UIUtil . drawLine ( g ,     (  ( int )     (  (  ( double )     ( dx )  )     *    zoomX )  )  ,     0  ,     (  ( int )     (  (  ( double )     ( dx )  )     *    zoomX )  )  ,    size . height )  ;", "}", "for    ( int   dy    =    ls ;    dy    <    Height ;    dy    +  =    ls )     {", "UIUtil . drawLine ( g ,     0  ,     (  ( int )     (  (  ( double )     ( dy )  )     *    zoomY )  )  ,    size . width ,     (  ( int )     (  (  ( double )     ( dy )  )     *    zoomY )  )  )  ;", "}", "}", "}", "METHOD_END"], "methodName": ["paintGrid"], "fileName": "org.intellij.images.ui.ImageComponentUI"}, {"methodBody": ["METHOD_START", "{", "ImageDocument   document    =    ic . getDocument (  )  ;", "Dimension   size    =    ic . getCanvasSize (  )  ;", "Graphics 2 D   g 2 d    =     (  ( Graphics 2 D )     ( g )  )  ;", "RenderingHints   oldHints    =    g 2 d . getRenderingHints (  )  ;", "BufferedImage   image    =    document . getValue ( ic . getZoomFactor (  )  )  ;", "Image   renderer    =    image ;", "if    (  (  ( size . width )     >     ( image . getWidth (  )  )  )     &  &     (  ( size . height )     >     ( image . getHeight (  )  )  )  )     {", "g 2 d . setRenderingHint ( RenderingHints . KEY _ ANTIALIASING ,    RenderingHints . VALUE _ ANTIALIAS _ OFF )  ;", "g 2 d . setRenderingHint ( RenderingHints . KEY _ INTERPOLATION ,    RenderingHints . VALUE _ INTERPOLATION _ NEAREST _ NEIGHBOR )  ;", "} else    {", "g 2 d . setRenderingHint ( RenderingHints . KEY _ ANTIALIASING ,    RenderingHints . VALUE _ ANTIALIAS _ ON )  ;", "g 2 d . setRenderingHint ( RenderingHints . KEY _ INTERPOLATION ,    RenderingHints . VALUE _ INTERPOLATION _ BILINEAR )  ;", "}", "UIUtil . drawImage ( g ,    renderer ,    new   Rectangle (  0  ,     0  ,    size . width ,    size . height )  ,    ic )  ;", "g 2 d . setRenderingHints ( oldHints )  ;", "}", "METHOD_END"], "methodName": ["paintImage"], "fileName": "org.intellij.images.ui.ImageComponentUI"}, {"methodBody": ["METHOD_START", "{", "return   fileName ;", "}", "METHOD_END"], "methodName": ["getFileName"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   fileSize ;", "}", "METHOD_END"], "methodName": ["getFileSize"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   StringUtil . formatFileSize ( fileSize )  ;", "}", "METHOD_END"], "methodName": ["getFileSizeText"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   format ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   imageComponent ;", "}", "METHOD_END"], "methodName": ["getImageComponent"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   imagesCount ;", "}", "METHOD_END"], "methodName": ["getImagesCount"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   ThumbnailComponent . uiClassID ;", "}", "METHOD_END"], "methodName": ["getUIClassID"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   directory ;", "}", "METHOD_END"], "methodName": ["isDirectory"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "boolean   oldValue    =    this . directory ;", "if    ( oldValue    !  =    directory )     {", "this . directory    =    directory ;", "firePropertyChange (  . DIRECTORY _ PROP ,    oldValue ,    this . directory )  ;", "}", "}", "METHOD_END"], "methodName": ["setDirectory"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "String   oldValue    =    this . fileName ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( fileName )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( fileName    !  =    null )  )  )     {", "this . fileName    =    fileName ;", "firePropertyChange (  . FILE _ NAME _ PROP ,    oldValue ,    this . fileName )  ;", "}", "}", "METHOD_END"], "methodName": ["setFileName"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "long   oldValue    =    this . fileSize ;", "if    ( oldValue    !  =    fileSize )     {", "this . fileSize    =    fileSize ;", "firePropertyChange (  . FILE _ SIZE _ PROP ,    new   Long ( oldValue )  ,    new   Long ( this . fileSize )  )  ;", "}", "}", "METHOD_END"], "methodName": ["setFileSize"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "String   oldValue    =    this . format ;", "if    (  (  ( oldValue    !  =    null )     &  &     (  !  ( oldValue . equals ( format )  )  )  )     |  |     (  ( oldValue    =  =    null )     &  &     ( format    !  =    null )  )  )     {", "this . format    =    format ;", "firePropertyChange (  . FORMAT _ PROP ,    oldValue ,    this . format )  ;", "}", "}", "METHOD_END"], "methodName": ["setFormat"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "int   oldValue    =    this . imagesCount ;", "if    ( oldValue    !  =    imagesCount )     {", "this . imagesCount    =    imagesCount ;", "firePropertyChange (  . IMAGES _ COUNT _ PROP ,    oldValue ,    this . imagesCount )  ;", "}", "}", "METHOD_END"], "methodName": ["setImagesCount"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "setUI ( UIManager . getUI ( this )  )  ;", "}", "METHOD_END"], "methodName": ["updateUI"], "fileName": "org.intellij.images.ui.ThumbnailComponent"}, {"methodBody": ["METHOD_START", "{", "return   ThumbnailComponentUI . ui ;", "}", "METHOD_END"], "methodName": ["createUI"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "if    (  \" PNG \"  . equals ( format )  )     {", "return    . PNG _ COLOR ;", "} else", "if    (  \" GIF \"  . equals ( format )  )     {", "return    . GIF _ COLOR ;", "} else", "if    (  (  \" JPG \"  . equals ( format )  )     |  |     (  \" JPEG \"  . equals ( format )  )  )     {", "return    . JPG _ COLOR ;", "} else", "if    (  (  \" BMP \"  . equals ( format )  )     |  |     (  \" WBMP \"  . equals ( format )  )  )     {", "return    . BMP _ COLOR ;", "}", "return   Color . BLACK ;", "}", "METHOD_END"], "methodName": ["getFormatColor"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   labelFont    =    UIUtil . getLabelFont (  )  ;", "FontMetrics   fontMetrics    =    c . getFontMetrics ( labelFont )  ;", "return   new   Dimension (  (  ( ImagesIconsBlank . getIconWidth (  )  )     +     1  0  )  ,     (  (  ( ImagesIconsBlank . getIconHeight (  )  )     +     ( fontMetrics . getHeight (  )  )  )     +     1  5  )  )  ;", "}", "METHOD_END"], "methodName": ["getPreferredSize"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   labelFont    =    UIUtil . getLabelFont (  )  ;", "return   labelFont . deriveFont (  (  ( labelFont . getSize 2 D (  )  )     -     2  .  0 F )  )  ;", "}", "METHOD_END"], "methodName": ["getSmallFont"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "return   UIManager . getString ( ThumbnailComponentUI . THUMBNAIL _ COMPONENT _ ERROR _ STRING )  ;", "}", "METHOD_END"], "methodName": ["getSubmnailComponentErrorString"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "ThumbnailComponent   tc    =     (  ( ThumbnailComponent )     ( c )  )  ;", "if    ( tc    !  =    null )     {", "UISettings . setupAntialiasing ( g )  ;", "paintBackground ( g ,    tc )  ;", "if    ( tc . isDirectory (  )  )     {", "paintDirectory ( g ,    tc )  ;", "} else    {", "paintImageThumbnail ( g ,    tc )  ;", "}", "if    (  ( tc . isDirectory (  )  )     |  |     ( tc . getImageComponent (  )  . isFileNameVisible (  )  )  )", "paintFileName ( g ,    tc )  ;", "}", "}", "METHOD_END"], "methodName": ["paint"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Dimension   size    =    tc . getSize (  )  ;", "g . setColor ( tc . getBackground (  )  )  ;", "g . fillRect (  0  ,     0  ,    size . width ,    size . height )  ;", "}", "METHOD_END"], "methodName": ["paintBackground"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "ImagesIcons . ThumbnailDirectory . paintIcon ( tc ,    g ,     5  ,     5  )  ;", "int   imagesCount    =    tc . getImagesCount (  )  ;", "if    ( imagesCount    >     0  )     {", "final   String   title    =    ImagesBundle . message (  \" icons . count \"  ,    imagesCount )  ;", "Font   font    =     . getSmallFont (  )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "g . setColor ( Color . BLACK )  ;", "g . setFont ( font )  ;", "g . drawString ( title ,     (  5     +     (  (  ( ImagesIcons . ThumbnailDirectory . getIconWidth (  )  )     -     ( fontMetrics . stringWidth ( title )  )  )     /     2  )  )  ,     (  (  ( ImagesIcons . ThumbnailDirectory . getIconHeight (  )  )     /     2  )     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["paintDirectory"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   font    =    ThumbnailComponentUI . getSmallFont (  )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "Messages . getErrorIcon (  )  . paintIcon ( tc ,    g ,     (  5     +     (  (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     ( Messages . getErrorIcon (  )  . getIconWidth (  )  )  )     /     2  )  )  ,     (  5     +     (  (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     -     ( Messages . getErrorIcon (  )  . getIconHeight (  )  )  )     /     2  )  )  )  ;", "String   error    =    getSubmnailComponentErrorString (  )  ;", "g . setColor ( RED )  ;", "g . setFont ( font )  ;", "g . drawString ( error ,     8  ,     (  8     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paintError"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   font    =    UIUtil . getLabelFont (  )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "g . setFont ( font )  ;", "g . setColor ( tc . getForeground (  )  )  ;", "String   fileName    =    tc . getFileName (  )  ;", "String   title    =    fileName ;", "while    (  ( fontMetrics . stringWidth ( title )  )     >     (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     8  )  )     {", "title    =    title . substring (  0  ,     (  ( title . length (  )  )     -     1  )  )  ;", "}", "if    ( fileName . equals ( title )  )     {", "g . drawString ( fileName ,     (  6     +     (  (  (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     2  )     -     ( fontMetrics . stringWidth ( title )  )  )     /     2  )  )  ,     (  (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     +     8  )     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "} else    {", "int   dotsWidth    =    fontMetrics . stringWidth (  . DOTS )  ;", "while    (  ( fontMetrics . stringWidth ( title )  )     >     (  (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     8  )     -    dotsWidth )  )     {", "title    =    title . substring (  0  ,     (  ( title . length (  )  )     -     1  )  )  ;", "}", "g . drawString (  ( title    +     (  . DOTS )  )  ,     6  ,     (  (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     +     8  )     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "}", "}", "METHOD_END"], "methodName": ["paintFileName"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   font    =    ThumbnailComponentUI . getSmallFont (  )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "g . setColor ( Color . BLACK )  ;", "g . setFont ( font )  ;", "g . drawString ( tc . getFileSizeText (  )  ,     8  ,     (  (  (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     +     4  )     -     ( fontMetrics . getHeight (  )  )  )     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "}", "METHOD_END"], "methodName": ["paintFileSize"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "Font   font    =    ThumbnailComponentUI . getSmallFont (  )  . deriveFont ( Font . BOLD )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "String   format    =    tc . getFormat (  )  . toUpperCase (  )  ;", "int   stringWidth    =    fontMetrics . stringWidth ( format )  ;", "int   x    =     (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -    stringWidth )     +     2  ;", "int   y    =     (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     -     ( fontMetrics . getHeight (  )  )  )     +     4  ;", "g . setColor ( ThumbnailComponentUI . LINE _ COLOR )  ;", "g . drawLine (  ( x    -     3  )  ,     ( y    -     1  )  ,     (  ( x    +    stringWidth )     +     1  )  ,     ( y    -     1  )  )  ;", "g . drawLine (  ( x    -     4  )  ,    y ,     ( x    -     4  )  ,     (  ( y    +     ( fontMetrics . getHeight (  )  )  )     -     1  )  )  ;", "g . setColor ( getFormatColor ( format )  )  ;", "g . setFont ( font )  ;", "g . drawString ( format ,    x ,     ( y    +     ( fontMetrics . getAscent (  )  )  )  )  ;", "return   fontMetrics . getHeight (  )  ;", "}", "METHOD_END"], "methodName": ["paintFormatText"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "ImageComponent   imageComponent    =    tc . getImageComponent (  )  ;", "int   blankHeight    =    ImagesIconsBlank . getIconHeight (  )  ;", "if    ( imageComponent . isFileSizeVisible (  )  )     {", "blankHeight    -  =    paintImageCaps ( g ,    imageComponent )  ;", "blankHeight    -  =    paintFormatText ( tc ,    g )  ;", "}", "pain ( g ,    imageComponent ,    blankHeight )  ;", "}", "METHOD_END"], "methodName": ["paintImage"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "String   description    =    imageComponent . getDescription (  )  ;", "Font   font    =     . getSmallFont (  )  ;", "FontMetrics   fontMetrics    =    g . getFontMetrics ( font )  ;", "g . setColor ( Color . BLACK )  ;", "g . setFont ( font )  ;", "g . drawString ( description ,     8  ,     (  7     +     ( fontMetrics . getAscent (  )  )  )  )  ;", "return   fontMetrics . getHeight (  )  ;", "}", "METHOD_END"], "methodName": ["paintImageCaps"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "ImageComponent   imageComponent    =    tc . getImageComponent (  )  ;", "if    ( imageComponent . isFileSizeVisible (  )  )", "icons . ImagesIconsBlank . paintIcon ( tc ,    g ,     5  ,     5  )  ;", "ImageDocument   document    =    imageComponent . getDocument (  )  ;", "BufferedImage   image    =    document . getValue (  )  ;", "if    ( image    !  =    null )     {", "paintImage ( g ,    tc )  ;", "} else    {", "paintError ( g ,    tc )  ;", "}", "if    ( imageComponent . isFileSizeVisible (  )  )", "paintFileSize ( g ,    tc )  ;", "}", "METHOD_END"], "methodName": ["paintImageThumbnail"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "int   maxWidth    =     ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     1  0  ;", "int   maxHeight    =    blankHeight    -     1  0  ;", "BufferedImage   image    =    imageComponent . getDocument (  )  . getValue (  )  ;", "int   imageWidth    =    image . getWidth (  )  ;", "int   imageHeight    =    image . getHeight (  )  ;", "if    (  ( imageWidth    >    maxWidth )     |  |     ( imageHeight    >    maxHeight )  )     {", "if    ( imageWidth    >    maxWidth )     {", "double   proportion    =     (  ( double )     ( maxWidth )  )     /     (  ( double )     ( imageWidth )  )  ;", "imageWidth    =    maxWidth ;", "imageHeight    =     (  ( int )     (  (  ( double )     ( imageHeight )  )     *    proportion )  )  ;", "}", "if    ( imageHeight    >    maxHeight )     {", "double   proportion    =     (  ( double )     ( maxHeight )  )     /     (  ( double )     ( imageHeight )  )  ;", "imageHeight    =    maxHeight ;", "imageWidth    =     (  ( int )     (  (  ( double )     ( imageWidth )  )     *    proportion )  )  ;", "}", "}", "imageComponent . setCanvasSize ( imageWidth ,    imageHeight )  ;", "Dimension   size    =    imageComponent . getSize (  )  ;", "int   x    =     5     +     (  (  ( ImagesIcons . ThumbnailBlank . getIconWidth (  )  )     -     ( size . width )  )     /     2  )  ;", "int   y    =     5     +     (  (  ( ImagesIcons . ThumbnailBlank . getIconHeight (  )  )     -     ( size . height )  )     /     2  )  ;", "imageComponent . paint ( g . create ( x ,    y ,    size . width ,    size . height )  )  ;", "}", "METHOD_END"], "methodName": ["paintThumbnail"], "fileName": "org.intellij.images.ui.ThumbnailComponentUI"}, {"methodBody": ["METHOD_START", "{", "return   ImageInfoReader . read ( new   ByteArrayInputStream ( data )  )  ;", "}", "METHOD_END"], "methodName": ["getInfo"], "fileName": "org.intellij.images.util.ImageInfoReader"}, {"methodBody": ["METHOD_START", "{", "return   ImageInfoReader . read ( new   File ( file )  )  ;", "}", "METHOD_END"], "methodName": ["getInfo"], "fileName": "org.intellij.images.util.ImageInfoReader"}, {"methodBody": ["METHOD_START", "{", "try    ( ImageInputStream   iis    =    ImageIO . createImageInputStream ( input )  )     {", "Iterator < ImageReader >    it    =    ImageIO . getImageReaders ( iis )  ;", "ImageReader   reader    =     ( it . hasNext (  )  )     ?    it . next (  )     :    null ;", "if    ( reader    !  =    null )     {", "reader . setInput ( iis ,    true )  ;", "int   w    =    reader . getWidth (  0  )  ;", "int   h    =    reader . getHeight (  0  )  ;", "Iterator < ImageTypeSpecifier >    it 2     =    reader . getImageTypes (  0  )  ;", "int   bpp    =     (  ( it 2     !  =    null )     &  &     ( it 2  . hasNext (  )  )  )     ?    it 2  . next (  )  . getColorModel (  )  . getPixelSize (  )     :     -  1  ;", "return   new    . Info ( w ,    h ,    bpp )  ;", "}", "}    catch    ( Exception   e )     {", ". LOG . warn ( e )  ;", "}", "return   null ;", "}", "METHOD_END"], "methodName": ["read"], "fileName": "org.intellij.images.util.ImageInfoReader"}, {"methodBody": ["METHOD_START", "{", "if    (  !  ( input   instanceof   ImageInputStream )  )     {", "return   false ;", "}", "final   ImageInputStream   stream    =     (  ( ImageInputStream )     ( input )  )  ;", "try    {", "final   ImageFormat   imageFormat    =    Imaging . guessFormat ( new    . MyByteSource ( stream )  )  ;", "if    ( myFormats . contains ( imageFormat )  )     {", "myFormat . set ( imageFormat )  ;", "return   true ;", "}", "return   false ;", "}    catch    ( ImageReadException   e )     {", "throw   new   IOException ( e )  ;", "}", "}", "METHOD_END"], "methodName": ["canDecodeInput"], "fileName": "org.intellij.images.util.imageio.CommonsImagingImageReaderSpi"}, {"methodBody": ["METHOD_START", "{", "return   new   CommonsImagingImageReaderSpi . MyImageReader ( this ,    myFormat . get (  )  )  ;", "}", "METHOD_END"], "methodName": ["createReaderInstance"], "fileName": "org.intellij.images.util.imageio.CommonsImagingImageReaderSpi"}, {"methodBody": ["METHOD_START", "{", "return    \" Apache   Commons   Imaging   adapter   reader \"  ;", "}", "METHOD_END"], "methodName": ["getDescription"], "fileName": "org.intellij.images.util.imageio.CommonsImagingImageReaderSpi"}, {"methodBody": ["METHOD_START", "{", "IfsUtil . refresh ( file )  ;", "return   file . getUserData ( IfsUtil . FORMAT _ KEY )  ;", "}", "METHOD_END"], "methodName": ["getFormat"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "ImageDocument . ScaledImageProvider   imageProvider    =    IfsUtil . getImageProvider ( file )  ;", "if    ( imageProvider    =  =    null )", "return   null ;", "return   imageProvider . apply (  1  .  0  )  ;", "}", "METHOD_END"], "methodName": ["getImage"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "IfsUtil . refresh ( file )  ;", "SoftReference < ImageDocument . ScaledImageProvider >    imageProviderRef    =    file . getUserData ( IfsUtil . IMAGE _ PROVIDER _ REF _ KEY )  ;", "return   SoftReference . dereference ( imageProviderRef )  ;", "}", "METHOD_END"], "methodName": ["getImageProvider"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "final   LogicalRoot   logicalRoot    =    LogicalRootsManager . getLogicalRootsManager ( project )  . findLogicalRoot ( file )  ;", "if    ( logicalRoot    !  =    null )     {", "return    . getRelativePath ( file ,    logicalRoot . getVirtualFile (  )  )  ;", "}", "ProjectFileIndex   fileIndex    =    ProjectRootManager . getInstance ( project )  . getFileIndex (  )  ;", "VirtualFile   sourceRoot    =    fileIndex . getSourceRootForFile ( file )  ;", "if    ( sourceRoot    !  =    null )     {", "return    . getRelativePath ( file ,    sourceRoot )  ;", "}", "VirtualFile   root    =    fileIndex . getContentRootForFile ( file )  ;", "if    ( root    !  =    null )     {", "return    . getRelativePath ( file ,    root )  ;", "}", "return   file . getPath (  )  ;", "}", "METHOD_END"], "methodName": ["getReferencePath"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "if    ( root . equals ( file )  )     {", "return   file . getPath (  )  ;", "}", "return    \"  /  \"     +     ( VCore . getRelativePath ( file ,    root ,     '  /  '  )  )  ;", "}", "METHOD_END"], "methodName": ["getRelativePath"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "return   IfsUtil . SVG _ FORMAT . equalsIgnoreCase ( file . getExtension (  )  )  ;", "}", "METHOD_END"], "methodName": ["isScalableImage"], "fileName": "org.intellij.images.vfs.IfsUtil"}, {"methodBody": ["METHOD_START", "{", "Long   loadedTimeStamp    =    file . getUserData ( IfsUtil . TIMESTAMP _ KEY )  ;", "SoftReference < ImageDocument . ScaledImageProvider >    imageProviderRef    =    file . getUserData ( IfsUtil . IMAGE _ PROVIDER _ REF _ KEY )  ;", "if    (  (  ( loadedTimeStamp    =  =    null )     |  |     (  ( loadedTimeStamp . longValue (  )  )     !  =     ( file . getTimeStamp (  )  )  )  )     |  |     (  ( SoftReference . dereference ( imageProviderRef )  )     =  =    null )  )     {", "try    {", "final   byte [  ]    content    =    file . contentsToByteArray (  )  ;", "if    ( IfsUtil . ICO _ FORMAT . equalsIgnoreCase ( file . getExtension (  )  )  )     {", "try    {", "final   BufferedImage   image    =    IfsUtil . ICO _ IMAGE _ PARSER . getBufferedImage ( new   ByteSourceArray ( content )  ,    null )  ;", "file . putUserData ( IfsUtil . FORMAT _ KEY ,    IfsUtil . ICO _ FORMAT )  ;", "file . putUserData ( IfsUtil . IMAGE _ PROVIDER _ REF _ KEY ,    new   SoftReference (  (    zoom )     -  >    image )  )  ;", "return   true ;", "}    catch    ( ImageReadException   ignore )     {", "}", "}", "if    ( IfsUtil . isScalableImage ( file )  )     {", "SVGLoader . load ( null ,    new   ByteArrayInputStream ( content )  ,     1  .  0 F )  ;", "file . putUserData ( IfsUtil . FORMAT _ KEY ,    IfsUtil . SVG _ FORMAT )  ;", "file . putUserData ( IfsUtil . IMAGE _ PROVIDER _ REF _ KEY ,    new   SoftReference (  (    zoom )     -  >     {", "try    {", "return    (  ( BufferedImage )     ( SVGLoader . load ( null ,    new   ByteArrayInputStream ( content )  ,    zoom . floatValue (  )  )  )  )  ;", "}    catch    (    e )     {", "return   UIUtil . createImage (  0  ,     0  ,    BufferedImage . TYPE _ INT _ ARGB )  ;", "}", "}  )  )  ;", "return   true ;", "}", "InputStream   inputStream    =    new   ByteArrayInputStream ( content ,     0  ,    content . length )  ;", "ImageInputStream   imageInputStream    =    ImageIO . createImageInputStream ( inputStream )  ;", "try    {", "Iterator < ImageReader >    imageReaders    =    ImageIO . getImageReaders ( imageInputStream )  ;", "if    ( imageReaders . hasNext (  )  )     {", "ImageReader   imageReader    =    imageReaders . next (  )  ;", "try    {", "file . putUserData ( IfsUtil . FORMAT _ KEY ,    imageReader . getFormatName (  )  )  ;", "ImageReadParam   param    =    imageReader . getDefaultReadParam (  )  ;", "imageReader . setInput ( imageInputStream ,    true ,    true )  ;", "int   minIndex    =    imageReader . getMinIndex (  )  ;", "BufferedImage   image    =    imageReader . read ( minIndex ,    param )  ;", "file . putUserData ( IfsUtil . IMAGE _ PROVIDER _ REF _ KEY ,    new   SoftReference (  (    zoom )     -  >    image )  )  ;", "return   true ;", "}    finally    {", "imageReader . dispose (  )  ;", "}", "}", "}    finally    {", "imageInputStream . close (  )  ;", "}", "}    finally    {", "file . putUserData ( IfsUtil . TIMESTAMP _ KEY ,    file . getTimeStamp (  )  )  ;", "}", "}", "return   false ;", "}", "METHOD_END"], "methodName": ["refresh"], "fileName": "org.intellij.images.vfs.IfsUtil"}]